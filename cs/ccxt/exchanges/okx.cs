namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class okx : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "okx" },
            { "name", "OKX" },
            { "countries", new List<object>() {"CN", "US"} },
            { "version", "v5" },
            { "rateLimit", multiply(100, 1.03) },
            { "pro", true },
            { "certified", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", true },
                { "option", true },
                { "addMargin", true },
                { "cancelAllOrders", false },
                { "cancelAllOrdersAfter", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "cancelOrdersForSymbols", true },
                { "closeAllPositions", false },
                { "closePosition", true },
                { "createConvertTrade", true },
                { "createDepositAddress", false },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketSellOrderWithCost", true },
                { "createOrder", true },
                { "createOrders", true },
                { "createOrderWithTakeProfitAndStopLoss", true },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", true },
                { "createStopLossOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "createTakeProfitOrder", true },
                { "createTrailingPercentOrder", true },
                { "createTriggerOrder", true },
                { "editOrder", true },
                { "fetchAccounts", true },
                { "fetchAllGreeks", true },
                { "fetchBalance", true },
                { "fetchBidsAsks", null },
                { "fetchBorrowInterest", true },
                { "fetchBorrowRateHistories", true },
                { "fetchBorrowRateHistory", true },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrder", null },
                { "fetchClosedOrders", true },
                { "fetchConvertCurrencies", true },
                { "fetchConvertQuote", true },
                { "fetchConvertTrade", true },
                { "fetchConvertTradeHistory", true },
                { "fetchCrossBorrowRate", true },
                { "fetchCrossBorrowRates", true },
                { "fetchCurrencies", true },
                { "fetchDeposit", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", true },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", false },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", true },
                { "fetchFundingInterval", true },
                { "fetchFundingIntervals", false },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchGreeks", true },
                { "fetchIndexOHLCV", true },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchL3OrderBook", false },
                { "fetchLedger", true },
                { "fetchLedgerEntry", null },
                { "fetchLeverage", true },
                { "fetchLeverageTiers", false },
                { "fetchLongShortRatio", false },
                { "fetchLongShortRatioHistory", true },
                { "fetchMarginAdjustmentHistory", true },
                { "fetchMarketLeverageTiers", true },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMarkPrice", true },
                { "fetchMarkPrices", true },
                { "fetchMySettlementHistory", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenInterestHistory", true },
                { "fetchOpenInterests", true },
                { "fetchOpenOrder", null },
                { "fetchOpenOrders", true },
                { "fetchOption", true },
                { "fetchOptionChain", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", false },
                { "fetchOrders", false },
                { "fetchOrderTrades", true },
                { "fetchPosition", true },
                { "fetchPositionHistory", "emulated" },
                { "fetchPositions", true },
                { "fetchPositionsForSymbol", true },
                { "fetchPositionsHistory", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchSettlementHistory", true },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchTradingLimits", false },
                { "fetchTransactionFee", false },
                { "fetchTransactionFees", false },
                { "fetchTransactions", false },
                { "fetchTransfer", true },
                { "fetchTransfers", true },
                { "fetchUnderlyingAssets", true },
                { "fetchVolatilityHistory", false },
                { "fetchWithdrawal", true },
                { "fetchWithdrawals", true },
                { "fetchWithdrawalWhitelist", false },
                { "reduceMargin", true },
                { "repayCrossMargin", true },
                { "sandbox", true },
                { "setLeverage", true },
                { "setMargin", false },
                { "setMarginMode", true },
                { "setPositionMode", true },
                { "signIn", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1H" },
                { "2h", "2H" },
                { "4h", "4H" },
                { "6h", "6H" },
                { "12h", "12H" },
                { "1d", "1D" },
                { "1w", "1W" },
                { "1M", "1M" },
                { "3M", "3M" },
            } },
            { "hostname", "www.okx.com" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/152485636-38b19e4a-bece-4dec-979a-5982859ffc04.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "rest", "https://{hostname}" },
                } },
                { "www", "https://www.okx.com" },
                { "doc", "https://www.okx.com/docs-v5/en/" },
                { "fees", "https://www.okx.com/pages/products/fees.html" },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://www.okx.com/join/CCXT2023" },
                    { "discount", 0.2 },
                } },
                { "test", new Dictionary<string, object>() {
                    { "rest", "https://{hostname}" },
                } },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "market/books-full", 2 },
                        { "market/tickers", 1 },
                        { "market/ticker", 1 },
                        { "market/index-tickers", 1 },
                        { "market/books", divide(1, 2) },
                        { "market/books-lite", divide(5, 3) },
                        { "market/candles", divide(1, 2) },
                        { "market/history-candles", 1 },
                        { "market/index-candles", 1 },
                        { "market/history-index-candles", 2 },
                        { "market/mark-price-candles", 1 },
                        { "market/history-mark-price-candles", 2 },
                        { "market/trades", divide(1, 5) },
                        { "market/history-trades", 2 },
                        { "market/option/instrument-family-trades", 1 },
                        { "market/platform-24-volume", 10 },
                        { "market/open-oracle", 50 },
                        { "market/exchange-rate", 20 },
                        { "market/index-components", 1 },
                        { "public/market-data-history", 4 },
                        { "public/economic-calendar", 50 },
                        { "market/block-tickers", 1 },
                        { "market/block-ticker", 1 },
                        { "public/block-trades", 1 },
                        { "public/instruments", 1 },
                        { "public/delivery-exercise-history", divide(1, 2) },
                        { "public/open-interest", 1 },
                        { "public/funding-rate", 1 },
                        { "public/funding-rate-history", 1 },
                        { "public/price-limit", 1 },
                        { "public/opt-summary", 1 },
                        { "public/estimated-price", 2 },
                        { "public/discount-rate-interest-free-quota", 10 },
                        { "public/time", 2 },
                        { "public/mark-price", 2 },
                        { "public/position-tiers", 2 },
                        { "public/interest-rate-loan-quota", 10 },
                        { "public/vip-interest-rate-loan-quota", 10 },
                        { "public/underlying", 1 },
                        { "public/insurance-fund", 2 },
                        { "public/convert-contract-coin", 2 },
                        { "public/option-trades", 1 },
                        { "public/instrument-tick-bands", 4 },
                        { "rubik/stat/trading-data/support-coin", 4 },
                        { "rubik/stat/taker-volume", 4 },
                        { "rubik/stat/margin/loan-ratio", 4 },
                        { "rubik/stat/contracts/long-short-account-ratio", 4 },
                        { "rubik/stat/contracts/long-short-account-ratio-contract", 4 },
                        { "rubik/stat/contracts/open-interest-volume", 4 },
                        { "rubik/stat/option/open-interest-volume", 4 },
                        { "rubik/stat/option/open-interest-volume-ratio", 4 },
                        { "rubik/stat/option/open-interest-volume-expiry", 4 },
                        { "rubik/stat/option/open-interest-volume-strike", 4 },
                        { "rubik/stat/option/taker-block-volume", 4 },
                        { "system/status", 50 },
                        { "sprd/spreads", 1 },
                        { "sprd/books", divide(1, 2) },
                        { "sprd/ticker", 1 },
                        { "sprd/public-trades", divide(1, 5) },
                        { "market/sprd-ticker", 2 },
                        { "market/sprd-candles", 2 },
                        { "market/sprd-history-candles", 2 },
                        { "tradingBot/grid/ai-param", 1 },
                        { "tradingBot/grid/min-investment", 1 },
                        { "tradingBot/public/rsi-back-testing", 1 },
                        { "asset/exchange-list", divide(5, 3) },
                        { "finance/staking-defi/eth/apy-history", divide(5, 3) },
                        { "finance/staking-defi/sol/apy-history", divide(5, 3) },
                        { "finance/savings/lending-rate-summary", divide(5, 3) },
                        { "finance/savings/lending-rate-history", divide(5, 3) },
                        { "finance/fixed-loan/lending-offers", divide(10, 3) },
                        { "finance/fixed-loan/lending-apy-history", divide(10, 3) },
                        { "finance/fixed-loan/pending-lending-volume", divide(10, 3) },
                        { "finance/sfp/dcd/products", divide(2, 3) },
                        { "copytrading/public-lead-traders", 4 },
                        { "copytrading/public-weekly-pnl", 4 },
                        { "copytrading/public-stats", 4 },
                        { "copytrading/public-preference-currency", 4 },
                        { "copytrading/public-current-subpositions", 4 },
                        { "copytrading/public-subpositions-history", 4 },
                        { "support/announcements-types", 20 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "rfq/counterparties", 4 },
                        { "rfq/maker-instrument-settings", 4 },
                        { "rfq/mmp-config", 4 },
                        { "rfq/rfqs", 10 },
                        { "rfq/quotes", 10 },
                        { "rfq/trades", 4 },
                        { "rfq/public-trades", 4 },
                        { "sprd/order", divide(1, 3) },
                        { "sprd/orders-pending", divide(1, 3) },
                        { "sprd/orders-history", divide(1, 2) },
                        { "sprd/orders-history-archive", divide(1, 2) },
                        { "sprd/trades", divide(1, 3) },
                        { "trade/order", divide(1, 3) },
                        { "trade/orders-pending", divide(1, 3) },
                        { "trade/orders-history", divide(1, 2) },
                        { "trade/orders-history-archive", 1 },
                        { "trade/fills", divide(1, 3) },
                        { "trade/fills-history", 2.2 },
                        { "trade/fills-archive", 2 },
                        { "trade/order-algo", 1 },
                        { "trade/orders-algo-pending", 1 },
                        { "trade/orders-algo-history", 1 },
                        { "trade/easy-convert-currency-list", 20 },
                        { "trade/easy-convert-history", 20 },
                        { "trade/one-click-repay-currency-list", 20 },
                        { "trade/one-click-repay-currency-list-v2", 20 },
                        { "trade/one-click-repay-history", 20 },
                        { "trade/one-click-repay-history-v2", 20 },
                        { "trade/account-rate-limit", 1 },
                        { "asset/currencies", divide(5, 3) },
                        { "asset/balances", divide(5, 3) },
                        { "asset/non-tradable-assets", divide(5, 3) },
                        { "asset/asset-valuation", 10 },
                        { "asset/transfer-state", 10 },
                        { "asset/bills", divide(5, 3) },
                        { "asset/deposit-lightning", 5 },
                        { "asset/deposit-address", divide(5, 3) },
                        { "asset/deposit-history", divide(5, 3) },
                        { "asset/withdrawal-history", divide(5, 3) },
                        { "asset/deposit-withdraw-status", 20 },
                        { "asset/convert/currencies", divide(5, 3) },
                        { "asset/convert/currency-pair", divide(5, 3) },
                        { "asset/convert/history", divide(5, 3) },
                        { "asset/monthly-statement", 2 },
                        { "account/instruments", 1 },
                        { "account/balance", 2 },
                        { "account/positions", 2 },
                        { "account/positions-history", 100 },
                        { "account/account-position-risk", 2 },
                        { "account/bills", divide(5, 3) },
                        { "account/bills-archive", divide(5, 3) },
                        { "account/bills-history-archive", 2 },
                        { "account/config", 4 },
                        { "account/max-size", 1 },
                        { "account/max-avail-size", 1 },
                        { "account/leverage-info", 1 },
                        { "account/adjust-leverage-info", 4 },
                        { "account/max-loan", 1 },
                        { "account/trade-fee", 4 },
                        { "account/interest-accrued", 4 },
                        { "account/interest-rate", 4 },
                        { "account/max-withdrawal", 1 },
                        { "account/risk-state", 2 },
                        { "account/quick-margin-borrow-repay-history", 4 },
                        { "account/borrow-repay-history", 4 },
                        { "account/vip-interest-accrued", 4 },
                        { "account/vip-interest-deducted", 4 },
                        { "account/vip-loan-order-list", 4 },
                        { "account/vip-loan-order-detail", 4 },
                        { "account/interest-limits", 4 },
                        { "account/greeks", 2 },
                        { "account/position-tiers", 2 },
                        { "account/mmp-config", 4 },
                        { "account/fixed-loan/borrowing-limit", 4 },
                        { "account/fixed-loan/borrowing-quote", 5 },
                        { "account/fixed-loan/borrowing-orders-list", 5 },
                        { "account/spot-manual-borrow-repay", 30 },
                        { "account/set-auto-repay", 4 },
                        { "account/spot-borrow-repay-history", 4 },
                        { "account/move-positions-history", 10 },
                        { "users/subaccount/list", 10 },
                        { "account/subaccount/balances", divide(10, 3) },
                        { "asset/subaccount/balances", divide(10, 3) },
                        { "account/subaccount/max-withdrawal", 1 },
                        { "asset/subaccount/bills", divide(5, 3) },
                        { "asset/subaccount/managed-subaccount-bills", divide(5, 3) },
                        { "users/entrust-subaccount-list", 10 },
                        { "account/subaccount/interest-limits", 4 },
                        { "users/subaccount/apikey", 10 },
                        { "tradingBot/grid/orders-algo-pending", 1 },
                        { "tradingBot/grid/orders-algo-history", 1 },
                        { "tradingBot/grid/orders-algo-details", 1 },
                        { "tradingBot/grid/sub-orders", 1 },
                        { "tradingBot/grid/positions", 1 },
                        { "tradingBot/grid/ai-param", 1 },
                        { "tradingBot/signal/signals", 1 },
                        { "tradingBot/signal/orders-algo-details", 1 },
                        { "tradingBot/signal/orders-algo-history", 1 },
                        { "tradingBot/signal/positions", 1 },
                        { "tradingBot/signal/positions-history", 1 },
                        { "tradingBot/signal/sub-orders", 1 },
                        { "tradingBot/signal/event-history", 1 },
                        { "tradingBot/recurring/orders-algo-pending", 1 },
                        { "tradingBot/recurring/orders-algo-history", 1 },
                        { "tradingBot/recurring/orders-algo-details", 1 },
                        { "tradingBot/recurring/sub-orders", 1 },
                        { "finance/savings/balance", divide(5, 3) },
                        { "finance/savings/lending-history", divide(5, 3) },
                        { "finance/staking-defi/offers", divide(10, 3) },
                        { "finance/staking-defi/orders-active", divide(10, 3) },
                        { "finance/staking-defi/orders-history", divide(10, 3) },
                        { "finance/staking-defi/eth/balance", divide(5, 3) },
                        { "finance/staking-defi/eth/purchase-redeem-history", divide(5, 3) },
                        { "finance/staking-defi/eth/product-info", 3 },
                        { "finance/staking-defi/sol/balance", divide(5, 3) },
                        { "finance/staking-defi/sol/purchase-redeem-history", divide(5, 3) },
                        { "copytrading/current-subpositions", 1 },
                        { "copytrading/subpositions-history", 1 },
                        { "copytrading/instruments", 4 },
                        { "copytrading/profit-sharing-details", 4 },
                        { "copytrading/total-profit-sharing", 4 },
                        { "copytrading/unrealized-profit-sharing-details", 4 },
                        { "copytrading/copy-settings", 4 },
                        { "copytrading/batch-leverage-info", 4 },
                        { "copytrading/current-lead-traders", 4 },
                        { "copytrading/lead-traders-history", 4 },
                        { "broker/nd/info", 10 },
                        { "broker/nd/subaccount-info", 10 },
                        { "broker/nd/subaccount/apikey", 10 },
                        { "asset/broker/nd/subaccount-deposit-address", divide(5, 3) },
                        { "asset/broker/nd/subaccount-deposit-history", 4 },
                        { "asset/broker/nd/subaccount-withdrawal-history", 4 },
                        { "broker/nd/rebate-daily", 100 },
                        { "broker/nd/rebate-per-orders", 300 },
                        { "finance/sfp/dcd/order", 2 },
                        { "finance/sfp/dcd/orders", 2 },
                        { "broker/fd/rebate-per-orders", 300 },
                        { "broker/fd/if-rebate", 5 },
                        { "affiliate/invitee/detail", 1 },
                        { "users/partner/if-rebate", 1 },
                        { "support/announcements", 4 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "rfq/create-rfq", 4 },
                        { "rfq/cancel-rfq", 4 },
                        { "rfq/cancel-batch-rfqs", 10 },
                        { "rfq/cancel-all-rfqs", 10 },
                        { "rfq/execute-quote", 15 },
                        { "rfq/maker-instrument-settings", 4 },
                        { "rfq/mmp-reset", 4 },
                        { "rfq/mmp-config", 100 },
                        { "rfq/create-quote", 0.4 },
                        { "rfq/cancel-quote", 0.4 },
                        { "rfq/cancel-batch-quotes", 10 },
                        { "rfq/cancel-all-quotes", 10 },
                        { "sprd/order", 1 },
                        { "sprd/cancel-order", 1 },
                        { "sprd/mass-cancel", 1 },
                        { "sprd/amend-order", 1 },
                        { "sprd/cancel-all-after", 10 },
                        { "trade/order", divide(1, 3) },
                        { "trade/batch-orders", divide(1, 15) },
                        { "trade/cancel-order", divide(1, 3) },
                        { "trade/cancel-batch-orders", divide(1, 15) },
                        { "trade/amend-order", divide(1, 3) },
                        { "trade/amend-batch-orders", divide(1, 150) },
                        { "trade/close-position", 1 },
                        { "trade/fills-archive", 172800 },
                        { "trade/order-algo", 1 },
                        { "trade/cancel-algos", 1 },
                        { "trade/amend-algos", 1 },
                        { "trade/cancel-advance-algos", 1 },
                        { "trade/easy-convert", 20 },
                        { "trade/one-click-repay", 20 },
                        { "trade/one-click-repay-v2", 20 },
                        { "trade/mass-cancel", 4 },
                        { "trade/cancel-all-after", 10 },
                        { "asset/transfer", 10 },
                        { "asset/withdrawal", divide(5, 3) },
                        { "asset/withdrawal-lightning", 5 },
                        { "asset/cancel-withdrawal", divide(5, 3) },
                        { "asset/convert-dust-assets", 10 },
                        { "asset/convert/estimate-quote", 1 },
                        { "asset/convert/trade", 1 },
                        { "asset/monthly-statement", 1 },
                        { "account/set-position-mode", 4 },
                        { "account/set-leverage", 1 },
                        { "account/position/margin-balance", 1 },
                        { "account/set-greeks", 4 },
                        { "account/set-isolated-mode", 4 },
                        { "account/quick-margin-borrow-repay", 4 },
                        { "account/borrow-repay", divide(5, 3) },
                        { "account/simulated_margin", 10 },
                        { "account/position-builder", 10 },
                        { "account/set-riskOffset-type", 2 },
                        { "account/activate-option", 4 },
                        { "account/set-auto-loan", 4 },
                        { "account/set-account-level", 4 },
                        { "account/mmp-reset", 4 },
                        { "account/mmp-config", 100 },
                        { "account/fixed-loan/borrowing-order", 5 },
                        { "account/fixed-loan/amend-borrowing-order", 5 },
                        { "account/fixed-loan/manual-reborrow", 5 },
                        { "account/fixed-loan/repay-borrowing-order", 5 },
                        { "account/bills-history-archive", 72000 },
                        { "account/move-positions", 10 },
                        { "account/set-settle-currency", 1 },
                        { "users/subaccount/modify-apikey", 10 },
                        { "asset/subaccount/transfer", 10 },
                        { "users/subaccount/set-transfer-out", 10 },
                        { "account/subaccount/set-loan-allocation", 4 },
                        { "users/subaccount/create-subaccount", 10 },
                        { "users/subaccount/subaccount-apikey", 10 },
                        { "users/subaccount/delete-apikey", 10 },
                        { "tradingBot/grid/order-algo", 1 },
                        { "tradingBot/grid/amend-order-algo", 1 },
                        { "tradingBot/grid/stop-order-algo", 1 },
                        { "tradingBot/grid/close-position", 1 },
                        { "tradingBot/grid/cancel-close-order", 1 },
                        { "tradingBot/grid/order-instant-trigger", 1 },
                        { "tradingBot/grid/withdraw-income", 1 },
                        { "tradingBot/grid/compute-margin-balance", 1 },
                        { "tradingBot/grid/margin-balance", 1 },
                        { "tradingBot/grid/min-investment", 1 },
                        { "tradingBot/grid/adjust-investment", 1 },
                        { "tradingBot/signal/create-signal", 1 },
                        { "tradingBot/signal/order-algo", 1 },
                        { "tradingBot/signal/stop-order-algo", 1 },
                        { "tradingBot/signal/margin-balance", 1 },
                        { "tradingBot/signal/amendTPSL", 1 },
                        { "tradingBot/signal/set-instruments", 1 },
                        { "tradingBot/signal/close-position", 1 },
                        { "tradingBot/signal/sub-order", 1 },
                        { "tradingBot/signal/cancel-sub-order", 1 },
                        { "tradingBot/recurring/order-algo", 1 },
                        { "tradingBot/recurring/amend-order-algo", 1 },
                        { "tradingBot/recurring/stop-order-algo", 1 },
                        { "finance/savings/purchase-redempt", divide(5, 3) },
                        { "finance/savings/set-lending-rate", divide(5, 3) },
                        { "finance/staking-defi/purchase", 3 },
                        { "finance/staking-defi/redeem", 3 },
                        { "finance/staking-defi/cancel", 3 },
                        { "finance/staking-defi/eth/purchase", 5 },
                        { "finance/staking-defi/eth/redeem", 5 },
                        { "finance/staking-defi/sol/purchase", 5 },
                        { "finance/staking-defi/sol/redeem", 5 },
                        { "copytrading/algo-order", 1 },
                        { "copytrading/close-subposition", 1 },
                        { "copytrading/set-instruments", 4 },
                        { "copytrading/first-copy-settings", 4 },
                        { "copytrading/amend-copy-settings", 4 },
                        { "copytrading/stop-copy-trading", 4 },
                        { "copytrading/batch-set-leverage", 4 },
                        { "broker/nd/create-subaccount", 0.25 },
                        { "broker/nd/delete-subaccount", 1 },
                        { "broker/nd/subaccount/apikey", 0.25 },
                        { "broker/nd/subaccount/modify-apikey", 1 },
                        { "broker/nd/subaccount/delete-apikey", 1 },
                        { "broker/nd/set-subaccount-level", 4 },
                        { "broker/nd/set-subaccount-fee-rate", 4 },
                        { "broker/nd/set-subaccount-assets", 0.25 },
                        { "asset/broker/nd/subaccount-deposit-address", 1 },
                        { "asset/broker/nd/modify-subaccount-deposit-address", divide(5, 3) },
                        { "broker/nd/rebate-per-orders", 36000 },
                        { "finance/sfp/dcd/quote", 10 },
                        { "finance/sfp/dcd/order", 10 },
                        { "broker/nd/report-subaccount-ip", 0.25 },
                        { "broker/fd/rebate-per-orders", 36000 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.0015") },
                    { "maker", this.parseNumber("0.0010") },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.0015") },
                    { "maker", this.parseNumber("0.0010") },
                } },
                { "future", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.0005") },
                    { "maker", this.parseNumber("0.0002") },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.00050") },
                    { "maker", this.parseNumber("0.00020") },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "password", true },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "1", typeof(ExchangeError) },
                    { "2", typeof(ExchangeError) },
                    { "4088", typeof(ManualInteractionNeeded) },
                    { "50000", typeof(BadRequest) },
                    { "50001", typeof(OnMaintenance) },
                    { "50002", typeof(BadRequest) },
                    { "50004", typeof(RequestTimeout) },
                    { "50005", typeof(ExchangeNotAvailable) },
                    { "50006", typeof(BadRequest) },
                    { "50007", typeof(AccountSuspended) },
                    { "50008", typeof(AuthenticationError) },
                    { "50009", typeof(AccountSuspended) },
                    { "50010", typeof(ExchangeError) },
                    { "50011", typeof(RateLimitExceeded) },
                    { "50012", typeof(ExchangeError) },
                    { "50013", typeof(ExchangeNotAvailable) },
                    { "50014", typeof(BadRequest) },
                    { "50015", typeof(ExchangeError) },
                    { "50016", typeof(ExchangeError) },
                    { "50017", typeof(ExchangeError) },
                    { "50018", typeof(ExchangeError) },
                    { "50019", typeof(ExchangeError) },
                    { "50020", typeof(ExchangeError) },
                    { "50021", typeof(ExchangeError) },
                    { "50022", typeof(ExchangeError) },
                    { "50023", typeof(ExchangeError) },
                    { "50024", typeof(BadRequest) },
                    { "50025", typeof(ExchangeError) },
                    { "50026", typeof(ExchangeNotAvailable) },
                    { "50027", typeof(PermissionDenied) },
                    { "50028", typeof(ExchangeError) },
                    { "50044", typeof(BadRequest) },
                    { "50061", typeof(ExchangeError) },
                    { "50062", typeof(ExchangeError) },
                    { "50100", typeof(ExchangeError) },
                    { "50101", typeof(AuthenticationError) },
                    { "50102", typeof(InvalidNonce) },
                    { "50103", typeof(AuthenticationError) },
                    { "50104", typeof(AuthenticationError) },
                    { "50105", typeof(AuthenticationError) },
                    { "50106", typeof(AuthenticationError) },
                    { "50107", typeof(AuthenticationError) },
                    { "50108", typeof(ExchangeError) },
                    { "50109", typeof(ExchangeError) },
                    { "50110", typeof(PermissionDenied) },
                    { "50111", typeof(AuthenticationError) },
                    { "50112", typeof(AuthenticationError) },
                    { "50113", typeof(AuthenticationError) },
                    { "50114", typeof(AuthenticationError) },
                    { "50115", typeof(BadRequest) },
                    { "51000", typeof(BadRequest) },
                    { "51001", typeof(BadSymbol) },
                    { "51002", typeof(BadSymbol) },
                    { "51003", typeof(BadRequest) },
                    { "51004", typeof(InvalidOrder) },
                    { "51005", typeof(InvalidOrder) },
                    { "51006", typeof(InvalidOrder) },
                    { "51007", typeof(InvalidOrder) },
                    { "51008", typeof(InsufficientFunds) },
                    { "51009", typeof(AccountSuspended) },
                    { "51010", typeof(AccountNotEnabled) },
                    { "51011", typeof(InvalidOrder) },
                    { "51012", typeof(BadSymbol) },
                    { "51014", typeof(BadSymbol) },
                    { "51015", typeof(BadSymbol) },
                    { "51016", typeof(InvalidOrder) },
                    { "51017", typeof(ExchangeError) },
                    { "51018", typeof(ExchangeError) },
                    { "51019", typeof(ExchangeError) },
                    { "51020", typeof(InvalidOrder) },
                    { "51021", typeof(ContractUnavailable) },
                    { "51022", typeof(ContractUnavailable) },
                    { "51023", typeof(ExchangeError) },
                    { "51024", typeof(AccountSuspended) },
                    { "51025", typeof(ExchangeError) },
                    { "51026", typeof(BadSymbol) },
                    { "51027", typeof(ContractUnavailable) },
                    { "51028", typeof(ContractUnavailable) },
                    { "51029", typeof(ContractUnavailable) },
                    { "51030", typeof(ContractUnavailable) },
                    { "51031", typeof(InvalidOrder) },
                    { "51046", typeof(InvalidOrder) },
                    { "51047", typeof(InvalidOrder) },
                    { "51051", typeof(InvalidOrder) },
                    { "51072", typeof(InvalidOrder) },
                    { "51073", typeof(InvalidOrder) },
                    { "51074", typeof(InvalidOrder) },
                    { "51090", typeof(InvalidOrder) },
                    { "51091", typeof(InvalidOrder) },
                    { "51092", typeof(InvalidOrder) },
                    { "51093", typeof(InvalidOrder) },
                    { "51094", typeof(InvalidOrder) },
                    { "51095", typeof(InvalidOrder) },
                    { "51096", typeof(InvalidOrder) },
                    { "51098", typeof(InvalidOrder) },
                    { "51099", typeof(InvalidOrder) },
                    { "51100", typeof(InvalidOrder) },
                    { "51101", typeof(InvalidOrder) },
                    { "51102", typeof(InvalidOrder) },
                    { "51103", typeof(InvalidOrder) },
                    { "51104", typeof(InvalidOrder) },
                    { "51105", typeof(InvalidOrder) },
                    { "51106", typeof(InvalidOrder) },
                    { "51107", typeof(InvalidOrder) },
                    { "51108", typeof(InvalidOrder) },
                    { "51109", typeof(InvalidOrder) },
                    { "51110", typeof(InvalidOrder) },
                    { "51111", typeof(BadRequest) },
                    { "51112", typeof(InvalidOrder) },
                    { "51113", typeof(RateLimitExceeded) },
                    { "51115", typeof(InvalidOrder) },
                    { "51116", typeof(InvalidOrder) },
                    { "51117", typeof(InvalidOrder) },
                    { "51118", typeof(InvalidOrder) },
                    { "51119", typeof(InsufficientFunds) },
                    { "51120", typeof(InvalidOrder) },
                    { "51121", typeof(InvalidOrder) },
                    { "51122", typeof(InvalidOrder) },
                    { "51124", typeof(InvalidOrder) },
                    { "51125", typeof(InvalidOrder) },
                    { "51126", typeof(InvalidOrder) },
                    { "51127", typeof(InsufficientFunds) },
                    { "51128", typeof(InvalidOrder) },
                    { "51129", typeof(InvalidOrder) },
                    { "51130", typeof(BadSymbol) },
                    { "51131", typeof(InsufficientFunds) },
                    { "51132", typeof(InvalidOrder) },
                    { "51133", typeof(InvalidOrder) },
                    { "51134", typeof(InvalidOrder) },
                    { "51135", typeof(InvalidOrder) },
                    { "51136", typeof(InvalidOrder) },
                    { "51137", typeof(InvalidOrder) },
                    { "51138", typeof(InvalidOrder) },
                    { "51139", typeof(InvalidOrder) },
                    { "51155", typeof(RestrictedLocation) },
                    { "51156", typeof(BadRequest) },
                    { "51159", typeof(BadRequest) },
                    { "51162", typeof(InvalidOrder) },
                    { "51163", typeof(InvalidOrder) },
                    { "51166", typeof(InvalidOrder) },
                    { "51174", typeof(InvalidOrder) },
                    { "51185", typeof(InvalidOrder) },
                    { "51201", typeof(InvalidOrder) },
                    { "51202", typeof(InvalidOrder) },
                    { "51203", typeof(InvalidOrder) },
                    { "51204", typeof(InvalidOrder) },
                    { "51205", typeof(InvalidOrder) },
                    { "51250", typeof(InvalidOrder) },
                    { "51251", typeof(InvalidOrder) },
                    { "51252", typeof(InvalidOrder) },
                    { "51253", typeof(InvalidOrder) },
                    { "51254", typeof(InvalidOrder) },
                    { "51255", typeof(InvalidOrder) },
                    { "51256", typeof(InvalidOrder) },
                    { "51257", typeof(InvalidOrder) },
                    { "51258", typeof(InvalidOrder) },
                    { "51259", typeof(InvalidOrder) },
                    { "51260", typeof(InvalidOrder) },
                    { "51261", typeof(InvalidOrder) },
                    { "51262", typeof(InvalidOrder) },
                    { "51263", typeof(InvalidOrder) },
                    { "51264", typeof(InvalidOrder) },
                    { "51265", typeof(InvalidOrder) },
                    { "51267", typeof(InvalidOrder) },
                    { "51268", typeof(InvalidOrder) },
                    { "51269", typeof(InvalidOrder) },
                    { "51270", typeof(InvalidOrder) },
                    { "51271", typeof(InvalidOrder) },
                    { "51272", typeof(InvalidOrder) },
                    { "51273", typeof(InvalidOrder) },
                    { "51274", typeof(InvalidOrder) },
                    { "51275", typeof(InvalidOrder) },
                    { "51276", typeof(InvalidOrder) },
                    { "51277", typeof(InvalidOrder) },
                    { "51278", typeof(InvalidOrder) },
                    { "51279", typeof(InvalidOrder) },
                    { "51280", typeof(InvalidOrder) },
                    { "51321", typeof(InvalidOrder) },
                    { "51322", typeof(InvalidOrder) },
                    { "51323", typeof(BadRequest) },
                    { "51324", typeof(BadRequest) },
                    { "51325", typeof(InvalidOrder) },
                    { "51327", typeof(InvalidOrder) },
                    { "51328", typeof(InvalidOrder) },
                    { "51329", typeof(InvalidOrder) },
                    { "51330", typeof(InvalidOrder) },
                    { "51400", typeof(OrderNotFound) },
                    { "51401", typeof(OrderNotFound) },
                    { "51402", typeof(OrderNotFound) },
                    { "51403", typeof(InvalidOrder) },
                    { "51404", typeof(InvalidOrder) },
                    { "51405", typeof(ExchangeError) },
                    { "51406", typeof(ExchangeError) },
                    { "51407", typeof(BadRequest) },
                    { "51408", typeof(ExchangeError) },
                    { "51409", typeof(ExchangeError) },
                    { "51410", typeof(CancelPending) },
                    { "51500", typeof(ExchangeError) },
                    { "51501", typeof(ExchangeError) },
                    { "51502", typeof(InsufficientFunds) },
                    { "51503", typeof(ExchangeError) },
                    { "51506", typeof(ExchangeError) },
                    { "51508", typeof(ExchangeError) },
                    { "51509", typeof(ExchangeError) },
                    { "51510", typeof(ExchangeError) },
                    { "51511", typeof(ExchangeError) },
                    { "51600", typeof(ExchangeError) },
                    { "51601", typeof(ExchangeError) },
                    { "51602", typeof(ExchangeError) },
                    { "51603", typeof(OrderNotFound) },
                    { "51732", typeof(AuthenticationError) },
                    { "51733", typeof(AuthenticationError) },
                    { "51734", typeof(AuthenticationError) },
                    { "51735", typeof(ExchangeError) },
                    { "51736", typeof(InsufficientFunds) },
                    { "52000", typeof(ExchangeError) },
                    { "54000", typeof(ExchangeError) },
                    { "54001", typeof(ExchangeError) },
                    { "54008", typeof(InvalidOrder) },
                    { "54009", typeof(InvalidOrder) },
                    { "54011", typeof(InvalidOrder) },
                    { "54072", typeof(ExchangeError) },
                    { "54073", typeof(BadRequest) },
                    { "54074", typeof(ExchangeError) },
                    { "55100", typeof(InvalidOrder) },
                    { "55101", typeof(InvalidOrder) },
                    { "55102", typeof(InvalidOrder) },
                    { "55103", typeof(InvalidOrder) },
                    { "55104", typeof(InvalidOrder) },
                    { "55111", typeof(InvalidOrder) },
                    { "55112", typeof(InvalidOrder) },
                    { "55113", typeof(InvalidOrder) },
                    { "58000", typeof(ExchangeError) },
                    { "58001", typeof(AuthenticationError) },
                    { "58002", typeof(PermissionDenied) },
                    { "58003", typeof(ExchangeError) },
                    { "58004", typeof(AccountSuspended) },
                    { "58005", typeof(ExchangeError) },
                    { "58006", typeof(ExchangeError) },
                    { "58007", typeof(ExchangeError) },
                    { "58100", typeof(ExchangeError) },
                    { "58101", typeof(AccountSuspended) },
                    { "58102", typeof(RateLimitExceeded) },
                    { "58103", typeof(ExchangeError) },
                    { "58104", typeof(ExchangeError) },
                    { "58105", typeof(ExchangeError) },
                    { "58106", typeof(ExchangeError) },
                    { "58107", typeof(ExchangeError) },
                    { "58108", typeof(ExchangeError) },
                    { "58109", typeof(ExchangeError) },
                    { "58110", typeof(ExchangeError) },
                    { "58111", typeof(ExchangeError) },
                    { "58112", typeof(ExchangeError) },
                    { "58114", typeof(ExchangeError) },
                    { "58115", typeof(ExchangeError) },
                    { "58116", typeof(ExchangeError) },
                    { "58117", typeof(ExchangeError) },
                    { "58125", typeof(BadRequest) },
                    { "58126", typeof(BadRequest) },
                    { "58127", typeof(BadRequest) },
                    { "58128", typeof(BadRequest) },
                    { "58200", typeof(ExchangeError) },
                    { "58201", typeof(ExchangeError) },
                    { "58202", typeof(ExchangeError) },
                    { "58203", typeof(InvalidAddress) },
                    { "58204", typeof(AccountSuspended) },
                    { "58205", typeof(ExchangeError) },
                    { "58206", typeof(ExchangeError) },
                    { "58207", typeof(InvalidAddress) },
                    { "58208", typeof(ExchangeError) },
                    { "58209", typeof(ExchangeError) },
                    { "58210", typeof(ExchangeError) },
                    { "58211", typeof(ExchangeError) },
                    { "58212", typeof(ExchangeError) },
                    { "58213", typeof(AuthenticationError) },
                    { "58221", typeof(BadRequest) },
                    { "58222", typeof(BadRequest) },
                    { "58224", typeof(BadRequest) },
                    { "58227", typeof(BadRequest) },
                    { "58228", typeof(BadRequest) },
                    { "58229", typeof(InsufficientFunds) },
                    { "58300", typeof(ExchangeError) },
                    { "58350", typeof(InsufficientFunds) },
                    { "59000", typeof(ExchangeError) },
                    { "59001", typeof(ExchangeError) },
                    { "59100", typeof(ExchangeError) },
                    { "59101", typeof(ExchangeError) },
                    { "59102", typeof(ExchangeError) },
                    { "59103", typeof(InsufficientFunds) },
                    { "59104", typeof(ExchangeError) },
                    { "59105", typeof(ExchangeError) },
                    { "59106", typeof(ExchangeError) },
                    { "59107", typeof(ExchangeError) },
                    { "59108", typeof(InsufficientFunds) },
                    { "59109", typeof(ExchangeError) },
                    { "59128", typeof(InvalidOrder) },
                    { "59200", typeof(InsufficientFunds) },
                    { "59201", typeof(InsufficientFunds) },
                    { "59216", typeof(BadRequest) },
                    { "59260", typeof(PermissionDenied) },
                    { "59262", typeof(PermissionDenied) },
                    { "59300", typeof(ExchangeError) },
                    { "59301", typeof(ExchangeError) },
                    { "59313", typeof(ExchangeError) },
                    { "59401", typeof(ExchangeError) },
                    { "59410", typeof(OperationRejected) },
                    { "59411", typeof(InsufficientFunds) },
                    { "59412", typeof(OperationRejected) },
                    { "59413", typeof(OperationRejected) },
                    { "59414", typeof(BadRequest) },
                    { "59500", typeof(ExchangeError) },
                    { "59501", typeof(ExchangeError) },
                    { "59502", typeof(ExchangeError) },
                    { "59503", typeof(ExchangeError) },
                    { "59504", typeof(ExchangeError) },
                    { "59505", typeof(ExchangeError) },
                    { "59506", typeof(ExchangeError) },
                    { "59507", typeof(ExchangeError) },
                    { "59508", typeof(AccountSuspended) },
                    { "59515", typeof(ExchangeError) },
                    { "59516", typeof(ExchangeError) },
                    { "59517", typeof(ExchangeError) },
                    { "59518", typeof(ExchangeError) },
                    { "59519", typeof(ExchangeError) },
                    { "59642", typeof(BadRequest) },
                    { "59643", typeof(ExchangeError) },
                    { "59683", typeof(ExchangeError) },
                    { "59684", typeof(BadRequest) },
                    { "59686", typeof(BadRequest) },
                    { "60001", typeof(AuthenticationError) },
                    { "60002", typeof(AuthenticationError) },
                    { "60003", typeof(AuthenticationError) },
                    { "60004", typeof(AuthenticationError) },
                    { "60005", typeof(AuthenticationError) },
                    { "60006", typeof(InvalidNonce) },
                    { "60007", typeof(AuthenticationError) },
                    { "60008", typeof(AuthenticationError) },
                    { "60009", typeof(AuthenticationError) },
                    { "60010", typeof(AuthenticationError) },
                    { "60011", typeof(AuthenticationError) },
                    { "60012", typeof(BadRequest) },
                    { "60013", typeof(BadRequest) },
                    { "60014", typeof(RateLimitExceeded) },
                    { "60015", typeof(NetworkError) },
                    { "60016", typeof(ExchangeNotAvailable) },
                    { "60017", typeof(BadRequest) },
                    { "60018", typeof(BadRequest) },
                    { "60019", typeof(BadRequest) },
                    { "60020", typeof(ExchangeError) },
                    { "60021", typeof(AccountNotEnabled) },
                    { "60022", typeof(AuthenticationError) },
                    { "60023", typeof(DDoSProtection) },
                    { "60024", typeof(AuthenticationError) },
                    { "60025", typeof(ExchangeError) },
                    { "60026", typeof(AuthenticationError) },
                    { "60027", typeof(ArgumentsRequired) },
                    { "60028", typeof(NotSupported) },
                    { "60029", typeof(AccountNotEnabled) },
                    { "60030", typeof(AccountNotEnabled) },
                    { "60031", typeof(AuthenticationError) },
                    { "60032", typeof(AuthenticationError) },
                    { "63999", typeof(ExchangeError) },
                    { "64000", typeof(BadRequest) },
                    { "64001", typeof(BadRequest) },
                    { "64002", typeof(BadRequest) },
                    { "64003", typeof(AccountNotEnabled) },
                    { "70010", typeof(BadRequest) },
                    { "70013", typeof(BadRequest) },
                    { "70016", typeof(BadRequest) },
                    { "70060", typeof(BadRequest) },
                    { "70061", typeof(BadRequest) },
                    { "70062", typeof(BadRequest) },
                    { "70064", typeof(BadRequest) },
                    { "70065", typeof(BadRequest) },
                    { "70066", typeof(BadRequest) },
                    { "70067", typeof(BadRequest) },
                    { "1009", typeof(BadRequest) },
                    { "4001", typeof(AuthenticationError) },
                    { "4002", typeof(BadRequest) },
                    { "4003", typeof(RateLimitExceeded) },
                    { "4004", typeof(NetworkError) },
                    { "4005", typeof(ExchangeNotAvailable) },
                    { "4006", typeof(BadRequest) },
                    { "4007", typeof(AuthenticationError) },
                    { "4008", typeof(RateLimitExceeded) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Internal Server Error", typeof(ExchangeNotAvailable) },
                    { "server error", typeof(ExchangeNotAvailable) },
                } },
            } },
            { "httpExceptions", new Dictionary<string, object>() {
                { "429", typeof(ExchangeNotAvailable) },
            } },
            { "precisionMode", TICK_SIZE },
            { "options", new Dictionary<string, object>() {
                { "sandboxMode", false },
                { "defaultNetwork", "ERC20" },
                { "defaultNetworks", new Dictionary<string, object>() {
                    { "ETH", "ERC20" },
                    { "BTC", "BTC" },
                    { "USDT", "TRC20" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "BTC", "Bitcoin" },
                    { "BTCLN", "Lightning" },
                    { "BTCLIGHTNING", "Lightning" },
                    { "BEP20", "BSC" },
                    { "BRC20", "BRC20" },
                    { "ERC20", "ERC20" },
                    { "TRC20", "TRC20" },
                    { "CRC20", "Crypto" },
                    { "ACA", "Acala" },
                    { "ALGO", "Algorand" },
                    { "APT", "Aptos" },
                    { "SCROLL", "Scroll" },
                    { "ARBONE", "Arbitrum One" },
                    { "AVAXC", "Avalanche C-Chain" },
                    { "AVAXX", "Avalanche X-Chain" },
                    { "BASE", "Base" },
                    { "SUI", "SUI" },
                    { "ZKSYNCERA", "zkSync Era" },
                    { "LINEA", "Linea" },
                    { "AR", "Arweave" },
                    { "ASTR", "Astar" },
                    { "BCH", "BitcoinCash" },
                    { "BSV", "Bitcoin SV" },
                    { "ADA", "Cardano" },
                    { "CSPR", "Casper" },
                    { "CELO", "CELO" },
                    { "XCH", "Chia" },
                    { "ATOM", "Cosmos" },
                    { "DGB", "Digibyte" },
                    { "DOGE", "Dogecoin" },
                    { "EGLD", "Elrond" },
                    { "CFX", "Conflux" },
                    { "EOS", "EOS" },
                    { "CORE", "CORE" },
                    { "ETC", "Ethereum Classic" },
                    { "ETHW", "EthereumPow" },
                    { "FIL", "Filecoin" },
                    { "ONE", "Harmony" },
                    { "HBAR", "Hedera" },
                    { "ICX", "ICON" },
                    { "ICP", "Dfinity" },
                    { "IOST", "IOST" },
                    { "IOTA", "MIOTA" },
                    { "KLAY", "Klaytn" },
                    { "KSM", "Kusama" },
                    { "LSK", "Lisk" },
                    { "LTC", "Litecoin" },
                    { "METIS", "Metis" },
                    { "MINA", "Mina" },
                    { "GLRM", "Moonbeam" },
                    { "MOVR", "Moonriver" },
                    { "NANO", "Nano" },
                    { "NEAR", "NEAR" },
                    { "NULS", "NULS" },
                    { "OASYS", "OASYS" },
                    { "ONT", "Ontology" },
                    { "OPTIMISM", "Optimism" },
                    { "LAT", "PlatON" },
                    { "DOT", "Polkadot" },
                    { "MATIC", "Polygon" },
                    { "RVN", "Ravencoin" },
                    { "XRP", "Ripple" },
                    { "SC", "Siacoin" },
                    { "SOL", "Solana" },
                    { "STX", "l-Stacks" },
                    { "XLM", "Stellar Lumens" },
                    { "XTZ", "Tezos" },
                    { "TON", "TON" },
                    { "THETA", "Theta" },
                    { "WAX", "Wax" },
                    { "ZIL", "Zilliqa" },
                } },
                { "fetchOpenInterestHistory", new Dictionary<string, object>() {
                    { "timeframes", new Dictionary<string, object>() {
                        { "5m", "5m" },
                        { "1h", "1H" },
                        { "8h", "8H" },
                        { "1d", "1D" },
                        { "5M", "5m" },
                        { "1H", "1H" },
                        { "8H", "8H" },
                        { "1D", "1D" },
                    } },
                } },
                { "fetchOHLCV", new Dictionary<string, object>() {
                    { "timezone", "UTC" },
                } },
                { "fetchPositions", new Dictionary<string, object>() {
                    { "method", "privateGetAccountPositions" },
                } },
                { "createOrder", "privatePostTradeBatchOrders" },
                { "createMarketBuyOrderRequiresPrice", false },
                { "fetchMarkets", new Dictionary<string, object>() {
                    { "types", new List<object>() {"spot", "future", "swap", "option"} },
                } },
                { "timeDifference", 0 },
                { "adjustForTimeDifference", false },
                { "defaultType", "spot" },
                { "fetchLedger", new Dictionary<string, object>() {
                    { "method", "privateGetAccountBills" },
                } },
                { "fetchOrder", new Dictionary<string, object>() {
                    { "method", "privateGetTradeOrder" },
                } },
                { "fetchOpenOrders", new Dictionary<string, object>() {
                    { "method", "privateGetTradeOrdersPending" },
                } },
                { "cancelOrders", new Dictionary<string, object>() {
                    { "method", "privatePostTradeCancelBatchOrders" },
                } },
                { "fetchCanceledOrders", new Dictionary<string, object>() {
                    { "method", "privateGetTradeOrdersHistory" },
                } },
                { "fetchClosedOrders", new Dictionary<string, object>() {
                    { "method", "privateGetTradeOrdersHistory" },
                } },
                { "withdraw", new Dictionary<string, object>() {
                    { "password", null },
                    { "pwd", null },
                } },
                { "algoOrderTypes", new Dictionary<string, object>() {
                    { "conditional", true },
                    { "trigger", true },
                    { "oco", true },
                    { "move_order_stop", true },
                    { "iceberg", true },
                    { "twap", true },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "funding", "6" },
                    { "trading", "18" },
                    { "spot", "18" },
                    { "future", "18" },
                    { "futures", "18" },
                    { "margin", "18" },
                    { "swap", "18" },
                    { "option", "18" },
                } },
                { "accountsById", new Dictionary<string, object>() {
                    { "6", "funding" },
                    { "18", "trading" },
                } },
                { "exchangeType", new Dictionary<string, object>() {
                    { "spot", "SPOT" },
                    { "margin", "MARGIN" },
                    { "swap", "SWAP" },
                    { "future", "FUTURES" },
                    { "futures", "FUTURES" },
                    { "option", "OPTION" },
                    { "SPOT", "SPOT" },
                    { "MARGIN", "MARGIN" },
                    { "SWAP", "SWAP" },
                    { "FUTURES", "FUTURES" },
                    { "OPTION", "OPTION" },
                } },
                { "brokerId", "6b9ad766b55dBCDE" },
            } },
            { "features", new Dictionary<string, object>() {
                { "default", new Dictionary<string, object>() {
                    { "sandbox", true },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "triggerPrice", true },
                        { "triggerPriceType", new Dictionary<string, object>() {
                            { "last", true },
                            { "mark", true },
                            { "index", true },
                        } },
                        { "triggerDirection", false },
                        { "stopLossPrice", true },
                        { "takeProfitPrice", true },
                        { "attachedStopLossTakeProfit", new Dictionary<string, object>() {
                            { "triggerPriceType", new Dictionary<string, object>() {
                                { "last", true },
                                { "mark", true },
                                { "index", true },
                            } },
                            { "price", true },
                        } },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", true },
                        { "trailing", true },
                        { "iceberg", true },
                        { "leverage", false },
                        { "selfTradePrevention", true },
                        { "marketBuyByCost", true },
                        { "marketBuyRequiresPrice", false },
                    } },
                    { "createOrders", new Dictionary<string, object>() {
                        { "max", 20 },
                    } },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "daysBack", 90 },
                        { "limit", 100 },
                        { "untilDays", 10000 },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", true },
                        { "trailing", true },
                        { "symbolRequired", true },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "trigger", true },
                        { "trailing", true },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", null },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "daysBack", 90 },
                        { "daysBackCanceled", divide(1, 12) },
                        { "untilDays", null },
                        { "trigger", true },
                        { "trailing", true },
                        { "symbolRequired", false },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 300 },
                        { "historical", 100 },
                    } },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "extends", "default" },
                    { "fetchCurrencies", new Dictionary<string, object>() {
                        { "private", true },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "default" },
                    } },
                    { "inverse", new Dictionary<string, object>() {
                        { "extends", "default" },
                    } },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "default" },
                    } },
                    { "inverse", new Dictionary<string, object>() {
                        { "extends", "default" },
                    } },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "AE", "AET" },
                { "WIN", "WINTOKEN" },
            } },
        });
    }

    public override object handleMarketTypeAndParams(object methodName, object market = null, object parameters = null, object defaultValue = null)
    {
        parameters ??= new Dictionary<string, object>();
        object instType = this.safeString(parameters, "instType");
        parameters = this.omit(parameters, "instType");
        object type = this.safeString(parameters, "type");
        if (isTrue(isTrue((isEqual(type, null))) && isTrue((!isEqual(instType, null)))))
        {
            ((IDictionary<string,object>)parameters)["type"] = instType;
        }
        return base.handleMarketTypeAndParams(methodName, market, parameters, defaultValue);
    }

    public virtual object convertToInstrumentType(object type)
    {
        object exchangeTypes = this.safeDict(this.options, "exchangeType", new Dictionary<string, object>() {});
        return this.safeString(exchangeTypes, type, type);
    }

    public override object createExpiredOptionMarket(object symbol)
    {
        // support expired option contracts
        object quote = "USD";
        object optionParts = ((string)symbol).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
        object symbolBase = ((string)symbol).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
        object bs = null;
        if (isTrue(isGreaterThan(getIndexOf(symbol, "/"), -1)))
        {
            bs = this.safeString(symbolBase, 0);
        } else
        {
            bs = this.safeString(optionParts, 0);
        }
        object settle = bs;
        object expiry = this.safeString(optionParts, 2);
        object strike = this.safeString(optionParts, 3);
        object optionType = this.safeString(optionParts, 4);
        object datetime = this.convertExpireDate(expiry);
        object timestamp = this.parse8601(datetime);
        return new Dictionary<string, object>() {
            { "id", add(add(add(add(add(add(add(add(bs, "-"), quote), "-"), expiry), "-"), strike), "-"), optionType) },
            { "symbol", add(add(add(add(add(add(add(add(add(add(bs, "/"), quote), ":"), settle), "-"), expiry), "-"), strike), "-"), optionType) },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", bs },
            { "quoteId", quote },
            { "settleId", settle },
            { "active", false },
            { "type", "option" },
            { "linear", null },
            { "inverse", null },
            { "spot", false },
            { "swap", false },
            { "future", false },
            { "option", true },
            { "margin", false },
            { "contract", true },
            { "contractSize", this.parseNumber("1") },
            { "expiry", timestamp },
            { "expiryDatetime", datetime },
            { "optionType", ((bool) isTrue((isEqual(optionType, "C")))) ? "call" : "put" },
            { "strike", this.parseNumber(strike) },
            { "precision", new Dictionary<string, object>() {
                { "amount", null },
                { "price", null },
            } },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "info", null },
        };
    }

    public override object safeMarket(object marketId = null, object market = null, object delimiter = null, object marketType = null)
    {
        object isOption = isTrue((!isEqual(marketId, null))) && isTrue((isTrue((isGreaterThan(getIndexOf(marketId, "-C"), -1))) || isTrue((isGreaterThan(getIndexOf(marketId, "-P"), -1)))));
        if (isTrue(isTrue(isOption) && !isTrue((inOp(this.markets_by_id, marketId)))))
        {
            // handle expired option contracts
            return this.createExpiredOptionMarket(marketId);
        }
        return base.safeMarket(marketId, market, delimiter, marketType);
    }

    /**
     * @method
     * @name okx#fetchStatus
     * @description the latest known information on the availability of the exchange API
     * @see https://www.okx.com/docs-v5/en/#status-get-status
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
     */
    public async override Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetSystemStatus(parameters);
        //
        // Note, if there is no maintenance around, the 'data' array is empty
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "begin": "1621328400000",
        //                 "end": "1621329000000",
        //                 "href": "https://www.okx.com/support/hc/en-us/articles/360060882172",
        //                 "scheDesc": "",
        //                 "serviceType": "1", // 0 WebSocket, 1 Spot/Margin, 2 Futures, 3 Perpetual, 4 Options, 5 Trading service
        //                 "state": "scheduled", // ongoing, completed, canceled
        //                 "system": "classic", // classic, unified
        //                 "title": "Classic Spot System Upgrade"
        //             },
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object dataLength = getArrayLength(data);
        object update = new Dictionary<string, object>() {
            { "updated", null },
            { "status", ((bool) isTrue((isEqual(dataLength, 0)))) ? "ok" : "maintenance" },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object eventVar = getValue(data, i);
            object state = this.safeString(eventVar, "state");
            ((IDictionary<string,object>)update)["eta"] = this.safeInteger(eventVar, "end");
            ((IDictionary<string,object>)update)["url"] = this.safeString(eventVar, "href");
            if (isTrue(isEqual(state, "ongoing")))
            {
                ((IDictionary<string,object>)update)["status"] = "maintenance";
            } else if (isTrue(isEqual(state, "scheduled")))
            {
                ((IDictionary<string,object>)update)["status"] = "ok";
            } else if (isTrue(isEqual(state, "completed")))
            {
                ((IDictionary<string,object>)update)["status"] = "ok";
            } else if (isTrue(isEqual(state, "canceled")))
            {
                ((IDictionary<string,object>)update)["status"] = "ok";
            }
        }
        return update;
    }

    /**
     * @method
     * @name okx#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-system-time
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetPublicTime(parameters);
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {"ts": "1621247923668"}
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.safeInteger(first, "ts");
    }

    /**
     * @method
     * @name okx#fetchAccounts
     * @description fetch all the accounts associated with a profile
     * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-account-configuration
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
     */
    public async override Task<object> fetchAccounts(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.privateGetAccountConfig(parameters);
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "acctLv": "2",
        //                 "acctStpMode": "cancel_maker",
        //                 "autoLoan": false,
        //                 "ctIsoMode": "automatic",
        //                 "enableSpotBorrow": false,
        //                 "greeksType": "PA",
        //                 "feeType": "0",
        //                 "ip": "",
        //                 "type": "0",
        //                 "kycLv": "3",
        //                 "label": "v5 test",
        //                 "level": "Lv1",
        //                 "levelTmp": "",
        //                 "liquidationGear": "-1",
        //                 "mainUid": "44705892343619584",
        //                 "mgnIsoMode": "automatic",
        //                 "opAuth": "1",
        //                 "perm": "read_only,withdraw,trade",
        //                 "posMode": "long_short_mode",
        //                 "roleType": "0",
        //                 "spotBorrowAutoRepay": false,
        //                 "spotOffsetType": "",
        //                 "spotRoleType": "0",
        //                 "spotTraderInsts": [],
        //                 "traderInsts": [],
        //                 "uid": "44705892343619584",
        //                 "settleCcy": "USDT",
        //                 "settleCcyList": ["USD", "USDC", "USDG"],
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object account = getValue(data, i);
            object accountId = this.safeString(account, "uid");
            object type = this.safeString(account, "acctLv");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", accountId },
                { "type", type },
                { "currency", null },
                { "info", account },
                { "code", null },
            });
        }
        return result;
    }

    public override object nonce()
    {
        return subtract(this.milliseconds(), getValue(this.options, "timeDifference"));
    }

    /**
     * @method
     * @name okx#fetchMarkets
     * @description retrieves data on all markets for okx
     * @see https://www.okx.com/docs-v5/en/#rest-api-public-data-get-instruments
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.options, "adjustForTimeDifference")))
        {
            await this.loadTimeDifference();
        }
        object types = new List<object>() {"spot", "future", "swap", "option"};
        object fetchMarketsOption = this.safeDict(this.options, "fetchMarkets");
        if (isTrue(!isEqual(fetchMarketsOption, null)))
        {
            types = this.safeList(fetchMarketsOption, "types", types);
        } else
        {
            types = this.safeList(this.options, "fetchMarkets", types); // backward-support
        }
        object promises = new List<object>() {};
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(types)); postFixIncrement(ref i))
        {
            ((IList<object>)promises).Add(this.fetchMarketsByType(getValue(types, i), parameters));
        }
        promises = await promiseAll(promises);
        for (object i = 0; isLessThan(i, getArrayLength(promises)); postFixIncrement(ref i))
        {
            result = this.arrayConcat(result, getValue(promises, i));
        }
        return result;
    }

    public override object parseMarket(object market)
    {
        //
        //     {
        //         "alias": "", // this_week, next_week, quarter, next_quarter
        //         "baseCcy": "BTC",
        //         "category": "1",
        //         "ctMult": "",
        //         "ctType": "", // inverse, linear
        //         "ctVal": "",
        //         "ctValCcy": "",
        //         "expTime": "",
        //         "instId": "BTC-USDT", // BTC-USD-210521, CSPR-USDT-SWAP, BTC-USD-210517-44000-C
        //         "instType": "SPOT", // SPOT, FUTURES, SWAP, OPTION
        //         "lever": "10",
        //         "listTime": "1548133413000",
        //         "lotSz": "0.00000001",
        //         "minSz": "0.00001",
        //         "optType": "",
        //         "quoteCcy": "USDT",
        //         "settleCcy": "",
        //         "state": "live",
        //         "stk": "",
        //         "tickSz": "0.1",
        //         "uly": ""
        //     }
        //
        //     {
        //         "alias": "",
        //         "baseCcy": "",
        //         "category": "1",
        //         "ctMult": "0.1",
        //         "ctType": "",
        //         "ctVal": "1",
        //         "ctValCcy": "BTC",
        //         "expTime": "1648195200000",
        //         "instId": "BTC-USD-220325-194000-P",
        //         "instType": "OPTION",
        //         "lever": "",
        //         "listTime": "1631262612280",
        //         "contTdSwTime": "1631262812280",
        //         "lotSz": "1",
        //         "minSz": "1",
        //         "optType": "P",
        //         "quoteCcy": "",
        //         "settleCcy": "BTC",
        //         "state": "live",
        //         "stk": "194000",
        //         "tickSz": "0.0005",
        //         "uly": "BTC-USD"
        //     }
        //
        object id = this.safeString(market, "instId");
        object type = this.safeStringLower(market, "instType");
        if (isTrue(isEqual(type, "futures")))
        {
            type = "future";
        }
        object spot = (isEqual(type, "spot"));
        object future = (isEqual(type, "future"));
        object swap = (isEqual(type, "swap"));
        object option = (isEqual(type, "option"));
        object contract = isTrue(isTrue(swap) || isTrue(future)) || isTrue(option);
        object baseId = this.safeString(market, "baseCcy", ""); // defaulting to '' because some weird preopen markets have empty baseId
        object quoteId = this.safeString(market, "quoteCcy", "");
        object settleId = this.safeString(market, "settleCcy");
        object settle = this.safeCurrencyCode(settleId);
        object underlying = this.safeString(market, "uly");
        if (isTrue(isTrue((!isEqual(underlying, null))) && !isTrue(spot)))
        {
            object parts = ((string)underlying).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            baseId = this.safeString(parts, 0);
            quoteId = this.safeString(parts, 1);
        }
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(bs, "/"), quote);
        object expiry = null;
        object strikePrice = null;
        object optionType = null;
        if (isTrue(contract))
        {
            if (isTrue(!isEqual(settle, null)))
            {
                symbol = add(add(symbol, ":"), settle);
            }
            if (isTrue(future))
            {
                expiry = this.safeInteger(market, "expTime");
                if (isTrue(!isEqual(expiry, null)))
                {
                    object ymd = this.yymmdd(expiry);
                    symbol = add(add(symbol, "-"), ymd);
                }
            } else if (isTrue(option))
            {
                expiry = this.safeInteger(market, "expTime");
                strikePrice = this.safeString(market, "stk");
                optionType = this.safeString(market, "optType");
                if (isTrue(!isEqual(expiry, null)))
                {
                    object ymd = this.yymmdd(expiry);
                    symbol = add(add(add(add(add(add(symbol, "-"), ymd), "-"), strikePrice), "-"), optionType);
                    optionType = ((bool) isTrue((isEqual(optionType, "P")))) ? "put" : "call";
                }
            }
        }
        object fees = this.safeDict2(this.fees, type, "trading", new Dictionary<string, object>() {});
        object maxLeverage = this.safeString(market, "lever", "1");
        maxLeverage = Precise.stringMax(maxLeverage, "1");
        object maxSpotCost = this.safeNumber(market, "maxMktSz");
        return this.extend(fees, new Dictionary<string, object>() {
            { "id", id },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", type },
            { "spot", spot },
            { "margin", isTrue(spot) && isTrue((Precise.stringGt(maxLeverage, "1"))) },
            { "swap", swap },
            { "future", future },
            { "option", option },
            { "active", true },
            { "contract", contract },
            { "linear", ((bool) isTrue(contract)) ? (isEqual(quoteId, settleId)) : null },
            { "inverse", ((bool) isTrue(contract)) ? (isEqual(baseId, settleId)) : null },
            { "contractSize", ((bool) isTrue(contract)) ? this.safeNumber(market, "ctVal") : null },
            { "expiry", expiry },
            { "expiryDatetime", this.iso8601(expiry) },
            { "strike", this.parseNumber(strikePrice) },
            { "optionType", optionType },
            { "created", this.safeInteger2(market, "contTdSwTime", "listTime") },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber(market, "lotSz") },
                { "price", this.safeNumber(market, "tickSz") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", this.parseNumber("1") },
                    { "max", this.parseNumber(maxLeverage) },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "minSz") },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", ((bool) isTrue(contract)) ? null : maxSpotCost },
                } },
            } },
            { "info", market },
        });
    }

    public async virtual Task<object> fetchMarketsByType(object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "instType", this.convertToInstrumentType(type) },
        };
        if (isTrue(isEqual(type, "option")))
        {
            object optionsUnderlying = this.safeList(this.options, "defaultUnderlying", new List<object>() {"BTC-USD", "ETH-USD"});
            object promises = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(optionsUnderlying)); postFixIncrement(ref i))
            {
                object underlying = getValue(optionsUnderlying, i);
                ((IDictionary<string,object>)request)["uly"] = underlying;
                ((IList<object>)promises).Add(this.publicGetPublicInstruments(this.extend(request, parameters)));
            }
            object promisesResult = await promiseAll(promises);
            object markets = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(promisesResult)); postFixIncrement(ref i))
            {
                object res = this.safeDict(promisesResult, i, new Dictionary<string, object>() {});
                object options = this.safeList(res, "data", new List<object>() {});
                markets = this.arrayConcat(markets, options);
            }
            return this.parseMarkets(markets);
        }
        object response = await this.publicGetPublicInstruments(this.extend(request, parameters));
        //
        // spot, future, swap, option
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "alias": "", // this_week, next_week, quarter, next_quarter
        //                 "baseCcy": "BTC",
        //                 "category": "1",
        //                 "ctMult": "",
        //                 "ctType": "", // inverse, linear
        //                 "ctVal": "",
        //                 "ctValCcy": "",
        //                 "expTime": "",
        //                 "instId": "BTC-USDT", // BTC-USD-210521, CSPR-USDT-SWAP, BTC-USD-210517-44000-C
        //                 "instType": "SPOT", // SPOT, FUTURES, SWAP, OPTION
        //                 "lever": "10",
        //                 "listTime": "1548133413000",
        //                 "lotSz": "0.00000001",
        //                 "minSz": "0.00001",
        //                 "optType": "",
        //                 "quoteCcy": "USDT",
        //                 "settleCcy": "",
        //                 "state": "live",
        //                 "stk": "",
        //                 "tickSz": "0.1",
        //                 "uly": ""
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object dataResponse = this.safeList(response, "data", new List<object>() {});
        return this.parseMarkets(dataResponse);
    }

    /**
     * @method
     * @name okx#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-currencies
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        // this endpoint requires authentication
        // while fetchCurrencies is a public API method by design
        // therefore we check the keys here
        // and fallback to generating the currencies from the markets
        parameters ??= new Dictionary<string, object>();
        object isSandboxMode = this.safeBool(this.options, "sandboxMode", false);
        if (isTrue(!isTrue(this.checkRequiredCredentials(false)) || isTrue(isSandboxMode)))
        {
            return new Dictionary<string, object>() {};
        }
        //
        // has['fetchCurrencies'] is currently set to true, but an unauthorized request returns
        //
        //     {"msg":"Request header OK_ACCESS_KEY can't be empty.","code":"50103"}
        //
        object response = await this.privateGetAssetCurrencies(parameters);
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "canDep": true,
        //                "canInternal": false,
        //                "canWd": true,
        //                "ccy": "USDT",
        //                "chain": "USDT-TRC20",
        //                "logoLink": "https://static.coinall.ltd/cdn/assets/imgs/221/5F74EB20302D7761.png",
        //                "mainNet": false,
        //                "maxFee": "1.6",
        //                "maxWd": "8852150",
        //                "minFee": "0.8",
        //                "minWd": "2",
        //                "name": "Tether",
        //                "usedWdQuota": "0",
        //                "wdQuota": "500",
        //                "wdTickSz": "3"
        //            },
        //            {
        //                "canDep": true,
        //                "canInternal": false,
        //                "canWd": true,
        //                "ccy": "USDT",
        //                "chain": "USDT-ERC20",
        //                "logoLink": "https://static.coinall.ltd/cdn/assets/imgs/221/5F74EB20302D7761.png",
        //                "mainNet": false,
        //                "maxFee": "16",
        //                "maxWd": "8852150",
        //                "minFee": "8",
        //                "minWd": "2",
        //                "name": "Tether",
        //                "usedWdQuota": "0",
        //                "wdQuota": "500",
        //                "wdTickSz": "3"
        //            },
        //            ...
        //        ],
        //        "msg": ""
        //    }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        object dataByCurrencyId = this.groupBy(data, "ccy");
        object currencyIds = new List<object>(((IDictionary<string,object>)dataByCurrencyId).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencyIds, i);
            object currency = this.safeCurrency(currencyId);
            object code = getValue(currency, "code");
            object chains = getValue(dataByCurrencyId, currencyId);
            object networks = new Dictionary<string, object>() {};
            object type = "crypto";
            object chainsLength = getArrayLength(chains);
            for (object j = 0; isLessThan(j, chainsLength); postFixIncrement(ref j))
            {
                object chain = getValue(chains, j);
                // allow empty string for rare fiat-currencies, e.g. TRY
                object networkId = this.safeString(chain, "chain", ""); // USDT-BEP20, USDT-Avalance-C, etc
                if (isTrue(isEqual(networkId, "")))
                {
                    // only happens for fiat 'TRY' currency
                    type = "fiat";
                }
                object idParts = ((string)networkId).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
                object parts = this.arraySlice(idParts, 1);
                object chainPart = String.Join("-", ((IList<object>)parts).ToArray());
                object networkCode = this.networkIdToCode(chainPart, getValue(currency, "code"));
                ((IDictionary<string,object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                    { "id", networkId },
                    { "network", networkCode },
                    { "active", null },
                    { "deposit", this.safeBool(chain, "canDep") },
                    { "withdraw", this.safeBool(chain, "canWd") },
                    { "fee", this.safeNumber(chain, "fee") },
                    { "precision", this.parseNumber(this.parsePrecision(this.safeString(chain, "wdTickSz"))) },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", this.safeNumber(chain, "minWd") },
                            { "max", this.safeNumber(chain, "maxWd") },
                        } },
                    } },
                    { "info", chain },
                };
            }
            object firstChain = this.safeDict(chains, 0, new Dictionary<string, object>() {});
            ((IDictionary<string,object>)result)[(string)code] = this.safeCurrencyStructure(new Dictionary<string, object>() {
                { "info", chains },
                { "code", code },
                { "id", currencyId },
                { "name", this.safeString(firstChain, "name") },
                { "active", null },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "precision", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "type", type },
                { "networks", networks },
            });
        }
        return result;
    }

    /**
     * @method
     * @name okx#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-get-order-book
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.method] 'publicGetMarketBooksFull' or 'publicGetMarketBooks' default is 'publicGetMarketBooks'
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object method = null;
        var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchOrderBook", "method", "publicGetMarketBooks");
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        if (isTrue(isTrue(isEqual(method, "publicGetMarketBooksFull")) && isTrue(isEqual(limit, null))))
        {
            limit = 5000;
        }
        limit = ((bool) isTrue((isEqual(limit, null)))) ? 100 : limit;
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["sz"] = limit; // max 400
        }
        object response = null;
        if (isTrue(isTrue((isEqual(method, "publicGetMarketBooksFull"))) || isTrue((isGreaterThan(limit, 400)))))
        {
            response = await this.publicGetMarketBooksFull(this.extend(request, parameters));
        } else
        {
            response = await this.publicGetMarketBooks(this.extend(request, parameters));
        }
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "asks": [
        //                     ["0.07228","4.211619","0","2"], // price, amount, liquidated orders, total open orders
        //                     ["0.0723","299.880364","0","2"],
        //                     ["0.07231","3.72832","0","1"],
        //                 ],
        //                 "bids": [
        //                     ["0.07221","18.5","0","1"],
        //                     ["0.0722","18.5","0","1"],
        //                     ["0.07219","0.505407","0","1"],
        //                 ],
        //                 "ts": "1621438475342"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(first, "ts");
        return this.parseOrderBook(first, symbol, timestamp);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //      {
        //          "instType":"SWAP",
        //          "instId":"BTC-USDT-SWAP",
        //          "markPx":"200",
        //          "ts":"1597026383085"
        //      }
        //
        //     {
        //         "instType": "SPOT",
        //         "instId": "ETH-BTC",
        //         "last": "0.07319",
        //         "lastSz": "0.044378",
        //         "askPx": "0.07322",
        //         "askSz": "4.2",
        //         "bidPx": "0.0732",
        //         "bidSz": "6.050058",
        //         "open24h": "0.07801",
        //         "high24h": "0.07975",
        //         "low24h": "0.06019",
        //         "volCcy24h": "11788.887619",
        //         "vol24h": "167493.829229",
        //         "ts": "1621440583784",
        //         "sodUtc0": "0.07872",
        //         "sodUtc8": "0.07345"
        //     }
        //     {
        //          instId: 'LTC-USDT',
        //          idxPx: '65.74',
        //          open24h: '65.37',
        //          high24h: '66.15',
        //          low24h: '64.97',
        //          sodUtc0: '65.68',
        //          sodUtc8: '65.54',
        //          ts: '1728467346900'
        //     },
        //
        object timestamp = this.safeInteger(ticker, "ts");
        object marketId = this.safeString(ticker, "instId");
        market = this.safeMarket(marketId, market, "-");
        object symbol = getValue(market, "symbol");
        object last = this.safeString(ticker, "last");
        object open = this.safeString(ticker, "open24h");
        object spot = this.safeBool(market, "spot", false);
        object quoteVolume = ((bool) isTrue(spot)) ? this.safeString(ticker, "volCcy24h") : null;
        object baseVolume = this.safeString(ticker, "vol24h");
        object high = this.safeString(ticker, "high24h");
        object low = this.safeString(ticker, "low24h");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", high },
            { "low", low },
            { "bid", this.safeString(ticker, "bidPx") },
            { "bidVolume", this.safeString(ticker, "bidSz") },
            { "ask", this.safeString(ticker, "askPx") },
            { "askVolume", this.safeString(ticker, "askSz") },
            { "vwap", null },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "markPrice", this.safeString(ticker, "markPx") },
            { "indexPrice", this.safeString(ticker, "idxPx") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name okx#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-get-ticker
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object response = await this.publicGetMarketTicker(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "instType": "SPOT",
        //                 "instId": "ETH-BTC",
        //                 "last": "0.07319",
        //                 "lastSz": "0.044378",
        //                 "askPx": "0.07322",
        //                 "askSz": "4.2",
        //                 "bidPx": "0.0732",
        //                 "bidSz": "6.050058",
        //                 "open24h": "0.07801",
        //                 "high24h": "0.07975",
        //                 "low24h": "0.06019",
        //                 "volCcy24h": "11788.887619",
        //                 "vol24h": "167493.829229",
        //                 "ts": "1621440583784",
        //                 "sodUtc0": "0.07872",
        //                 "sodUtc8": "0.07345"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseTicker(first, market);
    }

    /**
     * @method
     * @name okx#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-get-tickers
     * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object market = this.getMarketFromSymbols(symbols);
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "instType", this.convertToInstrumentType(marketType) },
        };
        if (isTrue(isEqual(marketType, "option")))
        {
            object defaultUnderlying = this.safeString(this.options, "defaultUnderlying", "BTC-USD");
            object currencyId = this.safeString2(parameters, "uly", "marketId", defaultUnderlying);
            if (isTrue(isEqual(currencyId, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchTickers() requires an underlying uly or marketId parameter for options markets")) ;
            } else
            {
                ((IDictionary<string,object>)request)["uly"] = currencyId;
            }
        }
        object response = await this.publicGetMarketTickers(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "instType": "SPOT",
        //                 "instId": "BCD-BTC",
        //                 "last": "0.0000769",
        //                 "lastSz": "5.4788",
        //                 "askPx": "0.0000777",
        //                 "askSz": "3.2197",
        //                 "bidPx": "0.0000757",
        //                 "bidSz": "4.7509",
        //                 "open24h": "0.0000885",
        //                 "high24h": "0.0000917",
        //                 "low24h": "0.0000596",
        //                 "volCcy24h": "9.2877",
        //                 "vol24h": "124824.1985",
        //                 "ts": "1621441741434",
        //                 "sodUtc0": "0.0000905",
        //                 "sodUtc8": "0.0000729"
        //             },
        //         ]
        //     }
        //
        object tickers = this.safeList(response, "data", new List<object>() {});
        return this.parseTickers(tickers, symbols);
    }

    /**
     * @method
     * @name okx#fetchMarkPrice
     * @description fetches mark price for the market
     * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-mark-price
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchMarkPrice(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object response = await this.publicGetPublicMarkPrice(this.extend(request, parameters));
        //
        // {
        //     "code": "0",
        //     "data": [
        //         {
        //             "instId": "ETH-USDT",
        //             "instType": "MARGIN",
        //             "markPx": "2403.98",
        //             "ts": "1728578500703"
        //         }
        //     ],
        //     "msg": ""
        // }
        //
        object data = this.safeList(response, "data");
        return this.parseTicker(this.safeDict(data, 0), market);
    }

    /**
     * @method
     * @name okx#fetchMarkPrices
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-mark-price
     * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchMarkPrices(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object market = this.getMarketFromSymbols(symbols);
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters, "swap");
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "instType", this.convertToInstrumentType(marketType) },
        };
        if (isTrue(isEqual(marketType, "option")))
        {
            object defaultUnderlying = this.safeString(this.options, "defaultUnderlying", "BTC-USD");
            object currencyId = this.safeString2(parameters, "uly", "marketId", defaultUnderlying);
            if (isTrue(isEqual(currencyId, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchMarkPrices() requires an underlying uly or marketId parameter for options markets")) ;
            } else
            {
                ((IDictionary<string,object>)request)["uly"] = currencyId;
            }
        }
        object response = await this.publicGetPublicMarkPrice(this.extend(request, parameters));
        object tickers = this.safeList(response, "data", new List<object>() {});
        return this.parseTickers(tickers, symbols);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public fetchTrades
        //
        //     {
        //         "instId": "ETH-BTC",
        //         "side": "sell",
        //         "sz": "0.119501",
        //         "px": "0.07065",
        //         "tradeId": "15826757",
        //         "ts": "1621446178316"
        //     }
        //
        // option: fetchTrades
        //
        //     {
        //         "fillVol": "0.46387625976562497",
        //         "fwdPx": "26299.754935451125",
        //         "indexPx": "26309.7",
        //         "instFamily": "BTC-USD",
        //         "instId": "BTC-USD-230526-26000-C",
        //         "markPx": "0.042386283557554236",
        //         "optType": "C",
        //         "px": "0.0415",
        //         "side": "sell",
        //         "sz": "90",
        //         "tradeId": "112",
        //         "ts": "1683907480154"
        //     }
        //
        // private fetchMyTrades
        //
        //     {
        //         "side": "buy",
        //         "fillSz": "0.007533",
        //         "fillPx": "2654.98",
        //         "fee": "-0.000007533",
        //         "ordId": "317321390244397056",
        //         "instType": "SPOT",
        //         "instId": "ETH-USDT",
        //         "clOrdId": "",
        //         "posSide": "net",
        //         "billId": "317321390265368576",
        //         "tag": "0",
        //         "execType": "T",
        //         "tradeId": "107601752",
        //         "feeCcy": "ETH",
        //         "ts": "1621927314985"
        //     }
        //
        object id = this.safeString(trade, "tradeId");
        object marketId = this.safeString(trade, "instId");
        market = this.safeMarket(marketId, market, "-");
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger(trade, "ts");
        object price = this.safeString2(trade, "fillPx", "px");
        object amount = this.safeString2(trade, "fillSz", "sz");
        object side = this.safeString(trade, "side");
        object orderId = this.safeString(trade, "ordId");
        object feeCostString = this.safeString(trade, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCostSigned = Precise.stringNeg(feeCostString);
            object feeCurrencyId = this.safeString(trade, "feeCcy");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCostSigned },
                { "currency", feeCurrencyCode },
            };
        }
        object takerOrMaker = this.safeString(trade, "execType");
        if (isTrue(isEqual(takerOrMaker, "T")))
        {
            takerOrMaker = "taker";
        } else if (isTrue(isEqual(takerOrMaker, "M")))
        {
            takerOrMaker = "maker";
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", id },
            { "order", orderId },
            { "type", null },
            { "takerOrMaker", takerOrMaker },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    /**
     * @method
     * @name okx#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-trades
     * @see https://www.okx.com/docs-v5/en/#rest-api-public-data-get-option-trades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.method] 'publicGetMarketTrades' or 'publicGetMarketHistoryTrades' default is 'publicGetMarketTrades'
     * @param {boolean} [params.paginate] *only applies to publicGetMarketHistoryTrades* default false, when true will automatically paginate by calling this endpoint multiple times
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchTrades", symbol, since, limit, parameters, "tradeId", "after", null, 100);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "option")))
        {
            response = await this.publicGetPublicOptionTrades(this.extend(request, parameters));
        } else
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit; // default 100
            }
            object method = null;
            var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchTrades", "method", "publicGetMarketTrades");
            method = ((IList<object>)methodparametersVariable)[0];
            parameters = ((IList<object>)methodparametersVariable)[1];
            if (isTrue(isEqual(method, "publicGetMarketTrades")))
            {
                response = await this.publicGetMarketTrades(this.extend(request, parameters));
            } else if (isTrue(isEqual(method, "publicGetMarketHistoryTrades")))
            {
                response = await this.publicGetMarketHistoryTrades(this.extend(request, parameters));
            }
        }
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {"instId":"ETH-BTC","side":"sell","sz":"0.119501","px":"0.07065","tradeId":"15826757","ts":"1621446178316"},
        //             {"instId":"ETH-BTC","side":"sell","sz":"0.03","px":"0.07068","tradeId":"15826756","ts":"1621446178066"},
        //             {"instId":"ETH-BTC","side":"buy","sz":"0.507","px":"0.07069","tradeId":"15826755","ts":"1621446175085"},
        //         ]
        //     }
        //
        // option
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "fillVol": "0.46387625976562497",
        //                 "fwdPx": "26299.754935451125",
        //                 "indexPx": "26309.7",
        //                 "instFamily": "BTC-USD",
        //                 "instId": "BTC-USD-230526-26000-C",
        //                 "markPx": "0.042386283557554236",
        //                 "optType": "C",
        //                 "px": "0.0415",
        //                 "side": "sell",
        //                 "sz": "90",
        //                 "tradeId": "112",
        //                 "ts": "1683907480154"
        //             },
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         "1678928760000", // timestamp
        //         "24341.4", // open
        //         "24344", // high
        //         "24313.2", // low
        //         "24323", // close
        //         "628", // contract volume
        //         "2.5819", // base volume
        //         "62800", // quote volume
        //         "0" // candlestick state
        //     ]
        //
        object res = this.handleMarketTypeAndParams("fetchOHLCV", market, null);
        object type = getValue(res, 0);
        object volumeIndex = ((bool) isTrue((isEqual(type, "spot")))) ? 5 : 6;
        return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, volumeIndex)};
    }

    /**
     * @method
     * @name okx#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-candlesticks
     * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-candlesticks-history
     * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-mark-price-candlesticks
     * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-mark-price-candlesticks-history
     * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-index-candlesticks
     * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-index-candlesticks-history
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-get-candlesticks-history
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.price] "mark" or "index" for mark price and index price candles
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @param {string} [params.type] "Candles" or "HistoryCandles", default is "Candles" for recent candles, "HistoryCandles" for older candles
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, 200);
        }
        object price = this.safeString(parameters, "price");
        parameters = this.omit(parameters, "price");
        object options = this.safeDict(this.options, "fetchOHLCV", new Dictionary<string, object>() {});
        object timezone = this.safeString(options, "timezone", "UTC");
        object limitIsUndefined = (isEqual(limit, null));
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100; // default 100, max 100
        } else
        {
            limit = mathMin(limit, 300); // max 100
        }
        object duration = this.parseTimeframe(timeframe);
        object bar = this.safeString(this.timeframes, timeframe, timeframe);
        if (isTrue(isTrue((isEqual(timezone, "UTC"))) && isTrue((isGreaterThanOrEqual(duration, 21600)))))
        {
            bar = add(bar, ((string)timezone).ToLower());
        }
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "bar", bar },
            { "limit", limit },
        };
        object defaultType = "Candles";
        if (isTrue(!isEqual(since, null)))
        {
            object now = this.milliseconds();
            object durationInMilliseconds = multiply(duration, 1000);
            // switch to history candles if since is past the cutoff for current candles
            object historyBorder = subtract(now, (multiply((subtract(1440, 1)), durationInMilliseconds)));
            if (isTrue(isLessThan(since, historyBorder)))
            {
                defaultType = "HistoryCandles";
                object maxLimit = ((bool) isTrue((!isEqual(price, null)))) ? 100 : 300;
                limit = mathMin(limit, maxLimit); // max 300 for historical endpoint
            }
            object startTime = mathMax(subtract(since, 1), 0);
            ((IDictionary<string,object>)request)["before"] = startTime;
            ((IDictionary<string,object>)request)["after"] = this.sum(since, multiply(durationInMilliseconds, limit));
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["after"] = until;
            parameters = this.omit(parameters, "until");
        }
        defaultType = this.safeString(options, "type", defaultType); // Candles or HistoryCandles
        object type = this.safeString(parameters, "type", defaultType);
        parameters = this.omit(parameters, "type");
        object isHistoryCandles = (isEqual(type, "HistoryCandles"));
        object response = null;
        if (isTrue(isEqual(price, "mark")))
        {
            if (isTrue(isHistoryCandles))
            {
                response = await this.publicGetMarketHistoryMarkPriceCandles(this.extend(request, parameters));
            } else
            {
                response = await this.publicGetMarketMarkPriceCandles(this.extend(request, parameters));
            }
        } else if (isTrue(isEqual(price, "index")))
        {
            ((IDictionary<string,object>)request)["instId"] = getValue(getValue(market, "info"), "instFamily"); // okx index candles require instFamily instead of instId
            if (isTrue(isHistoryCandles))
            {
                response = await this.publicGetMarketHistoryIndexCandles(this.extend(request, parameters));
            } else
            {
                response = await this.publicGetMarketIndexCandles(this.extend(request, parameters));
            }
        } else
        {
            if (isTrue(isHistoryCandles))
            {
                if (isTrue(isTrue(limitIsUndefined) && isTrue((isEqual(limit, 100)))))
                {
                    limit = 300;
                    ((IDictionary<string,object>)request)["limit"] = 300; // reassign to 300, but this whole logic needs to be simplified...
                }
                response = await this.publicGetMarketHistoryCandles(this.extend(request, parameters));
            } else
            {
                response = await this.publicGetMarketCandles(this.extend(request, parameters));
            }
        }
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             ["1678928760000","24341.4","24344","24313.2","24323","628","2.5819","62800","0"],
        //             ["1678928700000","24324.1","24347.6","24321.7","24341.4","2565","10.5401","256500","1"],
        //             ["1678928640000","24300.2","24324.1","24288","24324.1","3304","13.5937","330400","1"],
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    /**
     * @method
     * @name okx#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-funding-rate-history
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory", symbol, since, limit, "8h", parameters, 100);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["before"] = mathMax(subtract(since, 1), 0);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.publicGetPublicFundingRateHistory(this.extend(request, parameters));
        //
        //     {
        //         "code":"0",
        //         "msg":"",
        //         "data":[
        //             {
        //                 "instType":"SWAP",
        //                 "instId":"BTC-USDT-SWAP",
        //                 "fundingRate":"0.018",
        //                 "realizedRate":"0.017",
        //                 "fundingTime":"1597026383085"
        //             },
        //             {
        //                 "instType":"SWAP",
        //                 "instId":"BTC-USDT-SWAP",
        //                 "fundingRate":"0.018",
        //                 "realizedRate":"0.017",
        //                 "fundingTime":"1597026383085"
        //             }
        //         ]
        //     }
        //
        object rates = new List<object>() {};
        object data = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object rate = getValue(data, i);
            object timestamp = this.safeInteger(rate, "fundingTime");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", rate },
                { "symbol", this.safeSymbol(this.safeString(rate, "instId")) },
                { "fundingRate", this.safeNumber(rate, "realizedRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    public virtual object parseBalanceByType(object type, object response)
    {
        if (isTrue(isEqual(type, "funding")))
        {
            return this.parseFundingBalance(response);
        } else
        {
            return this.parseTradingBalance(response);
        }
    }

    public virtual object parseTradingBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object data = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(first, "uTime");
        object details = this.safeList(first, "details", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(details)); postFixIncrement(ref i))
        {
            object balance = getValue(details, i);
            object currencyId = this.safeString(balance, "ccy");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            // it may be incorrect to use total, free and used for swap accounts
            object eq = this.safeString(balance, "eq");
            object availEq = this.safeString(balance, "availEq");
            ((IDictionary<string,object>)account)["total"] = eq;
            if (isTrue(isEqual(availEq, null)))
            {
                ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "availBal");
                ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "frozenBal");
            } else
            {
                ((IDictionary<string,object>)account)["free"] = availEq;
            }
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        ((IDictionary<string,object>)result)["timestamp"] = timestamp;
        ((IDictionary<string,object>)result)["datetime"] = this.iso8601(timestamp);
        return this.safeBalance(result);
    }

    public virtual object parseFundingBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object data = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object balance = getValue(data, i);
            object currencyId = this.safeString(balance, "ccy");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            // it may be incorrect to use total, free and used for swap accounts
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "bal");
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "availBal");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "frozenBal");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        // https://www.okx.com/docs-v5/en/#rest-api-account-get-fee-rates
        //
        //     {
        //         "category": "1",
        //         "delivery": "",
        //         "exercise": "",
        //         "instType": "SPOT",
        //         "level": "Lv1",
        //         "maker": "-0.0008",
        //         "taker": "-0.001",
        //         "ts": "1639043138472"
        //     }
        //
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", this.safeSymbol(null, market) },
            { "maker", this.parseNumber(Precise.stringNeg(this.safeString2(fee, "maker", "makerU"))) },
            { "taker", this.parseNumber(Precise.stringNeg(this.safeString2(fee, "taker", "takerU"))) },
            { "percentage", null },
            { "tierBased", null },
        };
    }

    /**
     * @method
     * @name okx#fetchTradingFee
     * @description fetch the trading fees for a market
     * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-fee-rates
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instType", this.convertToInstrumentType(getValue(market, "type")) },
        };
        if (isTrue(getValue(market, "spot")))
        {
            ((IDictionary<string,object>)request)["instId"] = getValue(market, "id");
        } else if (isTrue(isTrue(isTrue(getValue(market, "swap")) || isTrue(getValue(market, "future"))) || isTrue(getValue(market, "option"))))
        {
            ((IDictionary<string,object>)request)["uly"] = add(add(getValue(market, "baseId"), "-"), getValue(market, "quoteId"));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchTradingFee() supports spot, swap, future or option markets only")) ;
        }
        object response = await this.privateGetAccountTradeFee(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "category": "1",
        //                 "delivery": "",
        //                 "exercise": "",
        //                 "instType": "SPOT",
        //                 "level": "Lv1",
        //                 "maker": "-0.0008",
        //                 "taker": "-0.001",
        //                 "ts": "1639043138472"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseTradingFee(first, market);
    }

    /**
     * @method
     * @name okx#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-get-balance
     * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-balance
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] wallet type, ['funding' or 'trading'] default is 'trading'
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(isEqual(marketType, "funding")))
        {
            response = await this.privateGetAssetBalances(this.extend(request, query));
        } else
        {
            response = await this.privateGetAccountBalance(this.extend(request, query));
        }
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "adjEq": "",
        //                 "details": [
        //                     {
        //                         "availBal": "",
        //                         "availEq": "28.21006347",
        //                         "cashBal": "28.21006347",
        //                         "ccy": "USDT",
        //                         "crossLiab": "",
        //                         "disEq": "28.2687404020176",
        //                         "eq":"28 .21006347",
        //                         "eqUsd": "28.2687404020176",
        //                         "frozenBal": "0",
        //                         "interest": "",
        //                         "isoEq": "0",
        //                         "isoLiab": "",
        //                         "liab": "",
        //                         "maxLoan": "",
        //                         "mgnRatio": "",
        //                         "notionalLever": "0",
        //                         "ordFrozen": "0",
        //                         "twap": "0",
        //                         "uTime": "1621556539861",
        //                         "upl": "0",
        //                         "uplLiab": ""
        //                     }
        //                 ],
        //                 "imr": "",
        //                 "isoEq": "0",
        //                 "mgnRatio": "",
        //                 "mmr": "",
        //                 "notionalUsd": "",
        //                 "ordFroz": "",
        //                 "totalEq": "28.2687404020176",
        //                 "uTime": "1621556553510"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "adjEq": "",
        //                 "details": [
        //                     {
        //                         "availBal": "0.049",
        //                         "availEq": "",
        //                         "cashBal": "0.049",
        //                         "ccy": "BTC",
        //                         "crossLiab": "",
        //                         "disEq": "1918.55678",
        //                         "eq": "0.049",
        //                         "eqUsd": "1918.55678",
        //                         "frozenBal": "0",
        //                         "interest": "",
        //                         "isoEq": "",
        //                         "isoLiab": "",
        //                         "liab": "",
        //                         "maxLoan": "",
        //                         "mgnRatio": "",
        //                         "notionalLever": "",
        //                         "ordFrozen": "0",
        //                         "twap": "0",
        //                         "uTime": "1621973128591",
        //                         "upl": "",
        //                         "uplLiab": ""
        //                     }
        //                 ],
        //                 "imr": "",
        //                 "isoEq": "",
        //                 "mgnRatio": "",
        //                 "mmr": "",
        //                 "notionalUsd": "",
        //                 "ordFroz": "",
        //                 "totalEq": "1918.55678",
        //                 "uTime": "1622045126908"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        // funding
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "availBal": "0.00005426",
        //                 "bal": 0.0000542600000000,
        //                 "ccy": "BTC",
        //                 "frozenBal": "0"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        return this.parseBalanceByType(marketType, response);
    }

    /**
     * @method
     * @name okx#createMarketBuyOrderWithCost
     * @description create a market buy order by providing the symbol and cost
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-place-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot markets only")) ;
        }
        object req = new Dictionary<string, object>() {
            { "createMarketBuyOrderRequiresPrice", false },
            { "tgtCcy", "quote_ccy" },
        };
        return await this.createOrder(symbol, "market", "buy", cost, null, this.extend(req, parameters));
    }

    /**
     * @method
     * @name okx#createMarketSellOrderWithCost
     * @description create a market buy order by providing the symbol and cost
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-place-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketSellOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketSellOrderWithCost() supports spot markets only")) ;
        }
        object req = new Dictionary<string, object>() {
            { "createMarketBuyOrderRequiresPrice", false },
            { "tgtCcy", "quote_ccy" },
        };
        return await this.createOrder(symbol, "market", "sell", cost, null, this.extend(req, parameters));
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "side", side },
            { "ordType", type },
            { "sz", this.amountToPrecision(symbol, amount) },
        };
        object spot = getValue(market, "spot");
        object contract = getValue(market, "contract");
        object triggerPrice = this.safeValueN(parameters, new List<object>() {"triggerPrice", "stopPrice", "triggerPx"});
        object timeInForce = this.safeString(parameters, "timeInForce", "GTC");
        object takeProfitPrice = this.safeValue2(parameters, "takeProfitPrice", "tpTriggerPx");
        object tpOrdPx = this.safeValue(parameters, "tpOrdPx", price);
        object tpTriggerPxType = this.safeString(parameters, "tpTriggerPxType", "last");
        object stopLossPrice = this.safeValue2(parameters, "stopLossPrice", "slTriggerPx");
        object slOrdPx = this.safeValue(parameters, "slOrdPx", price);
        object slTriggerPxType = this.safeString(parameters, "slTriggerPxType", "last");
        object clientOrderId = this.safeString2(parameters, "clOrdId", "clientOrderId");
        object stopLoss = this.safeValue(parameters, "stopLoss");
        object stopLossDefined = (!isEqual(stopLoss, null));
        object takeProfit = this.safeValue(parameters, "takeProfit");
        object takeProfitDefined = (!isEqual(takeProfit, null));
        object trailingPercent = this.safeString2(parameters, "trailingPercent", "callbackRatio");
        object isTrailingPercentOrder = !isEqual(trailingPercent, null);
        object trailingPrice = this.safeString2(parameters, "trailingPrice", "callbackSpread");
        object isTrailingPriceOrder = !isEqual(trailingPrice, null);
        object trigger = isTrue((!isEqual(triggerPrice, null))) || isTrue((isEqual(type, "trigger")));
        object isReduceOnly = this.safeValue(parameters, "reduceOnly", false);
        object defaultMarginMode = this.safeString2(this.options, "defaultMarginMode", "marginMode", "cross");
        object marginMode = this.safeString2(parameters, "marginMode", "tdMode"); // cross or isolated, tdMode not ommited so as to be extended into the request
        object margin = false;
        if (isTrue(isTrue((!isEqual(marginMode, null))) && isTrue((!isEqual(marginMode, "cash")))))
        {
            margin = true;
        } else
        {
            marginMode = defaultMarginMode;
            margin = this.safeBool(parameters, "margin", false);
        }
        if (isTrue(spot))
        {
            if (isTrue(margin))
            {
                object defaultCurrency = ((bool) isTrue((isEqual(side, "buy")))) ? getValue(market, "quote") : getValue(market, "base");
                object currency = this.safeString(parameters, "ccy", defaultCurrency);
                ((IDictionary<string,object>)request)["ccy"] = this.safeCurrencyCode(currency);
            }
            object tradeMode = ((bool) isTrue(margin)) ? marginMode : "cash";
            ((IDictionary<string,object>)request)["tdMode"] = tradeMode;
        } else if (isTrue(contract))
        {
            if (isTrue(isTrue(getValue(market, "swap")) || isTrue(getValue(market, "future"))))
            {
                object positionSide = null;
                var positionSideparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "positionSide");
                positionSide = ((IList<object>)positionSideparametersVariable)[0];
                parameters = ((IList<object>)positionSideparametersVariable)[1];
                if (isTrue(!isEqual(positionSide, null)))
                {
                    ((IDictionary<string,object>)request)["posSide"] = positionSide;
                } else
                {
                    object hedged = null;
                    var hedgedparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "hedged");
                    hedged = ((IList<object>)hedgedparametersVariable)[0];
                    parameters = ((IList<object>)hedgedparametersVariable)[1];
                    if (isTrue(hedged))
                    {
                        object isBuy = (isEqual(side, "buy"));
                        object isProtective = isTrue(isTrue((!isEqual(takeProfitPrice, null))) || isTrue((!isEqual(stopLossPrice, null)))) || isTrue(isReduceOnly);
                        if (isTrue(isProtective))
                        {
                            // in case of protective orders, the posSide should be opposite of position side
                            // reduceOnly is emulated and not natively supported by the exchange
                            ((IDictionary<string,object>)request)["posSide"] = ((bool) isTrue(isBuy)) ? "short" : "long";
                            if (isTrue(isReduceOnly))
                            {
                                parameters = this.omit(parameters, "reduceOnly");
                            }
                        } else
                        {
                            ((IDictionary<string,object>)request)["posSide"] = ((bool) isTrue(isBuy)) ? "long" : "short";
                        }
                    }
                }
            }
            ((IDictionary<string,object>)request)["tdMode"] = marginMode;
        }
        object isMarketOrder = isEqual(type, "market");
        object postOnly = false;
        var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, isEqual(type, "post_only"), parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        parameters = this.omit(parameters, new List<object>() {"currency", "ccy", "marginMode", "timeInForce", "stopPrice", "triggerPrice", "clientOrderId", "stopLossPrice", "takeProfitPrice", "slOrdPx", "tpOrdPx", "margin", "stopLoss", "takeProfit", "trailingPercent"});
        object ioc = isTrue((isEqual(timeInForce, "IOC"))) || isTrue((isEqual(type, "ioc")));
        object fok = isTrue((isEqual(timeInForce, "FOK"))) || isTrue((isEqual(type, "fok")));
        object conditional = isTrue(isTrue((!isEqual(stopLossPrice, null))) || isTrue((!isEqual(takeProfitPrice, null)))) || isTrue((isEqual(type, "conditional")));
        object marketIOC = isTrue((isTrue(isMarketOrder) && isTrue(ioc))) || isTrue((isEqual(type, "optimal_limit_ioc")));
        object defaultTgtCcy = this.safeString(this.options, "tgtCcy", "base_ccy");
        object tgtCcy = this.safeString(parameters, "tgtCcy", defaultTgtCcy);
        if (isTrue(isTrue((!isTrue(contract))) && isTrue((!isTrue(margin)))))
        {
            ((IDictionary<string,object>)request)["tgtCcy"] = tgtCcy;
        }
        if (isTrue(isTrue(isMarketOrder) || isTrue(marketIOC)))
        {
            ((IDictionary<string,object>)request)["ordType"] = "market";
            if (isTrue(isTrue(spot) && isTrue((isEqual(side, "buy")))))
            {
                // spot market buy: "sz" can refer either to base currency units or to quote currency units
                // see documentation: https://www.okx.com/docs-v5/en/#rest-api-trade-place-order
                if (isTrue(isEqual(tgtCcy, "quote_ccy")))
                {
                    // quote_ccy: sz refers to units of quote currency
                    object createMarketBuyOrderRequiresPrice = true;
                    var createMarketBuyOrderRequiresPriceparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                    createMarketBuyOrderRequiresPrice = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[0];
                    parameters = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[1];
                    object notional = this.safeNumber2(parameters, "cost", "sz");
                    parameters = this.omit(parameters, new List<object>() {"cost", "sz"});
                    if (isTrue(createMarketBuyOrderRequiresPrice))
                    {
                        if (isTrue(!isEqual(price, null)))
                        {
                            if (isTrue(isEqual(notional, null)))
                            {
                                object amountString = this.numberToString(amount);
                                object priceString = this.numberToString(price);
                                object quoteAmount = Precise.stringMul(amountString, priceString);
                                notional = this.parseNumber(quoteAmount);
                            }
                        } else if (isTrue(isEqual(notional, null)))
                        {
                            throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'cost' unified extra parameter or in exchange-specific 'sz' extra parameter (the exchange-specific behaviour)")) ;
                        }
                    } else
                    {
                        notional = ((bool) isTrue((isEqual(notional, null)))) ? amount : notional;
                    }
                    ((IDictionary<string,object>)request)["sz"] = this.costToPrecision(symbol, notional);
                }
            }
            if (isTrue(isTrue(marketIOC) && isTrue(contract)))
            {
                ((IDictionary<string,object>)request)["ordType"] = "optimal_limit_ioc";
            }
        } else
        {
            if (isTrue(isTrue((!isTrue(trigger))) && isTrue((!isTrue(conditional)))))
            {
                ((IDictionary<string,object>)request)["px"] = this.priceToPrecision(symbol, price);
            }
        }
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["ordType"] = "post_only";
        } else if (isTrue(isTrue(ioc) && !isTrue(marketIOC)))
        {
            ((IDictionary<string,object>)request)["ordType"] = "ioc";
        } else if (isTrue(fok))
        {
            ((IDictionary<string,object>)request)["ordType"] = "fok";
        }
        if (isTrue(isTrailingPercentOrder))
        {
            object convertedTrailingPercent = Precise.stringDiv(trailingPercent, "100");
            ((IDictionary<string,object>)request)["callbackRatio"] = convertedTrailingPercent;
            ((IDictionary<string,object>)request)["ordType"] = "move_order_stop";
        } else if (isTrue(isTrailingPriceOrder))
        {
            ((IDictionary<string,object>)request)["callbackSpread"] = trailingPrice;
            ((IDictionary<string,object>)request)["ordType"] = "move_order_stop";
        } else if (isTrue(isTrue(stopLossDefined) || isTrue(takeProfitDefined)))
        {
            object attachAlgoOrd = new Dictionary<string, object>() {};
            if (isTrue(stopLossDefined))
            {
                object stopLossTriggerPrice = this.safeValueN(stopLoss, new List<object>() {"triggerPrice", "stopPrice", "slTriggerPx"});
                if (isTrue(isEqual(stopLossTriggerPrice, null)))
                {
                    throw new InvalidOrder ((string)add(this.id, " createOrder() requires a trigger price in params[\"stopLoss\"][\"triggerPrice\"], or params[\"stopLoss\"][\"stopPrice\"], or params[\"stopLoss\"][\"slTriggerPx\"] for a stop loss order")) ;
                }
                object slTriggerPx = this.priceToPrecision(symbol, stopLossTriggerPrice);
                object slOrder = new Dictionary<string, object>() {};
                ((IDictionary<string,object>)slOrder)["slTriggerPx"] = slTriggerPx;
                object stopLossLimitPrice = this.safeValueN(stopLoss, new List<object>() {"price", "stopLossPrice", "slOrdPx"});
                object stopLossOrderType = this.safeString(stopLoss, "type");
                if (isTrue(!isEqual(stopLossOrderType, null)))
                {
                    object stopLossLimitOrderType = (isEqual(stopLossOrderType, "limit"));
                    object stopLossMarketOrderType = (isEqual(stopLossOrderType, "market"));
                    if (isTrue(isTrue((!isTrue(stopLossLimitOrderType))) && isTrue((!isTrue(stopLossMarketOrderType)))))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() params[\"stopLoss\"][\"type\"] must be either \"limit\" or \"market\"")) ;
                    } else if (isTrue(stopLossLimitOrderType))
                    {
                        if (isTrue(isEqual(stopLossLimitPrice, null)))
                        {
                            throw new InvalidOrder ((string)add(this.id, " createOrder() requires a limit price in params[\"stopLoss\"][\"price\"] or params[\"stopLoss\"][\"slOrdPx\"] for a stop loss limit order")) ;
                        } else
                        {
                            ((IDictionary<string,object>)slOrder)["slOrdPx"] = this.priceToPrecision(symbol, stopLossLimitPrice);
                        }
                    } else if (isTrue(isEqual(stopLossOrderType, "market")))
                    {
                        ((IDictionary<string,object>)slOrder)["slOrdPx"] = "-1";
                    }
                } else if (isTrue(!isEqual(stopLossLimitPrice, null)))
                {
                    ((IDictionary<string,object>)slOrder)["slOrdPx"] = this.priceToPrecision(symbol, stopLossLimitPrice); // limit sl order
                } else
                {
                    ((IDictionary<string,object>)slOrder)["slOrdPx"] = "-1"; // market sl order
                }
                object stopLossTriggerPriceType = this.safeString2(stopLoss, "triggerPriceType", "slTriggerPxType", "last");
                if (isTrue(!isEqual(stopLossTriggerPriceType, null)))
                {
                    if (isTrue(isTrue(isTrue((!isEqual(stopLossTriggerPriceType, "last"))) && isTrue((!isEqual(stopLossTriggerPriceType, "index")))) && isTrue((!isEqual(stopLossTriggerPriceType, "mark")))))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() stop loss trigger price type must be one of \"last\", \"index\" or \"mark\"")) ;
                    }
                    ((IDictionary<string,object>)slOrder)["slTriggerPxType"] = stopLossTriggerPriceType;
                }
                attachAlgoOrd = this.extend(attachAlgoOrd, slOrder);
            }
            if (isTrue(takeProfitDefined))
            {
                object takeProfitTriggerPrice = this.safeValueN(takeProfit, new List<object>() {"triggerPrice", "stopPrice", "tpTriggerPx"});
                if (isTrue(isEqual(takeProfitTriggerPrice, null)))
                {
                    throw new InvalidOrder ((string)add(this.id, " createOrder() requires a trigger price in params[\"takeProfit\"][\"triggerPrice\"], or params[\"takeProfit\"][\"stopPrice\"], or params[\"takeProfit\"][\"tpTriggerPx\"] for a take profit order")) ;
                }
                object tpOrder = new Dictionary<string, object>() {};
                ((IDictionary<string,object>)tpOrder)["tpTriggerPx"] = this.priceToPrecision(symbol, takeProfitTriggerPrice);
                object takeProfitLimitPrice = this.safeValueN(takeProfit, new List<object>() {"price", "takeProfitPrice", "tpOrdPx"});
                object takeProfitOrderType = this.safeString2(takeProfit, "type", "tpOrdKind");
                if (isTrue(!isEqual(takeProfitOrderType, null)))
                {
                    object takeProfitLimitOrderType = (isEqual(takeProfitOrderType, "limit"));
                    object takeProfitMarketOrderType = (isEqual(takeProfitOrderType, "market"));
                    if (isTrue(isTrue((!isTrue(takeProfitLimitOrderType))) && isTrue((!isTrue(takeProfitMarketOrderType)))))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() params[\"takeProfit\"][\"type\"] must be either \"limit\" or \"market\"")) ;
                    } else if (isTrue(takeProfitLimitOrderType))
                    {
                        if (isTrue(isEqual(takeProfitLimitPrice, null)))
                        {
                            throw new InvalidOrder ((string)add(this.id, " createOrder() requires a limit price in params[\"takeProfit\"][\"price\"] or params[\"takeProfit\"][\"tpOrdPx\"] for a take profit limit order")) ;
                        } else
                        {
                            ((IDictionary<string,object>)tpOrder)["tpOrdKind"] = takeProfitOrderType;
                            ((IDictionary<string,object>)tpOrder)["tpOrdPx"] = this.priceToPrecision(symbol, takeProfitLimitPrice);
                        }
                    } else if (isTrue(isEqual(takeProfitOrderType, "market")))
                    {
                        ((IDictionary<string,object>)tpOrder)["tpOrdPx"] = "-1";
                    }
                } else if (isTrue(!isEqual(takeProfitLimitPrice, null)))
                {
                    ((IDictionary<string,object>)tpOrder)["tpOrdKind"] = "limit";
                    ((IDictionary<string,object>)tpOrder)["tpOrdPx"] = this.priceToPrecision(symbol, takeProfitLimitPrice); // limit tp order
                } else
                {
                    ((IDictionary<string,object>)tpOrder)["tpOrdPx"] = "-1"; // market tp order
                }
                object takeProfitTriggerPriceType = this.safeString2(takeProfit, "triggerPriceType", "tpTriggerPxType", "last");
                if (isTrue(!isEqual(takeProfitTriggerPriceType, null)))
                {
                    if (isTrue(isTrue(isTrue((!isEqual(takeProfitTriggerPriceType, "last"))) && isTrue((!isEqual(takeProfitTriggerPriceType, "index")))) && isTrue((!isEqual(takeProfitTriggerPriceType, "mark")))))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() take profit trigger price type must be one of \"last\", \"index\" or \"mark\"")) ;
                    }
                    ((IDictionary<string,object>)tpOrder)["tpTriggerPxType"] = takeProfitTriggerPriceType;
                }
                attachAlgoOrd = this.extend(attachAlgoOrd, tpOrder);
            }
            object attachOrdKeys = new List<object>(((IDictionary<string,object>)attachAlgoOrd).Keys);
            object attachOrdLen = getArrayLength(attachOrdKeys);
            if (isTrue(isGreaterThan(attachOrdLen, 0)))
            {
                ((IDictionary<string,object>)request)["attachAlgoOrds"] = new List<object>() {attachAlgoOrd};
            }
        }
        // algo order details
        if (isTrue(trigger))
        {
            ((IDictionary<string,object>)request)["ordType"] = "trigger";
            ((IDictionary<string,object>)request)["triggerPx"] = this.priceToPrecision(symbol, triggerPrice);
            ((IDictionary<string,object>)request)["orderPx"] = ((bool) isTrue(isMarketOrder)) ? "-1" : this.priceToPrecision(symbol, price);
        } else if (isTrue(conditional))
        {
            ((IDictionary<string,object>)request)["ordType"] = "conditional";
            object twoWayCondition = (isTrue((!isEqual(takeProfitPrice, null))) && isTrue((!isEqual(stopLossPrice, null))));
            // if TP and SL are sent together
            // as ordType 'conditional' only stop-loss order will be applied
            // tpOrdKind is 'condition' which is the default
            if (isTrue(twoWayCondition))
            {
                ((IDictionary<string,object>)request)["ordType"] = "oco";
            }
            if (isTrue(isEqual(side, "sell")))
            {
                request = this.omit(request, "tgtCcy");
            }
            if (isTrue(isEqual(this.safeString(request, "tdMode"), "cash")))
            {
                // for some reason tdMode = cash throws
                // {"code":"1","data":[{"algoClOrdId":"","algoId":"","clOrdId":"","sCode":"51000","sMsg":"Parameter tdMode error ","tag":""}],"msg":""}
                ((IDictionary<string,object>)request)["tdMode"] = marginMode;
            }
            if (isTrue(!isEqual(takeProfitPrice, null)))
            {
                ((IDictionary<string,object>)request)["tpTriggerPx"] = this.priceToPrecision(symbol, takeProfitPrice);
                object tpOrdPxReq = "-1";
                if (isTrue(!isEqual(tpOrdPx, null)))
                {
                    tpOrdPxReq = this.priceToPrecision(symbol, tpOrdPx);
                }
                ((IDictionary<string,object>)request)["tpOrdPx"] = tpOrdPxReq;
                ((IDictionary<string,object>)request)["tpTriggerPxType"] = tpTriggerPxType;
            }
            if (isTrue(!isEqual(stopLossPrice, null)))
            {
                ((IDictionary<string,object>)request)["slTriggerPx"] = this.priceToPrecision(symbol, stopLossPrice);
                object slOrdPxReq = "-1";
                if (isTrue(!isEqual(slOrdPx, null)))
                {
                    slOrdPxReq = this.priceToPrecision(symbol, slOrdPx);
                }
                ((IDictionary<string,object>)request)["slOrdPx"] = slOrdPxReq;
                ((IDictionary<string,object>)request)["slTriggerPxType"] = slTriggerPxType;
            }
        }
        if (isTrue(isEqual(clientOrderId, null)))
        {
            object brokerId = this.safeString(this.options, "brokerId");
            if (isTrue(!isEqual(brokerId, null)))
            {
                ((IDictionary<string,object>)request)["clOrdId"] = add(brokerId, this.uuid16());
                ((IDictionary<string,object>)request)["tag"] = brokerId;
            }
        } else
        {
            ((IDictionary<string,object>)request)["clOrdId"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"clOrdId", "clientOrderId"});
        }
        return this.extend(request, parameters);
    }

    /**
     * @method
     * @name okx#createOrder
     * @description create a trade order
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-place-order
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-place-multiple-orders
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-algo-trading-post-place-algo-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.reduceOnly] a mark to reduce the position size for margin, swap and future orders
     * @param {bool} [params.postOnly] true to place a post only order
     * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
     * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
     * @param {float} [params.takeProfit.price] used for take profit limit orders, not used for take profit market price orders
     * @param {string} [params.takeProfit.type] 'market' or 'limit' used to specify the take profit price type
     * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
     * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
     * @param {float} [params.stopLoss.price] used for stop loss limit orders, not used for stop loss market price orders
     * @param {string} [params.stopLoss.type] 'market' or 'limit' used to specify the stop loss price type
     * @param {string} [params.positionSide] if position mode is one-way: set to 'net', if position mode is hedge-mode: set to 'long' or 'short'
     * @param {string} [params.trailingPercent] the percent to trail away from the current market price
     * @param {string} [params.tpOrdKind] 'condition' or 'limit', the default is 'condition'
     * @param {bool} [params.hedged] *swap and future only* true for hedged mode, false for one way mode
     * @param {string} [params.marginMode] 'cross' or 'isolated', the default is 'cross'
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object method = this.safeString(this.options, "createOrder", "privatePostTradeBatchOrders");
        object requestOrdType = this.safeString(request, "ordType");
        if (isTrue(isTrue(isTrue(isTrue(isTrue(isTrue(isTrue((isEqual(requestOrdType, "trigger"))) || isTrue((isEqual(requestOrdType, "conditional")))) || isTrue((isEqual(requestOrdType, "move_order_stop")))) || isTrue((isEqual(type, "move_order_stop")))) || isTrue((isEqual(type, "oco")))) || isTrue((isEqual(type, "iceberg")))) || isTrue((isEqual(type, "twap")))))
        {
            method = "privatePostTradeOrderAlgo";
        }
        if (isTrue(isTrue(isTrue((!isEqual(method, "privatePostTradeOrder"))) && isTrue((!isEqual(method, "privatePostTradeOrderAlgo")))) && isTrue((!isEqual(method, "privatePostTradeBatchOrders")))))
        {
            throw new ExchangeError ((string)add(this.id, " createOrder() this.options[\"createOrder\"] must be either privatePostTradeBatchOrders or privatePostTradeOrder or privatePostTradeOrderAlgo")) ;
        }
        if (isTrue(isEqual(method, "privatePostTradeBatchOrders")))
        {
            // keep the request body the same
            // submit a single order in an array to the batch order endpoint
            // because it has a lower ratelimit
            request = new List<object>() {request};
        }
        object response = null;
        if (isTrue(isEqual(method, "privatePostTradeOrder")))
        {
            response = await this.privatePostTradeOrder(request);
        } else if (isTrue(isEqual(method, "privatePostTradeOrderAlgo")))
        {
            response = await this.privatePostTradeOrderAlgo(request);
        } else
        {
            response = await this.privatePostTradeBatchOrders(request);
        }
        object data = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
        object order = this.parseOrder(first, market);
        ((IDictionary<string,object>)order)["type"] = type;
        ((IDictionary<string,object>)order)["side"] = side;
        return order;
    }

    /**
     * @method
     * @name okx#createOrders
     * @description create a list of trade orders
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-place-multiple-orders
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object extendedParams = this.extend(orderParams, parameters); // the request does not accept extra params since it's a list, so we're extending each order with the common params
            object orderRequest = this.createOrderRequest(marketId, type, side, amount, price, extendedParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object response = await this.privatePostTradeBatchOrders(ordersRequests);
        // {
        //     "code": "0",
        //     "data": [
        //        {
        //           "clOrdId": "e847386590ce4dBCc7f2a1b4c4509f82",
        //           "ordId": "636305438765568000",
        //           "sCode": "0",
        //           "sMsg": "Order placed",
        //           "tag": "e847386590ce4dBC"
        //        },
        //        {
        //           "clOrdId": "e847386590ce4dBC0b9993fe642d8f62",
        //           "ordId": "636305438765568001",
        //           "sCode": "0",
        //           "sMsg": "Order placed",
        //           "tag": "e847386590ce4dBC"
        //        }
        //     ],
        //     "inTime": "1697979038584486",
        //     "msg": "",
        //     "outTime": "1697979038586493"
        // }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data);
    }

    public virtual object editOrderRequest(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object isAlgoOrder = null;
        if (isTrue(isTrue(isTrue(isTrue(isTrue(isTrue((isEqual(type, "trigger"))) || isTrue((isEqual(type, "conditional")))) || isTrue((isEqual(type, "move_order_stop")))) || isTrue((isEqual(type, "oco")))) || isTrue((isEqual(type, "iceberg")))) || isTrue((isEqual(type, "twap")))))
        {
            isAlgoOrder = true;
        }
        object clientOrderId = this.safeString2(parameters, "clOrdId", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            if (isTrue(isAlgoOrder))
            {
                ((IDictionary<string,object>)request)["algoClOrdId"] = clientOrderId;
            } else
            {
                ((IDictionary<string,object>)request)["clOrdId"] = clientOrderId;
            }
        } else
        {
            if (isTrue(isAlgoOrder))
            {
                ((IDictionary<string,object>)request)["algoId"] = id;
            } else
            {
                ((IDictionary<string,object>)request)["ordId"] = id;
            }
        }
        object stopLossTriggerPrice = this.safeValue2(parameters, "stopLossPrice", "newSlTriggerPx");
        object stopLossPrice = this.safeValue(parameters, "newSlOrdPx");
        object stopLossTriggerPriceType = this.safeString(parameters, "newSlTriggerPxType", "last");
        object takeProfitTriggerPrice = this.safeValue2(parameters, "takeProfitPrice", "newTpTriggerPx");
        object takeProfitPrice = this.safeValue(parameters, "newTpOrdPx");
        object takeProfitTriggerPriceType = this.safeString(parameters, "newTpTriggerPxType", "last");
        object stopLoss = this.safeValue(parameters, "stopLoss");
        object takeProfit = this.safeValue(parameters, "takeProfit");
        object stopLossDefined = (!isEqual(stopLoss, null));
        object takeProfitDefined = (!isEqual(takeProfit, null));
        if (isTrue(isAlgoOrder))
        {
            if (isTrue(isTrue((isEqual(stopLossTriggerPrice, null))) && isTrue((isEqual(takeProfitTriggerPrice, null)))))
            {
                throw new BadRequest ((string)add(this.id, " editOrder() requires a stopLossPrice or takeProfitPrice parameter for editing an algo order")) ;
            }
            if (isTrue(!isEqual(stopLossTriggerPrice, null)))
            {
                if (isTrue(isEqual(stopLossPrice, null)))
                {
                    throw new BadRequest ((string)add(this.id, " editOrder() requires a newSlOrdPx parameter for editing an algo order")) ;
                }
                ((IDictionary<string,object>)request)["newSlTriggerPx"] = this.priceToPrecision(symbol, stopLossTriggerPrice);
                ((IDictionary<string,object>)request)["newSlOrdPx"] = ((bool) isTrue((isEqual(type, "market")))) ? "-1" : this.priceToPrecision(symbol, stopLossPrice);
                ((IDictionary<string,object>)request)["newSlTriggerPxType"] = stopLossTriggerPriceType;
            }
            if (isTrue(!isEqual(takeProfitTriggerPrice, null)))
            {
                if (isTrue(isEqual(takeProfitPrice, null)))
                {
                    throw new BadRequest ((string)add(this.id, " editOrder() requires a newTpOrdPx parameter for editing an algo order")) ;
                }
                ((IDictionary<string,object>)request)["newTpTriggerPx"] = this.priceToPrecision(symbol, takeProfitTriggerPrice);
                ((IDictionary<string,object>)request)["newTpOrdPx"] = ((bool) isTrue((isEqual(type, "market")))) ? "-1" : this.priceToPrecision(symbol, takeProfitPrice);
                ((IDictionary<string,object>)request)["newTpTriggerPxType"] = takeProfitTriggerPriceType;
            }
        } else
        {
            if (isTrue(!isEqual(stopLossTriggerPrice, null)))
            {
                ((IDictionary<string,object>)request)["newSlTriggerPx"] = this.priceToPrecision(symbol, stopLossTriggerPrice);
                ((IDictionary<string,object>)request)["newSlOrdPx"] = ((bool) isTrue((isEqual(type, "market")))) ? "-1" : this.priceToPrecision(symbol, stopLossPrice);
                ((IDictionary<string,object>)request)["newSlTriggerPxType"] = stopLossTriggerPriceType;
            }
            if (isTrue(!isEqual(takeProfitTriggerPrice, null)))
            {
                ((IDictionary<string,object>)request)["newTpTriggerPx"] = this.priceToPrecision(symbol, takeProfitTriggerPrice);
                ((IDictionary<string,object>)request)["newTpOrdPx"] = ((bool) isTrue((isEqual(type, "market")))) ? "-1" : this.priceToPrecision(symbol, takeProfitPrice);
                ((IDictionary<string,object>)request)["newTpTriggerPxType"] = takeProfitTriggerPriceType;
            }
            if (isTrue(stopLossDefined))
            {
                stopLossTriggerPrice = this.safeValue(stopLoss, "triggerPrice");
                stopLossPrice = this.safeValue(stopLoss, "price");
                object stopLossType = this.safeString(stopLoss, "type");
                ((IDictionary<string,object>)request)["newSlTriggerPx"] = this.priceToPrecision(symbol, stopLossTriggerPrice);
                ((IDictionary<string,object>)request)["newSlOrdPx"] = ((bool) isTrue((isEqual(stopLossType, "market")))) ? "-1" : this.priceToPrecision(symbol, stopLossPrice);
                ((IDictionary<string,object>)request)["newSlTriggerPxType"] = stopLossTriggerPriceType;
            }
            if (isTrue(takeProfitDefined))
            {
                takeProfitTriggerPrice = this.safeValue(takeProfit, "triggerPrice");
                takeProfitPrice = this.safeValue(takeProfit, "price");
                object takeProfitType = this.safeString(takeProfit, "type");
                ((IDictionary<string,object>)request)["newTpOrdKind"] = ((bool) isTrue((isEqual(takeProfitType, "limit")))) ? takeProfitType : "condition";
                ((IDictionary<string,object>)request)["newTpTriggerPx"] = this.priceToPrecision(symbol, takeProfitTriggerPrice);
                ((IDictionary<string,object>)request)["newTpOrdPx"] = ((bool) isTrue((isEqual(takeProfitType, "market")))) ? "-1" : this.priceToPrecision(symbol, takeProfitPrice);
                ((IDictionary<string,object>)request)["newTpTriggerPxType"] = takeProfitTriggerPriceType;
            }
        }
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["newSz"] = this.amountToPrecision(symbol, amount);
        }
        if (!isTrue(isAlgoOrder))
        {
            if (isTrue(!isEqual(price, null)))
            {
                ((IDictionary<string,object>)request)["newPx"] = this.priceToPrecision(symbol, price);
            }
        }
        parameters = this.omit(parameters, new List<object>() {"clOrdId", "clientOrderId", "takeProfitPrice", "stopLossPrice", "stopLoss", "takeProfit", "postOnly"});
        return this.extend(request, parameters);
    }

    /**
     * @method
     * @name okx#editOrder
     * @description edit a trade order
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-amend-order
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-algo-trading-post-amend-algo-order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of the currency you want to trade in units of the base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] client order id, uses id if not passed
     * @param {float} [params.stopLossPrice] stop loss trigger price
     * @param {float} [params.newSlOrdPx] the stop loss order price, set to stopLossPrice if the type is market
     * @param {string} [params.newSlTriggerPxType] 'last', 'index' or 'mark' used to specify the stop loss trigger price type, default is 'last'
     * @param {float} [params.takeProfitPrice] take profit trigger price
     * @param {float} [params.newTpOrdPx] the take profit order price, set to takeProfitPrice if the type is market
     * @param {string} [params.newTpTriggerPxType] 'last', 'index' or 'mark' used to specify the take profit trigger price type, default is 'last'
     * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered
     * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
     * @param {float} [params.stopLoss.price] used for stop loss limit orders, not used for stop loss market price orders
     * @param {string} [params.stopLoss.type] 'market' or 'limit' used to specify the stop loss price type
     * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered
     * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
     * @param {float} [params.takeProfit.price] used for take profit limit orders, not used for take profit market price orders
     * @param {string} [params.takeProfit.type] 'market' or 'limit' used to specify the take profit price type
     * @param {string} [params.newTpOrdKind] 'condition' or 'limit', the default is 'condition'
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = this.editOrderRequest(id, symbol, type, side, amount, price, parameters);
        object isAlgoOrder = null;
        if (isTrue(isTrue(isTrue(isTrue(isTrue(isTrue((isEqual(type, "trigger"))) || isTrue((isEqual(type, "conditional")))) || isTrue((isEqual(type, "move_order_stop")))) || isTrue((isEqual(type, "oco")))) || isTrue((isEqual(type, "iceberg")))) || isTrue((isEqual(type, "twap")))))
        {
            isAlgoOrder = true;
        }
        object response = null;
        if (isTrue(isAlgoOrder))
        {
            response = await this.privatePostTradeAmendAlgos(this.extend(request, parameters));
        } else
        {
            response = await this.privatePostTradeAmendOrder(this.extend(request, parameters));
        }
        //
        //     {
        //        "code": "0",
        //        "data": [
        //            {
        //                 "clOrdId": "e847386590ce4dBCc1a045253497a547",
        //                 "ordId": "559176536793178112",
        //                 "reqId": "",
        //                 "sCode": "0",
        //                 "sMsg": ""
        //            }
        //        ],
        //        "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
        object order = this.parseOrder(first, market);
        ((IDictionary<string,object>)order)["type"] = type;
        ((IDictionary<string,object>)order)["side"] = side;
        return order;
    }

    /**
     * @method
     * @name okx#cancelOrder
     * @description cancels an open order
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-cancel-order
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-algo-trading-post-cancel-algo-order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.trigger] true if trigger orders
     * @param {boolean} [params.trailing] set to true if you want to cancel a trailing order
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        object trigger = this.safeValue2(parameters, "stop", "trigger");
        object trailing = this.safeBool(parameters, "trailing", false);
        if (isTrue(isTrue(trigger) || isTrue(trailing)))
        {
            object orderInner = await this.cancelOrders(new List<object>() {id}, symbol, parameters);
            return this.safeDict(orderInner, 0);
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object clientOrderId = this.safeString2(parameters, "clOrdId", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clOrdId"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["ordId"] = id;
        }
        object query = this.omit(parameters, new List<object>() {"clOrdId", "clientOrderId"});
        object response = await this.privatePostTradeCancelOrder(this.extend(request, query));
        // {"code":"0","data":[{"clOrdId":"","ordId":"317251910906576896","sCode":"0","sMsg":""}],"msg":""}
        object data = this.safeValue(response, "data", new List<object>() {});
        object order = this.safeDict(data, 0);
        return this.parseOrder(order, market);
    }

    public virtual object parseIds(object ids)
    {
        /**
         * @ignore
         * @method
         * @name okx#parseIds
         * @param {string[]|string} ids order ids
         * @returns {string[]} list of order ids
         */
        if (isTrue(isTrue((!isEqual(ids, null))) && isTrue((ids is string))))
        {
            return ((string)ids).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
        } else
        {
            return ids;
        }
    }

    /**
     * @method
     * @name okx#cancelOrders
     * @description cancel multiple orders
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-cancel-multiple-orders
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-algo-trading-post-cancel-algo-order
     * @param {string[]} ids order ids
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.trigger] whether the order is a stop/trigger order
     * @param {boolean} [params.trailing] set to true if you want to cancel trailing orders
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        // TODO : the original endpoint signature differs, according to that you can skip individual symbol and assign ids in batch. At this moment, `params` is not being used too.
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new List<object>() {};
        object options = this.safeValue(this.options, "cancelOrders", new Dictionary<string, object>() {});
        object defaultMethod = this.safeString(options, "method", "privatePostTradeCancelBatchOrders");
        object method = this.safeString(parameters, "method", defaultMethod);
        object clientOrderIds = this.parseIds(this.safeValue2(parameters, "clOrdId", "clientOrderId"));
        object algoIds = this.parseIds(this.safeValue(parameters, "algoId"));
        object trigger = this.safeValue2(parameters, "stop", "trigger");
        object trailing = this.safeBool(parameters, "trailing", false);
        if (isTrue(isTrue(trigger) || isTrue(trailing)))
        {
            method = "privatePostTradeCancelAlgos";
        }
        if (isTrue(isEqual(clientOrderIds, null)))
        {
            ids = this.parseIds(ids);
            if (isTrue(!isEqual(algoIds, null)))
            {
                for (object i = 0; isLessThan(i, getArrayLength(algoIds)); postFixIncrement(ref i))
                {
                    ((IList<object>)request).Add(new Dictionary<string, object>() {
                        { "algoId", getValue(algoIds, i) },
                        { "instId", getValue(market, "id") },
                    });
                }
            }
            for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
            {
                if (isTrue(isTrue(trailing) || isTrue(trigger)))
                {
                    ((IList<object>)request).Add(new Dictionary<string, object>() {
                        { "algoId", getValue(ids, i) },
                        { "instId", getValue(market, "id") },
                    });
                } else
                {
                    ((IList<object>)request).Add(new Dictionary<string, object>() {
                        { "ordId", getValue(ids, i) },
                        { "instId", getValue(market, "id") },
                    });
                }
            }
        } else
        {
            for (object i = 0; isLessThan(i, getArrayLength(clientOrderIds)); postFixIncrement(ref i))
            {
                ((IList<object>)request).Add(new Dictionary<string, object>() {
                    { "instId", getValue(market, "id") },
                    { "clOrdId", getValue(clientOrderIds, i) },
                });
            }
        }
        object response = null;
        if (isTrue(isEqual(method, "privatePostTradeCancelAlgos")))
        {
            response = await this.privatePostTradeCancelAlgos(request); // * dont extend with params, otherwise ARRAY will be turned into OBJECT
        } else
        {
            response = await this.privatePostTradeCancelBatchOrders(request); // * dont extend with params, otherwise ARRAY will be turned into OBJECT
        }
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "clOrdId": "e123456789ec4dBC1123456ba123b45e",
        //                 "ordId": "405071912345641543",
        //                 "sCode": "0",
        //                 "sMsg": ""
        //             },
        //             ...
        //         ],
        //         "msg": ""
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "algoId": "431375349042380800",
        //                 "sCode": "0",
        //                 "sMsg": ""
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object ordersData = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(ordersData, market, null, null, parameters);
    }

    /**
     * @method
     * @name okx#cancelOrdersForSymbols
     * @description cancel multiple orders for multiple symbols
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-cancel-multiple-orders
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-algo-trading-post-cancel-algo-order
     * @param {CancellationRequest[]} orders each order should contain the parameters required by cancelOrder namely id and symbol, example [{"id": "a", "symbol": "BTC/USDT"}, {"id": "b", "symbol": "ETH/USDT"}]
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.trigger] whether the order is a stop/trigger order
     * @param {boolean} [params.trailing] set to true if you want to cancel trailing orders
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrdersForSymbols(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new List<object>() {};
        object options = this.safeDict(this.options, "cancelOrders", new Dictionary<string, object>() {});
        object defaultMethod = this.safeString(options, "method", "privatePostTradeCancelBatchOrders");
        object method = this.safeString(parameters, "method", defaultMethod);
        object trigger = this.safeBool2(parameters, "stop", "trigger");
        object trailing = this.safeBool(parameters, "trailing", false);
        object isStopOrTrailing = isTrue(trigger) || isTrue(trailing);
        if (isTrue(isStopOrTrailing))
        {
            method = "privatePostTradeCancelAlgos";
        }
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object order = getValue(orders, i);
            object id = this.safeString(order, "id");
            object clientOrderId = this.safeString2(order, "clOrdId", "clientOrderId");
            object symbol = this.safeString(order, "symbol");
            object market = this.market(symbol);
            object idKey = "ordId";
            if (isTrue(isStopOrTrailing))
            {
                idKey = "algoId";
            } else if (isTrue(!isEqual(clientOrderId, null)))
            {
                idKey = "clOrdId";
            }
            object requestItem = new Dictionary<string, object>() {
                { "instId", getValue(market, "id") },
            };
            ((IDictionary<string,object>)requestItem)[(string)idKey] = ((bool) isTrue((!isEqual(clientOrderId, null)))) ? clientOrderId : id;
            ((IList<object>)request).Add(requestItem);
        }
        object response = null;
        if (isTrue(isEqual(method, "privatePostTradeCancelAlgos")))
        {
            response = await this.privatePostTradeCancelAlgos(request); // * dont extend with params, otherwise ARRAY will be turned into OBJECT
        } else
        {
            response = await this.privatePostTradeCancelBatchOrders(request); // * dont extend with params, otherwise ARRAY will be turned into OBJECT
        }
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "clOrdId": "e123456789ec4dBC1123456ba123b45e",
        //                 "ordId": "405071912345641543",
        //                 "sCode": "0",
        //                 "sMsg": ""
        //             },
        //             ...
        //         ],
        //         "msg": ""
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "algoId": "431375349042380800",
        //                 "sCode": "0",
        //                 "sMsg": ""
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object ordersData = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(ordersData, null, null, null, parameters);
    }

    /**
     * @method
     * @name okx#cancelAllOrdersAfter
     * @description dead man's switch, cancel all orders after the given timeout
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-cancel-all-after
     * @param {number} timeout time in milliseconds, 0 represents cancel the timer
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} the api result
     */
    public async override Task<object> cancelAllOrdersAfter(object timeout, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "timeOut", ((bool) isTrue((isGreaterThan(timeout, 0)))) ? this.parseToInt(divide(timeout, 1000)) : 0 },
        };
        object response = await this.privatePostTradeCancelAllAfter(this.extend(request, parameters));
        //
        //     {
        //         "code":"0",
        //         "msg":"",
        //         "data":[
        //             {
        //                 "triggerTime":"1587971460",
        //                 "ts":"1587971400"
        //             }
        //         ]
        //     }
        //
        return response;
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "canceled", "canceled" },
            { "order_failed", "canceled" },
            { "live", "open" },
            { "partially_filled", "open" },
            { "filled", "closed" },
            { "effective", "closed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //
        //     {
        //         "clOrdId": "oktswap6",
        //         "ordId": "312269865356374016",
        //         "tag": "",
        //         "sCode": "0",
        //         "sMsg": ""
        //     }
        //
        // editOrder
        //
        //     {
        //         "clOrdId": "e847386590ce4dBCc1a045253497a547",
        //         "ordId": "559176536793178112",
        //         "reqId": "",
        //         "sCode": "0",
        //         "sMsg": ""
        //     }
        //
        // Spot and Swap fetchOrder, fetchOpenOrders
        //
        //     {
        //         "accFillSz": "0",
        //         "avgPx": "",
        //         "cTime": "1621910749815",
        //         "category": "normal",
        //         "ccy": "",
        //         "clOrdId": "",
        //         "fee": "0",
        //         "feeCcy": "ETH",
        //         "fillPx": "",
        //         "fillSz": "0",
        //         "fillTime": "",
        //         "instId": "ETH-USDT",
        //         "instType": "SPOT",
        //         "lever": "",
        //         "ordId": "317251910906576896",
        //         "ordType": "limit",
        //         "pnl": "0",
        //         "posSide": "net",
        //         "px": "2000",
        //         "rebate": "0",
        //         "rebateCcy": "USDT",
        //         "side": "buy",
        //         "slOrdPx": "",
        //         "slTriggerPx": "",
        //         "state": "live",
        //         "sz": "0.001",
        //         "tag": "",
        //         "tdMode": "cash",
        //         "tpOrdPx": "",
        //         "tpTriggerPx": "",
        //         "tradeId": "",
        //         "uTime": "1621910749815"
        //     }
        //
        // watchOrders & fetchClosedOrders
        //
        //    {
        //        "algoClOrdId": "",
        //        "algoId": "",
        //        "attachAlgoClOrdId": "",
        //        "attachAlgoOrds": [],
        //        "cancelSource": "",
        //        "cancelSourceReason": "", // not present in WS, but present in fetchClosedOrders
        //        "category": "normal",
        //        "ccy": "", // empty in WS, but eg. `USDT` in fetchClosedOrders
        //        "clOrdId": "",
        //        "cTime": "1751705801423",
        //        "feeCcy": "USDT",
        //        "instId": "LINK-USDT-SWAP",
        //        "instType": "SWAP",
        //        "isTpLimit": "false",
        //        "lever": "3",
        //        "linkedAlgoOrd": { "algoId": "" },
        //        "ordId": "2657625147249614848",
        //        "ordType": "limit",
        //        "posSide": "net",
        //        "px": "13.142",
        //        "pxType": "",
        //        "pxUsd": "",
        //        "pxVol": "",
        //        "quickMgnType": "",
        //        "rebate": "0",
        //        "rebateCcy": "USDT",
        //        "reduceOnly": "true",
        //        "side": "sell",
        //        "slOrdPx": "",
        //        "slTriggerPx": "",
        //        "slTriggerPxType": "",
        //        "source": "",
        //        "stpId": "",
        //        "stpMode": "cancel_maker",
        //        "sz": "0.1",
        //        "tag": "",
        //        "tdMode": "isolated",
        //        "tgtCcy": "",
        //        "tpOrdPx": "",
        //        "tpTriggerPx": "",
        //        "tpTriggerPxType": "",
        //        "uTime": "1751705807467",
        //        "reqId": "",                      // field present only in WS
        //        "msg": "",                        // field present only in WS
        //        "amendResult": "",                // field present only in WS
        //        "amendSource": "",                // field present only in WS
        //        "code": "0",                      // field present only in WS
        //        "fillFwdPx": "",                  // field present only in WS
        //        "fillMarkVol": "",                // field present only in WS
        //        "fillPxUsd": "",                  // field present only in WS
        //        "fillPxVol": "",                  // field present only in WS
        //        "lastPx": "13.142",               // field present only in WS
        //        "notionalUsd": "1.314515408",     // field present only in WS
        //
        //     #### these below fields are empty on first omit from websocket, because of "creation" event. however, if order is executed, it also immediately sends another update with these fields filled  ###
        //
        //        "pnl": "-0.0001",
        //        "accFillSz": "0.1",
        //        "avgPx": "13.142",
        //        "state": "filled",
        //        "fee": "-0.00026284",
        //        "fillPx": "13.142",
        //        "tradeId": "293429690",
        //        "fillSz": "0.1",
        //        "fillTime": "1751705807467",
        //        "fillNotionalUsd": "1.314515408", // field present only in WS
        //        "fillPnl": "-0.0001",             // field present only in WS
        //        "fillFee": "-0.00026284",         // field present only in WS
        //        "fillFeeCcy": "USDT",             // field present only in WS
        //        "execType": "M",                  // field present only in WS
        //        "fillMarkPx": "13.141",           // field present only in WS
        //        "fillIdxPx": "13.147"             // field present only in WS
        //    }
        //
        //
        // Algo Order fetchOpenOrders, fetchCanceledOrders, fetchClosedOrders
        //
        //     {
        //         "activePx": "",
        //         "activePxType": "",
        //         "actualPx": "",
        //         "actualSide": "buy",
        //         "actualSz": "0",
        //         "algoId": "431375349042380800",
        //         "cTime": "1649119897778",
        //         "callbackRatio": "",
        //         "callbackSpread": "",
        //         "ccy": "",
        //         "ctVal": "0.01",
        //         "instId": "BTC-USDT-SWAP",
        //         "instType": "SWAP",
        //         "last": "46538.9",
        //         "lever": "125",
        //         "moveTriggerPx": "",
        //         "notionalUsd": "467.059",
        //         "ordId": "",
        //         "ordPx": "50000",
        //         "ordType": "trigger",
        //         "posSide": "long",
        //         "pxLimit": "",
        //         "pxSpread": "",
        //         "pxVar": "",
        //         "side": "buy",
        //         "slOrdPx": "",
        //         "slTriggerPx": "",
        //         "slTriggerPxType": "",
        //         "state": "live",
        //         "sz": "1",
        //         "szLimit": "",
        //         "tag": "",
        //         "tdMode": "isolated",
        //         "tgtCcy": "",
        //         "timeInterval": "",
        //         "tpOrdPx": "",
        //         "tpTriggerPx": "",
        //         "tpTriggerPxType": "",
        //         "triggerPx": "50000",
        //         "triggerPxType": "last",
        //         "triggerTime": "",
        //         "uly": "BTC-USDT"
        //     }
        //
        object scode = this.safeString(order, "sCode");
        if (isTrue(isTrue((!isEqual(scode, null))) && isTrue((!isEqual(scode, "0")))))
        {
            return this.safeOrder(new Dictionary<string, object>() {
                { "id", this.safeString(order, "ordId") },
                { "clientOrderId", this.safeString(order, "clOrdId") },
                { "status", "rejected" },
                { "info", order },
            });
        }
        object id = this.safeString2(order, "algoId", "ordId");
        object timestamp = this.safeInteger(order, "cTime");
        object lastUpdateTimestamp = this.safeInteger(order, "uTime");
        object lastTradeTimestamp = this.safeInteger(order, "fillTime");
        object side = this.safeString(order, "side");
        object type = this.safeString(order, "ordType");
        object postOnly = null;
        object timeInForce = null;
        if (isTrue(isEqual(type, "post_only")))
        {
            postOnly = true;
            type = "limit";
        } else if (isTrue(isEqual(type, "fok")))
        {
            timeInForce = "FOK";
            type = "limit";
        } else if (isTrue(isEqual(type, "ioc")))
        {
            timeInForce = "IOC";
            type = "limit";
        }
        object marketId = this.safeString(order, "instId");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeSymbol(marketId, market, "-");
        object filled = this.safeString(order, "accFillSz");
        object price = this.safeString2(order, "px", "ordPx");
        object average = this.safeString(order, "avgPx");
        object status = this.parseOrderStatus(this.safeString(order, "state"));
        object feeCostString = this.safeString(order, "fee");
        object amount = null;
        object cost = null;
        // spot market buy: "sz" can refer either to base currency units or to quote currency units
        // see documentation: https://www.okx.com/docs-v5/en/#rest-api-trade-place-order
        object defaultTgtCcy = this.safeString(this.options, "tgtCcy", "base_ccy");
        object tgtCcy = this.safeString(order, "tgtCcy", defaultTgtCcy);
        object instType = this.safeString(order, "instType");
        if (isTrue(isTrue(isTrue(isTrue((isEqual(side, "buy"))) && isTrue((isEqual(type, "market")))) && isTrue((isEqual(instType, "SPOT")))) && isTrue((isEqual(tgtCcy, "quote_ccy")))))
        {
            // "sz" refers to the cost
            cost = this.safeString(order, "sz");
        } else
        {
            // "sz" refers to the trade currency amount
            amount = this.safeString(order, "sz");
        }
        object fee = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCostSigned = Precise.stringNeg(feeCostString);
            object feeCurrencyId = this.safeString(order, "feeCcy");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(feeCostSigned) },
                { "currency", feeCurrencyCode },
            };
        }
        object clientOrderId = this.safeString(order, "clOrdId");
        if (isTrue(isTrue((!isEqual(clientOrderId, null))) && isTrue((isLessThan(((string)clientOrderId).Length, 1)))))
        {
            clientOrderId = null; // fix empty clientOrderId string
        }
        object stopLossPrice = this.safeNumber2(order, "slTriggerPx", "slOrdPx");
        object takeProfitPrice = this.safeNumber2(order, "tpTriggerPx", "tpOrdPx");
        object reduceOnlyRaw = this.safeString(order, "reduceOnly");
        object reduceOnly = false;
        if (isTrue(!isEqual(reduceOnly, null)))
        {
            reduceOnly = (isEqual(reduceOnlyRaw, "true"));
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "lastUpdateTimestamp", lastUpdateTimestamp },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "side", side },
            { "price", price },
            { "stopLossPrice", stopLossPrice },
            { "takeProfitPrice", takeProfitPrice },
            { "triggerPrice", this.safeNumberN(order, new List<object>() {"triggerPx", "moveTriggerPx"}) },
            { "average", average },
            { "cost", cost },
            { "amount", amount },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", fee },
            { "trades", null },
            { "reduceOnly", reduceOnly },
        }, market);
    }

    /**
     * @method
     * @name okx#fetchOrder
     * @description fetch an order by the id
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-get-order-details
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-algo-trading-get-algo-order-details
     * @param {string} id the order id
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra and exchange specific parameters
     * @param {boolean} [params.trigger] true if fetching trigger orders
     * @returns [an order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object clientOrderId = this.safeString2(parameters, "clOrdId", "clientOrderId");
        object options = this.safeValue(this.options, "fetchOrder", new Dictionary<string, object>() {});
        object defaultMethod = this.safeString(options, "method", "privateGetTradeOrder");
        object method = this.safeString(parameters, "method", defaultMethod);
        object trigger = this.safeValue2(parameters, "stop", "trigger");
        if (isTrue(trigger))
        {
            method = "privateGetTradeOrderAlgo";
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["algoClOrdId"] = clientOrderId;
            } else
            {
                ((IDictionary<string,object>)request)["algoId"] = id;
            }
        } else
        {
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["clOrdId"] = clientOrderId;
            } else
            {
                ((IDictionary<string,object>)request)["ordId"] = id;
            }
        }
        object query = this.omit(parameters, new List<object>() {"method", "clOrdId", "clientOrderId", "stop", "trigger"});
        object response = null;
        if (isTrue(isEqual(method, "privateGetTradeOrderAlgo")))
        {
            response = await this.privateGetTradeOrderAlgo(this.extend(request, query));
        } else
        {
            response = await this.privateGetTradeOrder(this.extend(request, query));
        }
        //
        // Spot and Swap
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "accFillSz": "0",
        //                 "avgPx": "",
        //                 "cTime": "1621910749815",
        //                 "category": "normal",
        //                 "ccy": "",
        //                 "clOrdId": "",
        //                 "fee": "0",
        //                 "feeCcy": "ETH",
        //                 "fillPx": "",
        //                 "fillSz": "0",
        //                 "fillTime": "",
        //                 "instId": "ETH-USDT",
        //                 "instType": "SPOT",
        //                 "lever": "",
        //                 "ordId": "317251910906576896",
        //                 "ordType": "limit",
        //                 "pnl": "0",
        //                 "posSide": "net",
        //                 "px":"20 00",
        //                 "rebate": "0",
        //                 "rebateCcy": "USDT",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "state": "live",
        //                 "sz":"0. 001",
        //                 "tag": "",
        //                 "tdMode": "cash",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tradeId": "",
        //                 "uTime": "1621910749815"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        // Algo order
        //     {
        //         "code":"0",
        //         "msg":"",
        //         "data":[
        //             {
        //                 "instType":"FUTURES",
        //                 "instId":"BTC-USD-200329",
        //                 "ordId":"123445",
        //                 "ccy":"BTC",
        //                 "clOrdId":"",
        //                 "algoId":"1234",
        //                 "sz":"999",
        //                 "closeFraction":"",
        //                 "ordType":"oco",
        //                 "side":"buy",
        //                 "posSide":"long",
        //                 "tdMode":"cross",
        //                 "tgtCcy": "",
        //                 "state":"effective",
        //                 "lever":"20",
        //                 "tpTriggerPx":"",
        //                 "tpTriggerPxType":"",
        //                 "tpOrdPx":"",
        //                 "slTriggerPx":"",
        //                 "slTriggerPxType":"",
        //                 "triggerPx":"99",
        //                 "triggerPxType":"last",
        //                 "ordPx":"12",
        //                 "actualSz":"",
        //                 "actualPx":"",
        //                 "actualSide":"",
        //                 "pxVar":"",
        //                 "pxSpread":"",
        //                 "pxLimit":"",
        //                 "szLimit":"",
        //                 "tag": "adadadadad",
        //                 "timeInterval":"",
        //                 "callbackRatio":"",
        //                 "callbackSpread":"",
        //                 "activePx":"",
        //                 "moveTriggerPx":"",
        //                 "reduceOnly": "false",
        //                 "triggerTime":"1597026383085",
        //                 "last": "16012",
        //                 "failCode": "",
        //                 "algoClOrdId": "",
        //                 "cTime":"1597026383000"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object order = this.safeDict(data, 0);
        return this.parseOrder(order, market);
    }

    /**
     * @method
     * @name okx#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-get-order-list
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-algo-trading-get-algo-order-list
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of  open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.trigger] True if fetching trigger or conditional orders
     * @param {string} [params.ordType] "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"
     * @param {string} [params.algoId] Algo ID "'433845797218942976'"
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchOpenOrders", symbol, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instId"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 100
        }
        object options = this.safeValue(this.options, "fetchOpenOrders", new Dictionary<string, object>() {});
        object algoOrderTypes = this.safeValue(this.options, "algoOrderTypes", new Dictionary<string, object>() {});
        object defaultMethod = this.safeString(options, "method", "privateGetTradeOrdersPending");
        object method = this.safeString(parameters, "method", defaultMethod);
        object ordType = this.safeString(parameters, "ordType");
        object trigger = this.safeValue2(parameters, "stop", "trigger");
        object trailing = this.safeBool(parameters, "trailing", false);
        if (isTrue(isTrue(isTrue(trailing) || isTrue(trigger)) || isTrue((inOp(algoOrderTypes, ordType)))))
        {
            method = "privateGetTradeOrdersAlgoPending";
        }
        if (isTrue(trailing))
        {
            ((IDictionary<string,object>)request)["ordType"] = "move_order_stop";
        } else if (isTrue(isTrue(trigger) && isTrue((isEqual(ordType, null)))))
        {
            ((IDictionary<string,object>)request)["ordType"] = "trigger";
        }
        object query = this.omit(parameters, new List<object>() {"method", "stop", "trigger", "trailing"});
        object response = null;
        if (isTrue(isEqual(method, "privateGetTradeOrdersAlgoPending")))
        {
            response = await this.privateGetTradeOrdersAlgoPending(this.extend(request, query));
        } else
        {
            response = await this.privateGetTradeOrdersPending(this.extend(request, query));
        }
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "accFillSz": "0",
        //                 "avgPx": "",
        //                 "cTime": "1621910749815",
        //                 "category": "normal",
        //                 "ccy": "",
        //                 "clOrdId": "",
        //                 "fee": "0",
        //                 "feeCcy": "ETH",
        //                 "fillPx": "",
        //                 "fillSz": "0",
        //                 "fillTime": "",
        //                 "instId": "ETH-USDT",
        //                 "instType": "SPOT",
        //                 "lever": "",
        //                 "ordId": "317251910906576896",
        //                 "ordType": "limit",
        //                 "pnl": "0",
        //                 "posSide": "net",
        //                 "px":"20 00",
        //                 "rebate": "0",
        //                 "rebateCcy": "USDT",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "state": "live",
        //                 "sz":"0. 001",
        //                 "tag": "",
        //                 "tdMode": "cash",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tradeId": "",
        //                 "uTime": "1621910749815"
        //             }
        //         ],
        //         "msg":""
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "activePx": "",
        //                 "activePxType": "",
        //                 "actualPx": "",
        //                 "actualSide": "buy",
        //                 "actualSz": "0",
        //                 "algoId": "431375349042380800",
        //                 "cTime": "1649119897778",
        //                 "callbackRatio": "",
        //                 "callbackSpread": "",
        //                 "ccy": "",
        //                 "ctVal": "0.01",
        //                 "instId": "BTC-USDT-SWAP",
        //                 "instType": "SWAP",
        //                 "last": "46538.9",
        //                 "lever": "125",
        //                 "moveTriggerPx": "",
        //                 "notionalUsd": "467.059",
        //                 "ordId": "",
        //                 "ordPx": "50000",
        //                 "ordType": "trigger",
        //                 "posSide": "long",
        //                 "pxLimit": "",
        //                 "pxSpread": "",
        //                 "pxVar": "",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "slTriggerPxType": "",
        //                 "state": "live",
        //                 "sz": "1",
        //                 "szLimit": "",
        //                 "tag": "",
        //                 "tdMode": "isolated",
        //                 "tgtCcy": "",
        //                 "timeInterval": "",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tpTriggerPxType": "",
        //                 "triggerPx": "50000",
        //                 "triggerPxType": "last",
        //                 "triggerTime": "",
        //                 "uly": "BTC-USDT"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    /**
     * @method
     * @name okx#fetchCanceledOrders
     * @description fetches information on multiple canceled orders made by the user
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-get-order-history-last-7-days
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-algo-trading-get-algo-order-history
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] timestamp in ms of the earliest order, default is undefined
     * @param {int} [limit] max number of orders to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.trigger] True if fetching trigger or conditional orders
     * @param {string} [params.ordType] "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"
     * @param {string} [params.algoId] Algo ID "'433845797218942976'"
     * @param {int} [params.until] timestamp in ms to fetch orders for
     * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
     * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instId"] = getValue(market, "id");
        }
        object type = null;
        object query = null;
        var typequeryVariable = this.handleMarketTypeAndParams("fetchCanceledOrders", market, parameters);
        type = ((IList<object>)typequeryVariable)[0];
        query = ((IList<object>)typequeryVariable)[1];
        ((IDictionary<string,object>)request)["instType"] = this.convertToInstrumentType(type);
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 100
        }
        ((IDictionary<string,object>)request)["state"] = "canceled";
        object options = this.safeValue(this.options, "fetchCanceledOrders", new Dictionary<string, object>() {});
        object algoOrderTypes = this.safeValue(this.options, "algoOrderTypes", new Dictionary<string, object>() {});
        object defaultMethod = this.safeString(options, "method", "privateGetTradeOrdersHistory");
        object method = this.safeString(parameters, "method", defaultMethod);
        object ordType = this.safeString(parameters, "ordType");
        object trigger = this.safeValue2(parameters, "stop", "trigger");
        object trailing = this.safeBool(parameters, "trailing", false);
        if (isTrue(trailing))
        {
            method = "privateGetTradeOrdersAlgoHistory";
            ((IDictionary<string,object>)request)["ordType"] = "move_order_stop";
        } else if (isTrue(isTrue(trigger) || isTrue((inOp(algoOrderTypes, ordType)))))
        {
            method = "privateGetTradeOrdersAlgoHistory";
            object algoId = this.safeString(parameters, "algoId");
            if (isTrue(!isEqual(algoId, null)))
            {
                ((IDictionary<string,object>)request)["algoId"] = algoId;
                parameters = this.omit(parameters, "algoId");
            }
            if (isTrue(trigger))
            {
                if (isTrue(isEqual(ordType, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " fetchCanceledOrders() requires an \"ordType\" string parameter, \"conditional\", \"oco\", \"trigger\", \"move_order_stop\", \"iceberg\", or \"twap\"")) ;
                }
            }
        } else
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["begin"] = since;
            }
            object until = this.safeInteger(query, "until");
            if (isTrue(!isEqual(until, null)))
            {
                ((IDictionary<string,object>)request)["end"] = until;
                query = this.omit(query, new List<object>() {"until"});
            }
        }
        object send = this.omit(query, new List<object>() {"method", "stop", "trigger", "trailing"});
        object response = null;
        if (isTrue(isEqual(method, "privateGetTradeOrdersAlgoHistory")))
        {
            response = await this.privateGetTradeOrdersAlgoHistory(this.extend(request, send));
        } else
        {
            response = await this.privateGetTradeOrdersHistory(this.extend(request, send));
        }
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "accFillSz": "0",
        //                 "avgPx": "",
        //                 "cTime": "1644037822494",
        //                 "category": "normal",
        //                 "ccy": "",
        //                 "clOrdId": "",
        //                 "fee": "0",
        //                 "feeCcy": "BTC",
        //                 "fillPx": "",
        //                 "fillSz": "0",
        //                 "fillTime": "",
        //                 "instId": "BTC-USDT",
        //                 "instType": "SPOT",
        //                 "lever": "",
        //                 "ordId": "410059580352409602",
        //                 "ordType": "limit",
        //                 "pnl": "0",
        //                 "posSide": "net",
        //                 "px": "30000",
        //                 "rebate": "0",
        //                 "rebateCcy": "USDT",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "slTriggerPxType": "",
        //                 "source": "",
        //                 "state": "canceled",
        //                 "sz": "0.0005452",
        //                 "tag": "",
        //                 "tdMode": "cash",
        //                 "tgtCcy": "",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tpTriggerPxType": "",
        //                 "tradeId": "",
        //                 "uTime": "1644038165667"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "activePx": "",
        //                 "activePxType": "",
        //                 "actualPx": "",
        //                 "actualSide": "buy",
        //                 "actualSz": "0",
        //                 "algoId": "433845797218942976",
        //                 "cTime": "1649708898523",
        //                 "callbackRatio": "",
        //                 "callbackSpread": "",
        //                 "ccy": "",
        //                 "ctVal": "0.01",
        //                 "instId": "BTC-USDT-SWAP",
        //                 "instType": "SWAP",
        //                 "last": "39950.4",
        //                 "lever": "125",
        //                 "moveTriggerPx": "",
        //                 "notionalUsd": "1592.1760000000002",
        //                 "ordId": "",
        //                 "ordPx": "29000",
        //                 "ordType": "trigger",
        //                 "posSide": "long",
        //                 "pxLimit": "",
        //                 "pxSpread": "",
        //                 "pxVar": "",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "slTriggerPxType": "",
        //                 "state": "canceled",
        //                 "sz": "4",
        //                 "szLimit": "",
        //                 "tag": "",
        //                 "tdMode": "isolated",
        //                 "tgtCcy": "",
        //                 "timeInterval": "",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tpTriggerPxType": "",
        //                 "triggerPx": "30000",
        //                 "triggerPxType": "last",
        //                 "triggerTime": "",
        //                 "uly": "BTC-USDT"
        //             },
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    /**
     * @method
     * @name okx#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-get-order-history-last-7-days
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-algo-trading-get-algo-order-history
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-get-order-history-last-3-months
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.trigger] True if fetching trigger or conditional orders
     * @param {string} [params.ordType] "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"
     * @param {string} [params.algoId] Algo ID "'433845797218942976'"
     * @param {int} [params.until] timestamp in ms to fetch orders for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {string} [params.method] method to be used, either 'privateGetTradeOrdersHistory', 'privateGetTradeOrdersHistoryArchive' or 'privateGetTradeOrdersAlgoHistory' default is 'privateGetTradeOrdersHistory'
     * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchClosedOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchClosedOrders", symbol, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instId"] = getValue(market, "id");
        }
        object type = null;
        object query = null;
        var typequeryVariable = this.handleMarketTypeAndParams("fetchClosedOrders", market, parameters);
        type = ((IList<object>)typequeryVariable)[0];
        query = ((IList<object>)typequeryVariable)[1];
        ((IDictionary<string,object>)request)["instType"] = this.convertToInstrumentType(type);
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 100
        }
        object options = this.safeDict(this.options, "fetchClosedOrders", new Dictionary<string, object>() {});
        object algoOrderTypes = this.safeDict(this.options, "algoOrderTypes", new Dictionary<string, object>() {});
        object defaultMethod = this.safeString(options, "method", "privateGetTradeOrdersHistory");
        object method = this.safeString(parameters, "method", defaultMethod);
        object ordType = this.safeString(parameters, "ordType");
        object trigger = this.safeBool2(parameters, "stop", "trigger");
        object trailing = this.safeBool(parameters, "trailing", false);
        if (isTrue(isTrue(isTrue(trailing) || isTrue(trigger)) || isTrue((inOp(algoOrderTypes, ordType)))))
        {
            method = "privateGetTradeOrdersAlgoHistory";
            ((IDictionary<string,object>)request)["state"] = "effective";
        }
        if (isTrue(trailing))
        {
            ((IDictionary<string,object>)request)["ordType"] = "move_order_stop";
        } else if (isTrue(trigger))
        {
            if (isTrue(isEqual(ordType, null)))
            {
                ((IDictionary<string,object>)request)["ordType"] = "trigger";
            }
        } else
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["begin"] = since;
            }
            object until = this.safeInteger(query, "until");
            if (isTrue(!isEqual(until, null)))
            {
                ((IDictionary<string,object>)request)["end"] = until;
                query = this.omit(query, new List<object>() {"until"});
            }
            ((IDictionary<string,object>)request)["state"] = "filled";
        }
        object send = this.omit(query, new List<object>() {"method", "stop", "trigger", "trailing"});
        object response = null;
        if (isTrue(isEqual(method, "privateGetTradeOrdersAlgoHistory")))
        {
            response = await this.privateGetTradeOrdersAlgoHistory(this.extend(request, send));
        } else if (isTrue(isEqual(method, "privateGetTradeOrdersHistoryArchive")))
        {
            response = await this.privateGetTradeOrdersHistoryArchive(this.extend(request, send));
        } else
        {
            response = await this.privateGetTradeOrdersHistory(this.extend(request, send));
        }
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "accFillSz": "0",
        //                 "avgPx": "",
        //                 "cTime": "1621910749815",
        //                 "category": "normal",
        //                 "ccy": "",
        //                 "clOrdId": "",
        //                 "fee": "0",
        //                 "feeCcy": "ETH",
        //                 "fillPx": "",
        //                 "fillSz": "0",
        //                 "fillTime": "",
        //                 "instId": "ETH-USDT",
        //                 "instType": "SPOT",
        //                 "lever": "",
        //                 "ordId": "317251910906576896",
        //                 "ordType": "limit",
        //                 "pnl": "0",
        //                 "posSide": "net",
        //                 "px": "2000",
        //                 "rebate": "0",
        //                 "rebateCcy": "USDT",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "state": "live",
        //                 "sz": "0.001",
        //                 "tag": "",
        //                 "tdMode": "cash",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tradeId": "",
        //                 "uTime": "1621910749815"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "activePx": "",
        //                 "activePxType": "",
        //                 "actualPx": "",
        //                 "actualSide": "buy",
        //                 "actualSz": "0",
        //                 "algoId": "433845797218942976",
        //                 "cTime": "1649708898523",
        //                 "callbackRatio": "",
        //                 "callbackSpread": "",
        //                 "ccy": "",
        //                 "ctVal": "0.01",
        //                 "instId": "BTC-USDT-SWAP",
        //                 "instType": "SWAP",
        //                 "last": "39950.4",
        //                 "lever": "125",
        //                 "moveTriggerPx": "",
        //                 "notionalUsd": "1592.1760000000002",
        //                 "ordId": "",
        //                 "ordPx": "29000",
        //                 "ordType": "trigger",
        //                 "posSide": "long",
        //                 "pxLimit": "",
        //                 "pxSpread": "",
        //                 "pxVar": "",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "slTriggerPxType": "",
        //                 "state": "effective",
        //                 "sz": "4",
        //                 "szLimit": "",
        //                 "tag": "",
        //                 "tdMode": "isolated",
        //                 "tgtCcy": "",
        //                 "timeInterval": "",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tpTriggerPxType": "",
        //                 "triggerPx": "30000",
        //                 "triggerPxType": "last",
        //                 "triggerTime": "",
        //                 "uly": "BTC-USDT"
        //             },
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    /**
     * @method
     * @name okx#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-get-transaction-details-last-3-months
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] Timestamp in ms of the latest time to retrieve trades for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instId"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["begin"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("end", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        var typequeryVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        ((IDictionary<string,object>)request)["instType"] = this.convertToInstrumentType(type);
        if (isTrue(isTrue((!isEqual(limit, null))) && isTrue((isEqual(since, null)))))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 100
        }
        object response = await this.privateGetTradeFillsHistory(this.extend(request, query));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "side": "buy",
        //                 "fillSz": "0.007533",
        //                 "fillPx": "2654.98",
        //                 "fee": "-0.000007533",
        //                 "ordId": "317321390244397056",
        //                 "instType": "SPOT",
        //                 "instId": "ETH-USDT",
        //                 "clOrdId": "",
        //                 "posSide": "net",
        //                 "billId": "317321390265368576",
        //                 "tag": "0",
        //                 "execType": "T",
        //                 "tradeId": "107601752",
        //                 "feeCcy": "ETH",
        //                 "ts": "1621927314985"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit, query);
    }

    /**
     * @method
     * @name okx#fetchOrderTrades
     * @description fetch all the trades made from a single order
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-get-transaction-details-last-3-months
     * @param {string} id order id
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "ordId", id },
        };
        return await this.fetchMyTrades(symbol, since, limit, this.extend(request, parameters));
    }

    /**
     * @method
     * @name okx#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
     * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-bills-details-last-7-days
     * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-bills-details-last-3-months
     * @see https://www.okx.com/docs-v5/en/#rest-api-funding-asset-bills-details
     * @param {string} [code] unified currency code, default is undefined
     * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
     * @param {int} [limit] max number of ledger entries to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated'
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchLedger", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchLedger", code, since, limit, parameters);
        }
        object options = this.safeDict(this.options, "fetchLedger", new Dictionary<string, object>() {});
        object method = this.safeString(options, "method");
        method = this.safeString(parameters, "method", method);
        parameters = this.omit(parameters, "method");
        object request = new Dictionary<string, object>() {};
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchLedger", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, null)))
        {
            marginMode = this.safeString(parameters, "mgnMode");
        }
        if (isTrue(!isEqual(method, "privateGetAssetBills")))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                ((IDictionary<string,object>)request)["mgnMode"] = marginMode;
            }
        }
        var typequeryVariable = this.handleMarketTypeAndParams("fetchLedger", null, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        if (isTrue(!isEqual(type, null)))
        {
            ((IDictionary<string,object>)request)["instType"] = this.convertToInstrumentType(type);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["ccy"] = getValue(currency, "id");
        }
        var requestparametersVariable = this.handleUntilOption("end", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(method, "privateGetAccountBillsArchive")))
        {
            response = await this.privateGetAccountBillsArchive(this.extend(request, query));
        } else if (isTrue(isEqual(method, "privateGetAssetBills")))
        {
            response = await this.privateGetAssetBills(this.extend(request, query));
        } else
        {
            response = await this.privateGetAccountBills(this.extend(request, query));
        }
        //
        // privateGetAccountBills, privateGetAccountBillsArchive
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "bal": "0.0000819307998198",
        //                 "balChg": "-664.2679586599999802",
        //                 "billId": "310394313544966151",
        //                 "ccy": "USDT",
        //                 "fee": "0",
        //                 "from": "",
        //                 "instId": "LTC-USDT",
        //                 "instType": "SPOT",
        //                 "mgnMode": "cross",
        //                 "notes": "",
        //                 "ordId": "310394313519800320",
        //                 "pnl": "0",
        //                 "posBal": "0",
        //                 "posBalChg": "0",
        //                 "subType": "2",
        //                 "sz": "664.26795866",
        //                 "to": "",
        //                 "ts": "1620275771196",
        //                 "type": "2"
        //             }
        //         ]
        //     }
        //
        // privateGetAssetBills
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "billId": "12344",
        //                 "ccy": "BTC",
        //                 "balChg": "2",
        //                 "bal": "12",
        //                 "type": "1",
        //                 "ts": "1597026383085"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseLedger(data, currency, since, limit);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "1", "transfer" },
            { "2", "trade" },
            { "3", "trade" },
            { "4", "rebate" },
            { "5", "trade" },
            { "6", "transfer" },
            { "7", "trade" },
            { "8", "fee" },
            { "9", "trade" },
            { "10", "trade" },
            { "11", "trade" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        // privateGetAccountBills, privateGetAccountBillsArchive
        //
        //     {
        //         "bal": "0.0000819307998198",
        //         "balChg": "-664.2679586599999802",
        //         "billId": "310394313544966151",
        //         "ccy": "USDT",
        //         "fee": "0",
        //         "from": "",
        //         "instId": "LTC-USDT",
        //         "instType": "SPOT",
        //         "mgnMode": "cross",
        //         "notes": "",
        //         "ordId": "310394313519800320",
        //         "pnl": "0",
        //         "posBal": "0",
        //         "posBalChg": "0",
        //         "subType": "2",
        //         "sz": "664.26795866",
        //         "to": "",
        //         "ts": "1620275771196",
        //         "type": "2"
        //     }
        //
        // privateGetAssetBills
        //
        //     {
        //         "billId": "12344",
        //         "ccy": "BTC",
        //         "balChg": "2",
        //         "bal": "12",
        //         "type": "1",
        //         "ts": "1597026383085"
        //     }
        //
        object currencyId = this.safeString(item, "ccy");
        object code = this.safeCurrencyCode(currencyId, currency);
        currency = this.safeCurrency(currencyId, currency);
        object timestamp = this.safeInteger(item, "ts");
        object feeCostString = this.safeString(item, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(Precise.stringNeg(feeCostString)) },
                { "currency", code },
            };
        }
        object marketId = this.safeString(item, "instId");
        object symbol = this.safeSymbol(marketId, null, "-");
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", this.safeString(item, "billId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "account", null },
            { "referenceId", this.safeString(item, "ordId") },
            { "referenceAccount", null },
            { "type", this.parseLedgerEntryType(this.safeString(item, "type")) },
            { "currency", code },
            { "symbol", symbol },
            { "amount", this.safeNumber(item, "balChg") },
            { "before", null },
            { "after", this.safeNumber(item, "bal") },
            { "status", "ok" },
            { "fee", fee },
        }, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "addr": "okbtothemoon",
        //         "memo": "971668", // may be missing
        //         "tag":"52055", // may be missing
        //         "pmtId": "", // may be missing
        //         "ccy": "BTC",
        //         "to": "6", // 1 SPOT, 3 FUTURES, 6 FUNDING, 9 SWAP, 12 OPTION, 18 Unified account
        //         "selected": true
        //     }
        //
        //     {
        //         "ccy":"usdt-erc20",
        //         "to":"6",
        //         "addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa",
        //         "selected":true
        //     }
        //
        //     {
        //        "chain": "ETH-OKExChain",
        //        "addrEx": { "comment": "6040348" }, // some currencies like TON may have this field,
        //        "ctAddr": "72315c",
        //        "ccy": "ETH",
        //        "to": "6",
        //        "addr": "0x1c9f2244d1ccaa060bd536827c18925db10db102",
        //        "selected": true
        //     }
        //
        object address = this.safeString(depositAddress, "addr");
        object tag = this.safeStringN(depositAddress, new List<object>() {"tag", "pmtId", "memo"});
        if (isTrue(isEqual(tag, null)))
        {
            object addrEx = this.safeValue(depositAddress, "addrEx", new Dictionary<string, object>() {});
            tag = this.safeString(addrEx, "comment");
        }
        object currencyId = this.safeString(depositAddress, "ccy");
        currency = this.safeCurrency(currencyId, currency);
        object code = getValue(currency, "code");
        object chain = this.safeString(depositAddress, "chain");
        object networks = this.safeValue(currency, "networks", new Dictionary<string, object>() {});
        object networksById = this.indexBy(networks, "id");
        object networkData = this.safeValue(networksById, chain);
        // inconsistent naming responses from exchange
        // with respect to network naming provided in currency info vs address chain-names and ids
        //
        // response from address endpoint:
        //      {
        //          "chain": "USDT-Polygon",
        //          "ctAddr": "",
        //          "ccy": "USDT",
        //          "to":"6" ,
        //          "addr": "0x1903441e386cc49d937f6302955b5feb4286dcfa",
        //          "selected": true
        //      }
        // network information from currency['networks'] field:
        // Polygon: {
        //        info: {
        //            canDep: false,
        //            canInternal: false,
        //            canWd: false,
        //            ccy: 'USDT',
        //            chain: 'USDT-Polygon-Bridge',
        //            mainNet: false,
        //            maxFee: '26.879528',
        //            minFee: '13.439764',
        //            minWd: '0.001',
        //            name: ''
        //        },
        //        id: 'USDT-Polygon-Bridge',
        //        network: 'Polygon',
        //        active: false,
        //        deposit: false,
        //        withdraw: false,
        //        fee: 13.439764,
        //        precision: undefined,
        //        limits: {
        //            withdraw: {
        //                min: 0.001,
        //                max: undefined
        //            }
        //        }
        //     },
        //
        if (isTrue(isEqual(chain, "USDT-Polygon")))
        {
            networkData = this.safeValue2(networksById, "USDT-Polygon-Bridge", "USDT-Polygon");
        }
        object network = this.safeString(networkData, "network");
        object networkCode = this.networkIdToCode(network, code);
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", code },
            { "network", networkCode },
            { "address", address },
            { "tag", tag },
        };
    }

    /**
     * @method
     * @name okx#fetchDepositAddressesByNetwork
     * @description fetch a dictionary of addresses for a currency, indexed by network
     * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-get-deposit-address
     * @param {string} code unified currency code of the currency for the deposit address
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure} indexed by the network
     */
    public async override Task<object> fetchDepositAddressesByNetwork(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
        };
        object response = await this.privateGetAssetDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "addr": "okbtothemoon",
        //                 "memo": "971668", // may be missing
        //                 "tag":"52055", // may be missing
        //                 "pmtId": "", // may be missing
        //                 "ccy": "BTC",
        //                 "to": "6", // 1 SPOT, 3 FUTURES, 6 FUNDING, 9 SWAP, 12 OPTION, 18 Unified account
        //                 "selected": true
        //             },
        //             // {"ccy":"usdt-erc20","to":"6","addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa","selected":true},
        //             // {"ccy":"usdt-trc20","to":"6","addr":"TRrd5SiSZrfQVRKm4e9SRSbn2LNTYqCjqx","selected":true},
        //             // {"ccy":"usdt_okexchain","to":"6","addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa","selected":true},
        //             // {"ccy":"usdt_kip20","to":"6","addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa","selected":true},
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object filtered = this.filterBy(data, "selected", true);
        object parsed = this.parseDepositAddresses(filtered, new List<object>() {getValue(currency, "code")}, false);
        return this.indexBy(parsed, "network");
    }

    /**
     * @method
     * @name okx#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-get-deposit-address
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network] the network name for the deposit address
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object rawNetwork = this.safeString(parameters, "network"); // some networks are like "Dora Vota Mainnet"
        parameters = this.omit(parameters, "network");
        code = this.safeCurrencyCode(code);
        object network = this.networkIdToCode(rawNetwork, code);
        object response = await this.fetchDepositAddressesByNetwork(code, parameters);
        if (isTrue(!isEqual(network, null)))
        {
            object result = this.safeDict(response, network);
            if (isTrue(isEqual(result, null)))
            {
                throw new InvalidAddress ((string)add(add(add(add(this.id, " fetchDepositAddress() cannot find "), network), " deposit address for "), code)) ;
            }
            return result;
        }
        object codeNetwork = this.networkIdToCode(code, code);
        if (isTrue(inOp(response, codeNetwork)))
        {
            return getValue(response, codeNetwork);
        }
        // if the network is not specified, return the first address
        object keys = new List<object>(((IDictionary<string,object>)response).Keys);
        object first = this.safeString(keys, 0);
        return this.safeDict(response, first);
    }

    /**
     * @method
     * @name okx#withdraw
     * @description make a withdrawal
     * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-withdrawal
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        if (isTrue(isTrue((!isEqual(tag, null))) && isTrue((isGreaterThan(((string)tag).Length, 0)))))
        {
            address = add(add(address, ":"), tag);
        }
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
            { "toAddr", address },
            { "dest", "4" },
            { "amt", this.numberToString(amount) },
        };
        object network = this.safeString(parameters, "network"); // this line allows the user to specify either ERC20 or ETH
        if (isTrue(!isEqual(network, null)))
        {
            object networks = this.safeDict(this.options, "networks", new Dictionary<string, object>() {});
            network = this.safeString(networks, ((string)network).ToUpper(), network); // handle ETH>ERC20 alias
            ((IDictionary<string,object>)request)["chain"] = add(add(getValue(currency, "id"), "-"), network);
            parameters = this.omit(parameters, "network");
        }
        object fee = this.safeString(parameters, "fee");
        if (isTrue(isEqual(fee, null)))
        {
            object currencies = await this.fetchCurrencies();
            this.currencies = this.mapToSafeMap(this.deepExtend(this.currencies, currencies));
            object targetNetwork = this.safeDict(getValue(currency, "networks"), this.networkIdToCode(network), new Dictionary<string, object>() {});
            fee = this.safeString(targetNetwork, "fee");
            if (isTrue(isEqual(fee, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " withdraw() requires a \"fee\" string parameter, network transaction fee must be  0. Withdrawals to OKCoin or OKX are fee-free, please set \"0\". Withdrawing to external digital asset address requires network transaction fee.")) ;
            }
        }
        ((IDictionary<string,object>)request)["fee"] = this.numberToString(fee); // withdrawals to OKCoin or OKX are fee-free, please set 0
        object query = this.omit(parameters, new List<object>() {"fee"});
        object response = await this.privatePostAssetWithdrawal(this.extend(request, query));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "amt": "0.1",
        //                 "wdId": "67485",
        //                 "ccy": "BTC"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object transaction = this.safeDict(data, 0);
        return this.parseTransaction(transaction, currency);
    }

    /**
     * @method
     * @name okx#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-deposit-history
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchDeposits", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchDeposits", code, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["ccy"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["before"] = mathMax(subtract(since, 1), 0);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 100
        }
        var requestparametersVariable = this.handleUntilOption("after", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateGetAssetDepositHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "amt": "0.01044408",
        //                 "txId": "1915737_3_0_0_asset",
        //                 "ccy": "BTC",
        //                 "from": "13801825426",
        //                 "to": "",
        //                 "ts": "1597026383085",
        //                 "state": "2",
        //                 "depId": "4703879"
        //             },
        //             {
        //                 "amt": "491.6784211",
        //                 "txId": "1744594_3_184_0_asset",
        //                 "ccy": "OKB",
        //                 "from": "",
        //                 "to": "",
        //                 "ts": "1597026383085",
        //                 "state": "2",
        //                 "depId": "4703809"
        //             },
        //             {
        //                 "amt": "223.18782496",
        //                 "txId": "6d892c669225b1092c780bf0da0c6f912fc7dc8f6b8cc53b003288624c",
        //                 "ccy": "USDT",
        //                 "from": "",
        //                 "to": "39kK4XvgEuM7rX9frgyHoZkWqx4iKu1spD",
        //                 "ts": "1597026383085",
        //                 "state": "2",
        //                 "depId": "4703779"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit, parameters);
    }

    /**
     * @method
     * @name okx#fetchDeposit
     * @description fetch data on a currency deposit via the deposit id
     * @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-deposit-history
     * @param {string} id deposit id
     * @param {string} code filter by currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async virtual Task<object> fetchDeposit(object id, object code = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "depId", id },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["ccy"] = getValue(currency, "id");
        }
        object response = await this.privateGetAssetDepositHistory(this.extend(request, parameters));
        object data = this.safeValue(response, "data");
        object deposit = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseTransaction(deposit, currency);
    }

    /**
     * @method
     * @name okx#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-withdrawal-history
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchWithdrawals", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchWithdrawals", code, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["ccy"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["before"] = mathMax(subtract(since, 1), 0);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 100
        }
        var requestparametersVariable = this.handleUntilOption("after", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateGetAssetWithdrawalHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "amt": "0.094",
        //                 "wdId": "4703879",
        //                 "fee": "0.01000000eth",
        //                 "txId": "0x62477bac6509a04512819bb1455e923a60dea5966c7caeaa0b24eb8fb0432b85",
        //                 "ccy": "ETH",
        //                 "from": "13426335357",
        //                 "to": "0xA41446125D0B5b6785f6898c9D67874D763A1519",
        //                 "ts": "1597026383085",
        //                 "state": "2"
        //             },
        //             {
        //                 "amt": "0.01",
        //                 "wdId": "4703879",
        //                 "fee": "0.00000000btc",
        //                 "txId": "",
        //                 "ccy": "BTC",
        //                 "from": "13426335357",
        //                 "to": "13426335357",
        //                 "ts": "1597026383085",
        //                 "state": "2"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit, parameters);
    }

    /**
     * @method
     * @name okx#fetchWithdrawal
     * @description fetch data on a currency withdrawal via the withdrawal id
     * @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-withdrawal-history
     * @param {string} id withdrawal id
     * @param {string} code unified currency code of the currency withdrawn, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async virtual Task<object> fetchWithdrawal(object id, object code = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "wdId", id },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["ccy"] = getValue(currency, "id");
        }
        object response = await this.privateGetAssetWithdrawalHistory(this.extend(request, parameters));
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "chain": "USDT-TRC20",
        //                "clientId": '',
        //                "fee": "0.8",
        //                "ccy": "USDT",
        //                "amt": "54.561",
        //                "txId": "00cff6ec7fa7c7d7d184bd84e82b9ff36863f07c0421188607f87dfa94e06b70",
        //                "from": "example@email.com",
        //                "to": "TEY6qjnKDyyq5jDc3DJizWLCdUySrpQ4yp",
        //                "state": "2",
        //                "ts": "1641376485000",
        //                "wdId": "25147041"
        //            }
        //        ],
        //        "msg": ''
        //    }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object withdrawal = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseTransaction(withdrawal);
    }

    public virtual object parseTransactionStatus(object status)
    {
        //
        // deposit statuses
        //
        //     {
        //         "0": "waiting for confirmation",
        //         "1": "deposit credited",
        //         "2": "deposit successful"
        //     }
        //
        // withdrawal statuses
        //
        //     {
        //        '-3': "pending cancel",
        //        "-2": "canceled",
        //        "-1": "failed",
        //         "0": "pending",
        //         "1": "sending",
        //         "2": "sent",
        //         "3": "awaiting email verification",
        //         "4": "awaiting manual verification",
        //         "5": "awaiting identity verification"
        //     }
        //
        object statuses = new Dictionary<string, object>() {
            { "-3", "pending" },
            { "-2", "canceled" },
            { "-1", "failed" },
            { "0", "pending" },
            { "1", "pending" },
            { "2", "ok" },
            { "3", "pending" },
            { "4", "pending" },
            { "5", "pending" },
            { "6", "pending" },
            { "7", "pending" },
            { "8", "pending" },
            { "9", "pending" },
            { "10", "pending" },
            { "12", "pending" },
            { "15", "pending" },
            { "16", "pending" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // withdraw
        //
        //     {
        //         "amt": "0.1",
        //         "wdId": "67485",
        //         "ccy": "BTC"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "amt": "0.094",
        //         "wdId": "4703879",
        //         "fee": "0.01000000eth",
        //         "txId": "0x62477bac6509a04512819bb1455e923a60dea5966c7caeaa0b24eb8fb0432b85",
        //         "ccy": "ETH",
        //         "from": "13426335357",
        //         "to": "0xA41446125D0B5b6785f6898c9D67874D763A1519",
        //         "tag",
        //         "pmtId",
        //         "memo",
        //         "ts": "1597026383085",
        //         "state": "2"
        //     }
        //
        // fetchDeposits
        //
        //     {
        //         "amt": "0.01044408",
        //         "txId": "1915737_3_0_0_asset",
        //         "ccy": "BTC",
        //         "from": "13801825426",
        //         "to": "",
        //         "ts": "1597026383085",
        //         "state": "2",
        //         "depId": "4703879"
        //     }
        //
        object type = null;
        object id = null;
        object withdrawalId = this.safeString(transaction, "wdId");
        object addressFrom = this.safeString(transaction, "from");
        object addressTo = this.safeString(transaction, "to");
        object address = addressTo;
        object tagTo = this.safeString2(transaction, "tag", "memo");
        tagTo = this.safeString2(transaction, "pmtId", tagTo);
        if (isTrue(!isEqual(withdrawalId, null)))
        {
            type = "withdrawal";
            id = withdrawalId;
        } else
        {
            // the payment_id will appear on new deposits but appears to be removed from the response after 2 months
            id = this.safeString(transaction, "depId");
            type = "deposit";
        }
        object currencyId = this.safeString(transaction, "ccy");
        object code = this.safeCurrencyCode(currencyId);
        object amount = this.safeNumber(transaction, "amt");
        object status = this.parseTransactionStatus(this.safeString(transaction, "state"));
        object txid = this.safeString(transaction, "txId");
        object timestamp = this.safeInteger(transaction, "ts");
        object feeCost = null;
        if (isTrue(isEqual(type, "deposit")))
        {
            feeCost = 0;
        } else
        {
            feeCost = this.safeNumber(transaction, "fee");
        }
        // todo parse tags
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "currency", code },
            { "amount", amount },
            { "network", null },
            { "addressFrom", addressFrom },
            { "addressTo", addressTo },
            { "address", address },
            { "tagFrom", null },
            { "tagTo", tagTo },
            { "tag", tagTo },
            { "status", status },
            { "type", type },
            { "updated", null },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "internal", null },
            { "comment", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", feeCost },
            } },
        };
    }

    /**
     * @method
     * @name okx#fetchLeverage
     * @description fetch the set leverage for a market
     * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated'
     * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
     */
    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchLeverage", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, null)))
        {
            marginMode = this.safeString(parameters, "mgnMode", "cross"); // cross as default marginMode
        }
        if (isTrue(isTrue((!isEqual(marginMode, "cross"))) && isTrue((!isEqual(marginMode, "isolated")))))
        {
            throw new BadRequest ((string)add(this.id, " fetchLeverage() requires a marginMode parameter that must be either cross or isolated")) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "mgnMode", marginMode },
        };
        object response = await this.privateGetAccountLeverageInfo(this.extend(request, parameters));
        //
        //     {
        //        "code": "0",
        //        "data": [
        //            {
        //                "instId": "BTC-USDT-SWAP",
        //                "lever": "5.00000000",
        //                "mgnMode": "isolated",
        //                "posSide": "net"
        //            }
        //        ],
        //        "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseLeverage(data, market);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        object marketId = null;
        object marginMode = null;
        object longLeverage = null;
        object shortLeverage = null;
        for (object i = 0; isLessThan(i, getArrayLength(leverage)); postFixIncrement(ref i))
        {
            object entry = getValue(leverage, i);
            marginMode = this.safeStringLower(entry, "mgnMode");
            marketId = this.safeString(entry, "instId");
            object positionSide = this.safeStringLower(entry, "posSide");
            if (isTrue(isEqual(positionSide, "long")))
            {
                longLeverage = this.safeInteger(entry, "lever");
            } else if (isTrue(isEqual(positionSide, "short")))
            {
                shortLeverage = this.safeInteger(entry, "lever");
            } else
            {
                longLeverage = this.safeInteger(entry, "lever");
                shortLeverage = this.safeInteger(entry, "lever");
            }
        }
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", this.safeSymbol(marketId, market) },
            { "marginMode", marginMode },
            { "longLeverage", longLeverage },
            { "shortLeverage", shortLeverage },
        };
    }

    /**
     * @method
     * @name okx#fetchPosition
     * @description fetch data on a single open contract trade position
     * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-positions
     * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.instType] MARGIN, SWAP, FUTURES, OPTION
     * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var typequeryVariable = this.handleMarketTypeAndParams("fetchPosition", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        if (isTrue(!isEqual(type, null)))
        {
            ((IDictionary<string,object>)request)["instType"] = this.convertToInstrumentType(type);
        }
        object response = await this.privateGetAccountPositions(this.extend(request, query));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "adl": "1",
        //                 "availPos": "1",
        //                 "avgPx": "2566.31",
        //                 "cTime": "1619507758793",
        //                 "ccy": "ETH",
        //                 "deltaBS": "",
        //                 "deltaPA": "",
        //                 "gammaBS": "",
        //                 "gammaPA": "",
        //                 "imr": "",
        //                 "instId": "ETH-USD-210430",
        //                 "instType": "FUTURES",
        //                 "interest": "0",
        //                 "last": "2566.22",
        //                 "lever": "10",
        //                 "liab": "",
        //                 "liabCcy": "",
        //                 "liqPx": "2352.8496681818233",
        //                 "margin": "0.0003896645377994",
        //                 "mgnMode": "isolated",
        //                 "mgnRatio": "11.731726509588816",
        //                 "mmr": "0.0000311811092368",
        //                 "optVal": "",
        //                 "pTime": "1619507761462",
        //                 "pos": "1",
        //                 "posCcy": "",
        //                 "posId": "307173036051017730",
        //                 "posSide": "long",
        //                 "thetaBS": "",
        //                 "thetaPA": "",
        //                 "tradeId": "109844",
        //                 "uTime": "1619507761462",
        //                 "upl": "-0.0000009932766034",
        //                 "uplRatio": "-0.0025490556801078",
        //                 "vegaBS": "",
        //                 "vegaPA": ""
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object position = this.safeDict(data, 0);
        if (isTrue(isEqual(position, null)))
        {
            return null;
        }
        return this.parsePosition(position, market);
    }

    /**
     * @method
     * @name okx#fetchPositions
     * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-positions
     * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-positions-history history
     * @description fetch all open positions
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.instType] MARGIN, SWAP, FUTURES, OPTION
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            object marketIds = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object entry = getValue(symbols, i);
                object market = this.market(entry);
                ((IList<object>)marketIds).Add(getValue(market, "id"));
            }
            object marketIdsLength = getArrayLength(marketIds);
            if (isTrue(isGreaterThan(marketIdsLength, 0)))
            {
                ((IDictionary<string,object>)request)["instId"] = String.Join(",", ((IList<object>)marketIds).ToArray());
            }
        }
        object fetchPositionsOptions = this.safeDict(this.options, "fetchPositions", new Dictionary<string, object>() {});
        object method = this.safeString(fetchPositionsOptions, "method", "privateGetAccountPositions");
        object response = null;
        if (isTrue(isEqual(method, "privateGetAccountPositionsHistory")))
        {
            response = await this.privateGetAccountPositionsHistory(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetAccountPositions(this.extend(request, parameters));
        }
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "adl": "1",
        //                 "availPos": "1",
        //                 "avgPx": "2566.31",
        //                 "cTime": "1619507758793",
        //                 "ccy": "ETH",
        //                 "deltaBS": "",
        //                 "deltaPA": "",
        //                 "gammaBS": "",
        //                 "gammaPA": "",
        //                 "imr": "",
        //                 "instId": "ETH-USD-210430",
        //                 "instType": "FUTURES",
        //                 "interest": "0",
        //                 "last": "2566.22",
        //                 "lever": "10",
        //                 "liab": "",
        //                 "liabCcy": "",
        //                 "liqPx": "2352.8496681818233",
        //                 "margin": "0.0003896645377994",
        //                 "mgnMode": "isolated",
        //                 "mgnRatio": "11.731726509588816",
        //                 "mmr": "0.0000311811092368",
        //                 "optVal": "",
        //                 "pTime": "1619507761462",
        //                 "pos": "1",
        //                 "posCcy": "",
        //                 "posId": "307173036051017730",
        //                 "posSide": "long",
        //                 "thetaBS": "",
        //                 "thetaPA": "",
        //                 "tradeId": "109844",
        //                 "uTime": "1619507761462",
        //                 "upl": "-0.0000009932766034",
        //                 "uplRatio": "-0.0025490556801078",
        //                 "vegaBS": "",
        //                 "vegaPA": ""
        //             }
        //         ]
        //     }
        //
        object positions = this.safeList(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parsePosition(getValue(positions, i)));
        }
        return this.filterByArrayPositions(result, "symbol", this.marketSymbols(symbols), false);
    }

    /**
     * @method
     * @name okx#fetchPositionsForSymbol
     * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-positions
     * @description fetch all open positions for specific symbol
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.instType] MARGIN (if needed)
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositionsForSymbol(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchPositions(new List<object>() {symbol}, parameters);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //        "adl": "3",
        //        "availPos": "1",
        //        "avgPx": "34131.1",
        //        "cTime": "1627227626502",
        //        "ccy": "USDT",
        //        "deltaBS": "",
        //        "deltaPA": "",
        //        "gammaBS": "",
        //        "gammaPA": "",
        //        "imr": "170.66093041794787",
        //        "instId": "BTC-USDT-SWAP",
        //        "instType": "SWAP",
        //        "interest": "0",
        //        "last": "34134.4",
        //        "lever": "2",
        //        "liab": "",
        //        "liabCcy": "",
        //        "liqPx": "12608.959083877446",
        //        "markPx": "4786.459271773621",
        //        "margin": "",
        //        "mgnMode": "cross",
        //        "mgnRatio": "140.49930117599155",
        //        "mmr": "1.3652874433435829",
        //        "notionalUsd": "341.5130010779638",
        //        "optVal": "",
        //        "pos": "1",
        //        "posCcy": "",
        //        "posId": "339552508062380036",
        //        "posSide": "long",
        //        "thetaBS": "",
        //        "thetaPA": "",
        //        "tradeId": "98617799",
        //        "uTime": "1627227626502",
        //        "upl": "0.0108608358957281",
        //        "uplRatio": "0.0000636418743944",
        //        "vegaBS": "",
        //        "vegaPA": ""
        //    }
        // history
        //    {
        //        "cTime":"1708351230102",
        //        "ccy":"USDT",
        //        "closeAvgPx":"1.2567",
        //        "closeTotalPos":"40",
        //        "direction":"short",
        //        "fee":"-0.0351036",
        //        "fundingFee":"0",
        //        "instId":"SUSHI-USDT-SWAP",
        //        "instType":"SWAP",
        //        "lever":"10.0",
        //        "liqPenalty":"0",
        //        "mgnMode":"isolated",
        //        "openAvgPx":"1.2462",
        //        "openMaxPos":"40",
        //        "pnl":"-0.42",
        //        "pnlRatio":"-0.0912982667308618",
        //        "posId":"666159086676836352",
        //        "realizedPnl":"-0.4551036",
        //        "triggerPx":"",
        //        "type":"2",
        //        "uTime":"1708354805699",
        //        "uly":"SUSHI-USDT"
        //    }
        //
        object marketId = this.safeString(position, "instId");
        market = this.safeMarket(marketId, market, null, "contract");
        object symbol = getValue(market, "symbol");
        object pos = this.safeString(position, "pos"); // 'pos' field: One way mode: 0 if position is not open, 1 if open | Two way (hedge) mode: -1 if short, 1 if long, 0 if position is not open
        object contractsAbs = Precise.stringAbs(pos);
        object side = this.safeString2(position, "posSide", "direction");
        object hedged = !isEqual(side, "net");
        object contracts = this.parseNumber(contractsAbs);
        if (isTrue(getValue(market, "margin")))
        {
            // margin position
            if (isTrue(isEqual(side, "net")))
            {
                object posCcy = this.safeString(position, "posCcy");
                object parsedCurrency = this.safeCurrencyCode(posCcy);
                if (isTrue(!isEqual(parsedCurrency, null)))
                {
                    side = ((bool) isTrue((isEqual(getValue(market, "base"), parsedCurrency)))) ? "long" : "short";
                }
            }
            if (isTrue(isEqual(side, null)))
            {
                side = this.safeString(position, "direction");
            }
        } else
        {
            if (isTrue(!isEqual(pos, null)))
            {
                if (isTrue(isEqual(side, "net")))
                {
                    if (isTrue(Precise.stringGt(pos, "0")))
                    {
                        side = "long";
                    } else if (isTrue(Precise.stringLt(pos, "0")))
                    {
                        side = "short";
                    } else
                    {
                        side = null;
                    }
                }
            }
        }
        object contractSize = this.safeNumber(market, "contractSize");
        object contractSizeString = this.numberToString(contractSize);
        object markPriceString = this.safeString(position, "markPx");
        object notionalString = this.safeString(position, "notionalUsd");
        if (isTrue(getValue(market, "inverse")))
        {
            notionalString = Precise.stringDiv(Precise.stringMul(contractsAbs, contractSizeString), markPriceString);
        }
        object notional = this.parseNumber(notionalString);
        object marginMode = this.safeString(position, "mgnMode");
        object initialMarginString = null;
        object entryPriceString = this.safeString2(position, "avgPx", "openAvgPx");
        object unrealizedPnlString = this.safeString(position, "upl");
        object leverageString = this.safeString(position, "lever");
        object initialMarginPercentage = null;
        object collateralString = null;
        if (isTrue(isEqual(marginMode, "cross")))
        {
            initialMarginString = this.safeString(position, "imr");
            collateralString = Precise.stringAdd(initialMarginString, unrealizedPnlString);
        } else if (isTrue(isEqual(marginMode, "isolated")))
        {
            initialMarginPercentage = Precise.stringDiv("1", leverageString);
            collateralString = this.safeString(position, "margin");
        }
        object maintenanceMarginString = this.safeString(position, "mmr");
        object maintenanceMargin = this.parseNumber(maintenanceMarginString);
        object maintenanceMarginPercentageString = Precise.stringDiv(maintenanceMarginString, notionalString);
        if (isTrue(isEqual(initialMarginPercentage, null)))
        {
            initialMarginPercentage = this.parseNumber(Precise.stringDiv(initialMarginString, notionalString, 4));
        } else if (isTrue(isEqual(initialMarginString, null)))
        {
            initialMarginString = Precise.stringMul(initialMarginPercentage, notionalString);
        }
        object rounder = "0.00005"; // round to closest 0.01%
        object maintenanceMarginPercentage = this.parseNumber(Precise.stringDiv(Precise.stringAdd(maintenanceMarginPercentageString, rounder), "1", 4));
        object liquidationPrice = this.safeNumber(position, "liqPx");
        object percentageString = this.safeString(position, "uplRatio");
        object percentage = this.parseNumber(Precise.stringMul(percentageString, "100"));
        object timestamp = this.safeInteger(position, "cTime");
        object marginRatio = this.parseNumber(Precise.stringDiv(maintenanceMarginString, collateralString, 4));
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", this.safeString(position, "posId") },
            { "symbol", symbol },
            { "notional", notional },
            { "marginMode", marginMode },
            { "liquidationPrice", liquidationPrice },
            { "entryPrice", this.parseNumber(entryPriceString) },
            { "unrealizedPnl", this.parseNumber(unrealizedPnlString) },
            { "realizedPnl", this.safeNumber(position, "realizedPnl") },
            { "percentage", percentage },
            { "contracts", contracts },
            { "contractSize", contractSize },
            { "markPrice", this.parseNumber(markPriceString) },
            { "lastPrice", this.safeNumber(position, "closeAvgPx") },
            { "side", side },
            { "hedged", hedged },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", this.safeInteger(position, "uTime") },
            { "maintenanceMargin", maintenanceMargin },
            { "maintenanceMarginPercentage", maintenanceMarginPercentage },
            { "collateral", this.parseNumber(collateralString) },
            { "initialMargin", this.parseNumber(initialMarginString) },
            { "initialMarginPercentage", this.parseNumber(initialMarginPercentage) },
            { "leverage", this.parseNumber(leverageString) },
            { "marginRatio", marginRatio },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    /**
     * @method
     * @name okx#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://www.okx.com/docs-v5/en/#rest-api-funding-funds-transfer
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account to transfer from
     * @param {string} toAccount account to transfer to
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountsByType = this.safeDict(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, toAccount);
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
            { "amt", this.currencyToPrecision(code, amount) },
            { "type", "0" },
            { "from", fromId },
            { "to", toId },
        };
        if (isTrue(isEqual(fromId, "master")))
        {
            ((IDictionary<string,object>)request)["type"] = "1";
            ((IDictionary<string,object>)request)["subAcct"] = toId;
            ((IDictionary<string,object>)request)["from"] = this.safeString(parameters, "from", "6");
            ((IDictionary<string,object>)request)["to"] = this.safeString(parameters, "to", "6");
        } else if (isTrue(isEqual(toId, "master")))
        {
            ((IDictionary<string,object>)request)["type"] = "2";
            ((IDictionary<string,object>)request)["subAcct"] = fromId;
            ((IDictionary<string,object>)request)["from"] = this.safeString(parameters, "from", "6");
            ((IDictionary<string,object>)request)["to"] = this.safeString(parameters, "to", "6");
        }
        object response = await this.privatePostAssetTransfer(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "transId": "754147",
        //                 "ccy": "USDT",
        //                 "from": "6",
        //                 "amt": "0.1",
        //                 "to": "18"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object rawTransfer = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseTransfer(rawTransfer, currency);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer
        //
        //     {
        //         "transId": "754147",
        //         "ccy": "USDT",
        //         "from": "6",
        //         "amt": "0.1",
        //         "to": "18"
        //     }
        //
        // fetchTransfer
        //
        //     {
        //         "amt": "5",
        //         "ccy": "USDT",
        //         "from": "18",
        //         "instId": "",
        //         "state": "success",
        //         "subAcct": "",
        //         "to": "6",
        //         "toInstId": "",
        //         "transId": "464424732",
        //         "type": "0"
        //     }
        //
        // fetchTransfers
        //
        //     {
        //         "bal": "70.6874353780312913",
        //         "balChg": "-4.0000000000000000", // negative means "to funding", positive meand "from funding"
        //         "billId": "588900695232225299",
        //         "ccy": "USDT",
        //         "execType": "",
        //         "fee": "",
        //         "from": "18",
        //         "instId": "",
        //         "instType": "",
        //         "mgnMode": "",
        //         "notes": "To Funding Account",
        //         "ordId": "",
        //         "pnl": "",
        //         "posBal": "",
        //         "posBalChg": "",
        //         "price": "0",
        //         "subType": "12",
        //         "sz": "-4",
        //         "to": "6",
        //         "ts": "1686676866989",
        //         "type": "1"
        //     }
        //
        object id = this.safeString2(transfer, "transId", "billId");
        object currencyId = this.safeString(transfer, "ccy");
        object code = this.safeCurrencyCode(currencyId, currency);
        object amount = this.safeNumber(transfer, "amt");
        object fromAccountId = this.safeString(transfer, "from");
        object toAccountId = this.safeString(transfer, "to");
        object accountsById = this.safeDict(this.options, "accountsById", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(transfer, "ts");
        object balanceChange = this.safeString(transfer, "sz");
        if (isTrue(!isEqual(balanceChange, null)))
        {
            amount = this.parseNumber(Precise.stringAbs(balanceChange));
        }
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", code },
            { "amount", amount },
            { "fromAccount", this.safeString(accountsById, fromAccountId) },
            { "toAccount", this.safeString(accountsById, toAccountId) },
            { "status", this.parseTransferStatus(this.safeString(transfer, "state")) },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "success", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> fetchTransfer(object id, object code = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "transId", id },
        };
        object response = await this.privateGetAssetTransferState(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "amt": "5",
        //                 "ccy": "USDT",
        //                 "from": "18",
        //                 "instId": "",
        //                 "state": "success",
        //                 "subAcct": "",
        //                 "to": "6",
        //                 "toInstId": "",
        //                 "transId": "464424732",
        //                 "type": "0"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object transfer = this.safeDict(data, 0);
        return this.parseTransfer(transfer);
    }

    /**
     * @method
     * @name okx#fetchTransfers
     * @description fetch a history of internal transfers made on an account
     * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-bills-details-last-3-months
     * @param {string} code unified currency code of the currency transferred
     * @param {int} [since] the earliest time in ms to fetch transfers for
     * @param {int} [limit] the maximum number of transfers structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        object request = new Dictionary<string, object>() {
            { "type", "1" },
        };
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["ccy"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["begin"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetAccountBillsArchive(this.extend(request, parameters));
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "bal": "70.6874353780312913",
        //                "balChg": "-4.0000000000000000",
        //                "billId": "588900695232225299",
        //                "ccy": "USDT",
        //                "execType": "",
        //                "fee": "",
        //                "from": "18",
        //                "instId": "",
        //                "instType": "",
        //                "mgnMode": "",
        //                "notes": "To Funding Account",
        //                "ordId": "",
        //                "pnl": "",
        //                "posBal": "",
        //                "posBalChg": "",
        //                "price": "0",
        //                "subType": "12",
        //                "sz": "-4",
        //                "to": "6",
        //                "ts": "1686676866989",
        //                "type": "1"
        //            },
        //            ...
        //        ],
        //        "msg": ""
        //    }
        //
        object transfers = this.safeList(response, "data", new List<object>() {});
        return this.parseTransfers(transfers, currency, since, limit, parameters);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object isArray = ((parameters is IList<object>) || (parameters.GetType().IsGenericType && parameters.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))));
        object request = add(add(add("/api/", this.version), "/"), this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        object url = add(this.implodeHostname(getValue(getValue(this.urls, "api"), "rest")), request);
        // const type = this.getPathAuthenticationType (path);
        if (isTrue(isEqual(api, "public")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            // inject id in implicit api call
            if (isTrue(isTrue(isEqual(method, "POST")) && isTrue((isTrue(isTrue(isEqual(path, "trade/batch-orders")) || isTrue(isEqual(path, "trade/order-algo"))) || isTrue(isEqual(path, "trade/order"))))))
            {
                object brokerId = this.safeString(this.options, "brokerId", "6b9ad766b55dBCDE");
                if (isTrue(((parameters is IList<object>) || (parameters.GetType().IsGenericType && parameters.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
                {
                    for (object i = 0; isLessThan(i, getArrayLength(parameters)); postFixIncrement(ref i))
                    {
                        object entry = getValue(parameters, i);
                        object clientOrderId = this.safeString(entry, "clOrdId");
                        if (isTrue(isEqual(clientOrderId, null)))
                        {
                            ((IDictionary<string,object>)entry)["clOrdId"] = add(brokerId, this.uuid16());
                            ((IDictionary<string,object>)entry)["tag"] = brokerId;
                            ((List<object>)parameters)[Convert.ToInt32(i)] = entry;
                        }
                    }
                } else
                {
                    object clientOrderId = this.safeString(parameters, "clOrdId");
                    if (isTrue(isEqual(clientOrderId, null)))
                    {
                        ((IDictionary<string,object>)parameters)["clOrdId"] = add(brokerId, this.uuid16());
                        ((IDictionary<string,object>)parameters)["tag"] = brokerId;
                    }
                }
            }
            object timestamp = this.iso8601(this.nonce());
            headers = new Dictionary<string, object>() {
                { "OK-ACCESS-KEY", this.apiKey },
                { "OK-ACCESS-PASSPHRASE", this.password },
                { "OK-ACCESS-TIMESTAMP", timestamp },
            };
            object auth = add(add(timestamp, method), request);
            if (isTrue(isEqual(method, "GET")))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    object urlencodedQuery = add("?", this.urlencode(query));
                    url = add(url, urlencodedQuery);
                    auth = add(auth, urlencodedQuery);
                }
            } else
            {
                if (isTrue(isTrue(isArray) || isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys)))))
                {
                    body = this.json(query);
                    auth = add(auth, body);
                }
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
            }
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256, "base64");
            ((IDictionary<string,object>)headers)["OK-ACCESS-SIGN"] = signature;
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //    {
        //        "fundingRate": "0.00027815",
        //        "fundingTime": "1634256000000",
        //        "instId": "BTC-USD-SWAP",
        //        "instType": "SWAP",
        //        "nextFundingRate": "0.00017",
        //        "nextFundingTime": "1634284800000"
        //    }
        // ws
        //     {
        //        "fundingRate":"0.0001875391284828",
        //        "fundingTime":"1700726400000",
        //        "instId":"BTC-USD-SWAP",
        //        "instType":"SWAP",
        //        "method": "next_period",
        //        "maxFundingRate":"0.00375",
        //        "minFundingRate":"-0.00375",
        //        "nextFundingRate":"0.0002608059239328",
        //        "nextFundingTime":"1700755200000",
        //        "premium": "0.0001233824646391",
        //        "settFundingRate":"0.0001699799259033",
        //        "settState":"settled",
        //        "ts":"1700724675402"
        //     }
        //
        // in the response above nextFundingRate is actually two funding rates from now
        //
        object nextFundingRateTimestamp = this.safeInteger(contract, "nextFundingTime");
        object marketId = this.safeString(contract, "instId");
        object symbol = this.safeSymbol(marketId, market);
        object nextFundingRate = this.safeNumber(contract, "nextFundingRate");
        object fundingTime = this.safeInteger(contract, "fundingTime");
        object fundingTimeString = this.safeString(contract, "fundingTime");
        object nextFundingTimeString = this.safeString(contract, "nextFundingTime");
        object millisecondsInterval = Precise.stringSub(nextFundingTimeString, fundingTimeString);
        // https://www.okx.com/support/hc/en-us/articles/360053909272--Introduction-to-perpetual-swap-funding-fee
        // > The current interest is 0.
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", this.parseNumber("0") },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", this.safeNumber(contract, "fundingRate") },
            { "fundingTimestamp", fundingTime },
            { "fundingDatetime", this.iso8601(fundingTime) },
            { "nextFundingRate", nextFundingRate },
            { "nextFundingTimestamp", nextFundingRateTimestamp },
            { "nextFundingDatetime", this.iso8601(nextFundingRateTimestamp) },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", this.parseFundingInterval(millisecondsInterval) },
        };
    }

    public virtual object parseFundingInterval(object interval)
    {
        object intervals = new Dictionary<string, object>() {
            { "3600000", "1h" },
            { "14400000", "4h" },
            { "28800000", "8h" },
            { "57600000", "16h" },
            { "86400000", "24h" },
        };
        return this.safeString(intervals, interval, interval);
    }

    /**
     * @method
     * @name okx#fetchFundingInterval
     * @description fetch the current funding rate interval
     * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-funding-rate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingInterval(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchFundingRate(symbol, parameters);
    }

    /**
     * @method
     * @name okx#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-funding-rate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new ExchangeError ((string)add(this.id, " fetchFundingRate() is only valid for swap markets")) ;
        }
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object response = await this.publicGetPublicFundingRate(this.extend(request, parameters));
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "fundingRate": "0.00027815",
        //                "fundingTime": "1634256000000",
        //                "instId": "BTC-USD-SWAP",
        //                "instType": "SWAP",
        //                "nextFundingRate": "0.00017",
        //                "nextFundingTime": "1634284800000"
        //            }
        //        ],
        //        "msg": ""
        //    }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object entry = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseFundingRate(entry, market);
    }

    /**
     * @method
     * @name okx#fetchFundingRates
     * @description fetches the current funding rates for multiple symbols
     * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-funding-rate
     * @param {string[]} symbols unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [funding rates structure]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}
     */
    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, "swap", true);
        object request = new Dictionary<string, object>() {
            { "instId", "ANY" },
        };
        object response = await this.publicGetPublicFundingRate(this.extend(request, parameters));
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "fundingRate": "0.00027815",
        //                "fundingTime": "1634256000000",
        //                "instId": "BTC-USD-SWAP",
        //                "instType": "SWAP",
        //                "nextFundingRate": "0.00017",
        //                "nextFundingTime": "1634284800000"
        //            }
        //        ],
        //        "msg": ""
        //    }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseFundingRates(data, symbols);
    }

    /**
     * @method
     * @name okx#fetchFundingHistory
     * @description fetch the history of funding payments paid and received on this account
     * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-bills-details-last-3-months
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch funding history for
     * @param {int} [limit] the maximum number of funding history structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
     */
    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "type", "8" },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = ((object)limit).ToString(); // default 100, max 100
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            if (isTrue(getValue(market, "contract")))
            {
                if (isTrue(getValue(market, "linear")))
                {
                    ((IDictionary<string,object>)request)["ctType"] = "linear";
                    ((IDictionary<string,object>)request)["ccy"] = getValue(market, "quoteId");
                } else
                {
                    ((IDictionary<string,object>)request)["ctType"] = "inverse";
                    ((IDictionary<string,object>)request)["ccy"] = getValue(market, "baseId");
                }
            }
        }
        var typequeryVariable = this.handleMarketTypeAndParams("fetchFundingHistory", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        if (isTrue(isEqual(type, "swap")))
        {
            ((IDictionary<string,object>)request)["instType"] = this.convertToInstrumentType(type);
        }
        // AccountBillsArchive has the same cost as AccountBills but supports three months of data
        object response = await this.privateGetAccountBillsArchive(this.extend(request, query));
        //
        //    {
        //        "bal": "0.0242946200998573",
        //        "balChg": "0.0000148752712240",
        //        "billId": "377970609204146187",
        //        "ccy": "ETH",
        //        "execType": "",
        //        "fee": "0",
        //        "from": "",
        //        "instId": "ETH-USD-SWAP",
        //        "instType": "SWAP",
        //        "mgnMode": "isolated",
        //        "notes": "",
        //        "ordId": "",
        //        "pnl": "0.000014875271224",
        //        "posBal": "0",
        //        "posBalChg": "0",
        //        "subType": "174",
        //        "sz": "9",
        //        "to": "",
        //        "ts": "1636387215588",
        //        "type": "8"
        //    }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object timestamp = this.safeInteger(entry, "ts");
            object instId = this.safeString(entry, "instId");
            object marketInner = this.safeMarket(instId);
            object currencyId = this.safeString(entry, "ccy");
            object code = this.safeCurrencyCode(currencyId);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", getValue(marketInner, "symbol") },
                { "code", code },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
                { "id", this.safeString(entry, "billId") },
                { "amount", this.safeNumber(entry, "balChg") },
            });
        }
        object sorted = this.sortBy(result, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    /**
     * @method
     * @name okx#setLeverage
     * @description set the level of leverage for a market
     * @see https://www.okx.com/docs-v5/en/#rest-api-account-set-leverage
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated'
     * @param {string} [params.posSide] 'long' or 'short' or 'net' for isolated margin long/short mode on futures and swap markets, default is 'net'
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        if (isTrue(isTrue((isLessThan(leverage, 1))) || isTrue((isGreaterThan(leverage, 125)))))
        {
            throw new BadRequest ((string)add(this.id, " setLeverage() leverage should be between 1 and 125")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("setLeverage", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, null)))
        {
            marginMode = this.safeString(parameters, "mgnMode", "cross"); // cross as default marginMode
        }
        if (isTrue(isTrue((!isEqual(marginMode, "cross"))) && isTrue((!isEqual(marginMode, "isolated")))))
        {
            throw new BadRequest ((string)add(this.id, " setLeverage() requires a marginMode parameter that must be either cross or isolated")) ;
        }
        object request = new Dictionary<string, object>() {
            { "lever", leverage },
            { "mgnMode", marginMode },
            { "instId", getValue(market, "id") },
        };
        object posSide = this.safeString(parameters, "posSide", "net");
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            if (isTrue(isTrue(isTrue(!isEqual(posSide, "long")) && isTrue(!isEqual(posSide, "short"))) && isTrue(!isEqual(posSide, "net"))))
            {
                throw new BadRequest ((string)add(this.id, " setLeverage() requires the posSide argument to be either \"long\", \"short\" or \"net\"")) ;
            }
            ((IDictionary<string,object>)request)["posSide"] = posSide;
        }
        object response = await this.privatePostAccountSetLeverage(this.extend(request, parameters));
        //
        //     {
        //       "code": "0",
        //       "data": [
        //         {
        //           "instId": "BTC-USDT-SWAP",
        //           "lever": "5",
        //           "mgnMode": "isolated",
        //           "posSide": "long"
        //         }
        //       ],
        //       "msg": ""
        //     }
        //
        return response;
    }

    /**
     * @method
     * @name okx#fetchPositionMode
     * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-account-configuration
     * @description fetchs the position mode, hedged or one way, hedged for binance is set identically for all linear markets or all inverse markets
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.accountId] if you have multiple accounts, you must specify the account id to fetch the position mode
     * @returns {object} an object detailing whether the market is in hedged or one-way mode
     */
    public async override Task<object> fetchPositionMode(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object accounts = await this.fetchAccounts();
        object length = getArrayLength(accounts);
        object selectedAccount = null;
        if (isTrue(isGreaterThan(length, 1)))
        {
            object accountId = this.safeString(parameters, "accountId");
            if (isTrue(isEqual(accountId, null)))
            {
                object accountIds = this.getListFromObjectValues(accounts, "id");
                throw new ExchangeError ((string)add(add(this.id, " fetchPositionMode() can not detect position mode, because you have multiple accounts. Set params[\"accountId\"] to desired id from: "), String.Join(", ", ((IList<object>)accountIds).ToArray()))) ;
            } else
            {
                object accountsById = this.indexBy(accounts, "id");
                selectedAccount = this.safeDict(accountsById, accountId);
            }
        } else
        {
            selectedAccount = getValue(accounts, 0);
        }
        object mainAccount = getValue(selectedAccount, "info");
        object posMode = this.safeString(mainAccount, "posMode"); // long_short_mode, net_mode
        object isHedged = isEqual(posMode, "long_short_mode");
        return new Dictionary<string, object>() {
            { "info", mainAccount },
            { "hedged", isHedged },
        };
    }

    /**
     * @method
     * @name okx#setPositionMode
     * @description set hedged to true or false for a market
     * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-set-position-mode
     * @param {bool} hedged set to true to use long_short_mode, false for net_mode
     * @param {string} symbol not used by okx setPositionMode
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setPositionMode(object hedged, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object hedgeMode = null;
        if (isTrue(hedged))
        {
            hedgeMode = "long_short_mode";
        } else
        {
            hedgeMode = "net_mode";
        }
        object request = new Dictionary<string, object>() {
            { "posMode", hedgeMode },
        };
        object response = await this.privatePostAccountSetPositionMode(this.extend(request, parameters));
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "posMode": "net_mode"
        //            }
        //        ],
        //        "msg": ""
        //    }
        //
        return response;
    }

    /**
     * @method
     * @name okx#setMarginMode
     * @description set margin mode to 'cross' or 'isolated'
     * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-set-leverage
     * @param {string} marginMode 'cross' or 'isolated'
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.leverage] leverage
     * @returns {object} response from the exchange
     */
    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        marginMode = ((string)marginMode).ToLower();
        if (isTrue(isTrue((!isEqual(marginMode, "cross"))) && isTrue((!isEqual(marginMode, "isolated")))))
        {
            throw new BadRequest ((string)add(this.id, " setMarginMode() marginMode must be either cross or isolated")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object lever = this.safeInteger2(parameters, "lever", "leverage");
        if (isTrue(isTrue(isTrue((isEqual(lever, null))) || isTrue((isLessThan(lever, 1)))) || isTrue((isGreaterThan(lever, 125)))))
        {
            throw new BadRequest ((string)add(this.id, " setMarginMode() params[\"lever\"] should be between 1 and 125")) ;
        }
        parameters = this.omit(parameters, new List<object>() {"leverage"});
        object request = new Dictionary<string, object>() {
            { "lever", lever },
            { "mgnMode", marginMode },
            { "instId", getValue(market, "id") },
        };
        object response = await this.privatePostAccountSetLeverage(this.extend(request, parameters));
        //
        //     {
        //       "code": "0",
        //       "data": [
        //         {
        //           "instId": "BTC-USDT-SWAP",
        //           "lever": "5",
        //           "mgnMode": "isolated",
        //           "posSide": "long"
        //         }
        //       ],
        //       "msg": ""
        //     }
        //
        return response;
    }

    /**
     * @method
     * @name okx#fetchCrossBorrowRates
     * @description fetch the borrow interest rates of all currencies
     * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-interest-rate
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
     */
    public async override Task<object> fetchCrossBorrowRates(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetAccountInterestRate(parameters);
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "ccy": "BTC",
        //                "interestRate": "0.00000833"
        //            }
        //            ...
        //        ],
        //    }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            ((IList<object>)rates).Add(this.parseBorrowRate(getValue(data, i)));
        }
        return ((object)rates);
    }

    /**
     * @method
     * @name okx#fetchCrossBorrowRate
     * @description fetch the rate of interest to borrow a currency for margin trading
     * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-interest-rate
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [borrow rate structure]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
     */
    public async override Task<object> fetchCrossBorrowRate(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
        };
        object response = await this.privateGetAccountInterestRate(this.extend(request, parameters));
        //
        //    {
        //        "code": "0",
        //        "data": [
        //             {
        //                "ccy": "USDT",
        //                "interestRate": "0.00002065"
        //             }
        //             ...
        //        ],
        //        "msg": ""
        //    }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object rate = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseBorrowRate(rate);
    }

    public override object parseBorrowRate(object info, object currency = null)
    {
        //
        //    {
        //        "amt": "992.10341195",
        //        "ccy": "BTC",
        //        "rate": "0.01",
        //        "ts": "1643954400000"
        //    }
        //
        object ccy = this.safeString(info, "ccy");
        object timestamp = this.safeInteger(info, "ts");
        return new Dictionary<string, object>() {
            { "currency", this.safeCurrencyCode(ccy) },
            { "rate", this.safeNumber2(info, "interestRate", "rate") },
            { "period", 86400000 },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public virtual object parseBorrowRateHistories(object response, object codes, object since, object limit)
    {
        //
        //    [
        //        {
        //            "amt": "992.10341195",
        //            "ccy": "BTC",
        //            "rate": "0.01",
        //            "ts": "1643954400000"
        //        },
        //        ...
        //    ]
        //
        object borrowRateHistories = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object item = getValue(response, i);
            object code = this.safeCurrencyCode(this.safeString(item, "ccy"));
            if (isTrue(isTrue(isEqual(codes, null)) || isTrue(this.inArray(code, codes))))
            {
                if (!isTrue((inOp(borrowRateHistories, code))))
                {
                    ((IDictionary<string,object>)borrowRateHistories)[(string)code] = new List<object>() {};
                }
                object borrowRateStructure = this.parseBorrowRate(item);
                object borrrowRateCode = getValue(borrowRateHistories, code);
                ((IList<object>)borrrowRateCode).Add(borrowRateStructure);
            }
        }
        object keys = new List<object>(((IDictionary<string,object>)borrowRateHistories).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object code = getValue(keys, i);
            ((IDictionary<string,object>)borrowRateHistories)[(string)code] = this.filterByCurrencySinceLimit(getValue(borrowRateHistories, code), code, since, limit);
        }
        return borrowRateHistories;
    }

    /**
     * @method
     * @name okx#fetchBorrowRateHistories
     * @description retrieves a history of a multiple currencies borrow interest rate at specific time slots, returns all currencies if no symbols passed, default is undefined
     * @see https://www.okx.com/docs-v5/en/#financial-product-savings-get-public-borrow-history-public
     * @param {string[]|undefined} codes list of unified currency codes, default is undefined
     * @param {int} [since] timestamp in ms of the earliest borrowRate, default is undefined
     * @param {int} [limit] max number of borrow rate prices to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure} indexed by the market symbol
     */
    public async virtual Task<object> fetchBorrowRateHistories(object codes = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["before"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.publicGetFinanceSavingsLendingRateHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "amt": "992.10341195",
        //                 "ccy": "BTC",
        //                 "rate": "0.01",
        //                 "ts": "1643954400000"
        //             },
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseBorrowRateHistories(data, codes, since, limit);
    }

    /**
     * @method
     * @name okx#fetchBorrowRateHistory
     * @description retrieves a history of a currencies borrow interest rate at specific time slots
     * @see https://www.okx.com/docs-v5/en/#financial-product-savings-get-public-borrow-history-public
     * @param {string} code unified currency code
     * @param {int} [since] timestamp for the earliest borrow rate
     * @param {int} [limit] the maximum number of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure} to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
     */
    public async virtual Task<object> fetchBorrowRateHistory(object code, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["before"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.publicGetFinanceSavingsLendingRateHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "amt": "992.10341195",
        //                 "ccy": "BTC",
        //                 "rate": "0.01",
        //                 "ts": "1643954400000"
        //             },
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseBorrowRateHistory(data, code, since, limit);
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object posSide = this.safeString(parameters, "posSide", "net");
        parameters = this.omit(parameters, new List<object>() {"posSide"});
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "amt", amount },
            { "type", type },
            { "posSide", posSide },
        };
        object response = await this.privatePostAccountPositionMarginBalance(this.extend(request, parameters));
        //
        //     {
        //       "code": "0",
        //       "data": [
        //         {
        //           "amt": "0.01",
        //           "instId": "ETH-USD-SWAP",
        //           "posSide": "net",
        //           "type": "reduce"
        //         }
        //       ],
        //       "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object entry = this.safeDict(data, 0, new Dictionary<string, object>() {});
        object errorCode = this.safeString(response, "code");
        return this.extend(this.parseMarginModification(entry, market), new Dictionary<string, object>() {
            { "status", ((bool) isTrue((isEqual(errorCode, "0")))) ? "ok" : "failed" },
        });
    }

    public override object parseMarginModification(object data, object market = null)
    {
        //
        // addMargin/reduceMargin
        //
        //    {
        //        "amt": "0.01",
        //        "instId": "ETH-USD-SWAP",
        //        "posSide": "net",
        //        "type": "reduce"
        //    }
        //
        // fetchMarginAdjustmentHistory
        //
        //    {
        //        bal: '67621.4325135010619812',
        //        balChg: '-10.0000000000000000',
        //        billId: '691293628710342659',
        //        ccy: 'USDT',
        //        clOrdId: '',
        //        execType: '',
        //        fee: '0',
        //        fillFwdPx: '',
        //        fillIdxPx: '',
        //        fillMarkPx: '',
        //        fillMarkVol: '',
        //        fillPxUsd: '',
        //        fillPxVol: '',
        //        fillTime: '1711089244850',
        //        from: '',
        //        instId: 'XRP-USDT-SWAP',
        //        instType: 'SWAP',
        //        interest: '0',
        //        mgnMode: 'isolated',
        //        notes: '',
        //        ordId: '',
        //        pnl: '0',
        //        posBal: '73.12',
        //        posBalChg: '10.00',
        //        px: '',
        //        subType: '160',
        //        sz: '10',
        //        tag: '',
        //        to: '',
        //        tradeId: '0',
        //        ts: '1711089244699',
        //        type: '6'
        //    }
        //
        object amountRaw = this.safeString2(data, "amt", "posBalChg");
        object typeRaw = this.safeString(data, "type");
        object type = null;
        if (isTrue(isEqual(typeRaw, "6")))
        {
            type = ((bool) isTrue(Precise.stringGt(amountRaw, "0"))) ? "add" : "reduce";
        } else
        {
            type = typeRaw;
        }
        object amount = Precise.stringAbs(amountRaw);
        object marketId = this.safeString(data, "instId");
        object responseMarket = this.safeMarket(marketId, market);
        object code = ((bool) isTrue(getValue(responseMarket, "inverse"))) ? getValue(responseMarket, "base") : getValue(responseMarket, "quote");
        object timestamp = this.safeInteger(data, "ts");
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", getValue(responseMarket, "symbol") },
            { "type", type },
            { "marginMode", "isolated" },
            { "amount", this.parseNumber(amount) },
            { "code", code },
            { "total", null },
            { "status", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }

    /**
     * @method
     * @name okx#reduceMargin
     * @description remove margin from a position
     * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-increase-decrease-margin
     * @param {string} symbol unified market symbol
     * @param {float} amount the amount of margin to remove
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
     */
    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "reduce", parameters);
    }

    /**
     * @method
     * @name okx#addMargin
     * @description add margin
     * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-increase-decrease-margin
     * @param {string} symbol unified market symbol
     * @param {float} amount amount of margin to add
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
     */
    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "add", parameters);
    }

    /**
     * @method
     * @name okx#fetchMarketLeverageTiers
     * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes for a single market
     * @see https://www.okx.com/docs-v5/en/#rest-api-public-data-get-position-tiers
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated'
     * @returns {object} a [leverage tiers structure]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}
     */
    public async override Task<object> fetchMarketLeverageTiers(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object type = ((bool) isTrue(getValue(market, "spot"))) ? "MARGIN" : this.convertToInstrumentType(getValue(market, "type"));
        object uly = this.safeString(getValue(market, "info"), "uly");
        if (!isTrue(uly))
        {
            if (isTrue(!isEqual(type, "MARGIN")))
            {
                throw new BadRequest ((string)add(add(this.id, " fetchMarketLeverageTiers() cannot fetch leverage tiers for "), symbol)) ;
            }
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchMarketLeverageTiers", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, null)))
        {
            marginMode = this.safeString(parameters, "tdMode", "cross"); // cross as default marginMode
        }
        object request = new Dictionary<string, object>() {
            { "instType", type },
            { "tdMode", marginMode },
            { "uly", uly },
        };
        if (isTrue(isEqual(type, "MARGIN")))
        {
            ((IDictionary<string,object>)request)["instId"] = getValue(market, "id");
        }
        object response = await this.publicGetPublicPositionTiers(this.extend(request, parameters));
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "baseMaxLoan": "500",
        //                "imr": "0.1",
        //                "instId": "ETH-USDT",
        //                "maxLever": "10",
        //                "maxSz": "500",
        //                "minSz": "0",
        //                "mmr": "0.03",
        //                "optMgnFactor": "0",
        //                "quoteMaxLoan": "200000",
        //                "tier": "1",
        //                "uly": ""
        //            },
        //            ...
        //        ]
        //    }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseMarketLeverageTiers(data, market);
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        /**
         * @ignore
         * @method
         * @param {object} info Exchange response for 1 market
         * @param {object} market CCXT market
         */
        //
        //    [
        //        {
        //            "baseMaxLoan": "500",
        //            "imr": "0.1",
        //            "instId": "ETH-USDT",
        //            "maxLever": "10",
        //            "maxSz": "500",
        //            "minSz": "0",
        //            "mmr": "0.03",
        //            "optMgnFactor": "0",
        //            "quoteMaxLoan": "200000",
        //            "tier": "1",
        //            "uly": ""
        //        },
        //        ...
        //    ]
        //
        object tiers = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(info)); postFixIncrement(ref i))
        {
            object tier = getValue(info, i);
            object marketId = this.safeString(tier, "instId");
            ((IList<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.safeInteger(tier, "tier") },
                { "symbol", this.safeSymbol(marketId, market) },
                { "currency", getValue(market, "quote") },
                { "minNotional", this.safeNumber(tier, "minSz") },
                { "maxNotional", this.safeNumber(tier, "maxSz") },
                { "maintenanceMarginRate", this.safeNumber(tier, "mmr") },
                { "maxLeverage", this.safeNumber(tier, "maxLever") },
                { "info", tier },
            });
        }
        return tiers;
    }

    /**
     * @method
     * @name okx#fetchBorrowInterest
     * @description fetch the interest owed b the user for borrowing currency for margin trading
     * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-interest-accrued-data
     * @param {string} code the unified currency code for the currency of the interest
     * @param {string} symbol the market symbol of an isolated margin market, if undefined, the interest for cross margin markets is returned
     * @param {int} [since] timestamp in ms of the earliest time to receive interest records for
     * @param {int} [limit] the number of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure} to retrieve
     * @param {object} [params] exchange specific parameters
     * @param {int} [params.type] Loan type 1 - VIP loans 2 - Market loans *Default is Market loans*
     * @param {string} [params.marginMode] 'cross' or 'isolated'
     * @returns {object[]} An list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
     */
    public async override Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBorrowInterest", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, null)))
        {
            marginMode = this.safeString(parameters, "mgnMode", "cross"); // cross as default marginMode
        }
        object request = new Dictionary<string, object>() {
            { "mgnMode", marginMode },
        };
        object market = null;
        if (isTrue(!isEqual(code, null)))
        {
            object currency = this.currency(code);
            ((IDictionary<string,object>)request)["ccy"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["before"] = subtract(since, 1);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instId"] = getValue(market, "id");
        }
        object response = await this.privateGetAccountInterestAccrued(this.extend(request, parameters));
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "ccy": "USDT",
        //                "instId": "",
        //                "interest": "0.0003960833333334",
        //                "interestRate": "0.0000040833333333",
        //                "liab": "97",
        //                "mgnMode": "",
        //                "ts": "1637312400000",
        //                "type": "1"
        //            },
        //            ...
        //        ],
        //        "msg": ""
        //    }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object interest = this.parseBorrowInterests(data);
        return this.filterByCurrencySinceLimit(interest, code, since, limit);
    }

    public override object parseBorrowInterest(object info, object market = null)
    {
        object instId = this.safeString(info, "instId");
        if (isTrue(!isEqual(instId, null)))
        {
            market = this.safeMarket(instId, market);
        }
        object timestamp = this.safeInteger(info, "ts");
        return new Dictionary<string, object>() {
            { "info", info },
            { "symbol", this.safeString(market, "symbol") },
            { "currency", this.safeCurrencyCode(this.safeString(info, "ccy")) },
            { "interest", this.safeNumber(info, "interest") },
            { "interestRate", this.safeNumber(info, "interestRate") },
            { "amountBorrowed", this.safeNumber(info, "liab") },
            { "marginMode", this.safeString(info, "mgnMode") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }

    /**
     * @method
     * @name okx#borrowCrossMargin
     * @description create a loan to borrow margin (need to be VIP 5 and above)
     * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-vip-loans-borrow-and-repay
     * @param {string} code unified currency code of the currency to borrow
     * @param {float} amount the amount to borrow
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
     */
    public async override Task<object> borrowCrossMargin(object code, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
            { "amt", this.currencyToPrecision(code, amount) },
            { "side", "borrow" },
        };
        object response = await this.privatePostAccountBorrowRepay(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "amt": "102",
        //                 "ccy": "USDT",
        //                 "ordId": "544199684697214976",
        //                 "side": "borrow",
        //                 "state": "1"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object loan = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseMarginLoan(loan, currency);
    }

    /**
     * @method
     * @name okx#repayCrossMargin
     * @description repay borrowed margin and interest
     * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-vip-loans-borrow-and-repay
     * @param {string} code unified currency code of the currency to repay
     * @param {float} amount the amount to repay
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.id] the order ID of borrowing, it is necessary while repaying
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
     */
    public async override Task<object> repayCrossMargin(object code, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object id = this.safeString2(parameters, "id", "ordId");
        parameters = this.omit(parameters, "id");
        if (isTrue(isEqual(id, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " repayCrossMargin() requires an id parameter")) ;
        }
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
            { "amt", this.currencyToPrecision(code, amount) },
            { "side", "repay" },
            { "ordId", id },
        };
        object response = await this.privatePostAccountBorrowRepay(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "amt": "102",
        //                 "ccy": "USDT",
        //                 "ordId": "544199684697214976",
        //                 "side": "repay",
        //                 "state": "1"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object loan = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseMarginLoan(loan, currency);
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        //     {
        //         "amt": "102",
        //         "availLoan": "97",
        //         "ccy": "USDT",
        //         "loanQuota": "6000000",
        //         "posLoan": "0",
        //         "side": "repay",
        //         "usedLoan": "97"
        //     }
        //
        object currencyId = this.safeString(info, "ccy");
        return new Dictionary<string, object>() {
            { "id", null },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber(info, "amt") },
            { "symbol", null },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    /**
     * @method
     * @name okx#fetchOpenInterest
     * @description Retrieves the open interest of a currency
     * @see https://www.okx.com/docs-v5/en/#rest-api-public-data-get-open-interest
     * @param {string} symbol Unified CCXT market symbol
     * @param {object} [params] exchange specific parameters
     * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
     */
    public async override Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "contract")))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterest() supports contract markets only")) ;
        }
        object type = this.convertToInstrumentType(getValue(market, "type"));
        object uly = this.safeString(getValue(market, "info"), "uly");
        object request = new Dictionary<string, object>() {
            { "instType", type },
            { "uly", uly },
            { "instId", getValue(market, "id") },
        };
        object response = await this.publicGetPublicOpenInterest(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "instId": "BTC-USDT-SWAP",
        //                 "instType": "SWAP",
        //                 "oi": "2125419",
        //                 "oiCcy": "21254.19",
        //                 "ts": "1664005108969"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOpenInterest(getValue(data, 0), market);
    }

    /**
     * @method
     * @name okx#fetchOpenInterests
     * @description Retrieves the open interests of some currencies
     * @see https://www.okx.com/docs-v5/en/#rest-api-public-data-get-open-interest
     * @param {string[]} symbols Unified CCXT market symbols
     * @param {object} [params] exchange specific parameters
     * @param {string} params.instType Instrument type, options: 'SWAP', 'FUTURES', 'OPTION', default to 'SWAP'
     * @param {string} params.uly Underlying, Applicable to FUTURES/SWAP/OPTION, if instType is 'OPTION', either uly or instFamily is required
     * @param {string} params.instFamily Instrument family, Applicable to FUTURES/SWAP/OPTION, if instType is 'OPTION', either uly or instFamily is required
     * @returns {object} an dictionary of [open interest structures]{@link https://docs.ccxt.com/#/?id=open-interest-structure}
     */
    public async override Task<object> fetchOpenInterests(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, true, true);
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            market = this.market(getValue(symbols, 0));
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleSubTypeAndParams("fetchOpenInterests", market, parameters, "swap");
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object instType = "SWAP";
        if (isTrue(isEqual(marketType, "future")))
        {
            instType = "FUTURES";
        } else if (isTrue(isEqual(instType, "option")))
        {
            instType = "OPTION";
        }
        object request = new Dictionary<string, object>() {
            { "instType", instType },
        };
        object uly = this.safeString(parameters, "uly");
        if (isTrue(!isEqual(uly, null)))
        {
            ((IDictionary<string,object>)request)["uly"] = uly;
        }
        object instFamily = this.safeString(parameters, "instFamily");
        if (isTrue(!isEqual(instFamily, null)))
        {
            ((IDictionary<string,object>)request)["instFamily"] = instFamily;
        }
        if (isTrue(isTrue(isTrue(isEqual(instType, "OPTION")) && isTrue(isEqual(uly, null))) && isTrue(isEqual(instFamily, null))))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterests() requires either uly or instFamily parameter for OPTION markets")) ;
        }
        object response = await this.publicGetPublicOpenInterest(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "instId": "BTC-USDT-SWAP",
        //                 "instType": "SWAP",
        //                 "oi": "2125419",
        //                 "oiCcy": "21254.19",
        //                 "ts": "1664005108969"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOpenInterests(data, symbols);
    }

    /**
     * @method
     * @name okx#fetchOpenInterestHistory
     * @description Retrieves the open interest history of a currency
     * @see https://www.okx.com/docs-v5/en/#rest-api-trading-data-get-contracts-open-interest-and-volume
     * @see https://www.okx.com/docs-v5/en/#rest-api-trading-data-get-options-open-interest-and-volume
     * @param {string} symbol Unified CCXT currency code or unified symbol
     * @param {string} timeframe "5m", "1h", or "1d" for option only "1d" or "8h"
     * @param {int} [since] The time in ms of the earliest record to retrieve as a unix timestamp
     * @param {int} [limit] Not used by okx, but parsed internally by CCXT
     * @param {object} [params] Exchange specific parameters
     * @param {int} [params.until] The time in ms of the latest record to retrieve as a unix timestamp
     * @returns An array of [open interest structures]{@link https://docs.ccxt.com/#/?id=open-interest-structure}
     */
    public async override Task<object> fetchOpenInterestHistory(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1d";
        parameters ??= new Dictionary<string, object>();
        object options = this.safeDict(this.options, "fetchOpenInterestHistory", new Dictionary<string, object>() {});
        object timeframes = this.safeDict(options, "timeframes", new Dictionary<string, object>() {});
        timeframe = this.safeString(timeframes, timeframe, timeframe);
        if (isTrue(isTrue(isTrue(!isEqual(timeframe, "5m")) && isTrue(!isEqual(timeframe, "1H"))) && isTrue(!isEqual(timeframe, "1D"))))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterestHistory cannot only use the 5m, 1h, and 1d timeframe")) ;
        }
        await this.loadMarkets();
        // handle unified currency code or symbol
        object currencyId = null;
        object market = null;
        if (isTrue(isTrue((inOp(this.markets, symbol))) || isTrue((inOp(this.markets_by_id, symbol)))))
        {
            market = this.market(symbol);
            currencyId = getValue(market, "baseId");
        } else
        {
            object currency = this.currency(symbol);
            currencyId = getValue(currency, "id");
        }
        object request = new Dictionary<string, object>() {
            { "ccy", currencyId },
            { "period", timeframe },
        };
        object type = null;
        object response = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchOpenInterestHistory", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(isEqual(type, "option")))
        {
            response = await this.publicGetRubikStatOptionOpenInterestVolume(this.extend(request, parameters));
        } else
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["begin"] = since;
            }
            object until = this.safeInteger(parameters, "until");
            if (isTrue(!isEqual(until, null)))
            {
                ((IDictionary<string,object>)request)["end"] = until;
                parameters = this.omit(parameters, new List<object>() {"until"});
            }
            response = await this.publicGetRubikStatContractsOpenInterestVolume(this.extend(request, parameters));
        }
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            [
        //                "1648221300000",  // timestamp
        //                "2183354317.945",  // open interest (USD)
        //                "74285877.617",  // volume (USD)
        //            ],
        //            ...
        //        ],
        //        "msg": ''
        //    }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOpenInterestsHistory(data, null, since, limit);
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        // fetchOpenInterestHistory
        //
        //    [
        //        "1648221300000",  // timestamp
        //        "2183354317.945",  // open interest (USD) - (coin) for options
        //        "74285877.617",  // volume (USD) - (coin) for options
        //    ]
        //
        // fetchOpenInterest
        //
        //     {
        //         "instId": "BTC-USD-230520-25500-P",
        //         "instType": "OPTION",
        //         "oi": "300",
        //         "oiCcy": "3",
        //         "oiUsd": "3",
        //         "ts": "1684551166251"
        //     }
        //
        object id = this.safeString(interest, "instId");
        market = this.safeMarket(id, market);
        object time = this.safeInteger(interest, "ts");
        object timestamp = this.safeInteger(interest, 0, time);
        object baseVolume = null;
        object quoteVolume = null;
        object openInterestAmount = null;
        object openInterestValue = null;
        object type = this.safeString(this.options, "defaultType");
        if (isTrue(((interest is IList<object>) || (interest.GetType().IsGenericType && interest.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            if (isTrue(isEqual(type, "option")))
            {
                openInterestAmount = this.safeNumber(interest, 1);
                baseVolume = this.safeNumber(interest, 2);
            } else
            {
                openInterestValue = this.safeNumber(interest, 1);
                quoteVolume = this.safeNumber(interest, 2);
            }
        } else
        {
            baseVolume = this.safeNumber(interest, "oiCcy");
            openInterestAmount = this.safeNumber(interest, "oi");
            openInterestValue = this.safeNumber(interest, "oiUsd");
        }
        return this.safeOpenInterest(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(id) },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "openInterestAmount", openInterestAmount },
            { "openInterestValue", openInterestValue },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", interest },
        }, market);
    }

    public override void setSandboxMode(object enable)
    {
        base.setSandboxMode(enable);
        ((IDictionary<string,object>)this.options)["sandboxMode"] = enable;
        if (isTrue(enable))
        {
            ((IDictionary<string,object>)this.headers)["x-simulated-trading"] = "1";
        } else if (isTrue(inOp(this.headers, "x-simulated-trading")))
        {
            this.headers = this.omit(this.headers, "x-simulated-trading");
        }
    }

    /**
     * @method
     * @name okx#fetchDepositWithdrawFees
     * @description fetch deposit and withdraw fees
     * @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-currencies
     * @param {string[]|undefined} codes list of unified currency codes
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [fees structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(codes, null)))
        {
            object ids = this.currencyIds(codes);
            ((IDictionary<string,object>)request)["ccy"] = String.Join(",", ((IList<object>)ids).ToArray());
        }
        object response = await this.privateGetAssetCurrencies(this.extend(request, parameters));
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "canDep": true,
        //                "canInternal": false,
        //                "canWd": true,
        //                "ccy": "USDT",
        //                "chain": "USDT-TRC20",
        //                "logoLink": "https://static.coinall.ltd/cdn/assets/imgs/221/5F74EB20302D7761.png",
        //                "mainNet": false,
        //                "maxFee": "1.6",
        //                "maxWd": "8852150",
        //                "minFee": "0.8",
        //                "minWd": "2",
        //                "name": "Tether",
        //                "usedWdQuota": "0",
        //                "wdQuota": "500",
        //                "wdTickSz": "3"
        //            },
        //            {
        //                "canDep": true,
        //                "canInternal": false,
        //                "canWd": true,
        //                "ccy": "USDT",
        //                "chain": "USDT-ERC20",
        //                "logoLink": "https://static.coinall.ltd/cdn/assets/imgs/221/5F74EB20302D7761.png",
        //                "mainNet": false,
        //                "maxFee": "16",
        //                "maxWd": "8852150",
        //                "minFee": "8",
        //                "minWd": "2",
        //                "name": "Tether",
        //                "usedWdQuota": "0",
        //                "wdQuota": "500",
        //                "wdTickSz": "3"
        //            },
        //            ...
        //        ],
        //        "msg": ""
        //    }
        //
        object data = this.safeList(response, "data");
        return this.parseDepositWithdrawFees(data, codes);
    }

    public override object parseDepositWithdrawFees(object response, object codes = null, object currencyIdKey = null)
    {
        //
        // [
        //   {
        //       "canDep": true,
        //       "canInternal": false,
        //       "canWd": true,
        //       "ccy": "USDT",
        //       "chain": "USDT-TRC20",
        //       "logoLink": "https://static.coinall.ltd/cdn/assets/imgs/221/5F74EB20302D7761.png",
        //       "mainNet": false,
        //       "maxFee": "1.6",
        //       "maxWd": "8852150",
        //       "minFee": "0.8",
        //       "minWd": "2",
        //       "name": "Tether",
        //       "usedWdQuota": "0",
        //       "wdQuota": "500",
        //       "wdTickSz": "3"
        //   }
        // ]
        //
        object depositWithdrawFees = new Dictionary<string, object>() {};
        codes = this.marketCodes(codes);
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object feeInfo = getValue(response, i);
            object currencyId = this.safeString(feeInfo, "ccy");
            object code = this.safeCurrencyCode(currencyId);
            if (isTrue(isTrue((isEqual(codes, null))) || isTrue((this.inArray(code, codes)))))
            {
                object depositWithdrawFee = this.safeValue(depositWithdrawFees, code);
                if (isTrue(isEqual(depositWithdrawFee, null)))
                {
                    ((IDictionary<string,object>)depositWithdrawFees)[(string)code] = this.depositWithdrawFee(new Dictionary<string, object>() {});
                }
                ((IDictionary<string,object>)getValue(getValue(depositWithdrawFees, code), "info"))[(string)currencyId] = feeInfo;
                object chain = this.safeString(feeInfo, "chain");
                if (isTrue(isEqual(chain, null)))
                {
                    continue;
                }
                object chainSplit = ((string)chain).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
                object networkId = this.safeValue(chainSplit, 1);
                object withdrawFee = this.safeNumber(feeInfo, "fee");
                object withdrawResult = new Dictionary<string, object>() {
                    { "fee", withdrawFee },
                    { "percentage", ((bool) isTrue((!isEqual(withdrawFee, null)))) ? false : null },
                };
                object depositResult = new Dictionary<string, object>() {
                    { "fee", null },
                    { "percentage", null },
                };
                object networkCode = this.networkIdToCode(networkId, code);
                ((IDictionary<string,object>)getValue(getValue(depositWithdrawFees, code), "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                    { "withdraw", withdrawResult },
                    { "deposit", depositResult },
                };
            }
        }
        object depositWithdrawCodes = new List<object>(((IDictionary<string,object>)depositWithdrawFees).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(depositWithdrawCodes)); postFixIncrement(ref i))
        {
            object code = getValue(depositWithdrawCodes, i);
            object currency = this.currency(code);
            ((IDictionary<string,object>)depositWithdrawFees)[(string)code] = this.assignDefaultDepositWithdrawFees(getValue(depositWithdrawFees, code), currency);
        }
        return depositWithdrawFees;
    }

    /**
     * @method
     * @name okx#fetchSettlementHistory
     * @description fetches historical settlement records
     * @see https://www.okx.com/docs-v5/en/#rest-api-public-data-get-delivery-exercise-history
     * @param {string} symbol unified market symbol to fetch the settlement history for
     * @param {int} [since] timestamp in ms
     * @param {int} [limit] number of records
     * @param {object} [params] exchange specific params
     * @returns {object[]} a list of [settlement history objects]{@link https://docs.ccxt.com/#/?id=settlement-history-structure}
     */
    public async virtual Task<object> fetchSettlementHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchSettlementHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchSettlementHistory", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(isTrue(!isEqual(type, "future")) && isTrue(!isEqual(type, "option"))))
        {
            throw new NotSupported ((string)add(this.id, " fetchSettlementHistory() supports futures and options markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "instType", this.convertToInstrumentType(type) },
            { "uly", add(add(getValue(market, "baseId"), "-"), getValue(market, "quoteId")) },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["before"] = subtract(since, 1);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.publicGetPublicDeliveryExerciseHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "details": [
        //                     {
        //                         "insId": "BTC-USD-230523-25750-C",
        //                         "px": "27290.1486867000556483",
        //                         "type": "exercised"
        //                     },
        //                 ],
        //                 "ts":"1684656000000"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object settlements = this.parseSettlements(data, market);
        object sorted = this.sortBy(settlements, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    public virtual object parseSettlement(object settlement, object market)
    {
        //
        //     {
        //         "insId": "BTC-USD-230521-28500-P",
        //         "px": "27081.2007345984751516",
        //         "type": "exercised"
        //     }
        //
        object marketId = this.safeString(settlement, "insId");
        return new Dictionary<string, object>() {
            { "info", settlement },
            { "symbol", this.safeSymbol(marketId, market) },
            { "price", this.safeNumber(settlement, "px") },
            { "timestamp", null },
            { "datetime", null },
        };
    }

    public virtual object parseSettlements(object settlements, object market)
    {
        //
        //     {
        //         "details": [
        //             {
        //                 "insId": "BTC-USD-230523-25750-C",
        //                 "px": "27290.1486867000556483",
        //                 "type": "exercised"
        //             },
        //         ],
        //         "ts":"1684656000000"
        //     }
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(settlements)); postFixIncrement(ref i))
        {
            object entry = getValue(settlements, i);
            object timestamp = this.safeInteger(entry, "ts");
            object details = this.safeList(entry, "details", new List<object>() {});
            for (object j = 0; isLessThan(j, getArrayLength(details)); postFixIncrement(ref j))
            {
                object settlement = this.parseSettlement(getValue(details, j), market);
                ((IList<object>)result).Add(this.extend(settlement, new Dictionary<string, object>() {
                    { "timestamp", timestamp },
                    { "datetime", this.iso8601(timestamp) },
                }));
            }
        }
        return result;
    }

    /**
     * @method
     * @name okx#fetchUnderlyingAssets
     * @description fetches the market ids of underlying assets for a specific contract market type
     * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-underlying
     * @param {object} [params] exchange specific params
     * @param {string} [params.type] the contract market type, 'option', 'swap' or 'future', the default is 'option'
     * @returns {object[]} a list of [underlying assets]{@link https://docs.ccxt.com/#/?id=underlying-assets-structure}
     */
    public async virtual Task<object> fetchUnderlyingAssets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchUnderlyingAssets", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(isTrue((isEqual(marketType, null))) || isTrue((isEqual(marketType, "spot")))))
        {
            marketType = "option";
        }
        if (isTrue(isTrue(isTrue((!isEqual(marketType, "option"))) && isTrue((!isEqual(marketType, "swap")))) && isTrue((!isEqual(marketType, "future")))))
        {
            throw new NotSupported ((string)add(this.id, " fetchUnderlyingAssets() supports contract markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "instType", this.convertToInstrumentType(marketType) },
        };
        object response = await this.publicGetPublicUnderlying(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             [
        //                 "BTC-USD",
        //                 "ETH-USD"
        //             ]
        //         ],
        //         "msg": ""
        //     }
        //
        object underlyings = this.safeList(response, "data", new List<object>() {});
        return getValue(underlyings, 0);
    }

    /**
     * @method
     * @name okx#fetchGreeks
     * @description fetches an option contracts greeks, financial metrics used to measure the factors that affect the price of an options contract
     * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-option-market-data
     * @param {string} symbol unified symbol of the market to fetch greeks for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [greeks structure]{@link https://docs.ccxt.com/#/?id=greeks-structure}
     */
    public async override Task<object> fetchGreeks(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = getValue(market, "id");
        object optionParts = ((string)marketId).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
        object request = new Dictionary<string, object>() {
            { "uly", getValue(getValue(market, "info"), "uly") },
            { "instFamily", getValue(getValue(market, "info"), "instFamily") },
            { "expTime", this.safeString(optionParts, 2) },
        };
        object response = await this.publicGetPublicOptSummary(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "askVol": "0",
        //                 "bidVol": "0",
        //                 "delta": "0.5105464486882039",
        //                 "deltaBS": "0.7325502184143025",
        //                 "fwdPx": "37675.80158694987186",
        //                 "gamma": "-0.13183515090501083",
        //                 "gammaBS": "0.000024139685826358558",
        //                 "instId": "BTC-USD-240329-32000-C",
        //                 "instType": "OPTION",
        //                 "lever": "4.504428015946619",
        //                 "markVol": "0.5916253554539876",
        //                 "realVol": "0",
        //                 "theta": "-0.0004202992014012855",
        //                 "thetaBS": "-18.52354631567909",
        //                 "ts": "1699586421976",
        //                 "uly": "BTC-USD",
        //                 "vega": "0.0020207455080045846",
        //                 "vegaBS": "74.44022302387287",
        //                 "volLv": "0.5948549730405797"
        //             },
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object entryMarketId = this.safeString(entry, "instId");
            if (isTrue(isEqual(entryMarketId, marketId)))
            {
                return this.parseGreeks(entry, market);
            }
        }
        return null;
    }

    /**
     * @method
     * @name okx#fetchAllGreeks
     * @description fetches all option contracts greeks, financial metrics used to measure the factors that affect the price of an options contract
     * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-option-market-data
     * @param {string[]} [symbols] unified symbols of the markets to fetch greeks for, all markets are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} params.uly Underlying, either uly or instFamily is required
     * @param {string} params.instFamily Instrument family, either uly or instFamily is required
     * @returns {object} a [greeks structure]{@link https://docs.ccxt.com/#/?id=greeks-structure}
     */
    public async override Task<object> fetchAllGreeks(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        symbols = this.marketSymbols(symbols, null, true, true, true);
        object symbolsLength = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            symbolsLength = getArrayLength(symbols);
        }
        if (isTrue(isTrue((isEqual(symbols, null))) || isTrue((!isEqual(symbolsLength, 1)))))
        {
            object uly = this.safeString(parameters, "uly");
            if (isTrue(!isEqual(uly, null)))
            {
                ((IDictionary<string,object>)request)["uly"] = uly;
            }
            object instFamily = this.safeString(parameters, "instFamily");
            if (isTrue(!isEqual(instFamily, null)))
            {
                ((IDictionary<string,object>)request)["instFamily"] = instFamily;
            }
            if (isTrue(isTrue((isEqual(uly, null))) && isTrue((isEqual(instFamily, null)))))
            {
                throw new BadRequest ((string)add(this.id, " fetchAllGreeks() requires either a uly or instFamily parameter")) ;
            }
        }
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            if (isTrue(isEqual(symbolsLength, 1)))
            {
                market = this.market(getValue(symbols, 0));
                object marketId = getValue(market, "id");
                object optionParts = ((string)marketId).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
                ((IDictionary<string,object>)request)["uly"] = getValue(getValue(market, "info"), "uly");
                ((IDictionary<string,object>)request)["instFamily"] = getValue(getValue(market, "info"), "instFamily");
                ((IDictionary<string,object>)request)["expTime"] = this.safeString(optionParts, 2);
            }
        }
        parameters = this.omit(parameters, new List<object>() {"uly", "instFamily"});
        object response = await this.publicGetPublicOptSummary(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "askVol": "0",
        //                 "bidVol": "0",
        //                 "delta": "0.5105464486882039",
        //                 "deltaBS": "0.7325502184143025",
        //                 "fwdPx": "37675.80158694987186",
        //                 "gamma": "-0.13183515090501083",
        //                 "gammaBS": "0.000024139685826358558",
        //                 "instId": "BTC-USD-240329-32000-C",
        //                 "instType": "OPTION",
        //                 "lever": "4.504428015946619",
        //                 "markVol": "0.5916253554539876",
        //                 "realVol": "0",
        //                 "theta": "-0.0004202992014012855",
        //                 "thetaBS": "-18.52354631567909",
        //                 "ts": "1699586421976",
        //                 "uly": "BTC-USD",
        //                 "vega": "0.0020207455080045846",
        //                 "vegaBS": "74.44022302387287",
        //                 "volLv": "0.5948549730405797"
        //             },
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseAllGreeks(data, symbols);
    }

    public override object parseGreeks(object greeks, object market = null)
    {
        //
        //     {
        //         "askVol": "0",
        //         "bidVol": "0",
        //         "delta": "0.5105464486882039",
        //         "deltaBS": "0.7325502184143025",
        //         "fwdPx": "37675.80158694987186",
        //         "gamma": "-0.13183515090501083",
        //         "gammaBS": "0.000024139685826358558",
        //         "instId": "BTC-USD-240329-32000-C",
        //         "instType": "OPTION",
        //         "lever": "4.504428015946619",
        //         "markVol": "0.5916253554539876",
        //         "realVol": "0",
        //         "theta": "-0.0004202992014012855",
        //         "thetaBS": "-18.52354631567909",
        //         "ts": "1699586421976",
        //         "uly": "BTC-USD",
        //         "vega": "0.0020207455080045846",
        //         "vegaBS": "74.44022302387287",
        //         "volLv": "0.5948549730405797"
        //     }
        //
        object timestamp = this.safeInteger(greeks, "ts");
        object marketId = this.safeString(greeks, "instId");
        object symbol = this.safeSymbol(marketId, market);
        return new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "delta", this.safeNumber(greeks, "delta") },
            { "gamma", this.safeNumber(greeks, "gamma") },
            { "theta", this.safeNumber(greeks, "theta") },
            { "vega", this.safeNumber(greeks, "vega") },
            { "rho", null },
            { "bidSize", null },
            { "askSize", null },
            { "bidImpliedVolatility", this.safeNumber(greeks, "bidVol") },
            { "askImpliedVolatility", this.safeNumber(greeks, "askVol") },
            { "markImpliedVolatility", this.safeNumber(greeks, "markVol") },
            { "bidPrice", null },
            { "askPrice", null },
            { "markPrice", null },
            { "lastPrice", null },
            { "underlyingPrice", null },
            { "info", greeks },
        };
    }

    /**
     * @method
     * @name okx#closePosition
     * @description closes open positions for a market
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-close-positions
     * @param {string} symbol Unified CCXT market symbol
     * @param {string} [side] 'buy' or 'sell', leave as undefined in net mode
     * @param {object} [params] extra parameters specific to the okx api endpoint
     * @param {string} [params.clientOrderId] a unique identifier for the order
     * @param {string} [params.marginMode] 'cross' or 'isolated', default is 'cross;
     * @param {string} [params.code] *required in the case of closing cross MARGIN position for Single-currency margin* margin currency
     *
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {boolean} [params.autoCxl] whether any pending orders for closing out needs to be automatically canceled when close position via a market order. false or true, the default is false
     * @param {string} [params.tag] order tag a combination of case-sensitive alphanumerics, all numbers, or all letters of up to 16 characters
     * @returns {object[]} [A list of position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> closePosition(object symbol, object side = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        object code = this.safeString(parameters, "code");
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("closePosition", parameters, "cross");
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "mgnMode", marginMode },
        };
        if (isTrue(!isEqual(side, null)))
        {
            if (isTrue((isEqual(side, "buy"))))
            {
                ((IDictionary<string,object>)request)["posSide"] = "long";
            } else if (isTrue(isEqual(side, "sell")))
            {
                ((IDictionary<string,object>)request)["posSide"] = "short";
            } else
            {
                ((IDictionary<string,object>)request)["posSide"] = side;
            }
        }
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clOrdId"] = clientOrderId;
        }
        if (isTrue(!isEqual(code, null)))
        {
            object currency = this.currency(code);
            ((IDictionary<string,object>)request)["ccy"] = getValue(currency, "id");
        }
        object response = await this.privatePostTradeClosePosition(this.extend(request, parameters));
        //
        //    {
        //        "code": "1",
        //        "data": [
        //            {
        //                "clOrdId":"e847386590ce4dBCe903bbc394dc88bf",
        //                "ordId":"",
        //                "sCode":"51000",
        //                "sMsg":"Parameter posSide error ",
        //                "tag":"e847386590ce4dBC"
        //            }
        //        ],
        //        "inTime": "1701877077101064",
        //        "msg": "All operations failed",
        //        "outTime": "1701877077102579"
        //    }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object order = this.safeDict(data, 0);
        return this.parseOrder(order, market);
    }

    /**
     * @method
     * @name okx#fetchOption
     * @description fetches option data that is commonly found in an option chain
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-get-ticker
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [option chain structure]{@link https://docs.ccxt.com/#/?id=option-chain-structure}
     */
    public async override Task<object> fetchOption(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object response = await this.publicGetMarketTicker(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "instType": "OPTION",
        //                 "instId": "BTC-USD-241227-60000-P",
        //                 "last": "",
        //                 "lastSz": "0",
        //                 "askPx": "",
        //                 "askSz": "0",
        //                 "bidPx": "",
        //                 "bidSz": "0",
        //                 "open24h": "",
        //                 "high24h": "",
        //                 "low24h": "",
        //                 "volCcy24h": "0",
        //                 "vol24h": "0",
        //                 "ts": "1711176035035",
        //                 "sodUtc0": "",
        //                 "sodUtc8": ""
        //             }
        //         ]
        //     }
        //
        object result = this.safeList(response, "data", new List<object>() {});
        object chain = this.safeDict(result, 0, new Dictionary<string, object>() {});
        return this.parseOption(chain, null, market);
    }

    /**
     * @method
     * @name okx#fetchOptionChain
     * @description fetches data for an underlying asset that is commonly found in an option chain
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-get-tickers
     * @param {string} code base currency to fetch an option chain for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.uly] the underlying asset, can be obtained from fetchUnderlyingAssets ()
     * @returns {object} a list of [option chain structures]{@link https://docs.ccxt.com/#/?id=option-chain-structure}
     */
    public async override Task<object> fetchOptionChain(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "uly", add(getValue(currency, "code"), "-USD") },
            { "instType", "OPTION" },
        };
        object response = await this.publicGetMarketTickers(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "instType": "OPTION",
        //                 "instId": "BTC-USD-240323-52000-C",
        //                 "last": "",
        //                 "lastSz": "0",
        //                 "askPx": "",
        //                 "askSz": "0",
        //                 "bidPx": "",
        //                 "bidSz": "0",
        //                 "open24h": "",
        //                 "high24h": "",
        //                 "low24h": "",
        //                 "volCcy24h": "0",
        //                 "vol24h": "0",
        //                 "ts": "1711176207008",
        //                 "sodUtc0": "",
        //                 "sodUtc8": ""
        //             },
        //         ]
        //     }
        //
        object result = this.safeList(response, "data", new List<object>() {});
        return this.parseOptionChain(result, null, "instId");
    }

    public override object parseOption(object chain, object currency = null, object market = null)
    {
        //
        //     {
        //         "instType": "OPTION",
        //         "instId": "BTC-USD-241227-60000-P",
        //         "last": "",
        //         "lastSz": "0",
        //         "askPx": "",
        //         "askSz": "0",
        //         "bidPx": "",
        //         "bidSz": "0",
        //         "open24h": "",
        //         "high24h": "",
        //         "low24h": "",
        //         "volCcy24h": "0",
        //         "vol24h": "0",
        //         "ts": "1711176035035",
        //         "sodUtc0": "",
        //         "sodUtc8": ""
        //     }
        //
        object marketId = this.safeString(chain, "instId");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(chain, "ts");
        return new Dictionary<string, object>() {
            { "info", chain },
            { "currency", null },
            { "symbol", getValue(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "impliedVolatility", null },
            { "openInterest", null },
            { "bidPrice", this.safeNumber(chain, "bidPx") },
            { "askPrice", this.safeNumber(chain, "askPx") },
            { "midPrice", null },
            { "markPrice", null },
            { "lastPrice", this.safeNumber(chain, "last") },
            { "underlyingPrice", null },
            { "change", null },
            { "percentage", null },
            { "baseVolume", this.safeNumber(chain, "volCcy24h") },
            { "quoteVolume", null },
        };
    }

    /**
     * @method
     * @name okx#fetchConvertQuote
     * @description fetch a quote for converting from one currency to another
     * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-estimate-quote
     * @param {string} fromCode the currency that you want to sell and convert from
     * @param {string} toCode the currency that you want to buy and convert into
     * @param {float} [amount] how much you want to trade in units of the from currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
     */
    public async override Task<object> fetchConvertQuote(object fromCode, object toCode, object amount = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "baseCcy", ((string)fromCode).ToUpper() },
            { "quoteCcy", ((string)toCode).ToUpper() },
            { "rfqSzCcy", ((string)fromCode).ToUpper() },
            { "rfqSz", this.numberToString(amount) },
            { "side", "sell" },
        };
        object response = await this.privatePostAssetConvertEstimateQuote(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "baseCcy": "ETH",
        //                 "baseSz": "0.01023052",
        //                 "clQReqId": "",
        //                 "cnvtPx": "2932.40104429",
        //                 "origRfqSz": "30",
        //                 "quoteCcy": "USDT",
        //                 "quoteId": "quoterETH-USDT16461885104612381",
        //                 "quoteSz": "30",
        //                 "quoteTime": "1646188510461",
        //                 "rfqSz": "30",
        //                 "rfqSzCcy": "USDT",
        //                 "side": "buy",
        //                 "ttlMs": "10000"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = this.safeDict(data, 0, new Dictionary<string, object>() {});
        object fromCurrencyId = this.safeString(result, "baseCcy", fromCode);
        object fromCurrency = this.currency(fromCurrencyId);
        object toCurrencyId = this.safeString(result, "quoteCcy", toCode);
        object toCurrency = this.currency(toCurrencyId);
        return this.parseConversion(result, fromCurrency, toCurrency);
    }

    /**
     * @method
     * @name okx#createConvertTrade
     * @description convert from one currency to another
     * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-convert-trade
     * @param {string} id the id of the trade that you want to make
     * @param {string} fromCode the currency that you want to sell and convert from
     * @param {string} toCode the currency that you want to buy and convert into
     * @param {float} [amount] how much you want to trade in units of the from currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
     */
    public async override Task<object> createConvertTrade(object id, object fromCode, object toCode, object amount = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "quoteId", id },
            { "baseCcy", fromCode },
            { "quoteCcy", toCode },
            { "szCcy", fromCode },
            { "sz", this.numberToString(amount) },
            { "side", "sell" },
        };
        object response = await this.privatePostAssetConvertTrade(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "baseCcy": "ETH",
        //                 "clTReqId": "",
        //                 "fillBaseSz": "0.01023052",
        //                 "fillPx": "2932.40104429",
        //                 "fillQuoteSz": "30",
        //                 "instId": "ETH-USDT",
        //                 "quoteCcy": "USDT",
        //                 "quoteId": "quoterETH-USDT16461885104612381",
        //                 "side": "buy",
        //                 "state": "fullyFilled",
        //                 "tradeId": "trader16461885203381437",
        //                 "ts": "1646188520338"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = this.safeDict(data, 0, new Dictionary<string, object>() {});
        object fromCurrencyId = this.safeString(result, "baseCcy", fromCode);
        object fromCurrency = this.currency(fromCurrencyId);
        object toCurrencyId = this.safeString(result, "quoteCcy", toCode);
        object toCurrency = this.currency(toCurrencyId);
        return this.parseConversion(result, fromCurrency, toCurrency);
    }

    /**
     * @method
     * @name okx#fetchConvertTrade
     * @description fetch the data for a conversion trade
     * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-get-convert-history
     * @param {string} id the id of the trade that you want to fetch
     * @param {string} [code] the unified currency code of the conversion trade
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
     */
    public async override Task<object> fetchConvertTrade(object id, object code = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "clTReqId", id },
        };
        object response = await this.privateGetAssetConvertHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "clTReqId": "",
        //                 "instId": "ETH-USDT",
        //                 "side": "buy",
        //                 "fillPx": "2932.401044",
        //                 "baseCcy": "ETH",
        //                 "quoteCcy": "USDT",
        //                 "fillBaseSz": "0.01023052",
        //                 "state": "fullyFilled",
        //                 "tradeId": "trader16461885203381437",
        //                 "fillQuoteSz": "30",
        //                 "ts": "1646188520000"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = this.safeDict(data, 0, new Dictionary<string, object>() {});
        object fromCurrencyId = this.safeString(result, "baseCcy");
        object toCurrencyId = this.safeString(result, "quoteCcy");
        object fromCurrency = null;
        object toCurrency = null;
        if (isTrue(!isEqual(fromCurrencyId, null)))
        {
            fromCurrency = this.currency(fromCurrencyId);
        }
        if (isTrue(!isEqual(toCurrencyId, null)))
        {
            toCurrency = this.currency(toCurrencyId);
        }
        return this.parseConversion(result, fromCurrency, toCurrency);
    }

    /**
     * @method
     * @name okx#fetchConvertTradeHistory
     * @description fetch the users history of conversion trades
     * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-get-convert-history
     * @param {string} [code] the unified currency code
     * @param {int} [since] the earliest time in ms to fetch conversions for
     * @param {int} [limit] the maximum number of conversion structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest conversion to fetch
     * @returns {object[]} a list of [conversion structures]{@link https://docs.ccxt.com/#/?id=conversion-structure}
     */
    public async override Task<object> fetchConvertTradeHistory(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        var requestparametersVariable = this.handleUntilOption("after", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["before"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetAssetConvertHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "clTReqId": "",
        //                 "instId": "ETH-USDT",
        //                 "side": "buy",
        //                 "fillPx": "2932.401044",
        //                 "baseCcy": "ETH",
        //                 "quoteCcy": "USDT",
        //                 "fillBaseSz": "0.01023052",
        //                 "state": "fullyFilled",
        //                 "tradeId": "trader16461885203381437",
        //                 "fillQuoteSz": "30",
        //                 "ts": "1646188520000"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object rows = this.safeList(response, "data", new List<object>() {});
        return this.parseConversions(rows, code, "baseCcy", "quoteCcy", since, limit);
    }

    public override object parseConversion(object conversion, object fromCurrency = null, object toCurrency = null)
    {
        //
        // fetchConvertQuote
        //
        //     {
        //         "baseCcy": "ETH",
        //         "baseSz": "0.01023052",
        //         "clQReqId": "",
        //         "cnvtPx": "2932.40104429",
        //         "origRfqSz": "30",
        //         "quoteCcy": "USDT",
        //         "quoteId": "quoterETH-USDT16461885104612381",
        //         "quoteSz": "30",
        //         "quoteTime": "1646188510461",
        //         "rfqSz": "30",
        //         "rfqSzCcy": "USDT",
        //         "side": "buy",
        //         "ttlMs": "10000"
        //     }
        //
        // createConvertTrade
        //
        //     {
        //         "baseCcy": "ETH",
        //         "clTReqId": "",
        //         "fillBaseSz": "0.01023052",
        //         "fillPx": "2932.40104429",
        //         "fillQuoteSz": "30",
        //         "instId": "ETH-USDT",
        //         "quoteCcy": "USDT",
        //         "quoteId": "quoterETH-USDT16461885104612381",
        //         "side": "buy",
        //         "state": "fullyFilled",
        //         "tradeId": "trader16461885203381437",
        //         "ts": "1646188520338"
        //     }
        //
        // fetchConvertTrade, fetchConvertTradeHistory
        //
        //     {
        //         "clTReqId": "",
        //         "instId": "ETH-USDT",
        //         "side": "buy",
        //         "fillPx": "2932.401044",
        //         "baseCcy": "ETH",
        //         "quoteCcy": "USDT",
        //         "fillBaseSz": "0.01023052",
        //         "state": "fullyFilled",
        //         "tradeId": "trader16461885203381437",
        //         "fillQuoteSz": "30",
        //         "ts": "1646188520000"
        //     }
        //
        object timestamp = this.safeInteger2(conversion, "quoteTime", "ts");
        object fromCoin = this.safeString(conversion, "baseCcy");
        object fromCode = this.safeCurrencyCode(fromCoin, fromCurrency);
        object to = this.safeString(conversion, "quoteCcy");
        object toCode = this.safeCurrencyCode(to, toCurrency);
        return new Dictionary<string, object>() {
            { "info", conversion },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", this.safeStringN(conversion, new List<object>() {"clQReqId", "tradeId", "quoteId"}) },
            { "fromCurrency", fromCode },
            { "fromAmount", this.safeNumber2(conversion, "baseSz", "fillBaseSz") },
            { "toCurrency", toCode },
            { "toAmount", this.safeNumber2(conversion, "quoteSz", "fillQuoteSz") },
            { "price", this.safeNumber2(conversion, "cnvtPx", "fillPx") },
            { "fee", null },
        };
    }

    /**
     * @method
     * @name okx#fetchConvertCurrencies
     * @description fetches all available currencies that can be converted
     * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-get-convert-currencies
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchConvertCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetAssetConvertCurrencies(parameters);
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "ccy": "BTC",
        //                 "max": "",
        //                 "min": ""
        //             },
        //         ],
        //         "msg": ""
        //     }
        //
        object result = new Dictionary<string, object>() {};
        object data = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object id = this.safeString(entry, "ccy");
            object code = this.safeCurrencyCode(id);
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "info", entry },
                { "id", id },
                { "code", code },
                { "networks", null },
                { "type", null },
                { "name", null },
                { "active", null },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "precision", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(entry, "min") },
                        { "max", this.safeNumber(entry, "max") },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", null },
            };
        }
        return result;
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        //
        //    {
        //        "code": "1",
        //        "data": [
        //            {
        //                "clOrdId": "",
        //                "ordId": "",
        //                "sCode": "51119",
        //                "sMsg": "Order placement failed due to insufficient balance. ",
        //                "tag": ""
        //            }
        //        ],
        //        "msg": ""
        //    },
        //    {
        //        "code": "58001",
        //        "data": [],
        //        "msg": "Incorrect trade password"
        //    }
        //
        object code = this.safeString(response, "code");
        if (isTrue(isTrue((!isEqual(code, "0"))) && isTrue((!isEqual(code, "2")))))
        {
            object feedback = add(add(this.id, " "), body);
            object data = this.safeList(response, "data", new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object error = getValue(data, i);
                object errorCode = this.safeString(error, "sCode");
                object message = this.safeString(error, "sMsg");
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
                this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            }
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }

    /**
     * @method
     * @name okx#fetchMarginAdjustmentHistory
     * @description fetches the history of margin added or reduced from contract isolated positions
     * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-bills-details-last-7-days
     * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-bills-details-last-3-months
     * @param {string} [symbol] not used by okx fetchMarginAdjustmentHistory
     * @param {string} [type] "add" or "reduce"
     * @param {int} [since] the earliest time in ms to fetch margin adjustment history for
     * @param {int} [limit] the maximum number of entries to retrieve
     * @param {object} params extra parameters specific to the exchange api endpoint
     * @param {boolean} [params.auto] true if fetching auto margin increases
     * @returns {object[]} a list of [margin structures]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
     */
    public async override Task<object> fetchMarginAdjustmentHistory(object symbol = null, object type = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object auto = this.safeBool(parameters, "auto");
        if (isTrue(isEqual(type, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMarginAdjustmentHistory () requires a type argument")) ;
        }
        object isAdd = isEqual(type, "add");
        object subType = ((bool) isTrue(isAdd)) ? "160" : "161";
        if (isTrue(auto))
        {
            if (isTrue(isAdd))
            {
                subType = "162";
            } else
            {
                throw new BadRequest ((string)add(add(this.id, " cannot fetch margin adjustments for type "), type)) ;
            }
        }
        object request = new Dictionary<string, object>() {
            { "subType", subType },
            { "mgnMode", "isolated" },
        };
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = null;
        object now = this.milliseconds();
        object oneWeekAgo = subtract(now, 604800000);
        object threeMonthsAgo = subtract(now, 7776000000);
        if (isTrue(isTrue((isEqual(since, null))) || isTrue((isGreaterThan(since, oneWeekAgo)))))
        {
            response = await this.privateGetAccountBills(this.extend(request, parameters));
        } else if (isTrue(isGreaterThan(since, threeMonthsAgo)))
        {
            response = await this.privateGetAccountBillsArchive(this.extend(request, parameters));
        } else
        {
            throw new BadRequest ((string)add(this.id, " fetchMarginAdjustmentHistory () cannot fetch margin adjustments older than 3 months")) ;
        }
        //
        //    {
        //        code: '0',
        //        data: [
        //            {
        //                bal: '67621.4325135010619812',
        //                balChg: '-10.0000000000000000',
        //                billId: '691293628710342659',
        //                ccy: 'USDT',
        //                clOrdId: '',
        //                execType: '',
        //                fee: '0',
        //                fillFwdPx: '',
        //                fillIdxPx: '',
        //                fillMarkPx: '',
        //                fillMarkVol: '',
        //                fillPxUsd: '',
        //                fillPxVol: '',
        //                fillTime: '1711089244850',
        //                from: '',
        //                instId: 'XRP-USDT-SWAP',
        //                instType: 'SWAP',
        //                interest: '0',
        //                mgnMode: 'isolated',
        //                notes: '',
        //                ordId: '',
        //                pnl: '0',
        //                posBal: '73.12',
        //                posBalChg: '10.00',
        //                px: '',
        //                subType: '160',
        //                sz: '10',
        //                tag: '',
        //                to: '',
        //                tradeId: '0',
        //                ts: '1711089244699',
        //                type: '6'
        //            }
        //        ],
        //        msg: ''
        //    }
        //
        object data = this.safeList(response, "data");
        object modifications = this.parseMarginModifications(data);
        return this.filterBySymbolSinceLimit(modifications, symbol, since, limit);
    }

    /**
     * @method
     * @name okx#fetchPositionsHistory
     * @description fetches historical positions
     * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-positions-history
     * @param {string} [symbols] unified market symbols
     * @param {int} [since] timestamp in ms of the earliest position to fetch
     * @param {int} [limit] the maximum amount of records to fetch, default=100, max=100
     * @param {object} params extra parameters specific to the exchange api endpoint
     * @param {string} [params.marginMode] "cross" or "isolated"
     *
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {string} [params.instType] margin, swap, futures or option
     * @param {string} [params.type] the type of latest close position 1: close position partially, 2close all, 3liquidation, 4partial liquidation; 5adl, is it is the latest type if there are several types for the same position
     * @param {string} [params.posId] position id, there is attribute expiration, the posid will be expired if it is more than 30 days after the last full close position, then position will use new posid
     * @param {string} [params.before] timestamp in ms of the earliest position to fetch based on the last update time of the position
     * @param {string} [params.after] timestamp in ms of the latest position to fetch based on the last update time of the position
     * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositionsHistory(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marginMode = this.safeString(parameters, "marginMode");
        object instType = this.safeStringUpper(parameters, "instType");
        parameters = this.omit(parameters, new List<object>() {"until", "marginMode", "instType"});
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100;
        }
        object request = new Dictionary<string, object>() {
            { "limit", limit },
        };
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(isEqual(symbolsLength, 1)))
            {
                object market = this.market(getValue(symbols, 0));
                ((IDictionary<string,object>)request)["instId"] = getValue(market, "id");
            }
        }
        if (isTrue(!isEqual(marginMode, null)))
        {
            ((IDictionary<string,object>)request)["mgnMode"] = marginMode;
        }
        if (isTrue(!isEqual(instType, null)))
        {
            ((IDictionary<string,object>)request)["instType"] = instType;
        }
        object response = await this.privateGetAccountPositionsHistory(this.extend(request, parameters));
        //
        //    {
        //        code: '0',
        //        data: [
        //            {
        //                cTime: '1708735940395',
        //                ccy: 'USDT',
        //                closeAvgPx: '0.6330444444444444',
        //                closeTotalPos: '27',
        //                direction: 'long',
        //                fee: '-1.69566',
        //                fundingFee: '-11.870404179341788',
        //                instId: 'XRP-USDT-SWAP',
        //                instType: 'SWAP',
        //                lever: '3.0',
        //                liqPenalty: '0',
        //                mgnMode: 'cross',
        //                openAvgPx: '0.623',
        //                openMaxPos: '15',
        //                pnl: '27.11999999999988',
        //                pnlRatio: '0.0241732402722634',
        //                posId: '681423155054862336',
        //                realizedPnl: '13.553935820658092',
        //                triggerPx: '',
        //                type: '2',
        //                uTime: '1711088748170',
        //                uly: 'XRP-USDT'
        //            },
        //            ...
        //        ],
        //        msg: ''
        //    }
        //
        object data = this.safeList(response, "data");
        object positions = this.parsePositions(data, symbols, parameters);
        return this.filterBySinceLimit(positions, since, limit);
    }

    /**
     * @method
     * @name okx#fetchLongShortRatioHistory
     * @description fetches the long short ratio history for a unified market symbol
     * @see https://www.okx.com/docs-v5/en/#trading-statistics-rest-api-get-contract-long-short-ratio
     * @param {string} symbol unified symbol of the market to fetch the long short ratio for
     * @param {string} [timeframe] the period for the ratio
     * @param {int} [since] the earliest time in ms to fetch ratios for
     * @param {int} [limit] the maximum number of long short ratio structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest ratio to fetch
     * @returns {object[]} an array of [long short ratio structures]{@link https://docs.ccxt.com/#/?id=long-short-ratio-structure}
     */
    public async override Task<object> fetchLongShortRatioHistory(object symbol = null, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object until = this.safeString2(parameters, "until", "end");
        parameters = this.omit(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["end"] = until;
        }
        if (isTrue(!isEqual(timeframe, null)))
        {
            ((IDictionary<string,object>)request)["period"] = timeframe;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["begin"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.publicGetRubikStatContractsLongShortAccountRatioContract(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             ["1729323600000", "0.9398602814619824"],
        //             ["1729323300000", "0.9398602814619824"],
        //             ["1729323000000", "0.9398602814619824"],
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "timestamp", this.safeString(entry, 0) },
                { "longShortRatio", this.safeString(entry, 1) },
            });
        }
        return this.parseLongShortRatioHistory(result, market);
    }

    public override object parseLongShortRatio(object info, object market = null)
    {
        object timestamp = this.safeInteger(info, "timestamp");
        object symbol = null;
        if (isTrue(!isEqual(market, null)))
        {
            symbol = getValue(market, "symbol");
        }
        return new Dictionary<string, object>() {
            { "info", info },
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "timeframe", null },
            { "longShortRatio", this.safeNumber(info, "longShortRatio") },
        };
    }
}
