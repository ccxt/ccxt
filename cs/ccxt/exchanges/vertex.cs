namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class vertex : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "vertex" },
            { "name", "Vertex" },
            { "countries", new List<object>() {} },
            { "version", "v1" },
            { "rateLimit", 50 },
            { "certified", false },
            { "pro", true },
            { "dex", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", true },
                { "future", true },
                { "option", false },
                { "addMargin", false },
                { "borrowCrossMargin", false },
                { "borrowIsolatedMargin", false },
                { "cancelAllOrders", true },
                { "cancelAllOrdersAfter", false },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "cancelOrdersForSymbols", false },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createMarketBuyOrderWithCost", false },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", true },
                { "createReduceOnlyOrder", true },
                { "editOrder", false },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrders", false },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", false },
                { "fetchDepositAddresses", false },
                { "fetchDeposits", false },
                { "fetchDepositWithdrawFee", false },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLedger", false },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchLiquidations", false },
                { "fetchMarginMode", null },
                { "fetchMarketLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyLiquidations", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchOrderTrades", false },
                { "fetchPosition", false },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", true },
                { "fetchTicker", false },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", true },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", false },
                { "reduceMargin", false },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", false },
                { "sandbox", true },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", 60 },
                { "5m", 300 },
                { "15m", 900 },
                { "1h", 3600 },
                { "2h", 7200 },
                { "4h", 14400 },
                { "1d", 86400 },
                { "1w", 604800 },
                { "1M", 604800 },
            } },
            { "hostname", "vertexprotocol.com" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/ccxt/ccxt/assets/43336371/bd04a0fa-3b48-47b6-9d8b-124954d520a8" },
                { "api", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "archive", "https://archive.prod.{hostname}/v1" },
                        { "gateway", "https://gateway.prod.{hostname}/v1" },
                        { "trigger", "https://trigger.prod.{hostname}/v1" },
                    } },
                    { "v2", new Dictionary<string, object>() {
                        { "archive", "https://archive.prod.{hostname}/v2" },
                        { "gateway", "https://gateway.prod.{hostname}/v2" },
                    } },
                } },
                { "test", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "archive", "https://archive.sepolia-test.{hostname}/v1" },
                        { "gateway", "https://gateway.sepolia-test.{hostname}/v1" },
                        { "trigger", "https://trigger.sepolia-test.{hostname}/v1" },
                    } },
                    { "v2", new Dictionary<string, object>() {
                        { "archive", "https://archive.sepolia-test.{hostname}/v2" },
                        { "gateway", "https://gateway.sepolia-test.{hostname}/v2" },
                    } },
                } },
                { "www", "https://vertexprotocol.com/" },
                { "doc", "https://docs.vertexprotocol.com/" },
                { "fees", "https://docs.vertexprotocol.com/basics/fees" },
                { "referral", "https://app.vertexprotocol.com?referrer=0xCfC9BaB96a2eA3d3c3F031c005e82E1D9F295aC1" },
            } },
            { "api", new Dictionary<string, object>() {
                { "v1", new Dictionary<string, object>() {
                    { "archive", new Dictionary<string, object>() {
                        { "post", new Dictionary<string, object>() {
                            { "", 1 },
                        } },
                    } },
                    { "gateway", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "query", 1 },
                            { "symbols", 1 },
                            { "time", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "query", 1 },
                            { "execute", 1 },
                        } },
                    } },
                    { "trigger", new Dictionary<string, object>() {
                        { "post", new Dictionary<string, object>() {
                            { "execute", 1 },
                            { "query", 1 },
                        } },
                    } },
                } },
                { "v2", new Dictionary<string, object>() {
                    { "archive", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "tickers", 1 },
                            { "contracts", 1 },
                            { "trades", 1 },
                            { "vrtx", 1 },
                        } },
                    } },
                    { "gateway", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "assets", 0.6667 },
                            { "pairs", 1 },
                            { "orderbook", 1 },
                        } },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "swap", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.0002") },
                    { "maker", this.parseNumber("0.0002") },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.0002") },
                    { "maker", this.parseNumber("0.0002") },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", false },
                { "secret", false },
                { "walletAddress", true },
                { "privateKey", true },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "1000", typeof(RateLimitExceeded) },
                    { "1015", typeof(RateLimitExceeded) },
                    { "1001", typeof(PermissionDenied) },
                    { "1002", typeof(PermissionDenied) },
                    { "1003", typeof(PermissionDenied) },
                    { "2000", typeof(InvalidOrder) },
                    { "2001", typeof(InvalidOrder) },
                    { "2002", typeof(InvalidOrder) },
                    { "2003", typeof(InvalidOrder) },
                    { "2004", typeof(InvalidOrder) },
                    { "2005", typeof(InvalidOrder) },
                    { "2006", typeof(InvalidOrder) },
                    { "2007", typeof(InvalidOrder) },
                    { "2008", typeof(InvalidOrder) },
                    { "2009", typeof(InvalidOrder) },
                    { "2010", typeof(InvalidOrder) },
                    { "2011", typeof(BadRequest) },
                    { "2012", typeof(BadRequest) },
                    { "2013", typeof(InvalidOrder) },
                    { "2014", typeof(PermissionDenied) },
                    { "2015", typeof(InvalidOrder) },
                    { "2016", typeof(InvalidOrder) },
                    { "2017", typeof(InvalidOrder) },
                    { "2019", typeof(InvalidOrder) },
                    { "2020", typeof(InvalidOrder) },
                    { "2021", typeof(InvalidOrder) },
                    { "2022", typeof(InvalidOrder) },
                    { "2023", typeof(InvalidOrder) },
                    { "2024", typeof(InsufficientFunds) },
                    { "2025", typeof(InsufficientFunds) },
                    { "2026", typeof(BadRequest) },
                    { "2027", typeof(AuthenticationError) },
                    { "2028", typeof(AuthenticationError) },
                    { "2029", typeof(AuthenticationError) },
                    { "2030", typeof(BadRequest) },
                    { "2031", typeof(InvalidOrder) },
                    { "2033", typeof(InvalidOrder) },
                    { "2034", typeof(InvalidOrder) },
                    { "2035", typeof(InvalidOrder) },
                    { "2036", typeof(InvalidOrder) },
                    { "2037", typeof(InvalidOrder) },
                    { "2038", typeof(InvalidOrder) },
                    { "2039", typeof(InvalidOrder) },
                    { "2040", typeof(InvalidOrder) },
                    { "2041", typeof(InvalidOrder) },
                    { "2042", typeof(InvalidOrder) },
                    { "2043", typeof(InvalidOrder) },
                    { "2044", typeof(InvalidOrder) },
                    { "2045", typeof(InvalidOrder) },
                    { "2046", typeof(InvalidOrder) },
                    { "2047", typeof(InvalidOrder) },
                    { "2048", typeof(InvalidOrder) },
                    { "2049", typeof(ExchangeError) },
                    { "2050", typeof(PermissionDenied) },
                    { "2051", typeof(InvalidOrder) },
                    { "2052", typeof(InvalidOrder) },
                    { "2053", typeof(InvalidOrder) },
                    { "2054", typeof(InvalidOrder) },
                    { "2055", typeof(InvalidOrder) },
                    { "2056", typeof(InvalidOrder) },
                    { "2057", typeof(InvalidOrder) },
                    { "2058", typeof(InvalidOrder) },
                    { "2059", typeof(InvalidOrder) },
                    { "2060", typeof(InvalidOrder) },
                    { "2061", typeof(InvalidOrder) },
                    { "2062", typeof(InvalidOrder) },
                    { "2063", typeof(InvalidOrder) },
                    { "2064", typeof(InvalidOrder) },
                    { "2065", typeof(InvalidOrder) },
                    { "2066", typeof(InvalidOrder) },
                    { "2067", typeof(InvalidOrder) },
                    { "2068", typeof(InvalidOrder) },
                    { "2069", typeof(InvalidOrder) },
                    { "2070", typeof(InvalidOrder) },
                    { "2071", typeof(InvalidOrder) },
                    { "2072", typeof(InvalidOrder) },
                    { "2073", typeof(InvalidOrder) },
                    { "2074", typeof(InvalidOrder) },
                    { "2075", typeof(InvalidOrder) },
                    { "2076", typeof(InvalidOrder) },
                    { "3000", typeof(BadRequest) },
                    { "3001", typeof(BadRequest) },
                    { "3002", typeof(BadRequest) },
                    { "3003", typeof(BadRequest) },
                    { "4000", typeof(BadRequest) },
                    { "4001", typeof(ExchangeError) },
                    { "4002", typeof(ExchangeError) },
                    { "4003", typeof(ExchangeError) },
                    { "4004", typeof(InvalidOrder) },
                    { "5000", typeof(ExchangeError) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "precisionMode", TICK_SIZE },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "options", new Dictionary<string, object>() {
                { "defaultType", "swap" },
                { "sandboxMode", false },
                { "timeDifference", 0 },
                { "brokerId", 5930043274845996 },
            } },
        });
    }

    public override void setSandboxMode(object enabled)
    {
        base.setSandboxMode(enabled);
        ((IDictionary<string,object>)this.options)["sandboxMode"] = enabled;
    }

    public virtual object convertToX18(object num)
    {
        if (isTrue((num is string)))
        {
            return Precise.stringMul(num, "1000000000000000000");
        }
        object numStr = this.numberToString(num);
        return Precise.stringMul(numStr, "1000000000000000000");
    }

    public virtual object convertFromX18(object num)
    {
        if (isTrue((num is string)))
        {
            return Precise.stringDiv(num, "1000000000000000000");
        }
        object numStr = this.numberToString(num);
        return Precise.stringDiv(numStr, "1000000000000000000");
    }

    /**
     * @method
     * @name vertex#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://docs.vertexprotocol.com/developer-resources/api/v2/assets
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        object response = await this.v2GatewayGetAssets(this.extend(request, parameters));
        //
        // [
        //     {
        //         "product_id": 2,
        //         "ticker_id": "BTC-PERP_USDC",
        //         "market_type": "perp",
        //         "name": "Bitcoin Perp",
        //         "symbol": "BTC-PERP",
        //         "maker_fee": 0.0002,
        //         "taker_fee": 0,
        //         "can_withdraw": false,
        //         "can_deposit": false
        //     },
        //     {
        //         "product_id": 1,
        //         "ticker_id": "BTC_USDC",
        //         "market_type": "spot",
        //         "name": "Bitcoin",
        //         "symbol": "BTC",
        //         "taker_fee": 0.0003,
        //         "maker_fee": 0,
        //         "can_withdraw": true,
        //         "can_deposit": true
        //     }
        // ]
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object data = this.safeDict(response, i, new Dictionary<string, object>() {});
            object tickerId = this.safeString(data, "ticker_id");
            if (isTrue(isTrue((!isEqual(tickerId, null))) && isTrue((isGreaterThan(getIndexOf(tickerId, "PERP"), 0)))))
            {
                continue;
            }
            object id = this.safeString(data, "product_id");
            object name = this.safeString(data, "symbol");
            object code = this.safeCurrencyCode(name);
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "name", name },
                { "code", code },
                { "precision", null },
                { "info", data },
                { "active", null },
                { "deposit", this.safeBool(data, "can_deposit") },
                { "withdraw", this.safeBool(data, "can_withdraw") },
                { "networks", null },
                { "fee", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
            };
        }
        return result;
    }

    public override object parseMarket(object market)
    {
        //
        // {
        //     "type": "spot",
        //     "product_id": 3,
        //     "symbol": "WETH",
        //     "price_increment_x18": "100000000000000000",
        //     "size_increment": "10000000000000000",
        //     "min_size": "100000000000000000",
        //     "min_depth_x18": "5000000000000000000000",
        //     "max_spread_rate_x18": "2000000000000000",
        //     "maker_fee_rate_x18": "0",
        //     "taker_fee_rate_x18": "300000000000000",
        //     "long_weight_initial_x18": "900000000000000000",
        //     "long_weight_maintenance_x18": "950000000000000000"
        // }
        //
        object marketType = this.safeString(market, "type");
        object quoteId = "USDC";
        object quote = this.safeCurrencyCode(quoteId);
        object baseId = this.safeString(market, "symbol");
        object bs = this.safeCurrencyCode(baseId);
        object settleId = quoteId;
        object settle = this.safeCurrencyCode(settleId);
        object symbol = add(add(bs, "/"), quote);
        object spot = isEqual(marketType, "spot");
        object contract = !isTrue(spot);
        object swap = !isTrue(spot);
        if (isTrue(swap))
        {
            object splitSymbol = ((string)bs).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            symbol = add(add(add(add(getValue(splitSymbol, 0), "/"), quote), ":"), settle);
        }
        object priceIncrementX18 = this.safeString(market, "price_increment_x18");
        object sizeIncrementX18 = this.safeString(market, "size_increment");
        object minSizeX18 = this.safeString(market, "min_size");
        object takerX18 = this.safeNumber(market, "taker_fee_rate_x18");
        object makerX18 = this.safeNumber(market, "maker_fee_rate_x18");
        object isInverse = ((bool) isTrue((spot))) ? null : false;
        object isLinear = ((bool) isTrue((spot))) ? null : true;
        object contractSize = ((bool) isTrue((spot))) ? null : this.parseNumber("1");
        return new Dictionary<string, object>() {
            { "id", this.safeString(market, "product_id") },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", ((bool) isTrue((spot))) ? null : settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", ((bool) isTrue((spot))) ? null : settleId },
            { "type", ((bool) isTrue((spot))) ? "spot" : "swap" },
            { "spot", spot },
            { "margin", null },
            { "swap", swap },
            { "future", false },
            { "option", false },
            { "active", true },
            { "contract", contract },
            { "linear", isLinear },
            { "inverse", isInverse },
            { "taker", this.parseNumber(this.convertFromX18(takerX18)) },
            { "maker", this.parseNumber(this.convertFromX18(makerX18)) },
            { "contractSize", contractSize },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.parseNumber(this.convertFromX18(sizeIncrementX18)) },
                { "price", this.parseNumber(this.convertFromX18(priceIncrementX18)) },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.parseNumber(this.convertFromX18(minSizeX18)) },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        };
    }

    /**
     * @method
     * @name vertex#fetchMarkets
     * @description retrieves data on all markets for vertex
     * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", "symbols" },
        };
        object response = await this.v1GatewayGetQuery(this.extend(request, parameters));
        //
        // {
        //     "status": "success",
        //     "data": {
        //         "symbols": {
        //             "WETH": {
        //                 "type": "spot",
        //                 "product_id": 3,
        //                 "symbol": "WETH",
        //                 "price_increment_x18": "100000000000000000",
        //                 "size_increment": "10000000000000000",
        //                 "min_size": "100000000000000000",
        //                 "min_depth_x18": "5000000000000000000000",
        //                 "max_spread_rate_x18": "2000000000000000",
        //                 "maker_fee_rate_x18": "0",
        //                 "taker_fee_rate_x18": "300000000000000",
        //                 "long_weight_initial_x18": "900000000000000000",
        //                 "long_weight_maintenance_x18": "950000000000000000"
        //             }
        //         }
        //     },
        //     "request_type": "query_symbols"
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object markets = this.safeDict(data, "symbols", new Dictionary<string, object>() {});
        object symbols = new List<object>(((IDictionary<string,object>)markets).Keys);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object rawMarket = this.safeDict(markets, symbol, new Dictionary<string, object>() {});
            ((IList<object>)result).Add(this.parseMarket(rawMarket));
        }
        return result;
    }

    /**
     * @method
     * @name vertex#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1GatewayGetTime(parameters);
        // 1717481623452
        return this.parseNumber(response);
    }

    /**
     * @method
     * @name vertex#fetchStatus
     * @description the latest known information on the availability of the exchange API
     * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/status
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
     */
    public async override Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", "status" },
        };
        object response = await this.v1GatewayGetQuery(this.extend(request, parameters));
        //
        // {
        //     "status": "success",
        //     "data": "active",
        //     "request_type": "query_status",
        // }
        //
        object status = this.safeString(response, "data");
        if (isTrue(isEqual(status, "active")))
        {
            status = "ok";
        } else
        {
            status = "error";
        }
        return new Dictionary<string, object>() {
            { "status", status },
            { "updated", null },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // {
        //       "ticker_id": "ARB_USDC",
        //       "trade_id": 999994,
        //       "price": 1.1366122408151016,
        //       "base_filled": 175,
        //       "quote_filled": -198.90714214264278,
        //       "timestamp": 1691068943,
        //       "trade_type": "buy"
        // }
        // fetchMytrades
        // {
        //     "digest": "0x80ce789702b670b7d33f2aa67e12c85f124395c3f9acdb422dde3b4973ccd50c",
        //     "order": {
        //         "sender": "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
        //         "priceX18": "27544000000000000000000",
        //         "amount": "2000000000000000000",
        //         "expiration": "4611686020107119633",
        //         "nonce": "1761322608857448448"
        //     },
        //     "base_filled": "736000000000000000",
        //     "quote_filled": "-20276464287857571514302",
        //     "fee": "4055287857571514302",
        //     "sequencer_fee": "0"
        //     "cumulative_fee": "4055287857571514302",
        //     "cumulative_base_filled": "736000000000000000",
        //     "cumulative_quote_filled": "-20276464287857571514302",
        //     "submission_idx": "563012",
        //     "pre_balance": {
        //       "base": {
        //         "perp": {
        //           "product_id": 2,
        //           "lp_balance": {
        //             "amount": "0",
        //             "last_cumulative_funding_x18": "1823351297710837"
        //           },
        //           "balance": {
        //             "amount": "2686684000000000000000",
        //             "v_quote_balance": "-76348662407149297671587247",
        //             "last_cumulative_funding_x18": "134999841911604906604576"
        //           }
        //         }
        //       },
        //       "quote": null
        //     },
        //     "post_balance": {
        //       "base": {
        //         "perp": {
        //           "product_id": 2,
        //           "lp_balance": {
        //             "amount": "0",
        //             "last_cumulative_funding_x18": "1823351297710837"
        //           },
        //           "balance": {
        //             "amount": "2686013000000000000000",
        //             "v_quote_balance": "-76328351274188497671587247",
        //             "last_cumulative_funding_x18": "134999841911604906604576"
        //           }
        //         }
        //       },
        //       "quote": null
        //     }
        //   }
        object price = null;
        object amount = null;
        object side = null;
        object fee = null;
        object feeCost = this.convertFromX18(this.safeString(trade, "fee"));
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", null },
            };
        }
        object id = this.safeString2(trade, "trade_id", "submission_idx");
        object order = this.safeString(trade, "digest");
        object timestamp = this.safeTimestamp(trade, "timestamp");
        if (isTrue(isEqual(timestamp, null)))
        {
            // fetchMyTrades
            object baseBalance = this.safeDict(this.safeDict(trade, "pre_balance", new Dictionary<string, object>() {}), "base", new Dictionary<string, object>() {});
            object marketId = null;
            if (isTrue(inOp(baseBalance, "perp")))
            {
                marketId = this.safeString(this.safeDict(baseBalance, "perp", new Dictionary<string, object>() {}), "product_id");
            } else
            {
                marketId = this.safeString(this.safeDict(baseBalance, "spot", new Dictionary<string, object>() {}), "product_id");
            }
            market = this.safeMarket(marketId);
            object subOrder = this.safeDict(trade, "order", new Dictionary<string, object>() {});
            price = this.convertFromX18(this.safeString(subOrder, "priceX18"));
            amount = this.convertFromX18(this.safeString(trade, "base_filled"));
            if (isTrue(Precise.stringLt(amount, "0")))
            {
                side = "sell";
            } else
            {
                side = "buy";
            }
        } else
        {
            object tickerId = this.safeString(trade, "ticker_id");
            object splitTickerId = ((string)tickerId).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
            object splitSymbol = ((string)getValue(splitTickerId, 0)).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            object marketId = add(getValue(splitSymbol, 0), getValue(splitTickerId, 1));
            market = this.safeMarket(marketId, market);
            price = this.safeString(trade, "price");
            amount = this.safeString(trade, "base_filled");
            side = this.safeStringLower(trade, "trade_type");
        }
        amount = Precise.stringAbs(amount);
        object symbol = getValue(market, "symbol");
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "order", order },
            { "takerOrMaker", null },
            { "type", null },
            { "fee", fee },
            { "info", trade },
        }, market);
    }

    /**
     * @method
     * @name vertex#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://docs.vertexprotocol.com/developer-resources/api/v2/trades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = add(getValue(market, "baseId"), "_USDC");
        object request = new Dictionary<string, object>() {
            { "ticker_id", marketId },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v2ArchiveGetTrades(this.extend(request, parameters));
        //
        // [
        //     {
        //       "ticker_id": "ARB_USDC",
        //       "trade_id": 999994,
        //       "price": 1.1366122408151016,
        //       "base_filled": 175,
        //       "quote_filled": -198.90714214264278,
        //       "timestamp": 1691068943,
        //       "trade_type": "buy"
        //     },
        //     {
        //       "ticker_id": "ARB_USDC",
        //       "trade_id": 999978,
        //       "price": 1.136512210806099,
        //       "base_filled": 175,
        //       "quote_filled": -198.8896368910673,
        //       "timestamp": 1691068882,
        //       "trade_type": "buy"
        //     }
        // ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    /**
     * @method
     * @name vertex#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://docs.vertexprotocol.com/developer-resources/api/archive-indexer/matches
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchMyTrades", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object market = null;
        object matchesRequest = new Dictionary<string, object>() {
            { "subaccount", this.convertAddressToSender(userAddress) },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)matchesRequest)["product_ids"] = new List<object> {this.parseToNumeric(getValue(market, "id"))};
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, "until");
            ((IDictionary<string,object>)matchesRequest)["max_time"] = until;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)matchesRequest)["limit"] = limit;
        }
        object request = new Dictionary<string, object>() {
            { "matches", matchesRequest },
        };
        object response = await this.v1ArchivePost(this.extend(request, parameters));
        //
        // {
        //     "matches": [
        //       {
        //         "digest": "0x80ce789702b670b7d33f2aa67e12c85f124395c3f9acdb422dde3b4973ccd50c",
        //         "order": {
        //           "sender": "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
        //           "priceX18": "27544000000000000000000",
        //           "amount": "2000000000000000000",
        //           "expiration": "4611686020107119633",
        //           "nonce": "1761322608857448448"
        //         },
        //         "base_filled": "736000000000000000",
        //         "quote_filled": "-20276464287857571514302",
        //         "fee": "4055287857571514302",
        //         "sequencer_fee": "0"
        //         "cumulative_fee": "4055287857571514302",
        //         "cumulative_base_filled": "736000000000000000",
        //         "cumulative_quote_filled": "-20276464287857571514302",
        //         "submission_idx": "563012",
        //         "pre_balance": {
        //           "base": {
        //             "perp": {
        //               "product_id": 2,
        //               "lp_balance": {
        //                 "amount": "0",
        //                 "last_cumulative_funding_x18": "1823351297710837"
        //               },
        //               "balance": {
        //                 "amount": "2686684000000000000000",
        //                 "v_quote_balance": "-76348662407149297671587247",
        //                 "last_cumulative_funding_x18": "134999841911604906604576"
        //               }
        //             }
        //           },
        //           "quote": null
        //         },
        //         "post_balance": {
        //           "base": {
        //             "perp": {
        //               "product_id": 2,
        //               "lp_balance": {
        //                 "amount": "0",
        //                 "last_cumulative_funding_x18": "1823351297710837"
        //               },
        //               "balance": {
        //                 "amount": "2686013000000000000000",
        //                 "v_quote_balance": "-76328351274188497671587247",
        //                 "last_cumulative_funding_x18": "134999841911604906604576"
        //               }
        //             }
        //           },
        //           "quote": null
        //         }
        //       },
        //       {
        //         "digest": "0x0f6e5a0434e36d8e6d4fed950d3624b0d8c91a8a84efd156bb25c1382561c0c2",
        //         "order": {
        //           "sender": "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
        //           "priceX18": "27540000000000000000000",
        //           "amount": "2000000000000000000",
        //           "expiration": "4611686020107119623",
        //           "nonce": "1761322602510417920"
        //         },
        //         "base_filled": "723999999999999999",
        //         "quote_filled": "-19944943483044913474043",
        //         "fee": "5983483044913474042",
        //         "cumulative_fee": "11958484645393618085",
        //         "cumulative_base_filled": "1446999999999999998",
        //         "cumulative_quote_filled": "-39861640484645393618087",
        //         "submission_idx": "563011",
        //         "pre_balance": {
        //           "base": {
        //             "perp": {
        //               "product_id": 2,
        //               "lp_balance": {
        //                 "amount": "0",
        //                 "last_cumulative_funding_x18": "1823351297710837"
        //               },
        //               "balance": {
        //                 "amount": "2686684000000000000000",
        //                 "v_quote_balance": "-76348662407149297671587247",
        //                 "last_cumulative_funding_x18": "134999841911604906604576"
        //               }
        //             }
        //           },
        //           "quote": null
        //         },
        //         "post_balance": {
        //           "base": {
        //             "perp": {
        //               "product_id": 2,
        //               "lp_balance": {
        //                 "amount": "0",
        //                 "last_cumulative_funding_x18": "1823351297710837"
        //               },
        //               "balance": {
        //                 "amount": "2686013000000000000000",
        //                 "v_quote_balance": "-76328351274188497671587247",
        //                 "last_cumulative_funding_x18": "134999841911604906604576"
        //               }
        //             }
        //           },
        //           "quote": null
        //         }
        //       }
        //     ],
        //     "txs": [
        //       {
        //         "tx": {
        //           "match_orders": {
        //             "product_id": 2,
        //             "amm": true,
        //             "taker": {
        //               "order": {
        //                 "sender": "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
        //                 "price_x18": "27544000000000000000000",
        //                 "amount": "2000000000000000000",
        //                 "expiration": 4611686020107120000,
        //                 "nonce": 1761322608857448400
        //               },
        //               "signature": "0xe8fa7151bde348afa3b46dc52798046b7c8318f1b0a7f689710debbc094658cc1bf5a7e478ccc8278b625da0b9402c86b580d2e31e13831337dfd6153f4b37811b"
        //             },
        //             "maker": {
        //               "order": {
        //                 "sender": "0xebdbbcdbd2646c5f23a1e0806027eee5f71b074664656661756c740000000000",
        //                 "price_x18": "27544000000000000000000",
        //                 "amount": "-736000000000000000",
        //                 "expiration": 1679731669,
        //                 "nonce": 1761322585591644200
        //               },
        //               "signature": "0x47f9d47f0777f3ca0b13f07b7682dbeea098c0e377b87dcb025754fe34c900e336b8c7744e021fb9c46a4f8c6a1478bafa28bf0d023ae496aa3efa4d8e81df181c"
        //             }
        //           }
        //         },
        //         "submission_idx": "563012",
        //         "timestamp": "1679728133"
        //       },
        //       {
        //         "tx": {
        //           "match_orders": {
        //             "product_id": 1,
        //             "amm": true,
        //             "taker": {
        //               "order": {
        //                 "sender": "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
        //                 "price_x18": "27540000000000000000000",
        //                 "amount": "2000000000000000000",
        //                 "expiration": 4611686020107120000,
        //                 "nonce": 1761322602510418000
        //               },
        //               "signature": "0x826c68f1a3f76d9ffbe8041f8d45e969d31f1ab6f2ae2f6379d1493e479e56436091d6cf4c72e212dd2f1d2fa17c627c4c21bd6d281c77172b8af030488478b71c"
        //             },
        //             "maker": {
        //               "order": {
        //                 "sender": "0xf8d240d9514c9a4715d66268d7af3b53d619642564656661756c740000000000",
        //                 "price_x18": "27540000000000000000000",
        //                 "amount": "-724000000000000000",
        //                 "expiration": 1679731656,
        //                 "nonce": 1761322565506171000
        //               },
        //               "signature": "0xd8b6505b8d9b8c3cbfe793080976388035682c02a27893fb26b48a5b2bfe943f4162dea3a42e24e0dff5e2f74fbf77e33d83619140a2a581117c55e6cc236bdb1c"
        //             }
        //           }
        //         },
        //         "submission_idx": "563011",
        //         "timestamp": "1679728127"
        //       }
        //     ]
        // }
        //
        object trades = this.safeList(response, "matches", new List<object>() {});
        return this.parseTrades(trades, market, since, limit, parameters);
    }

    /**
     * @method
     * @name vertex#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://docs.vertexprotocol.com/developer-resources/api/v2/orderbook
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = add(getValue(market, "baseId"), "_USDC");
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100;
        }
        object request = new Dictionary<string, object>() {
            { "ticker_id", marketId },
            { "depth", limit },
        };
        object response = await this.v2GatewayGetOrderbook(this.extend(request, parameters));
        //
        // {
        //     "ticker_id": "ETH-PERP_USDC",
        //     "bids": [
        //         [
        //             1612.3,
        //             0.31
        //         ],
        //         [
        //             1612.0,
        //             0.93
        //         ],
        //         [
        //             1611.5,
        //             1.55
        //         ],
        //         [
        //             1610.8,
        //             2.17
        //         ]
        //     ],
        //     "asks": [
        //         [
        //             1612.9,
        //             0.93
        //         ],
        //         [
        //             1613.4,
        //             1.55
        //         ],
        //         [
        //             1614.1,
        //             2.17
        //         ]
        //     ],
        //     "timestamp": 1694375362016
        // }
        //
        object timestamp = this.safeInteger(response, "timestamp");
        return this.parseOrderBook(response, symbol, timestamp, "bids", "asks");
    }

    /**
     * @method
     * @name vertex#fetchTradingFees
     * @description fetch the trading fees for multiple markets
     * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/fee-rates
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
     */
    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchTradingFees", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "type", "fee_rates" },
            { "sender", this.convertAddressToSender(userAddress) },
        };
        object response = await this.v1GatewayGetQuery(this.extend(request, parameters));
        //
        // {
        //     "status": "success",
        //     "data": {
        //       "taker_fee_rates_x18": [
        //         "0",
        //         "300000000000000",
        //         "200000000000000",
        //         "300000000000000",
        //         "200000000000000"
        //       ],
        //       "maker_fee_rates_x18": [
        //         "0",
        //         "0",
        //         "0",
        //         "0",
        //         "0"
        //       ],
        //       "liquidation_sequencer_fee": "250000000000000000",
        //       "health_check_sequencer_fee": "100000000000000000",
        //       "taker_sequencer_fee": "25000000000000000",
        //       "withdraw_sequencer_fees": [
        //         "10000000000000000",
        //         "40000000000000",
        //         "0",
        //         "600000000000000",
        //         "0"
        //       ]
        //     },
        //     "request_type": "query_fee_rates",
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object maker = this.safeList(data, "maker_fee_rates_x18", new List<object>() {});
        object taker = this.safeList(data, "taker_fee_rates_x18", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(taker)); postFixIncrement(ref i))
        {
            object market = this.safeMarket(this.numberToString(i));
            if (isTrue(isEqual(getValue(market, "id"), null)))
            {
                continue;
            }
            object symbol = getValue(market, "symbol");
            ((IDictionary<string,object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "info", response },
                { "symbol", symbol },
                { "maker", this.parseNumber(this.convertFromX18(getValue(maker, i))) },
                { "taker", this.parseNumber(this.convertFromX18(getValue(taker, i))) },
                { "percentage", true },
                { "tierBased", false },
            };
        }
        return result;
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        // example response in fetchOHLCV
        return new List<object> {this.safeTimestamp(ohlcv, "timestamp"), this.parseNumber(this.convertFromX18(this.safeString(ohlcv, "open_x18"))), this.parseNumber(this.convertFromX18(this.safeString(ohlcv, "high_x18"))), this.parseNumber(this.convertFromX18(this.safeString(ohlcv, "low_x18"))), this.parseNumber(this.convertFromX18(this.safeString(ohlcv, "close_x18"))), this.parseNumber(this.convertFromX18(this.safeString(ohlcv, "volume")))};
    }

    /**
     * @method
     * @name vertex#fetchOHLCV
     * @see https://docs.vertexprotocol.com/developer-resources/api/archive-indexer/candlesticks
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] max=1000, max=100 when since is defined and is less than (now - (999 * (timeframe in ms)))
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object ohlcvRequest = new Dictionary<string, object>() {
            { "product_id", this.parseToInt(getValue(market, "id")) },
            { "granularity", this.safeInteger(this.timeframes, timeframe) },
        };
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, "until");
            ((IDictionary<string,object>)ohlcvRequest)["max_time"] = until;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)ohlcvRequest)["limit"] = mathMin(limit, 1000);
        }
        object request = new Dictionary<string, object>() {
            { "candlesticks", ohlcvRequest },
        };
        object response = await this.v1ArchivePost(this.extend(request, parameters));
        //
        // {
        //     "candlesticks": [
        //       {
        //         "product_id": 1,
        //         "granularity": 60,
        //         "submission_idx": "627709",
        //         "timestamp": "1680118140",
        //         "open_x18": "27235000000000000000000",
        //         "high_x18": "27298000000000000000000",
        //         "low_x18": "27235000000000000000000",
        //         "close_x18": "27298000000000000000000",
        //         "volume": "1999999999999999998"
        //       },
        //       {
        //         "product_id": 1,
        //         "granularity": 60,
        //         "submission_idx": "627699",
        //         "timestamp": "1680118080",
        //         "open_x18": "27218000000000000000000",
        //         "high_x18": "27245000000000000000000",
        //         "low_x18": "27218000000000000000000",
        //         "close_x18": "27245000000000000000000",
        //         "volume": "11852999999999999995"
        //       }
        //     ]
        // }
        //
        object rows = this.safeList(response, "candlesticks", new List<object>() {});
        return this.parseOHLCVs(rows, market, timeframe, since, limit);
    }

    public override object parseFundingRate(object ticker, object market = null)
    {
        //
        // {
        //     "product_id": 4,
        //     "funding_rate_x18": "2447900598160952",
        //     "update_time": "1680116326"
        // }
        //
        // {
        //     "ETH-PERP_USDC": {
        //         "ticker_id": "ETH-PERP_USDC",
        //         "base_currency": "ETH-PERP",
        //         "quote_currency": "USDC",
        //         "last_price": 1620.3,
        //         "base_volume": 1309.2,
        //         "quote_volume": 2117828.093867611,
        //         "product_type": "perpetual",
        //         "contract_price": 1620.372642114429,
        //         "contract_price_currency": "USD",
        //         "open_interest": 1635.2,
        //         "open_interest_usd": 2649633.3443855145,
        //         "index_price": 1623.293496279935,
        //         "mark_price": 1623.398589416731,
        //         "funding_rate": 0.000068613217104332,
        //         "next_funding_rate_timestamp": 1694379600,
        //         "price_change_percent_24h": -0.6348599635253989
        //     }
        // }
        //
        object fundingRate = this.safeNumber(ticker, "funding_rate");
        if (isTrue(isEqual(fundingRate, null)))
        {
            object fundingRateX18 = this.safeString(ticker, "funding_rate_x18");
            fundingRate = this.parseNumber(this.convertFromX18(fundingRateX18));
        }
        object fundingTimestamp = this.safeTimestamp2(ticker, "update_time", "next_funding_rate_timestamp");
        object markPrice = this.safeNumber(ticker, "mark_price");
        object indexPrice = this.safeNumber(ticker, "index_price");
        return new Dictionary<string, object>() {
            { "info", ticker },
            { "symbol", getValue(market, "symbol") },
            { "markPrice", markPrice },
            { "indexPrice", indexPrice },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", fundingRate },
            { "fundingTimestamp", fundingTimestamp },
            { "fundingDatetime", this.iso8601(fundingTimestamp) },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", null },
        };
    }

    /**
     * @method
     * @name vertex#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://docs.vertexprotocol.com/developer-resources/api/archive-indexer/funding-rate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "funding_rate", new Dictionary<string, object>() {
                { "product_id", this.parseToInt(getValue(market, "id")) },
            } },
        };
        object response = await this.v1ArchivePost(this.extend(request, parameters));
        //
        // {
        //     "product_id": 4,
        //     "funding_rate_x18": "2447900598160952",
        //     "update_time": "1680116326"
        // }
        //
        return this.parseFundingRate(response, market);
    }

    /**
     * @method
     * @name vertex#fetchFundingRates
     * @description fetches funding rates for multiple markets
     * @see https://docs.vertexprotocol.com/developer-resources/api/v2/contracts
     * @param {string[]} symbols unified symbols of the markets to fetch the funding rates for, all market funding rates are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            symbols = this.marketSymbols(symbols);
        }
        object response = await this.v2ArchiveGetContracts(this.extend(request, parameters));
        //
        // {
        //     "ETH-PERP_USDC": {
        //         "ticker_id": "ETH-PERP_USDC",
        //         "base_currency": "ETH-PERP",
        //         "quote_currency": "USDC",
        //         "last_price": 1620.3,
        //         "base_volume": 1309.2,
        //         "quote_volume": 2117828.093867611,
        //         "product_type": "perpetual",
        //         "contract_price": 1620.372642114429,
        //         "contract_price_currency": "USD",
        //         "open_interest": 1635.2,
        //         "open_interest_usd": 2649633.3443855145,
        //         "index_price": 1623.293496279935,
        //         "mark_price": 1623.398589416731,
        //         "funding_rate": 0.000068613217104332,
        //         "next_funding_rate_timestamp": 1694379600,
        //         "price_change_percent_24h": -0.6348599635253989
        //     }
        // }
        //
        object keys = new List<object>(((IDictionary<string,object>)response).Keys);
        object fundingRates = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object tickerId = getValue(keys, i);
            object parsedTickerId = ((string)tickerId).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            object data = getValue(response, tickerId);
            object marketId = add(getValue(parsedTickerId, 0), "/USDC:USDC");
            object market = this.market(marketId);
            object ticker = this.parseFundingRate(data, market);
            object symbol = getValue(ticker, "symbol");
            ((IDictionary<string,object>)fundingRates)[(string)symbol] = ticker;
        }
        return this.filterByArray(fundingRates, "symbol", symbols);
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        // {
        //     "ETH-PERP_USDC": {
        //         "ticker_id": "ETH-PERP_USDC",
        //         "base_currency": "ETH-PERP",
        //         "quote_currency": "USDC",
        //         "last_price": 1620.3,
        //         "base_volume": 1309.2,
        //         "quote_volume": 2117828.093867611,
        //         "product_type": "perpetual",
        //         "contract_price": 1620.372642114429,
        //         "contract_price_currency": "USD",
        //         "open_interest": 1635.2,
        //         "open_interest_usd": 2649633.3443855145,
        //         "index_price": 1623.293496279935,
        //         "mark_price": 1623.398589416731,
        //         "funding_rate": 0.000068613217104332,
        //         "next_funding_rate_timestamp": 1694379600,
        //         "price_change_percent_24h": -0.6348599635253989
        //     }
        // }
        //
        object value = this.safeNumber(interest, "open_interest_usd");
        return this.safeOpenInterest(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "openInterestAmount", null },
            { "openInterestValue", value },
            { "timestamp", null },
            { "datetime", null },
            { "info", interest },
        }, market);
    }

    /**
     * @method
     * @name vertex#fetchOpenInterest
     * @description Retrieves the open interest of a derivative trading pair
     * @see https://docs.vertexprotocol.com/developer-resources/api/v2/contracts
     * @param {string} symbol Unified CCXT market symbol
     * @param {object} [params] exchange specific parameters
     * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
     */
    public async override Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "contract")))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterest() supports contract markets only")) ;
        }
        object request = new Dictionary<string, object>() {};
        object response = await this.v2ArchiveGetContracts(this.extend(request, parameters));
        //
        // {
        //     "ETH-PERP_USDC": {
        //         "ticker_id": "ETH-PERP_USDC",
        //         "base_currency": "ETH-PERP",
        //         "quote_currency": "USDC",
        //         "last_price": 1620.3,
        //         "base_volume": 1309.2,
        //         "quote_volume": 2117828.093867611,
        //         "product_type": "perpetual",
        //         "contract_price": 1620.372642114429,
        //         "contract_price_currency": "USD",
        //         "open_interest": 1635.2,
        //         "open_interest_usd": 2649633.3443855145,
        //         "index_price": 1623.293496279935,
        //         "mark_price": 1623.398589416731,
        //         "funding_rate": 0.000068613217104332,
        //         "next_funding_rate_timestamp": 1694379600,
        //         "price_change_percent_24h": -0.6348599635253989
        //     }
        // }
        //
        object tickerId = add(getValue(market, "base"), "_USDC");
        object openInterest = this.safeDict(response, tickerId, new Dictionary<string, object>() {});
        return this.parseOpenInterest(openInterest, market);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "ticker_id": "BTC_USDC",
        //         "base_currency": "BTC",
        //         "quote_currency": "USDC",
        //         "last_price": 25728.0,
        //         "base_volume": 552.048,
        //         "quote_volume": 14238632.207250029,
        //         "price_change_percent_24h": -0.6348599635253989
        //     }
        //
        object bs = this.safeString(ticker, "base_currency");
        object quote = this.safeString(ticker, "quote_currency");
        object marketId = add(add(bs, "/"), quote);
        if (isTrue(isGreaterThan(getIndexOf(bs, "PERP"), 0)))
        {
            marketId = add(((string)marketId).Replace((string)"-PERP", (string)""), ":USDC");
        }
        market = this.market(marketId);
        object last = this.safeString(ticker, "last_price");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", null },
            { "datetime", null },
            { "high", null },
            { "low", null },
            { "bid", null },
            { "bidVolume", null },
            { "ask", null },
            { "askVolume", null },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", this.safeString(ticker, "price_change_percent_24h") },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "base_volume") },
            { "quoteVolume", this.safeString(ticker, "quote_volume") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name vertex#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://docs.vertexprotocol.com/developer-resources/api/v2/tickers
     * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, true, true, true);
        object request = new Dictionary<string, object>() {};
        object response = await this.v2ArchiveGetTickers(this.extend(request, parameters));
        //
        // {
        //     "ETH_USDC": {
        //         "ticker_id": "ETH_USDC",
        //         "base_currency": "ETH",
        //         "quote_currency": "USDC",
        //         "last_price": 1619.1,
        //         "base_volume": 1428.32,
        //         "quote_volume": 2310648.316391866,
        //         "price_change_percent_24h": -1.0509394462969588
        //     },
        //     "BTC_USDC": {
        //         "ticker_id": "BTC_USDC",
        //         "base_currency": "BTC",
        //         "quote_currency": "USDC",
        //         "last_price": 25728.0,
        //         "base_volume": 552.048,
        //         "quote_volume": 14238632.207250029,
        //         "price_change_percent_24h": -0.6348599635253989
        //     }
        // }
        //
        object tickers = new List<object>(((IDictionary<string,object>)response).Values);
        return this.parseTickers(tickers, symbols);
    }

    public async virtual Task<object> queryContracts(object parameters = null)
    {
        // query contract addresses for sending order
        parameters ??= new Dictionary<string, object>();
        object cachedContracts = this.safeDict(this.options, "v1contracts");
        if (isTrue(!isEqual(cachedContracts, null)))
        {
            return cachedContracts;
        }
        object request = new Dictionary<string, object>() {
            { "type", "contracts" },
        };
        object response = await this.v1GatewayGetQuery(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        ((IDictionary<string,object>)this.options)["v1contracts"] = data;
        return data;
    }

    public override object nonce()
    {
        return subtract(this.milliseconds(), getValue(this.options, "timeDifference"));
    }

    public virtual object hashMessage(object message)
    {
        return add("0x", this.hash(message, keccak, "hex"));
    }

    public virtual object signHash(object hash, object privateKey)
    {
        object signature = ecdsa(slice(hash, -64, null), slice(privateKey, -64, null), secp256k1, null);
        object r = getValue(signature, "r");
        object s = getValue(signature, "s");
        object v = this.intToBase16(this.sum(27, getValue(signature, "v")));
        return add(add(add("0x", (r as String).PadLeft(Convert.ToInt32(64), Convert.ToChar("0"))), (s as String).PadLeft(Convert.ToInt32(64), Convert.ToChar("0"))), v);
    }

    public virtual object signMessage(object message, object privateKey)
    {
        return this.signHash(this.hashMessage(message), slice(privateKey, -64, null));
    }

    public virtual object buildSig(object chainId, object messageTypes, object message, object verifyingContractAddress = null)
    {
        verifyingContractAddress ??= "";
        object domain = new Dictionary<string, object>() {
            { "chainId", chainId },
            { "name", "Vertex" },
            { "verifyingContract", verifyingContractAddress },
            { "version", "0.0.1" },
        };
        object msg = this.ethEncodeStructuredData(domain, messageTypes, message);
        object signature = this.signMessage(msg, this.privateKey);
        return signature;
    }

    public virtual object buildCreateOrderSig(object message, object chainId, object verifyingContractAddress)
    {
        object messageTypes = new Dictionary<string, object>() {
            { "Order", new List<object>() {new Dictionary<string, object>() {
    { "name", "sender" },
    { "type", "bytes32" },
}, new Dictionary<string, object>() {
    { "name", "priceX18" },
    { "type", "int128" },
}, new Dictionary<string, object>() {
    { "name", "amount" },
    { "type", "int128" },
}, new Dictionary<string, object>() {
    { "name", "expiration" },
    { "type", "uint64" },
}, new Dictionary<string, object>() {
    { "name", "nonce" },
    { "type", "uint64" },
}} },
        };
        return this.buildSig(chainId, messageTypes, message, verifyingContractAddress);
    }

    public virtual object buildListTriggerTxSig(object message, object chainId, object verifyingContractAddress)
    {
        object messageTypes = new Dictionary<string, object>() {
            { "ListTriggerOrders", new List<object>() {new Dictionary<string, object>() {
    { "name", "sender" },
    { "type", "bytes32" },
}, new Dictionary<string, object>() {
    { "name", "recvTime" },
    { "type", "uint64" },
}} },
        };
        return this.buildSig(chainId, messageTypes, message, verifyingContractAddress);
    }

    public virtual object buildCancelAllOrdersSig(object message, object chainId, object verifyingContractAddress)
    {
        object messageTypes = new Dictionary<string, object>() {
            { "CancellationProducts", new List<object>() {new Dictionary<string, object>() {
    { "name", "sender" },
    { "type", "bytes32" },
}, new Dictionary<string, object>() {
    { "name", "productIds" },
    { "type", "uint32[]" },
}, new Dictionary<string, object>() {
    { "name", "nonce" },
    { "type", "uint64" },
}} },
        };
        return this.buildSig(chainId, messageTypes, message, verifyingContractAddress);
    }

    public virtual object buildCancelOrdersSig(object message, object chainId, object verifyingContractAddress)
    {
        object messageTypes = new Dictionary<string, object>() {
            { "Cancellation", new List<object>() {new Dictionary<string, object>() {
    { "name", "sender" },
    { "type", "bytes32" },
}, new Dictionary<string, object>() {
    { "name", "productIds" },
    { "type", "uint32[]" },
}, new Dictionary<string, object>() {
    { "name", "digests" },
    { "type", "bytes32[]" },
}, new Dictionary<string, object>() {
    { "name", "nonce" },
    { "type", "uint64" },
}} },
        };
        return this.buildSig(chainId, messageTypes, message, verifyingContractAddress);
    }

    public virtual object buildWithdrawSig(object message, object chainId, object verifyingContractAddress)
    {
        object messageTypes = new Dictionary<string, object>() {
            { "WithdrawCollateral", new List<object>() {new Dictionary<string, object>() {
    { "name", "sender" },
    { "type", "bytes32" },
}, new Dictionary<string, object>() {
    { "name", "productId" },
    { "type", "uint32" },
}, new Dictionary<string, object>() {
    { "name", "amount" },
    { "type", "uint128" },
}, new Dictionary<string, object>() {
    { "name", "nonce" },
    { "type", "uint64" },
}} },
        };
        return this.buildSig(chainId, messageTypes, message, verifyingContractAddress);
    }

    public virtual object convertAddressToSender(object address)
    {
        object sender = add(address, "64656661756c74");
        return (sender as String).PadRight(Convert.ToInt32(66), Convert.ToChar("0"));
    }

    public virtual object getNonce(object now, object expiration)
    {
        if (isTrue(isEqual(now, null)))
        {
            now = this.nonce();
        }
        // nonce = ((now + expiration) << 20) + 1000
        // 1 << 20 = 1048576
        return Precise.stringAdd(Precise.stringMul(Precise.stringAdd(this.numberToString(now), this.numberToString(expiration)), "1048576"), "1000");
    }

    public virtual object getExpiration(object now, object timeInForce, object postOnly, object reduceOnly)
    {
        object expiration = Precise.stringAdd(this.numberToString(now), "86400");
        if (isTrue(isEqual(timeInForce, "ioc")))
        {
            // 1 << 62 = 4611686018427387904
            expiration = Precise.stringOr(expiration, "4611686018427387904");
        } else if (isTrue(isEqual(timeInForce, "fok")))
        {
            // 2 << 62 = 9223372036854775808
            expiration = Precise.stringOr(expiration, "9223372036854775808");
        } else if (isTrue(postOnly))
        {
            // 3 << 62 = 13835058055282163712
            expiration = Precise.stringOr(expiration, "13835058055282163712");
        }
        if (isTrue(reduceOnly))
        {
            // 1 << 61 = 2305843009213693952
            expiration = Precise.stringOr(expiration, "2305843009213693952");
        }
        return expiration;
    }

    public virtual object getAmount(object amount, object side)
    {
        object amountString = this.numberToString(amount);
        if (isTrue(isEqual(side, "sell")))
        {
            if (isTrue(isGreaterThan(amount, 0)))
            {
                // amount *= -1;
                amountString = Precise.stringMul(amountString, "-1");
            }
        } else
        {
            if (isTrue(isLessThan(amount, 0)))
            {
                // amount *= -1;
                amountString = Precise.stringMul(amountString, "-1");
            }
        }
        return amountString;
    }

    /**
     * @method
     * @name vertex#createOrder
     * @description create a trade order
     * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/place-order
     * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/executes/place-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.timeInForce] ioc, fok
     * @param {bool} [params.postOnly] true or false whether the order is post-only
     * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only, only works for ioc and fok order
     * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object marketType = ((string)type).ToLower();
        object isMarketOrder = isEqual(marketType, "market");
        if (isTrue(isTrue(isMarketOrder) && isTrue(isEqual(price, null))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createOrder() requires a price argument for market order")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = this.parseToInt(getValue(market, "id"));
        object contracts = await this.queryContracts();
        object chainId = this.safeString(contracts, "chain_id");
        object bookAddresses = this.safeList(contracts, "book_addrs", new List<object>() {});
        object verifyingContractAddress = this.safeString(bookAddresses, marketId);
        object defaultTimeInForce = ((bool) isTrue((isMarketOrder))) ? "fok" : null;
        object timeInForce = this.safeStringLower(parameters, "timeInForce", defaultTimeInForce);
        object postOnly = this.safeBool(parameters, "postOnly", false);
        object reduceOnly = this.safeBool(parameters, "reduceOnly", false);
        object triggerPrice = this.safeString2(parameters, "triggerPrice", "stopPrice");
        object stopLossPrice = this.safeString(parameters, "stopLossPrice", triggerPrice);
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        object isTrigger = (isTrue(stopLossPrice) || isTrue(takeProfitPrice));
        object now = this.nonce();
        object nonce = this.getNonce(now, 90000);
        if (isTrue(isTrue(postOnly) && isTrue(reduceOnly)))
        {
            throw new NotSupported ((string)add(this.id, " reduceOnly not supported when postOnly is enabled")) ;
        }
        object expiration = this.getExpiration(now, timeInForce, postOnly, reduceOnly);
        if (isTrue(isTrigger))
        {
            // 1 << 63 = 9223372036854775808
            nonce = Precise.stringOr(nonce, "9223372036854775808");
        }
        object amountString = this.getAmount(amount, side);
        object order = new Dictionary<string, object>() {
            { "sender", this.convertAddressToSender(this.walletAddress) },
            { "priceX18", this.convertToX18(this.priceToPrecision(symbol, price)) },
            { "amount", this.convertToX18(this.amountToPrecision(symbol, amountString)) },
            { "expiration", expiration },
            { "nonce", nonce },
        };
        object request = new Dictionary<string, object>() {
            { "place_order", new Dictionary<string, object>() {
                { "product_id", marketId },
                { "order", new Dictionary<string, object>() {
                    { "sender", getValue(order, "sender") },
                    { "priceX18", getValue(order, "priceX18") },
                    { "amount", getValue(order, "amount") },
                    { "expiration", this.numberToString(getValue(order, "expiration")) },
                    { "nonce", getValue(order, "nonce") },
                } },
                { "signature", this.buildCreateOrderSig(order, chainId, verifyingContractAddress) },
                { "id", this.safeInteger(this.options, "brokerId", 5930043274845996) },
            } },
        };
        parameters = this.omit(parameters, new List<object>() {"timeInForce", "reduceOnly", "postOnly", "triggerPrice", "stopPrice", "stopLossPrice", "takeProfitPrice"});
        object response = null;
        if (isTrue(isTrigger))
        {
            object trigger = new Dictionary<string, object>() {};
            if (isTrue(!isEqual(stopLossPrice, null)))
            {
                ((IDictionary<string,object>)trigger)["last_price_below"] = this.convertToX18(stopLossPrice);
            } else if (isTrue(!isEqual(takeProfitPrice, null)))
            {
                ((IDictionary<string,object>)trigger)["last_price_above"] = this.convertToX18(takeProfitPrice);
            }
            ((IDictionary<string,object>)getValue(request, "place_order"))["trigger"] = trigger;
            response = await this.v1TriggerPostExecute(this.extend(request, parameters));
        } else
        {
            response = await this.v1GatewayPostExecute(this.extend(request, parameters));
        }
        //
        // {
        //     "status": "success",
        //     "signature": {signature},
        //     "data": {
        //       "digest": {order digest}
        //     },
        //     "request_type": "execute_place_order"
        //     "id": 100
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(data, "digest") },
        });
    }

    /**
     * @method
     * @name vertex#editOrder
     * @description edit a trade order
     * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/cancel-and-place
     * @param {string} id cancel order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.timeInForce] ioc, fok
     * @param {bool} [params.postOnly] true or false whether the order is post-only
     * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only, only works for ioc and fok order
     * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object marketType = ((string)type).ToLower();
        object isMarketOrder = isEqual(marketType, "market");
        if (isTrue(isTrue(isMarketOrder) && isTrue(isEqual(price, null))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " editOrder() requires a price argument for market order")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = this.parseToInt(getValue(market, "id"));
        object defaultTimeInForce = ((bool) isTrue((isMarketOrder))) ? "fok" : null;
        object timeInForce = this.safeStringLower(parameters, "timeInForce", defaultTimeInForce);
        object postOnly = this.safeBool(parameters, "postOnly", false);
        object reduceOnly = this.safeBool(parameters, "reduceOnly", false);
        object triggerPrice = this.safeString2(parameters, "triggerPrice", "stopPrice");
        object stopLossPrice = this.safeString(parameters, "stopLossPrice", triggerPrice);
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        object isTrigger = (isTrue(stopLossPrice) || isTrue(takeProfitPrice));
        object contracts = await this.queryContracts();
        object chainId = this.safeString(contracts, "chain_id");
        object bookAddresses = this.safeList(contracts, "book_addrs", new List<object>() {});
        object verifyingContractAddressOrder = this.safeString(bookAddresses, marketId);
        object verifyingContractAddressCancel = this.safeString(contracts, "endpoint_addr");
        object now = this.nonce();
        object nonce = this.getNonce(now, 90000);
        object sender = this.convertAddressToSender(this.walletAddress);
        if (isTrue(isTrue(postOnly) && isTrue(reduceOnly)))
        {
            throw new NotSupported ((string)add(this.id, " reduceOnly not supported when postOnly is enabled")) ;
        }
        if (isTrue(isTrigger))
        {
            throw new NotSupported ((string)add(this.id, " editOrder() not supported for trigger order")) ;
        }
        object expiration = this.getExpiration(now, timeInForce, postOnly, reduceOnly);
        object amountString = this.getAmount(amount, side);
        object order = new Dictionary<string, object>() {
            { "sender", sender },
            { "priceX18", this.convertToX18(this.priceToPrecision(symbol, price)) },
            { "amount", this.convertToX18(this.amountToPrecision(symbol, amountString)) },
            { "expiration", expiration },
            { "nonce", nonce },
        };
        object cancels = new Dictionary<string, object>() {
            { "sender", sender },
            { "productIds", new List<object>() {marketId} },
            { "digests", new List<object>() {id} },
            { "nonce", nonce },
        };
        object request = new Dictionary<string, object>() {
            { "cancel_and_place", new Dictionary<string, object>() {
                { "cancel_tx", new Dictionary<string, object>() {
                    { "sender", getValue(cancels, "sender") },
                    { "productIds", getValue(cancels, "productIds") },
                    { "digests", getValue(cancels, "digests") },
                    { "nonce", this.numberToString(getValue(cancels, "nonce")) },
                } },
                { "cancel_signature", this.buildCancelOrdersSig(cancels, chainId, verifyingContractAddressCancel) },
                { "place_order", new Dictionary<string, object>() {
                    { "product_id", marketId },
                    { "order", new Dictionary<string, object>() {
                        { "sender", getValue(order, "sender") },
                        { "priceX18", getValue(order, "priceX18") },
                        { "amount", getValue(order, "amount") },
                        { "expiration", this.numberToString(getValue(order, "expiration")) },
                        { "nonce", getValue(order, "nonce") },
                    } },
                    { "signature", this.buildCreateOrderSig(order, chainId, verifyingContractAddressOrder) },
                    { "id", this.safeInteger(this.options, "brokerId", 5930043274845996) },
                } },
            } },
        };
        parameters = this.omit(parameters, new List<object>() {"timeInForce", "reduceOnly", "postOnly", "triggerPrice", "stopPrice", "stopLossPrice", "takeProfitPrice"});
        object response = await this.v1GatewayPostExecute(this.extend(request, parameters));
        //
        // {
        //     "status": "success",
        //     "signature": {signature},
        //     "data": {
        //       "digest": {order digest}
        //     },
        //     "request_type": "execute_cancel_and_place"
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(data, "digest") },
        });
    }

    public virtual object parseOrderStatus(object status)
    {
        if (isTrue(!isEqual(status, null)))
        {
            object statuses = new Dictionary<string, object>() {
                { "pending", "open" },
            };
            if (isTrue((status is string)))
            {
                return this.safeString(statuses, status, status);
            }
            object statusCancelled = this.safeDict(status, "cancelled");
            if (isTrue(!isEqual(statusCancelled, null)))
            {
                return "canceled";
            }
            object statusTriggered = this.safeDict(status, "triggered", new Dictionary<string, object>() {});
            object triggeredStatus = this.safeString(statusTriggered, "status", "failure");
            if (isTrue(isEqual(triggeredStatus, "success")))
            {
                return "closed";
            }
            return "canceled";
        }
        return status;
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // {
        //     "product_id": 1,
        //     "sender": "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
        //     "price_x18": "1000000000000000000",
        //     "amount": "1000000000000000000",
        //     "expiration": "2000000000",
        //     "nonce": "1",
        //     "unfilled_amount": "1000000000000000000",
        //     "digest": "0x0000000000000000000000000000000000000000000000000000000000000000",
        //     "placed_at": 1681951347,
        //     "order_type": "ioc"
        // }
        // stop order
        // {
        //     "order": {
        //       "order": {
        //         "sender": "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
        //         "priceX18": "1000000000000000000",
        //         "amount": "1000000000000000000",
        //         "expiration": "2000000000",
        //         "nonce": "1",
        //       },
        //       "signature": "0x...",
        //       "product_id": 1,
        //       "spot_leverage": true,
        //       "trigger": {
        //         "price_above": "1000000000000000000"
        //       },
        //       "digest": "0x..."
        //     },
        //     "status": "pending",
        //     "updated_at": 1688768157050
        // }
        //
        object marketId = this.safeString(order, "product_id");
        object timestamp = this.safeTimestamp(order, "placed_at");
        object amount = this.safeString(order, "amount");
        object price = this.safeString(order, "price_x18");
        object remaining = this.safeString(order, "unfilled_amount");
        object triggerPriceNum = null;
        object status = this.safeValue(order, "status");
        if (isTrue(!isEqual(status, null)))
        {
            // trigger order
            object outerOrder = this.safeDict(order, "order", new Dictionary<string, object>() {});
            object innerOrder = this.safeDict(outerOrder, "order", new Dictionary<string, object>() {});
            marketId = this.safeString(outerOrder, "product_id");
            amount = this.safeString(innerOrder, "amount");
            price = this.safeString(innerOrder, "priceX18");
            timestamp = this.safeTimestamp(order, "updated_at");
            object trigger = this.safeDict(outerOrder, "trigger", new Dictionary<string, object>() {});
            object triggerPrice = this.safeStringN(trigger, new List<object>() {"price_above", "price_below", "last_price_above", "last_price_below"});
            if (isTrue(!isEqual(triggerPrice, null)))
            {
                triggerPriceNum = this.parseToNumeric(this.convertFromX18(triggerPrice));
            }
        }
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object priceNum = null;
        if (isTrue(!isEqual(price, null)))
        {
            priceNum = this.parseToNumeric(this.convertFromX18(price));
        }
        object amountNum = null;
        if (isTrue(!isEqual(amount, null)))
        {
            amountNum = this.parseToNumeric(this.convertFromX18(amount));
        }
        object remainingNum = null;
        if (isTrue(!isEqual(remaining, null)))
        {
            remainingNum = this.parseToNumeric(this.convertFromX18(remaining));
        }
        object side = null;
        if (isTrue(isTrue(!isEqual(amountNum, null)) && isTrue(!isEqual(remainingNum, null))))
        {
            side = ((bool) isTrue((isTrue(isLessThan(amountNum, 0)) || isTrue(isLessThan(remainingNum, 0))))) ? "sell" : "buy";
        }
        object tif = this.parseTimeInForce(this.safeString(order, "order_type"));
        object isPostOnly = (isEqual(tif, "PO"));
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString(order, "digest") },
            { "clientOrderId", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", null },
            { "symbol", symbol },
            { "type", null },
            { "timeInForce", tif },
            { "postOnly", isPostOnly },
            { "reduceOnly", null },
            { "side", side },
            { "price", priceNum },
            { "triggerPrice", triggerPriceNum },
            { "amount", amountNum },
            { "cost", null },
            { "average", null },
            { "filled", null },
            { "remaining", remainingNum },
            { "status", this.parseOrderStatus(status) },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public virtual object parseTimeInForce(object timeInForce)
    {
        object timeInForces = new Dictionary<string, object>() {
            { "POST_ONLY", "PO" },
        };
        return this.safeStringUpper(timeInForces, timeInForce, timeInForce);
    }

    /**
     * @method
     * @name vertex#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/order
     * @param {string} id the order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "type", "order" },
            { "product_id", this.parseToInt(getValue(market, "id")) },
            { "digest", id },
        };
        object response = await this.v1GatewayGetQuery(this.extend(request, parameters));
        //
        // {
        //     "status": "success",
        //     "data": {
        //       "product_id": 1,
        //       "sender": "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
        //       "price_x18": "1000000000000000000",
        //       "amount": "1000000000000000000",
        //       "expiration": "2000000000",
        //       "nonce": "1",
        //       "unfilled_amount": "1000000000000000000",
        //       "digest": "0x0000000000000000000000000000000000000000000000000000000000000000",
        //       "placed_at": 1681951347,
        //       "order_type": "ioc"
        //     },
        //     "request_type": "query_order",
        // }
        //
        object data = this.safeDict(response, "data");
        return this.parseOrder(data, market);
    }

    /**
     * @method
     * @name vertex#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/orders
     * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/queries/list-trigger-orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.stop] whether the order is a stop/algo order
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        await this.loadMarkets();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchOpenOrders", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object market = null;
        object stop = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["product_id"] = this.parseToNumeric(getValue(market, "id"));
        }
        object response = null;
        if (isTrue(stop))
        {
            object contracts = await this.queryContracts();
            object chainId = this.safeString(contracts, "chain_id");
            object verifyingContractAddress = this.safeString(contracts, "endpoint_addr");
            object tx = new Dictionary<string, object>() {
                { "sender", this.convertAddressToSender(userAddress) },
                { "recvTime", add(this.nonce(), 90000) },
            };
            ((IDictionary<string,object>)request)["signature"] = this.buildListTriggerTxSig(tx, chainId, verifyingContractAddress);
            ((IDictionary<string,object>)request)["tx"] = new Dictionary<string, object>() {
                { "sender", getValue(tx, "sender") },
                { "recvTime", this.numberToString(getValue(tx, "recvTime")) },
            };
            ((IDictionary<string,object>)request)["type"] = "list_trigger_orders";
            ((IDictionary<string,object>)request)["pending"] = true;
            object until = this.safeInteger(parameters, "until");
            parameters = this.omit(parameters, "until");
            if (isTrue(!isEqual(until, null)))
            {
                ((IDictionary<string,object>)request)["max_update_time"] = until;
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            response = await this.v1TriggerPostQuery(this.extend(request, parameters));
        } else
        {
            this.checkRequiredArgument("fetchOpenOrders", symbol, "symbol");
            ((IDictionary<string,object>)request)["type"] = "subaccount_orders";
            ((IDictionary<string,object>)request)["sender"] = this.convertAddressToSender(userAddress);
            response = await this.v1GatewayPostQuery(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeList(data, "orders");
        return this.parseOrders(orders, market, since, limit);
    }

    /**
     * @method
     * @name vertex#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/queries/list-trigger-orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.stop] whether the order is a stop/algo order
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object stop = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        if (!isTrue(stop))
        {
            throw new NotSupported ((string)add(this.id, " fetchOrders only support trigger orders")) ;
        }
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchOrders", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {
            { "type", "list_trigger_orders" },
            { "pending", false },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["product_id"] = this.parseToNumeric(getValue(market, "id"));
        }
        object contracts = await this.queryContracts();
        object chainId = this.safeString(contracts, "chain_id");
        object verifyingContractAddress = this.safeString(contracts, "endpoint_addr");
        object tx = new Dictionary<string, object>() {
            { "sender", this.convertAddressToSender(userAddress) },
            { "recvTime", add(this.nonce(), 90000) },
        };
        ((IDictionary<string,object>)request)["signature"] = this.buildListTriggerTxSig(tx, chainId, verifyingContractAddress);
        ((IDictionary<string,object>)request)["tx"] = new Dictionary<string, object>() {
            { "sender", getValue(tx, "sender") },
            { "recvTime", this.numberToString(getValue(tx, "recvTime")) },
        };
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["max_update_time"] = until;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v1TriggerPostQuery(this.extend(request, parameters));
        //
        // {
        //     "status": "success",
        //     "data": {
        //       "orders": [
        //         {
        //           "order": {
        //             "order": {
        //               "sender": "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
        //               "priceX18": "1000000000000000000",
        //               "amount": "1000000000000000000",
        //               "expiration": "2000000000",
        //               "nonce": "1",
        //             },
        //             "signature": "0x...",
        //             "product_id": 1,
        //             "spot_leverage": true,
        //             "trigger": {
        //               "price_above": "1000000000000000000"
        //             },
        //             "digest": "0x..."
        //           },
        //           "status": "pending",
        //           "updated_at": 1688768157050
        //         }
        //       ]
        //     },
        //     "request_type": "query_list_trigger_orders"
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeList(data, "orders");
        return this.parseOrders(orders, market, since, limit);
    }

    /**
     * @method
     * @name vertex#cancelAllOrders
     * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/cancel-product-orders
     * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/executes/cancel-product-orders
     * @description cancel all open orders in a market
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.stop] whether the order is a stop/algo order
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        object marketId = getValue(market, "id");
        object contracts = await this.queryContracts();
        object chainId = this.safeString(contracts, "chain_id");
        object verifyingContractAddress = this.safeString(contracts, "endpoint_addr");
        object now = this.nonce();
        object nonce = this.getNonce(now, 90000);
        object cancels = new Dictionary<string, object>() {
            { "sender", this.convertAddressToSender(this.walletAddress) },
            { "productIds", new List<object> {this.parseToNumeric(marketId)} },
            { "nonce", nonce },
        };
        object request = new Dictionary<string, object>() {
            { "cancel_product_orders", new Dictionary<string, object>() {
                { "tx", new Dictionary<string, object>() {
                    { "sender", getValue(cancels, "sender") },
                    { "productIds", getValue(cancels, "productIds") },
                    { "nonce", this.numberToString(getValue(cancels, "nonce")) },
                } },
                { "signature", this.buildCancelAllOrdersSig(cancels, chainId, verifyingContractAddress) },
            } },
        };
        object stop = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        object response = null;
        if (isTrue(stop))
        {
            response = await this.v1TriggerPostExecute(this.extend(request, parameters));
        } else
        {
            response = await this.v1GatewayPostExecute(this.extend(request, parameters));
        }
        return response;
    }

    /**
     * @method
     * @name vertex#cancelOrder
     * @description cancels an open order
     * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/cancel-orders
     * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/executes/cancel-orders
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.cancelOrders(new List<object>() {id}, symbol, parameters);
    }

    /**
     * @method
     * @name vertex#cancelOrders
     * @description cancel multiple orders
     * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/cancel-orders
     * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/executes/cancel-orders
     * @param {string[]} ids order ids
     * @param {string} [symbol] unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = getValue(market, "id");
        object contracts = await this.queryContracts();
        object chainId = this.safeString(contracts, "chain_id");
        object verifyingContractAddress = this.safeString(contracts, "endpoint_addr");
        object now = this.nonce();
        object nonce = this.getNonce(now, 90000);
        object cancels = new Dictionary<string, object>() {
            { "sender", this.convertAddressToSender(this.walletAddress) },
            { "productIds", new List<object>() {} },
            { "digests", ids },
            { "nonce", nonce },
        };
        object marketIdNum = this.parseToNumeric(marketId);
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            ((IList<object>)getValue(cancels, "productIds")).Add(marketIdNum);
        }
        object request = new Dictionary<string, object>() {
            { "cancel_orders", new Dictionary<string, object>() {
                { "tx", new Dictionary<string, object>() {
                    { "sender", getValue(cancels, "sender") },
                    { "productIds", getValue(cancels, "productIds") },
                    { "digests", getValue(cancels, "digests") },
                    { "nonce", this.numberToString(getValue(cancels, "nonce")) },
                } },
                { "signature", this.buildCancelOrdersSig(cancels, chainId, verifyingContractAddress) },
            } },
        };
        object stop = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        object response = null;
        if (isTrue(stop))
        {
            response = await this.v1TriggerPostExecute(this.extend(request, parameters));
        } else
        {
            response = await this.v1GatewayPostExecute(this.extend(request, parameters));
        }
        return response;
    }

    /**
     * @method
     * @name vertex#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/subaccount-info
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchBalance", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "type", "subaccount_info" },
            { "subaccount", this.convertAddressToSender(userAddress) },
        };
        object response = await this.v1GatewayGetQuery(this.extend(request, parameters));
        //
        // {
        //     "status": "success",
        //     "data": {
        //       "subaccount": "0x265167ddfac55365d6ff07fc5943276319aa6b9f64656661756c740000000000",
        //       "exists": true,
        //       "healths": [
        //         {
        //           "assets": "75323297691833342306",
        //           "liabilities": "46329556869051092241",
        //           "health": "28993740822782250065"
        //         },
        //         {
        //           "assets": "75323297691833342306",
        //           "liabilities": "35968911700887320741",
        //           "health": "39354385990946021565"
        //         },
        //         {
        //           "assets": "80796966663601107565",
        //           "liabilities": "0",
        //           "health": "80796966663601107565"
        //         }
        //       ],
        //       "health_contributions": [
        //         [
        //           "75323297691833340000",
        //           "75323297691833340000",
        //           "75323297691833340000"
        //         ],
        //         [
        //           "0",
        //           "0",
        //           "0"
        //         ],
        //         [
        //           "0",
        //           "0",
        //           "0"
        //         ],
        //         [
        //           "0",
        //           "0",
        //           "0"
        //         ],
        //         [
        //           "-46329556869051090000",
        //           "-35968911700887323000",
        //           "5473668971767765000"
        //         ]
        //       ],
        //       "spot_count": 3,
        //       "perp_count": 2,
        //       "spot_balances": [
        //         {
        //           "product_id": 1,
        //           "lp_balance": {
        //             "amount": "0"
        //           },
        //           "balance": {
        //             "amount": "0",
        //             "last_cumulative_multiplier_x18": "1003419811982007193"
        //           }
        //         },
        //         {
        //           "product_id": 3,
        //           "lp_balance": {
        //             "amount": "0"
        //           },
        //           "balance": {
        //             "amount": "0",
        //             "last_cumulative_multiplier_x18": "1007584195035969404"
        //           }
        //         },
        //         {
        //           "product_id": 0,
        //           "lp_balance": {
        //             "amount": "0"
        //           },
        //           "balance": {
        //             "amount": "75323297691833342306",
        //             "last_cumulative_multiplier_x18": "1000000002391497578"
        //           }
        //         }
        //       ],
        //       "perp_balances": [
        //         {
        //           "product_id": 2,
        //           "lp_balance": {
        //             "amount": "0",
        //             "last_cumulative_funding_x18": "-284321955122859921"
        //           },
        //           "balance": {
        //             "amount": "0",
        //             "v_quote_balance": "0",
        //             "last_cumulative_funding_x18": "6363466629611946777168"
        //           }
        //         },
        //         {
        //           "product_id": 4,
        //           "lp_balance": {
        //             "amount": "0",
        //             "last_cumulative_funding_x18": "-90979748449893411"
        //           },
        //           "balance": {
        //             "amount": "-200000000000000000",
        //             "v_quote_balance": "419899475698318625259",
        //             "last_cumulative_funding_x18": "141182516563970577208"
        //           }
        //         }
        //       ],
        //       "spot_products": [
        //         {
        //           "product_id": 1,
        //           "oracle_price_x18": "30217830336443750750000",
        //           "risk": {
        //             "long_weight_initial_x18": "750000000000000000",
        //             "short_weight_initial_x18": "1250000000000000000",
        //             "long_weight_maintenance_x18": "800000000000000000",
        //             "short_weight_maintenance_x18": "1200000000000000000",
        //             "large_position_penalty_x18": "0"
        //           },
        //           "config": {
        //             "token": "0x5cc7c91690b2cbaee19a513473d73403e13fb431",
        //             "interest_inflection_util_x18": "800000000000000000",
        //             "interest_floor_x18": "10000000000000000",
        //             "interest_small_cap_x18": "40000000000000000",
        //             "interest_large_cap_x18": "1000000000000000000"
        //           },
        //           "state": {
        //             "cumulative_deposits_multiplier_x18": "1001304691727847318",
        //             "cumulative_borrows_multiplier_x18": "1003419811982007193",
        //             "total_deposits_normalized": "213107447159798397806318",
        //             "total_borrows_normalized": "4907820740150097483532"
        //           },
        //           "lp_state": {
        //             "supply": "1304981417419495030893348",
        //             "quote": {
        //               "amount": "2048495687410669565222259",
        //               "last_cumulative_multiplier_x18": "1000000002391497578"
        //             },
        //             "base": {
        //               "amount": "67623029247538886515",
        //               "last_cumulative_multiplier_x18": "1001304691727847318"
        //             }
        //           },
        //           "book_info": {
        //             "size_increment": "1000000000000000",
        //             "price_increment_x18": "1000000000000000000",
        //             "min_size": "10000000000000000",
        //             "collected_fees": "8865582805773573662738183",
        //             "lp_spread_x18": "3000000000000000"
        //           }
        //         },
        //         {
        //           "product_id": 3,
        //           "oracle_price_x18": "2075217009708333333333",
        //           "risk": {
        //             "long_weight_initial_x18": "750000000000000000",
        //             "short_weight_initial_x18": "1250000000000000000",
        //             "long_weight_maintenance_x18": "800000000000000000",
        //             "short_weight_maintenance_x18": "1200000000000000000",
        //             "large_position_penalty_x18": "0"
        //           },
        //           "config": {
        //             "token": "0xcc59686e3a32fb104c8ff84dd895676265efb8a6",
        //             "interest_inflection_util_x18": "800000000000000000",
        //             "interest_floor_x18": "10000000000000000",
        //             "interest_small_cap_x18": "40000000000000000",
        //             "interest_large_cap_x18": "1000000000000000000"
        //           },
        //           "state": {
        //             "cumulative_deposits_multiplier_x18": "1003722507760089346",
        //             "cumulative_borrows_multiplier_x18": "1007584195035969404",
        //             "total_deposits_normalized": "232750303205807326418622",
        //             "total_borrows_normalized": "110730726549469855171025"
        //           },
        //           "lp_state": {
        //             "supply": "902924999999999999774268",
        //             "quote": {
        //               "amount": "1165328092090344104989049",
        //               "last_cumulative_multiplier_x18": "1000000002391497578"
        //             },
        //             "base": {
        //               "amount": "563265647183403990588",
        //               "last_cumulative_multiplier_x18": "1003722507760089346"
        //             }
        //           },
        //           "book_info": {
        //             "size_increment": "10000000000000000",
        //             "price_increment_x18": "100000000000000000",
        //             "min_size": "100000000000000000",
        //             "collected_fees": "1801521329724633001446457",
        //             "lp_spread_x18": "3000000000000000"
        //           }
        //         },
        //         {
        //           "product_id": 0,
        //           "oracle_price_x18": "1000000000000000000",
        //           "risk": {
        //             "long_weight_initial_x18": "1000000000000000000",
        //             "short_weight_initial_x18": "1000000000000000000",
        //             "long_weight_maintenance_x18": "1000000000000000000",
        //             "short_weight_maintenance_x18": "1000000000000000000",
        //             "large_position_penalty_x18": "0"
        //           },
        //           "config": {
        //             "token": "0x179522635726710dd7d2035a81d856de4aa7836c",
        //             "interest_inflection_util_x18": "800000000000000000",
        //             "interest_floor_x18": "10000000000000000",
        //             "interest_small_cap_x18": "40000000000000000",
        //             "interest_large_cap_x18": "1000000000000000000"
        //           },
        //           "state": {
        //             "cumulative_deposits_multiplier_x18": "1000000002391497578",
        //             "cumulative_borrows_multiplier_x18": "1001593395547514024",
        //             "total_deposits_normalized": "60000256267437588885818752247843",
        //             "total_borrows_normalized": "391445043137305055810336885"
        //           },
        //           "lp_state": {
        //             "supply": "0",
        //             "quote": {
        //               "amount": "0",
        //               "last_cumulative_multiplier_x18": "0"
        //             },
        //             "base": {
        //               "amount": "0",
        //               "last_cumulative_multiplier_x18": "0"
        //             }
        //           },
        //           "book_info": {
        //             "size_increment": "0",
        //             "price_increment_x18": "0",
        //             "min_size": "0",
        //             "collected_fees": "0",
        //             "lp_spread_x18": "0"
        //           }
        //         }
        //       ],
        //       "perp_products": [
        //         {
        //           "product_id": 2,
        //           "oracle_price_x18": "30219079716463070000000",
        //           "risk": {
        //             "long_weight_initial_x18": "875000000000000000",
        //             "short_weight_initial_x18": "1125000000000000000",
        //             "long_weight_maintenance_x18": "900000000000000000",
        //             "short_weight_maintenance_x18": "1100000000000000000",
        //             "large_position_penalty_x18": "0"
        //           },
        //           "state": {
        //             "cumulative_funding_long_x18": "6363466629611946777168",
        //             "cumulative_funding_short_x18": "6363466629611946777168",
        //             "available_settle": "100612314098927536086702448",
        //             "open_interest": "57975708279961875623240"
        //           },
        //           "lp_state": {
        //             "supply": "783207415944433511804197",
        //             "last_cumulative_funding_x18": "6363466629611946777168",
        //             "cumulative_funding_per_lp_x18": "-284321955122859921",
        //             "base": "37321000000000000000",
        //             "quote": "1150991638943862165224593"
        //           },
        //           "book_info": {
        //             "size_increment": "1000000000000000",
        //             "price_increment_x18": "1000000000000000000",
        //             "min_size": "10000000000000000",
        //             "collected_fees": "7738341933653651206856235",
        //             "lp_spread_x18": "3000000000000000"
        //           }
        //         },
        //         {
        //           "product_id": 4,
        //           "oracle_price_x18": "2072129033632754300000",
        //           "risk": {
        //             "long_weight_initial_x18": "875000000000000000",
        //             "short_weight_initial_x18": "1125000000000000000",
        //             "long_weight_maintenance_x18": "900000000000000000",
        //             "short_weight_maintenance_x18": "1100000000000000000",
        //             "large_position_penalty_x18": "0"
        //           },
        //           "state": {
        //             "cumulative_funding_long_x18": "141182516563970577208",
        //             "cumulative_funding_short_x18": "141182516563970577208",
        //             "available_settle": "33807443862986950288685582",
        //             "open_interest": "316343836992291503987611"
        //           },
        //           "lp_state": {
        //             "supply": "541756546038144467864559",
        //             "last_cumulative_funding_x18": "141182516563970577208",
        //             "cumulative_funding_per_lp_x18": "-90979748449893411",
        //             "base": "362320000000000000000",
        //             "quote": "750080187685127907834038"
        //           },
        //           "book_info": {
        //             "size_increment": "10000000000000000",
        //             "price_increment_x18": "100000000000000000",
        //             "min_size": "100000000000000000",
        //             "collected_fees": "1893278317732551619694831",
        //             "lp_spread_x18": "3000000000000000"
        //           }
        //         }
        //       ]
        //     },
        //     "request_type": "query_subaccount_info"
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object balances = this.safeList(data, "spot_balances", new List<object>() {});
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object marketId = this.safeString(balance, "product_id");
            object market = this.safeMarket(marketId);
            object isUsdcMarketId = isEqual(marketId, "0");
            if (isTrue(isTrue(isEqual(getValue(market, "id"), null)) && !isTrue(isUsdcMarketId)))
            {
                continue;
            }
            object baseId = ((bool) isTrue((isUsdcMarketId))) ? "USDC" : this.safeString(market, "baseId");
            object code = this.safeCurrencyCode(baseId);
            object account = this.account();
            object tokenBalance = this.safeDict(balance, "balance", new Dictionary<string, object>() {});
            object total = this.convertFromX18(this.safeString(tokenBalance, "amount"));
            ((IDictionary<string,object>)account)["total"] = total;
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // {
        //     "product_id": 2,
        //     "lp_balance": {
        //       "amount": "0",
        //       "last_cumulative_funding_x18": "-284321955122859921"
        //     },
        //     "balance": {
        //       "amount": "0",
        //       "v_quote_balance": "0",
        //       "last_cumulative_funding_x18": "6363466629611946777168"
        //     }
        //   },
        //   {
        //     "product_id": 4,
        //     "lp_balance": {
        //       "amount": "0",
        //       "last_cumulative_funding_x18": "-90979748449893411"
        //     },
        //     "balance": {
        //       "amount": "-200000000000000000",
        //       "v_quote_balance": "419899475698318625259",
        //       "last_cumulative_funding_x18": "141182516563970577208"
        //     }
        // }
        //
        object marketId = this.safeString(position, "product_id");
        market = this.safeMarket(marketId);
        object balance = this.safeDict(position, "balance", new Dictionary<string, object>() {});
        object contractSize = this.convertFromX18(this.safeString(balance, "amount"));
        object side = "buy";
        if (isTrue(Precise.stringLt(contractSize, "1")))
        {
            side = "sell";
        }
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", this.safeString(market, "symbol") },
            { "timestamp", null },
            { "datetime", null },
            { "lastUpdateTimestamp", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "entryPrice", null },
            { "notional", null },
            { "leverage", null },
            { "unrealizedPnl", null },
            { "contracts", null },
            { "contractSize", this.parseToNumeric(contractSize) },
            { "marginRatio", null },
            { "liquidationPrice", null },
            { "markPrice", null },
            { "lastPrice", null },
            { "collateral", null },
            { "marginMode", "cross" },
            { "marginType", null },
            { "side", side },
            { "percentage", null },
            { "hedged", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    /**
     * @method
     * @name vertex#fetchPositions
     * @description fetch all open positions
     * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/subaccount-info
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchPositions", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "type", "subaccount_info" },
            { "subaccount", this.convertAddressToSender(userAddress) },
        };
        object response = await this.v1GatewayGetQuery(this.extend(request, parameters));
        // the response is the same as fetchBalance
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object positions = this.safeList(data, "perp_balances", new List<object>() {});
        symbols = this.marketSymbols(symbols);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object position = this.extend(this.parsePosition(getValue(positions, i), null), parameters);
            if (isTrue(isEqual(getValue(position, "contractSize"), 0)))
            {
                continue;
            }
            ((IList<object>)result).Add(position);
        }
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public async virtual Task<object> queryNonces()
    {
        object request = new Dictionary<string, object>() {
            { "type", "nonces" },
            { "address", this.walletAddress },
        };
        object response = await this.v1GatewayGetQuery(request);
        //
        // {
        //     "status":"success",
        //     "data":{
        //       "tx_nonce": 0,
        //       "order_nonce": 1753048133299863552
        //     },
        //     "request_type": "query_nonces",
        // }
        //
        return this.safeDict(response, "data", new Dictionary<string, object>() {});
    }

    /**
     * @method
     * @name vertex#withdraw
     * @description make a withdrawal
     * @see https://docs.vertexprotocol.com/developer-resources/api/withdrawing-on-chain
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        await this.loadMarkets();
        object currency = this.currency(code);
        object contracts = await this.queryContracts();
        object chainId = this.safeString(contracts, "chain_id");
        object verifyingContractAddress = this.safeString(contracts, "endpoint_addr");
        object nonces = await this.queryNonces();
        object nonce = this.safeNumber(nonces, "tx_nonce");
        object withdraw = new Dictionary<string, object>() {
            { "sender", this.convertAddressToSender(this.walletAddress) },
            { "productId", this.parseToNumeric(getValue(currency, "id")) },
            { "amount", ((object)amount).ToString() },
            { "nonce", nonce },
        };
        object request = new Dictionary<string, object>() {
            { "withdraw_collateral", new Dictionary<string, object>() {
                { "tx", new Dictionary<string, object>() {
                    { "sender", getValue(withdraw, "sender") },
                    { "productId", getValue(withdraw, "productId") },
                    { "amount", getValue(withdraw, "amount") },
                    { "nonce", this.numberToString(getValue(withdraw, "nonce")) },
                } },
                { "signature", this.buildWithdrawSig(withdraw, chainId, verifyingContractAddress) },
            } },
        };
        object response = await this.v1GatewayPostExecute(this.extend(request, parameters));
        //
        //     {
        //         "status": "success",
        //         "signature": {signature},
        //         "request_type": "execute_withdraw_collateral"
        //     }
        //
        object transaction = this.parseTransaction(response, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "address", address },
        });
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        //     {
        //         "status": "success",
        //         "signature": {signature},
        //         "request_type": "execute_withdraw_collateral"
        //     }
        //
        object code = null;
        if (isTrue(!isEqual(currency, null)))
        {
            code = getValue(currency, "code");
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", null },
            { "txid", null },
            { "timestamp", null },
            { "datetime", null },
            { "addressFrom", null },
            { "address", null },
            { "addressTo", null },
            { "tagFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "type", "withdrawal" },
            { "amount", null },
            { "currency", code },
            { "status", this.parseTransactionStatus(this.safeString(transaction, "status")) },
            { "updated", null },
            { "network", null },
            { "comment", null },
            { "internal", null },
            { "fee", null },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "success", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object handlePublicAddress(object methodName, object parameters)
    {
        object userAux = null;
        var userAuxparametersVariable = this.handleOptionAndParams(parameters, methodName, "user");
        userAux = ((IList<object>)userAuxparametersVariable)[0];
        parameters = ((IList<object>)userAuxparametersVariable)[1];
        object user = userAux;
        var userparametersVariable = this.handleOptionAndParams(parameters, methodName, "address", userAux);
        user = ((IList<object>)userparametersVariable)[0];
        parameters = ((IList<object>)userparametersVariable)[1];
        if (isTrue(isTrue((!isEqual(user, null))) && isTrue((!isEqual(user, "")))))
        {
            return new List<object>() {user, parameters};
        }
        if (isTrue(isTrue((!isEqual(this.walletAddress, null))) && isTrue((!isEqual(this.walletAddress, "")))))
        {
            return new List<object>() {this.walletAddress, parameters};
        }
        throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a user parameter inside 'params' or the wallet address set")) ;
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        //
        //
        object status = this.safeString(response, "status", "");
        if (isTrue(isEqual(status, "failure")))
        {
            object message = this.safeString(response, "error");
            object feedback = add(add(this.id, " "), body);
            object errorCode = this.safeString(response, "error_code");
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object version = this.safeString(api, 0);
        object type = this.safeString(api, 1);
        object url = this.implodeHostname(getValue(getValue(getValue(this.urls, "api"), version), type));
        if (isTrue(isTrue(!isEqual(version, "v1")) || isTrue(!isEqual(type, "archive"))))
        {
            url = add(add(url, "/"), path);
        }
        if (isTrue(isEqual(method, "POST")))
        {
            headers = new Dictionary<string, object>() {
                { "Content-Type", "application/json" },
            };
            body = this.json(parameters);
        } else
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.urlencode(parameters)));
            }
        }
        if (isTrue(!isEqual(path, "execute")))
        {
            // required encoding for public methods
            if (isTrue(!isEqual(headers, null)))
            {
                ((IDictionary<string,object>)headers)["Accept-Encoding"] = "gzip";
            } else
            {
                headers = new Dictionary<string, object>() {
                    { "Accept-Encoding", "gzip" },
                };
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }
}
