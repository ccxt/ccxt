namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class latoken : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "latoken" },
            { "name", "Latoken" },
            { "countries", new List<object>() {"KY"} },
            { "version", "v2" },
            { "rateLimit", 1000 },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createOrder", true },
                { "createPostOnlyOrder", false },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", false },
                { "createStopOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", false },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDepositsWithdrawals", true },
                { "fetchDepositWithdrawFees", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMyTrades", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchPosition", false },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsForSymbol", false },
                { "fetchPositionsHistory", false },
                { "fetchPositionsRisk", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchTransactions", "emulated" },
                { "fetchTransfer", false },
                { "fetchTransfers", true },
                { "transfer", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/61511972-24c39f00-aa01-11e9-9f7c-471f1d6e5214.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "rest", "https://api.latoken.com" },
                } },
                { "www", "https://latoken.com" },
                { "doc", new List<object>() {"https://api.latoken.com"} },
                { "fees", "https://latoken.com/fees" },
                { "referral", "https://latoken.com/invite?r=mvgp2djk" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "book/{currency}/{quote}", 1 },
                        { "chart/week", 1 },
                        { "chart/week/{currency}/{quote}", 1 },
                        { "currency", 1 },
                        { "currency/available", 1 },
                        { "currency/quotes", 1 },
                        { "currency/{currency}", 1 },
                        { "pair", 1 },
                        { "pair/available", 1 },
                        { "ticker", 1 },
                        { "ticker/{base}/{quote}", 1 },
                        { "time", 1 },
                        { "trade/history/{currency}/{quote}", 1 },
                        { "trade/fee/{currency}/{quote}", 1 },
                        { "trade/feeLevels", 1 },
                        { "transaction/bindings", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "auth/account", 1 },
                        { "auth/account/currency/{currency}/{type}", 1 },
                        { "auth/order", 1 },
                        { "auth/order/getOrder/{id}", 1 },
                        { "auth/order/pair/{currency}/{quote}", 1 },
                        { "auth/order/pair/{currency}/{quote}/active", 1 },
                        { "auth/stopOrder", 1 },
                        { "auth/stopOrder/getOrder/{id}", 1 },
                        { "auth/stopOrder/pair/{currency}/{quote}", 1 },
                        { "auth/stopOrder/pair/{currency}/{quote}/active", 1 },
                        { "auth/trade", 1 },
                        { "auth/trade/pair/{currency}/{quote}", 1 },
                        { "auth/trade/fee/{currency}/{quote}", 1 },
                        { "auth/transaction", 1 },
                        { "auth/transaction/bindings", 1 },
                        { "auth/transaction/bindings/{currency}", 1 },
                        { "auth/transaction/{id}", 1 },
                        { "auth/transfer", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "auth/order/cancel", 1 },
                        { "auth/order/cancelAll", 1 },
                        { "auth/order/cancelAll/{currency}/{quote}", 1 },
                        { "auth/order/place", 1 },
                        { "auth/spot/deposit", 1 },
                        { "auth/spot/withdraw", 1 },
                        { "auth/stopOrder/cancel", 1 },
                        { "auth/stopOrder/cancelAll", 1 },
                        { "auth/stopOrder/cancelAll/{currency}/{quote}", 1 },
                        { "auth/stopOrder/place", 1 },
                        { "auth/transaction/depositAddress", 1 },
                        { "auth/transaction/withdraw", 1 },
                        { "auth/transaction/withdraw/cancel", 1 },
                        { "auth/transaction/withdraw/confirm", 1 },
                        { "auth/transaction/withdraw/resendCode", 1 },
                        { "auth/transfer/email", 1 },
                        { "auth/transfer/id", 1 },
                        { "auth/transfer/phone", 1 },
                    } },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "feeSide", "get" },
                    { "tierBased", false },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.0049") },
                    { "taker", this.parseNumber("0.0049") },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "BUX", "Buxcoin" },
                { "CBT", "Community Business Token" },
                { "CTC", "CyberTronchain" },
                { "DMD", "Diamond Coin" },
                { "FREN", "Frenchie" },
                { "GDX", "GoldenX" },
                { "GEC", "Geco One" },
                { "GEM", "NFTmall" },
                { "GMT", "GMT Token" },
                { "IMC", "IMCoin" },
                { "MT", "Monarch" },
                { "TPAY", "Tetra Pay" },
                { "TRADE", "Smart Trade Coin" },
                { "TSL", "Treasure SL" },
                { "UNO", "Unobtanium" },
                { "WAR", "Warrior Token" },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "INTERNAL_ERROR", typeof(ExchangeError) },
                    { "SERVICE_UNAVAILABLE", typeof(ExchangeNotAvailable) },
                    { "NOT_AUTHORIZED", typeof(AuthenticationError) },
                    { "FORBIDDEN", typeof(PermissionDenied) },
                    { "BAD_REQUEST", typeof(BadRequest) },
                    { "NOT_FOUND", typeof(ExchangeError) },
                    { "ACCESS_DENIED", typeof(PermissionDenied) },
                    { "REQUEST_REJECTED", typeof(ExchangeError) },
                    { "HTTP_MEDIA_TYPE_NOT_SUPPORTED", typeof(BadRequest) },
                    { "MEDIA_TYPE_NOT_ACCEPTABLE", typeof(BadRequest) },
                    { "METHOD_ARGUMENT_NOT_VALID", typeof(BadRequest) },
                    { "VALIDATION_ERROR", typeof(BadRequest) },
                    { "ACCOUNT_EXPIRED", typeof(AccountSuspended) },
                    { "BAD_CREDENTIALS", typeof(AuthenticationError) },
                    { "COOKIE_THEFT", typeof(AuthenticationError) },
                    { "CREDENTIALS_EXPIRED", typeof(AccountSuspended) },
                    { "INSUFFICIENT_AUTHENTICATION", typeof(AuthenticationError) },
                    { "UNKNOWN_LOCATION", typeof(AuthenticationError) },
                    { "TOO_MANY_REQUESTS", typeof(RateLimitExceeded) },
                    { "INSUFFICIENT_FUNDS", typeof(InsufficientFunds) },
                    { "ORDER_VALIDATION", typeof(InvalidOrder) },
                    { "BAD_TICKS", typeof(InvalidOrder) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "invalid API key, signature or digest", typeof(AuthenticationError) },
                    { "The API key was revoked", typeof(AuthenticationError) },
                    { "request expired or bad", typeof(InvalidNonce) },
                    { "For input string", typeof(BadRequest) },
                    { "Unable to resolve currency by tag", typeof(BadSymbol) },
                    { "Can't find currency with tag", typeof(BadSymbol) },
                    { "Unable to place order because pair is in inactive state", typeof(BadSymbol) },
                    { "API keys are not available for", typeof(AccountSuspended) },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "defaultType", "spot" },
                { "types", new Dictionary<string, object>() {
                    { "wallet", "ACCOUNT_TYPE_WALLET" },
                    { "funding", "ACCOUNT_TYPE_WALLET" },
                    { "spot", "ACCOUNT_TYPE_SPOT" },
                } },
                { "accounts", new Dictionary<string, object>() {
                    { "ACCOUNT_TYPE_WALLET", "wallet" },
                    { "ACCOUNT_TYPE_SPOT", "spot" },
                } },
                { "fetchTradingFee", new Dictionary<string, object>() {
                    { "method", "fetchPrivateTradingFee" },
                } },
            } },
        });
    }

    public override object nonce()
    {
        return subtract(this.milliseconds(), getValue(this.options, "timeDifference"));
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name latoken#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @see https://api.latoken.com/doc/v2/#tag/Time/operation/currentTime
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetTime(parameters);
        //
        //     {
        //         "serverTime": 1570615577321
        //     }
        //
        return this.safeInteger(response, "serverTime");
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name latoken#fetchMarkets
        * @description retrieves data on all markets for latoken
        * @see https://api.latoken.com/doc/v2/#tag/Pair/operation/getActivePairs
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object currencies = await this.fetchCurrenciesFromCache(parameters);
        //
        //     [
        //         {
        //             "id":"1a075819-9e0b-48fc-8784-4dab1d186d6d",
        //             "status":"CURRENCY_STATUS_ACTIVE",
        //             "type":"CURRENCY_TYPE_ALTERNATIVE", // CURRENCY_TYPE_CRYPTO, CURRENCY_TYPE_IEO
        //             "name":"MyCryptoBank",
        //             "tag":"MCB",
        //             "description":"",
        //             "logo":"",
        //             "decimals":18,
        //             "created":1572912000000,
        //             "tier":1,
        //             "assetClass":"ASSET_CLASS_UNKNOWN",
        //             "minTransferAmount":0
        //         },
        //         {
        //             "id":"db02758e-2507-46a5-a805-7bc60355b3eb",
        //             "status":"CURRENCY_STATUS_ACTIVE",
        //             "type":"CURRENCY_TYPE_FUTURES_CONTRACT",
        //             "name":"BTC USDT Futures Contract",
        //             "tag":"BTCUSDT",
        //             "description":"",
        //             "logo":"",
        //             "decimals":8,
        //             "created":1589459984395,
        //             "tier":1,
        //             "assetClass":"ASSET_CLASS_UNKNOWN",
        //             "minTransferAmount":0
        //         },
        //     ]
        //
        object response = await this.publicGetPair(parameters);
        //
        //     [
        //         {
        //             "id":"dba4289b-6b46-4d94-bf55-49eec9a163ad",
        //             "status":"PAIR_STATUS_ACTIVE", // CURRENCY_STATUS_INACTIVE
        //             "baseCurrency":"fb9b53d6-bbf6-472f-b6ba-73cc0d606c9b",
        //             "quoteCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f",
        //             "priceTick":"0.000000100000000000",
        //             "priceDecimals":7,
        //             "quantityTick":"0.010000000",
        //             "quantityDecimals":2,
        //             "costDisplayDecimals":7,
        //             "created":1572957210501,
        //             "minOrderQuantity":"0",
        //             "maxOrderCostUsd":"999999999999999999",
        //             "minOrderCostUsd":"0",
        //             "externalSymbol":""
        //         }
        //     ]
        //
        if (isTrue(this.safeValue(this.options, "adjustForTimeDifference", true)))
        {
            await this.loadTimeDifference();
        }
        object currenciesById = this.indexBy(currencies, "id");
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object market = getValue(response, i);
            object id = this.safeString(market, "id");
            // the exchange shows them inverted
            object baseId = this.safeString(market, "baseCurrency");
            object quoteId = this.safeString(market, "quoteCurrency");
            object baseCurrency = this.safeValue(currenciesById, baseId);
            object quoteCurrency = this.safeValue(currenciesById, quoteId);
            if (isTrue(isTrue(!isEqual(baseCurrency, null)) && isTrue(!isEqual(quoteCurrency, null))))
            {
                object bs = this.safeCurrencyCode(this.safeString(baseCurrency, "tag"));
                object quote = this.safeCurrencyCode(this.safeString(quoteCurrency, "tag"));
                object lowercaseQuote = ((string)quote).ToLower();
                object capitalizedQuote = this.capitalize(lowercaseQuote);
                object status = this.safeString(market, "status");
                ((IList<object>)result).Add(new Dictionary<string, object>() {
                    { "id", id },
                    { "symbol", add(add(bs, "/"), quote) },
                    { "base", bs },
                    { "quote", quote },
                    { "settle", null },
                    { "baseId", baseId },
                    { "quoteId", quoteId },
                    { "settleId", null },
                    { "type", "spot" },
                    { "spot", true },
                    { "margin", false },
                    { "swap", false },
                    { "future", false },
                    { "option", false },
                    { "active", (isEqual(status, "PAIR_STATUS_ACTIVE")) },
                    { "contract", false },
                    { "linear", null },
                    { "inverse", null },
                    { "contractSize", null },
                    { "expiry", null },
                    { "expiryDatetime", null },
                    { "strike", null },
                    { "optionType", null },
                    { "precision", new Dictionary<string, object>() {
                        { "amount", this.safeNumber(market, "quantityTick") },
                        { "price", this.safeNumber(market, "priceTick") },
                    } },
                    { "limits", new Dictionary<string, object>() {
                        { "leverage", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "amount", new Dictionary<string, object>() {
                            { "min", this.safeNumber(market, "minOrderQuantity") },
                            { "max", null },
                        } },
                        { "price", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "cost", new Dictionary<string, object>() {
                            { "min", this.safeNumber(market, add("minOrderCost", capitalizedQuote)) },
                            { "max", this.safeNumber(market, add("maxOrderCost", capitalizedQuote)) },
                        } },
                    } },
                    { "created", this.safeInteger(market, "created") },
                    { "info", market },
                });
            }
        }
        return result;
    }

    public async virtual Task<object> fetchCurrenciesFromCache(object parameters = null)
    {
        // this method is now redundant
        // currencies are now fetched before markets
        parameters ??= new Dictionary<string, object>();
        object options = this.safeValue(this.options, "fetchCurrencies", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(options, "timestamp");
        object expires = this.safeInteger(options, "expires", 1000);
        object now = this.milliseconds();
        if (isTrue(isTrue((isEqual(timestamp, null))) || isTrue((isGreaterThan((subtract(now, timestamp)), expires)))))
        {
            object response = await this.publicGetCurrency(parameters);
            ((IDictionary<string,object>)this.options)["fetchCurrencies"] = this.extend(options, new Dictionary<string, object>() {
                { "response", response },
                { "timestamp", now },
            });
        }
        return this.safeValue(getValue(this.options, "fetchCurrencies"), "response");
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name latoken#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.fetchCurrenciesFromCache(parameters);
        //
        //     [
        //         {
        //             "id":"1a075819-9e0b-48fc-8784-4dab1d186d6d",
        //             "status":"CURRENCY_STATUS_ACTIVE",
        //             "type":"CURRENCY_TYPE_ALTERNATIVE", // CURRENCY_TYPE_CRYPTO, CURRENCY_TYPE_IEO
        //             "name":"MyCryptoBank",
        //             "tag":"MCB",
        //             "description":"",
        //             "logo":"",
        //             "decimals":18,
        //             "created":1572912000000,
        //             "tier":1,
        //             "assetClass":"ASSET_CLASS_UNKNOWN",
        //             "minTransferAmount":0
        //         },
        //         {
        //             "id":"db02758e-2507-46a5-a805-7bc60355b3eb",
        //             "status":"CURRENCY_STATUS_ACTIVE",
        //             "type":"CURRENCY_TYPE_FUTURES_CONTRACT",
        //             "name":"BTC USDT Futures Contract",
        //             "tag":"BTCUSDT",
        //             "description":"",
        //             "logo":"",
        //             "decimals":8,
        //             "created":1589459984395,
        //             "tier":1,
        //             "assetClass":"ASSET_CLASS_UNKNOWN",
        //             "minTransferAmount":0
        //         },
        //     ]
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object currency = getValue(response, i);
            object id = this.safeString(currency, "id");
            object tag = this.safeString(currency, "tag");
            object code = this.safeCurrencyCode(tag);
            object fee = this.safeNumber(currency, "fee");
            object currencyType = this.safeString(currency, "type");
            object type = null;
            if (isTrue(isEqual(currencyType, "CURRENCY_TYPE_ALTERNATIVE")))
            {
                type = "other";
            } else
            {
                // CURRENCY_TYPE_CRYPTO and CURRENCY_TYPE_IEO are all cryptos
                type = "crypto";
            }
            object status = this.safeString(currency, "status");
            object active = (isEqual(status, "CURRENCY_STATUS_ACTIVE"));
            object name = this.safeString(currency, "name");
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "code", code },
                { "info", currency },
                { "name", name },
                { "type", type },
                { "active", active },
                { "deposit", null },
                { "withdraw", null },
                { "fee", fee },
                { "precision", this.parseNumber(this.parsePrecision(this.safeString(currency, "decimals"))) },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(currency, "minTransferAmount") },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "networks", new Dictionary<string, object>() {} },
            };
        }
        return result;
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name latoken#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://api.latoken.com/doc/v2/#tag/Account/operation/getBalancesByUser
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetAuthAccount(parameters);
        //
        //     [
        //         {
        //             "id": "e5852e02-8711-431c-9749-a6f5503c6dbe",
        //             "status": "ACCOUNT_STATUS_ACTIVE",
        //             "type": "ACCOUNT_TYPE_WALLET",
        //             "timestamp": "1635920106506",
        //             "currency": "0c3a106d-bde3-4c13-a26e-3fd2394529e5",
        //             "available": "100.000000",
        //             "blocked": "0.000000"
        //         },
        //         {
        //             "id": "369df204-acbc-467e-a25e-b16e3cc09cf6",
        //             "status": "ACCOUNT_STATUS_ACTIVE",
        //             "type": "ACCOUNT_TYPE_SPOT",
        //             "timestamp": "1635920106504",
        //             "currency": "0c3a106d-bde3-4c13-a26e-3fd2394529e5",
        //             "available": "100.000000",
        //             "blocked": "0.000000"
        //         }
        //     ]
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        object maxTimestamp = null;
        object defaultType = this.safeString2(this.options, "fetchBalance", "defaultType", "spot");
        object type = this.safeString(parameters, "type", defaultType);
        object types = this.safeValue(this.options, "types", new Dictionary<string, object>() {});
        object accountType = this.safeString(types, type, type);
        object balancesByType = this.groupBy(response, "type");
        object balances = this.safeValue(balancesByType, accountType, new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object currencyId = this.safeString(balance, "currency");
            object timestamp = this.safeInteger(balance, "timestamp");
            if (isTrue(!isEqual(timestamp, null)))
            {
                if (isTrue(isEqual(maxTimestamp, null)))
                {
                    maxTimestamp = timestamp;
                } else
                {
                    maxTimestamp = mathMax(maxTimestamp, timestamp);
                }
            }
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "available");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "blocked");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        ((IDictionary<string,object>)result)["timestamp"] = maxTimestamp;
        ((IDictionary<string,object>)result)["datetime"] = this.iso8601(maxTimestamp);
        return this.safeBalance(result);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name latoken#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://api.latoken.com/doc/v2/#tag/Order-Book/operation/getOrderBook
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(market, "baseId") },
            { "quote", getValue(market, "quoteId") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // max 1000
        }
        object response = await this.publicGetBookCurrencyQuote(this.extend(request, parameters));
        //
        //     {
        //         "ask":[
        //             {"price":"4428.76","quantity":"0.08136","cost":"360.3239136","accumulated":"360.3239136"},
        //             {"price":"4429.77","quantity":"1.11786","cost":"4951.8626922","accumulated":"5312.1866058"},
        //             {"price":"4430.94","quantity":"1.78418","cost":"7905.5945292","accumulated":"13217.781135"},
        //         ],
        //         "bid":[
        //             {"price":"4428.43","quantity":"0.13675","cost":"605.5878025","accumulated":"605.5878025"},
        //             {"price":"4428.19","quantity":"0.03619","cost":"160.2561961","accumulated":"765.8439986"},
        //             {"price":"4428.15","quantity":"0.02926","cost":"129.567669","accumulated":"895.4116676"},
        //         ],
        //         "totalAsk":"53.14814",
        //         "totalBid":"112216.9029791"
        //     }
        //
        return this.parseOrderBook(response, symbol, null, "bid", "ask", "price", "quantity");
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //    {
        //        "symbol": "92151d82-df98-4d88-9a4d-284fa9eca49f/0c3a106d-bde3-4c13-a26e-3fd2394529e5",
        //        "baseCurrency": "92151d82-df98-4d88-9a4d-284fa9eca49f",
        //        "quoteCurrency": "0c3a106d-bde3-4c13-a26e-3fd2394529e5",
        //        "volume24h": "165723597.189022176000000000",
        //        "volume7d": "934505768.625109571000000000",
        //        "change24h": "0.0200",
        //        "change7d": "-6.4200",
        //        "amount24h": "6438.457663100000000000",
        //        "amount7d": "35657.785013800000000000",
        //        "lastPrice": "25779.16",
        //        "lastQuantity": "0.248403300000000000",
        //        "bestBid": "25778.74",
        //        "bestBidQuantity": "0.6520232",
        //        "bestAsk": "25779.17",
        //        "bestAskQuantity": "0.4956043",
        //        "updateTimestamp": "1693965231406"
        //    }
        //
        object marketId = this.safeString(ticker, "symbol");
        object last = this.safeString(ticker, "lastPrice");
        object timestamp = this.safeIntegerOmitZero(ticker, "updateTimestamp"); // sometimes latoken provided '0' ts from /ticker endpoint
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(marketId, market) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "low", null },
            { "high", null },
            { "bid", this.safeString(ticker, "bestBid") },
            { "bidVolume", this.safeString(ticker, "bestBidQuantity") },
            { "ask", this.safeString(ticker, "bestAsk") },
            { "askVolume", this.safeString(ticker, "bestAskQuantity") },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", this.safeString(ticker, "change24h") },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "amount24h") },
            { "quoteVolume", this.safeString(ticker, "volume24h") },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name latoken#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://api.latoken.com/doc/v2/#tag/Ticker/operation/getTicker
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "base", getValue(market, "baseId") },
            { "quote", getValue(market, "quoteId") },
        };
        object response = await this.publicGetTickerBaseQuote(this.extend(request, parameters));
        //
        //    {
        //        "symbol": "92151d82-df98-4d88-9a4d-284fa9eca49f/0c3a106d-bde3-4c13-a26e-3fd2394529e5",
        //        "baseCurrency": "92151d82-df98-4d88-9a4d-284fa9eca49f",
        //        "quoteCurrency": "0c3a106d-bde3-4c13-a26e-3fd2394529e5",
        //        "volume24h": "165723597.189022176000000000",
        //        "volume7d": "934505768.625109571000000000",
        //        "change24h": "0.0200",
        //        "change7d": "-6.4200",
        //        "amount24h": "6438.457663100000000000",
        //        "amount7d": "35657.785013800000000000",
        //        "lastPrice": "25779.16",
        //        "lastQuantity": "0.248403300000000000",
        //        "bestBid": "25778.74",
        //        "bestBidQuantity": "0.6520232",
        //        "bestAsk": "25779.17",
        //        "bestAskQuantity": "0.4956043",
        //        "updateTimestamp": "1693965231406"
        //    }
        //
        return this.parseTicker(response, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name latoken#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://api.latoken.com/doc/v2/#tag/Ticker/operation/getAllTickers
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetTicker(parameters);
        //
        //    [
        //        {
        //            "symbol": "92151d82-df98-4d88-9a4d-284fa9eca49f/0c3a106d-bde3-4c13-a26e-3fd2394529e5",
        //            "baseCurrency": "92151d82-df98-4d88-9a4d-284fa9eca49f",
        //            "quoteCurrency": "0c3a106d-bde3-4c13-a26e-3fd2394529e5",
        //            "volume24h": "165723597.189022176000000000",
        //            "volume7d": "934505768.625109571000000000",
        //            "change24h": "0.0200",
        //            "change7d": "-6.4200",
        //            "amount24h": "6438.457663100000000000",
        //            "amount7d": "35657.785013800000000000",
        //            "lastPrice": "25779.16",
        //            "lastQuantity": "0.248403300000000000",
        //            "bestBid": "25778.74",
        //            "bestBidQuantity": "0.6520232",
        //            "bestAsk": "25779.17",
        //            "bestAskQuantity": "0.4956043",
        //            "updateTimestamp": "1693965231406"
        //        }
        //    ]
        //
        return this.parseTickers(response, symbols);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //     {
        //         "id":"c152f814-8eeb-44f0-8f3f-e5c568f2ffcf",
        //         "isMakerBuyer":false,
        //         "baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f",
        //         "quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5",
        //         "price":"4435.56",
        //         "quantity":"0.32534",
        //         "cost":"1443.0650904",
        //         "timestamp":1635854642725,
        //         "makerBuyer":false
        //     }
        //
        // fetchMyTrades (private)
        //
        //     {
        //         "id":"02e02533-b4bf-4ba9-9271-24e2108dfbf7",
        //         "isMakerBuyer":false,
        //         "direction":"TRADE_DIRECTION_BUY",
        //         "baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f",
        //         "quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5",
        //         "price":"4564.32",
        //         "quantity":"0.01000",
        //         "cost":"45.6432",
        //         "fee":"0.223651680000000000",
        //         "order":"c9cac6a0-484c-4892-88e7-ad51b39f2ce1",
        //         "timestamp":1635921580399,
        //         "makerBuyer":false
        //     }
        //
        object type = null;
        object timestamp = this.safeInteger(trade, "timestamp");
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString(trade, "quantity");
        object costString = this.safeString(trade, "cost");
        object makerBuyer = this.safeValue(trade, "makerBuyer");
        object side = this.safeString(trade, "direction");
        if (isTrue(isEqual(side, null)))
        {
            side = ((bool) isTrue(makerBuyer)) ? "sell" : "buy";
        } else
        {
            if (isTrue(isEqual(side, "TRADE_DIRECTION_BUY")))
            {
                side = "buy";
            } else if (isTrue(isEqual(side, "TRADE_DIRECTION_SELL")))
            {
                side = "sell";
            }
        }
        object isBuy = (isEqual(side, "buy"));
        object takerOrMaker = ((bool) isTrue((isTrue(makerBuyer) && isTrue(isBuy)))) ? "maker" : "taker";
        object baseId = this.safeString(trade, "baseCurrency");
        object quoteId = this.safeString(trade, "quoteCurrency");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(bs, "/"), quote);
        if (isTrue(inOp(this.markets, symbol)))
        {
            market = this.market(symbol);
        }
        object id = this.safeString(trade, "id");
        object orderId = this.safeString(trade, "order");
        object feeCost = this.safeString(trade, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", quote },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", id },
            { "order", orderId },
            { "type", type },
            { "takerOrMaker", takerOrMaker },
            { "side", side },
            { "price", priceString },
            { "amount", amountString },
            { "cost", costString },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name latoken#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://api.latoken.com/doc/v2/#tag/Trade/operation/getTradesByPair
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(market, "baseId") },
            { "quote", getValue(market, "quoteId") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 100); // default 100, limit 100
        }
        object response = await this.publicGetTradeHistoryCurrencyQuote(this.extend(request, parameters));
        //
        //     [
        //         {"id":"c152f814-8eeb-44f0-8f3f-e5c568f2ffcf","isMakerBuyer":false,"baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f","quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5","price":"4435.56","quantity":"0.32534","cost":"1443.0650904","timestamp":1635854642725,"makerBuyer":false},
        //         {"id":"cfecbefb-3d11-43d7-b9d4-fa16211aad8a","isMakerBuyer":false,"baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f","quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5","price":"4435.13","quantity":"0.26540","cost":"1177.083502","timestamp":1635854641114,"makerBuyer":false},
        //         {"id":"f43d3ec8-db94-49f3-b534-91dbc2779296","isMakerBuyer":true,"baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f","quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5","price":"4435.00","quantity":"0.41738","cost":"1851.0803","timestamp":1635854640323,"makerBuyer":true},
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name latoken#fetchTradingFee
        * @description fetch the trading fees for a market
        * @see https://api.latoken.com/doc/v2/#tag/Trade/operation/getFeeByPair
        * @see https://api.latoken.com/doc/v2/#tag/Trade/operation/getAuthFeeByPair
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object options = this.safeValue(this.options, "fetchTradingFee", new Dictionary<string, object>() {});
        object defaultMethod = this.safeString(options, "method", "fetchPrivateTradingFee");
        object method = this.safeString(parameters, "method", defaultMethod);
        parameters = this.omit(parameters, "method");
        if (isTrue(isEqual(method, "fetchPrivateTradingFee")))
        {
            return await this.fetchPrivateTradingFee(symbol, parameters);
        } else if (isTrue(isEqual(method, "fetchPublicTradingFee")))
        {
            return await this.fetchPublicTradingFee(symbol, parameters);
        } else
        {
            throw new NotSupported ((string)add(this.id, " not support this method")) ;
        }
    }

    public async virtual Task<object> fetchPublicTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(market, "baseId") },
            { "quote", getValue(market, "quoteId") },
        };
        object response = await this.publicGetTradeFeeCurrencyQuote(this.extend(request, parameters));
        //
        //     {
        //         "makerFee": "0.004900000000000000",
        //         "takerFee": "0.004900000000000000",
        //         "type": "FEE_SCHEME_TYPE_PERCENT_QUOTE",
        //         "take": "FEE_SCHEME_TAKE_PROPORTION"
        //     }
        //
        return new Dictionary<string, object>() {
            { "info", response },
            { "symbol", getValue(market, "symbol") },
            { "maker", this.safeNumber(response, "makerFee") },
            { "taker", this.safeNumber(response, "takerFee") },
            { "percentage", null },
            { "tierBased", null },
        };
    }

    public async virtual Task<object> fetchPrivateTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(market, "baseId") },
            { "quote", getValue(market, "quoteId") },
        };
        object response = await this.privateGetAuthTradeFeeCurrencyQuote(this.extend(request, parameters));
        //
        //     {
        //         "makerFee": "0.004900000000000000",
        //         "takerFee": "0.004900000000000000",
        //         "type": "FEE_SCHEME_TYPE_PERCENT_QUOTE",
        //         "take": "FEE_SCHEME_TAKE_PROPORTION"
        //     }
        //
        return new Dictionary<string, object>() {
            { "info", response },
            { "symbol", getValue(market, "symbol") },
            { "maker", this.safeNumber(response, "makerFee") },
            { "taker", this.safeNumber(response, "takerFee") },
            { "percentage", null },
            { "tierBased", null },
        };
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name latoken#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://api.latoken.com/doc/v2/#tag/Trade/operation/getTradesByTrader
        * @see https://api.latoken.com/doc/v2/#tag/Trade/operation/getTradesByAssetAndTrader
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100
        }
        object response = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["currency"] = getValue(market, "baseId");
            ((IDictionary<string,object>)request)["quote"] = getValue(market, "quoteId");
            response = await this.privateGetAuthTradePairCurrencyQuote(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetAuthTrade(this.extend(request, parameters));
        }
        //
        //     [
        //         {
        //             "id":"02e02533-b4bf-4ba9-9271-24e2108dfbf7",
        //             "isMakerBuyer":false,
        //             "direction":"TRADE_DIRECTION_BUY",
        //             "baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f",
        //             "quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5",
        //             "price":"4564.32",
        //             "quantity":"0.01000",
        //             "cost":"45.6432",
        //             "fee":"0.223651680000000000",
        //             "order":"c9cac6a0-484c-4892-88e7-ad51b39f2ce1",
        //             "timestamp":1635921580399,
        //             "makerBuyer":false
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "ORDER_STATUS_PLACED", "open" },
            { "ORDER_STATUS_CLOSED", "closed" },
            { "ORDER_STATUS_CANCELLED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderType(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "ORDER_TYPE_MARKET", "market" },
            { "ORDER_TYPE_LIMIT", "limit" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseTimeInForce(object timeInForce)
    {
        object timeInForces = new Dictionary<string, object>() {
            { "ORDER_CONDITION_GOOD_TILL_CANCELLED", "GTC" },
            { "ORDER_CONDITION_IMMEDIATE_OR_CANCEL", "IOC" },
            { "ORDER_CONDITION_FILL_OR_KILL", "FOK" },
        };
        return this.safeString(timeInForces, timeInForce, timeInForce);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //
        //    {
        //        "baseCurrency": "f7dac554-8139-4ff6-841f-0e586a5984a0",
        //        "quoteCurrency": "a5a7a7a9-e2a3-43f9-8754-29a02f6b709b",
        //        "side": "BID",
        //        "clientOrderId": "my-wonderful-order-number-71566",
        //        "price": "10103.19",
        //        "stopPrice": "10103.19",
        //        "quantity": "3.21",
        //        "timestamp": 1568185507
        //    }
        //
        // fetchOrder, fetchOpenOrders, fetchOrders
        //
        //     {
        //         "id":"a76bd262-3560-4bfb-98ac-1cedd394f4fc",
        //         "status":"ORDER_STATUS_PLACED",
        //         "side":"ORDER_SIDE_BUY",
        //         "condition":"ORDER_CONDITION_GOOD_TILL_CANCELLED",
        //         "type":"ORDER_TYPE_LIMIT",
        //         "baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f",
        //         "quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5",
        //         "clientOrderId":"web-macos_chrome_1a6a6659-6f7c-4fac-be0b-d1d7ac06d",
        //         "price":"4000.00",
        //         "quantity":"0.01",
        //         "cost":"40.000000000000000000",
        //         "filled":"0",
        //         "trader":"7244bb3a-b6b2-446a-ac78-fa4bce5b59a9",
        //         "creator":"ORDER_CREATOR_USER",
        //         "creatorId":"",
        //         "timestamp":1635920767648
        //     }
        //
        // cancelOrder
        //
        //     {
        //         "message":"cancellation request successfully submitted",
        //         "status":"SUCCESS",
        //         "id":"a631426d-3543-45ba-941e-75f7825afb0f"
        //     }
        //
        object id = this.safeString(order, "id");
        object timestamp = this.safeInteger(order, "timestamp");
        object baseId = this.safeString(order, "baseCurrency");
        object quoteId = this.safeString(order, "quoteCurrency");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = null;
        if (isTrue(isTrue((!isEqual(bs, null))) && isTrue((!isEqual(quote, null)))))
        {
            symbol = add(add(bs, "/"), quote);
            if (isTrue(inOp(this.markets, symbol)))
            {
                market = this.market(symbol);
            }
        }
        object orderSide = this.safeString(order, "side");
        object side = null;
        if (isTrue(!isEqual(orderSide, null)))
        {
            object parts = ((string)orderSide).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
            object partsLength = getArrayLength(parts);
            side = this.safeStringLower(parts, subtract(partsLength, 1));
        }
        object type = this.parseOrderType(this.safeString(order, "type"));
        object price = this.safeString(order, "price");
        object amount = this.safeString(order, "quantity");
        object filled = this.safeString(order, "filled");
        object cost = this.safeString(order, "cost");
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object message = this.safeString(order, "message");
        if (isTrue(!isEqual(message, null)))
        {
            if (isTrue(isGreaterThanOrEqual(getIndexOf(message, "cancel"), 0)))
            {
                status = "canceled";
            } else if (isTrue(isGreaterThanOrEqual(getIndexOf(message, "accept"), 0)))
            {
                status = "open";
            }
        }
        object clientOrderId = this.safeString(order, "clientOrderId");
        object timeInForce = this.parseTimeInForce(this.safeString(order, "condition"));
        object triggerPrice = this.safeString(order, "stopPrice");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "info", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "status", status },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", triggerPrice },
            { "triggerPrice", triggerPrice },
            { "cost", cost },
            { "amount", amount },
            { "filled", filled },
            { "average", null },
            { "remaining", null },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name latoken#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://api.latoken.com/doc/v2/#tag/Order/operation/getMyActiveOrdersByPair
        * @see https://api.latoken.com/doc/v2/#tag/StopOrder/operation/getMyActiveStopOrdersByPair  // stop
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.trigger] true if fetching trigger orders
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOpenOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object response = null;
        object isTrigger = this.safeValue2(parameters, "trigger", "stop");
        parameters = this.omit(parameters, "stop");
        // privateGetAuthOrderActive doesn't work even though its listed at https://api.latoken.com/doc/v2/#tag/Order/operation/getMyActiveOrders
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(market, "baseId") },
            { "quote", getValue(market, "quoteId") },
        };
        if (isTrue(isTrigger))
        {
            response = await this.privateGetAuthStopOrderPairCurrencyQuoteActive(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetAuthOrderPairCurrencyQuoteActive(this.extend(request, parameters));
        }
        //
        //     [
        //         {
        //             "id":"a76bd262-3560-4bfb-98ac-1cedd394f4fc",
        //             "status":"ORDER_STATUS_PLACED",
        //             "side":"ORDER_SIDE_BUY",
        //             "condition":"ORDER_CONDITION_GOOD_TILL_CANCELLED",
        //             "type":"ORDER_TYPE_LIMIT",
        //             "baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f",
        //             "quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5",
        //             "clientOrderId":"web-macos_chrome_1a6a6659-6f7c-4fac-be0b-d1d7ac06d",
        //             "price":"4000.00",
        //             "quantity":"0.01000",
        //             "cost":"40.00",
        //             "filled":"0.00000",
        //             "trader":"7244bb3a-b6b2-446a-ac78-fa4bce5b59a9",
        //             "creator":"USER",
        //             "creatorId":"",
        //             "timestamp":1635920767648
        //         }
        //     ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name latoken#fetchOrders
        * @description fetches information on multiple orders made by the user
        * @see https://api.latoken.com/doc/v2/#tag/Order/operation/getMyOrders
        * @see https://api.latoken.com/doc/v2/#tag/Order/operation/getMyOrdersByPair
        * @see https://api.latoken.com/doc/v2/#tag/StopOrder/operation/getMyStopOrders       // stop
        * @see https://api.latoken.com/doc/v2/#tag/StopOrder/operation/getMyStopOrdersByPair // stop
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.trigger] true if fetching trigger orders
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        object isTrigger = this.safeValue2(parameters, "trigger", "stop");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100
        }
        object response = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["currency"] = getValue(market, "baseId");
            ((IDictionary<string,object>)request)["quote"] = getValue(market, "quoteId");
            if (isTrue(isTrigger))
            {
                response = await this.privateGetAuthStopOrderPairCurrencyQuote(this.extend(request, parameters));
            } else
            {
                response = await this.privateGetAuthOrderPairCurrencyQuote(this.extend(request, parameters));
            }
        } else
        {
            if (isTrue(isTrigger))
            {
                response = await this.privateGetAuthStopOrder(this.extend(request, parameters));
            } else
            {
                response = await this.privateGetAuthOrder(this.extend(request, parameters));
            }
        }
        //
        //     [
        //         {
        //             "id":"a76bd262-3560-4bfb-98ac-1cedd394f4fc",
        //             "status":"ORDER_STATUS_PLACED",
        //             "side":"ORDER_SIDE_BUY",
        //             "condition":"ORDER_CONDITION_GOOD_TILL_CANCELLED",
        //             "type":"ORDER_TYPE_LIMIT",
        //             "baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f",
        //             "quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5",
        //             "clientOrderId":"web-macos_chrome_1a6a6659-6f7c-4fac-be0b-d1d7ac06d",
        //             "price":"4000.00",
        //             "quantity":"0.01000",
        //             "cost":"40.00",
        //             "filled":"0.00000",
        //             "trader":"7244bb3a-b6b2-446a-ac78-fa4bce5b59a9",
        //             "creator":"USER",
        //             "creatorId":"",
        //             "timestamp":1635920767648
        //         }
        //     ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name latoken#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://api.latoken.com/doc/v2/#tag/Order/operation/getOrderById
        * @see https://api.latoken.com/doc/v2/#tag/StopOrder/operation/getStopOrderById
        * @param {string} [symbol] not used by latoken fetchOrder
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.trigger] true if fetching a trigger order
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object isTrigger = this.safeValue2(parameters, "trigger", "stop");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        object response = null;
        if (isTrue(isTrigger))
        {
            response = await this.privateGetAuthStopOrderGetOrderId(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetAuthOrderGetOrderId(this.extend(request, parameters));
        }
        //
        //     {
        //         "id":"a76bd262-3560-4bfb-98ac-1cedd394f4fc",
        //         "status":"ORDER_STATUS_PLACED",
        //         "side":"ORDER_SIDE_BUY",
        //         "condition":"ORDER_CONDITION_GOOD_TILL_CANCELLED",
        //         "type":"ORDER_TYPE_LIMIT",
        //         "baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f",
        //         "quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5",
        //         "clientOrderId":"web-macos_chrome_1a6a6659-6f7c-4fac-be0b-d1d7ac06d",
        //         "price":"4000.00",
        //         "quantity":"0.01",
        //         "cost":"40.000000000000000000",
        //         "filled":"0",
        //         "trader":"7244bb3a-b6b2-446a-ac78-fa4bce5b59a9",
        //         "creator":"ORDER_CREATOR_USER",
        //         "creatorId":"",
        //         "timestamp":1635920767648
        //     }
        //
        return this.parseOrder(response);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name latoken#createOrder
        * @description create a trade order
        * @see https://api.latoken.com/doc/v2/#tag/Order/operation/placeOrder
        * @see https://api.latoken.com/doc/v2/#tag/StopOrder/operation/placeStopOrder  // stop
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.triggerPrice] the price at which a trigger order is triggered at
        *
        * EXCHANGE SPECIFIC PARAMETERS
        * @param {string} [params.condition] "GTC", "IOC", or  "FOK"
        * @param {string} [params.clientOrderId] [ 0 .. 50 ] characters, client's custom order id (free field for your convenience)
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object uppercaseType = ((string)type).ToUpper();
        object request = new Dictionary<string, object>() {
            { "baseCurrency", getValue(market, "baseId") },
            { "quoteCurrency", getValue(market, "quoteId") },
            { "side", ((string)side).ToUpper() },
            { "condition", "GTC" },
            { "type", uppercaseType },
            { "clientOrderId", this.uuid() },
            { "quantity", this.amountToPrecision(symbol, amount) },
            { "timestamp", this.seconds() },
        };
        if (isTrue(isEqual(uppercaseType, "LIMIT")))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object triggerPrice = this.safeString2(parameters, "triggerPrice", "stopPrice");
        parameters = this.omit(parameters, new List<object>() {"triggerPrice", "stopPrice"});
        object response = null;
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, triggerPrice);
            response = await this.privatePostAuthStopOrderPlace(this.extend(request, parameters));
        } else
        {
            response = await this.privatePostAuthOrderPlace(this.extend(request, parameters));
        }
        //
        //    {
        //        "baseCurrency": "f7dac554-8139-4ff6-841f-0e586a5984a0",
        //        "quoteCurrency": "a5a7a7a9-e2a3-43f9-8754-29a02f6b709b",
        //        "side": "BID",
        //        "clientOrderId": "my-wonderful-order-number-71566",
        //        "price": "10103.19",
        //        "stopPrice": "10103.19",
        //        "quantity": "3.21",
        //        "timestamp": 1568185507
        //    }
        //
        return this.parseOrder(response, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name latoken#cancelOrder
        * @description cancels an open order
        * @see https://api.latoken.com/doc/v2/#tag/Order/operation/cancelOrder
        * @see https://api.latoken.com/doc/v2/#tag/StopOrder/operation/cancelStopOrder  // stop
        * @param {string} id order id
        * @param {string} symbol not used by latoken cancelOrder ()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.trigger] true if cancelling a trigger order
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object isTrigger = this.safeValue2(parameters, "trigger", "stop");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        object response = null;
        if (isTrue(isTrigger))
        {
            response = await this.privatePostAuthStopOrderCancel(this.extend(request, parameters));
        } else
        {
            response = await this.privatePostAuthOrderCancel(this.extend(request, parameters));
        }
        //
        //     {
        //         "id": "12345678-1234-1244-1244-123456789012",
        //         "message": "cancellation request successfully submitted",
        //         "status": "SUCCESS",
        //         "error": "",
        //         "errors": { }
        //     }
        //
        return this.parseOrder(response);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name latoken#cancelAllOrders
        * @description cancel all open orders in a market
        * @see https://api.latoken.com/doc/v2/#tag/Order/operation/cancelAllOrders
        * @see https://api.latoken.com/doc/v2/#tag/Order/operation/cancelAllOrdersByPair
        * @param {string} symbol unified market symbol of the market to cancel orders in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.trigger] true if cancelling trigger orders
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        object isTrigger = this.safeValue2(parameters, "trigger", "stop");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        object response = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["currency"] = getValue(market, "baseId");
            ((IDictionary<string,object>)request)["quote"] = getValue(market, "quoteId");
            if (isTrue(isTrigger))
            {
                response = await this.privatePostAuthStopOrderCancelAllCurrencyQuote(this.extend(request, parameters));
            } else
            {
                response = await this.privatePostAuthOrderCancelAllCurrencyQuote(this.extend(request, parameters));
            }
        } else
        {
            if (isTrue(isTrigger))
            {
                response = await this.privatePostAuthStopOrderCancelAll(this.extend(request, parameters));
            } else
            {
                response = await this.privatePostAuthOrderCancelAll(this.extend(request, parameters));
            }
        }
        //
        //     {
        //         "message":"cancellation request successfully submitted",
        //         "status":"SUCCESS"
        //     }
        //
        return new List<object> {this.safeOrder(new Dictionary<string, object>() {
    { "info", response },
})};
    }

    public async override Task<object> fetchTransactions(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name latoken#fetchTransactions
        * @deprecated
        * @description use fetchDepositsWithdrawals instead
        * @see https://api.latoken.com/doc/v2/#tag/Transaction/operation/getUserTransactions
        * @param {string} code unified currency code for the currency of the transactions, default is undefined
        * @param {int} [since] timestamp in ms of the earliest transaction, default is undefined
        * @param {int} [limit] max number of transactions to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object response = await this.privateGetAuthTransaction(this.extend(request, parameters));
        //
        //     {
        //         "hasNext":false,
        //         "content":[
        //             {
        //                 "id":"fbf7d0d1-2629-4ad8-9def-7a1dba423362",
        //                 "status":"TRANSACTION_STATUS_CONFIRMED",
        //                 "type":"TRANSACTION_TYPE_DEPOSIT",
        //                 "senderAddress":"",
        //                 "recipientAddress":"0x3c46fa2e3f9023bc4897828ed173f8ecb3a554bc",
        //                 "amount":"200.000000000000000000",
        //                 "transactionFee":"0.000000000000000000",
        //                 "timestamp":1635893208404,
        //                 "transactionHash":"0x28bad3b74a042df13d64ddfbca855566a51bf7f190b8cd565c236a18d5cd493f#42",
        //                 "blockHeight":13540262,
        //                 "currency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5",
        //                 "memo":null,
        //                 "paymentProvider":"a8d6d1cb-f84a-4e9d-aa82-c6a08b356ee1",
        //                 "requiresCode":false
        //             }
        //         ],
        //         "first":true,
        //         "hasContent":true,
        //         "pageSize":10
        //     }
        //
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object content = this.safeList(response, "content", new List<object>() {});
        return this.parseTransactions(content, currency, since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        //     {
        //         "id":"fbf7d0d1-2629-4ad8-9def-7a1dba423362",
        //         "status":"TRANSACTION_STATUS_CONFIRMED",
        //         "type":"TRANSACTION_TYPE_DEPOSIT",
        //         "senderAddress":"",
        //         "recipientAddress":"0x3c46fa2e3f9023bc4897828ed173f8ecb3a554bc",
        //         "amount":"200.000000000000000000",
        //         "transactionFee":"0.000000000000000000",
        //         "timestamp":1635893208404,
        //         "transactionHash":"0x28bad3b74a042df13d64ddfbca855566a51bf7f190b8cd565c236a18d5cd493f#42",
        //         "blockHeight":13540262,
        //         "currency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5",
        //         "memo":null,
        //         "paymentProvider":"a8d6d1cb-f84a-4e9d-aa82-c6a08b356ee1",
        //         "requiresCode":false
        //     }
        //
        object id = this.safeString(transaction, "id");
        object timestamp = this.safeInteger(transaction, "timestamp");
        object currencyId = this.safeString(transaction, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        object amount = this.safeNumber(transaction, "amount");
        object addressFrom = this.safeString(transaction, "senderAddress");
        object addressTo = this.safeString(transaction, "recipientAddress");
        object txid = this.safeString(transaction, "transactionHash");
        object tagTo = this.safeString(transaction, "memo");
        object fee = new Dictionary<string, object>() {
            { "currency", null },
            { "cost", null },
            { "rate", null },
        };
        object feeCost = this.safeNumber(transaction, "transactionFee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            ((IDictionary<string,object>)fee)["cost"] = feeCost;
            ((IDictionary<string,object>)fee)["currency"] = code;
        }
        object type = this.parseTransactionType(this.safeString(transaction, "type"));
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", null },
            { "addressFrom", addressFrom },
            { "addressTo", addressTo },
            { "address", addressTo },
            { "tagFrom", null },
            { "tagTo", tagTo },
            { "tag", tagTo },
            { "type", type },
            { "amount", amount },
            { "currency", code },
            { "status", status },
            { "updated", null },
            { "comment", null },
            { "internal", null },
            { "fee", fee },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "TRANSACTION_STATUS_CONFIRMED", "ok" },
            { "TRANSACTION_STATUS_EXECUTED", "ok" },
            { "TRANSACTION_STATUS_CHECKING", "pending" },
            { "TRANSACTION_STATUS_CANCELLED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseTransactionType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "TRANSACTION_TYPE_DEPOSIT", "deposit" },
            { "TRANSACTION_TYPE_WITHDRAWAL", "withdrawal" },
        };
        return this.safeString(types, type, type);
    }

    public async override Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name latoken#fetchTransfers
        * @description fetch a history of internal transfers made on an account
        * @see https://api.latoken.com/doc/v2/#tag/Transfer/operation/getUsersTransfers
        * @param {string} code unified currency code of the currency transferred
        * @param {int} [since] the earliest time in ms to fetch transfers for
        * @param {int} [limit] the maximum number of  transfers structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object response = await this.privateGetAuthTransfer(parameters);
        //
        //     {
        //         "hasNext": true,
        //         "content": [
        //             {
        //             "id": "ebd6312f-cb4f-45d1-9409-4b0b3027f21e",
        //             "status": "TRANSFER_STATUS_COMPLETED",
        //             "type": "TRANSFER_TYPE_WITHDRAW_SPOT",
        //             "fromAccount": "c429c551-adbb-4078-b74b-276bea308a36",
        //             "toAccount": "631c6203-bd62-4734-a04d-9b2a951f43b9",
        //             "transferringFunds": 1259.0321785,
        //             "usdValue": 1259.032179,
        //             "rejectReason": null,
        //             "timestamp": 1633515579530,
        //             "direction": "INTERNAL",
        //             "method": "TRANSFER_METHOD_UNKNOWN",
        //             "recipient": null,
        //             "sender": null,
        //             "currency": "0c3a106d-bde3-4c13-a26e-3fd2394529e5",
        //             "codeRequired": false,
        //             "fromUser": "ce555f3f-585d-46fb-9ae6-487f66738073",
        //             "toUser": "ce555f3f-585d-46fb-9ae6-487f66738073",
        //             "fee": 0
        //             },
        //             ...
        //         ],
        //         "first": true,
        //         "pageSize": 20,
        //         "hasContent": true
        //     }
        //
        object transfers = this.safeList(response, "content", new List<object>() {});
        return this.parseTransfers(transfers, currency, since, limit);
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name latoken#transfer
        * @description transfer currency internally between wallets on the same account
        * @see https://api.latoken.com/doc/v2/#tag/Transfer/operation/transferByEmail
        * @see https://api.latoken.com/doc/v2/#tag/Transfer/operation/transferById
        * @see https://api.latoken.com/doc/v2/#tag/Transfer/operation/transferByPhone
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "recipient", toAccount },
            { "value", this.currencyToPrecision(code, amount) },
        };
        object response = null;
        if (isTrue(isGreaterThanOrEqual(getIndexOf(toAccount, "@"), 0)))
        {
            response = await this.privatePostAuthTransferEmail(this.extend(request, parameters));
        } else if (isTrue(isEqual(((string)toAccount).Length, 36)))
        {
            response = await this.privatePostAuthTransferId(this.extend(request, parameters));
        } else
        {
            response = await this.privatePostAuthTransferPhone(this.extend(request, parameters));
        }
        //
        //     {
        //         "id": "e6fc4ace-7750-44e4-b7e9-6af038ac7107",
        //         "status": "TRANSFER_STATUS_COMPLETED",
        //         "type": "TRANSFER_TYPE_DEPOSIT_SPOT",
        //         "fromAccount": "3bf61015-bf32-47a6-b237-c9f70df772ad",
        //         "toAccount": "355eb279-7c7e-4515-814a-575a49dc0325",
        //         "transferringFunds": "500000.000000000000000000",
        //         "usdValue": "0.000000000000000000",
        //         "rejectReason": "",
        //         "timestamp": 1576844438402,
        //         "direction": "INTERNAL",
        //         "method": "TRANSFER_METHOD_UNKNOWN",
        //         "recipient": "",
        //         "sender": "",
        //         "currency": "40af7879-a8cc-4576-a42d-7d2749821b58",
        //         "codeRequired": false,
        //         "fromUser": "cd555555-666d-46fb-9ae6-487f66738073",
        //         "toUser": "cd555555-666d-46fb-9ae6-487f66738073",
        //         "fee": 0
        //     }
        //
        return this.parseTransfer(response);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        //     {
        //         "id": "e6fc4ace-7750-44e4-b7e9-6af038ac7107",
        //         "status": "TRANSFER_STATUS_COMPLETED",
        //         "type": "TRANSFER_TYPE_DEPOSIT_SPOT",
        //         "fromAccount": "3bf61015-bf32-47a6-b237-c9f70df772ad",
        //         "toAccount": "355eb279-7c7e-4515-814a-575a49dc0325",
        //         "transferringFunds": "500000.000000000000000000",
        //         "usdValue": "0.000000000000000000",
        //         "rejectReason": "",
        //         "timestamp": 1576844438402,
        //         "direction": "INTERNAL",
        //         "method": "TRANSFER_METHOD_UNKNOWN",
        //         "recipient": "",
        //         "sender": "",
        //         "currency": "40af7879-a8cc-4576-a42d-7d2749821b58",
        //         "codeRequired": false,
        //         "fromUser": "cd555555-666d-46fb-9ae6-487f66738073",
        //         "toUser": "cd555555-666d-46fb-9ae6-487f66738073",
        //         "fee": 0
        //     }
        //
        object timestamp = this.safeTimestamp(transfer, "timestamp");
        object currencyId = this.safeString(transfer, "currency");
        object status = this.safeString(transfer, "status");
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", this.safeString(transfer, "id") },
            { "timestamp", this.safeInteger(transfer, "timestamp") },
            { "datetime", this.iso8601(timestamp) },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber(transfer, "transferringFunds") },
            { "fromAccount", this.safeString(transfer, "fromAccount") },
            { "toAccount", this.safeString(transfer, "toAccount") },
            { "status", this.parseTransferStatus(status) },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "TRANSFER_STATUS_COMPLETED", "ok" },
            { "TRANSFER_STATUS_PENDING", "pending" },
            { "TRANSFER_STATUS_REJECTED", "failed" },
            { "TRANSFER_STATUS_UNVERIFIED", "pending" },
            { "TRANSFER_STATUS_CANCELLED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        object request = add(add(add("/", this.version), "/"), this.implodeParams(path, parameters));
        object requestString = request;
        object query = this.omit(parameters, this.extractParams(path));
        object urlencodedQuery = this.urlencode(query);
        if (isTrue(isEqual(method, "GET")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                requestString = add(requestString, add("?", urlencodedQuery));
            }
        }
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object auth = add(add(method, request), urlencodedQuery);
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha512);
            headers = new Dictionary<string, object>() {
                { "X-LA-APIKEY", this.apiKey },
                { "X-LA-SIGNATURE", signature },
                { "X-LA-DIGEST", "HMAC-SHA512" },
            };
            if (isTrue(isEqual(method, "POST")))
            {
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
                body = this.json(query);
            }
        }
        object url = add(getValue(getValue(this.urls, "api"), "rest"), requestString);
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;
        }
        //
        // {"result":false,"message":"invalid API key, signature or digest","error":"BAD_REQUEST","status":"FAILURE"}
        // {"result":false,"message":"request expired or bad <timeAlive>/<timestamp> format","error":"BAD_REQUEST","status":"FAILURE"}
        // {"message":"Internal Server Error","error":"INTERNAL_ERROR","status":"FAILURE"}
        // {"result":false,"message":"Internal error","error":"For input string: \"NaN\"","status":"FAILURE"}
        //
        object message = this.safeString(response, "message");
        object feedback = add(add(this.id, " "), body);
        if (isTrue(!isEqual(message, null)))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
        }
        object error = this.safeValue(response, "error");
        object errorMessage = this.safeString(error, "message");
        if (isTrue(isTrue((!isEqual(error, null))) || isTrue((!isEqual(errorMessage, null)))))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), error, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
