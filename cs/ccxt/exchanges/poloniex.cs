namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class poloniex : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "poloniex" },
            { "name", "Poloniex" },
            { "countries", new List<object>() {"US"} },
            { "rateLimit", 5 },
            { "certified", false },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", null },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createDepositAddress", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "editOrder", true },
                { "fetchBalance", true },
                { "fetchClosedOrder", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingRate", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", false },
                { "fetchOrderTrades", true },
                { "fetchPosition", false },
                { "fetchPositionMode", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", true },
                { "fetchTransactions", "emulated" },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "fetchWithdrawals", true },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "MINUTE_1" },
                { "5m", "MINUTE_5" },
                { "10m", "MINUTE_10" },
                { "15m", "MINUTE_15" },
                { "30m", "MINUTE_30" },
                { "1h", "HOUR_1" },
                { "2h", "HOUR_2" },
                { "4h", "HOUR_4" },
                { "6h", "HOUR_6" },
                { "12h", "HOUR_12" },
                { "1d", "DAY_1" },
                { "3d", "DAY_3" },
                { "1w", "WEEK_1" },
                { "1M", "MONTH_1" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/27766817-e9456312-5ee6-11e7-9b3c-b628ca5626a5.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "rest", "https://api.poloniex.com" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "rest", "https://sand-spot-api-gateway.poloniex.com" },
                } },
                { "www", "https://www.poloniex.com" },
                { "doc", "https://docs.poloniex.com" },
                { "fees", "https://poloniex.com/fees" },
                { "referral", "https://poloniex.com/signup?c=UBFZJRPJ" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "markets", 20 },
                        { "markets/{symbol}", 1 },
                        { "currencies", 20 },
                        { "currencies/{currency}", 20 },
                        { "v2/currencies", 20 },
                        { "v2/currencies/{currency}", 20 },
                        { "timestamp", 1 },
                        { "markets/price", 1 },
                        { "markets/{symbol}/price", 1 },
                        { "markets/markPrice", 1 },
                        { "markets/{symbol}/markPrice", 1 },
                        { "markets/{symbol}/markPriceComponents", 1 },
                        { "markets/{symbol}/orderBook", 1 },
                        { "markets/{symbol}/candles", 1 },
                        { "markets/{symbol}/trades", 20 },
                        { "markets/ticker24h", 20 },
                        { "markets/{symbol}/ticker24h", 20 },
                        { "markets/collateralInfo", 1 },
                        { "markets/{currency}/collateralInfo", 1 },
                        { "markets/borrowRatesInfo", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "accounts", 4 },
                        { "accounts/balances", 4 },
                        { "accounts/{id}/balances", 4 },
                        { "accounts/activity", 20 },
                        { "accounts/transfer", 20 },
                        { "accounts/transfer/{id}", 4 },
                        { "feeinfo", 20 },
                        { "accounts/interest/history", 1 },
                        { "subaccounts", 4 },
                        { "subaccounts/balances", 20 },
                        { "subaccounts/{id}/balances", 4 },
                        { "subaccounts/transfer", 20 },
                        { "subaccounts/transfer/{id}", 4 },
                        { "wallets/addresses", 20 },
                        { "wallets/addresses/{currency}", 20 },
                        { "wallets/activity", 20 },
                        { "margin/accountMargin", 4 },
                        { "margin/borrowStatus", 4 },
                        { "margin/maxSize", 4 },
                        { "orders", 20 },
                        { "orders/{id}", 4 },
                        { "orders/killSwitchStatus", 4 },
                        { "smartorders", 20 },
                        { "smartorders/{id}", 4 },
                        { "orders/history", 20 },
                        { "smartorders/history", 20 },
                        { "trades", 20 },
                        { "orders/{id}/trades", 4 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "accounts/transfer", 4 },
                        { "subaccounts/transfer", 20 },
                        { "wallets/address", 20 },
                        { "wallets/withdraw", 20 },
                        { "v2/wallets/withdraw", 20 },
                        { "orders", 4 },
                        { "orders/batch", 20 },
                        { "orders/killSwitch", 4 },
                        { "smartorders", 4 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "orders/{id}", 4 },
                        { "orders/cancelByIds", 20 },
                        { "orders", 20 },
                        { "smartorders/{id}", 4 },
                        { "smartorders/cancelByIds", 20 },
                        { "smartorders", 20 },
                    } },
                    { "put", new Dictionary<string, object>() {
                        { "orders/{id}", 20 },
                        { "smartorders/{id}", 20 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "feeSide", "get" },
                    { "maker", this.parseNumber("0.0009") },
                    { "taker", this.parseNumber("0.0009") },
                } },
                { "funding", new Dictionary<string, object>() {} },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "AIR", "AirCoin" },
                { "APH", "AphroditeCoin" },
                { "BCC", "BTCtalkcoin" },
                { "BCHABC", "BCHABC" },
                { "BDG", "Badgercoin" },
                { "BTM", "Bitmark" },
                { "CON", "Coino" },
                { "ETHTRON", "ETH" },
                { "GOLD", "GoldEagles" },
                { "GPUC", "GPU" },
                { "HOT", "Hotcoin" },
                { "ITC", "Information Coin" },
                { "KEY", "KEYCoin" },
                { "MASK", "NFTX Hashmasks Index" },
                { "MEME", "Degenerator Meme" },
                { "PLX", "ParallaxCoin" },
                { "REPV2", "REP" },
                { "STR", "XLM" },
                { "SOC", "SOCC" },
                { "TRADE", "Unitrade" },
                { "TRXETH", "TRX" },
                { "XAP", "API Coin" },
                { "USDTBSC", "USDT" },
                { "USDTTRON", "USDT" },
                { "USDTETH", "USDT" },
                { "UST", "USTC" },
            } },
            { "options", new Dictionary<string, object>() {
                { "createMarketBuyOrderRequiresPrice", true },
                { "networks", new Dictionary<string, object>() {
                    { "BEP20", "BSC" },
                    { "ERC20", "ETH" },
                    { "TRC20", "TRON" },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "cost", new Dictionary<string, object>() {
                        { "min", new Dictionary<string, object>() {
                            { "BTC", 0.0001 },
                            { "ETH", 0.0001 },
                            { "USDT", 1 },
                            { "TRX", 100 },
                            { "BNB", 0.06 },
                            { "USDC", 1 },
                            { "USDJ", 1 },
                            { "TUSD", 0.0001 },
                            { "DAI", 1 },
                            { "PAX", 1 },
                            { "BUSD", 1 },
                        } },
                    } },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "spot" },
                    { "future", "futures" },
                } },
                { "accountsById", new Dictionary<string, object>() {
                    { "exchange", "spot" },
                    { "futures", "future" },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "500", typeof(ExchangeNotAvailable) },
                    { "603", typeof(RequestTimeout) },
                    { "601", typeof(BadRequest) },
                    { "415", typeof(ExchangeError) },
                    { "602", typeof(ArgumentsRequired) },
                    { "21604", typeof(BadRequest) },
                    { "21600", typeof(AuthenticationError) },
                    { "21605", typeof(AuthenticationError) },
                    { "21102", typeof(ExchangeError) },
                    { "21100", typeof(AuthenticationError) },
                    { "21704", typeof(AuthenticationError) },
                    { "21700", typeof(BadRequest) },
                    { "21705", typeof(BadRequest) },
                    { "21707", typeof(ExchangeError) },
                    { "21708", typeof(BadRequest) },
                    { "21601", typeof(AccountSuspended) },
                    { "21711", typeof(ExchangeError) },
                    { "21709", typeof(InsufficientFunds) },
                    { "250000", typeof(ExchangeError) },
                    { "250001", typeof(BadRequest) },
                    { "250002", typeof(BadRequest) },
                    { "250003", typeof(BadRequest) },
                    { "250004", typeof(BadRequest) },
                    { "250005", typeof(InsufficientFunds) },
                    { "250008", typeof(BadRequest) },
                    { "250012", typeof(ExchangeError) },
                    { "21110", typeof(BadRequest) },
                    { "10040", typeof(BadSymbol) },
                    { "10060", typeof(ExchangeError) },
                    { "10020", typeof(BadSymbol) },
                    { "10041", typeof(BadSymbol) },
                    { "21340", typeof(OnMaintenance) },
                    { "21341", typeof(InvalidOrder) },
                    { "21342", typeof(InvalidOrder) },
                    { "21343", typeof(InvalidOrder) },
                    { "21351", typeof(AccountSuspended) },
                    { "21352", typeof(BadSymbol) },
                    { "21353", typeof(PermissionDenied) },
                    { "21354", typeof(PermissionDenied) },
                    { "21359", typeof(OrderNotFound) },
                    { "21360", typeof(InvalidOrder) },
                    { "24106", typeof(BadRequest) },
                    { "24201", typeof(ExchangeNotAvailable) },
                    { "21301", typeof(OrderNotFound) },
                    { "21302", typeof(ExchangeError) },
                    { "21304", typeof(ExchangeError) },
                    { "21305", typeof(OrderNotFound) },
                    { "21307", typeof(ExchangeError) },
                    { "21309", typeof(InvalidOrder) },
                    { "21310", typeof(InvalidOrder) },
                    { "21311", typeof(InvalidOrder) },
                    { "21312", typeof(InvalidOrder) },
                    { "21314", typeof(InvalidOrder) },
                    { "21315", typeof(InvalidOrder) },
                    { "21317", typeof(InvalidOrder) },
                    { "21319", typeof(InvalidOrder) },
                    { "21320", typeof(InvalidOrder) },
                    { "21321", typeof(InvalidOrder) },
                    { "21322", typeof(InvalidOrder) },
                    { "21324", typeof(BadRequest) },
                    { "21327", typeof(InvalidOrder) },
                    { "21328", typeof(InvalidOrder) },
                    { "21330", typeof(InvalidOrder) },
                    { "21335", typeof(InvalidOrder) },
                    { "21336", typeof(InvalidOrder) },
                    { "21337", typeof(InvalidOrder) },
                    { "21344", typeof(InvalidOrder) },
                    { "21345", typeof(InvalidOrder) },
                    { "21346", typeof(InvalidOrder) },
                    { "21348", typeof(InvalidOrder) },
                    { "21347", typeof(InvalidOrder) },
                    { "21349", typeof(InvalidOrder) },
                    { "21350", typeof(InvalidOrder) },
                    { "21355", typeof(ExchangeError) },
                    { "21356", typeof(BadRequest) },
                    { "24101", typeof(BadSymbol) },
                    { "24102", typeof(InvalidOrder) },
                    { "24103", typeof(InvalidOrder) },
                    { "24104", typeof(InvalidOrder) },
                    { "24105", typeof(InvalidOrder) },
                    { "25020", typeof(InvalidOrder) },
                    { "25000", typeof(InvalidOrder) },
                    { "25001", typeof(InvalidOrder) },
                    { "25002", typeof(InvalidOrder) },
                    { "25003", typeof(ExchangeError) },
                    { "25004", typeof(InvalidOrder) },
                    { "25005", typeof(ExchangeError) },
                    { "25006", typeof(InvalidOrder) },
                    { "25007", typeof(InvalidOrder) },
                    { "25008", typeof(InvalidOrder) },
                    { "25009", typeof(ExchangeError) },
                    { "25010", typeof(PermissionDenied) },
                    { "25011", typeof(InvalidOrder) },
                    { "25012", typeof(ExchangeError) },
                    { "25013", typeof(OrderNotFound) },
                    { "25014", typeof(OrderNotFound) },
                    { "25015", typeof(OrderNotFound) },
                    { "25016", typeof(ExchangeError) },
                    { "25017", typeof(ExchangeError) },
                    { "25018", typeof(BadRequest) },
                    { "25019", typeof(BadSymbol) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
        });
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         [
        //             "22814.01",
        //             "22937.42",
        //             "22832.57",
        //             "22937.42",
        //             "3916.58764051",
        //             "0.171199",
        //             "2982.64647063",
        //             "0.130295",
        //             33,
        //             0,
        //             "22877.449915304470460711",
        //             "MINUTE_5",
        //             1659664800000,
        //             1659665099999
        //         ]
        //     ]
        //
        return new List<object> {this.safeInteger(ohlcv, 12), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 0), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 5)};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://docs.poloniex.com/#public-endpoints-market-data-candles
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp in ms
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate", false);
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, 500);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "interval", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            // limit should in between 100 and 500
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.publicGetMarketsSymbolCandles(this.extend(request, parameters));
        //
        //     [
        //         [
        //             "22814.01",
        //             "22937.42",
        //             "22832.57",
        //             "22937.42",
        //             "3916.58764051",
        //             "0.171199",
        //             "2982.64647063",
        //             "0.130295",
        //             33,
        //             0,
        //             "22877.449915304470460711",
        //             "MINUTE_5",
        //             1659664800000,
        //             1659665099999
        //         ]
        //     ]
        //
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    public async override Task<object> loadMarkets(object reload = null, object parameters = null)
    {
        reload ??= false;
        parameters ??= new Dictionary<string, object>();
        object markets = await base.loadMarkets(reload, parameters);
        object currenciesByNumericId = this.safeValue(this.options, "currenciesByNumericId");
        if (isTrue(isTrue((isEqual(currenciesByNumericId, null))) || isTrue(reload)))
        {
            ((IDictionary<string,object>)this.options)["currenciesByNumericId"] = this.indexBy(this.currencies, "numericId");
        }
        return markets;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name poloniex#fetchMarkets
        * @description retrieves data on all markets for poloniex
        * @see https://docs.poloniex.com/#public-endpoints-reference-data-symbol-information
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object markets = await this.publicGetMarkets(parameters);
        //
        //     [
        //         {
        //             "symbol" : "BTS_BTC",
        //             "baseCurrencyName" : "BTS",
        //             "quoteCurrencyName" : "BTC",
        //             "displayName" : "BTS/BTC",
        //             "state" : "NORMAL",
        //             "visibleStartTime" : 1659018816626,
        //             "tradableStartTime" : 1659018816626,
        //             "symbolTradeLimit" : {
        //                 "symbol" : "BTS_BTC",
        //                 "priceScale" : 10,
        //                 "quantityScale" : 0,
        //                 "amountScale" : 8,
        //                 "minQuantity" : "100",
        //                 "minAmount" : "0.00001",
        //                 "highestBid" : "0",
        //                 "lowestAsk" : "0"
        //             }
        //         }
        //     ]
        //
        return this.parseMarkets(markets);
    }

    public override object parseMarket(object market)
    {
        object id = this.safeString(market, "symbol");
        object baseId = this.safeString(market, "baseCurrencyName");
        object quoteId = this.safeString(market, "quoteCurrencyName");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object state = this.safeString(market, "state");
        object active = isEqual(state, "NORMAL");
        object symbolTradeLimit = this.safeValue(market, "symbolTradeLimit");
        // these are known defaults
        return new Dictionary<string, object>() {
            { "id", id },
            { "symbol", add(add(bs, "/"), quote) },
            { "base", bs },
            { "quote", quote },
            { "settle", null },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", null },
            { "type", "spot" },
            { "spot", true },
            { "margin", false },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "active", active },
            { "contract", false },
            { "linear", null },
            { "inverse", null },
            { "contractSize", null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.parseNumber(this.parsePrecision(this.safeString(symbolTradeLimit, "quantityScale"))) },
                { "price", this.parseNumber(this.parsePrecision(this.safeString(symbolTradeLimit, "priceScale"))) },
            } },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(symbolTradeLimit, "minQuantity") },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", this.safeNumber(symbolTradeLimit, "minAmount") },
                    { "max", null },
                } },
            } },
            { "created", this.safeInteger(market, "tradableStartTime") },
            { "info", market },
        };
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name poloniex#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @see https://docs.poloniex.com/#public-endpoints-reference-data-system-timestamp
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetTimestamp(parameters);
        return this.safeInteger(response, "serverTime");
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "symbol" : "BTC_USDT",
        //         "open" : "26053.33",
        //         "low" : "26053.33",
        //         "high" : "26798.02",
        //         "close" : "26447.58",
        //         "quantity" : "6116.210188",
        //         "amount" : "161082122.88450926",
        //         "tradeCount" : "134709",
        //         "startTime" : "1692784440000",
        //         "closeTime" : "1692870839630",
        //         "displayName" : "BTC/USDT",
        //         "dailyChange" : "0.0151",
        //         "bid" : "26447.57",
        //         "bidQuantity" : "0.016313",
        //         "ask" : "26447.58",
        //         "askQuantity" : "0.068307",
        //         "ts" : "1692870845446",
        //         "markPrice" : "26444.11"
        //     }
        //
        object timestamp = this.safeInteger(ticker, "ts");
        object marketId = this.safeString(ticker, "symbol");
        market = this.safeMarket(marketId);
        object close = this.safeString(ticker, "close");
        object relativeChange = this.safeString(ticker, "dailyChange");
        object percentage = Precise.stringMul(relativeChange, "100");
        object bidVolume = this.safeString(ticker, "bidQuantity");
        object askVolume = this.safeString(ticker, "askQuantity");
        return this.safeTicker(new Dictionary<string, object>() {
            { "id", marketId },
            { "symbol", getValue(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(ticker, "bid") },
            { "bidVolume", bidVolume },
            { "ask", this.safeString(ticker, "ask") },
            { "askVolume", askVolume },
            { "vwap", null },
            { "open", this.safeString(ticker, "open") },
            { "close", close },
            { "last", close },
            { "previousClose", null },
            { "change", null },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "quantity") },
            { "quoteVolume", this.safeString(ticker, "amount") },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://docs.poloniex.com/#public-endpoints-market-data-ticker
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.publicGetMarketsTicker24h(parameters);
        //
        //     [
        //         {
        //              "symbol" : "BTC_USDT",
        //              "open" : "26053.33",
        //              "low" : "26053.33",
        //              "high" : "26798.02",
        //              "close" : "26447.58",
        //              "quantity" : "6116.210188",
        //              "amount" : "161082122.88450926",
        //              "tradeCount" : "134709",
        //              "startTime" : "1692784440000",
        //              "closeTime" : "1692870839630",
        //              "displayName" : "BTC/USDT",
        //              "dailyChange" : "0.0151",
        //              "bid" : "26447.57",
        //              "bidQuantity" : "0.016313",
        //              "ask" : "26447.58",
        //              "askQuantity" : "0.068307",
        //              "ts" : "1692870845446",
        //              "markPrice" : "26444.11"
        //         }
        //     ]
        //
        return this.parseTickers(response, symbols);
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name poloniex#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://docs.poloniex.com/#public-endpoints-reference-data-currency-information
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetCurrencies(this.extend(parameters, new Dictionary<string, object>() {
            { "includeMultiChainCurrencies", true },
        }));
        //
        //     [
        //         {
        //             "1CR": {
        //                 "id": 1,
        //                 "name": "1CRedit",
        //                 "description": "BTC Clone",
        //                 "type": "address",
        //                 "withdrawalFee": "0.01000000",
        //                 "minConf": 10000,
        //                 "depositAddress": null,
        //                 "blockchain": "1CR",
        //                 "delisted": false,
        //                 "tradingState": "NORMAL",
        //                 "walletState": "DISABLED",
        //                 "walletDepositState": "DISABLED",
        //                 "walletWithdrawalState": "DISABLED",
        //                 "parentChain": null,
        //                 "isMultiChain": false,
        //                 "isChildChain": false,
        //                 "childChains": []
        //             }
        //         }
        //     ]
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object item = this.safeValue(response, i);
            object ids = new List<object>(((IDictionary<string,object>)item).Keys);
            object id = this.safeValue(ids, 0);
            object currency = this.safeValue(item, id);
            object code = this.safeCurrencyCode(id);
            object name = this.safeString(currency, "name");
            object networkId = this.safeString(currency, "blockchain");
            object networkCode = null;
            if (isTrue(!isEqual(networkId, null)))
            {
                networkCode = this.networkIdToCode(networkId, code);
            }
            object delisted = this.safeValue(currency, "delisted");
            object walletEnabled = isEqual(this.safeString(currency, "walletState"), "ENABLED");
            object depositEnabled = isEqual(this.safeString(currency, "walletDepositState"), "ENABLED");
            object withdrawEnabled = isEqual(this.safeString(currency, "walletWithdrawalState"), "ENABLED");
            object active = isTrue(isTrue(!isTrue(delisted) && isTrue(walletEnabled)) && isTrue(depositEnabled)) && isTrue(withdrawEnabled);
            object numericId = this.safeInteger(currency, "id");
            object feeString = this.safeString(currency, "withdrawalFee");
            object parentChain = this.safeValue(currency, "parentChain");
            object noParentChain = isEqual(parentChain, null);
            if (isTrue(isEqual(this.safeValue(result, code), null)))
            {
                ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                    { "id", id },
                    { "code", code },
                    { "info", null },
                    { "name", name },
                    { "active", active },
                    { "deposit", depositEnabled },
                    { "withdraw", withdrawEnabled },
                    { "fee", this.parseNumber(feeString) },
                    { "precision", null },
                    { "limits", new Dictionary<string, object>() {
                        { "amount", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                    } },
                };
            }
            object minFeeString = this.safeString(getValue(result, code), "fee");
            if (isTrue(!isEqual(feeString, null)))
            {
                minFeeString = ((bool) isTrue((isEqual(minFeeString, null)))) ? feeString : Precise.stringMin(feeString, minFeeString);
            }
            object depositAvailable = this.safeValue(getValue(result, code), "deposit");
            depositAvailable = ((bool) isTrue((depositEnabled))) ? depositEnabled : depositAvailable;
            object withdrawAvailable = this.safeValue(getValue(result, code), "withdraw");
            withdrawAvailable = ((bool) isTrue((withdrawEnabled))) ? withdrawEnabled : withdrawAvailable;
            object networks = this.safeValue(getValue(result, code), "networks", new Dictionary<string, object>() {});
            if (isTrue(!isEqual(networkCode, null)))
            {
                ((IDictionary<string,object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                    { "info", currency },
                    { "id", networkId },
                    { "network", networkCode },
                    { "currencyId", id },
                    { "numericId", numericId },
                    { "deposit", depositEnabled },
                    { "withdraw", withdrawEnabled },
                    { "active", active },
                    { "fee", this.parseNumber(feeString) },
                    { "precision", null },
                    { "limits", new Dictionary<string, object>() {
                        { "amount", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                    } },
                };
            }
            ((IDictionary<string,object>)getValue(result, code))["networks"] = networks;
            object info = this.safeValue(getValue(result, code), "info", new List<object>() {});
            object rawInfo = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)rawInfo)[(string)id] = currency;
            ((IList<object>)info).Add(rawInfo);
            ((IDictionary<string,object>)getValue(result, code))["info"] = info;
            if (isTrue(noParentChain))
            {
                ((IDictionary<string,object>)getValue(result, code))["id"] = id;
                ((IDictionary<string,object>)getValue(result, code))["name"] = name;
            }
            ((IDictionary<string,object>)getValue(result, code))["active"] = isTrue(depositAvailable) && isTrue(withdrawAvailable);
            ((IDictionary<string,object>)getValue(result, code))["deposit"] = depositAvailable;
            ((IDictionary<string,object>)getValue(result, code))["withdraw"] = withdrawAvailable;
            ((IDictionary<string,object>)getValue(result, code))["fee"] = this.parseNumber(minFeeString);
        }
        return result;
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://docs.poloniex.com/#public-endpoints-market-data-ticker
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetMarketsSymbolTicker24h(this.extend(request, parameters));
        //
        //     {
        //         "symbol" : "BTC_USDT",
        //         "open" : "26053.33",
        //         "low" : "26053.33",
        //         "high" : "26798.02",
        //         "close" : "26447.58",
        //         "quantity" : "6116.210188",
        //         "amount" : "161082122.88450926",
        //         "tradeCount" : "134709",
        //         "startTime" : "1692784440000",
        //         "closeTime" : "1692870839630",
        //         "displayName" : "BTC/USDT",
        //         "dailyChange" : "0.0151",
        //         "bid" : "26447.57",
        //         "bidQuantity" : "0.016313",
        //         "ask" : "26447.58",
        //         "askQuantity" : "0.068307",
        //         "ts" : "1692870845446",
        //         "markPrice" : "26444.11"
        //     }
        //
        return this.parseTicker(response, market);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades
        //
        //     {
        //         "id" : "60014521",
        //         "price" : "23162.94",
        //         "quantity" : "0.00009",
        //         "amount" : "2.0846646",
        //         "takerSide" : "SELL",
        //         "ts" : 1659684602042,
        //         "createTime" : 1659684602036
        //     }
        //
        // fetchMyTrades
        //
        //     {
        //         "id": "32164924331503616",
        //         "symbol": "LINK_USDT",
        //         "accountType": "SPOT",
        //         "orderId": "32164923987566592",
        //         "side": "SELL",
        //         "type": "MARKET",
        //         "matchRole": "TAKER",
        //         "createTime": 1648635115525,
        //         "price": "11",
        //         "quantity": "0.5",
        //         "amount": "5.5",
        //         "feeCurrency": "USDT",
        //         "feeAmount": "0.007975",
        //         "pageId": "32164924331503616",
        //         "clientOrderId": "myOwnId-321"
        //     }
        //
        // fetchOrderTrades (taker trades)
        //
        //     {
        //         "id": "30341456333942784",
        //         "symbol": "LINK_USDT",
        //         "accountType": "SPOT",
        //         "orderId": "30249408733945856",
        //         "side": "BUY",
        //         "type": "LIMIT",
        //         "matchRole": "MAKER",
        //         "createTime": 1648200366864,
        //         "price": "3.1",
        //         "quantity": "1",
        //         "amount": "3.1",
        //         "feeCurrency": "LINK",
        //         "feeAmount": "0.00145",
        //         "pageId": "30341456333942784",
        //         "clientOrderId": ""
        //     }
        //
        //
        object id = this.safeString2(trade, "id", "tradeID");
        object orderId = this.safeString(trade, "orderId");
        object timestamp = this.safeInteger2(trade, "ts", "createTime");
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market, "_");
        object symbol = getValue(market, "symbol");
        object side = this.safeStringLower2(trade, "side", "takerSide");
        object fee = null;
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString(trade, "quantity");
        object costString = this.safeString(trade, "amount");
        object feeCurrencyId = this.safeString(trade, "feeCurrency");
        object feeCostString = this.safeString(trade, "feeAmount");
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", feeCurrencyCode },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "order", orderId },
            { "type", this.safeStringLower(trade, "type") },
            { "side", side },
            { "takerOrMaker", this.safeStringLower(trade, "matchRole") },
            { "price", priceString },
            { "amount", amountString },
            { "cost", costString },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://docs.poloniex.com/#public-endpoints-market-data-trades
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object trades = await this.publicGetMarketsSymbolTrades(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "id" : "60014521",
        //             "price" : "23162.94",
        //             "quantity" : "0.00009",
        //             "amount" : "2.0846646",
        //             "takerSide" : "SELL",
        //             "ts" : 1659684602042,
        //             "createTime" : 1659684602036
        //         }
        //     ]
        //
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://docs.poloniex.com/#authenticated-endpoints-trades-trade-history
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch entries for
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, parameters);
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateGetTrades(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "id": "32164924331503616",
        //             "symbol": "LINK_USDT",
        //             "accountType": "SPOT",
        //             "orderId": "32164923987566592",
        //             "side": "SELL",
        //             "type": "MARKET",
        //             "matchRole": "TAKER",
        //             "createTime": 1648635115525,
        //             "price": "11",
        //             "quantity": "0.5",
        //             "amount": "5.5",
        //             "feeCurrency": "USDT",
        //             "feeAmount": "0.007975",
        //             "pageId": "32164924331503616",
        //             "clientOrderId": "myOwnId-321"
        //         }
        //     ]
        //
        object result = this.parseTrades(response, market, since, limit);
        return result;
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "open" },
            { "PARTIALLY_FILLED", "open" },
            { "FILLED", "closed" },
            { "PENDING_CANCEL", "canceled" },
            { "PARTIALLY_CANCELED", "canceled" },
            { "CANCELED", "canceled" },
            { "FAILED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // fetchOpenOrder
        //
        //     {
        //         "id" : "7xxxxxxxxxxxxxxx6",
        //         "clientOrderId" : "",
        //         "symbol" : "ETH_USDT",
        //         "state" : "NEW",
        //         "accountType" : "SPOT",
        //         "side" : "BUY",
        //         "type" : "LIMIT",
        //         "timeInForce" : "GTC",
        //         "quantity" : "0.001",
        //         "price" : "1600",
        //         "avgPrice" : "0",
        //         "amount" : "0",
        //         "filledQuantity" : "0",
        //         "filledAmount" : "0",
        //         "createTime" : 16xxxxxxxxx26,
        //         "updateTime" : 16xxxxxxxxx36
        //     }
        //
        // fetchOpenOrders
        //
        //     {
        //         "id": "24993088082542592",
        //         "clientOrderId": "",
        //         "symbol": "ELON_USDC",
        //         "state": "NEW",
        //         "accountType": "SPOT",
        //         "side": "SELL",
        //         "type": "MARKET",
        //         "timeInForce": "GTC",
        //         "quantity": "1.00",
        //         "price": "0.00",
        //         "avgPrice": "0.00",
        //         "amount": "0.00",
        //         "filledQuantity": "0.00",
        //         "filledAmount": "0.00",
        //         "createTime": 1646925216548,
        //         "updateTime": 1646925216548
        //     }
        //
        // createOrder, editOrder
        //
        //     {
        //         "id": "29772698821328896",
        //         "clientOrderId": "1234Abc"
        //     }
        //
        object timestamp = this.safeInteger2(order, "timestamp", "createTime");
        if (isTrue(isEqual(timestamp, null)))
        {
            timestamp = this.parse8601(this.safeString(order, "date"));
        }
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market, "_");
        object symbol = getValue(market, "symbol");
        object resultingTrades = this.safeValue(order, "resultingTrades");
        if (!isTrue(((resultingTrades is IList<object>) || (resultingTrades.GetType().IsGenericType && resultingTrades.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            resultingTrades = this.safeValue(resultingTrades, this.safeString(market, "id", marketId));
        }
        object price = this.safeString2(order, "price", "rate");
        object amount = this.safeString(order, "quantity");
        object filled = this.safeString(order, "filledQuantity");
        object status = this.parseOrderStatus(this.safeString(order, "state"));
        object side = this.safeStringLower(order, "side");
        object rawType = this.safeString(order, "type");
        object type = this.parseOrderType(rawType);
        object id = this.safeStringN(order, new List<object>() {"orderNumber", "id", "orderId"});
        object fee = null;
        object feeCurrency = this.safeString(order, "tokenFeeCurrency");
        object feeCost = null;
        object feeCurrencyCode = null;
        object rate = this.safeString(order, "fee");
        if (isTrue(isEqual(feeCurrency, null)))
        {
            feeCurrencyCode = ((bool) isTrue((isEqual(side, "buy")))) ? getValue(market, "base") : getValue(market, "quote");
        } else
        {
            // poloniex accepts a 30% discount to pay fees in TRX
            feeCurrencyCode = this.safeCurrencyCode(feeCurrency);
            feeCost = this.safeString(order, "tokenFee");
        }
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "rate", rate },
                { "cost", feeCost },
                { "currency", feeCurrencyCode },
            };
        }
        object clientOrderId = this.safeString(order, "clientOrderId");
        object triggerPrice = this.safeString2(order, "triggerPrice", "stopPrice");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", this.safeInteger(order, "updateTime") },
            { "status", status },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", this.safeString(order, "timeInForce") },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", triggerPrice },
            { "triggerPrice", triggerPrice },
            { "cost", null },
            { "average", this.safeString(order, "avgPrice") },
            { "amount", amount },
            { "filled", filled },
            { "remaining", null },
            { "trades", resultingTrades },
            { "fee", fee },
        }, market);
    }

    public virtual object parseOrderType(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "MARKET", "market" },
            { "LIMIT", "limit" },
            { "STOP-LIMIT", "limit" },
            { "STOP-MARKET", "market" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOpenOrders(object orders, object market, object result)
    {
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object order = getValue(orders, i);
            object extended = this.extend(order, new Dictionary<string, object>() {
                { "status", "open" },
                { "type", "limit" },
                { "side", getValue(order, "type") },
                { "price", getValue(order, "rate") },
            });
            ((IList<object>)result).Add(this.parseOrder(extended, market));
        }
        return result;
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://docs.poloniex.com/#authenticated-endpoints-orders-open-orders
        * @see https://docs.poloniex.com/#authenticated-endpoints-smart-orders-open-orders  // trigger orders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.stop] set true to fetch trigger orders instead of regular orders
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object isTrigger = this.safeValue2(parameters, "trigger", "stop");
        parameters = this.omit(parameters, new List<object>() {"trigger", "stop"});
        object response = null;
        if (isTrue(isTrigger))
        {
            response = await this.privateGetSmartorders(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetOrders(this.extend(request, parameters));
        }
        //
        //     [
        //         {
        //             "id" : "7xxxxxxxxxxxxxxx6",
        //             "clientOrderId" : "",
        //             "symbol" : "ETH_USDT",
        //             "state" : "NEW",
        //             "accountType" : "SPOT",
        //             "side" : "BUY",
        //             "type" : "LIMIT",
        //             "timeInForce" : "GTC",
        //             "quantity" : "0.001",
        //             "price" : "1600",
        //             "avgPrice" : "0",
        //             "amount" : "0",
        //             "filledQuantity" : "0",
        //             "filledAmount" : "0",
        //             "stopPrice": "3750.00",              // for trigger orders
        //             "createTime" : 16xxxxxxxxx26,
        //             "updateTime" : 16xxxxxxxxx36
        //         }
        //     ]
        //
        object extension = new Dictionary<string, object>() {
            { "status", "open" },
        };
        return this.parseOrders(response, market, since, limit, extension);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#createOrder
        * @description create a trade order
        * @see https://docs.poloniex.com/#authenticated-endpoints-orders-create-order
        * @see https://docs.poloniex.com/#authenticated-endpoints-smart-orders-create-order  // trigger orders
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.triggerPrice] *spot only* The price at which a trigger order is triggered at
        * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " createOrder() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", side },
        };
        object triggerPrice = this.safeNumber2(parameters, "stopPrice", "triggerPrice");
        var requestparametersVariable = this.orderRequest(symbol, type, side, amount, request, price, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = null;
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            response = await this.privatePostSmartorders(this.extend(request, parameters));
        } else
        {
            response = await this.privatePostOrders(this.extend(request, parameters));
        }
        //
        //     {
        //         "id" : "78923648051920896",
        //         "clientOrderId" : ""
        //     }
        //
        response = this.extend(response, new Dictionary<string, object>() {
            { "type", side },
        });
        return this.parseOrder(response, market);
    }

    public virtual object orderRequest(object symbol, object type, object side, object amount, object request, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object upperCaseType = ((string)type).ToUpper();
        object isMarket = isEqual(upperCaseType, "MARKET");
        object isPostOnly = this.isPostOnly(isMarket, isEqual(upperCaseType, "LIMIT_MAKER"), parameters);
        object triggerPrice = this.safeNumber2(parameters, "stopPrice", "triggerPrice");
        parameters = this.omit(parameters, new List<object>() {"postOnly", "triggerPrice", "stopPrice"});
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            upperCaseType = ((bool) isTrue((isEqual(price, null)))) ? "STOP" : "STOP_LIMIT";
            ((IDictionary<string,object>)request)["stopPrice"] = triggerPrice;
        } else if (isTrue(isPostOnly))
        {
            upperCaseType = "LIMIT_MAKER";
        }
        ((IDictionary<string,object>)request)["type"] = upperCaseType;
        if (isTrue(isMarket))
        {
            if (isTrue(isEqual(side, "buy")))
            {
                object quoteAmount = null;
                object createMarketBuyOrderRequiresPrice = true;
                var createMarketBuyOrderRequiresPriceparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                createMarketBuyOrderRequiresPrice = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[0];
                parameters = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[1];
                object cost = this.safeNumber(parameters, "cost");
                parameters = this.omit(parameters, "cost");
                if (isTrue(!isEqual(cost, null)))
                {
                    quoteAmount = this.costToPrecision(symbol, cost);
                } else if (isTrue(createMarketBuyOrderRequiresPrice))
                {
                    if (isTrue(isEqual(price, null)))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument")) ;
                    } else
                    {
                        object amountString = this.numberToString(amount);
                        object priceString = this.numberToString(price);
                        object costRequest = Precise.stringMul(amountString, priceString);
                        quoteAmount = this.costToPrecision(symbol, costRequest);
                    }
                } else
                {
                    quoteAmount = this.costToPrecision(symbol, amount);
                }
                ((IDictionary<string,object>)request)["amount"] = quoteAmount;
            } else
            {
                ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
            }
        } else
        {
            ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientOrderId"] = clientOrderId;
            parameters = this.omit(parameters, "clientOrderId");
        }
        // remember the timestamp before issuing the request
        return new List<object>() {request, parameters};
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#editOrder
        * @description edit a trade order
        * @see https://docs.poloniex.com/#authenticated-endpoints-orders-cancel-replace-order
        * @see https://docs.poloniex.com/#authenticated-endpoints-smart-orders-cancel-replace-order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} [amount] how much of the currency you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " editOrder() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object triggerPrice = this.safeNumber2(parameters, "stopPrice", "triggerPrice");
        var requestparametersVariable = this.orderRequest(symbol, type, side, amount, request, price, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = null;
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            response = await this.privatePutSmartordersId(this.extend(request, parameters));
        } else
        {
            response = await this.privatePutOrdersId(this.extend(request, parameters));
        }
        //
        //     {
        //         "id" : "78923648051920896",
        //         "clientOrderId" : ""
        //     }
        //
        response = this.extend(response, new Dictionary<string, object>() {
            { "type", side },
        });
        return this.parseOrder(response, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        //
        // @method
        // @name poloniex#cancelOrder
        // @description cancels an open order
        // @see https://docs.poloniex.com/#authenticated-endpoints-orders-cancel-order-by-id
        // @see https://docs.poloniex.com/#authenticated-endpoints-smart-orders-cancel-order-by-id  // trigger orders
        // @param {string} id order id
        // @param {string} symbol unified symbol of the market the order was made in
        // @param {object} [params] extra parameters specific to the exchange API endpoint
        // @param {boolean} [params.trigger] true if canceling a trigger order
        // @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        //
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeValue(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            id = clientOrderId;
        }
        ((IDictionary<string,object>)request)["id"] = id;
        object isTrigger = this.safeValue2(parameters, "trigger", "stop");
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "trigger", "stop"});
        object response = null;
        if (isTrue(isTrigger))
        {
            response = await this.privateDeleteSmartordersId(this.extend(request, parameters));
        } else
        {
            response = await this.privateDeleteOrdersId(this.extend(request, parameters));
        }
        //
        //   {
        //       "orderId":"210832697138888704",
        //       "clientOrderId":"",
        //       "state":"PENDING_CANCEL",
        //       "code":200,
        //       "message":""
        //   }
        //
        return this.parseOrder(response);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#cancelAllOrders
        * @description cancel all open orders
        * @see https://docs.poloniex.com/#authenticated-endpoints-orders-cancel-all-orders
        * @see https://docs.poloniex.com/#authenticated-endpoints-smart-orders-cancel-all-orders  // trigger orders
        * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.trigger] true if canceling trigger orders
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "symbols", new List<object>() {} },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbols"] = new List<object>() {getValue(market, "id")};
        }
        object isTrigger = this.safeValue2(parameters, "trigger", "stop");
        parameters = this.omit(parameters, new List<object>() {"trigger", "stop"});
        object response = null;
        if (isTrue(isTrigger))
        {
            response = await this.privateDeleteSmartorders(this.extend(request, parameters));
        } else
        {
            response = await this.privateDeleteOrders(this.extend(request, parameters));
        }
        //
        //     [
        //         {
        //             "orderId" : "78xxxxxxxx80",
        //             "clientOrderId" : "",
        //             "state" : "NEW",
        //             "code" : 200,
        //             "message" : ""
        //         }, {
        //             "orderId" : "78xxxxxxxxx80",
        //             "clientOrderId" : "",
        //             "state" : "NEW",
        //             "code" : 200,
        //             "message" : ""
        //         }
        //     ]
        //
        return this.parseOrders(response, market);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#fetchOrder
        * @description fetch an order by it's id
        * @see https://docs.poloniex.com/#authenticated-endpoints-orders-order-details
        * @see https://docs.poloniex.com/#authenticated-endpoints-smart-orders-open-orders  // trigger orders
        * @param {string} id order id
        * @param {string} symbol unified market symbol, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.trigger] true if fetching a trigger order
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        id = ((object)id).ToString();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object isTrigger = this.safeValue2(parameters, "trigger", "stop");
        parameters = this.omit(parameters, new List<object>() {"trigger", "stop"});
        object response = null;
        if (isTrue(isTrigger))
        {
            response = await this.privateGetSmartordersId(this.extend(request, parameters));
            response = this.safeValue(response, 0);
        } else
        {
            response = await this.privateGetOrdersId(this.extend(request, parameters));
        }
        //
        //     {
        //         "id": "21934611974062080",
        //         "clientOrderId": "123",
        //         "symbol": "TRX_USDC",
        //         "state": "NEW",
        //         "accountType": "SPOT",
        //         "side": "SELL",
        //         "type": "LIMIT",
        //         "timeInForce": "GTC",
        //         "quantity": "1.00",
        //         "price": "10.00",
        //         "avgPrice": "0.00",
        //         "amount": "0.00",
        //         "filledQuantity": "0.00",
        //         "filledAmount": "0.00",
        //         "stopPrice": "3750.00",              // for trigger orders
        //         "createTime": 1646196019020,
        //         "updateTime": 1646196019020
        //     }
        //
        object order = this.parseOrder(response);
        ((IDictionary<string,object>)order)["id"] = id;
        return order;
    }

    public async override Task<object> fetchOrderStatus(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orders = await this.fetchOpenOrders(symbol, null, null, parameters);
        object indexed = this.indexBy(orders, "id");
        return ((bool) isTrue((inOp(indexed, id)))) ? "open" : "closed";
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @see https://docs.poloniex.com/#authenticated-endpoints-trades-trades-by-order-id
        * @param {string} id order id
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object trades = await this.privateGetOrdersIdTrades(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "id": "30341456333942784",
        //             "symbol": "LINK_USDT",
        //             "accountType": "SPOT",
        //             "orderId": "30249408733945856",
        //             "side": "BUY",
        //             "type": "LIMIT",
        //             "matchRole": "MAKER",
        //             "createTime": 1648200366864,
        //             "price": "3.1",
        //             "quantity": "1",
        //             "amount": "3.1",
        //             "feeCurrency": "LINK",
        //             "feeAmount": "0.00145",
        //             "pageId": "30341456333942784",
        //             "clientOrderId": ""
        //         }
        //     ]
        //
        return this.parseTrades(trades);
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object account = this.safeValue(response, i, new Dictionary<string, object>() {});
            object balances = this.safeValue(account, "balances");
            for (object j = 0; isLessThan(j, getArrayLength(balances)); postFixIncrement(ref j))
            {
                object balance = this.safeValue(balances, j);
                object currencyId = this.safeString(balance, "currency");
                object code = this.safeCurrencyCode(currencyId);
                object newAccount = this.account();
                ((IDictionary<string,object>)newAccount)["free"] = this.safeString(balance, "available");
                ((IDictionary<string,object>)newAccount)["used"] = this.safeString(balance, "hold");
                ((IDictionary<string,object>)result)[(string)code] = newAccount;
            }
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name poloniex#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://docs.poloniex.com/#authenticated-endpoints-accounts-all-account-balances
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "accountType", "SPOT" },
        };
        object response = await this.privateGetAccountsBalances(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "accountId" : "7xxxxxxxxxx8",
        //             "accountType" : "SPOT",
        //             "balances" : [
        //                 {
        //                     "currencyId" : "214",
        //                     "currency" : "USDT",
        //                     "available" : "2.00",
        //                     "hold" : "0.00"
        //                 }
        //             ]
        //         }
        //     ]
        //
        return this.parseBalance(response);
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name poloniex#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @see https://docs.poloniex.com/#authenticated-endpoints-accounts-fee-info
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetFeeinfo(parameters);
        //
        //     {
        //         "trxDiscount" : false,
        //         "makerRate" : "0.00145",
        //         "takerRate" : "0.00155",
        //         "volume30D" : "0.00"
        //     }
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(this.symbols, i);
            ((IDictionary<string,object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "info", response },
                { "symbol", symbol },
                { "maker", this.safeNumber(response, "makerRate") },
                { "taker", this.safeNumber(response, "takerRate") },
                { "percentage", true },
                { "tierBased", true },
            };
        }
        return result;
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://docs.poloniex.com/#public-endpoints-market-data-order-book
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // The default value of limit is 10. Valid limit values are: 5, 10, 20, 50, 100, 150.
        }
        object response = await this.publicGetMarketsSymbolOrderBook(this.extend(request, parameters));
        //
        //     {
        //         "time" : 1659695219507,
        //         "scale" : "-1",
        //         "asks" : [ "23139.82", "0.317981", "23140", "0.191091", "23170.06", "0.01", "23200", "0.107758", "23230.55", "0.01", "23247.2", "0.154", "23254", "0.005121", "23263", "0.038", "23285.4", "0.308", "23300", "0.108896" ],
        //         "bids" : [ "23139.74", "0.432092", "23139.73", "0.198592", "23123.21", "0.000886", "23123.2", "0.308", "23121.4", "0.154", "23105", "0.000789", "23100", "0.078175", "23069.1", "0.026276", "23068.83", "0.001329", "23051", "0.000048" ],
        //         "ts" : 1659695219513
        //     }
        //
        object timestamp = this.safeInteger(response, "time");
        object asks = this.safeValue(response, "asks");
        object bids = this.safeValue(response, "bids");
        object asksResult = new List<object>() {};
        object bidsResult = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(asks)); postFixIncrement(ref i))
        {
            if (isTrue(isLessThan((mod(i, 2)), 1)))
            {
                object price = this.safeNumber(asks, i);
                object amount = this.safeNumber(asks, this.sum(i, 1));
                ((IList<object>)asksResult).Add(new List<object>() {price, amount});
            }
        }
        for (object i = 0; isLessThan(i, getArrayLength(bids)); postFixIncrement(ref i))
        {
            if (isTrue(isLessThan((mod(i, 2)), 1)))
            {
                object price = this.safeNumber(bids, i);
                object amount = this.safeNumber(bids, this.sum(i, 1));
                ((IList<object>)bidsResult).Add(new List<object>() {price, amount});
            }
        }
        return new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "bids", this.sortBy(bidsResult, 0, true) },
            { "asks", this.sortBy(asksResult, 0) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "nonce", null },
        };
    }

    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#createDepositAddress
        * @description create a currency deposit address
        * @see https://docs.poloniex.com/#authenticated-endpoints-wallets-deposit-addresses
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object network = this.safeStringUpper(parameters, "network"); // this line allows the user to specify either ERC20 or ETH
        network = this.safeString(networks, network, network); // handle ERC20>ETH alias
        if (isTrue(!isEqual(network, null)))
        {
            ((IDictionary<string,object>)request)["currency"] = add(((IDictionary<string,object>)request)["currency"], network); // when network the currency need to be changed to currency+network https://docs.poloniex.com/#withdraw on MultiChain Currencies section
            parameters = this.omit(parameters, "network");
        } else
        {
            if (isTrue(isEqual(getValue(currency, "id"), "USDT")))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " createDepositAddress requires a network parameter for "), code), ".")) ;
            }
        }
        object response = await this.privatePostWalletsAddress(this.extend(request, parameters));
        //
        //     {
        //         "address" : "0xfxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxf"
        //     }
        //
        object address = this.safeString(response, "address");
        object tag = null;
        this.checkAddress(address);
        if (isTrue(!isEqual(currency, null)))
        {
            object depositAddress = this.safeString(getValue(currency, "info"), "depositAddress");
            if (isTrue(!isEqual(depositAddress, null)))
            {
                tag = address;
                address = depositAddress;
            }
        }
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", network },
            { "info", response },
        };
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://docs.poloniex.com/#authenticated-endpoints-wallets-deposit-addresses
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object network = this.safeStringUpper(parameters, "network"); // this line allows the user to specify either ERC20 or ETH
        network = this.safeString(networks, network, network); // handle ERC20>ETH alias
        if (isTrue(!isEqual(network, null)))
        {
            ((IDictionary<string,object>)request)["currency"] = add(((IDictionary<string,object>)request)["currency"], network); // when network the currency need to be changed to currency+network https://docs.poloniex.com/#withdraw on MultiChain Currencies section
            parameters = this.omit(parameters, "network");
        } else
        {
            if (isTrue(isEqual(getValue(currency, "id"), "USDT")))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " fetchDepositAddress requires a network parameter for "), code), ".")) ;
            }
        }
        object response = await this.privateGetWalletsAddresses(this.extend(request, parameters));
        //
        //     {
        //         "USDTTRON" : "Txxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxp"
        //     }
        //
        object address = this.safeString(response, getValue(request, "currency"));
        object tag = null;
        this.checkAddress(address);
        if (isTrue(!isEqual(currency, null)))
        {
            object depositAddress = this.safeString(getValue(currency, "info"), "depositAddress");
            if (isTrue(!isEqual(depositAddress, null)))
            {
                tag = address;
                address = depositAddress;
            }
        }
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", network },
            { "info", response },
        };
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#transfer
        * @description transfer currency internally between wallets on the same account
        * @see https://docs.poloniex.com/#authenticated-endpoints-accounts-accounts-transfer
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        amount = this.currencyToPrecision(code, amount);
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, fromAccount);
        object request = new Dictionary<string, object>() {
            { "amount", amount },
            { "currency", getValue(currency, "id") },
            { "fromAccount", fromId },
            { "toAccount", toId },
        };
        object response = await this.privatePostAccountsTransfer(this.extend(request, parameters));
        //
        //    {
        //        "transferId" : "168041074"
        //    }
        //
        return this.parseTransfer(response, currency);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        //    {
        //        "transferId" : "168041074"
        //    }
        //
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", this.safeString(transfer, "transferId") },
            { "timestamp", null },
            { "datetime", null },
            { "currency", this.safeString(currency, "id") },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", null },
        };
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#withdraw
        * @description make a withdrawal
        * @see https://docs.poloniex.com/#authenticated-endpoints-wallets-withdraw-currency
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", amount },
            { "address", address },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["paymentId"] = tag;
        }
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object network = this.safeStringUpper(parameters, "network"); // this line allows the user to specify either ERC20 or ETH
        network = this.safeString(networks, network, network); // handle ERC20>ETH alias
        if (isTrue(!isEqual(network, null)))
        {
            ((IDictionary<string,object>)request)["currency"] = add(((IDictionary<string,object>)request)["currency"], network); // when network the currency need to be changed to currency+network https://docs.poloniex.com/#withdraw on MultiChain Currencies section
            parameters = this.omit(parameters, "network");
        }
        object response = await this.privatePostWalletsWithdraw(this.extend(request, parameters));
        //
        //     {
        //         "response": "Withdrew 1.00000000 USDT.",
        //         "email2FA": false,
        //         "withdrawalNumber": 13449869
        //     }
        //
        return this.parseTransaction(response, currency);
    }

    public async virtual Task<object> fetchTransactionsHelper(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object year = 31104000; // 60 * 60 * 24 * 30 * 12 = one year of history, why not
        object now = this.seconds();
        object start = ((bool) isTrue((!isEqual(since, null)))) ? this.parseToInt(divide(since, 1000)) : subtract(now, multiply(10, year));
        object request = new Dictionary<string, object>() {
            { "start", start },
            { "end", now },
        };
        object response = await this.privateGetWalletsActivity(this.extend(request, parameters));
        //
        //     {
        //         "adjustments":[],
        //         "deposits":[
        //             {
        //                 "currency": "BTC",
        //                 "address": "1MEtiqJWru53FhhHrfJPPvd2tC3TPDVcmW",
        //                 "amount": "0.01063000",
        //                 "confirmations":  1,
        //                 "txid": "952b0e1888d6d491591facc0d37b5ebec540ac1efb241fdbc22bcc20d1822fb6",
        //                 "timestamp":  1507916888,
        //                 "status": "COMPLETE"
        //             },
        //             {
        //                 "currency": "ETH",
        //                 "address": "0x20108ba20b65c04d82909e91df06618107460197",
        //                 "amount": "4.00000000",
        //                 "confirmations": 38,
        //                 "txid": "0x4be260073491fe63935e9e0da42bd71138fdeb803732f41501015a2d46eb479d",
        //                 "timestamp": 1525060430,
        //                 "status": "COMPLETE"
        //             }
        //         ],
        //         "withdrawals":[
        //             {
        //                 "withdrawalNumber":13449869,
        //                 "currency":"USDTTRON", // not documented in API docs, see commonCurrencies in describe()
        //                 "address":"TXGaqPW23JdRWhsVwS2mRsGsegbdnAd3Rw",
        //                 "amount":"1.00000000",
        //                 "fee":"0.00000000",
        //                 "timestamp":1591573420,
        //                 "status":"COMPLETE: dadf427224b3d44b38a2c13caa4395e4666152556ca0b2f67dbd86a95655150f",
        //                 "ipAddress":"x.x.x.x",
        //                 "canCancel":0,
        //                 "canResendEmail":0,
        //                 "paymentID":null,
        //                 "scope":"crypto"
        //             },
        //             {
        //                 "withdrawalNumber": 8224394,
        //                 "currency": "EMC2",
        //                 "address": "EYEKyCrqTNmVCpdDV8w49XvSKRP9N3EUyF",
        //                 "amount": "63.10796020",
        //                 "fee": "0.01000000",
        //                 "timestamp": 1510819838,
        //                 "status": "COMPLETE: d37354f9d02cb24d98c8c4fc17aa42f475530b5727effdf668ee5a43ce667fd6",
        //                 "ipAddress": "x.x.x.x"
        //             },
        //             {
        //                 "withdrawalNumber": 9290444,
        //                 "currency": "ETH",
        //                 "address": "0x191015ff2e75261d50433fbd05bd57e942336149",
        //                 "amount": "0.15500000",
        //                 "fee": "0.00500000",
        //                 "timestamp": 1514099289,
        //                 "status": "COMPLETE: 0x12d444493b4bca668992021fd9e54b5292b8e71d9927af1f076f554e4bea5b2d",
        //                 "ipAddress": "x.x.x.x"
        //             },
        //             {
        //                 "withdrawalNumber": 11518260,
        //                 "currency": "BTC",
        //                 "address": "8JoDXAmE1GY2LRK8jD1gmAmgRPq54kXJ4t",
        //                 "amount": "0.20000000",
        //                 "fee": "0.00050000",
        //                 "timestamp": 1527918155,
        //                 "status": "COMPLETE: 1864f4ebb277d90b0b1ff53259b36b97fa1990edc7ad2be47c5e0ab41916b5ff",
        //                 "ipAddress": "x.x.x.x"
        //             }
        //         ]
        //     }
        //
        return response;
    }

    public async override Task<object> fetchDepositsWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#fetchDepositsWithdrawals
        * @description fetch history of deposits and withdrawals
        * @see https://docs.poloniex.com/#authenticated-endpoints-wallets-wallets-activity-records
        * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
        * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
        * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.fetchTransactionsHelper(code, since, limit, parameters);
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object withdrawals = this.safeValue(response, "withdrawals", new List<object>() {});
        object deposits = this.safeValue(response, "deposits", new List<object>() {});
        object withdrawalTransactions = this.parseTransactions(withdrawals, currency, since, limit);
        object depositTransactions = this.parseTransactions(deposits, currency, since, limit);
        object transactions = this.arrayConcat(depositTransactions, withdrawalTransactions);
        return this.filterByCurrencySinceLimit(this.sortBy(transactions, "timestamp"), code, since, limit);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://docs.poloniex.com/#authenticated-endpoints-wallets-wallets-activity-records
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.fetchTransactionsHelper(code, since, limit, parameters);
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object withdrawals = this.safeValue(response, "withdrawals", new List<object>() {});
        object transactions = this.parseTransactions(withdrawals, currency, since, limit);
        return this.filterByCurrencySinceLimit(transactions, code, since, limit);
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://docs.poloniex.com/#public-endpoints-reference-data-currency-information
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [fees structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetCurrencies(this.extend(parameters, new Dictionary<string, object>() {
            { "includeMultiChainCurrencies", true },
        }));
        //
        //     [
        //         {
        //             "1CR": {
        //                 "id": 1,
        //                 "name": "1CRedit",
        //                 "description": "BTC Clone",
        //                 "type": "address",
        //                 "withdrawalFee": "0.01000000",
        //                 "minConf": 10000,
        //                 "depositAddress": null,
        //                 "blockchain": "1CR",
        //                 "delisted": false,
        //                 "tradingState": "NORMAL",
        //                 "walletState": "DISABLED",
        //                 "parentChain": null,
        //                 "isMultiChain": false,
        //                 "isChildChain": false,
        //                 "childChains": []
        //             }
        //         }
        //     ]
        //
        object data = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object currencies = new List<object>(((IDictionary<string,object>)entry).Keys);
            object currencyId = this.safeString(currencies, 0);
            ((IDictionary<string,object>)data)[(string)currencyId] = getValue(entry, currencyId);
        }
        return this.parseDepositWithdrawFees(data, codes);
    }

    public override object parseDepositWithdrawFees(object response, object codes = null, object currencyIdKey = null)
    {
        //
        //         {
        //             "1CR": {
        //                 "id": 1,
        //                 "name": "1CRedit",
        //                 "description": "BTC Clone",
        //                 "type": "address",
        //                 "withdrawalFee": "0.01000000",
        //                 "minConf": 10000,
        //                 "depositAddress": null,
        //                 "blockchain": "1CR",
        //                 "delisted": false,
        //                 "tradingState": "NORMAL",
        //                 "walletState": "DISABLED",
        //                 "parentChain": null,
        //                 "isMultiChain": false,
        //                 "isChildChain": false,
        //                 "childChains": []
        //             },
        //         }
        //
        object depositWithdrawFees = new Dictionary<string, object>() {};
        codes = this.marketCodes(codes);
        object responseKeys = new List<object>(((IDictionary<string,object>)response).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(responseKeys)); postFixIncrement(ref i))
        {
            object currencyId = getValue(responseKeys, i);
            object code = this.safeCurrencyCode(currencyId);
            object feeInfo = getValue(response, currencyId);
            if (isTrue(isTrue((isEqual(codes, null))) || isTrue((this.inArray(code, codes)))))
            {
                object currency = this.currency(code);
                ((IDictionary<string,object>)depositWithdrawFees)[(string)code] = this.parseDepositWithdrawFee(feeInfo, currency);
                object childChains = this.safeValue(feeInfo, "childChains");
                object chainsLength = getArrayLength(childChains);
                if (isTrue(isGreaterThan(chainsLength, 0)))
                {
                    for (object j = 0; isLessThan(j, getArrayLength(childChains)); postFixIncrement(ref j))
                    {
                        object networkId = getValue(childChains, j);
                        networkId = ((string)networkId).Replace((string)code, (string)"");
                        object networkCode = this.networkIdToCode(networkId);
                        object networkInfo = this.safeValue(response, networkId);
                        object networkObject = new Dictionary<string, object>() {};
                        object withdrawFee = this.safeNumber(networkInfo, "withdrawalFee");
                        ((IDictionary<string,object>)networkObject)[(string)networkCode] = new Dictionary<string, object>() {
                            { "withdraw", new Dictionary<string, object>() {
                                { "fee", withdrawFee },
                                { "percentage", ((bool) isTrue((!isEqual(withdrawFee, null)))) ? false : null },
                            } },
                            { "deposit", new Dictionary<string, object>() {
                                { "fee", null },
                                { "percentage", null },
                            } },
                        };
                        ((IDictionary<string,object>)getValue(depositWithdrawFees, code))["networks"] = this.extend(getValue(getValue(depositWithdrawFees, code), "networks"), networkObject);
                    }
                }
            }
        }
        return depositWithdrawFees;
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        object depositWithdrawFee = this.depositWithdrawFee(new Dictionary<string, object>() {});
        ((IDictionary<string,object>)getValue(depositWithdrawFee, "info"))[(string)getValue(currency, "code")] = fee;
        object networkId = this.safeString(fee, "blockchain");
        object withdrawFee = this.safeNumber(fee, "withdrawalFee");
        object withdrawResult = new Dictionary<string, object>() {
            { "fee", withdrawFee },
            { "percentage", ((bool) isTrue((!isEqual(withdrawFee, null)))) ? false : null },
        };
        object depositResult = new Dictionary<string, object>() {
            { "fee", null },
            { "percentage", null },
        };
        ((IDictionary<string,object>)depositWithdrawFee)["withdraw"] = withdrawResult;
        ((IDictionary<string,object>)depositWithdrawFee)["deposit"] = depositResult;
        object networkCode = this.networkIdToCode(networkId);
        ((IDictionary<string,object>)getValue(depositWithdrawFee, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
            { "withdraw", withdrawResult },
            { "deposit", depositResult },
        };
        return depositWithdrawFee;
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name poloniex#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://docs.poloniex.com/#authenticated-endpoints-wallets-wallets-activity-records
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.fetchTransactionsHelper(code, since, limit, parameters);
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object deposits = this.safeValue(response, "deposits", new List<object>() {});
        object transactions = this.parseTransactions(deposits, currency, since, limit);
        return this.filterByCurrencySinceLimit(transactions, code, since, limit);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "COMPLETE", "ok" },
            { "COMPLETED", "ok" },
            { "AWAITING APPROVAL", "pending" },
            { "AWAITING_APPROVAL", "pending" },
            { "PENDING", "pending" },
            { "PROCESSING", "pending" },
            { "COMPLETE ERROR", "failed" },
            { "COMPLETE_ERROR", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // deposits
        //
        //     {
        //         "txid": "f49d489616911db44b740612d19464521179c76ebe9021af85b6de1e2f8d68cd",
        //         "amount": "49798.01987021",
        //         "status": "COMPLETE",
        //         "address": "DJVJZ58tJC8UeUv9Tqcdtn6uhWobouxFLT",
        //         "currency": "DOGE",
        //         "timestamp": 1524321838,
        //         "confirmations": 3371,
        //         "depositNumber": 134587098
        //     }
        //
        // withdrawals
        //
        //     {
        //         "withdrawalRequestsId": 7397527,
        //         "currency": "ETC",
        //         "address": "0x26419a62055af459d2cd69bb7392f5100b75e304",
        //         "amount": "13.19951600",
        //         "fee": "0.01000000",
        //         "timestamp": 1506010932,
        //         "status": "COMPLETED",
        //         "txid": "343346392f82ac16e8c2604f2a604b7b2382d0e9d8030f673821f8de4b5f5bk",
        //         "ipAddress": "1.2.3.4",
        //         "paymentID": null
        //     }
        //
        // withdraw
        //
        //     {
        //         "withdrawalRequestsId": 33485231
        //     }
        //
        object timestamp = this.safeTimestamp(transaction, "timestamp");
        object currencyId = this.safeString(transaction, "currency");
        object code = this.safeCurrencyCode(currencyId);
        object status = this.safeString(transaction, "status", "pending");
        status = this.parseTransactionStatus(status);
        object txid = this.safeString(transaction, "txid");
        object type = ((bool) isTrue((inOp(transaction, "withdrawalRequestsId")))) ? "withdrawal" : "deposit";
        object id = this.safeString2(transaction, "withdrawalRequestsId", "depositNumber");
        object address = this.safeString(transaction, "address");
        object tag = this.safeString(transaction, "paymentID");
        object amountString = this.safeString(transaction, "amount");
        object feeCostString = this.safeString(transaction, "fee");
        if (isTrue(isEqual(type, "withdrawal")))
        {
            amountString = Precise.stringSub(amountString, feeCostString);
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "currency", code },
            { "amount", this.parseNumber(amountString) },
            { "network", null },
            { "address", address },
            { "addressTo", null },
            { "addressFrom", null },
            { "tag", tag },
            { "tagTo", null },
            { "tagFrom", null },
            { "status", status },
            { "type", type },
            { "updated", null },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "comment", null },
            { "internal", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", this.parseNumber(feeCostString) },
                { "rate", null },
            } },
        };
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = getValue(getValue(this.urls, "api"), "rest");
        object query = this.omit(parameters, this.extractParams(path));
        object implodedPath = this.implodeParams(path, parameters);
        if (isTrue(isEqual(api, "public")))
        {
            url = add(url, add("/", implodedPath));
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else
        {
            this.checkRequiredCredentials();
            object timestamp = ((object)this.nonce()).ToString();
            object auth = add(method, "\n"); // eslint-disable-line quotes
            url = add(url, add("/", implodedPath));
            auth = add(auth, add("/", implodedPath));
            if (isTrue(isTrue(isTrue((isEqual(method, "POST"))) || isTrue((isEqual(method, "PUT")))) || isTrue((isEqual(method, "DELETE")))))
            {
                auth = add(auth, "\n"); // eslint-disable-line quotes
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    body = this.json(query);
                    auth = add(auth, add(add("requestBody=", body), "&"));
                }
                auth = add(auth, add("signTimestamp=", timestamp));
            } else
            {
                object sortedQuery = this.extend(new Dictionary<string, object>() {
                    { "signTimestamp", timestamp },
                }, query);
                sortedQuery = this.keysort(sortedQuery);
                auth = add(auth, add("\n", this.urlencode(sortedQuery))); // eslint-disable-line quotes
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    url = add(url, add("?", this.urlencode(query)));
                }
            }
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256, "base64");
            headers = new Dictionary<string, object>() {
                { "Content-Type", "application/json" },
                { "key", this.apiKey },
                { "signTimestamp", timestamp },
                { "signature", signature },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        //
        //     {
        //         "code" : 21709,
        //         "message" : "Low available balance"
        //     }
        //
        object responseCode = this.safeString(response, "code");
        if (isTrue(isTrue((!isEqual(responseCode, null))) && isTrue((!isEqual(responseCode, "200")))))
        {
            object codeInner = getValue(response, "code");
            object message = this.safeString(response, "message");
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), codeInner, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
