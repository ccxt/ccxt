namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class deepcoin { public deepcoin(object args = null) : base(args) { } }
public partial class deepcoin : ccxt.deepcoin
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchTicker", true },
                { "watchMarkPrice", false },
                { "watchMarkPrices", false },
                { "watchTickers", false },
                { "watchBidsAsks", false },
                { "watchOrderBook", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", false },
                { "watchOrderBookForSymbols", false },
                { "watchBalance", false },
                { "watchLiquidations", false },
                { "watchLiquidationsForSymbols", false },
                { "watchMyLiquidations", false },
                { "watchMyLiquidationsForSymbols", false },
                { "watchOHLCV", true },
                { "watchOHLCVForSymbols", false },
                { "watchOrders", true },
                { "watchMyTrades", true },
                { "watchPositions", true },
                { "watchFundingRate", false },
                { "watchFundingRates", false },
                { "createOrderWs", false },
                { "editOrderWs", false },
                { "cancelOrderWs", false },
                { "cancelOrdersWs", false },
                { "cancelAllOrdersWs", false },
                { "unWatchTicker", true },
                { "unWatchTrades", true },
                { "unWatchOHLCV", true },
                { "unWatchOrderBook", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", new Dictionary<string, object>() {
                            { "spot", "wss://stream.deepcoin.com/streamlet/trade/public/spot?platform=api" },
                            { "swap", "wss://stream.deepcoin.com/streamlet/trade/public/swap?platform=api" },
                        } },
                        { "private", "wss://stream.deepcoin.com/v1/private" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "lastRequestId", null },
                { "listenKey", null },
                { "listenKeyExpiryTimestamp", null },
                { "authenticate", new Dictionary<string, object>() {
                    { "method", "privateGetDeepcoinListenkeyExtend" },
                } },
                { "timeframes", new Dictionary<string, object>() {
                    { "1m", "1m" },
                    { "5m", "5m" },
                    { "15m", "15m" },
                    { "30m", "30m" },
                    { "1h", "1h" },
                    { "4h", "4h" },
                    { "12h", "12h" },
                    { "1d", "1d" },
                    { "1w", "1w" },
                    { "1M", "1o" },
                    { "1y", "1y" },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "ping", this.ping },
            } },
        });
    }

    public override object ping(WebSocketClient client)
    {
        object url = client.url;
        if (isTrue(isGreaterThanOrEqual(getIndexOf(url, "private"), 0)))
        {
            client.lastPong = this.milliseconds();
        }
        return "ping";
    }

    public virtual object handlePong(WebSocketClient client, object message)
    {
        client.lastPong = this.milliseconds();
        return message;
    }

    public virtual object requestId()
    {
        this.lockId();
        object previousValue = this.safeInteger(this.options, "lastRequestId", 0);
        object newValue = this.sum(previousValue, 1);
        ((IDictionary<string,object>)this.options)["lastRequestId"] = newValue;
        this.unlockId();
        return newValue;
    }

    public virtual object createPublicRequest(object market, object requestId, object topicID, object suffix = null, object unWatch = null)
    {
        suffix ??= "";
        unWatch ??= false;
        object marketId = getValue(market, "symbol"); // spot markets use symbol with slash
        if (isTrue(isEqual(getValue(market, "type"), "swap")))
        {
            marketId = add(getValue(market, "baseId"), getValue(market, "quoteId")); // swap markets use symbol without slash
        }
        object action = "1"; // subscribe
        if (isTrue(unWatch))
        {
            action = "0"; // unsubscribe
        }
        object request = new Dictionary<string, object>() {
            { "sendTopicAction", new Dictionary<string, object>() {
                { "Action", action },
                { "FilterValue", add(add("DeepCoin_", marketId), suffix) },
                { "LocalNo", requestId },
                { "ResumeNo", -1 },
                { "TopicID", topicID },
            } },
        };
        return request;
    }

    public async virtual Task<object> watchPublic(object market, object messageHash, object topicID, object parameters = null, object suffix = null)
    {
        parameters ??= new Dictionary<string, object>();
        suffix ??= "";
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "public"), getValue(market, "type"));
        object requestId = this.requestId();
        object request = this.createPublicRequest(market, requestId, topicID, suffix);
        object subscription = new Dictionary<string, object>() {
            { "subHash", messageHash },
            { "id", requestId },
        };
        return await this.watch(url, messageHash, this.deepExtend(request, parameters), messageHash, subscription);
    }

    public async virtual Task<object> unWatchPublic(object market, object messageHash, object topicID, object parameters = null, object subscription = null, object suffix = null)
    {
        parameters ??= new Dictionary<string, object>();
        subscription ??= new Dictionary<string, object>();
        suffix ??= "";
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "public"), getValue(market, "type"));
        object requestId = this.requestId();
        var client = this.client(url);
        object existingSubscription = this.safeDict(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(existingSubscription, null)))
        {
            throw new BadRequest ((string)add(add(this.id, " no subscription for "), messageHash)) ;
        }
        object subId = this.safeInteger(existingSubscription, "id");
        object request = this.createPublicRequest(market, subId, topicID, suffix, true); // unsubscribe message uses the same id as the original subscribe message
        object unsubHash = add("unsubscribe::", messageHash);
        subscription = this.extend(subscription, new Dictionary<string, object>() {
            { "subHash", messageHash },
            { "unsubHash", unsubHash },
            { "symbols", new List<object>() {getValue(market, "symbol")} },
            { "id", requestId },
        });
        return await this.watch(url, unsubHash, this.deepExtend(request, parameters), unsubHash, subscription);
    }

    public async virtual Task<object> watchPrivate(object messageHash, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object listenKey = await this.authenticate();
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "private"), "?listenKey="), listenKey);
        return await this.watch(url, messageHash, null, "private", parameters);
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object time = this.milliseconds();
        object listenKeyExpiryTimestamp = this.safeInteger(this.options, "listenKeyExpiryTimestamp", time);
        object expired = isGreaterThan((subtract(time, listenKeyExpiryTimestamp)), 60000); // 1 minute before expiry
        object listenKey = this.safeString(this.options, "listenKey");
        object response = null;
        if (isTrue(isEqual(listenKey, null)))
        {
            response = await this.privateGetDeepcoinListenkeyAcquire(parameters);
        } else if (isTrue(expired))
        {
            object method = this.safeString(this.options, "method", "privateGetDeepcoinListenkeyExtend");
            object getNewKey = (isEqual(method, "privateGetDeepcoinListenkeyAcquire"));
            if (isTrue(getNewKey))
            {
                response = await this.privateGetDeepcoinListenkeyAcquire(parameters);
            } else
            {
                object request = new Dictionary<string, object>() {
                    { "listenkey", listenKey },
                };
                response = await this.privateGetDeepcoinListenkeyExtend(this.extend(request, parameters));
            }
        }
        if (isTrue(!isEqual(response, null)))
        {
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            listenKey = this.safeString(data, "listenkey");
            listenKeyExpiryTimestamp = this.safeTimestamp(data, "expire_time");
            ((IDictionary<string,object>)this.options)["listenKey"] = listenKey;
            ((IDictionary<string,object>)this.options)["listenKeyExpiryTimestamp"] = listenKeyExpiryTimestamp;
        }
        return listenKey;
    }

    /**
     * @method
     * @name deepcoin#watchTicker
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://www.deepcoin.com/docs/publicWS/latestMarketData
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object messageHash = add(add("ticker", "::"), getValue(market, "symbol"));
        return await this.watchPublic(market, messageHash, "7", parameters);
    }

    /**
     * @method
     * @name deepcoin#unWatchTicker
     * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://www.deepcoin.com/docs/publicWS/latestMarketData
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> unWatchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object messageHash = add(add("ticker", "::"), getValue(market, "symbol"));
        object subscription = new Dictionary<string, object>() {
            { "topic", "ticker" },
        };
        return await this.unWatchPublic(market, messageHash, "7", parameters, subscription);
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        //     a: 'PO',
        //     m: 'Success',
        //     tt: 1760913034780,
        //     mt: 1760913034780,
        //     r: [
        //         {
        //             d: {
        //                 I: 'BTC/USDT',
        //                 U: 1760913034742,
        //                 PF: 0,
        //                 E: 0,
        //                 O: 108479.9,
        //                 H: 109449.9,
        //                 L: 108238,
        //                 V: 789.3424915,
        //                 T: 43003872.3705223,
        //                 N: 109345,
        //                 M: 87294.7,
        //                 D: 0,
        //                 V2: 3086.4496105,
        //                 T2: 332811624.339836,
        //                 F: 0,
        //                 C: 0,
        //                 BP1: 109344.9,
        //                 AP1: 109345.2
        //             }
        //         }
        //     ]
        //
        object response = this.safeList(message, "r", new List<object>() {});
        object first = this.safeDict(response, 0, new Dictionary<string, object>() {});
        object data = this.safeDict(first, "d", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "I");
        object market = this.safeMarket(marketId, null, "/");
        object symbol = this.safeSymbol(marketId, market);
        object parsedTicker = this.parseWsTicker(data, market);
        object messageHash = add(add("ticker", "::"), symbol);
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = parsedTicker;
        callDynamically(client as WebSocketClient, "resolve", new object[] {parsedTicker, messageHash});
    }

    public virtual object parseWsTicker(object ticker, object market = null)
    {
        //
        //     {
        //         I: 'BTC/USDT',
        //         U: 1760913034742,
        //         PF: 0,
        //         E: 0,
        //         O: 108479.9,
        //         H: 109449.9,
        //         L: 108238,
        //         V: 789.3424915,
        //         T: 43003872.3705223,
        //         N: 109345,
        //         M: 87294.7,
        //         D: 0,
        //         V2: 3086.4496105,
        //         T2: 332811624.339836,
        //         F: 0,
        //         C: 0,
        //         BP1: 109344.9,
        //         AP1: 109345.2
        //     }
        //
        object timestamp = this.safeInteger(ticker, "U");
        object high = this.safeNumber(ticker, "H");
        object low = this.safeNumber(ticker, "L");
        object open = this.safeNumber(ticker, "O");
        object last = this.safeNumber(ticker, "N");
        object bid = this.safeNumber(ticker, "BP1");
        object ask = this.safeNumber(ticker, "AP1");
        object baseVolume = this.safeNumber(ticker, "V");
        object quoteVolume = this.safeNumber(ticker, "T");
        if (isTrue(getValue(market, "inverse")))
        {
            object temp = baseVolume;
            baseVolume = quoteVolume;
            quoteVolume = temp;
        }
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", high },
            { "low", low },
            { "bid", bid },
            { "bidVolume", null },
            { "ask", ask },
            { "askVolume", null },
            { "vwap", null },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name deepcoin#watchTrades
     * @description watches information on multiple trades made in a market
     * @see https://www.deepcoin.com/docs/publicWS/lastTransactions
     * @param {string} symbol unified market symbol of the market trades were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of trade structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object messageHash = add(add("trades", "::"), getValue(market, "symbol"));
        object trades = await this.watchPublic(market, messageHash, "2", parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    /**
     * @method
     * @name deepcoin#unWatchTrades
     * @description unWatches the list of most recent trades for a particular symbol
     * @see https://www.deepcoin.com/docs/publicWS/lastTransactions
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> unWatchTrades(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object messageHash = add(add("trades", "::"), getValue(market, "symbol"));
        object subscription = new Dictionary<string, object>() {
            { "topic", "trades" },
        };
        return await this.unWatchPublic(market, messageHash, "2", parameters, subscription);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //         "a": "PMT",
        //         "b": 0,
        //         "tt": 1760968672380,
        //         "mt": 1760968672380,
        //         "r": [
        //             {
        //                 "d": {
        //                     "TradeID": "1001056452325378",
        //                     "I": "BTC/USDT",
        //                     "D": "1",
        //                     "P": 111061,
        //                     "V": 0.00137,
        //                     "T": 1760968672
        //                 }
        //             }
        //         ]
        //     }
        //
        object response = this.safeList(message, "r", new List<object>() {});
        object first = this.safeDict(response, 0, new Dictionary<string, object>() {});
        object data = this.safeDict(first, "d", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "I");
        object market = this.safeMarket(marketId, null, "/");
        object symbol = this.safeSymbol(marketId, market);
        if (!isTrue((inOp(this.trades, symbol))))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = new ArrayCache(limit);
        }
        object strored = getValue(this.trades, symbol);
        if (isTrue(!isEqual(data, null)))
        {
            object trade = this.parseWsTrade(data, market);
            callDynamically(strored, "append", new object[] {trade});
        }
        object messageHash = add(add("trades", "::"), symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {strored, messageHash});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        // watchTrades
        //     {
        //         "TradeID": "1001056452325378",
        //         "I": "BTC/USDT",
        //         "D": "1",
        //         "P": 111061,
        //         "V": 0.00137,
        //         "T": 1760968672
        //     }
        //
        // watchMyTrades
        //     {
        //         "A": "9256245",
        //         "CC": "USDT",
        //         "CP": 0,
        //         "D": "0",
        //         "F": 0.152,
        //         "I": "DOGE/USDT",
        //         "IT": 1761048103,
        //         "M": "9256245",
        //         "OS": "1001437462198486",
        //         "P": 0.19443,
        //         "T": 14.77668,
        //         "TI": "1001056459096708",
        //         "TT": 1761048103,
        //         "V": 76,
        //         "f": "DOGE",
        //         "l": 1,
        //         "m": "1",
        //         "o": "0"
        //     }
        //
        object direction = this.safeString(trade, "D");
        object timestamp = this.safeTimestamp2(trade, "TT", "T");
        object matchRole = this.safeString(trade, "m");
        object fee = null;
        object feeCost = this.safeString(trade, "F");
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", this.safeCurrencyCode(this.safeString(trade, "f")) },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "id", this.safeString2(trade, "TradeID", "TI") },
            { "order", this.safeString(trade, "OS") },
            { "type", null },
            { "takerOrMaker", this.handleTakerOrMaker(matchRole) },
            { "side", this.parseTradeSide(direction) },
            { "price", this.safeString(trade, "P") },
            { "amount", this.safeString(trade, "V") },
            { "cost", this.safeString(trade, "T") },
            { "fee", fee },
        }, market);
    }

    public virtual object parseTradeSide(object direction)
    {
        object sides = new Dictionary<string, object>() {
            { "0", "buy" },
            { "1", "sell" },
        };
        return this.safeString(sides, direction, direction);
    }

    public virtual object handleTakerOrMaker(object matchRole)
    {
        object roles = new Dictionary<string, object>() {
            { "0", "maker" },
            { "1", "taker" },
        };
        return this.safeString(roles, matchRole, matchRole);
    }

    /**
     * @method
     * @name deepcoin#watchOHLCV
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://www.deepcoin.com/docs/publicWS/KLines
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} [timeframe] the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object timeframes = this.safeDict(this.options, "timeframes", new Dictionary<string, object>() {});
        object interval = this.safeString(timeframes, timeframe, timeframe);
        object messageHash = add(add(add(add("ohlcv", "::"), symbol), "::"), timeframe);
        object suffix = add("_", interval);
        object ohlcv = await this.watchPublic(market, messageHash, "11", parameters, suffix);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    /**
     * @method
     * @name deepcoin#unWatchOHLCV
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://docs.backpack.exchange/#tag/Streams/Public/K-Line
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} [timeframe] the length of time each candle represents
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> unWatchOHLCV(object symbol, object timeframe = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object timeframes = this.safeDict(this.options, "timeframes", new Dictionary<string, object>() {});
        object interval = this.safeString(timeframes, timeframe, timeframe);
        object messageHash = add(add(add(add("ohlcv", "::"), symbol), "::"), timeframe);
        object suffix = add("_", interval);
        object subscription = new Dictionary<string, object>() {
            { "topic", "ohlcv" },
            { "symbolsAndTimeframes", new List<object>() {new List<object>() {symbol, timeframe}} },
        };
        return await this.unWatchPublic(market, messageHash, "11", parameters, subscription, suffix);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "a": "PK",
        //         "tt": 1760972831580,
        //         "mt": 1760972831580,
        //         "r": [
        //             {
        //                 "d": {
        //                     "I": "BTC/USDT",
        //                     "P": "1m",
        //                     "B": 1760972820,
        //                     "O": 111373,
        //                     "C": 111382.9,
        //                     "H": 111382.9,
        //                     "L": 111373,
        //                     "V": 0.2414172,
        //                     "M": 26888.19693324
        //                 },
        //                 "t": "LK"
        //             }
        //         ]
        //     }
        //
        object response = this.safeList(message, "r", new List<object>() {});
        object first = this.safeDict(response, 0, new Dictionary<string, object>() {});
        object data = this.safeDict(first, "d", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "I");
        object market = this.safeMarket(marketId, null, "/");
        object symbol = this.safeSymbol(marketId, market);
        object interval = this.safeString(data, "P");
        object timeframe = this.findTimeframe(interval);
        if (!isTrue((inOp(this.ohlcvs, symbol))))
        {
            ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = new Dictionary<string, object>() {};
        }
        if (!isTrue((inOp(getValue(this.ohlcvs, symbol), timeframe))))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = new ArrayCacheByTimestamp(limit);
        }
        object stored = getValue(getValue(this.ohlcvs, symbol), timeframe);
        if (isTrue(!isEqual(data, null)))
        {
            object ohlcv = this.parseWsOHLCV(data, market);
            callDynamically(stored, "append", new object[] {ohlcv});
        }
        object messageHash = add(add(add(add("ohlcv", "::"), symbol), "::"), timeframe);
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public override object parseWsOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "I": "BTC/USDT",
        //         "P": "1m",
        //         "B": 1760972820,
        //         "O": 111373,
        //         "C": 111382.9,
        //         "H": 111382.9,
        //         "L": 111373,
        //         "V": 0.2414172,
        //         "M": 26888.19693324
        //     }
        //
        return new List<object> {this.safeTimestamp(ohlcv, "B"), this.safeNumber(ohlcv, "O"), this.safeNumber(ohlcv, "H"), this.safeNumber(ohlcv, "L"), this.safeNumber(ohlcv, "C"), this.safeNumber(ohlcv, "V")};
    }

    /**
     * @method
     * @name deepcoin#watchOrderBook
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://www.deepcoin.com/docs/publicWS/25LevelIncrementalMarketData
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return.
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object messageHash = add(add("orderbook", "::"), getValue(market, "symbol"));
        object suffix = "_0.1";
        object orderbook = await this.watchPublic(market, messageHash, "25", parameters, suffix);
        return (orderbook as IOrderBook).limit();
    }

    /**
     * @method
     * @name deepcoin#unWatchOrderBook
     * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://www.deepcoin.com/docs/publicWS/25LevelIncrementalMarketData
     * @param {string} symbol unified array of symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> unWatchOrderBook(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object messageHash = add(add("orderbook", "::"), getValue(market, "symbol"));
        object suffix = "_0.1";
        object subscription = new Dictionary<string, object>() {
            { "topic", "orderbook" },
        };
        return await this.unWatchPublic(market, messageHash, "25", parameters, subscription, suffix);
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //     {
        //         "a": "PMO",
        //         "t": "i", // i - update, f - snapshot
        //         "r": [
        //             {
        //                 "d": { "I": "ETH/USDT", "D": "1", "P": 4021, "V": 54.39979 }
        //             },
        //             {
        //                 "d": { "I": "ETH/USDT", "D": "0", "P": 4021.1, "V": 49.56724 }
        //             }
        //         ],
        //         "tt": 1760975816446,
        //         "mt": 1760975816446
        //     }
        //
        object response = this.safeList(message, "r", new List<object>() {});
        object first = this.safeDict(response, 0, new Dictionary<string, object>() {});
        object data = this.safeDict(first, "d", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "I");
        object market = this.safeMarket(marketId, null, "/");
        object symbol = this.safeSymbol(marketId, market);
        if (!isTrue((inOp(this.orderbooks, symbol))))
        {
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook();
        }
        object orderbook = getValue(this.orderbooks, symbol);
        object type = this.safeString(message, "t");
        if (isTrue(isEqual(getValue(orderbook, "timestamp"), null)))
        {
            if (isTrue(isEqual(type, "f")))
            {
                // snapshot
                this.handleOrderBookSnapshot(client as WebSocketClient, message);
            } else
            {
                // cache the updates until the snapshot is received
                ((IList<object>)(orderbook as ccxt.pro.OrderBook).cache).Add(message);
            }
        } else
        {
            this.handleOrderBookMessage(client as WebSocketClient, message, orderbook);
            object messageHash = add(add("orderbook", "::"), symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
        }
    }

    public virtual void handleOrderBookSnapshot(WebSocketClient client, object message)
    {
        object entries = this.safeList(message, "r", new List<object>() {});
        object first = this.safeDict(entries, 0, new Dictionary<string, object>() {});
        object data = this.safeDict(first, "d", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "I");
        object market = this.safeMarket(marketId, null, "/");
        object symbol = this.safeSymbol(marketId, market);
        object orderbook = getValue(this.orderbooks, symbol);
        object orderedEntries = new Dictionary<string, object>() {
            { "bids", new List<object>() {} },
            { "asks", new List<object>() {} },
        };
        for (object i = 0; isLessThan(i, getArrayLength(entries)); postFixIncrement(ref i))
        {
            object entry = getValue(entries, i);
            object entryData = this.safeDict(entry, "d", new Dictionary<string, object>() {});
            object side = this.safeString(entryData, "D");
            object price = this.safeNumber(entryData, "P");
            object volume = this.safeNumber(entryData, "V");
            if (isTrue(isEqual(side, "0")))
            {
                // bid
                ((IList<object>)getValue(orderedEntries, "bids")).Add(new List<object>() {price, volume});
            } else if (isTrue(isEqual(side, "1")))
            {
                // ask
                ((IList<object>)getValue(orderedEntries, "asks")).Add(new List<object>() {price, volume});
            }
        }
        object timestamp = this.safeInteger(message, "mt");
        object snapshot = this.parseOrderBook(orderedEntries, symbol, timestamp);
        (orderbook as IOrderBook).reset(snapshot);
        object cachedMessages = (orderbook as ccxt.pro.OrderBook).cache;
        for (object j = 0; isLessThan(j, getArrayLength(cachedMessages)); postFixIncrement(ref j))
        {
            object cachedMessage = getValue(cachedMessages, j);
            this.handleOrderBookMessage(client as WebSocketClient, cachedMessage, orderbook);
        }
        (orderbook as ccxt.pro.OrderBook).cache = new List<object>() {};
        object messageHash = add(add("orderbook", "::"), symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public virtual void handleOrderBookMessage(WebSocketClient client, object message, object orderbook)
    {
        //     {
        //         "a": "PMO",
        //         "t": "i", // i - update, f - snapshot
        //         "r": [
        //             {
        //                 "d": { "I": "ETH/USDT", "D": "1", "P": 4021, "V": 54.39979 }
        //             },
        //             {
        //                 "d": { "I": "ETH/USDT", "D": "0", "P": 4021.1, "V": 49.56724 }
        //             }
        //         ],
        //         "tt": 1760975816446,
        //         "mt": 1760975816446
        //     }
        //
        object timestamp = this.safeInteger(message, "mt");
        if (isTrue(isGreaterThan(timestamp, getValue(orderbook, "timestamp"))))
        {
            object response = this.safeList(message, "r", new List<object>() {});
            this.handleDeltas(orderbook, response);
            ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        }
    }

    public override void handleDelta(object orderbook, object entry)
    {
        object data = this.safeDict(entry, "d", new Dictionary<string, object>() {});
        object bids = getValue(orderbook, "bids");
        object asks = getValue(orderbook, "asks");
        object side = this.safeString(data, "D");
        object price = this.safeNumber(data, "P");
        object volume = this.safeNumber(data, "V");
        if (isTrue(isEqual(side, "0")))
        {
            // bid
            (bids as IOrderBookSide).store(price, volume);
        } else if (isTrue(isEqual(side, "1")))
        {
            // ask
            (asks as IOrderBookSide).store(price, volume);
        }
    }

    /**
     * @method
     * @name deepcoin#watchMyTrades
     * @description watches information on multiple trades made by the user
     * @see https://www.deepcoin.com/docs/privateWS/Trade
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object messageHash = "myTrades";
        await this.loadMarkets();
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
            messageHash = add(messageHash, add("::", symbol));
        }
        object trades = await this.watchPrivate(messageHash, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleMyTrade(WebSocketClient client, object message)
    {
        //
        //     {
        //         "action": "PushTrade",
        //         "result": [
        //             {
        //                 "table": "Trade",
        //                 "data": {
        //                     "A": "9256245",
        //                     "CC": "USDT",
        //                     "CP": 0,
        //                     "D": "0",
        //                     "F": 0.152,
        //                     "I": "DOGE/USDT",
        //                     "IT": 1761048103,
        //                     "M": "9256245",
        //                     "OS": "1001437462198486",
        //                     "P": 0.19443,
        //                     "T": 14.77668,
        //                     "TI": "1001056459096708",
        //                     "TT": 1761048103,
        //                     "V": 76,
        //                     "f": "DOGE",
        //                     "l": 1,
        //                     "m": "1",
        //                     "o": "0"
        //                 }
        //             }
        //         ]
        //     }
        //
        object result = this.safeList(message, "result", new List<object>() {});
        object first = this.safeDict(result, 0, new Dictionary<string, object>() {});
        object data = this.safeDict(first, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "I");
        object market = this.safeMarket(marketId, null, "/");
        object symbol = this.safeSymbol(marketId, market);
        object messageHash = "myTrades";
        object symbolMessageHash = add(add(messageHash, "::"), symbol);
        if (isTrue(isTrue((inOp(client.futures, messageHash))) || isTrue((inOp(client.futures, symbolMessageHash)))))
        {
            if (isTrue(isEqual(this.myTrades, null)))
            {
                object limit = this.safeInteger(this.options, "tradesLimit", 1000);
                this.myTrades = new ArrayCacheBySymbolById(limit);
            }
            object stored = this.myTrades;
            object parsed = this.parseWsTrade(data, market);
            callDynamically(stored, "append", new object[] {parsed});
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, symbolMessageHash});
        }
    }

    /**
     * @method
     * @name deepcoin#watchOrders
     * @description watches information on multiple orders made by the user
     * @see https://www.deepcoin.com/docs/privateWS/order
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object messageHash = "orders";
        await this.loadMarkets();
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
            messageHash = add(messageHash, add("::", symbol));
        }
        object orders = await this.watchPrivate(messageHash, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        //
        //     {
        //         "action": "PushOrder",
        //         "result": [
        //             {
        //                 "table": "Order",
        //                 "data": {
        //                     "D": "0",
        //                     "I": "DOGE/USDT",
        //                     "IT": 1761051006,
        //                     "L": "1001437480817468",
        //                     "OPT": "4",
        //                     "OS": "1001437480817468",
        //                     "OT": "0",
        //                     "Or": "1",
        //                     "P": 0.19537,
        //                     "T": 14.84128,
        //                     "U": 1761051006,
        //                     "V": 76,
        //                     "VT": 76,
        //                     "i": 1,
        //                     "l": 1,
        //                     "o": "0",
        //                     "p": "0",
        //                     "t": 0.19528
        //                 }
        //             }
        //         ]
        //     }
        //
        object result = this.safeList(message, "result", new List<object>() {});
        object first = this.safeDict(result, 0, new Dictionary<string, object>() {});
        object data = this.safeDict(first, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "I");
        object market = this.safeMarket(marketId, null, "/");
        object symbol = this.safeSymbol(marketId, market);
        object messageHash = "orders";
        object symbolMessageHash = add(add(messageHash, "::"), symbol);
        if (isTrue(isTrue((inOp(client.futures, messageHash))) || isTrue((inOp(client.futures, symbolMessageHash)))))
        {
            if (isTrue(isEqual(this.orders, null)))
            {
                object limit = this.safeInteger(this.options, "ordersLimit", 1000);
                this.orders = new ArrayCacheBySymbolById(limit);
            }
            object parsed = this.parseWsOrder(data, market);
            callDynamically(this.orders, "append", new object[] {parsed});
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageHash});
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, symbolMessageHash});
        }
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        //     {
        //         "D": "0",
        //         "I": "DOGE/USDT",
        //         "IT": 1761051006,
        //         "L": "1001437480817468",
        //         "OPT": "4",
        //         "OS": "1001437480817468",
        //         "OT": "0",
        //         "Or": "1",
        //         "P": 0.19537,
        //         "T": 14.84128,
        //         "U": 1761051006,
        //         "V": 76,
        //         "VT": 76,
        //         "i": 1,
        //         "l": 1,
        //         "o": "0",
        //         "p": "0",
        //         "t": 0.19528
        //     }
        //
        object state = this.safeString(order, "Or");
        object timestamp = this.safeTimestamp(order, "IT");
        object direction = this.safeString(order, "D");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(order, "OS") },
            { "clientOrderId", null },
            { "datetime", this.iso8601(timestamp) },
            { "timestamp", timestamp },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", this.safeTimestamp(order, "U") },
            { "status", this.parseWsOrderStatus(state) },
            { "symbol", getValue(market, "symbol") },
            { "type", null },
            { "timeInForce", null },
            { "side", this.parseTradeSide(direction) },
            { "price", this.safeString(order, "P") },
            { "average", this.safeString(order, "t") },
            { "amount", this.safeString(order, "V") },
            { "filled", this.safeString(order, "VT") },
            { "remaining", null },
            { "triggerPrice", null },
            { "takeProfitPrice", this.safeString(order, "TPT") },
            { "stopLossPrice", this.safeString(order, "SLT") },
            { "cost", this.safeString(order, "T") },
            { "trades", null },
            { "fee", null },
            { "reduceOnly", null },
            { "postOnly", null },
            { "info", order },
        }, market);
    }

    public virtual object parseWsOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "1", "closed" },
            { "4", "open" },
            { "6", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name deepcoin#watchPositions
     * @description watch all open positions
     * @see https://www.deepcoin.com/docs/privateWS/Position
     * @param {string[]} [symbols] list of unified market symbols to watch positions for
     * @param {int} [since] the earliest time in ms to fetch positions for
     * @param {int} [limit] the maximum number of positions to retrieve
     * @param {object} params extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
     */
    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object listenKey = await this.authenticate();
        symbols = this.marketSymbols(symbols);
        object messageHash = "positions";
        object messageHashes = new List<object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                object symbolMessageHash = add(add(messageHash, "::"), symbol);
                ((IList<object>)messageHashes).Add(symbolMessageHash);
            }
        } else
        {
            ((IList<object>)messageHashes).Add(messageHash);
        }
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "private"), "?listenKey="), listenKey);
        object positions = await this.watchMultiple(url, messageHashes, parameters, new List<object>() {"private"});
        if (isTrue(this.newUpdates))
        {
            return positions;
        }
        return this.filterBySymbolsSinceLimit(this.positions, symbols, since, limit, true);
    }

    public virtual void handlePosition(WebSocketClient client, object message)
    {
        //
        //     {
        //         "action": "PushPosition",
        //         "result": [
        //             {
        //                 "table": "Position",
        //                 "data": {
        //                     "A": "9256245",
        //                     "CP": 0,
        //                     "I": "DOGE/USDT",
        //                     "M": "9256245",
        //                     "OP": 0.198845,
        //                     "Po": 151.696,
        //                     "U": 1761058213,
        //                     "i": 1,
        //                     "l": 1,
        //                     "p": "0",
        //                     "u": 0
        //                 }
        //             }
        //         ]
        //     }
        //
        object result = this.safeList(message, "result", new List<object>() {});
        object first = this.safeDict(result, 0, new Dictionary<string, object>() {});
        object data = this.safeDict(first, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "I");
        object market = this.safeMarket(marketId, null, "/");
        object symbol = this.safeSymbol(marketId, market);
        object messageHash = "positions";
        object symbolMessageHash = add(add(messageHash, "::"), symbol);
        if (isTrue(isTrue((inOp(client.futures, messageHash))) || isTrue((inOp(client.futures, symbolMessageHash)))))
        {
            if (isTrue(isEqual(this.positions, null)))
            {
                this.positions = new ArrayCacheBySymbolBySide();
            }
            object parsed = this.parseWsPosition(data, market);
            callDynamically(this.positions, "append", new object[] {parsed});
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.positions, messageHash});
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.positions, symbolMessageHash});
        }
    }

    public virtual object parseWsPosition(object position, object market = null)
    {
        //
        //     {
        //         "A": "9256245",
        //         "CP": 0,
        //         "I": "DOGE/USDT",
        //         "M": "9256245",
        //         "OP": 0.198845,
        //         "Po": 151.696,
        //         "U": 1761058213,
        //         "i": 1,
        //         "l": 1,
        //         "p": "0",
        //         "u": 0
        //     }
        //
        object timestamp = this.safeInteger(position, "U");
        object direction = this.safeString(position, "p");
        object marginMode = this.safeString(position, "i");
        return this.safePosition(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "id", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "contracts", this.safeString(position, "Po") },
            { "contractSize", null },
            { "side", this.parsePositionSide(direction) },
            { "notional", null },
            { "leverage", this.omitZero(this.safeString(position, "l")) },
            { "unrealizedPnl", null },
            { "realizedPnl", null },
            { "collateral", null },
            { "entryPrice", this.safeString(position, "OP") },
            { "markPrice", null },
            { "liquidationPrice", null },
            { "marginMode", this.parseWsMarginMode(marginMode) },
            { "hedged", true },
            { "maintenanceMargin", this.safeString(position, "u") },
            { "maintenanceMarginPercentage", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "marginRatio", null },
            { "lastUpdateTimestamp", null },
            { "lastPrice", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
            { "percentage", null },
            { "info", position },
        });
    }

    public virtual object parsePositionSide(object direction)
    {
        if (isTrue(isEqual(direction, null)))
        {
            return direction;
        }
        object directions = new Dictionary<string, object>() {
            { "0", "long" },
            { "1", "short" },
        };
        return this.safeString(directions, direction, direction);
    }

    public virtual object parseWsMarginMode(object marginMode)
    {
        if (isTrue(isEqual(marginMode, null)))
        {
            return marginMode;
        }
        object modes = new Dictionary<string, object>() {
            { "0", "isolated" },
            { "1", "cross" },
        };
        return this.safeString(modes, marginMode, marginMode);
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (isTrue(isEqual(message, "pong")))
        {
            this.handlePong(client as WebSocketClient, message);
        } else
        {
            object m = this.safeString(message, "m");
            if (isTrue(isTrue((!isEqual(m, null))) && isTrue((!isEqual(m, "Success")))))
            {
                this.handleErrorMessage(client as WebSocketClient, message);
            }
            object action = this.safeString2(message, "a", "action");
            if (isTrue(isEqual(action, "RecvTopicAction")))
            {
                this.handleSubscriptionStatus(client as WebSocketClient, message);
            } else if (isTrue(isEqual(action, "PO")))
            {
                this.handleTicker(client as WebSocketClient, message);
            } else if (isTrue(isEqual(action, "PMT")))
            {
                this.handleTrades(client as WebSocketClient, message);
            } else if (isTrue(isEqual(action, "PK")))
            {
                this.handleOHLCV(client as WebSocketClient, message);
            } else if (isTrue(isEqual(action, "PMO")))
            {
                this.handleOrderBook(client as WebSocketClient, message);
            } else if (isTrue(isEqual(action, "PushTrade")))
            {
                this.handleMyTrade(client as WebSocketClient, message);
            } else if (isTrue(isEqual(action, "PushOrder")))
            {
                this.handleOrder(client as WebSocketClient, message);
            } else if (isTrue(isEqual(action, "PushPosition")))
            {
                this.handlePosition(client as WebSocketClient, message);
            }
        }
    }

    public virtual void handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //     {
        //         "a": "RecvTopicAction",
        //         "m": "Success",
        //         "r": [
        //             {
        //                 "d": {
        //                     "A": "0",
        //                     "L": 1,
        //                     "T": "7",
        //                     "F": "DeepCoin_BTC/USDT",
        //                     "R": -1
        //                 }
        //             }
        //         ]
        //     }
        //
        object response = this.safeList(message, "r", new List<object>() {});
        object first = this.safeDict(response, 0, new Dictionary<string, object>() {});
        object data = this.safeDict(first, "d", new Dictionary<string, object>() {});
        object action = this.safeString(data, "A"); // 1 = subscribe, 0 = unsubscribe
        if (isTrue(isEqual(action, "0")))
        {
            object subscriptionsById = this.indexBy(((WebSocketClient)client).subscriptions, "id");
            object subId = this.safeInteger(data, "L");
            object subscription = this.safeDict(subscriptionsById, subId, new Dictionary<string, object>() {}); // original watch subscription
            object subHash = this.safeString(subscription, "subHash");
            object unsubHash = add("unsubscribe::", subHash);
            object unsubsciption = this.safeDict(((WebSocketClient)client).subscriptions, unsubHash, new Dictionary<string, object>() {}); // unWatch subscription
            this.handleUnSubscription(client as WebSocketClient, unsubsciption);
        }
    }

    public virtual void handleUnSubscription(WebSocketClient client, object subscription)
    {
        object subHash = this.safeString(subscription, "subHash");
        object unsubHash = this.safeString(subscription, "unsubHash");
        this.cleanUnsubscription(client as WebSocketClient, subHash, unsubHash);
        this.cleanCache(subscription);
    }

    public virtual void handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //     {
        //         "a": "RecvTopicAction",
        //         "m": "subscription cluster does not "exist": BTC/USD",
        //         "r": [
        //             {
        //                 "d": {
        //                     "A": "1",
        //                     "L": 1,
        //                     "T": "7",
        //                     "F": "DeepCoin_BTC/USD",
        //                     "R": -1
        //                 }
        //             }
        //         ]
        //     }
        //
        object messageText = this.safeString(message, "m", "");
        object response = this.safeList(message, "r", new List<object>() {});
        object first = this.safeDict(response, 0, new Dictionary<string, object>() {});
        object data = this.safeDict(first, "d", new Dictionary<string, object>() {});
        object requestId = this.safeInteger(data, "L");
        object subscriptionsById = this.indexBy(((WebSocketClient)client).subscriptions, "id");
        object subscription = this.safeDict(subscriptionsById, requestId, new Dictionary<string, object>() {});
        object messageHash = this.safeString(subscription, "subHash");
        object feedback = add(add(this.id, " "), this.json(message));
        try
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), messageText, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), messageText, feedback);
            throw new ExchangeError ((string)feedback) ;
        } catch(Exception e)
        {
            ((WebSocketClient)client).reject(e, messageHash);
        }
    }
}
