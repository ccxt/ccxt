namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class kucoinfutures { public kucoinfutures(object args = null) : base(args) { } }
public partial class kucoinfutures : ccxt.kucoinfutures
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchTicker", true },
                { "watchTrades", true },
                { "watchOrderBook", true },
                { "watchOrders", true },
                { "watchBalance", true },
                { "watchPosition", true },
                { "watchPositions", false },
                { "watchPositionForSymbols", false },
                { "watchTradesForSymbols", true },
                { "watchOrderBookForSymbols", true },
            } },
            { "options", new Dictionary<string, object>() {
                { "accountsByType", new Dictionary<string, object>() {
                    { "swap", "future" },
                    { "cross", "margin" },
                } },
                { "tradesLimit", 1000 },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "snapshotDelay", 20 },
                    { "snapshotMaxRetries", 3 },
                } },
                { "watchTicker", new Dictionary<string, object>() {
                    { "name", "contractMarket/tickerV2" },
                } },
                { "watchPosition", new Dictionary<string, object>() {
                    { "fetchPositionSnapshot", true },
                    { "awaitPositionSnapshot", true },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "ping", this.ping },
            } },
        });
    }

    public async virtual Task<object> negotiate(object privateChannel, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object connectId = ((bool) isTrue(privateChannel)) ? "private" : "public";
        object urls = this.safeValue(this.options, "urls", new Dictionary<string, object>() {});
        object spawaned = this.safeValue(urls, connectId);
        if (isTrue(!isEqual(spawaned, null)))
        {
            return await (spawaned as Exchange.Future);
        }
        // we store an awaitable to the url
        // so that multiple calls don't asynchronously
        // fetch different urls and overwrite each other
        ((IDictionary<string,object>)urls)[(string)connectId] = this.spawn(this.negotiateHelper, new object[] { privateChannel, parameters}); // we have to wait here otherwsie in c# will not work
        ((IDictionary<string,object>)this.options)["urls"] = urls;
        var future = getValue(urls, connectId);
        return await (future as Exchange.Future);
    }

    public async virtual Task<object> negotiateHelper(object privateChannel, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = null;
        object connectId = ((bool) isTrue(privateChannel)) ? "private" : "public";
        try
        {
            if (isTrue(privateChannel))
            {
                response = await this.futuresPrivatePostBulletPrivate(parameters);
            } else
            {
                response = await this.futuresPublicPostBulletPublic(parameters);
            }
            object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
            object instanceServers = this.safeValue(data, "instanceServers", new List<object>() {});
            object firstInstanceServer = this.safeValue(instanceServers, 0);
            object pingInterval = this.safeInteger(firstInstanceServer, "pingInterval");
            object endpoint = this.safeString(firstInstanceServer, "endpoint");
            object token = this.safeString(data, "token");
            object result = add(add(endpoint, "?"), this.urlencode(new Dictionary<string, object>() {
    { "token", token },
    { "privateChannel", privateChannel },
    { "connectId", connectId },
}));
            var client = this.client(result);
            client.keepAlive = pingInterval;
            return result;
        } catch(Exception e)
        {
            var future = this.safeValue(getValue(this.options, "urls"), connectId);
            ((Future)future).reject(e);

        }
        return null;
    }

    public virtual object requestId()
    {
        object requestId = this.sum(this.safeInteger(this.options, "requestId", 0), 1);
        ((IDictionary<string,object>)this.options)["requestId"] = requestId;
        return requestId;
    }

    public async virtual Task<object> subscribe(object url, object messageHash, object subscriptionHash, object subscription, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object requestId = ((object)this.requestId()).ToString();
        object request = new Dictionary<string, object>() {
            { "id", requestId },
            { "type", "subscribe" },
            { "topic", subscriptionHash },
            { "response", true },
        };
        object message = this.extend(request, parameters);
        object subscriptionRequest = new Dictionary<string, object>() {
            { "id", requestId },
        };
        if (isTrue(isEqual(subscription, null)))
        {
            subscription = subscriptionRequest;
        } else
        {
            subscription = this.extend(subscriptionRequest, subscription);
        }
        return await this.watch(url, messageHash, message, subscriptionHash, subscription);
    }

    public async virtual Task<object> subscribeMultiple(object url, object messageHashes, object topic, object subscriptionHashes, object subscription, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object requestId = ((object)this.requestId()).ToString();
        object request = new Dictionary<string, object>() {
            { "id", requestId },
            { "type", "subscribe" },
            { "topic", topic },
            { "response", true },
        };
        object message = this.extend(request, parameters);
        object subscriptionRequest = new Dictionary<string, object>() {
            { "id", requestId },
        };
        if (isTrue(isEqual(subscription, null)))
        {
            subscription = subscriptionRequest;
        } else
        {
            subscription = this.extend(subscriptionRequest, subscription);
        }
        return await this.watchMultiple(url, messageHashes, message, subscriptionHashes, subscription);
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name kucoinfutures#watchTicker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://docs.kucoin.com/futures/#get-real-time-symbol-ticker-v2
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object url = await this.negotiate(false);
        object options = this.safeValue(this.options, "watchTicker", new Dictionary<string, object>() {});
        object channel = this.safeString(options, "name", "contractMarket/tickerV2");
        object topic = add(add(add("/", channel), ":"), getValue(market, "id"));
        object messageHash = add("ticker:", symbol);
        return await this.subscribe(url, messageHash, topic, null, parameters);
    }

    public virtual object handleTicker(WebSocketClient client, object message)
    {
        //
        // market/tickerV2
        //
        //    {
        //        "type": "message",
        //        "topic": "/contractMarket/tickerV2:ADAUSDTM",
        //        "subject": "tickerV2",
        //        "data": {
        //            "symbol": "ADAUSDTM",
        //            "sequence": 1668007800439,
        //            "bestBidSize": 178,
        //            "bestBidPrice": "0.35959",
        //            "bestAskPrice": "0.35981",
        //            "ts": "1668141430037124460",
        //            "bestAskSize": 134
        //        }
        //    }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object marketId = this.safeValue(data, "symbol");
        object market = this.safeMarket(marketId, null, "-");
        object ticker = this.parseTicker(data, market);
        ((IDictionary<string,object>)this.tickers)[(string)getValue(market, "symbol")] = ticker;
        object messageHash = add("ticker:", getValue(market, "symbol"));
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
        return message;
    }

    public async override Task<object> watchPosition(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoinfutures#watchPosition
        * @description watch open positions for a specific symbol
        * @see https://docs.kucoin.com/futures/#position-change-events
        * @param {string|undefined} symbol unified market symbol
        * @param {object} params extra parameters specific to the exchange API endpoint
        * @returns {object} a [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchPosition() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object url = await this.negotiate(true);
        object market = this.market(symbol);
        object topic = add("/contract/position:", getValue(market, "id"));
        object request = new Dictionary<string, object>() {
            { "privateChannel", true },
        };
        object messageHash = add("position:", getValue(market, "symbol"));
        var client = this.client(url);
        this.setPositionCache(client as WebSocketClient, symbol);
        object fetchPositionSnapshot = this.handleOption("watchPosition", "fetchPositionSnapshot", true);
        object awaitPositionSnapshot = this.safeValue("watchPosition", "awaitPositionSnapshot", true);
        object currentPosition = this.getCurrentPosition(symbol);
        if (isTrue(isTrue(isTrue(fetchPositionSnapshot) && isTrue(awaitPositionSnapshot)) && isTrue(isEqual(currentPosition, null))))
        {
            object snapshot = await client.future(add("fetchPositionSnapshot:", symbol));
            return snapshot;
        }
        return await this.subscribe(url, messageHash, topic, null, this.extend(request, parameters));
    }

    public virtual object getCurrentPosition(object symbol)
    {
        if (isTrue(isEqual(this.positions, null)))
        {
            return null;
        }
        object cache = (this.positions as ArrayCacheBySymbolById).hashmap;
        object symbolCache = this.safeValue(cache, symbol, new Dictionary<string, object>() {});
        object values = new List<object>(((IDictionary<string,object>)symbolCache).Values);
        return this.safeValue(values, 0);
    }

    public virtual void setPositionCache(WebSocketClient client, object symbol)
    {
        object fetchPositionSnapshot = this.handleOption("watchPosition", "fetchPositionSnapshot", false);
        if (isTrue(fetchPositionSnapshot))
        {
            object messageHash = add("fetchPositionSnapshot:", symbol);
            if (!isTrue((inOp(client.futures, messageHash))))
            {
                client.future(messageHash);
                this.spawn(this.loadPositionSnapshot, new object[] { client, messageHash, symbol});
            }
        }
    }

    public async virtual Task loadPositionSnapshot(WebSocketClient client, object messageHash, object symbol)
    {
        object position = await this.fetchPosition(symbol);
        this.positions = new ArrayCacheBySymbolById();
        object cache = this.positions;
        callDynamically(cache, "append", new object[] {position});
        // don't remove the future from the .futures cache
        var future = getValue(client.futures, messageHash);
        (future as Future).resolve(cache);
        callDynamically(client as WebSocketClient, "resolve", new object[] {position, add("position:", symbol)});
    }

    public virtual void handlePosition(WebSocketClient client, object message)
    {
        //
        // Position Changes Caused Operations
        //    {
        //        "type": "message",
        //        "userId": "5c32d69203aa676ce4b543c7", // Deprecated, will detele later
        //        "channelType": "private",
        //        "topic": "/contract/position:XBTUSDM",
        //        "subject": "position.change",
        //        "data": {
        //            "realisedGrossPnl": 0E-8, //Accumulated realised profit and loss
        //            "symbol": "XBTUSDM", //Symbol
        //            "crossMode": false, //Cross mode or not
        //            "liquidationPrice": 1000000.0, //Liquidation price
        //            "posLoss": 0E-8, //Manually added margin amount
        //            "avgEntryPrice": 7508.22, //Average entry price
        //            "unrealisedPnl": -0.00014735, //Unrealised profit and loss
        //            "markPrice": 7947.83, //Mark price
        //            "posMargin": 0.00266779, //Position margin
        //            "autoDeposit": false, //Auto deposit margin or not
        //            "riskLimit": 100000, //Risk limit
        //            "unrealisedCost": 0.00266375, //Unrealised value
        //            "posComm": 0.00000392, //Bankruptcy cost
        //            "posMaint": 0.00001724, //Maintenance margin
        //            "posCost": 0.00266375, //Position value
        //            "maintMarginReq": 0.005, //Maintenance margin rate
        //            "bankruptPrice": 1000000.0, //Bankruptcy price
        //            "realisedCost": 0.00000271, //Currently accumulated realised position value
        //            "markValue": 0.00251640, //Mark value
        //            "posInit": 0.00266375, //Position margin
        //            "realisedPnl": -0.00000253, //Realised profit and losts
        //            "maintMargin": 0.00252044, //Position margin
        //            "realLeverage": 1.06, //Leverage of the order
        //            "changeReason": "positionChange", //changeReason:marginChange、positionChange、liquidation、autoAppendMarginStatusChange、adl
        //            "currentCost": 0.00266375, //Current position value
        //            "openingTimestamp": 1558433191000, //Open time
        //            "currentQty": -20, //Current position
        //            "delevPercentage": 0.52, //ADL ranking percentile
        //            "currentComm": 0.00000271, //Current commission
        //            "realisedGrossCost": 0E-8, //Accumulated reliased gross profit value
        //            "isOpen": true, //Opened position or not
        //            "posCross": 1.2E-7, //Manually added margin
        //            "currentTimestamp": 1558506060394, //Current timestamp
        //            "unrealisedRoePcnt": -0.0553, //Rate of return on investment
        //            "unrealisedPnlPcnt": -0.0553, //Position profit and loss ratio
        //            "settleCurrency": "XBT" //Currency used to clear and settle the trades
        //        }
        //    }
        // Position Changes Caused by Mark Price
        //    {
        //        "userId": "5cd3f1a7b7ebc19ae9558591", // Deprecated, will detele later
        //        "topic": "/contract/position:XBTUSDM",
        //        "subject": "position.change",
        //          "data": {
        //              "markPrice": 7947.83,                   //Mark price
        //              "markValue": 0.00251640,                 //Mark value
        //              "maintMargin": 0.00252044,              //Position margin
        //              "realLeverage": 10.06,                   //Leverage of the order
        //              "unrealisedPnl": -0.00014735,           //Unrealised profit and lost
        //              "unrealisedRoePcnt": -0.0553,           //Rate of return on investment
        //              "unrealisedPnlPcnt": -0.0553,            //Position profit and loss ratio
        //              "delevPercentage": 0.52,             //ADL ranking percentile
        //              "currentTimestamp": 1558087175068,      //Current timestamp
        //              "settleCurrency": "XBT"                 //Currency used to clear and settle the trades
        //          }
        //    }
        //  Funding Settlement
        //    {
        //        "userId": "xbc453tg732eba53a88ggyt8c", // Deprecated, will detele later
        //        "topic": "/contract/position:XBTUSDM",
        //        "subject": "position.settlement",
        //        "data": {
        //            "fundingTime": 1551770400000,          //Funding time
        //            "qty": 100,                            //Position siz
        //            "markPrice": 3610.85,                 //Settlement price
        //            "fundingRate": -0.002966,             //Funding rate
        //            "fundingFee": -296,                   //Funding fees
        //            "ts": 1547697294838004923,             //Current time (nanosecond)
        //            "settleCurrency": "XBT"                //Currency used to clear and settle the trades
        //        }
        //    }
        // Adjustmet result of risk limit level
        //     {
        //         "userId": "xbc453tg732eba53a88ggyt8c",
        //         "topic": "/contract/position:ADAUSDTM",
        //         "subject": "position.adjustRiskLimit",
        //         "data": {
        //           "success": true, // Successful or not
        //           "riskLimitLevel": 1, // Current risk limit level
        //           "msg": "" // Failure reason
        //         }
        //     }
        //
        object topic = this.safeString(message, "topic", "");
        object parts = ((string)topic).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(parts, 1);
        object symbol = this.safeSymbol(marketId, null, "");
        object cache = this.positions;
        object currentPosition = this.getCurrentPosition(symbol);
        object messageHash = add("position:", symbol);
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object newPosition = this.parsePosition(data);
        object keys = new List<object>(((IDictionary<string,object>)newPosition).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            if (isTrue(isEqual(getValue(newPosition, key), null)))
            {

            }
        }
        object position = this.extend(currentPosition, newPosition);
        callDynamically(cache, "append", new object[] {position});
        callDynamically(client as WebSocketClient, "resolve", new object[] {position, messageHash});
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoinfutures#watchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://docs.kucoin.com/futures/#execution-data
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoinfutures#watchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        object symbolsLength = getArrayLength(symbols);
        if (isTrue(isEqual(symbolsLength, 0)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchTradesForSymbols() requires a non-empty array of symbols")) ;
        }
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object url = await this.negotiate(false);
        symbols = this.marketSymbols(symbols);
        object marketIds = this.marketIds(symbols);
        object topic = add("/contractMarket/execution:", String.Join(",", ((IList<object>)marketIds).ToArray()));
        object subscriptionHashes = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object marketId = getValue(marketIds, i);
            ((IList<object>)messageHashes).Add(add("trades:", symbol));
            ((IList<object>)subscriptionHashes).Add(add("/contractMarket/execution:", marketId));
        }
        object trades = await this.subscribeMultiple(url, messageHashes, topic, subscriptionHashes, parameters);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeValue(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual object handleTrade(WebSocketClient client, object message)
    {
        //
        //    {
        //        "type": "message",
        //        "topic": "/contractMarket/execution:ADAUSDTM",
        //        "subject": "match",
        //        "data": {
        //            "makerUserId": "62286a4d720edf0001e81961",
        //            "symbol": "ADAUSDTM",
        //            "sequence": 41320766,
        //            "side": "sell",
        //            "size": 2,
        //            "price": 0.35904,
        //            "takerOrderId": "636dd9da9857ba00010cfa44",
        //            "makerOrderId": "636dd9c8df149d0001e62bc8",
        //            "takerUserId": "6180be22b6ab210001fa3371",
        //            "tradeId": "636dd9da0000d400d477eca7",
        //            "ts": 1668143578987357700
        //        }
        //    }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object trade = this.parseTrade(data);
        object symbol = getValue(trade, "symbol");
        object trades = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(trades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            trades = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = trades;
        }
        callDynamically(trades, "append", new object[] {trade});
        object messageHash = add("trades:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {trades, messageHash});
        return message;
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoinfutures#watchOrderBook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        *   1. After receiving the websocket Level 2 data flow, cache the data.
        *   2. Initiate a REST request to get the snapshot data of Level 2 order book.
        *   3. Playback the cached Level 2 data flow.
        *   4. Apply the new Level 2 data flow to the local snapshot to ensure that the sequence of the new Level 2 update lines up with the sequence of the previous Level 2 data. Discard all the message prior to that sequence, and then playback the change to snapshot.
        *   5. Update the level2 full data based on sequence according to the size. If the price is 0, ignore the messages and update the sequence. If the size=0, update the sequence and remove the price of which the size is 0 out of level 2. For other cases, please update the price.
        *   6. If the sequence of the newly pushed message does not line up to the sequence of the last message, you could pull through REST Level 2 message request to get the updated messages. Please note that the difference between the start and end parameters cannot exceed 500.
        * @see https://docs.kucoin.com/futures/#level-2-market-data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchOrderBookForSymbols(new List<object>() {symbol}, limit, parameters);
    }

    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoinfutures#watchOrderBookForSymbols
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string[]} symbols unified array of symbols
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        object symbolsLength = getArrayLength(symbols);
        if (isTrue(isEqual(symbolsLength, 0)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchOrderBookForSymbols() requires a non-empty array of symbols")) ;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(isTrue((!isEqual(limit, 20))) && isTrue((!isEqual(limit, 100)))))
            {
                throw new ExchangeError ((string)add(this.id, " watchOrderBook \'limit\' argument must be undefined, 20 or 100")) ;
            }
        }
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object marketIds = this.marketIds(symbols);
        object url = await this.negotiate(false);
        object topic = add("/contractMarket/level2:", String.Join(",", ((IList<object>)marketIds).ToArray()));
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleOrderBookSubscription },
            { "symbols", symbols },
            { "limit", limit },
        };
        object subscriptionHashes = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object marketId = getValue(marketIds, i);
            ((IList<object>)messageHashes).Add(add("orderbook:", symbol));
            ((IList<object>)subscriptionHashes).Add(add("/contractMarket/level2:", marketId));
        }
        object orderbook = await this.subscribeMultiple(url, messageHashes, topic, subscriptionHashes, subscription, parameters);
        return (orderbook as IOrderBook).limit();
    }

    public override void handleDelta(object orderbook, object delta)
    {
        ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger(delta, "sequence");
        object timestamp = this.safeInteger(delta, "timestamp");
        ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
        ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        object change = this.safeValue(delta, "change", new Dictionary<string, object>() {});
        object splitChange = ((string)change).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
        object price = this.safeNumber(splitChange, 0);
        object side = this.safeString(splitChange, 1);
        object quantity = this.safeNumber(splitChange, 2);
        object type = ((bool) isTrue((isEqual(side, "buy")))) ? "bids" : "asks";
        object value = new List<object>() {price, quantity};
        if (isTrue(isEqual(type, "bids")))
        {
            object storedBids = getValue(orderbook, "bids");
            (storedBids as IOrderBookSide).storeArray(value);
        } else
        {
            object storedAsks = getValue(orderbook, "asks");
            (storedAsks as IOrderBookSide).storeArray(value);
        }
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        // initial snapshot is fetched with ccxt's fetchOrderBook
        // the feed does not include a snapshot, just the deltas
        //
        //    {
        //        "type": "message",
        //        "topic": "/contractMarket/level2:ADAUSDTM",
        //        "subject": "level2",
        //        "data": {
        //            "sequence": 1668059586457,
        //            "change": "0.34172,sell,456", // type, side, quantity
        //            "timestamp": 1668573023223
        //        }
        //    }
        //
        object data = this.safeValue(message, "data");
        object topic = this.safeString(message, "topic");
        object topicParts = ((string)topic).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(topicParts, 1);
        object symbol = this.safeSymbol(marketId, null, "-");
        object messageHash = add("orderbook:", symbol);
        object storedOrderBook = this.safeValue(this.orderbooks, symbol);
        object nonce = this.safeInteger(storedOrderBook, "nonce");
        if (isTrue(isEqual(storedOrderBook, null)))
        {
            return;  // this shouldn't be needed, but for some reason sometimes this runs before handleOrderBookSubscription in c#
        }
        object deltaEnd = this.safeInteger(data, "sequence");
        if (isTrue(isEqual(nonce, null)))
        {
            object cacheLength = getArrayLength((storedOrderBook as ccxt.pro.OrderBook).cache);
            object topicPartsNew = ((string)topic).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
            object topicSymbol = this.safeString(topicPartsNew, 1);
            object topicChannel = this.safeString(topicPartsNew, 0);
            object subscriptions = new List<object>(((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Keys);
            object subscription = null;
            for (object i = 0; isLessThan(i, getArrayLength(subscriptions)); postFixIncrement(ref i))
            {
                object key = getValue(subscriptions, i);
                if (isTrue(isTrue((isGreaterThanOrEqual(getIndexOf(key, topicSymbol), 0))) && isTrue((isGreaterThanOrEqual(getIndexOf(key, topicChannel), 0)))))
                {
                    subscription = getValue(((WebSocketClient)client).subscriptions, key);
                    break;
                }
            }
            object limit = this.safeInteger(subscription, "limit");
            object snapshotDelay = this.handleOption("watchOrderBook", "snapshotDelay", 5);
            if (isTrue(isEqual(cacheLength, snapshotDelay)))
            {
                this.spawn(this.loadOrderBook, new object[] { client, messageHash, symbol, limit, new Dictionary<string, object>() {}});
            }
            ((IList<object>)(storedOrderBook as ccxt.pro.OrderBook).cache).Add(data);
            return;
        } else if (isTrue(isGreaterThanOrEqual(nonce, deltaEnd)))
        {
            return;
        }
        this.handleDelta(storedOrderBook, data);
        callDynamically(client as WebSocketClient, "resolve", new object[] {storedOrderBook, messageHash});
    }

    public override object getCacheIndex(object orderbook, object cache)
    {
        object firstDelta = this.safeValue(cache, 0);
        object nonce = this.safeInteger(orderbook, "nonce");
        object firstDeltaStart = this.safeInteger(firstDelta, "sequence");
        if (isTrue(isLessThan(nonce, subtract(firstDeltaStart, 1))))
        {
            return -1;
        }
        for (object i = 0; isLessThan(i, getArrayLength(cache)); postFixIncrement(ref i))
        {
            object delta = getValue(cache, i);
            object deltaStart = this.safeInteger(delta, "sequence");
            if (isTrue(isLessThan(nonce, subtract(deltaStart, 1))))
            {
                return i;
            }
        }
        return getArrayLength(cache);
    }

    public virtual void handleOrderBookSubscription(WebSocketClient client, object message, object subscription)
    {
        object limit = this.safeInteger(subscription, "limit");
        object symbols = this.safeValue(subscription, "symbols");
        if (isTrue(isEqual(symbols, null)))
        {
            object symbol = this.safeString(subscription, "symbol");
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
        } else
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
            }
        }
    }

    public virtual void handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //     {
        //         "id": "1578090438322",
        //         "type": "ack"
        //     }
        //
        object id = this.safeString(message, "id");
        object subscriptionsById = this.indexBy(((WebSocketClient)client).subscriptions, "id");
        object subscription = this.safeValue(subscriptionsById, id, new Dictionary<string, object>() {});
        object method = this.safeValue(subscription, "method");
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message, subscription});
        }
    }

    public virtual object handleSystemStatus(WebSocketClient client, object message)
    {
        //
        // todo: answer the question whether handleSystemStatus should be renamed
        // and unified as handleStatus for any usage pattern that
        // involves system status and maintenance updates
        //
        //     {
        //         "id": "1578090234088", // connectId
        //         "type": "welcome",
        //     }
        //
        return message;
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoinfutures#watchOrders
        * @description watches information on multiple orders made by the user
        * @see https://docs.kucoin.com/futures/#trade-orders-according-to-the-market
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object url = await this.negotiate(true);
        object topic = "/contractMarket/tradeOrders";
        object request = new Dictionary<string, object>() {
            { "privateChannel", true },
        };
        object messageHash = "orders";
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            symbol = getValue(market, "symbol");
            messageHash = add(add(messageHash, ":"), symbol);
        }
        object orders = await this.subscribe(url, messageHash, topic, null, this.extend(request, parameters));
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual object parseWsOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "open", "open" },
            { "filled", "closed" },
            { "match", "open" },
            { "update", "open" },
            { "canceled", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        //         "symbol": "XCAD-USDT",
        //     {
        //         "orderType": "limit",
        //         "side": "buy",
        //         "orderId": "6249167327218b000135e749",
        //         "type": "canceled",
        //         "orderTime": 1648957043065280224,
        //         "size": "100.452",
        //         "filledSize": "0",
        //         "price": "2.9635",
        //         "clientOid": "buy-XCAD-USDT-1648957043010159",
        //         "remainSize": "0",
        //         "status": "done",
        //         "ts": 1648957054031001037
        //     }
        //
        object id = this.safeString(order, "orderId");
        object clientOrderId = this.safeString(order, "clientOid");
        object orderType = this.safeStringLower(order, "orderType");
        object price = this.safeString(order, "price");
        object filled = this.safeString(order, "filledSize");
        object amount = this.safeString(order, "size");
        object rawType = this.safeString(order, "type");
        object status = this.parseWsOrderStatus(rawType);
        object timestamp = this.safeIntegerProduct(order, "orderTime", 0.000001);
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object side = this.safeStringLower(order, "side");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "symbol", symbol },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "type", orderType },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", null },
            { "amount", amount },
            { "cost", null },
            { "average", null },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        object messageHash = "orders";
        object data = this.safeValue(message, "data");
        object parsed = this.parseWsOrder(data);
        object symbol = this.safeString(parsed, "symbol");
        object orderId = this.safeString(parsed, "id");
        if (isTrue(!isEqual(symbol, null)))
        {
            if (isTrue(isEqual(this.orders, null)))
            {
                object limit = this.safeInteger(this.options, "ordersLimit", 1000);
                this.orders = new ArrayCacheBySymbolById(limit);
            }
            object cachedOrders = this.orders;
            object orders = this.safeValue((cachedOrders as ArrayCacheBySymbolById).hashmap, symbol, new Dictionary<string, object>() {});
            object order = this.safeValue(orders, orderId);
            if (isTrue(!isEqual(order, null)))
            {
                // todo add others to calculate average etc
                object stopPrice = this.safeValue(order, "stopPrice");
                if (isTrue(!isEqual(stopPrice, null)))
                {
                    ((IDictionary<string,object>)parsed)["stopPrice"] = stopPrice;
                }
                if (isTrue(isEqual(getValue(order, "status"), "closed")))
                {
                    ((IDictionary<string,object>)parsed)["status"] = "closed";
                }
            }
            callDynamically(cachedOrders, "append", new object[] {parsed});
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageHash});
            object symbolSpecificMessageHash = add(add(messageHash, ":"), symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, symbolSpecificMessageHash});
        }
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @name kucoinfutures#watchBalance
        * @description watch balance and get the amount of funds available for trading or funds locked in orders
        * @see https://docs.kucoin.com/futures/#account-balance-events
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object url = await this.negotiate(true);
        object topic = "/contractAccount/wallet";
        object request = new Dictionary<string, object>() {
            { "privateChannel", true },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleBalanceSubscription },
        };
        object messageHash = "balance";
        return await this.subscribe(url, messageHash, topic, subscription, this.extend(request, parameters));
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        //    {
        //        "id": "6375553193027a0001f6566f",
        //        "type": "message",
        //        "topic": "/contractAccount/wallet",
        //        "userId": "613a896885d8660006151f01",
        //        "channelType": "private",
        //        "subject": "availableBalance.change",
        //        "data": {
        //            "currency": "USDT",
        //            "holdBalance": "0.0000000000",
        //            "availableBalance": "14.0350281903",
        //            "timestamp": "1668633905657"
        //        }
        //    }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        ((IDictionary<string,object>)this.balance)["info"] = data;
        object currencyId = this.safeString(data, "currency");
        object code = this.safeCurrencyCode(currencyId);
        object account = this.account();
        ((IDictionary<string,object>)account)["free"] = this.safeString(data, "availableBalance");
        ((IDictionary<string,object>)account)["used"] = this.safeString(data, "holdBalance");
        ((IDictionary<string,object>)this.balance)[(string)code] = account;
        this.balance = this.safeBalance(this.balance);
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, "balance"});
    }

    public virtual void handleBalanceSubscription(WebSocketClient client, object message, object subscription)
    {
        this.spawn(this.fetchBalanceSnapshot, new object[] { client, message});
    }

    public async virtual Task fetchBalanceSnapshot(WebSocketClient client, object message)
    {
        await this.loadMarkets();
        this.checkRequiredCredentials();
        object messageHash = "balance";
        object selectedType = this.safeString2(this.options, "watchBalance", "defaultType", "swap"); // spot, margin, main, funding, future, mining, trade, contract, pool
        object parameters = new Dictionary<string, object>() {
            { "type", selectedType },
        };
        object snapshot = await this.fetchBalance(parameters);
        //
        //    {
        //        "info": {
        //            "code": "200000",
        //            "data": {
        //                "accountEquity": 0.0350281903,
        //                "unrealisedPNL": 0,
        //                "marginBalance": 0.0350281903,
        //                "positionMargin": 0,
        //                "orderMargin": 0,
        //                "frozenFunds": 0,
        //                "availableBalance": 0.0350281903,
        //                "currency": "USDT"
        //            }
        //        },
        //        "timestamp": undefined,
        //        "datetime": undefined,
        //        "USDT": {
        //            "free": 0.0350281903,
        //            "used": 0,
        //            "total": 0.0350281903
        //        },
        //        "free": {
        //            "USDT": 0.0350281903
        //        },
        //        "used": {
        //            "USDT": 0
        //        },
        //        "total": {
        //            "USDT": 0.0350281903
        //        }
        //    }
        //
        object keys = new List<object>(((IDictionary<string,object>)snapshot).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object code = getValue(keys, i);
            if (isTrue(isTrue(isTrue(isTrue(isTrue(isTrue(!isEqual(code, "free")) && isTrue(!isEqual(code, "used"))) && isTrue(!isEqual(code, "total"))) && isTrue(!isEqual(code, "timestamp"))) && isTrue(!isEqual(code, "datetime"))) && isTrue(!isEqual(code, "info"))))
            {
                ((IDictionary<string,object>)this.balance)[(string)code] = getValue(snapshot, code);
            }
        }
        ((IDictionary<string,object>)this.balance)["info"] = this.safeValue(snapshot, "info", new Dictionary<string, object>() {});
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, messageHash});
    }

    public virtual void handleSubject(WebSocketClient client, object message)
    {
        //
        //    {
        //        "type": "message",
        //        "topic": "/contractMarket/level2:ADAUSDTM",
        //        "subject": "level2",
        //        "data": {
        //            "sequence": 1668059586457,
        //            "change": "0.34172,sell,456", // type, side, quantity
        //            "timestamp": 1668573023223
        //        }
        //    }
        //
        object subject = this.safeString(message, "subject");
        object methods = new Dictionary<string, object>() {
            { "level2", this.handleOrderBook },
            { "tickerV2", this.handleTicker },
            { "availableBalance.change", this.handleBalance },
            { "match", this.handleTrade },
            { "orderChange", this.handleOrder },
            { "orderUpdated", this.handleOrder },
            { "position.change", this.handlePosition },
            { "position.settlement", this.handlePosition },
            { "position.adjustRiskLimit", this.handlePosition },
        };
        object method = this.safeValue(methods, subject);
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
    }

    public override object ping(WebSocketClient client)
    {
        // kucoin does not support built-in ws protocol-level ping-pong
        // instead it requires a custom json-based text ping-pong
        // https://docs.kucoin.com/#ping
        object id = ((object)this.requestId()).ToString();
        return new Dictionary<string, object>() {
            { "id", id },
            { "type", "ping" },
        };
    }

    public virtual object handlePong(WebSocketClient client, object message)
    {
        // https://docs.kucoin.com/#ping
        client.lastPong = this.milliseconds();
        return message;
    }

    public virtual void handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //    {
        //        "id": "64d8732c856851144bded10d",
        //        "type": "error",
        //        "code": 401,
        //        "data": "token is expired"
        //    }
        //
        object data = this.safeString(message, "data", "");
        if (isTrue(isEqual(data, "token is expired")))
        {
            object type = "public";
            if (isTrue(isGreaterThanOrEqual(getIndexOf(client.url, "connectId=private"), 0)))
            {
                type = "private";
            }
            ((IDictionary<string,object>)getValue(this.options, "urls"))[(string)type] = null;
        }
        this.handleErrors(null, null, client.url, null, null, data, message, null, null);
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        object type = this.safeString(message, "type");
        object methods = new Dictionary<string, object>() {
            { "welcome", this.handleSystemStatus },
            { "ack", this.handleSubscriptionStatus },
            { "message", this.handleSubject },
            { "pong", this.handlePong },
            { "error", this.handleErrorMessage },
        };
        object method = this.safeValue(methods, type);
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
    }
}
