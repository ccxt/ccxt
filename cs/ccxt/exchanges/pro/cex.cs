namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class cex { public cex(object args = null) : base(args) { } }
public partial class cex : ccxt.cex
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchBalance", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", false },
                { "watchMyTrades", true },
                { "watchOrders", true },
                { "watchOrderBook", true },
                { "watchOHLCV", true },
                { "watchPosition", null },
                { "createOrderWs", true },
                { "editOrderWs", true },
                { "cancelOrderWs", true },
                { "cancelOrdersWs", true },
                { "fetchOrderWs", true },
                { "fetchOpenOrdersWs", true },
                { "fetchTickerWs", true },
                { "fetchBalanceWs", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", "wss://ws.cex.io/ws" },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "orderbook", new Dictionary<string, object>() {} },
            } },
            { "streaming", new Dictionary<string, object>() {} },
            { "exceptions", new Dictionary<string, object>() {} },
        });
    }

    public virtual object requestId()
    {
        object requestId = this.sum(this.safeInteger(this.options, "requestId", 0), 1);
        ((IDictionary<string,object>)this.options)["requestId"] = requestId;
        return ((object)requestId).ToString();
    }

    /**
     * @method
     * @name cex#watchBalance
     * @description watch balance and get the amount of funds available for trading or funds locked in orders
     * @see https://cex.io/websocket-api#get-balance
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticate(parameters);
        object messageHash = this.requestId();
        object url = getValue(getValue(this.urls, "api"), "ws");
        object subscribe = new Dictionary<string, object>() {
            { "e", "get-balance" },
            { "data", new Dictionary<string, object>() {} },
            { "oid", this.requestId() },
        };
        object request = this.deepExtend(subscribe, parameters);
        return await this.watch(url, messageHash, request, messageHash, request);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        //     {
        //         "e": "get-balance",
        //         "data": {
        //             "balance": {
        //                 "BTC": "0.00000000",
        //                 "USD": "0.00",
        //                 ...
        //             },
        //             "obalance": {
        //                 "BTC": "0.00000000",
        //                 "USD": "0.00",
        //                 ...
        //             },
        //             "time": 1663761159605
        //         },
        //         "oid": 1,
        //         "ok": "ok"
        //     }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object freeBalance = this.safeValue(data, "balance", new Dictionary<string, object>() {});
        object usedBalance = this.safeValue(data, "obalance", new Dictionary<string, object>() {});
        object result = new Dictionary<string, object>() {
            { "info", data },
        };
        object currencyIds = new List<object>(((IDictionary<string,object>)freeBalance).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencyIds, i);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(freeBalance, currencyId);
            ((IDictionary<string,object>)account)["used"] = this.safeString(usedBalance, currencyId);
            object code = this.safeCurrencyCode(currencyId);
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        this.balance = this.safeBalance(result);
        object messageHash = this.safeString(message, "oid");
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, messageHash});
    }

    /**
     * @method
     * @name cex#watchTrades
     * @description get the list of most recent trades for a particular symbol. Note: can only watch one symbol at a time.
     * @see https://cex.io/websocket-api#old-pair-room
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object url = getValue(getValue(this.urls, "api"), "ws");
        object messageHash = "trades";
        object subscriptionHash = add("old:", symbol);
        ((IDictionary<string,object>)this.options)["currentWatchTradeSymbol"] = symbol; // exchange supports only 1 symbol for this watchTrades channel
        var client = this.safeValue(this.clients, url);
        if (isTrue(!isEqual(client as WebSocketClient, null)))
        {
            object subscriptionKeys = new List<object>(((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(subscriptionKeys)); postFixIncrement(ref i))
            {
                object subscriptionKey = getValue(subscriptionKeys, i);
                if (isTrue(isEqual(subscriptionKey, subscriptionHash)))
                {
                    continue;
                }
                subscriptionKey = slice(subscriptionKey, 0, 3);
                if (isTrue(isEqual(subscriptionKey, "old")))
                {
                    throw new ExchangeError ((string)add(this.id, " watchTrades() only supports watching one symbol at a time.")) ;
                }
            }
        }
        object message = new Dictionary<string, object>() {
            { "e", "subscribe" },
            { "rooms", new List<object>() {add(add(add("pair-", getValue(market, "base")), "-"), getValue(market, "quote"))} },
        };
        object request = this.deepExtend(message, parameters);
        object trades = await this.watch(url, messageHash, request, subscriptionHash);
        // assing symbol to the trades as message does not contain symbol information
        for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
        {
            ((IDictionary<string,object>)getValue(trades, i))["symbol"] = symbol;
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTradesSnapshot(WebSocketClient client, object message)
    {
        //
        //     {
        //         "e": "history",
        //         "data": [
        //            'buy:1710255706095:444444:71222.2:14892622'
        //            'sell:1710255658251:42530:71300:14892621'
        //            'buy:1710252424241:87913:72800:14892620'
        //            ... timestamp descending
        //         ]
        //     }
        //
        object data = this.safeList(message, "data", new List<object>() {});
        object limit = this.safeInteger(this.options, "tradesLimit", 1000);
        var stored = new ArrayCache(limit);
        object symbol = this.safeString(this.options, "currentWatchTradeSymbol");
        if (isTrue(isEqual(symbol, null)))
        {
            return;
        }
        object market = this.market(symbol);
        object dataLength = getArrayLength(data);
        for (object i = 0; isLessThan(i, dataLength); postFixIncrement(ref i))
        {
            object index = subtract(subtract(dataLength, 1), i);
            object rawTrade = getValue(data, index);
            object parsed = this.parseWsOldTrade(rawTrade, market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        object messageHash = "trades";
        this.trades = ((object)stored); // trades don't have symbol
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.trades, messageHash});
    }

    public virtual object parseWsOldTrade(object trade, object market = null)
    {
        //
        //  snapshot trade
        //    "sell:1665467367741:3888551:19058.8:14541219"
        //  update trade
        //    ['buy', '1665467516704', '98070', "19057.7", "14541220"]
        //
        if (!isTrue(((trade is IList<object>) || (trade.GetType().IsGenericType && trade.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            trade = ((string)trade).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
        }
        object side = this.safeString(trade, 0);
        object timestamp = this.safeInteger(trade, 1);
        object amount = this.safeString(trade, 2);
        object price = this.safeString(trade, 3);
        object id = this.safeString(trade, 4);
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", this.safeString(market, "symbol") },
            { "type", null },
            { "side", side },
            { "order", null },
            { "takerOrMaker", null },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", null },
        }, market);
    }

    public virtual void handleTrade(WebSocketClient client, object message)
    {
        //
        //     {
        //         "e": "history-update",
        //         "data": [
        //             ['buy', '1665467516704', '98070', "19057.7", "14541220"]
        //         ]
        //     }
        //
        object data = this.safeValue(message, "data", new List<object>() {});
        object stored = ((object)this.trades); // to do fix this, this.trades is not meant to be used like this
        object dataLength = getArrayLength(data);
        for (object i = 0; isLessThan(i, dataLength); postFixIncrement(ref i))
        {
            object index = subtract(subtract(dataLength, 1), i);
            object rawTrade = getValue(data, index);
            object parsed = this.parseWsOldTrade(rawTrade);
            callDynamically(stored, "append", new object[] {parsed});
        }
        object messageHash = "trades";
        this.trades = stored;
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.trades, messageHash});
    }

    /**
     * @method
     * @name cex#watchTicker
     * @see https://cex.io/websocket-api#ticker-subscription
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.method] public or private
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object url = getValue(getValue(this.urls, "api"), "ws");
        object messageHash = add("ticker:", symbol);
        object method = this.safeString(parameters, "method", "private"); // default to private because the specified ticker is received quicker
        object message = ((object)new Dictionary<string, object>() {
            { "e", "subscribe" },
            { "rooms", new List<object>() {"tickers"} },
        });
        object subscriptionHash = "tickers";
        if (isTrue(isEqual(method, "private")))
        {
            await this.authenticate();
            message = new Dictionary<string, object>() {
                { "e", "ticker" },
                { "data", new List<object>() {getValue(market, "baseId"), getValue(market, "quoteId")} },
                { "oid", this.requestId() },
            };
            subscriptionHash = add("ticker:", symbol);
        }
        object request = this.deepExtend(message, parameters);
        return await this.watch(url, messageHash, request, subscriptionHash);
    }

    /**
     * @method
     * @name cex#watchTickers
     * @see https://cex.io/websocket-api#ticker-subscription
     * @description watches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object messageHash = "tickers";
        object message = new Dictionary<string, object>() {
            { "e", "subscribe" },
            { "rooms", new List<object>() {"tickers"} },
        };
        object request = this.deepExtend(message, parameters);
        object ticker = await this.watch(url, messageHash, request, messageHash);
        object tickerSymbol = getValue(ticker, "symbol");
        if (isTrue(isTrue(!isEqual(symbols, null)) && !isTrue(this.inArray(tickerSymbol, symbols))))
        {
            return await this.watchTickers(symbols, parameters);
        }
        if (isTrue(this.newUpdates))
        {
            object result = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)result)[(string)tickerSymbol] = ticker;
            return result;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    /**
     * @method
     * @name cex#fetchTickerWs
     * @see https://docs.cex.io/#ws-api-ticker-deprecated
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the cex api endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickerWs(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object messageHash = this.requestId();
        object request = this.extend(new Dictionary<string, object>() {
            { "e", "ticker" },
            { "oid", messageHash },
            { "data", new List<object>() {getValue(market, "base"), getValue(market, "quote")} },
        }, parameters);
        return await this.watch(url, messageHash, request, messageHash);
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        //     {
        //         "e": "tick",
        //         "data": {
        //             "symbol1": "LRC",
        //             "symbol2": "USD",
        //             "price": "0.305",
        //             "open24": "0.301",
        //             "volume": "241421.641700"
        //         }
        //     }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object ticker = this.parseWsTicker(data);
        object symbol = getValue(ticker, "symbol");
        if (isTrue(isEqual(symbol, null)))
        {
            return;
        }
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
        object messageHash = add("ticker:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, "tickers"});
        messageHash = this.safeString(message, "oid");
        if (isTrue(!isEqual(messageHash, null)))
        {
            callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
        }
    }

    public virtual object parseWsTicker(object ticker, object market = null)
    {
        //
        //  public
        //    {
        //        "symbol1": "LRC",
        //        "symbol2": "USD",
        //        "price": "0.305",
        //        "open24": "0.301",
        //        "volume": "241421.641700"
        //    }
        //  private
        //    {
        //        "timestamp": "1663764969",
        //        "low": "18756.3",
        //        "high": "19200",
        //        "last": "19200",
        //        "volume": "0.94735907",
        //        "volume30d": "64.61299999",
        //        "bid": 19217.2,
        //        "ask": 19247.5,
        //        "priceChange": "44.3",
        //        "priceChangePercentage": "0.23",
        //        "pair": ["BTC", "USDT"]
        //    }
        object pair = this.safeValue(ticker, "pair", new List<object>() {});
        object baseId = this.safeString(ticker, "symbol1");
        if (isTrue(isEqual(baseId, null)))
        {
            baseId = this.safeString(pair, 0);
        }
        object quoteId = this.safeString(ticker, "symbol2");
        if (isTrue(isEqual(quoteId, null)))
        {
            quoteId = this.safeString(pair, 1);
        }
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(bs, "/"), quote);
        object timestamp = this.safeInteger(ticker, "timestamp");
        if (isTrue(!isEqual(timestamp, null)))
        {
            timestamp = multiply(timestamp, 1000);
        }
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(ticker, "bid") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "ask") },
            { "askVolume", null },
            { "vwap", null },
            { "open", this.safeString(ticker, "open24") },
            { "close", null },
            { "last", this.safeString2(ticker, "price", "last") },
            { "previousClose", null },
            { "change", this.safeString(ticker, "priceChange") },
            { "percentage", this.safeString(ticker, "priceChangePercentage") },
            { "average", null },
            { "baseVolume", null },
            { "quoteVolume", this.safeString(ticker, "volume") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name cex#fetchBalanceWs
     * @see https://docs.cex.io/#ws-api-get-balance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @param {object} [params] extra parameters specific to the cex api endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalanceWs(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object url = getValue(getValue(this.urls, "api"), "ws");
        object messageHash = this.requestId();
        object request = this.extend(new Dictionary<string, object>() {
            { "e", "get-balance" },
            { "oid", messageHash },
        }, parameters);
        return await this.watch(url, messageHash, request, messageHash);
    }

    /**
     * @method
     * @name cex#watchOrders
     * @description get the list of orders associated with the user. Note: In CEX.IO system, orders can be present in trade engine or in archive database. There can be time periods (~2 seconds or more), when order is done/canceled, but still not moved to archive database. That means, you cannot see it using calls: archived-orders/open-orders.
     * @see https://docs.cex.io/#ws-api-open-orders
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        await this.authenticate(parameters);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object messageHash = add("orders:", symbol);
        object message = new Dictionary<string, object>() {
            { "e", "open-orders" },
            { "data", new Dictionary<string, object>() {
                { "pair", new List<object>() {getValue(market, "baseId"), getValue(market, "quoteId")} },
            } },
            { "oid", symbol },
        };
        object request = this.deepExtend(message, parameters);
        object orders = await this.watch(url, messageHash, request, messageHash, request);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    /**
     * @method
     * @name cex#watchMyTrades
     * @description get the list of trades associated with the user. Note: In CEX.IO system, orders can be present in trade engine or in archive database. There can be time periods (~2 seconds or more), when order is done/canceled, but still not moved to archive database. That means, you cannot see it using calls: archived-orders/open-orders.
     * @see https://docs.cex.io/#ws-api-open-orders
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        await this.authenticate(parameters);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object market = this.market(symbol);
        object messageHash = add("myTrades:", getValue(market, "symbol"));
        object subscriptionHash = add("orders:", getValue(market, "symbol"));
        object message = new Dictionary<string, object>() {
            { "e", "open-orders" },
            { "data", new Dictionary<string, object>() {
                { "pair", new List<object>() {getValue(market, "baseId"), getValue(market, "quoteId")} },
            } },
            { "oid", getValue(market, "symbol") },
        };
        object request = this.deepExtend(message, parameters);
        object orders = await this.watch(url, messageHash, request, subscriptionHash, request);
        return this.filterBySymbolSinceLimit(orders, getValue(market, "symbol"), since, limit);
    }

    public virtual void handleTransaction(WebSocketClient client, object message)
    {
        object data = this.safeValue(message, "data");
        object symbol2 = this.safeString(data, "symbol2");
        if (isTrue(isEqual(symbol2, null)))
        {
            return;
        }
        this.handleOrderUpdate(client as WebSocketClient, message);
        this.handleMyTrades(client as WebSocketClient, message);
    }

    public virtual void handleMyTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //         "e": "tx",
        //         "data": {
        //             "d": "order:59091012956:a:USD",
        //             "c": "user:up105393824:a:USD",
        //             "a": "0.01",
        //             "ds": 0,
        //             "cs": "15.27",
        //             "user": "up105393824",
        //             "symbol": "USD",
        //             "order": 59091012956,
        //             "amount": "-18.49",
        //             "type": "buy",
        //             "time": "2022-09-24T19:36:18.466Z",
        //             "balance": "15.27",
        //             "id": "59091012966"
        //         }
        //     }
        //     {
        //         "e": "tx",
        //         "data": {
        //             "d": "order:59091012956:a:BTC",
        //             "c": "user:up105393824:a:BTC",
        //             "a": "0.00096420",
        //             "ds": 0,
        //             "cs": "0.00096420",
        //             "user": "up105393824",
        //             "symbol": "BTC",
        //             "symbol2": "USD",
        //             "amount": "0.00096420",
        //             "buy": 59091012956,
        //             "order": 59091012956,
        //             "sell": 59090796005,
        //             "price": 19135,
        //             "type": "buy",
        //             "time": "2022-09-24T19:36:18.466Z",
        //             "balance": "0.00096420",
        //             "fee_amount": "0.05",
        //             "id": "59091012962"
        //         }
        //     }
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object stored = this.myTrades;
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCacheBySymbolById(limit);
            this.myTrades = stored;
        }
        object trade = this.parseWsTrade(data);
        callDynamically(stored, "append", new object[] {trade});
        object messageHash = add("myTrades:", getValue(trade, "symbol"));
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        //     {
        //         "d": "order:59091012956:a:BTC",
        //         "c": "user:up105393824:a:BTC",
        //         "a": "0.00096420",
        //         "ds": 0,
        //         "cs": "0.00096420",
        //         "user": "up105393824",
        //         "symbol": "BTC",
        //         "symbol2": "USD",
        //         "amount": "0.00096420",
        //         "buy": 59091012956,
        //         "order": 59091012956,
        //         "sell": 59090796005,
        //         "price": 19135,
        //         "type": "buy",
        //         "time": "2022-09-24T19:36:18.466Z",
        //         "balance": "0.00096420",
        //         "fee_amount": "0.05",
        //         "id": "59091012962"
        //     }
        // Note symbol and symbol2 are inverse on sell and ammount is in symbol currency.
        //
        object side = this.safeString(trade, "type");
        object price = this.safeString(trade, "price");
        object datetime = this.safeString(trade, "time");
        object baseId = this.safeString(trade, "symbol");
        object quoteId = this.safeString(trade, "symbol2");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(bs, "/"), quote);
        object amount = this.safeString(trade, "amount");
        if (isTrue(isEqual(side, "sell")))
        {
            symbol = add(add(quote, "/"), bs);
            amount = Precise.stringDiv(amount, price); // due to rounding errors amount in not exact to trade
        }
        object parsedTrade = new Dictionary<string, object>() {
            { "id", this.safeString(trade, "id") },
            { "order", this.safeString(trade, "order") },
            { "info", trade },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "symbol", symbol },
            { "type", null },
            { "side", side },
            { "takerOrMaker", null },
            { "price", price },
            { "cost", null },
            { "amount", amount },
            { "fee", null },
        };
        object fee = this.safeString(trade, "fee_amount");
        if (isTrue(!isEqual(fee, null)))
        {
            ((IDictionary<string,object>)parsedTrade)["fee"] = new Dictionary<string, object>() {
                { "cost", fee },
                { "currency", quote },
                { "rate", null },
            };
        }
        return this.safeTrade(parsedTrade, market);
    }

    public virtual void handleOrderUpdate(WebSocketClient client, object message)
    {
        //
        //  partialExecution
        //     {
        //         "e": "order",
        //         "data": {
        //             "id": "150714937",
        //             "remains": "1000000",
        //             "price": "17513",
        //             "amount": 2000000, As Precision
        //             "time": "1654506118448",
        //             "type": "buy",
        //             "pair": {
        //                 "symbol1": "BTC",
        //                 "symbol2": "USD"
        //             },
        //             "fee": "0.15"
        //         }
        //     }
        //  canceled order
        //     {
        //         "e": "order",
        //         "data": {
        //             "id": "6310857",
        //             "remains": "200000000"
        //             "fremains": "2.00000000"
        //             "cancel": true,
        //             "pair": {
        //                 "symbol1": "BTC",
        //                 "symbol2": "USD"
        //             }
        //         }
        //     }
        //  fulfilledOrder
        //     {
        //         "e": "order",
        //         "data": {
        //             "id": "59098421630",
        //             "remains": "0",
        //             "pair": {
        //                 "symbol1": "BTC",
        //                 "symbol2": "USD"
        //             }
        //         }
        //     }
        //     {
        //         "e": "tx",
        //         "data": {
        //             "d": "order:59425993014:a:BTC",
        //             "c": "user:up105393824:a:BTC",
        //             "a": "0.00098152",
        //             "ds": 0,
        //             "cs": "0.00098152",
        //             "user": "up105393824",
        //             "symbol": "BTC",
        //             "symbol2": "USD",
        //             "amount": "0.00098152",
        //             "buy": 59425993014,
        //             "order": 59425993014,
        //             "sell": 59425986168,
        //             "price": 19306.6,
        //             "type": "buy",
        //             "time": "2022-10-02T01:11:15.148Z",
        //             "balance": "0.00098152",
        //             "fee_amount": "0.05",
        //             "id": "59425993020"
        //         }
        //     }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object isTransaction = isEqual(this.safeString(message, "e"), "tx");
        object orderId = this.safeString2(data, "id", "order");
        object remains = this.safeString(data, "remains");
        object baseId = this.safeString(data, "symbol");
        object quoteId = this.safeString(data, "symbol2");
        object pair = this.safeValue(data, "pair");
        if (isTrue(!isEqual(pair, null)))
        {
            baseId = this.safeString(pair, "symbol1");
            quoteId = this.safeString(pair, "symbol2");
        }
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(bs, "/"), quote);
        object market = this.safeMarket(symbol);
        remains = this.currencyFromPrecision(bs, remains);
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object storedOrders = this.orders;
        object ordersBySymbol = this.safeValue((storedOrders as ArrayCacheBySymbolById).hashmap, symbol, new Dictionary<string, object>() {});
        object order = this.safeValue(ordersBySymbol, orderId);
        if (isTrue(isEqual(order, null)))
        {
            order = this.parseWsOrderUpdate(data, market);
        }
        ((IDictionary<string,object>)order)["remaining"] = remains;
        object canceled = this.safeBool(data, "cancel", false);
        if (isTrue(canceled))
        {
            ((IDictionary<string,object>)order)["status"] = "canceled";
        }
        if (isTrue(isTransaction))
        {
            ((IDictionary<string,object>)order)["status"] = "closed";
        }
        object fee = this.safeNumber(data, "fee");
        if (isTrue(!isEqual(fee, null)))
        {
            ((IDictionary<string,object>)order)["fee"] = new Dictionary<string, object>() {
                { "cost", fee },
                { "currency", quote },
                { "rate", null },
            };
        }
        object timestamp = this.safeInteger(data, "time");
        ((IDictionary<string,object>)order)["timestamp"] = timestamp;
        ((IDictionary<string,object>)order)["datetime"] = this.iso8601(timestamp);
        order = this.safeOrder(order);
        callDynamically(storedOrders, "append", new object[] {order});
        object messageHash = add("orders:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {storedOrders, messageHash});
    }

    public virtual object parseWsOrderUpdate(object order, object market = null)
    {
        //
        //      {
        //          "id": "150714937",
        //          "remains": "1000000",
        //          "price": "17513",
        //          "amount": 2000000, As Precision
        //          "time": "1654506118448",
        //          "type": "buy",
        //          "pair": {
        //              "symbol1": "BTC",
        //              "symbol2": "USD"
        //          },
        //          "fee": "0.15"
        //      }
        //  transaction
        //      {
        //           "d": "order:59425993014:a:BTC",
        //           "c": "user:up105393824:a:BTC",
        //           "a": "0.00098152",
        //           "ds": 0,
        //           "cs": "0.00098152",
        //           "user": "up105393824",
        //           "symbol": "BTC",
        //           "symbol2": "USD",
        //           "amount": "0.00098152",
        //           "buy": 59425993014,
        //           "order": 59425993014,
        //           "sell": 59425986168,
        //           "price": 19306.6,
        //           "type": "buy",
        //           "time": "2022-10-02T01:11:15.148Z",
        //           "balance": "0.00098152",
        //           "fee_amount": "0.05",
        //           "id": "59425993020"
        //       }
        //
        object isTransaction = !isEqual(this.safeValue(order, "d"), null);
        object remainsPrecision = this.safeString(order, "remains");
        object remaining = null;
        if (isTrue(!isEqual(remainsPrecision, null)))
        {
            remaining = this.currencyFromPrecision(getValue(market, "base"), remainsPrecision);
        }
        object amount = this.safeString(order, "amount");
        if (!isTrue(isTransaction))
        {
            this.currencyFromPrecision(getValue(market, "base"), amount);
        }
        object baseId = this.safeString(order, "symbol");
        object quoteId = this.safeString(order, "symbol2");
        object pair = this.safeValue(order, "pair");
        if (isTrue(!isEqual(pair, null)))
        {
            baseId = this.safeString(order, "symbol1");
            quoteId = this.safeString(order, "symbol2");
        }
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = null;
        if (isTrue(isTrue(!isEqual(bs, null)) && isTrue(!isEqual(quote, null))))
        {
            symbol = add(add(bs, "/"), quote);
        }
        market = this.safeMarket(symbol, market);
        object time = this.safeInteger(order, "time", this.milliseconds());
        object timestamp = time;
        if (isTrue(isTransaction))
        {
            timestamp = this.parse8601(time);
        }
        object canceled = this.safeBool(order, "cancel", false);
        object status = "open";
        if (isTrue(canceled))
        {
            status = "canceled";
        } else if (isTrue(isTransaction))
        {
            status = "closed";
        }
        object parsedOrder = new Dictionary<string, object>() {
            { "id", this.safeString2(order, "id", "order") },
            { "clientOrderId", null },
            { "info", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "status", status },
            { "symbol", symbol },
            { "type", null },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", this.safeString(order, "type") },
            { "price", this.safeNumber(order, "price") },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "average", null },
            { "cost", null },
            { "amount", amount },
            { "filled", null },
            { "remaining", remaining },
            { "fee", new Dictionary<string, object>() {
                { "cost", this.safeNumber2(order, "fee", "fee_amount") },
                { "currency", quote },
                { "rate", null },
            } },
            { "trades", null },
        };
        if (isTrue(isTransaction))
        {
            ((IDictionary<string,object>)parsedOrder)["trades"] = this.parseWsTrade(order, market);
        }
        return this.safeOrder(parsedOrder, market);
    }

    public virtual object fromPrecision(object amount, object scale)
    {
        if (isTrue(isEqual(amount, null)))
        {
            return null;
        }
        var precise = new Precise(amount);
        precise.decimals = this.sum(precise.decimals, scale);
        precise.reduce();
        return ((object)precise).ToString();
    }

    public virtual object currencyFromPrecision(object currency, object amount)
    {
        object scale = this.safeInteger(getValue(this.currencies, currency), "precision", 0);
        return this.fromPrecision(amount, scale);
    }

    public virtual void handleOrdersSnapshot(WebSocketClient client, object message)
    {
        //
        //     {
        //         "e": "open-orders",
        //         "data": [{
        //             "id": "59098421630",
        //             "time": "1664062285425",
        //             "type": "buy",
        //             "price": "18920",
        //             "amount": "0.00100000",
        //             "pending": "0.00100000"
        //         }],
        //         "oid": 1,
        //         "ok": "ok"
        //     }
        //
        object symbol = this.safeString(message, "oid"); // symbol is set as requestId in watchOrders
        object rawOrders = this.safeValue(message, "data", new List<object>() {});
        object myOrders = this.orders;
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            myOrders = new ArrayCacheBySymbolById(limit);
        }
        for (object i = 0; isLessThan(i, getArrayLength(rawOrders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(rawOrders, i);
            object market = this.safeMarket(symbol);
            object order = this.parseOrder(rawOrder, market);
            ((IDictionary<string,object>)order)["status"] = "open";
            callDynamically(myOrders, "append", new object[] {order});
        }
        this.orders = myOrders;
        object messageHash = add("orders:", symbol);
        object ordersLength = getArrayLength(myOrders);
        if (isTrue(isGreaterThan(ordersLength, 0)))
        {
            callDynamically(client as WebSocketClient, "resolve", new object[] {myOrders, messageHash});
        }
    }

    /**
     * @method
     * @name cex#watchOrderBook
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://cex.io/websocket-api#orderbook-subscribe
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object url = getValue(getValue(this.urls, "api"), "ws");
        object messageHash = add("orderbook:", symbol);
        object depth = ((bool) isTrue((isEqual(limit, null)))) ? 0 : limit;
        object subscribe = new Dictionary<string, object>() {
            { "e", "order-book-subscribe" },
            { "data", new Dictionary<string, object>() {
                { "pair", new List<object>() {getValue(market, "baseId"), getValue(market, "quoteId")} },
                { "subscribe", true },
                { "depth", depth },
            } },
            { "oid", this.requestId() },
        };
        object request = this.deepExtend(subscribe, parameters);
        object orderbook = await this.watch(url, messageHash, request, messageHash);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBookSnapshot(WebSocketClient client, object message)
    {
        //
        //     {
        //         "e": "order-book-subscribe",
        //         "data": {
        //             "timestamp": 1663762032,
        //             "timestamp_ms": 1663762031680,
        //             "bids": [
        //                 [ 241.947, 155.91626 ],
        //                 [ 241, 154 ],
        //             ],
        //             "asks": [
        //                 [ 242.947, 155.91626 ],
        //                 [ 243, 154 ],    ],
        //             "pair": "BTC:USDT",
        //             "id": 616267120,
        //             "sell_total": "13.59066946",
        //             "buy_total": "163553.625948"
        //         },
        //         "oid": "1",
        //         "ok": "ok"
        //     }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object pair = this.safeString(data, "pair");
        object symbol = this.pairToSymbol(pair);
        object messageHash = add("orderbook:", symbol);
        object timestamp = this.safeInteger2(data, "timestamp_ms", "timestamp");
        object incrementalId = this.safeInteger(data, "id");
        object orderbook = this.orderBook(new Dictionary<string, object>() {});
        object snapshot = this.parseOrderBook(data, symbol, timestamp, "bids", "asks");
        ((IDictionary<string,object>)snapshot)["nonce"] = incrementalId;
        (orderbook as IOrderBook).reset(snapshot);
        ((IDictionary<string,object>)getValue(this.options, "orderbook"))[(string)symbol] = new Dictionary<string, object>() {
            { "incrementalId", incrementalId },
        };
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public virtual object pairToSymbol(object pair)
    {
        object parts = ((string)pair).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
        object baseId = this.safeString(parts, 0);
        object quoteId = this.safeString(parts, 1);
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(bs, "/"), quote);
        return symbol;
    }

    public virtual void handleOrderBookUpdate(WebSocketClient client, object message)
    {
        //
        //     {
        //         "e": "md_update",
        //         "data": {
        //             "id": 616267121,
        //             "pair": "BTC:USDT",
        //             "time": 1663762031719,
        //             "bids": [],
        //             "asks": [
        //                 [122, 23]
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object incrementalId = this.safeInteger(data, "id");
        object pair = this.safeString(data, "pair", "");
        object symbol = this.pairToSymbol(pair);
        object storedOrderBook = this.safeValue(this.orderbooks, symbol);
        object messageHash = add("orderbook:", symbol);
        if (isTrue(!isEqual(incrementalId, add(getValue(storedOrderBook, "nonce"), 1))))
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
            ((WebSocketClient)client).reject(add(this.id, " watchOrderBook() skipped a message"), messageHash);
            return;
        }
        object timestamp = this.safeInteger(data, "time");
        object asks = this.safeValue(data, "asks", new List<object>() {});
        object bids = this.safeValue(data, "bids", new List<object>() {});
        this.handleDeltas(getValue(storedOrderBook, "asks"), asks);
        this.handleDeltas(getValue(storedOrderBook, "bids"), bids);
        ((IDictionary<string,object>)storedOrderBook)["timestamp"] = timestamp;
        ((IDictionary<string,object>)storedOrderBook)["datetime"] = this.iso8601(timestamp);
        ((IDictionary<string,object>)storedOrderBook)["nonce"] = incrementalId;
        callDynamically(client as WebSocketClient, "resolve", new object[] {storedOrderBook, messageHash});
    }

    public override void handleDelta(object bookside, object delta)
    {
        object bidAsk = this.parseBidAsk(delta, 0, 1);
        (bookside as IOrderBookSide).storeArray(bidAsk);
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    /**
     * @method
     * @name cex#watchOHLCV
     * @see https://cex.io/websocket-api#minute-data
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market. It will return the last 120 minutes with the selected timeframe and then 1m candle updates after that.
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents.
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object messageHash = add("ohlcv:", symbol);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object request = new Dictionary<string, object>() {
            { "e", "init-ohlcv" },
            { "i", timeframe },
            { "rooms", new List<object>() {add(add(add("pair-", getValue(market, "baseId")), "-"), getValue(market, "quoteId"))} },
        };
        object ohlcv = await this.watch(url, messageHash, this.extend(request, parameters), messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual void handleInitOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "e": "init-ohlcv-data",
        //         "data": [
        //             [
        //                 1663660680,
        //                 "19396.4",
        //                 "19396.4",
        //                 "19396.4",
        //                 "19396.4",
        //                 "1262861"
        //             ],
        //             ...
        //         ],
        //         "pair": "BTC:USDT"
        //     }
        //
        object pair = this.safeString(message, "pair");
        object parts = ((string)pair).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
        object baseId = this.safeString(parts, 0);
        object quoteId = this.safeString(parts, 1);
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(bs, "/"), quote);
        object market = this.safeMarket(symbol);
        object messageHash = add("ohlcv:", symbol);
        object data = this.safeValue(message, "data", new List<object>() {});
        object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
        var stored = new ArrayCacheByTimestamp(limit);
        object sorted = this.sortBy(data, 0);
        for (object i = 0; isLessThan(i, getArrayLength(sorted)); postFixIncrement(ref i))
        {
            callDynamically(stored, "append", new object[] {this.parseOHLCV(getValue(sorted, i), market)});
        }
        if (!isTrue((inOp(this.ohlcvs, symbol))))
        {
            ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = new Dictionary<string, object>() {};
        }
        ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))["unknown"] = stored;
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public virtual object handleOHLCV24(WebSocketClient client, object message)
    {
        //
        //     {
        //         "e": "ohlcv24",
        //         "data": [ '18793.2', '19630', '18793.2', "19104.1", "314157273" ],
        //         "pair": "BTC:USDT"
        //     }
        //
        return message;
    }

    public virtual void handleOHLCV1m(WebSocketClient client, object message)
    {
        //
        //     {
        //         "e": "ohlcv1m",
        //         "data": {
        //             "pair": "BTC:USD",
        //             "time": "1665436800",
        //             "o": "19279.6",
        //             "h": "19279.6",
        //             "l": "19266.7",
        //             "c": "19266.7",
        //             "v": 3343884,
        //             "d": 3343884
        //         }
        //     }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object pair = this.safeString(data, "pair");
        object symbol = this.pairToSymbol(pair);
        object messageHash = add("ohlcv:", symbol);
        object ohlcv = new List<object> {this.safeTimestamp(data, "time"), this.safeNumber(data, "o"), this.safeNumber(data, "h"), this.safeNumber(data, "l"), this.safeNumber(data, "c"), this.safeNumber(data, "v")};
        object stored = this.safeValue(this.ohlcvs, symbol);
        callDynamically(stored, "append", new object[] {ohlcv});
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "e": "ohlcv",
        //         "data": [
        //             [1665461100, '19068.2', '19068.2', '19068.2', "19068.2", 268478]
        //         ],
        //         "pair": "BTC:USD"
        //     }
        //
        object data = this.safeValue(message, "data", new List<object>() {});
        object pair = this.safeString(message, "pair");
        object symbol = this.pairToSymbol(pair);
        object messageHash = add("ohlcv:", symbol);
        // const stored = this.safeValue (this.ohlcvs, symbol);
        object stored = getValue(getValue(this.ohlcvs, symbol), "unknown");
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object ohlcv = new List<object> {this.safeTimestamp(getValue(data, i), 0), this.safeNumber(getValue(data, i), 1), this.safeNumber(getValue(data, i), 2), this.safeNumber(getValue(data, i), 3), this.safeNumber(getValue(data, i), 4), this.safeNumber(getValue(data, i), 5)};
            callDynamically(stored, "append", new object[] {ohlcv});
        }
        object dataLength = getArrayLength(data);
        if (isTrue(isGreaterThan(dataLength, 0)))
        {
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        }
    }

    /**
     * @method
     * @name cex#fetchOrderWs
     * @description fetches information on an order made by the user
     * @see https://docs.cex.io/#ws-api-get-order
     * @param {string} id the order id
     * @param {string} symbol not used by cex fetchOrder
     * @param {object} [params] extra parameters specific to the cex api endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrderWs(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object data = this.extend(new Dictionary<string, object>() {
            { "order_id", ((object)id).ToString() },
        }, parameters);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object messageHash = this.requestId();
        object request = new Dictionary<string, object>() {
            { "e", "get-order" },
            { "oid", messageHash },
            { "data", data },
        };
        object response = await this.watch(url, messageHash, request, messageHash);
        return this.parseOrder(response, market);
    }

    /**
     * @method
     * @name cex#fetchOpenOrdersWs
     * @see https://docs.cex.io/#ws-api-open-orders
     * @description fetch all unfilled currently open orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of  open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the cex api endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrdersWs(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOpenOrdersWs requires a symbol.")) ;
        }
        await this.loadMarkets();
        await this.authenticate();
        object market = this.market(symbol);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object messageHash = this.requestId();
        object data = this.extend(new Dictionary<string, object>() {
            { "pair", new List<object>() {getValue(market, "baseId"), getValue(market, "quoteId")} },
        }, parameters);
        object request = new Dictionary<string, object>() {
            { "e", "open-orders" },
            { "oid", messageHash },
            { "data", data },
        };
        object response = await this.watch(url, messageHash, request, messageHash);
        return this.parseOrders(response, market, since, limit, parameters);
    }

    /**
     * @method
     * @name cex#createOrderWs
     * @see https://docs.cex.io/#ws-api-order-placement
     * @description create a trade order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} price the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the kraken api endpoint
     * @param {boolean} [params.maker_only] Optional, maker only places an order only if offers best sell (<= max) or buy(>= max) price for this pair, if not order placement will be rejected with an error - "Order is not maker"
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
     */
    public async override Task<object> createOrderWs(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(price, null)))
        {
            throw new BadRequest ((string)add(this.id, " createOrderWs requires a price argument")) ;
        }
        await this.loadMarkets();
        await this.authenticate();
        object market = this.market(symbol);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object messageHash = this.requestId();
        object data = this.extend(new Dictionary<string, object>() {
            { "pair", new List<object>() {getValue(market, "baseId"), getValue(market, "quoteId")} },
            { "amount", amount },
            { "price", price },
            { "type", side },
        }, parameters);
        object request = new Dictionary<string, object>() {
            { "e", "place-order" },
            { "oid", messageHash },
            { "data", data },
        };
        object rawOrder = await this.watch(url, messageHash, request, messageHash);
        return this.parseOrder(rawOrder, market);
    }

    /**
     * @method
     * @name cex#editOrderWs
     * @description edit a trade order
     * @see https://docs.cex.io/#ws-api-cancel-replace
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of the currency you want to trade in units of the base currency
     * @param {float|undefined} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the cex api endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
     */
    public async override Task<object> editOrderWs(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(amount, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " editOrder() requires a amount argument")) ;
        }
        if (isTrue(isEqual(price, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " editOrder() requires a price argument")) ;
        }
        await this.loadMarkets();
        await this.authenticate();
        object market = this.market(symbol);
        object data = this.extend(new Dictionary<string, object>() {
            { "pair", new List<object>() {getValue(market, "baseId"), getValue(market, "quoteId")} },
            { "type", side },
            { "amount", amount },
            { "price", price },
            { "order_id", id },
        }, parameters);
        object messageHash = this.requestId();
        object url = getValue(getValue(this.urls, "api"), "ws");
        object request = new Dictionary<string, object>() {
            { "e", "cancel-replace-order" },
            { "oid", messageHash },
            { "data", data },
        };
        object response = await this.watch(url, messageHash, request, messageHash, messageHash);
        return this.parseOrder(response, market);
    }

    /**
     * @method
     * @name cex#cancelOrderWs
     * @see https://docs.cex.io/#ws-api-order-cancel
     * @description cancels an open order
     * @param {string} id order id
     * @param {string} symbol not used by cex cancelOrder ()
     * @param {object} [params] extra parameters specific to the cex api endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrderWs(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object data = this.extend(new Dictionary<string, object>() {
            { "order_id", id },
        }, parameters);
        object messageHash = this.requestId();
        object url = getValue(getValue(this.urls, "api"), "ws");
        object request = new Dictionary<string, object>() {
            { "e", "cancel-order" },
            { "oid", messageHash },
            { "data", data },
        };
        object response = await this.watch(url, messageHash, request, messageHash, messageHash);
        return this.parseOrder(response, market);
    }

    /**
     * @method
     * @name cex#cancelOrdersWs
     * @description cancel multiple orders
     * @see https://docs.cex.io/#ws-api-mass-cancel-place
     * @param {string[]} ids order ids
     * @param {string} symbol not used by cex cancelOrders()
     * @param {object} [params] extra parameters specific to the cex api endpoint
     * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrdersWs(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(!isEqual(symbol, null)))
        {
            throw new BadRequest ((string)add(this.id, " cancelOrderWs does not allow filtering by symbol")) ;
        }
        await this.loadMarkets();
        await this.authenticate();
        object messageHash = this.requestId();
        object data = this.extend(new Dictionary<string, object>() {
            { "cancel-orders", ids },
        }, parameters);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object request = new Dictionary<string, object>() {
            { "e", "mass-cancel-place-orders" },
            { "oid", messageHash },
            { "data", data },
        };
        object response = await this.watch(url, messageHash, request, messageHash, messageHash);
        //
        //    {
        //        "cancel-orders": [{
        //            "order_id": 69202557979,
        //            "fremains": "0.15000000"
        //        }],
        //        "place-orders": [],
        //        "placed-cancelled": []
        //    }
        //
        object canceledOrders = this.safeValue(response, "cancel-orders");
        return this.parseOrders(canceledOrders, null, null, null, parameters);
    }

    public virtual void resolveData(WebSocketClient client, object message)
    {
        //
        //    "e": "open-orders",
        //    "data": [
        //       {
        //          "id": "2477098",
        //          "time": "1435927928618",
        //          "type": "buy",
        //          "price": "241.9477",
        //          "amount": "0.02000000",
        //          "pending": "0.02000000"
        //       },
        //       ...
        //    ],
        //    "oid": "1435927928274_9_open-orders",
        //    "ok": "ok"
        //    }
        //
        object data = this.safeValue(message, "data");
        object messageHash = this.safeString(message, "oid");
        callDynamically(client as WebSocketClient, "resolve", new object[] {data, messageHash});
    }

    public virtual object handleConnected(WebSocketClient client, object message)
    {
        //
        //     {
        //         "e": "connected"
        //     }
        //
        return message;
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        try
        {
            object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
            object error = this.safeString(data, "error");
            object eventVar = this.safeString(message, "e", "");
            object feedback = add(add(add(add(this.id, " "), eventVar), " "), error);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), error, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), error, feedback);
            throw new ExchangeError ((string)feedback) ;
        } catch(Exception error)
        {
            object messageHash = this.safeString(message, "oid");
            var future = this.safeValue(getValue(client as WebSocketClient, "futures"), messageHash);
            if (isTrue(!isEqual(future, null)))
            {
                ((WebSocketClient)client).reject(error, messageHash);
                return true;
            } else
            {
                throw error;
            }
        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        object ok = this.safeString(message, "ok");
        if (isTrue(isEqual(ok, "error")))
        {
            this.handleErrorMessage(client as WebSocketClient, message);
            return;
        }
        object eventVar = this.safeString(message, "e");
        object handlers = new Dictionary<string, object>() {
            { "auth", this.handleAuthenticationMessage },
            { "connected", this.handleConnected },
            { "tick", this.handleTicker },
            { "ticker", this.handleTicker },
            { "init-ohlcv-data", this.handleInitOHLCV },
            { "ohlcv24", this.handleOHLCV24 },
            { "ohlcv1m", this.handleOHLCV1m },
            { "ohlcv", this.handleOHLCV },
            { "get-balance", this.handleBalance },
            { "order-book-subscribe", this.handleOrderBookSnapshot },
            { "md_update", this.handleOrderBookUpdate },
            { "open-orders", this.resolveData },
            { "order", this.handleOrderUpdate },
            { "history-update", this.handleTrade },
            { "history", this.handleTradesSnapshot },
            { "tx", this.handleTransaction },
            { "place-order", this.resolveData },
            { "cancel-replace-order", this.resolveData },
            { "cancel-order", this.resolveData },
            { "mass-cancel-place-orders", this.resolveData },
            { "get-order", this.resolveData },
        };
        object handler = this.safeValue(handlers, eventVar);
        if (isTrue(!isEqual(handler, null)))
        {
            DynamicInvoker.InvokeMethod(handler, new object[] { client, message});
        }
    }

    public virtual void handleAuthenticationMessage(WebSocketClient client, object message)
    {
        //
        //     {
        //         "e": "auth",
        //         "data": {
        //             "ok": "ok"
        //         },
        //         "ok": "ok",
        //         "timestamp":1448034593
        //     }
        //
        var future = this.safeValue((client as WebSocketClient).futures, "authenticated");
        if (isTrue(!isEqual(future, null)))
        {
            (future as Future).resolve(true);
        }
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object url = getValue(getValue(this.urls, "api"), "ws");
        var client = this.client(url);
        object messageHash = "authenticated";
        var future = client.future("authenticated");
        object authenticated = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(authenticated, null)))
        {
            this.checkRequiredCredentials();
            object nonce = ((object)this.seconds()).ToString();
            object auth = add(nonce, this.apiKey);
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
            object request = new Dictionary<string, object>() {
                { "e", "auth" },
                { "auth", new Dictionary<string, object>() {
                    { "key", this.apiKey },
                    { "signature", ((string)signature).ToUpper() },
                    { "timestamp", nonce },
                } },
            };
            await this.watch(url, messageHash, this.extend(request, parameters), messageHash);
        }
        return await (future as Exchange.Future);
    }
}
