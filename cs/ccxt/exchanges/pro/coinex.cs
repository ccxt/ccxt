namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class coinex { public coinex(object args = null) : base(args) { } }
public partial class coinex : ccxt.coinex
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchBalance", true },
                { "watchBidsAsks", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
                { "watchMyTrades", true },
                { "watchOrders", true },
                { "watchOrderBook", true },
                { "watchOrderBookForSymbols", true },
                { "watchOHLCV", false },
                { "fetchOHLCVWs", false },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "spot", "wss://socket.coinex.com/v2/spot/" },
                        { "swap", "wss://socket.coinex.com/v2/futures/" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "ws", new Dictionary<string, object>() {
                    { "gunzip", true },
                } },
                { "timeframes", new Dictionary<string, object>() {
                    { "1m", 60 },
                    { "3m", 180 },
                    { "5m", 300 },
                    { "15m", 900 },
                    { "30m", 1800 },
                    { "1h", 3600 },
                    { "2h", 7200 },
                    { "4h", 14400 },
                    { "6h", 21600 },
                    { "12h", 43200 },
                    { "1d", 86400 },
                    { "3d", 259200 },
                    { "1w", 604800 },
                } },
                { "account", "spot" },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "limits", new List<object>() {5, 10, 20, 50} },
                    { "defaultLimit", 50 },
                    { "aggregations", new List<object>() {"1000", "100", "10", "1", "0", "0.1", "0.01", "0.001", "0.0001", "0.00001", "0.000001", "0.0000001", "0.00000001", "0.000000001", "0.0000000001", "0.00000000001"} },
                    { "defaultAggregation", "0" },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {} },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "20001", typeof(BadRequest) },
                    { "20002", typeof(NotSupported) },
                    { "21001", typeof(AuthenticationError) },
                    { "21002", typeof(AuthenticationError) },
                    { "23001", typeof(RequestTimeout) },
                    { "23002", typeof(RateLimitExceeded) },
                    { "24001", typeof(ExchangeError) },
                    { "24002", typeof(ExchangeNotAvailable) },
                    { "30001", typeof(BadRequest) },
                    { "30002", typeof(NotSupported) },
                    { "31001", typeof(AuthenticationError) },
                    { "31002", typeof(AuthenticationError) },
                    { "33001", typeof(RequestTimeout) },
                    { "33002", typeof(RateLimitExceeded) },
                    { "34001", typeof(ExchangeError) },
                    { "34002", typeof(ExchangeNotAvailable) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
        });
    }

    public virtual object requestId()
    {
        object requestId = this.sum(this.safeInteger(this.options, "requestId", 0), 1);
        ((IDictionary<string,object>)this.options)["requestId"] = requestId;
        return requestId;
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        //  spot
        //
        //     {
        //         "method": "state.update",
        //         "data": {
        //             "state_list": [
        //                 {
        //                     "market": "LATUSDT",
        //                     "last": "0.008157",
        //                     "open": "0.008286",
        //                     "close": "0.008157",
        //                     "high": "0.008390",
        //                     "low": "0.008106",
        //                     "volume": "807714.49139758",
        //                     "volume_sell": "286170.69645599",
        //                     "volume_buy": "266161.23236408",
        //                     "value": "6689.21644207",
        //                     "period": 86400
        //                 },
        //             ]
        //         },
        //         "id": null
        //     }
        //
        //  swap
        //
        //     {
        //         "method": "state.update",
        //         "data": {
        //             "state_list": [
        //                 {
        //                     "market": "ETHUSD_SIGNPRICE",
        //                     "last": "1892.29",
        //                     "open": "1884.62",
        //                     "close": "1892.29",
        //                     "high": "1894.09",
        //                     "low": "1863.72",
        //                     "volume": "0",
        //                     "value": "0",
        //                     "volume_sell": "0",
        //                     "volume_buy": "0",
        //                     "open_interest_size": "0",
        //                     "insurance_fund_size": "0",
        //                     "latest_funding_rate": "0",
        //                     "next_funding_rate": "0",
        //                     "latest_funding_time": 0,
        //                     "next_funding_time": 0,
        //                     "period": 86400
        //                 },
        //             ]
        //         ],
        //         "id": null
        //     }
        //
        object defaultType = this.safeString(this.options, "defaultType");
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object rawTickers = this.safeList(data, "state_list", new List<object>() {});
        object newTickers = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rawTickers)); postFixIncrement(ref i))
        {
            object entry = getValue(rawTickers, i);
            object marketId = this.safeString(entry, "market");
            object symbol = this.safeSymbol(marketId, null, null, defaultType);
            object market = this.safeMarket(marketId, null, null, defaultType);
            object parsedTicker = this.parseWSTicker(entry, market);
            ((IDictionary<string,object>)this.tickers)[(string)symbol] = parsedTicker;
            ((IList<object>)newTickers).Add(parsedTicker);
        }
        object messageHashes = this.findMessageHashes(client as WebSocketClient, "tickers::");
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object tickers = this.filterByArray(newTickers, "symbol", symbols);
            object tickersSymbols = new List<object>(((IDictionary<string,object>)tickers).Keys);
            object numTickers = getArrayLength(tickersSymbols);
            if (isTrue(isGreaterThan(numTickers, 0)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {tickers, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newTickers, "tickers"});
    }

    public virtual object parseWSTicker(object ticker, object market = null)
    {
        //
        //  spot
        //
        //     {
        //         "market": "LATUSDT",
        //         "last": "0.008157",
        //         "open": "0.008286",
        //         "close": "0.008157",
        //         "high": "0.008390",
        //         "low": "0.008106",
        //         "volume": "807714.49139758",
        //         "volume_sell": "286170.69645599",
        //         "volume_buy": "266161.23236408",
        //         "value": "6689.21644207",
        //         "period": 86400
        //     }
        //
        //  swap
        //
        //     {
        //         "market": "ETHUSD_SIGNPRICE",
        //         "last": "1892.29",
        //         "open": "1884.62",
        //         "close": "1892.29",
        //         "high": "1894.09",
        //         "low": "1863.72",
        //         "volume": "0",
        //         "value": "0",
        //         "volume_sell": "0",
        //         "volume_buy": "0",
        //         "open_interest_size": "0",
        //         "insurance_fund_size": "0",
        //         "latest_funding_rate": "0",
        //         "next_funding_rate": "0",
        //         "latest_funding_time": 0,
        //         "next_funding_time": 0,
        //         "period": 86400
        //     }
        //
        object defaultType = this.safeString(this.options, "defaultType");
        object marketId = this.safeString(ticker, "market");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(marketId, market, null, defaultType) },
            { "timestamp", null },
            { "datetime", null },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", null },
            { "bidVolume", this.safeString(ticker, "volume_buy") },
            { "ask", null },
            { "askVolume", this.safeString(ticker, "volume_sell") },
            { "vwap", null },
            { "open", this.safeString(ticker, "open") },
            { "close", this.safeString(ticker, "close") },
            { "last", this.safeString(ticker, "last") },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "volume") },
            { "quoteVolume", this.safeString(ticker, "value") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name coinex#watchBalance
     * @description watch balance and get the amount of funds available for trading or funds locked in orders
     * @see https://docs.coinex.com/api/v2/assets/balance/ws/spot_balance
     * @see https://docs.coinex.com/api/v2/assets/balance/ws/futures_balance
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchBalance", null, parameters, "spot");
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        await this.authenticate(type);
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), type);
        object currencies = new List<object>(((IDictionary<string,object>)this.currencies_by_id).Keys);
        if (isTrue(isEqual(currencies, null)))
        {
            currencies = new List<object>() {};
        }
        object messageHash = "balances";
        if (isTrue(isEqual(type, "spot")))
        {
            messageHash = add(messageHash, ":spot");
        } else
        {
            messageHash = add(messageHash, ":swap");
        }
        object subscribe = new Dictionary<string, object>() {
            { "method", "balance.subscribe" },
            { "params", new Dictionary<string, object>() {
                { "ccy_list", currencies },
            } },
            { "id", this.requestId() },
        };
        object request = this.deepExtend(subscribe, parameters);
        return await this.watch(url, messageHash, request, messageHash);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //     {
        //         "method": "balance.update",
        //         "data": {
        //             "balance_list": [
        //                 {
        //                     "margin_market": "BTCUSDT",
        //                     "ccy": "BTC",
        //                     "available": "44.62207740",
        //                     "frozen": "0.00000000",
        //                     "updated_at": 1689152421692
        //                 },
        //             ]
        //         },
        //         "id": null
        //     }
        //
        // swap
        //
        //     {
        //         "method": "balance.update",
        //         "data": {
        //             "balance_list": [
        //                 {
        //                     "ccy": "USDT",
        //                     "available": "97.92470982756335000001",
        //                     "frozen": "0.00000000000000000000",
        //                     "margin": "0.61442700000000000000",
        //                     "transferrable": "97.92470982756335000001",
        //                     "unrealized_pnl": "-0.00807000000000000000",
        //                     "equity": "97.92470982756335000001"
        //                 },
        //             ]
        //         },
        //         "id": null
        //     }
        //
        if (isTrue(isEqual(this.balance, null)))
        {
            this.balance = new Dictionary<string, object>() {};
        }
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object balances = this.safeList(data, "balance_list", new List<object>() {});
        object firstEntry = getValue(balances, 0);
        object updated = this.safeInteger(firstEntry, "updated_at");
        object unrealizedPnl = this.safeString(firstEntry, "unrealized_pnl");
        object isSpot = (!isEqual(updated, null));
        object isSwap = (!isEqual(unrealizedPnl, null));
        object info = null;
        object account = null;
        object rawBalances = new List<object>() {};
        if (isTrue(isSpot))
        {
            account = "spot";
            for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
            {
                rawBalances = this.arrayConcat(rawBalances, balances);
            }
            info = rawBalances;
        }
        if (isTrue(isSwap))
        {
            account = "swap";
            for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
            {
                rawBalances = this.arrayConcat(rawBalances, balances);
            }
            info = rawBalances;
        }
        for (object i = 0; isLessThan(i, getArrayLength(rawBalances)); postFixIncrement(ref i))
        {
            object entry = getValue(rawBalances, i);
            this.parseWsBalance(entry, account);
        }
        object messageHash = null;
        if (isTrue(!isEqual(account, null)))
        {
            if (isTrue(isEqual(this.safeValue(this.balance, account), null)))
            {
                ((IDictionary<string,object>)this.balance)[(string)account] = new Dictionary<string, object>() {};
            }
            ((IDictionary<string,object>)getValue(this.balance, account))["info"] = info;
            ((IDictionary<string,object>)this.balance)[(string)account] = this.safeBalance(getValue(this.balance, account));
            messageHash = add("balances:", account);
            callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, account), messageHash});
        }
    }

    public virtual void parseWsBalance(object balance, object accountType = null)
    {
        //
        // spot
        //
        //     {
        //         "margin_market": "BTCUSDT",
        //         "ccy": "BTC",
        //         "available": "44.62207740",
        //         "frozen": "0.00000000",
        //         "updated_at": 1689152421692
        //     }
        //
        // swap
        //
        //     {
        //         "ccy": "USDT",
        //         "available": "97.92470982756335000001",
        //         "frozen": "0.00000000000000000000",
        //         "margin": "0.61442700000000000000",
        //         "transferrable": "97.92470982756335000001",
        //         "unrealized_pnl": "-0.00807000000000000000",
        //         "equity": "97.92470982756335000001"
        //     }
        //
        object account = this.account();
        object currencyId = this.safeString(balance, "ccy");
        object code = this.safeCurrencyCode(currencyId);
        ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "available");
        ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "frozen");
        if (isTrue(!isEqual(accountType, null)))
        {
            if (isTrue(isEqual(this.safeValue(this.balance, accountType), null)))
            {
                ((IDictionary<string,object>)this.balance)[(string)accountType] = new Dictionary<string, object>() {};
            }
            ((IDictionary<string,object>)getValue(this.balance, accountType))[(string)code] = account;
        } else
        {
            ((IDictionary<string,object>)this.balance)[(string)code] = account;
        }
    }

    /**
     * @method
     * @name coinex#watchMyTrades
     * @description watches information on multiple trades made by the user
     * @see https://docs.coinex.com/api/v2/spot/deal/ws/user-deals
     * @see https://docs.coinex.com/api/v2/futures/deal/ws/user-deals
     * @param {string} [symbol] unified symbol of the market the trades were made in
     * @param {int} [since] the earliest time in ms to watch trades
     * @param {int} [limit] the maximum number of trade structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchMyTrades", market, parameters, "spot");
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        await this.authenticate(type);
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), type);
        object subscribedSymbols = new List<object>() {};
        object messageHash = "myTrades";
        if (isTrue(!isEqual(market, null)))
        {
            messageHash = add(messageHash, add(":", symbol));
            ((IList<object>)subscribedSymbols).Add(getValue(market, "id"));
        } else
        {
            if (isTrue(isEqual(type, "spot")))
            {
                messageHash = add(messageHash, ":spot");
            } else
            {
                messageHash = add(messageHash, ":swap");
            }
        }
        object message = new Dictionary<string, object>() {
            { "method", "user_deals.subscribe" },
            { "params", new Dictionary<string, object>() {
                { "market_list", subscribedSymbols },
            } },
            { "id", this.requestId() },
        };
        object request = this.deepExtend(message, parameters);
        object trades = await this.watch(url, messageHash, request, messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleMyTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //         "method": "user_deals.update",
        //         "data": {
        //             "deal_id": 3514376759,
        //             "created_at": 1689152421692,
        //             "market": "BTCUSDT",
        //             "side": "buy",
        //             "order_id": 8678890,
        //             "margin_market": "BTCUSDT",
        //             "price": "30718.42",
        //             "amount": "0.00000325",
        //             "role": "taker",
        //             "fee": "0.0299",
        //             "fee_ccy": "USDT"
        //         },
        //         "id": null
        //     }
        //
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "market");
        object isSpot = isGreaterThan(getIndexOf(client.url, "spot"), -1);
        object defaultType = ((bool) isTrue(isSpot)) ? "spot" : "swap";
        object market = this.safeMarket(marketId, null, null, defaultType);
        object symbol = getValue(market, "symbol");
        object messageHash = add("myTrades:", symbol);
        object messageWithType = add("myTrades:", getValue(market, "type"));
        object stored = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        object parsed = this.parseWsTrade(data, market);
        callDynamically(stored, "append", new object[] {parsed});
        ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.trades, symbol), messageWithType});
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.trades, symbol), messageHash});
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //     {
        //         "method": "deals.update",
        //         "data": {
        //             "market": "BTCUSDT",
        //             "deal_list": [
        //                 {
        //                     "deal_id": 3514376759,
        //                     "created_at": 1689152421692,
        //                     "side": "buy",
        //                     "price": "30718.42",
        //                     "amount": "0.00000325"
        //                 },
        //             ]
        //         },
        //         "id": null
        //     }
        //
        // swap
        //
        //     {
        //         "method": "deals.update",
        //         "data": {
        //             "market": "BTCUSDT",
        //             "deal_list": [
        //                 {
        //                     "deal_id": 3514376759,
        //                     "created_at": 1689152421692,
        //                     "side": "buy",
        //                     "price": "30718.42",
        //                     "amount": "0.00000325"
        //                 },
        //             ]
        //         },
        //         "id": null
        //     }
        //
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object trades = this.safeList(data, "deal_list", new List<object>() {});
        object marketId = this.safeString(data, "market");
        object isSpot = isGreaterThan(getIndexOf(client.url, "spot"), -1);
        object defaultType = ((bool) isTrue(isSpot)) ? "spot" : "swap";
        object market = this.safeMarket(marketId, null, null, defaultType);
        object symbol = getValue(market, "symbol");
        object messageHash = add("trades:", symbol);
        object stored = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
        {
            object trade = getValue(trades, i);
            object parsed = this.parseWsTrade(trade, market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.trades, symbol), messageHash});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        // spot watchTrades
        //
        //     {
        //         "deal_id": 3514376759,
        //         "created_at": 1689152421692,
        //         "side": "buy",
        //         "price": "30718.42",
        //         "amount": "0.00000325"
        //     }
        //
        // swap watchTrades
        //
        //     {
        //         "deal_id": 3514376759,
        //         "created_at": 1689152421692,
        //         "side": "buy",
        //         "price": "30718.42",
        //         "amount": "0.00000325"
        //     }
        //
        // spot and swap watchMyTrades
        //
        //     {
        //         "deal_id": 3514376759,
        //         "created_at": 1689152421692,
        //         "market": "BTCUSDT",
        //         "side": "buy",
        //         "order_id": 8678890,
        //         "margin_market": "BTCUSDT",
        //         "price": "30718.42",
        //         "amount": "0.00000325",
        //         "role": "taker",
        //         "fee": "0.0299",
        //         "fee_ccy": "USDT"
        //     }
        //
        object timestamp = this.safeInteger(trade, "created_at");
        object isSpot = (inOp(trade, "margin_market"));
        object defaultType = ((bool) isTrue(isSpot)) ? "spot" : "swap";
        object marketId = this.safeString(trade, "market");
        market = this.safeMarket(marketId, market, null, defaultType);
        object fee = new Dictionary<string, object>() {};
        object feeCost = this.omitZero(this.safeString(trade, "fee"));
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrencyId = this.safeString(trade, "fee_ccy", getValue(market, "quote"));
            fee = new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(feeCurrencyId) },
                { "cost", feeCost },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", this.safeString(trade, "deal_id") },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", this.safeSymbol(marketId, market, null, defaultType) },
            { "order", this.safeString(trade, "order_id") },
            { "type", null },
            { "side", this.safeString(trade, "side") },
            { "takerOrMaker", this.safeString(trade, "role") },
            { "price", this.safeString(trade, "price") },
            { "amount", this.safeString(trade, "amount") },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    /**
     * @method
     * @name coinex#watchTicker
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://docs.coinex.com/api/v2/spot/market/ws/market
     * @see https://docs.coinex.com/api/v2/futures/market/ws/market-state
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object tickers = await this.watchTickers(new List<object>() {symbol}, parameters);
        return getValue(tickers, getValue(market, "symbol"));
    }

    /**
     * @method
     * @name coinex#watchTickers
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
     * @see https://docs.coinex.com/api/v2/spot/market/ws/market
     * @see https://docs.coinex.com/api/v2/futures/market/ws/market-state
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketIds = this.marketIds(symbols);
        object market = null;
        object messageHashes = new List<object>() {};
        object symbolsDefined = (!isEqual(symbols, null));
        if (isTrue(symbolsDefined))
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                market = this.market(symbol);
                ((IList<object>)messageHashes).Add(add("tickers::", getValue(market, "symbol")));
            }
        } else
        {
            ((IList<object>)messageHashes).Add("tickers");
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchTickers", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), type);
        object subscriptionHashes = new List<object>() {"all@ticker"};
        object subscribe = new Dictionary<string, object>() {
            { "method", "state.subscribe" },
            { "params", new Dictionary<string, object>() {
                { "market_list", marketIds },
            } },
            { "id", this.requestId() },
        };
        object result = await this.watchMultiple(url, messageHashes, this.deepExtend(subscribe, parameters), subscriptionHashes);
        if (isTrue(this.newUpdates))
        {
            return result;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    /**
     * @method
     * @name coinex#watchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://docs.coinex.com/api/v2/spot/market/ws/market-deals
     * @see https://docs.coinex.com/api/v2/futures/market/ws/market-deals
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["callerMethodName"] = "watchTrades";
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    /**
     * @method
     * @name coinex#watchTradesForSymbols
     * @description watch the most recent trades for a list of symbols
     * @see https://docs.coinex.com/api/v2/spot/market/ws/market-deals
     * @see https://docs.coinex.com/api/v2/futures/market/ws/market-deals
     * @param {string[]} symbols unified symbols of the markets to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object subscribedSymbols = new List<object>() {};
        object messageHashes = new List<object>() {};
        object market = null;
        object callerMethodName = null;
        var callerMethodNameparametersVariable = this.handleParamString(parameters, "callerMethodName", "watchTradesForSymbols");
        callerMethodName = ((IList<object>)callerMethodNameparametersVariable)[0];
        parameters = ((IList<object>)callerMethodNameparametersVariable)[1];
        object symbolsDefined = (!isEqual(symbols, null));
        if (isTrue(symbolsDefined))
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                market = this.market(symbol);
                ((IList<object>)subscribedSymbols).Add(getValue(market, "id"));
                ((IList<object>)messageHashes).Add(add("trades:", getValue(market, "symbol")));
            }
        } else
        {
            ((IList<object>)messageHashes).Add("trades");
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams(callerMethodName, market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), type);
        object subscriptionHashes = new List<object>() {"trades"};
        object subscribe = new Dictionary<string, object>() {
            { "method", "deals.subscribe" },
            { "params", new Dictionary<string, object>() {
                { "market_list", subscribedSymbols },
            } },
            { "id", this.requestId() },
        };
        object trades = await this.watchMultiple(url, messageHashes, this.deepExtend(subscribe, parameters), subscriptionHashes);
        if (isTrue(this.newUpdates))
        {
            return trades;
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    /**
     * @method
     * @name coinex#watchOrderBookForSymbols
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://docs.coinex.com/api/v2/spot/market/ws/market-depth
     * @see https://docs.coinex.com/api/v2/futures/market/ws/market-depth
     * @param {string[]} symbols unified array of symbols
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object watchOrderBookSubscriptions = new Dictionary<string, object>() {};
        object messageHashes = new List<object>() {};
        object market = null;
        object type = null;
        object callerMethodName = null;
        var callerMethodNameparametersVariable = this.handleParamString(parameters, "callerMethodName", "watchOrderBookForSymbols");
        callerMethodName = ((IList<object>)callerMethodNameparametersVariable)[0];
        parameters = ((IList<object>)callerMethodNameparametersVariable)[1];
        var typeparametersVariable = this.handleMarketTypeAndParams(callerMethodName, null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object options = this.safeDict(this.options, "watchOrderBook", new Dictionary<string, object>() {});
        object limits = this.safeList(options, "limits", new List<object>() {});
        if (isTrue(isEqual(limit, null)))
        {
            limit = this.safeInteger(options, "defaultLimit", 50);
        }
        if (!isTrue(this.inArray(limit, limits)))
        {
            throw new NotSupported ((string)add(add(this.id, " watchOrderBookForSymbols() limit must be one of "), String.Join(", ", ((IList<object>)limits).ToArray()))) ;
        }
        object defaultAggregation = this.safeString(options, "defaultAggregation", "0");
        object aggregations = this.safeList(options, "aggregations", new List<object>() {});
        object aggregation = this.safeString(parameters, "aggregation", defaultAggregation);
        if (!isTrue(this.inArray(aggregation, aggregations)))
        {
            throw new NotSupported ((string)add(add(this.id, " watchOrderBookForSymbols() aggregation must be one of "), String.Join(", ", ((IList<object>)aggregations).ToArray()))) ;
        }
        parameters = this.omit(parameters, "aggregation");
        object symbolsDefined = (!isEqual(symbols, null));
        if (isTrue(symbolsDefined))
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                market = this.market(symbol);
                ((IList<object>)messageHashes).Add(add("orderbook:", getValue(market, "symbol")));
                ((IDictionary<string,object>)watchOrderBookSubscriptions)[(string)symbol] = new List<object>() {getValue(market, "id"), limit, aggregation, true};
            }
        } else
        {
            ((IList<object>)messageHashes).Add("orderbook");
        }
        object marketList = new List<object>(((IDictionary<string,object>)watchOrderBookSubscriptions).Values);
        object subscribe = new Dictionary<string, object>() {
            { "method", "depth.subscribe" },
            { "params", new Dictionary<string, object>() {
                { "market_list", marketList },
            } },
            { "id", this.requestId() },
        };
        object subscriptionHashes = this.hash(this.encode(this.json(watchOrderBookSubscriptions)), sha256);
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), type);
        object orderbooks = await this.watchMultiple(url, messageHashes, this.deepExtend(subscribe, parameters), subscriptionHashes);
        if (isTrue(this.newUpdates))
        {
            return orderbooks;
        }
        return (orderbooks as IOrderBook).limit();
    }

    /**
     * @method
     * @name coinex#watchOrderBook
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://docs.coinex.com/api/v2/spot/market/ws/market-depth
     * @see https://docs.coinex.com/api/v2/futures/market/ws/market-depth
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["callerMethodName"] = "watchOrderBook";
        return await this.watchOrderBookForSymbols(new List<object>() {symbol}, limit, parameters);
    }

    public override void handleDelta(object bookside, object delta)
    {
        object bidAsk = this.parseBidAsk(delta, 0, 1);
        (bookside as IOrderBookSide).storeArray(bidAsk);
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //     {
        //         "method": "depth.update",
        //         "data": {
        //             "market": "BTCUSDT",
        //             "is_full": true,
        //             "depth": {
        //                 "asks": [
        //                     [
        //                         "30740.00",
        //                         "0.31763545"
        //                     ],
        //                 ],
        //                 "bids": [
        //                     [
        //                         "30736.00",
        //                         "0.04857373"
        //                     ],
        //                 ],
        //                 "last": "30746.28",
        //                 "updated_at": 1689152421692,
        //                 "checksum": 2578768879
        //             }
        //         },
        //         "id": null
        //     }
        //
        object defaultType = this.safeString(this.options, "defaultType");
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object depth = this.safeDict(data, "depth", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "market");
        object market = this.safeMarket(marketId, null, null, defaultType);
        object symbol = getValue(market, "symbol");
        object name = "orderbook";
        object messageHash = add(add(name, ":"), symbol);
        object timestamp = this.safeInteger(depth, "updated_at");
        object currentOrderBook = this.safeValue(this.orderbooks, symbol);
        object fullOrderBook = this.safeBool(data, "is_full", false);
        if (isTrue(fullOrderBook))
        {
            object snapshot = this.parseOrderBook(depth, symbol, timestamp);
            if (isTrue(isEqual(currentOrderBook, null)))
            {
                ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(snapshot);
            } else
            {
                object orderbook = getValue(this.orderbooks, symbol);
                (orderbook as IOrderBook).reset(snapshot);
            }
        } else
        {
            object asks = this.safeList(depth, "asks", new List<object>() {});
            object bids = this.safeList(depth, "bids", new List<object>() {});
            this.handleDeltas(getValue(currentOrderBook, "asks"), asks);
            this.handleDeltas(getValue(currentOrderBook, "bids"), bids);
            ((IDictionary<string,object>)currentOrderBook)["nonce"] = timestamp;
            ((IDictionary<string,object>)currentOrderBook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)currentOrderBook)["datetime"] = this.iso8601(timestamp);
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = currentOrderBook;
        }
        // this.checkOrderBookChecksum (this.orderbooks[symbol]);
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.orderbooks, symbol), messageHash});
    }

    /**
     * @method
     * @name coinex#watchOrders
     * @description watches information on multiple orders made by the user
     * @see https://docs.coinex.com/api/v2/spot/order/ws/user-order
     * @see https://docs.coinex.com/api/v2/futures/order/ws/user-order
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.trigger] if the orders to watch are trigger orders or not
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object stop = this.safeBool2(parameters, "trigger", "stop");
        parameters = this.omit(parameters, new List<object>() {"trigger", "stop"});
        object messageHash = "orders";
        object market = null;
        object marketList = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchOrders", market, parameters, "spot");
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        await this.authenticate(type);
        if (isTrue(!isEqual(symbol, null)))
        {
            marketList = new List<object>() {getValue(market, "id")};
            messageHash = add(messageHash, add(":", symbol));
        } else
        {
            marketList = new List<object>() {};
            if (isTrue(isEqual(type, "spot")))
            {
                messageHash = add(messageHash, ":spot");
            } else
            {
                messageHash = add(messageHash, ":swap");
            }
        }
        object method = null;
        if (isTrue(stop))
        {
            method = "stop.subscribe";
        } else
        {
            method = "order.subscribe";
        }
        object message = new Dictionary<string, object>() {
            { "method", method },
            { "params", new Dictionary<string, object>() {
                { "market_list", marketList },
            } },
            { "id", this.requestId() },
        };
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), type);
        object request = this.deepExtend(message, parameters);
        object orders = await this.watch(url, messageHash, request, messageHash, request);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleOrders(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //     {
        //         "method": "order.update",
        //         "data": {
        //             "event": "put",
        //             "order": {
        //                 "order_id": 12750,
        //                 "market": "BTCUSDT",
        //                 "margin_market": "BTCUSDT",
        //                 "type": "limit",
        //                 "side": "buy",
        //                 "price": "5999.00",
        //                 "amount": "1.50000000",
        //                 "unfill_amount": "1.50000000",
        //                 "fill_value": "1.50000000",
        //                 "taker_fee_rate": "0.0001",
        //                 "maker_fee_rate": "0.0001",
        //                 "base_ccy_fee": "0.0001",
        //                 "quote_ccy_fee": "0.0001",
        //                 "discount_ccy_fee": "0.0001",
        //                 "last_fill_amount": "0",
        //                 "last_fill_price": "0",
        //                 "client_id": "buy1_1234",
        //                 "created_at": 1689152421692,
        //                 "updated_at": 1689152421692,
        //             }
        //         },
        //         "id": null
        //     }
        //
        // spot stop
        //
        //     {
        //         "method": "stop.update",
        //         "data": {
        //             "event": 1,
        //             "stop": {
        //                 "stop_id": 102067022299,
        //                 "market": "BTCUSDT",
        //                 "margin_market": "BTCUSDT",
        //                 "type": "limit",
        //                 "side": "buy",
        //                 "price": "20000.00",
        //                 "amount": "0.10000000",
        //                 "trigger_price": "20000.00",
        //                 "trigger_direction": "lower",
        //                 "taker_fee_rate": "0.0016",
        //                 "maker_fee_rate": "0.0016",
        //                 "status": "active_success",
        //                 "client_id": "",
        //                 "created_at": 1689152996689,
        //                 "updated_at": 1689152996689,
        //             }
        //         },
        //         "id": null
        //     }
        //
        // swap
        //
        //     {
        //         "method": "order.update",
        //         "data": {
        //             "event": "put",
        //             "order": {
        //                 "order_id": 98388656341,
        //                 "stop_id": 0,
        //                 "market": "BTCUSDT",
        //                 "side": "buy",
        //                 "type": "limit",
        //                 "amount": "0.0010",
        //                 "price": "50000.00",
        //                 "unfilled_amount": "0.0010",
        //                 "filled_amount": "0",
        //                 "filled_value": "0",
        //                 "fee": "0",
        //                 "fee_ccy": "USDT",
        //                 "taker_fee_rate": "0.00046",
        //                 "maker_fee_rate": "0.00000000000000000000",
        //                 "client_id": "",
        //                 "last_filled_amount": "0.0010",
        //                 "last_filled_price": "30721.35",
        //                 "created_at": 1689145715129,
        //                 "updated_at": 1689145715129
        //             }
        //         },
        //         "id": null
        //     }
        //
        // swap stop
        //
        //     {
        //         "method": "stop.update",
        //         "data": {
        //             "event": "put",
        //             "stop": {
        //                 "stop_id": 98389557871,
        //                 "market": "BTCUSDT",
        //                 "side": "sell",
        //                 "type": "limit",
        //                 "price": "20000.00",
        //                 "amount": "0.0100",
        //                 "trigger_price": "20000.00",
        //                 "trigger_direction": "higer",
        //                 "trigger_price_type": "index_price",
        //                 "taker_fee_rate": "0.00046",
        //                 "maker_fee_rate": "0.00026",
        //                 "client_id": "",
        //                 "created_at": 1689146382674,
        //                 "updated_at": 1689146382674
        //             }
        //         },
        //         "id": null
        //     }
        //
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object order = this.safeDict2(data, "order", "stop", new Dictionary<string, object>() {});
        object parsedOrder = this.parseWsOrder(order);
        object symbol = getValue(parsedOrder, "symbol");
        object market = this.market(symbol);
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object orders = this.orders;
        callDynamically(orders, "append", new object[] {parsedOrder});
        object messageHash = "orders";
        object messageWithType = add(add(messageHash, ":"), getValue(market, "type"));
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageWithType});
        messageHash = add(messageHash, add(":", symbol));
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageHash});
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        // spot
        //
        //     {
        //         "order_id": 12750,
        //         "market": "BTCUSDT",
        //         "margin_market": "BTCUSDT",
        //         "type": "limit",
        //         "side": "buy",
        //         "price": "5999.00",
        //         "amount": "1.50000000",
        //         "unfill_amount": "1.50000000",
        //         "fill_value": "1.50000000",
        //         "taker_fee_rate": "0.0001",
        //         "maker_fee_rate": "0.0001",
        //         "base_ccy_fee": "0.0001",
        //         "quote_ccy_fee": "0.0001",
        //         "discount_ccy_fee": "0.0001",
        //         "last_fill_amount": "0",
        //         "last_fill_price": "0",
        //         "client_id": "buy1_1234",
        //         "created_at": 1689152421692,
        //         "updated_at": 1689152421692,
        //     }
        //
        // spot stop
        //
        //     {
        //         "stop_id": 102067022299,
        //         "market": "BTCUSDT",
        //         "margin_market": "BTCUSDT",
        //         "type": "limit",
        //         "side": "buy",
        //         "price": "20000.00",
        //         "amount": "0.10000000",
        //         "trigger_price": "20000.00",
        //         "trigger_direction": "lower",
        //         "taker_fee_rate": "0.0016",
        //         "maker_fee_rate": "0.0016",
        //         "status": "active_success",
        //         "client_id": "",
        //         "created_at": 1689152996689,
        //         "updated_at": 1689152996689,
        //     }
        //
        // swap
        //
        //     {
        //         "order_id": 98388656341,
        //         "stop_id": 0,
        //         "market": "BTCUSDT",
        //         "side": "buy",
        //         "type": "limit",
        //         "amount": "0.0010",
        //         "price": "50000.00",
        //         "unfilled_amount": "0.0010",
        //         "filled_amount": "0",
        //         "filled_value": "0",
        //         "fee": "0",
        //         "fee_ccy": "USDT",
        //         "taker_fee_rate": "0.00046",
        //         "maker_fee_rate": "0.00000000000000000000",
        //         "client_id": "",
        //         "last_filled_amount": "0.0010",
        //         "last_filled_price": "30721.35",
        //         "created_at": 1689145715129,
        //         "updated_at": 1689145715129
        //     }
        //
        // swap stop
        //
        //     {
        //         "stop_id": 98389557871,
        //         "market": "BTCUSDT",
        //         "side": "sell",
        //         "type": "limit",
        //         "price": "20000.00",
        //         "amount": "0.0100",
        //         "trigger_price": "20000.00",
        //         "trigger_direction": "higer",
        //         "trigger_price_type": "index_price",
        //         "taker_fee_rate": "0.00046",
        //         "maker_fee_rate": "0.00026",
        //         "client_id": "",
        //         "created_at": 1689146382674,
        //         "updated_at": 1689146382674
        //     }
        //
        object timestamp = this.safeInteger(order, "created_at");
        object marketId = this.safeString(order, "market");
        object status = this.safeString(order, "status");
        object isSpot = (inOp(order, "margin_market"));
        object defaultType = ((bool) isTrue(isSpot)) ? "spot" : "swap";
        market = this.safeMarket(marketId, market, null, defaultType);
        object fee = null;
        object feeCost = this.omitZero(this.safeString2(order, "fee", "quote_ccy_fee"));
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrencyId = this.safeString(order, "fee_ccy", getValue(market, "quote"));
            fee = new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(feeCurrencyId) },
                { "cost", feeCost },
            };
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString2(order, "order_id", "stop_id") },
            { "clientOrderId", this.safeString(order, "client_id") },
            { "datetime", this.iso8601(timestamp) },
            { "timestamp", timestamp },
            { "lastTradeTimestamp", this.safeInteger(order, "updated_at") },
            { "symbol", getValue(market, "symbol") },
            { "type", this.safeString(order, "type") },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", this.safeString(order, "side") },
            { "price", this.safeString(order, "price") },
            { "stopPrice", this.safeString(order, "trigger_price") },
            { "triggerPrice", this.safeString(order, "trigger_price") },
            { "amount", this.safeString(order, "amount") },
            { "filled", this.safeString2(order, "filled_amount", "fill_value") },
            { "remaining", this.safeString2(order, "unfilled_amount", "unfill_amount") },
            { "cost", null },
            { "average", null },
            { "status", this.parseWsOrderStatus(status) },
            { "fee", fee },
            { "trades", null },
        }, market);
    }

    public virtual object parseWsOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "active_success", "open" },
            { "active_fail", "canceled" },
            { "cancel", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name coinex#watchBidsAsks
     * @description watches best bid & ask for symbols
     * @see https://docs.coinex.com/api/v2/spot/market/ws/market-bbo
     * @see https://docs.coinex.com/api/v2/futures/market/ws/market-bbo
     * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchBidsAsks(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketIds = this.marketIds(symbols);
        object messageHashes = new List<object>() {};
        object market = null;
        object symbolsDefined = (!isEqual(symbols, null));
        if (isTrue(symbolsDefined))
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                market = this.market(symbol);
                ((IList<object>)messageHashes).Add(add("bidsasks:", getValue(market, "symbol")));
            }
        } else
        {
            ((IList<object>)messageHashes).Add("bidsasks");
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchBidsAsks", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), type);
        object subscriptionHashes = new List<object>() {"all@bidsasks"};
        object subscribe = new Dictionary<string, object>() {
            { "method", "bbo.subscribe" },
            { "params", new Dictionary<string, object>() {
                { "market_list", marketIds },
            } },
            { "id", this.requestId() },
        };
        object result = await this.watchMultiple(url, messageHashes, this.deepExtend(subscribe, parameters), subscriptionHashes);
        if (isTrue(this.newUpdates))
        {
            return result;
        }
        return this.filterByArray(this.bidsasks, "symbol", symbols);
    }

    public virtual void handleBidAsk(WebSocketClient client, object message)
    {
        //
        //     {
        //         "method": "bbo.update",
        //         "data": {
        //             "market": "BTCUSDT",
        //             "updated_at": 1656660154,
        //             "best_bid_price": "20000",
        //             "best_bid_size": "0.1",
        //             "best_ask_price": "20001",
        //             "best_ask_size": "0.15"
        //         },
        //         "id": null
        //     }
        //
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object parsedTicker = this.parseWsBidAsk(data);
        object symbol = getValue(parsedTicker, "symbol");
        ((IDictionary<string,object>)this.bidsasks)[(string)symbol] = parsedTicker;
        object messageHash = add("bidsasks:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {parsedTicker, messageHash});
    }

    public virtual object parseWsBidAsk(object ticker, object market = null)
    {
        //
        //     {
        //         "market": "BTCUSDT",
        //         "updated_at": 1656660154,
        //         "best_bid_price": "20000",
        //         "best_bid_size": "0.1",
        //         "best_ask_price": "20001",
        //         "best_ask_size": "0.15"
        //     }
        //
        object defaultType = this.safeString(this.options, "defaultType");
        object marketId = this.safeString(ticker, "market");
        market = this.safeMarket(marketId, market, null, defaultType);
        object timestamp = this.safeTimestamp(ticker, "updated_at");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(marketId, market, null, defaultType) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "ask", this.safeNumber(ticker, "best_ask_price") },
            { "askVolume", this.safeNumber(ticker, "best_ask_size") },
            { "bid", this.safeNumber(ticker, "best_bid_price") },
            { "bidVolume", this.safeNumber(ticker, "best_bid_size") },
            { "info", ticker },
        }, market);
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        object method = this.safeString(message, "method");
        object error = this.safeString(message, "message");
        if (isTrue(!isEqual(error, null)))
        {
            this.handleErrors(null, null, client.url, method, null, this.json(error), message, null, null);
        }
        object handlers = new Dictionary<string, object>() {
            { "state.update", this.handleTicker },
            { "balance.update", this.handleBalance },
            { "deals.update", this.handleTrades },
            { "user_deals.update", this.handleMyTrades },
            { "depth.update", this.handleOrderBook },
            { "order.update", this.handleOrders },
            { "stop.update", this.handleOrders },
            { "bbo.update", this.handleBidAsk },
        };
        object handler = this.safeValue(handlers, method);
        if (isTrue(!isEqual(handler, null)))
        {
            DynamicInvoker.InvokeMethod(handler, new object[] { client, message});
            return;
        }
        this.handleSubscriptionStatus(client as WebSocketClient, message);
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        //
        //     { "id": 1, "code": 20001, "message": "invalid argument" }
        //     { "id": 2, "code": 21001, "message": "require auth" }
        //     { "id": 1, "code": 21002, "message": "Signature Incorrect" }
        //
        object message = this.safeStringLower(response, "message");
        object isErrorMessage = isTrue((!isEqual(message, null))) && isTrue((!isEqual(message, "ok")));
        object errorCode = this.safeString(response, "code");
        object isErrorCode = isTrue((!isEqual(errorCode, null))) && isTrue((!isEqual(errorCode, "0")));
        if (isTrue(isTrue(isErrorCode) || isTrue(isErrorMessage)))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }

    public virtual void handleAuthenticationMessage(WebSocketClient client, object message)
    {
        //
        // success
        //
        //     {
        //         "id": 1,
        //         "code": 0,
        //         "message": "OK"
        //     }
        //
        // fail
        //
        //     {
        //         "id": 1,
        //         "code": 21002,
        //         "message": ""
        //     }
        //
        object status = this.safeStringLower(message, "message");
        object errorCode = this.safeString(message, "code");
        object messageHash = "authenticated";
        if (isTrue(isTrue((isEqual(status, "ok"))) || isTrue((isEqual(errorCode, "0")))))
        {
            var future = this.safeValue((client as WebSocketClient).futures, messageHash);
            (future as Future).resolve(true);
        } else
        {
            var error = new AuthenticationError(this.json(message));
            ((WebSocketClient)client).reject(error, messageHash);
            if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
            {
                ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
            }
        }
    }

    public virtual void handleSubscriptionStatus(WebSocketClient client, object message)
    {
        object id = this.safeInteger(message, "id");
        object subscription = this.safeValue(((WebSocketClient)client).subscriptions, id);
        if (isTrue(!isEqual(subscription, null)))
        {
            object futureIndex = this.safeString(subscription, "future");
            var future = this.safeValue((client as WebSocketClient).futures, futureIndex);
            if (isTrue(!isEqual(future, null)))
            {
                (future as Future).resolve(true);
            }
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)id);
        }
    }

    public async virtual Task<object> authenticate(object type)
    {
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), type);
        var client = this.client(url);
        object time = this.milliseconds();
        object timestamp = ((object)time).ToString();
        object messageHash = "authenticated";
        var future = client.future(messageHash);
        object authenticated = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(!isEqual(authenticated, null)))
        {
            return await (future as Exchange.Future);
        }
        object requestId = this.requestId();
        object subscribe = new Dictionary<string, object>() {
            { "id", requestId },
            { "future", messageHash },
        };
        object hmac = this.hmac(this.encode(timestamp), this.encode(this.secret), sha256, "hex");
        object request = new Dictionary<string, object>() {
            { "id", requestId },
            { "method", "server.sign" },
            { "params", new Dictionary<string, object>() {
                { "access_id", this.apiKey },
                { "signed_str", ((string)hmac).ToLower() },
                { "timestamp", time },
            } },
        };
        this.watch(url, messageHash, request, requestId, subscribe);
        ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)messageHash] = true;
        return await (future as Exchange.Future);
    }
}
