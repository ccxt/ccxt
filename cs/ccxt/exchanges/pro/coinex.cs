namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class coinex { public coinex(object args = null) : base(args) { } }
public partial class coinex : ccxt.coinex
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchBalance", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchTrades", true },
                { "watchMyTrades", false },
                { "watchOrders", true },
                { "watchOrderBook", true },
                { "watchOHLCV", true },
                { "fetchOHLCVWs", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "spot", "wss://socket.coinex.com/" },
                        { "swap", "wss://perpetual.coinex.com/" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "watchOHLCVWarning", true },
                { "timeframes", new Dictionary<string, object>() {
                    { "1m", 60 },
                    { "3m", 180 },
                    { "5m", 300 },
                    { "15m", 900 },
                    { "30m", 1800 },
                    { "1h", 3600 },
                    { "2h", 7200 },
                    { "4h", 14400 },
                    { "6h", 21600 },
                    { "12h", 43200 },
                    { "1d", 86400 },
                    { "3d", 259200 },
                    { "1w", 604800 },
                } },
                { "account", "spot" },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "limits", new List<object>() {5, 10, 20, 50} },
                    { "defaultLimit", 50 },
                    { "aggregations", new List<object>() {"10", "1", "0", "0.1", "0.01"} },
                    { "defaultAggregation", "0" },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {} },
            { "exceptions", new Dictionary<string, object>() {
                { "codes", new Dictionary<string, object>() {
                    { "1", typeof(BadRequest) },
                    { "2", typeof(ExchangeError) },
                    { "3", typeof(ExchangeNotAvailable) },
                    { "4", typeof(NotSupported) },
                    { "5", typeof(RequestTimeout) },
                    { "6", typeof(AuthenticationError) },
                } },
            } },
        });
    }

    public virtual object requestId()
    {
        object requestId = this.sum(this.safeInteger(this.options, "requestId", 0), 1);
        ((IDictionary<string,object>)this.options)["requestId"] = requestId;
        return requestId;
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        //  spot
        //
        //     {
        //         "method": "state.update",
        //         "params": [{
        //             "BTCUSDT": {
        //                 "last": "31577.89",
        //                 "open": "29318.36",
        //                 "close": "31577.89",
        //                 "high": "32222.19",
        //                 "low": "29317.21",
        //                 "volume": "630.43024965",
        //                 "sell_total": "13.66143951",
        //                 "buy_total": "2.76410939",
        //                 "period": 86400,
        //                 "deal": "19457487.84611409070000000000"
        //             }
        //         }]
        //     }
        //
        //  swap
        //
        //     {
        //         "method": "state.update",
        //         "params": [{
        //             "BTCUSDT": {
        //                 "period": 86400,
        //                 "funding_time": 422,
        //                 "position_amount": "285.6246",
        //                 "funding_rate_last": "-0.00097933",
        //                 "funding_rate_next": "0.00022519",
        //                 "funding_rate_predict": "0.00075190",
        //                 "insurance": "17474289.49925859030905338270",
        //                 "last": "31570.08",
        //                 "sign_price": "31568.09",
        //                 "index_price": "31561.85000000",
        //                 "open": "29296.11",
        //                 "close": "31570.08",
        //                 "high": "32463.40",
        //                 "low": "29296.11",
        //                 "volume": "8774.7318",
        //                 "deal": "270675177.827928219109030017258398",
        //                 "sell_total": "19.2230",
        //                 "buy_total": "25.7814"
        //             }
        //         }]
        //     }
        //
        object defaultType = this.safeString(this.options, "defaultType");
        object parameters = this.safeValue(message, "params", new List<object>() {});
        object rawTickers = this.safeValue(parameters, 0, new Dictionary<string, object>() {});
        object keys = new List<object>(((IDictionary<string,object>)rawTickers).Keys);
        object newTickers = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object marketId = getValue(keys, i);
            object rawTicker = getValue(rawTickers, marketId);
            object symbol = this.safeSymbol(marketId, null, null, defaultType);
            object market = this.safeMarket(marketId, null, null, defaultType);
            object parsedTicker = this.parseWSTicker(rawTicker, market);
            ((IDictionary<string,object>)this.tickers)[(string)symbol] = parsedTicker;
            ((IList<object>)newTickers).Add(parsedTicker);
        }
        object messageHashes = this.findMessageHashes(client as WebSocketClient, "tickers::");
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object tickers = this.filterByArray(newTickers, "symbol", symbols);
            object tickersSymbols = new List<object>(((IDictionary<string,object>)tickers).Keys);
            object numTickers = getArrayLength(tickersSymbols);
            if (isTrue(isGreaterThan(numTickers, 0)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {tickers, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newTickers, "tickers"});
    }

    public virtual object parseWSTicker(object ticker, object market = null)
    {
        //
        //  spot
        //
        //     {
        //         "last": "31577.89",
        //         "open": "29318.36",
        //         "close": "31577.89",
        //         "high": "32222.19",
        //         "low": "29317.21",
        //         "volume": "630.43024965",
        //         "sell_total": "13.66143951",
        //         "buy_total": "2.76410939",
        //         "period": 86400,
        //         "deal": "19457487.84611409070000000000"
        //     }
        //
        //  swap
        //
        //     {
        //         "period": 86400,
        //         "funding_time": 422,
        //         "position_amount": "285.6246",
        //         "funding_rate_last": "-0.00097933",
        //         "funding_rate_next": "0.00022519",
        //         "funding_rate_predict": "0.00075190",
        //         "insurance": "17474289.49925859030905338270",
        //         "last": "31570.08",
        //         "sign_price": "31568.09",
        //         "index_price": "31561.85000000",
        //         "open": "29296.11",
        //         "close": "31570.08",
        //         "high": "32463.40",
        //         "low": "29296.11",
        //         "volume": "8774.7318",
        //         "deal": "270675177.827928219109030017258398",
        //         "sell_total": "19.2230",
        //         "buy_total": "25.7814"
        //     }
        //
        object defaultType = this.safeString(this.options, "defaultType");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(null, market, null, defaultType) },
            { "timestamp", null },
            { "datetime", null },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", null },
            { "bidVolume", this.safeString(ticker, "buy_total") },
            { "ask", null },
            { "askVolume", this.safeString(ticker, "sell_total") },
            { "vwap", null },
            { "open", this.safeString(ticker, "open") },
            { "close", this.safeString(ticker, "close") },
            { "last", this.safeString(ticker, "last") },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "volume") },
            { "quoteVolume", this.safeString(ticker, "deal") },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @name coinex#watchBalance
        * @description watch balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate(parameters);
        object messageHash = "balance";
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), type);
        object currencies = new List<object>(((IDictionary<string,object>)this.currencies_by_id).Keys);
        object subscribe = new Dictionary<string, object>() {
            { "method", "asset.subscribe" },
            { "params", currencies },
            { "id", this.requestId() },
        };
        object request = this.deepExtend(subscribe, parameters);
        return await this.watch(url, messageHash, request, messageHash);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        //     {
        //         "method": "asset.update",
        //         "params": [
        //             {
        //                 "BTC": {
        //                     "available": "250",
        //                     "frozen": "10",
        //                 }
        //             }
        //         ],
        //         "id": null
        //     }
        //
        object parameters = this.safeValue(message, "params", new List<object>() {});
        object first = this.safeValue(parameters, 0, new Dictionary<string, object>() {});
        ((IDictionary<string,object>)this.balance)["info"] = first;
        object currencies = new List<object>(((IDictionary<string,object>)first).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencies, i);
            object code = this.safeCurrencyCode(currencyId);
            object available = this.safeString(getValue(first, currencyId), "available");
            object frozen = this.safeString(getValue(first, currencyId), "frozen");
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = available;
            ((IDictionary<string,object>)account)["used"] = frozen;
            ((IDictionary<string,object>)this.balance)[(string)code] = account;
            this.balance = this.safeBalance(this.balance);
        }
        object messageHash = "balance";
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, messageHash});
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //         "method": "deals.update",
        //         "params": [
        //             "BTCUSD",
        //             [{
        //                 "type": "sell",
        //                 "time": 1496458040.059284,
        //                 "price ": "46444.74",
        //                 "id": 29433,
        //                 "amount": "0.00120000"
        //             }]
        //         ],
        //         "id": null
        //     }
        //
        object parameters = this.safeValue(message, "params", new List<object>() {});
        object marketId = this.safeString(parameters, 0);
        object trades = this.safeValue(parameters, 1, new List<object>() {});
        object defaultType = this.safeString(this.options, "defaultType");
        object market = this.safeMarket(marketId, null, null, defaultType);
        object symbol = getValue(market, "symbol");
        object messageHash = add("trades:", symbol);
        object stored = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
        {
            object trade = getValue(trades, i);
            object parsed = this.parseWsTrade(trade, market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.trades, symbol), messageHash});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        //     {
        //         "type": "sell",
        //         "time": 1496458040.059284,
        //         "price ": "46444.74",
        //         "id": 29433,
        //         "amount": "0.00120000"
        //     }
        //
        object timestamp = this.safeTimestamp(trade, "time");
        object defaultType = this.safeString(this.options, "defaultType");
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", this.safeString(trade, "id") },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", this.safeSymbol(null, market, null, defaultType) },
            { "order", null },
            { "type", null },
            { "side", this.safeString(trade, "type") },
            { "takerOrMaker", null },
            { "price", this.safeString(trade, "price") },
            { "amount", this.safeString(trade, "amount") },
            { "cost", null },
            { "fee", null },
        }, market);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //  spot
        //     {
        //         "error": null,
        //         "result": [
        //           [
        //             1673846940,
        //             "21148.74",
        //             "21148.38",
        //             "21148.75",
        //             "21138.66",
        //             "1.57060173",
        //             "33214.9138778914"
        //           ],
        //         ]
        //         "id": 1,
        //     }
        //  swap
        //     {
        //         "method": "kline.update",
        //         "params": [
        //             [
        //                 1654019640,   // timestamp
        //                 "32061.99",   // open
        //                 "32061.28",   // close
        //                 "32061.99",   // high
        //                 "32061.28",   // low
        //                 "0.1285",     // amount base
        //                 "4119.943736" // amount quote
        //             ]
        //         ],
        //         "id": null
        //     }
        //
        object candles = this.safeValue2(message, "params", "result", new List<object>() {});
        object messageHash = "ohlcv";
        object id = this.safeString(message, "id");
        object ohlcvs = this.parseOHLCVs(candles);
        if (isTrue(!isEqual(id, null)))
        {
            // spot subscription response
            callDynamically(client as WebSocketClient, "resolve", new object[] {ohlcvs, messageHash});
            return;
        }
        object keys = new List<object>(((IDictionary<string,object>)this.ohlcvs).Keys);
        object keysLength = getArrayLength(keys);
        if (isTrue(isEqual(keysLength, 0)))
        {
            ((IDictionary<string,object>)this.ohlcvs)["unknown"] = new Dictionary<string, object>() {};
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            var stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, "unknown"))["unknown"] = stored;
        }
        object ohlcv = getValue(getValue(this.ohlcvs, "unknown"), "unknown");
        for (object i = 0; isLessThan(i, getArrayLength(ohlcvs)); postFixIncrement(ref i))
        {
            object candle = getValue(ohlcvs, i);
            callDynamically(ohlcv, "append", new object[] {candle});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {ohlcv, messageHash});
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinex#watchTicker
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot004_websocket007_state_subscribe
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object tickers = await this.watchTickers(new List<object>() {symbol}, parameters);
        return this.safeValue(tickers, symbol);
    }

    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#watchTickers
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot004_websocket007_state_subscribe
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
        * @param {string[]} symbols unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchTickers", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), type);
        object messageHash = "tickers";
        if (isTrue(!isEqual(symbols, null)))
        {
            messageHash = add("tickers::", String.Join(",", ((IList<object>)symbols).ToArray()));
        }
        object subscribe = new Dictionary<string, object>() {
            { "method", "state.subscribe" },
            { "id", this.requestId() },
            { "params", new List<object>() {} },
        };
        object request = this.deepExtend(subscribe, parameters);
        object newTickers = await this.watch(url, messageHash, request, messageHash);
        if (isTrue(this.newUpdates))
        {
            return newTickers;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#watchTrades
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot004_websocket012_deal_subcribe
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures002_websocket019_deal_subcribe
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchTrades", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), type);
        object messageHash = add("trades:", symbol);
        object subscriptionHash = "trades";
        object subscribedSymbols = this.safeValue(this.options, "watchTradesSubscriptions", new List<object>() {});
        ((IList<object>)subscribedSymbols).Add(getValue(market, "id"));
        object message = new Dictionary<string, object>() {
            { "method", "deals.subscribe" },
            { "params", subscribedSymbols },
            { "id", this.requestId() },
        };
        ((IDictionary<string,object>)this.options)["watchTradesSubscriptions"] = subscribedSymbols;
        object request = this.deepExtend(message, parameters);
        object trades = await this.watch(url, messageHash, request, subscriptionHash);
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#watchOrderBook
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot004_websocket017_depth_subscribe_multi
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures002_websocket011_depth_subscribe_multi
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchOrderBook", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), type);
        object name = "orderbook";
        object messageHash = add(add(name, ":"), symbol);
        object options = this.safeValue(this.options, "watchOrderBook", new Dictionary<string, object>() {});
        object limits = this.safeValue(options, "limits", new List<object>() {});
        if (isTrue(isEqual(limit, null)))
        {
            limit = this.safeValue(options, "defaultLimit", 50);
        }
        if (!isTrue(this.inArray(limit, limits)))
        {
            throw new NotSupported ((string)add(add(this.id, " watchOrderBook() limit must be one of "), String.Join(", ", ((IList<object>)limits).ToArray()))) ;
        }
        object defaultAggregation = this.safeString(options, "defaultAggregation", "0");
        object aggregations = this.safeValue(options, "aggregations", new List<object>() {});
        object aggregation = this.safeString(parameters, "aggregation", defaultAggregation);
        if (!isTrue(this.inArray(aggregation, aggregations)))
        {
            throw new NotSupported ((string)add(add(this.id, " watchOrderBook() aggregation must be one of "), String.Join(", ", ((IList<object>)aggregations).ToArray()))) ;
        }
        parameters = this.omit(parameters, "aggregation");
        object watchOrderBookSubscriptions = this.safeValue(this.options, "watchOrderBookSubscriptions", new Dictionary<string, object>() {});
        ((IDictionary<string,object>)watchOrderBookSubscriptions)[(string)symbol] = new List<object>() {getValue(market, "id"), limit, aggregation, true};
        object subscribe = new Dictionary<string, object>() {
            { "method", "depth.subscribe_multi" },
            { "id", this.requestId() },
            { "params", new List<object>(((IDictionary<string,object>)watchOrderBookSubscriptions).Values) },
        };
        ((IDictionary<string,object>)this.options)["watchOrderBookSubscriptions"] = watchOrderBookSubscriptions;
        object subscriptionHash = this.hash(this.encode(this.json(watchOrderBookSubscriptions)), sha256);
        object request = this.deepExtend(subscribe, parameters);
        object orderbook = await this.watch(url, messageHash, request, subscriptionHash, request);
        return (orderbook as IOrderBook).limit();
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#watchOHLCV
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures002_websocket023_kline_subscribe
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchOHLCV", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(!isEqual(type, "swap")))
        {
            throw new NotSupported ((string)add(this.id, " watchOHLCV() is only supported for swap markets. Try using fetchOHLCV () instead")) ;
        }
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), type);
        object messageHash = "ohlcv";
        object watchOHLCVWarning = this.safeBool(this.options, "watchOHLCVWarning", true);
        var client = this.safeValue(this.clients, url, new Dictionary<string, object>() {});
        object clientSub = this.safeValue(client as WebSocketClient, "subscriptions", new Dictionary<string, object>() {});
        object existingSubscription = this.safeValue(clientSub, messageHash);
        object subSymbol = this.safeString(existingSubscription, "symbol");
        object subTimeframe = this.safeString(existingSubscription, "timeframe");
        // due to nature of coinex response can only watch one symbol at a time
        if (isTrue(isTrue(isTrue(watchOHLCVWarning) && isTrue(!isEqual(existingSubscription, null))) && isTrue((isTrue(!isEqual(subSymbol, symbol)) || isTrue(!isEqual(subTimeframe, timeframe))))))
        {
            throw new ExchangeError ((string)add(this.id, " watchOHLCV() can only watch one symbol and timeframe at a time. To supress this warning set watchOHLCVWarning to false in options")) ;
        }
        object timeframes = this.safeValue(this.options, "timeframes", new Dictionary<string, object>() {});
        object subscribe = new Dictionary<string, object>() {
            { "method", "kline.subscribe" },
            { "id", this.requestId() },
            { "params", new List<object>() {getValue(market, "id"), this.safeInteger(timeframes, timeframe)} },
        };
        object subscription = new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timeframe", timeframe },
        };
        object request = this.deepExtend(subscribe, parameters);
        object ohlcvs = await this.watch(url, messageHash, request, messageHash, subscription);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcvs, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcvs, since, limit, 0);
    }

    public async override Task<object> fetchOHLCVWs(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchOHLCV
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot004_websocket005_kline_query
        * @description query historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to query OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the exchange API endpoint
        * @param {int|undefined} params.end the end time for spot markets, this.seconds () is set as default
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var typequeryVariable = this.handleMarketTypeAndParams("fetchOHLCV", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), type);
        symbol = getValue(market, "symbol");
        object messageHash = "ohlcv";
        object timeframes = this.safeValue(this.options, "timeframes", new Dictionary<string, object>() {});
        timeframe = this.safeString(timeframes, timeframe, timeframe);
        if (isTrue(isEqual(since, null)))
        {
            since = 1640995200; // January 1, 2022
        }
        object id = this.requestId();
        object subscribe = new Dictionary<string, object>() {
            { "method", "kline.query" },
            { "params", new List<object>() {getValue(market, "id"), this.parseToInt(divide(since, 1000)), this.safeInteger(parameters, "end", this.seconds()), this.parseToInt(timeframe)} },
            { "id", id },
        };
        object subscription = new Dictionary<string, object>() {
            { "id", id },
            { "future", messageHash },
        };
        object subscriptionHash = id;
        object request = this.deepExtend(subscribe, query);
        object ohlcvs = await this.watch(url, messageHash, request, subscriptionHash, subscription);
        return this.filterBySinceLimit(ohlcvs, since, limit, 0);
    }

    public override void handleDelta(object bookside, object delta)
    {
        object bidAsk = this.parseBidAsk(delta, 0, 1);
        (bookside as IOrderBookSide).storeArray(bidAsk);
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //     {
        //         "method": "depth.update",
        //         "params": [
        //             false,
        //             {
        //                 "asks": [
        //                     ["46350.52", "1.07871851"],
        //                     ...
        //                 ],
        //                 "bids": [
        //                     ["46349.61", "0.04000000"],
        //                     ...
        //                 ],
        //                 "last": "46349.93",
        //                 "time": 1639987469166,
        //                 "checksum": 1533284725
        //             },
        //             "BTCUSDT"
        //         ],
        //         "id": null
        //     }
        //
        object parameters = this.safeValue(message, "params", new List<object>() {});
        object fullOrderBook = this.safeValue(parameters, 0);
        object orderbook = this.safeValue(parameters, 1);
        object marketId = this.safeString(parameters, 2);
        object defaultType = this.safeString(this.options, "defaultType");
        object market = this.safeMarket(marketId, null, null, defaultType);
        object symbol = getValue(market, "symbol");
        object name = "orderbook";
        object messageHash = add(add(name, ":"), symbol);
        object timestamp = this.safeInteger(orderbook, "time");
        object currentOrderBook = this.safeValue(this.orderbooks, symbol);
        if (isTrue(fullOrderBook))
        {
            object snapshot = this.parseOrderBook(orderbook, symbol, timestamp);
            if (isTrue(isEqual(currentOrderBook, null)))
            {
                orderbook = this.orderBook(snapshot);
                ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
            } else
            {
                orderbook = getValue(this.orderbooks, symbol);
                (orderbook as IOrderBook).reset(snapshot);
            }
        } else
        {
            object asks = this.safeValue(orderbook, "asks", new List<object>() {});
            object bids = this.safeValue(orderbook, "bids", new List<object>() {});
            this.handleDeltas(getValue(currentOrderBook, "asks"), asks);
            this.handleDeltas(getValue(currentOrderBook, "bids"), bids);
            ((IDictionary<string,object>)currentOrderBook)["nonce"] = timestamp;
            ((IDictionary<string,object>)currentOrderBook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)currentOrderBook)["datetime"] = this.iso8601(timestamp);
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = currentOrderBook;
        }
        // this.checkOrderBookChecksum (this.orderbooks[symbol]);
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.orderbooks, symbol), messageHash});
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate(parameters);
        object messageHash = "orders";
        object market = null;
        var typequeryVariable = this.handleMarketTypeAndParams("watchOrders", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        object message = new Dictionary<string, object>() {
            { "method", "order.subscribe" },
            { "id", this.requestId() },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            ((IDictionary<string,object>)message)["params"] = new List<object>() {getValue(market, "id")};
            messageHash = add(messageHash, add(":", symbol));
        } else
        {
            ((IDictionary<string,object>)message)["params"] = new List<object>() {};
        }
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), type);
        object request = this.deepExtend(message, query);
        object orders = await this.watch(url, messageHash, request, messageHash, request);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleOrders(WebSocketClient client, object message)
    {
        //
        //  spot
        //
        //      {
        //          "method": "order.update",
        //          "params": [
        //              1,
        //              {
        //                  "id": 77782469357,
        //                  "type": 1,
        //                  "side": 2,
        //                  "user": 1849116,
        //                  "account": 0,
        //                  "option": 2,
        //                  "ctime": 1653961043.048967,
        //                  "mtime": 1653961043.048967,
        //                  "market": "BTCUSDT",
        //                  "source": "web",
        //                  "client_id": '',
        //                  "price": "1.00",
        //                  "amount": "1.00000000",
        //                  "taker_fee": "0.0020",
        //                  "maker_fee": "0.0020",
        //                  "left": "1.00000000",
        //                  "deal_stock": "0",
        //                  "deal_money": "0",
        //                  "money_fee": "0",
        //                  "stock_fee": "0",
        //                  "asset_fee": "0",
        //                  "fee_discount": "1",
        //                  "last_deal_amount": "0",
        //                  "last_deal_price": "0",
        //                  "last_deal_time": 0,
        //                  "last_deal_id": 0,
        //                  "last_role": 0,
        //                  "fee_asset": null,
        //                  "stop_id": 0
        //              }
        //          ],
        //          "id": null
        //      }
        //
        //  swap
        //
        //      {
        //          "method": "order.update",
        //          "params": [
        //              1,
        //              {
        //                  "order_id": 23423462821,
        //                  "position_id": 0,
        //                  "stop_id": 0,
        //                  "market": "BTCUSDT",
        //                  "type": 1,
        //                  "side": 2,
        //                  "target": 0,
        //                  "effect_type": 1,
        //                  "user_id": 1849116,
        //                  "create_time": 1653961509.25049,
        //                  "update_time": 1653961509.25049,
        //                  "source": "web",
        //                  "price": "1.00",
        //                  "amount": "1.0000",
        //                  "taker_fee": "0.00050",
        //                  "maker_fee": "0.00030",
        //                  "left": "1.0000",
        //                  "deal_stock": "0.00000000000000000000",
        //                  "deal_fee": "0.00000000000000000000",
        //                  "deal_profit": "0.00000000000000000000",
        //                  "last_deal_amount": "0.00000000000000000000",
        //                  "last_deal_price": "0.00000000000000000000",
        //                  "last_deal_time": 0,
        //                  "last_deal_id": 0,
        //                  "last_deal_type": 0,
        //                  "last_deal_role": 0,
        //                  "client_id": '',
        //                  "fee_asset": '',
        //                  "fee_discount": "0.00000000000000000000",
        //                  "deal_asset_fee": "0.00000000000000000000",
        //                  "leverage": "3",
        //                  "position_type": 2
        //              }
        //          ],
        //          "id": null
        //      }
        //
        object parameters = this.safeValue(message, "params", new List<object>() {});
        object order = this.safeValue(parameters, 1, new Dictionary<string, object>() {});
        object parsedOrder = this.parseWsOrder(order);
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object orders = this.orders;
        callDynamically(orders, "append", new object[] {parsedOrder});
        object messageHash = "orders";
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageHash});
        messageHash = add(messageHash, add(":", getValue(parsedOrder, "symbol")));
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageHash});
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        //  spot
        //
        //       {
        //           "id": 77782469357,
        //           "type": 1,
        //           "side": 2,
        //           "user": 1849116,
        //           "account": 0,
        //           "option": 2,
        //           "ctime": 1653961043.048967,
        //           "mtime": 1653961043.048967,
        //           "market": "BTCUSDT",
        //           "source": "web",
        //           "client_id": '',
        //           "price": "1.00",
        //           "amount": "1.00000000",
        //           "taker_fee": "0.0020",
        //           "maker_fee": "0.0020",
        //           "left": "1.00000000",
        //           "deal_stock": "0",
        //           "deal_money": "0",
        //           "money_fee": "0",
        //           "stock_fee": "0",
        //           "asset_fee": "0",
        //           "fee_discount": "1",
        //           "last_deal_amount": "0",
        //           "last_deal_price": "0",
        //           "last_deal_time": 0,
        //           "last_deal_id": 0,
        //           "last_role": 0,
        //           "fee_asset": null,
        //           "stop_id": 0
        //       }
        //
        //  swap
        //
        //      {
        //          "order_id": 23423462821,
        //          "position_id": 0,
        //          "stop_id": 0,
        //          "market": "BTCUSDT",
        //          "type": 1,
        //          "side": 2,
        //          "target": 0,
        //          "effect_type": 1,
        //          "user_id": 1849116,
        //          "create_time": 1653961509.25049,
        //          "update_time": 1653961509.25049,
        //          "source": "web",
        //          "price": "1.00",
        //          "amount": "1.0000",
        //          "taker_fee": "0.00050",
        //          "maker_fee": "0.00030",
        //          "left": "1.0000",
        //          "deal_stock": "0.00000000000000000000",
        //          "deal_fee": "0.00000000000000000000",
        //          "deal_profit": "0.00000000000000000000",
        //          "last_deal_amount": "0.00000000000000000000",
        //          "last_deal_price": "0.00000000000000000000",
        //          "last_deal_time": 0,
        //          "last_deal_id": 0,
        //          "last_deal_type": 0,
        //          "last_deal_role": 0,
        //          "client_id": '',
        //          "fee_asset": '',
        //          "fee_discount": "0.00000000000000000000",
        //          "deal_asset_fee": "0.00000000000000000000",
        //          "leverage": "3",
        //          "position_type": 2
        //      }
        //
        //  order.update_stop
        //
        //       {
        //           "id": 78006745870,
        //           "type": 1,
        //           "side": 2,
        //           "user": 1849116,
        //           "account": 1,
        //           "option": 70,
        //           "direction": 1,
        //           "ctime": 1654171725.131976,
        //           "mtime": 1654171725.131976,
        //           "market": "BTCUSDT",
        //           "source": "web",
        //           "client_id": '',
        //           "stop_price": "1.00",
        //           "price": "1.00",
        //           "amount": "1.00000000",
        //           "taker_fee": "0.0020",
        //           "maker_fee": "0.0020",
        //           "fee_discount": "1",
        //           "fee_asset": null,
        //           "status": 0
        //       }
        //
        object timestamp = this.safeTimestamp2(order, "update_time", "mtime");
        object marketId = this.safeString(order, "market");
        object typeCode = this.safeString(order, "type");
        object type = this.safeString(new Dictionary<string, object>() {
            { "1", "limit" },
            { "2", "market" },
        }, typeCode);
        object sideCode = this.safeString(order, "side");
        object side = this.safeString(new Dictionary<string, object>() {
            { "1", "sell" },
            { "2", "buy" },
        }, sideCode);
        object remaining = this.safeString(order, "left");
        object amount = this.safeString(order, "amount");
        object status = this.safeString(order, "status");
        object defaultType = this.safeString(this.options, "defaultType");
        market = this.safeMarket(marketId, market, null, defaultType);
        object cost = this.safeString(order, "deal_money");
        object filled = this.safeString(order, "deal_stock");
        object average = null;
        if (isTrue(getValue(market, "swap")))
        {
            object leverage = this.safeString(order, "leverage");
            cost = Precise.stringDiv(filled, leverage);
            average = Precise.stringDiv(filled, amount);
            filled = null;
        }
        object fee = null;
        object feeCost = this.omitZero(this.safeString(order, "money_fee"));
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrencyId = this.safeString(order, "fee_asset", getValue(market, "quote"));
            fee = new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(feeCurrencyId) },
                { "cost", feeCost },
            };
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString2(order, "order_id", "id") },
            { "clientOrderId", this.safeString(order, "client_id") },
            { "datetime", this.iso8601(timestamp) },
            { "timestamp", timestamp },
            { "lastTradeTimestamp", this.safeTimestamp(order, "last_deal_time") },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", this.safeString(order, "price") },
            { "stopPrice", this.safeString(order, "stop_price") },
            { "triggerPrice", this.safeString(order, "stop_price") },
            { "amount", amount },
            { "filled", filled },
            { "remaining", remaining },
            { "cost", cost },
            { "average", average },
            { "status", this.parseWsOrderStatus(status) },
            { "fee", fee },
            { "trades", null },
        }, market);
    }

    public virtual object parseWsOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "0", "pending" },
            { "1", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        object error = this.safeValue(message, "error");
        if (isTrue(!isEqual(error, null)))
        {
            throw new ExchangeError ((string)add(add(this.id, " "), this.json(error))) ;
        }
        object method = this.safeString(message, "method");
        object handlers = new Dictionary<string, object>() {
            { "state.update", this.handleTicker },
            { "asset.update", this.handleBalance },
            { "deals.update", this.handleTrades },
            { "depth.update", this.handleOrderBook },
            { "order.update", this.handleOrders },
            { "kline.update", this.handleOHLCV },
            { "order.update_stop", this.handleOrders },
        };
        object handler = this.safeValue(handlers, method);
        if (isTrue(!isEqual(handler, null)))
        {
            DynamicInvoker.InvokeMethod(handler, new object[] { client, message});
            return;
        }
        this.handleSubscriptionStatus(client as WebSocketClient, message);
    }

    public virtual object handleAuthenticationMessage(WebSocketClient client, object message)
    {
        //
        //     {
        //         "error": null,
        //         "result": {
        //             "status": "success"
        //         },
        //         "id": 1
        //     }
        //
        object messageHashSpot = "authenticated:spot";
        object messageHashSwap = "authenticated:swap";
        // client.resolve (message, messageHashSpot);
        // client.resolve (message, messageHashSwap);
        object spotFuture = this.safeValue((client as WebSocketClient).futures, messageHashSpot);
        callDynamically(spotFuture, "resolve", new object[] {true});
        object swapFutures = this.safeValue((client as WebSocketClient).futures, messageHashSwap);
        callDynamically(swapFutures, "resolve", new object[] {true});
        return message;
    }

    public virtual void handleSubscriptionStatus(WebSocketClient client, object message)
    {
        object id = this.safeInteger(message, "id");
        object subscription = this.safeValue(((WebSocketClient)client).subscriptions, id);
        if (isTrue(!isEqual(subscription, null)))
        {
            object futureIndex = this.safeString(subscription, "future");
            if (isTrue(isEqual(futureIndex, "ohlcv")))
            {
                this.handleOHLCV(client as WebSocketClient, message);
                return;
            }
            var future = this.safeValue((client as WebSocketClient).futures, futureIndex);
            if (isTrue(!isEqual(future, null)))
            {
                (future as Future).resolve(true);
            }

        }
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("authenticate", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), type);
        var client = this.client(url);
        object time = this.milliseconds();
        object isSpot = (isEqual(type, "spot"));
        object spotMessageHash = "authenticated:spot";
        object swapMessageHash = "authenticated:swap";
        object messageHash = ((bool) isTrue(isSpot)) ? spotMessageHash : swapMessageHash;
        var future = client.future(messageHash);
        object authenticated = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(type, "spot")))
        {
            if (isTrue(!isEqual(authenticated, null)))
            {
                return await (future as Exchange.Future);
            }
            object requestId = this.requestId();
            object subscribe = new Dictionary<string, object>() {
                { "id", requestId },
                { "future", spotMessageHash },
            };
            object signData = add(add(add(add(add("access_id=", this.apiKey), "&tonce="), this.numberToString(time)), "&secret_key="), this.secret);
            object hash = this.hash(this.encode(signData), md5);
            object request = new Dictionary<string, object>() {
                { "method", "server.sign" },
                { "params", new List<object>() {this.apiKey, ((string)hash).ToUpper(), time} },
                { "id", requestId },
            };
            this.watch(url, messageHash, request, requestId, subscribe);
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)messageHash] = true;
            return await (future as Exchange.Future);
        } else
        {
            if (isTrue(!isEqual(authenticated, null)))
            {
                return await (future as Exchange.Future);
            }
            object requestId = this.requestId();
            object subscribe = new Dictionary<string, object>() {
                { "id", requestId },
                { "future", swapMessageHash },
            };
            object signData = add(add(add(add(add("access_id=", this.apiKey), "&timestamp="), this.numberToString(time)), "&secret_key="), this.secret);
            object hash = this.hash(this.encode(signData), sha256, "hex");
            object request = new Dictionary<string, object>() {
                { "method", "server.sign" },
                { "params", new List<object>() {this.apiKey, ((string)hash).ToLower(), time} },
                { "id", requestId },
            };
            this.watch(url, messageHash, request, requestId, subscribe);
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)messageHash] = true;
            return await (future as Exchange.Future);
        }
    }
}
