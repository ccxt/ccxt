namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class bybit { public bybit(object args = null) : base(args) { } }
public partial class bybit : ccxt.bybit
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "createOrderWs", true },
                { "editOrderWs", true },
                { "fetchOpenOrdersWs", false },
                { "fetchOrderWs", false },
                { "cancelOrderWs", true },
                { "cancelOrdersWs", false },
                { "cancelAllOrdersWs", false },
                { "fetchTradesWs", false },
                { "fetchBalanceWs", false },
                { "watchBalance", true },
                { "watchMyTrades", true },
                { "watchOHLCV", true },
                { "watchOHLCVForSymbols", false },
                { "watchOrderBook", true },
                { "watchOrderBookForSymbols", true },
                { "watchOrders", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchTrades", true },
                { "watchPositions", true },
                { "watchTradesForSymbols", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", new Dictionary<string, object>() {
                            { "spot", "wss://stream.{hostname}/v5/public/spot" },
                            { "inverse", "wss://stream.{hostname}/v5/public/inverse" },
                            { "option", "wss://stream.{hostname}/v5/public/option" },
                            { "linear", "wss://stream.{hostname}/v5/public/linear" },
                        } },
                        { "private", new Dictionary<string, object>() {
                            { "spot", new Dictionary<string, object>() {
                                { "unified", "wss://stream.{hostname}/v5/private" },
                                { "nonUnified", "wss://stream.{hostname}/spot/private/v3" },
                            } },
                            { "contract", "wss://stream.{hostname}/v5/private" },
                            { "usdc", "wss://stream.{hostname}/trade/option/usdc/private/v1" },
                            { "trade", "wss://stream-testnet.bybit.com/v5/trade" },
                        } },
                    } },
                } },
                { "test", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", new Dictionary<string, object>() {
                            { "spot", "wss://stream-testnet.{hostname}/v5/public/spot" },
                            { "inverse", "wss://stream-testnet.{hostname}/v5/public/inverse" },
                            { "linear", "wss://stream-testnet.{hostname}/v5/public/linear" },
                            { "option", "wss://stream-testnet.{hostname}/v5/public/option" },
                        } },
                        { "private", new Dictionary<string, object>() {
                            { "spot", new Dictionary<string, object>() {
                                { "unified", "wss://stream-testnet.{hostname}/v5/private" },
                                { "nonUnified", "wss://stream-testnet.{hostname}/spot/private/v3" },
                            } },
                            { "contract", "wss://stream-testnet.{hostname}/v5/private" },
                            { "usdc", "wss://stream-testnet.{hostname}/trade/option/usdc/private/v1" },
                            { "trade", "wss://stream-testnet.bybit.com/v5/trade" },
                        } },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "watchTicker", new Dictionary<string, object>() {
                    { "name", "tickers" },
                } },
                { "watchPositions", new Dictionary<string, object>() {
                    { "fetchPositionsSnapshot", true },
                    { "awaitPositionsSnapshot", true },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "timeframes", new Dictionary<string, object>() {
                        { "1m", "1m" },
                        { "3m", "3m" },
                        { "5m", "5m" },
                        { "15m", "15m" },
                        { "30m", "30m" },
                        { "1h", "1h" },
                        { "2h", "2h" },
                        { "4h", "4h" },
                        { "6h", "6h" },
                        { "12h", "12h" },
                        { "1d", "1d" },
                        { "1w", "1w" },
                        { "1M", "1M" },
                    } },
                } },
                { "contract", new Dictionary<string, object>() {
                    { "timeframes", new Dictionary<string, object>() {
                        { "1m", "1" },
                        { "3m", "3" },
                        { "5m", "5" },
                        { "15m", "15" },
                        { "30m", "30" },
                        { "1h", "60" },
                        { "2h", "120" },
                        { "4h", "240" },
                        { "6h", "360" },
                        { "12h", "720" },
                        { "1d", "D" },
                        { "1w", "W" },
                        { "1M", "M" },
                    } },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "ping", this.ping },
                { "keepAlive", 19000 },
            } },
        });
    }

    public virtual object requestId()
    {
        object requestId = this.sum(this.safeInteger(this.options, "requestId", 0), 1);
        ((IDictionary<string,object>)this.options)["requestId"] = requestId;
        return requestId;
    }

    public virtual object getUrlByMarketType(object symbol = null, object isPrivate = null, object method = null, object parameters = null)
    {
        isPrivate ??= false;
        parameters ??= new Dictionary<string, object>();
        object accessibility = ((bool) isTrue(isPrivate)) ? "private" : "public";
        object isUsdcSettled = null;
        object isSpot = null;
        object type = null;
        object market = null;
        object url = getValue(getValue(this.urls, "api"), "ws");
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            isUsdcSettled = isEqual(getValue(market, "settle"), "USDC");
            type = getValue(market, "type");
        } else
        {
            var typeparametersVariable = this.handleMarketTypeAndParams(method, null, parameters);
            type = ((IList<object>)typeparametersVariable)[0];
            parameters = ((IList<object>)typeparametersVariable)[1];
            object defaultSettle = this.safeString(this.options, "defaultSettle");
            defaultSettle = this.safeString2(parameters, "settle", "defaultSettle", defaultSettle);
            isUsdcSettled = (isEqual(defaultSettle, "USDC"));
        }
        isSpot = (isEqual(type, "spot"));
        if (isTrue(isPrivate))
        {
            url = ((bool) isTrue((isUsdcSettled))) ? getValue(getValue(url, accessibility), "usdc") : getValue(getValue(url, accessibility), "contract");
        } else
        {
            if (isTrue(isSpot))
            {
                url = getValue(getValue(url, accessibility), "spot");
            } else if (isTrue(isEqual(type, "swap")))
            {
                object subType = null;
                var subTypeparametersVariable = this.handleSubTypeAndParams(method, market, parameters, "linear");
                subType = ((IList<object>)subTypeparametersVariable)[0];
                parameters = ((IList<object>)subTypeparametersVariable)[1];
                url = getValue(getValue(url, accessibility), subType);
            } else
            {
                // option
                url = getValue(getValue(url, accessibility), "option");
            }
        }
        url = this.implodeHostname(url);
        return url;
    }

    public virtual object cleanParams(object parameters)
    {
        parameters = this.omit(parameters, new List<object>() {"type", "subType", "settle", "defaultSettle", "unifiedMargin"});
        return parameters;
    }

    public async override Task<object> createOrderWs(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#createOrderWs
        * @description create a trade order
        * @see https://bybit-exchange.github.io/docs/v5/order/create-order
        * @see https://bybit-exchange.github.io/docs/v5/websocket/trade/guideline#createamendcancel-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.timeInForce] "GTC", "IOC", "FOK"
        * @param {bool} [params.postOnly] true or false whether the order is post-only
        * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only
        * @param {string} [params.positionIdx] *contracts only*  0 for one-way mode, 1 buy side  of hedged mode, 2 sell side of hedged mode
        * @param {boolean} [params.isLeverage] *unified spot only* false then spot trading true then margin trading
        * @param {string} [params.tpslMode] *contract only* 'full' or 'partial'
        * @param {string} [params.mmp] *option only* market maker protection
        * @param {string} [params.triggerDirection] *contract only* the direction for trigger orders, 'above' or 'below'
        * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
        * @param {float} [params.stopLossPrice] The price at which a stop loss order is triggered at
        * @param {float} [params.takeProfitPrice] The price at which a take profit order is triggered at
        * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered
        * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
        * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered
        * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
        * @param {string} [params.trailingAmount] the quote amount to trail away from the current market price
        * @param {string} [params.trailingTriggerPrice] the price to trigger a trailing order, default uses the price argument
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orderRequest = this.createOrderRequest(symbol, type, side, amount, price, parameters, true);
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "private"), "trade");
        await this.authenticate(url);
        object requestId = ((object)this.requestId()).ToString();
        object request = new Dictionary<string, object>() {
            { "op", "order.create" },
            { "reqId", requestId },
            { "args", new List<object>() {orderRequest} },
            { "header", new Dictionary<string, object>() {
                { "X-BAPI-TIMESTAMP", ((object)this.milliseconds()).ToString() },
                { "X-BAPI-RECV-WINDOW", ((object)getValue(this.options, "recvWindow")).ToString() },
            } },
        };
        return await this.watch(url, requestId, request, requestId, true);
    }

    public async override Task<object> editOrderWs(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#editOrderWs
        * @description edit a trade order
        * @see https://bybit-exchange.github.io/docs/v5/order/amend-order
        * @see https://bybit-exchange.github.io/docs/v5/websocket/trade/guideline#createamendcancel-order
        * @param {string} id cancel order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} price the price at which the order is to be fullfilled, in units of the base currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.triggerPrice] The price that a trigger order is triggered at
        * @param {float} [params.stopLossPrice] The price that a stop loss order is triggered at
        * @param {float} [params.takeProfitPrice] The price that a take profit order is triggered at
        * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice that the attached take profit order will be triggered
        * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
        * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice that the attached stop loss order will be triggered
        * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
        * @param {string} [params.triggerBy] 'IndexPrice', 'MarkPrice' or 'LastPrice', default is 'LastPrice', required if no initial value for triggerPrice
        * @param {string} [params.slTriggerBy] 'IndexPrice', 'MarkPrice' or 'LastPrice', default is 'LastPrice', required if no initial value for stopLoss
        * @param {string} [params.tpTriggerby] 'IndexPrice', 'MarkPrice' or 'LastPrice', default is 'LastPrice', required if no initial value for takeProfit
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orderRequest = this.editOrderRequest(id, symbol, type, side, amount, price, parameters);
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "private"), "trade");
        await this.authenticate(url);
        object requestId = ((object)this.requestId()).ToString();
        object request = new Dictionary<string, object>() {
            { "op", "order.amend" },
            { "reqId", requestId },
            { "args", new List<object>() {orderRequest} },
            { "header", new Dictionary<string, object>() {
                { "X-BAPI-TIMESTAMP", ((object)this.milliseconds()).ToString() },
                { "X-BAPI-RECV-WINDOW", ((object)getValue(this.options, "recvWindow")).ToString() },
            } },
        };
        return await this.watch(url, requestId, request, requestId, true);
    }

    public async override Task<object> cancelOrderWs(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#cancelOrderWs
        * @description cancels an open order
        * @see https://bybit-exchange.github.io/docs/v5/order/cancel-order
        * @see https://bybit-exchange.github.io/docs/v5/websocket/trade/guideline#createamendcancel-order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.stop] *spot only* whether the order is a stop order
        * @param {string} [params.orderFilter] *spot only* 'Order' or 'StopOrder' or 'tpslOrder'
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orderRequest = this.cancelOrderRequest(id, symbol, parameters);
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "private"), "trade");
        await this.authenticate(url);
        object requestId = ((object)this.requestId()).ToString();

        object request = new Dictionary<string, object>() {
            { "op", "order.cancel" },
            { "reqId", requestId },
            { "args", new List<object>() {orderRequest} },
            { "header", new Dictionary<string, object>() {
                { "X-BAPI-TIMESTAMP", ((object)this.milliseconds()).ToString() },
                { "X-BAPI-RECV-WINDOW", ((object)getValue(this.options, "recvWindow")).ToString() },
            } },
        };
        return await this.watch(url, requestId, request, requestId, true);
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bybit#watchTicker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://bybit-exchange.github.io/docs/v5/websocket/public/ticker
        * @see https://bybit-exchange.github.io/docs/v5/websocket/public/etp-ticker
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object messageHash = add("ticker:", symbol);
        object url = this.getUrlByMarketType(symbol, false, "watchTicker", parameters);
        parameters = this.cleanParams(parameters);
        object options = this.safeValue(this.options, "watchTicker", new Dictionary<string, object>() {});
        object topic = this.safeString(options, "name", "tickers");
        if (isTrue(!isTrue(getValue(market, "spot")) && isTrue(!isEqual(topic, "tickers"))))
        {
            throw new BadRequest ((string)add(this.id, " watchTicker() only supports name tickers for contract markets")) ;
        }
        topic = add(topic, add(".", getValue(market, "id")));
        object topics = new List<object>() {topic};
        return await this.watchTopics(url, new List<object>() {messageHash}, topics, parameters);
    }

    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#watchTickers
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
        * @see https://bybit-exchange.github.io/docs/v5/websocket/public/ticker
        * @see https://bybit-exchange.github.io/docs/v5/websocket/public/etp-ticker
        * @param {string[]} symbols unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object messageHashes = new List<object>() {};
        object url = this.getUrlByMarketType(getValue(symbols, 0), false, "watchTickers", parameters);
        parameters = this.cleanParams(parameters);
        object options = this.safeValue(this.options, "watchTickers", new Dictionary<string, object>() {});
        object topic = this.safeString(options, "name", "tickers");
        object marketIds = this.marketIds(symbols);
        object topics = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = getValue(marketIds, i);
            ((IList<object>)topics).Add(add(add(topic, "."), marketId));
            ((IList<object>)messageHashes).Add(add("ticker:", getValue(symbols, i)));
        }
        object ticker = await this.watchTopics(url, messageHashes, topics, parameters);
        if (isTrue(this.newUpdates))
        {
            object result = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)result)[(string)getValue(ticker, "symbol")] = ticker;
            return result;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        // linear
        //     {
        //         "topic": "tickers.BTCUSDT",
        //         "type": "snapshot",
        //         "data": {
        //             "symbol": "BTCUSDT",
        //             "tickDirection": "PlusTick",
        //             "price24hPcnt": "0.017103",
        //             "lastPrice": "17216.00",
        //             "prevPrice24h": "16926.50",
        //             "highPrice24h": "17281.50",
        //             "lowPrice24h": "16915.00",
        //             "prevPrice1h": "17238.00",
        //             "markPrice": "17217.33",
        //             "indexPrice": "17227.36",
        //             "openInterest": "68744.761",
        //             "openInterestValue": "1183601235.91",
        //             "turnover24h": "1570383121.943499",
        //             "volume24h": "91705.276",
        //             "nextFundingTime": "1673280000000",
        //             "fundingRate": "-0.000212",
        //             "bid1Price": "17215.50",
        //             "bid1Size": "84.489",
        //             "ask1Price": "17216.00",
        //             "ask1Size": "83.020"
        //         },
        //         "cs": 24987956059,
        //         "ts": 1673272861686
        //     }
        //
        // option
        //     {
        //         "id": "tickers.BTC-6JAN23-17500-C-2480334983-1672917511074",
        //         "topic": "tickers.BTC-6JAN23-17500-C",
        //         "ts": 1672917511074,
        //         "data": {
        //             "symbol": "BTC-6JAN23-17500-C",
        //             "bidPrice": "0",
        //             "bidSize": "0",
        //             "bidIv": "0",
        //             "askPrice": "10",
        //             "askSize": "5.1",
        //             "askIv": "0.514",
        //             "lastPrice": "10",
        //             "highPrice24h": "25",
        //             "lowPrice24h": "5",
        //             "markPrice": "7.86976724",
        //             "indexPrice": "16823.73",
        //             "markPriceIv": "0.4896",
        //             "underlyingPrice": "16815.1",
        //             "openInterest": "49.85",
        //             "turnover24h": "446802.8473",
        //             "volume24h": "26.55",
        //             "totalVolume": "86",
        //             "totalTurnover": "1437431",
        //             "delta": "0.047831",
        //             "gamma": "0.00021453",
        //             "vega": "0.81351067",
        //             "theta": "-19.9115368",
        //             "predictedDeliveryPrice": "0",
        //             "change24h": "-0.33333334"
        //         },
        //         "type": "snapshot"
        //     }
        //
        // spot
        //     {
        //         "topic": "tickers.BTCUSDT",
        //         "ts": 1673853746003,
        //         "type": "snapshot",
        //         "cs": 2588407389,
        //         "data": {
        //             "symbol": "BTCUSDT",
        //             "lastPrice": "21109.77",
        //             "highPrice24h": "21426.99",
        //             "lowPrice24h": "20575",
        //             "prevPrice24h": "20704.93",
        //             "volume24h": "6780.866843",
        //             "turnover24h": "141946527.22907118",
        //             "price24hPcnt": "0.0196",
        //             "usdIndexPrice": "21120.2400136"
        //         }
        //     }
        //
        // lt ticker
        //     {
        //         "topic": "tickers_lt.EOS3LUSDT",
        //         "ts": 1672325446847,
        //         "type": "snapshot",
        //         "data": {
        //             "symbol": "EOS3LUSDT",
        //             "lastPrice": "0.41477848043290448",
        //             "highPrice24h": "0.435285472510871305",
        //             "lowPrice24h": "0.394601507960931382",
        //             "prevPrice24h": "0.431502290172376349",
        //             "price24hPcnt": "-0.0388"
        //         }
        //     }
        // swap delta
        //     {
        //         "topic":"tickers.AAVEUSDT",
        //         "type":"delta",
        //         "data":{
        //            "symbol":"AAVEUSDT",
        //            "bid1Price":"112.89",
        //            "bid1Size":"2.12",
        //            "ask1Price":"112.90",
        //            "ask1Size":"5.02"
        //         },
        //         "cs":78039939929,
        //         "ts":1709210212704
        //     }
        //
        object topic = this.safeString(message, "topic", "");
        object updateType = this.safeString(message, "type", "");
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object isSpot = !isEqual(this.safeString(data, "usdIndexPrice"), null);
        object type = ((bool) isTrue(isSpot)) ? "spot" : "contract";
        object symbol = null;
        object parsed = null;
        if (isTrue((isEqual(updateType, "snapshot"))))
        {
            parsed = this.parseTicker(data);
            symbol = getValue(parsed, "symbol");
        } else if (isTrue(isEqual(updateType, "delta")))
        {
            object topicParts = ((string)topic).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
            object topicLength = getArrayLength(topicParts);
            object marketId = this.safeString(topicParts, subtract(topicLength, 1));
            object market = this.safeMarket(marketId, null, null, type);
            symbol = getValue(market, "symbol");
            // update the info in place
            object ticker = this.safeDict(this.tickers, symbol, new Dictionary<string, object>() {});
            object rawTicker = this.safeDict(ticker, "info", new Dictionary<string, object>() {});
            object merged = this.extend(rawTicker, data);
            parsed = this.parseTicker(merged);
        }
        object timestamp = this.safeInteger(message, "ts");
        ((IDictionary<string,object>)parsed)["timestamp"] = timestamp;
        ((IDictionary<string,object>)parsed)["datetime"] = this.iso8601(timestamp);
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = parsed;
        object messageHash = add("ticker:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.tickers, symbol), messageHash});
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#watchOHLCV
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://bybit-exchange.github.io/docs/v5/websocket/public/kline
        * @see https://bybit-exchange.github.io/docs/v5/websocket/public/etp-kline
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object url = this.getUrlByMarketType(symbol, false, "watchOHLCV", parameters);
        parameters = this.cleanParams(parameters);
        object ohlcv = null;
        object timeframeId = this.safeString(this.timeframes, timeframe, timeframe);
        object topics = new List<object>() {add(add(add("kline.", timeframeId), "."), getValue(market, "id"))};
        object messageHash = add(add(add(add("kline", ":"), timeframeId), ":"), symbol);
        ohlcv = await this.watchTopics(url, new List<object>() {messageHash}, topics, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "topic": "kline.5.BTCUSDT",
        //         "data": [
        //             {
        //                 "start": 1672324800000,
        //                 "end": 1672325099999,
        //                 "interval": "5",
        //                 "open": "16649.5",
        //                 "close": "16677",
        //                 "high": "16677",
        //                 "low": "16608",
        //                 "volume": "2.081",
        //                 "turnover": "34666.4005",
        //                 "confirm": false,
        //                 "timestamp": 1672324988882
        //             }
        //         ],
        //         "ts": 1672324988882,
        //         "type": "snapshot"
        //     }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object topic = this.safeString(message, "topic");
        object topicParts = ((string)topic).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object topicLength = getArrayLength(topicParts);
        object timeframeId = this.safeString(topicParts, 1);
        object timeframe = this.findTimeframe(timeframeId);
        object marketId = this.safeString(topicParts, subtract(topicLength, 1));
        object isSpot = isGreaterThan(getIndexOf(client.url, "spot"), -1);
        object marketType = ((bool) isTrue(isSpot)) ? "spot" : "contract";
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        object ohlcvsByTimeframe = this.safeValue(this.ohlcvs, symbol);
        if (isTrue(isEqual(ohlcvsByTimeframe, null)))
        {
            ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = new Dictionary<string, object>() {};
        }
        object stored = this.safeValue(ohlcvsByTimeframe, timeframe);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
        }
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object parsed = this.parseWsOHLCV(getValue(data, i));
            callDynamically(stored, "append", new object[] {parsed});
        }
        object messageHash = add(add(add(add("kline", ":"), timeframeId), ":"), symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public override object parseWsOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "start": 1670363160000,
        //         "end": 1670363219999,
        //         "interval": "1",
        //         "open": "16987.5",
        //         "close": "16987.5",
        //         "high": "16988",
        //         "low": "16987.5",
        //         "volume": "23.511",
        //         "turnover": "399396.344",
        //         "confirm": false,
        //         "timestamp": 1670363219614
        //     }
        //
        return new List<object> {this.safeInteger(ohlcv, "start"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber2(ohlcv, "volume", "turnover")};
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#watchOrderBook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://bybit-exchange.github.io/docs/v5/websocket/public/orderbook
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return.
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchOrderBookForSymbols(new List<object>() {symbol}, limit, parameters);
    }

    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#watchOrderBook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://bybit-exchange.github.io/docs/v5/websocket/public/orderbook
        * @param {string[]} symbols unified array of symbols
        * @param {int} [limit] the maximum amount of order book entries to return.
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object symbolsLength = getArrayLength(symbols);
        if (isTrue(isEqual(symbolsLength, 0)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchOrderBookForSymbols() requires a non-empty array of symbols")) ;
        }
        symbols = this.marketSymbols(symbols);
        object url = this.getUrlByMarketType(getValue(symbols, 0), false, "watchOrderBook", parameters);
        parameters = this.cleanParams(parameters);
        object market = this.market(getValue(symbols, 0));
        if (isTrue(isEqual(limit, null)))
        {
            limit = ((bool) isTrue((getValue(market, "spot")))) ? 50 : 500;
        } else
        {
            if (!isTrue(getValue(market, "spot")))
            {
                // bybit only support limit 1, 50, 200, 500 for contract
                if (isTrue(isTrue(isTrue(isTrue((!isEqual(limit, 1))) && isTrue((!isEqual(limit, 50)))) && isTrue((!isEqual(limit, 200)))) && isTrue((!isEqual(limit, 500)))))
                {
                    throw new BadRequest ((string)add(this.id, " watchOrderBookForSymbols() can only use limit 1, 50, 200 and 500.")) ;
                }
            }
        }
        object topics = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object marketId = this.marketId(symbol);
            object topic = add(add(add("orderbook.", ((object)limit).ToString()), "."), marketId);
            ((IList<object>)topics).Add(topic);
            object messageHash = add("orderbook:", symbol);
            ((IList<object>)messageHashes).Add(messageHash);
        }
        object orderbook = await this.watchTopics(url, messageHashes, topics, parameters);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //     {
        //         "topic": "orderbook.50.BTCUSDT",
        //         "type": "snapshot",
        //         "ts": 1672304484978,
        //         "data": {
        //             "s": "BTCUSDT",
        //             "b": [
        //                 ...,
        //                 [
        //                     "16493.50",
        //                     "0.006"
        //                 ],
        //                 [
        //                     "16493.00",
        //                     "0.100"
        //                 ]
        //             ],
        //             "a": [
        //                 [
        //                     "16611.00",
        //                     "0.029"
        //                 ],
        //                 [
        //                     "16612.00",
        //                     "0.213"
        //                 ],
        //             ],
        //             "u": 18521288,
        //             "seq": 7961638724
        //         }
        //     }
        //
        object isSpot = isGreaterThanOrEqual(getIndexOf(client.url, "spot"), 0);
        object type = this.safeString(message, "type");
        object isSnapshot = (isEqual(type, "snapshot"));
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "s");
        object marketType = ((bool) isTrue(isSpot)) ? "spot" : "contract";
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger(message, "ts");
        object orderbook = this.safeValue(this.orderbooks, symbol);
        if (isTrue(isEqual(orderbook, null)))
        {
            orderbook = this.orderBook();
        }
        if (isTrue(isSnapshot))
        {
            object snapshot = this.parseOrderBook(data, symbol, timestamp, "b", "a");
            (orderbook as IOrderBook).reset(snapshot);
        } else
        {
            object asks = this.safeValue(data, "a", new List<object>() {});
            object bids = this.safeValue(data, "b", new List<object>() {});
            this.handleDeltas(getValue(orderbook, "asks"), asks);
            this.handleDeltas(getValue(orderbook, "bids"), bids);
            ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        }
        object messageHash = add(add("orderbook", ":"), symbol);
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public override void handleDelta(object bookside, object delta)
    {
        object bidAsk = this.parseBidAsk(delta, 0, 1);
        (bookside as IOrderBookSide).storeArray(bidAsk);
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#watchTrades
        * @description watches information on multiple trades made in a market
        * @see https://bybit-exchange.github.io/docs/v5/websocket/public/trade
        * @param {string} symbol unified market symbol of the market trades were made in
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trade structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#watchTradesForSymbols
        * @description get the list of most recent trades for a list of symbols
        * @see https://bybit-exchange.github.io/docs/v5/websocket/public/trade
        * @param {string[]} symbols unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object symbolsLength = getArrayLength(symbols);
        if (isTrue(isEqual(symbolsLength, 0)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchTradesForSymbols() requires a non-empty array of symbols")) ;
        }
        parameters = this.cleanParams(parameters);
        object url = this.getUrlByMarketType(getValue(symbols, 0), false, "watchTrades", parameters);
        object topics = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = this.market(symbol);
            object topic = add("publicTrade.", getValue(market, "id"));
            ((IList<object>)topics).Add(topic);
            object messageHash = add("trade:", symbol);
            ((IList<object>)messageHashes).Add(messageHash);
        }
        object trades = await this.watchTopics(url, messageHashes, topics, parameters);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeValue(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //         "topic": "publicTrade.BTCUSDT",
        //         "type": "snapshot",
        //         "ts": 1672304486868,
        //         "data": [
        //             {
        //                 "T": 1672304486865,
        //                 "s": "BTCUSDT",
        //                 "S": "Buy",
        //                 "v": "0.001",
        //                 "p": "16578.50",
        //                 "L": "PlusTick",
        //                 "i": "20f43950-d8dd-5b31-9112-a178eb6023af",
        //                 "BT": false
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object topic = this.safeString(message, "topic");
        object trades = data;
        object parts = ((string)topic).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object isSpot = isGreaterThanOrEqual(getIndexOf(client.url, "spot"), 0);
        object marketType = ((bool) isTrue((isSpot))) ? "spot" : "contract";
        object marketId = this.safeString(parts, 1);
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        object stored = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        for (object j = 0; isLessThan(j, getArrayLength(trades)); postFixIncrement(ref j))
        {
            object parsed = this.parseWsTrade(getValue(trades, j), market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        object messageHash = add(add("trade", ":"), symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        // public
        //    {
        //         "T": 1672304486865,
        //         "s": "BTCUSDT",
        //         "S": "Buy",
        //         "v": "0.001",
        //         "p": "16578.50",
        //         "L": "PlusTick",
        //         "i": "20f43950-d8dd-5b31-9112-a178eb6023af",
        //         "BT": false
        //     }
        //
        // spot private
        //     {
        //         "e": "ticketInfo",
        //         "E": "1662348310386",
        //         "s": "BTCUSDT",
        //         "q": "0.001007",
        //         "t": "1662348310373",
        //         "p": "19842.02",
        //         "T": "2100000000002220938",
        //         "o": "1238261807653647872",
        //         "c": "spotx008",
        //         "O": "1238225004531834368",
        //         "a": "533287",
        //         "A": "642908",
        //         "m": false,
        //         "S": "BUY"
        //     }
        //
        object id = this.safeStringN(trade, new List<object>() {"i", "T", "v"});
        object isContract = (inOp(trade, "BT"));
        object marketType = ((bool) isTrue(isContract)) ? "contract" : "spot";
        if (isTrue(!isEqual(market, null)))
        {
            marketType = getValue(market, "type");
        }
        object marketId = this.safeString(trade, "s");
        market = this.safeMarket(marketId, market, null, marketType);
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger2(trade, "t", "T");
        object side = this.safeStringLower(trade, "S");
        object takerOrMaker = null;
        object m = this.safeValue(trade, "m");
        if (isTrue(isEqual(side, null)))
        {
            side = ((bool) isTrue(m)) ? "buy" : "sell";
        } else
        {
            // spot private
            takerOrMaker = m;
        }
        object price = this.safeString(trade, "p");
        object amount = this.safeString2(trade, "q", "v");
        object orderId = this.safeString(trade, "o");
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "order", orderId },
            { "type", null },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", null },
        }, market);
    }

    public virtual object getPrivateType(object url)
    {
        if (isTrue(isGreaterThanOrEqual(getIndexOf(url, "spot"), 0)))
        {
            return "spot";
        } else if (isTrue(isGreaterThanOrEqual(getIndexOf(url, "v5/private"), 0)))
        {
            return "unified";
        } else
        {
            return "usdc";
        }
    }

    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#watchMyTrades
        * @description watches information on multiple trades made by the user
        * @see https://bybit-exchange.github.io/docs/v5/websocket/private/execution
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.unifiedMargin] use unified margin account
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
        */
        parameters ??= new Dictionary<string, object>();
        object method = "watchMyTrades";
        object messageHash = "myTrades";
        await this.loadMarkets();
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
            messageHash = add(messageHash, add(":", symbol));
        }
        object url = this.getUrlByMarketType(symbol, true, method, parameters);
        await this.authenticate(url);
        object topicByMarket = new Dictionary<string, object>() {
            { "spot", "ticketInfo" },
            { "unified", "execution" },
            { "usdc", "user.openapi.perp.trade" },
        };
        object topic = this.safeValue(topicByMarket, this.getPrivateType(url));
        object trades = await this.watchTopics(url, new List<object>() {messageHash}, new List<object>() {topic}, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleMyTrades(WebSocketClient client, object message)
    {
        //
        // spot
        //    {
        //        "type": "snapshot",
        //        "topic": "ticketInfo",
        //        "ts": "1662348310388",
        //        "data": [
        //            {
        //                "e": "ticketInfo",
        //                "E": "1662348310386",
        //                "s": "BTCUSDT",
        //                "q": "0.001007",
        //                "t": "1662348310373",
        //                "p": "19842.02",
        //                "T": "2100000000002220938",
        //                "o": "1238261807653647872",
        //                "c": "spotx008",
        //                "O": "1238225004531834368",
        //                "a": "533287",
        //                "A": "642908",
        //                "m": false,
        //                "S": "BUY"
        //            }
        //        ]
        //    }
        // unified
        //     {
        //         "id": "592324803b2785-26fa-4214-9963-bdd4727f07be",
        //         "topic": "execution",
        //         "creationTime": 1672364174455,
        //         "data": [
        //             {
        //                 "category": "linear",
        //                 "symbol": "XRPUSDT",
        //                 "execFee": "0.005061",
        //                 "execId": "7e2ae69c-4edf-5800-a352-893d52b446aa",
        //                 "execPrice": "0.3374",
        //                 "execQty": "25",
        //                 "execType": "Trade",
        //                 "execValue": "8.435",
        //                 "isMaker": false,
        //                 "feeRate": "0.0006",
        //                 "tradeIv": "",
        //                 "markIv": "",
        //                 "blockTradeId": "",
        //                 "markPrice": "0.3391",
        //                 "indexPrice": "",
        //                 "underlyingPrice": "",
        //                 "leavesQty": "0",
        //                 "orderId": "f6e324ff-99c2-4e89-9739-3086e47f9381",
        //                 "orderLinkId": "",
        //                 "orderPrice": "0.3207",
        //                 "orderQty": "25",
        //                 "orderType": "Market",
        //                 "stopOrderType": "UNKNOWN",
        //                 "side": "Sell",
        //                 "execTime": "1672364174443",
        //                 "isLeverage": "0"
        //             }
        //         ]
        //     }
        //
        object topic = this.safeString(message, "topic");
        object spot = isEqual(topic, "ticketInfo");
        object data = this.safeValue(message, "data", new List<object>() {});
        if (!isTrue(((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            data = this.safeValue(data, "result", new List<object>() {});
        }
        if (isTrue(isEqual(this.myTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            this.myTrades = new ArrayCacheBySymbolById(limit);
        }
        object trades = this.myTrades;
        object symbols = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object rawTrade = getValue(data, i);
            object parsed = null;
            if (isTrue(spot))
            {
                parsed = this.parseWsTrade(rawTrade);
            } else
            {
                parsed = this.parseTrade(rawTrade);
            }
            object symbol = getValue(parsed, "symbol");
            ((IDictionary<string,object>)symbols)[(string)symbol] = true;
            callDynamically(trades, "append", new object[] {parsed});
        }
        object keys = new List<object>(((IDictionary<string,object>)symbols).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object currentMessageHash = add("myTrades:", getValue(keys, i));
            callDynamically(client as WebSocketClient, "resolve", new object[] {trades, currentMessageHash});
        }
        // non-symbol specific
        object messageHash = "myTrades";
        callDynamically(client as WebSocketClient, "resolve", new object[] {trades, messageHash});
    }

    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#watchPositions
        * @see https://bybit-exchange.github.io/docs/v5/websocket/private/position
        * @description watch all open positions
        * @param {string[]} [symbols] list of unified market symbols
        * @param {object} params extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object method = "watchPositions";
        object messageHash = "";
        if (!isTrue(this.isEmpty(symbols)))
        {
            symbols = this.marketSymbols(symbols);
            messageHash = add("::", String.Join(",", ((IList<object>)symbols).ToArray()));
        }
        object firstSymbol = this.safeString(symbols, 0);
        object url = this.getUrlByMarketType(firstSymbol, true, method, parameters);
        messageHash = add("positions", messageHash);
        var client = this.client(url);
        await this.authenticate(url);
        this.setPositionsCache(client as WebSocketClient, symbols);
        object cache = this.positions;
        object fetchPositionsSnapshot = this.handleOption("watchPositions", "fetchPositionsSnapshot", true);
        object awaitPositionsSnapshot = this.safeBool("watchPositions", "awaitPositionsSnapshot", true);
        if (isTrue(isTrue(isTrue(fetchPositionsSnapshot) && isTrue(awaitPositionsSnapshot)) && isTrue(isEqual(cache, null))))
        {
            object snapshot = await client.future("fetchPositionsSnapshot");
            return this.filterBySymbolsSinceLimit(snapshot, symbols, since, limit, true);
        }
        object topics = new List<object>() {"position"};
        object newPositions = await this.watchTopics(url, new List<object>() {messageHash}, topics, parameters);
        if (isTrue(this.newUpdates))
        {
            return newPositions;
        }
        return this.filterBySymbolsSinceLimit(cache, symbols, since, limit, true);
    }

    public virtual void setPositionsCache(WebSocketClient client, object symbols = null)
    {
        if (isTrue(!isEqual(this.positions, null)))
        {
            return;
        }
        object fetchPositionsSnapshot = this.handleOption("watchPositions", "fetchPositionsSnapshot", true);
        if (isTrue(fetchPositionsSnapshot))
        {
            object messageHash = "fetchPositionsSnapshot";
            if (!isTrue((inOp(client.futures, messageHash))))
            {
                client.future(messageHash);
                this.spawn(this.loadPositionsSnapshot, new object[] { client, messageHash});
            }
        } else
        {
            this.positions = new ArrayCacheBySymbolBySide();
        }
    }

    public async virtual Task loadPositionsSnapshot(WebSocketClient client, object messageHash)
    {
        // as only one ws channel gives positions for all types, for snapshot must load all positions
        object fetchFunctions = new List<object> {this.fetchPositions(null, new Dictionary<string, object>() {
    { "type", "swap" },
    { "subType", "linear" },
}), this.fetchPositions(null, new Dictionary<string, object>() {
    { "type", "swap" },
    { "subType", "inverse" },
})};
        object promises = await promiseAll(fetchFunctions);
        this.positions = new ArrayCacheBySymbolBySide();
        object cache = this.positions;
        for (object i = 0; isLessThan(i, getArrayLength(promises)); postFixIncrement(ref i))
        {
            object positions = getValue(promises, i);
            for (object ii = 0; isLessThan(ii, getArrayLength(positions)); postFixIncrement(ref ii))
            {
                object position = getValue(positions, ii);
                callDynamically(cache, "append", new object[] {position});
            }
        }
        // don't remove the future from the .futures cache
        var future = getValue(client.futures, messageHash);
        (future as Future).resolve(cache);
        callDynamically(client as WebSocketClient, "resolve", new object[] {cache, "position"});
    }

    public virtual void handlePositions(WebSocketClient client, object message)
    {
        //
        //    {
        //        topic: 'position',
        //        id: '504b2671629b08e3c4f6960382a59363:3bc4028023786545:0:01',
        //        creationTime: 1694566055295,
        //        data: [{
        //            bustPrice: '15.00',
        //            category: 'inverse',
        //            createdTime: '1670083436351',
        //            cumRealisedPnl: '0.00011988',
        //            entryPrice: '19358.58553268',
        //            leverage: '10',
        //            liqPrice: '15.00',
        //            markPrice: '25924.00',
        //            positionBalance: '0.0000156',
        //            positionIdx: 0,
        //            positionMM: '0.001',
        //            positionIM: '0.0000015497',
        //            positionStatus: 'Normal',
        //            positionValue: '0.00015497',
        //            riskId: 1,
        //            riskLimitValue: '150',
        //            side: 'Buy',
        //            size: '3',
        //            stopLoss: '0.00',
        //            symbol: 'BTCUSD',
        //            takeProfit: '0.00',
        //            tpslMode: 'Full',
        //            tradeMode: 0,
        //            autoAddMargin: 1,
        //            trailingStop: '0.00',
        //            unrealisedPnl: '0.00003925',
        //            updatedTime: '1694566055293',
        //            adlRankIndicator: 3
        //        }]
        //    }
        //
        // each account is connected to a different endpoint
        // and has exactly one subscriptionhash which is the account type
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new ArrayCacheBySymbolBySide();
        }
        object cache = this.positions;
        object newPositions = new List<object>() {};
        object rawPositions = this.safeValue(message, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(rawPositions)); postFixIncrement(ref i))
        {
            object rawPosition = getValue(rawPositions, i);
            object position = this.parsePosition(rawPosition);
            object side = this.safeString(position, "side");
            // hacky solution to handle closing positions
            // without crashing, we should handle this properly later
            ((IList<object>)newPositions).Add(position);
            if (isTrue(isTrue(isEqual(side, null)) || isTrue(isEqual(side, ""))))
            {
                // closing update, adding both sides to "reset" both sides
                // since we don't know which side is being closed
                ((IDictionary<string,object>)position)["side"] = "long";
                callDynamically(cache, "append", new object[] {position});
                ((IDictionary<string,object>)position)["side"] = "short";
                callDynamically(cache, "append", new object[] {position});
                ((IDictionary<string,object>)position)["side"] = null;
            } else
            {
                // regular update
                callDynamically(cache, "append", new object[] {position});
            }
        }
        object messageHashes = this.findMessageHashes(client as WebSocketClient, "positions::");
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object positions = this.filterByArray(newPositions, "symbol", symbols, false);
            if (!isTrue(this.isEmpty(positions)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {positions, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newPositions, "positions"});
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#watchOrders
        * @description watches information on multiple orders made by the user
        * @see https://bybit-exchange.github.io/docs/v5/websocket/private/order
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object method = "watchOrders";
        object messageHash = "orders";
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
            messageHash = add(messageHash, add(":", symbol));
        }
        object url = this.getUrlByMarketType(symbol, true, method, parameters);
        await this.authenticate(url);
        object topicsByMarket = new Dictionary<string, object>() {
            { "spot", new List<object>() {"order", "stopOrder"} },
            { "unified", new List<object>() {"order"} },
            { "usdc", new List<object>() {"user.openapi.perp.order"} },
        };
        object topics = this.safeValue(topicsByMarket, this.getPrivateType(url));
        object orders = await this.watchTopics(url, new List<object>() {messageHash}, topics, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleOrderWs(WebSocketClient client, object message)
    {
        //
        //    {
        //        "reqId":"1",
        //        "retCode":0,
        //        "retMsg":"OK",
        //        "op":"order.create",
        //        "data":{
        //            "orderId":"1673523595617593600",
        //            "orderLinkId":"1673523595617593601"
        //        },
        //        "header":{
        //            "X-Bapi-Limit":"20",
        //            "X-Bapi-Limit-Status":"19",
        //            "X-Bapi-Limit-Reset-Timestamp":"1714235558880",
        //            "Traceid":"584a06d373f2fdcb3a4dfdd81d27df11",
        //            "Timenow":"1714235558881"
        //        },
        //        "connId":"cojidqec0hv9fgvhtbt0-40e"
        //    }
        //
        object messageHash = this.safeString(message, "reqId");
        object data = this.safeDict(message, "data");
        object order = this.parseOrder(data);
        callDynamically(client as WebSocketClient, "resolve", new object[] {order, messageHash});
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        //
        //     spot
        //     {
        //         "type": "snapshot",
        //         "topic": "order",
        //         "ts": "1662348310441",
        //         "data": [
        //             {
        //                 "e": "order",
        //                 "E": "1662348310441",
        //                 "s": "BTCUSDT",
        //                 "c": "spotx008",
        //                 "S": "BUY",
        //                 "o": "MARKET_OF_QUOTE",
        //                 "f": "GTC",
        //                 "q": "20",
        //                 "p": "0",
        //                 "X": "CANCELED",
        //                 "i": "1238261807653647872",
        //                 "M": "1238225004531834368",
        //                 "l": "0.001007",
        //                 "z": "0.001007",
        //                 "L": "19842.02",
        //                 "n": "0",
        //                 "N": "BTC",
        //                 "u": true,
        //                 "w": true,
        //                 "m": false,
        //                 "O": "1662348310368",
        //                 "Z": "19.98091414",
        //                 "A": "0",
        //                 "C": false,
        //                 "v": "0",
        //                 "d": "NO_LIQ",
        //                 "t": "2100000000002220938"
        //             }
        //         ]
        //     }
        // unified
        //     {
        //         "id": "5923240c6880ab-c59f-420b-9adb-3639adc9dd90",
        //         "topic": "order",
        //         "creationTime": 1672364262474,
        //         "data": [
        //             {
        //                 "symbol": "ETH-30DEC22-1400-C",
        //                 "orderId": "5cf98598-39a7-459e-97bf-76ca765ee020",
        //                 "side": "Sell",
        //                 "orderType": "Market",
        //                 "cancelType": "UNKNOWN",
        //                 "price": "72.5",
        //                 "qty": "1",
        //                 "orderIv": "",
        //                 "timeInForce": "IOC",
        //                 "orderStatus": "Filled",
        //                 "orderLinkId": "",
        //                 "lastPriceOnCreated": "",
        //                 "reduceOnly": false,
        //                 "leavesQty": "",
        //                 "leavesValue": "",
        //                 "cumExecQty": "1",
        //                 "cumExecValue": "75",
        //                 "avgPrice": "75",
        //                 "blockTradeId": "",
        //                 "positionIdx": 0,
        //                 "cumExecFee": "0.358635",
        //                 "createdTime": "1672364262444",
        //                 "updatedTime": "1672364262457",
        //                 "rejectReason": "EC_NoError",
        //                 "stopOrderType": "",
        //                 "triggerPrice": "",
        //                 "takeProfit": "",
        //                 "stopLoss": "",
        //                 "tpTriggerBy": "",
        //                 "slTriggerBy": "",
        //                 "triggerDirection": 0,
        //                 "triggerBy": "",
        //                 "closeOnTrigger": false,
        //                 "category": "option"
        //             }
        //         ]
        //     }
        //
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object orders = this.orders;
        object rawOrders = this.safeValue(message, "data", new List<object>() {});
        object first = this.safeValue(rawOrders, 0, new Dictionary<string, object>() {});
        object category = this.safeString(first, "category");
        object isSpot = isEqual(category, "spot");
        if (!isTrue(isSpot))
        {
            rawOrders = this.safeValue(rawOrders, "result", rawOrders);
        }
        object symbols = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rawOrders)); postFixIncrement(ref i))
        {
            object parsed = null;
            if (isTrue(isSpot))
            {
                parsed = this.parseWsSpotOrder(getValue(rawOrders, i));
            } else
            {
                parsed = this.parseOrder(getValue(rawOrders, i));
            }
            object symbol = getValue(parsed, "symbol");
            ((IDictionary<string,object>)symbols)[(string)symbol] = true;
            callDynamically(orders, "append", new object[] {parsed});
        }
        object symbolsArray = new List<object>(((IDictionary<string,object>)symbols).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(symbolsArray)); postFixIncrement(ref i))
        {
            object currentMessageHash = add("orders:", getValue(symbolsArray, i));
            callDynamically(client as WebSocketClient, "resolve", new object[] {orders, currentMessageHash});
        }
        object messageHash = "orders";
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
    }

    public virtual object parseWsSpotOrder(object order, object market = null)
    {
        //
        //    {
        //        "e": "executionReport",
        //        "E": "1653297251061", // timestamp
        //        "s": "LTCUSDT", // symbol
        //        "c": "1653297250740", // user id
        //        "S": "SELL", // side
        //        "o": "MARKET_OF_BASE", // order type
        //        "f": "GTC", // time in force
        //        "q": "0.16233", // quantity
        //        "p": "0", // price
        //        "X": "NEW", // status
        //        "i": "1162336018974750208", // order id
        //        "M": "0",
        //        "l": "0", // last filled
        //        "z": "0", // total filled
        //        "L": "0", // last traded price
        //        "n": "0", // trading fee
        //        "N": '', // fee asset
        //        "u": true,
        //        "w": true,
        //        "m": false, // is limit_maker
        //        "O": "1653297251042", // order creation
        //        "Z": "0", // total filled
        //        "A": "0", // account id
        //        "C": false, // is close
        //        "v": "0", // leverage
        //        "d": "NO_LIQ"
        //    }
        // v5
        //    {
        //        "category":"spot",
        //        "symbol":"LTCUSDT",
        //        "orderId":"1474764674982492160",
        //        "orderLinkId":"1690541649154749",
        //        "blockTradeId":"",
        //        "side":"Buy",
        //        "positionIdx":0,
        //        "orderStatus":"Cancelled",
        //        "cancelType":"UNKNOWN",
        //        "rejectReason":"EC_NoError",
        //        "timeInForce":"GTC",
        //        "isLeverage":"0",
        //        "price":"0",
        //        "qty":"5.00000",
        //        "avgPrice":"0",
        //        "leavesQty":"0.00000",
        //        "leavesValue":"5.0000000",
        //        "cumExecQty":"0.00000",
        //        "cumExecValue":"0.0000000",
        //        "cumExecFee":"",
        //        "orderType":"Market",
        //        "stopOrderType":"",
        //        "orderIv":"",
        //        "triggerPrice":"0.000",
        //        "takeProfit":"",
        //        "stopLoss":"",
        //        "triggerBy":"",
        //        "tpTriggerBy":"",
        //        "slTriggerBy":"",
        //        "triggerDirection":0,
        //        "placeType":"",
        //        "lastPriceOnCreated":"0.000",
        //        "closeOnTrigger":false,
        //        "reduceOnly":false,
        //        "smpGroup":0,
        //        "smpType":"None",
        //        "smpOrderId":"",
        //        "createdTime":"1690541649160",
        //        "updatedTime":"1690541649168"
        //     }
        //
        object id = this.safeString2(order, "i", "orderId");
        object marketId = this.safeString2(order, "s", "symbol");
        object symbol = this.safeSymbol(marketId, market, null, "spot");
        object timestamp = this.safeInteger2(order, "O", "createdTime");
        object price = this.safeString2(order, "p", "price");
        if (isTrue(isEqual(price, "0")))
        {
            price = null; // market orders
        }
        object filled = this.safeString2(order, "z", "cumExecQty");
        object status = this.parseOrderStatus(this.safeString2(order, "X", "orderStatus"));
        object side = this.safeStringLower2(order, "S", "side");
        object lastTradeTimestamp = this.safeString2(order, "E", "updatedTime");
        object timeInForce = this.safeString2(order, "f", "timeInForce");
        object amount = null;
        object cost = this.safeString2(order, "Z", "cumExecValue");
        object type = this.safeStringLower2(order, "o", "orderType");
        if (isTrue(isTrue((!isEqual(type, null))) && isTrue((isGreaterThanOrEqual(getIndexOf(type, "market"), 0)))))
        {
            type = "market";
        }
        if (isTrue(isTrue(isEqual(type, "market")) && isTrue(isEqual(side, "buy"))))
        {
            amount = filled;
        } else
        {
            amount = this.safeString2(order, "orderQty", "qty");
        }
        object fee = null;
        object feeCost = this.safeString2(order, "n", "cumExecFee");
        if (isTrue(isTrue(!isEqual(feeCost, null)) && isTrue(!isEqual(feeCost, "0"))))
        {
            object feeCurrencyId = this.safeString(order, "N");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrencyCode },
            };
        }
        object triggerPrice = this.omitZero(this.safeString(order, "triggerPrice"));
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", this.safeString2(order, "c", "orderLinkId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", triggerPrice },
            { "triggerPrice", triggerPrice },
            { "takeProfitPrice", this.safeString(order, "takeProfit") },
            { "stopLossPrice", this.safeString(order, "stopLoss") },
            { "reduceOnly", this.safeValue(order, "reduceOnly") },
            { "amount", amount },
            { "cost", cost },
            { "average", this.safeString(order, "avgPrice") },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bybit#watchBalance
        * @description watch balance and get the amount of funds available for trading or funds locked in orders
        * @see https://bybit-exchange.github.io/docs/v5/websocket/private/wallet
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object method = "watchBalance";
        object messageHash = "balances";
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchBalance", null, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object unified = await this.isUnifiedEnabled();
        object isUnifiedMargin = this.safeBool(unified, 0, false);
        object isUnifiedAccount = this.safeBool(unified, 1, false);
        object url = this.getUrlByMarketType(null, true, method, parameters);
        await this.authenticate(url);
        object topicByMarket = new Dictionary<string, object>() {
            { "spot", "outboundAccountInfo" },
            { "unified", "wallet" },
        };
        if (isTrue(isUnifiedAccount))
        {
            // unified account
            if (isTrue(isEqual(subType, "inverse")))
            {
                messageHash = add(messageHash, ":contract");
            } else
            {
                messageHash = add(messageHash, ":unified");
            }
        }
        if (isTrue(!isTrue(isUnifiedMargin) && !isTrue(isUnifiedAccount)))
        {
            // normal account using v5
            if (isTrue(isEqual(type, "spot")))
            {
                messageHash = add(messageHash, ":spot");
            } else
            {
                messageHash = add(messageHash, ":contract");
            }
        }
        if (isTrue(isUnifiedMargin))
        {
            // unified margin account using v5
            if (isTrue(isEqual(type, "spot")))
            {
                messageHash = add(messageHash, ":spot");
            } else
            {
                if (isTrue(isEqual(subType, "linear")))
                {
                    messageHash = add(messageHash, ":unified");
                } else
                {
                    messageHash = add(messageHash, ":contract");
                }
            }
        }
        object topics = new List<object> {this.safeValue(topicByMarket, this.getPrivateType(url))};
        return await this.watchTopics(url, new List<object>() {messageHash}, topics, parameters);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        // spot
        //    {
        //        "type": "snapshot",
        //        "topic": "outboundAccountInfo",
        //        "ts": "1662107217641",
        //        "data": [
        //            {
        //                "e": "outboundAccountInfo",
        //                "E": "1662107217640",
        //                "T": true,
        //                "W": true,
        //                "D": true,
        //                "B": [
        //                    {
        //                        "a": "USDT",
        //                        "f": "176.81254174",
        //                        "l": "201.575"
        //                    }
        //                ]
        //            }
        //        ]
        //    }
        // unified
        //     {
        //         "id": "5923242c464be9-25ca-483d-a743-c60101fc656f",
        //         "topic": "wallet",
        //         "creationTime": 1672364262482,
        //         "data": [
        //             {
        //                 "accountIMRate": "0.016",
        //                 "accountMMRate": "0.003",
        //                 "totalEquity": "12837.78330098",
        //                 "totalWalletBalance": "12840.4045924",
        //                 "totalMarginBalance": "12837.78330188",
        //                 "totalAvailableBalance": "12632.05767702",
        //                 "totalPerpUPL": "-2.62129051",
        //                 "totalInitialMargin": "205.72562486",
        //                 "totalMaintenanceMargin": "39.42876721",
        //                 "coin": [
        //                     {
        //                         "coin": "USDC",
        //                         "equity": "200.62572554",
        //                         "usdValue": "200.62572554",
        //                         "walletBalance": "201.34882644",
        //                         "availableToWithdraw": "0",
        //                         "availableToBorrow": "1500000",
        //                         "borrowAmount": "0",
        //                         "accruedInterest": "0",
        //                         "totalOrderIM": "0",
        //                         "totalPositionIM": "202.99874213",
        //                         "totalPositionMM": "39.14289747",
        //                         "unrealisedPnl": "74.2768991",
        //                         "cumRealisedPnl": "-209.1544627",
        //                         "bonus": "0"
        //                     },
        //                     {
        //                         "coin": "BTC",
        //                         "equity": "0.06488393",
        //                         "usdValue": "1023.08402268",
        //                         "walletBalance": "0.06488393",
        //                         "availableToWithdraw": "0.06488393",
        //                         "availableToBorrow": "2.5",
        //                         "borrowAmount": "0",
        //                         "accruedInterest": "0",
        //                         "totalOrderIM": "0",
        //                         "totalPositionIM": "0",
        //                         "totalPositionMM": "0",
        //                         "unrealisedPnl": "0",
        //                         "cumRealisedPnl": "0",
        //                         "bonus": "0"
        //                     },
        //                     {
        //                         "coin": "ETH",
        //                         "equity": "0",
        //                         "usdValue": "0",
        //                         "walletBalance": "0",
        //                         "availableToWithdraw": "0",
        //                         "availableToBorrow": "26",
        //                         "borrowAmount": "0",
        //                         "accruedInterest": "0",
        //                         "totalOrderIM": "0",
        //                         "totalPositionIM": "0",
        //                         "totalPositionMM": "0",
        //                         "unrealisedPnl": "0",
        //                         "cumRealisedPnl": "0",
        //                         "bonus": "0"
        //                     },
        //                     {
        //                         "coin": "USDT",
        //                         "equity": "11726.64664904",
        //                         "usdValue": "11613.58597018",
        //                         "walletBalance": "11728.54414904",
        //                         "availableToWithdraw": "11723.92075829",
        //                         "availableToBorrow": "2500000",
        //                         "borrowAmount": "0",
        //                         "accruedInterest": "0",
        //                         "totalOrderIM": "0",
        //                         "totalPositionIM": "2.72589075",
        //                         "totalPositionMM": "0.28576575",
        //                         "unrealisedPnl": "-1.8975",
        //                         "cumRealisedPnl": "0.64782276",
        //                         "bonus": "0"
        //                     },
        //                     {
        //                         "coin": "EOS3L",
        //                         "equity": "215.0570412",
        //                         "usdValue": "0",
        //                         "walletBalance": "215.0570412",
        //                         "availableToWithdraw": "215.0570412",
        //                         "availableToBorrow": "0",
        //                         "borrowAmount": "0",
        //                         "accruedInterest": "",
        //                         "totalOrderIM": "0",
        //                         "totalPositionIM": "0",
        //                         "totalPositionMM": "0",
        //                         "unrealisedPnl": "0",
        //                         "cumRealisedPnl": "0",
        //                         "bonus": "0"
        //                     },
        //                     {
        //                         "coin": "BIT",
        //                         "equity": "1.82",
        //                         "usdValue": "0.48758257",
        //                         "walletBalance": "1.82",
        //                         "availableToWithdraw": "1.82",
        //                         "availableToBorrow": "0",
        //                         "borrowAmount": "0",
        //                         "accruedInterest": "",
        //                         "totalOrderIM": "0",
        //                         "totalPositionIM": "0",
        //                         "totalPositionMM": "0",
        //                         "unrealisedPnl": "0",
        //                         "cumRealisedPnl": "0",
        //                         "bonus": "0"
        //                     }
        //                 ],
        //                 "accountType": "UNIFIED"
        //             }
        //         ]
        //     }
        //
        if (isTrue(isEqual(this.balance, null)))
        {
            this.balance = new Dictionary<string, object>() {};
        }
        object messageHash = "balance";
        object topic = this.safeValue(message, "topic");
        object info = null;
        object rawBalances = new List<object>() {};
        object account = null;
        if (isTrue(isEqual(topic, "outboundAccountInfo")))
        {
            account = "spot";
            object data = this.safeValue(message, "data", new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object B = this.safeValue(getValue(data, i), "B", new List<object>() {});
                rawBalances = this.arrayConcat(rawBalances, B);
            }
            info = rawBalances;
        }
        if (isTrue(isEqual(topic, "wallet")))
        {
            object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object result = this.safeValue(data, 0, new Dictionary<string, object>() {});
                account = this.safeStringLower(result, "accountType");
                rawBalances = this.arrayConcat(rawBalances, this.safeValue(result, "coin", new List<object>() {}));
            }
            info = data;
        }
        for (object i = 0; isLessThan(i, getArrayLength(rawBalances)); postFixIncrement(ref i))
        {
            this.parseWsBalance(getValue(rawBalances, i), account);
        }
        if (isTrue(!isEqual(account, null)))
        {
            if (isTrue(isEqual(this.safeValue(this.balance, account), null)))
            {
                ((IDictionary<string,object>)this.balance)[(string)account] = new Dictionary<string, object>() {};
            }
            ((IDictionary<string,object>)getValue(this.balance, account))["info"] = info;
            object timestamp = this.safeInteger(message, "ts");
            ((IDictionary<string,object>)getValue(this.balance, account))["timestamp"] = timestamp;
            ((IDictionary<string,object>)getValue(this.balance, account))["datetime"] = this.iso8601(timestamp);
            ((IDictionary<string,object>)this.balance)[(string)account] = this.safeBalance(getValue(this.balance, account));
            messageHash = add("balances:", account);
            callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, account), messageHash});
        } else
        {
            ((IDictionary<string,object>)this.balance)["info"] = info;
            object timestamp = this.safeInteger(message, "ts");
            ((IDictionary<string,object>)this.balance)["timestamp"] = timestamp;
            ((IDictionary<string,object>)this.balance)["datetime"] = this.iso8601(timestamp);
            this.balance = this.safeBalance(this.balance);
            messageHash = "balances";
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, messageHash});
        }
    }

    public virtual void parseWsBalance(object balance, object accountType = null)
    {
        //
        // spot
        //    {
        //        "a": "USDT",
        //        "f": "176.81254174",
        //        "l": "201.575"
        //    }
        // unified
        //     {
        //         "coin": "BTC",
        //         "equity": "0.06488393",
        //         "usdValue": "1023.08402268",
        //         "walletBalance": "0.06488393",
        //         "availableToWithdraw": "0.06488393",
        //         "availableToBorrow": "2.5",
        //         "borrowAmount": "0",
        //         "accruedInterest": "0",
        //         "totalOrderIM": "0",
        //         "totalPositionIM": "0",
        //         "totalPositionMM": "0",
        //         "unrealisedPnl": "0",
        //         "cumRealisedPnl": "0",
        //         "bonus": "0"
        //     }
        //
        object account = this.account();
        object currencyId = this.safeString2(balance, "a", "coin");
        object code = this.safeCurrencyCode(currencyId);
        ((IDictionary<string,object>)account)["free"] = this.safeStringN(balance, new List<object>() {"availableToWithdraw", "f", "free", "availableToWithdraw"});
        ((IDictionary<string,object>)account)["used"] = this.safeString2(balance, "l", "locked");
        ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "walletBalance");
        if (isTrue(!isEqual(accountType, null)))
        {
            if (isTrue(isEqual(this.safeValue(this.balance, accountType), null)))
            {
                ((IDictionary<string,object>)this.balance)[(string)accountType] = new Dictionary<string, object>() {};
            }
            ((IDictionary<string,object>)getValue(this.balance, accountType))[(string)code] = account;
        } else
        {
            ((IDictionary<string,object>)this.balance)[(string)code] = account;
        }
    }

    public async virtual Task<object> watchTopics(object url, object messageHashes, object topics, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "req_id", this.requestId() },
            { "args", topics },
        };
        object message = this.extend(request, parameters);
        return await this.watchMultiple(url, messageHashes, message, topics);
    }

    public async virtual Task<object> authenticate(object url, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object messageHash = "authenticated";
        var client = this.client(url);
        var future = client.future(messageHash);
        object authenticated = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(authenticated, null)))
        {
            object expiresInt = add(this.milliseconds(), 10000);
            object expires = this.numberToString(expiresInt);
            object path = "GET/realtime";
            object auth = add(path, expires);
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256, "hex");
            object request = new Dictionary<string, object>() {
                { "op", "auth" },
                { "args", new List<object>() {this.apiKey, expires, signature} },
            };
            object message = this.extend(request, parameters);
            this.watch(url, messageHash, message, messageHash);
        }
        return await (future as Exchange.Future);
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //   {
        //       "success": false,
        //       "ret_msg": "error:invalid op",
        //       "conn_id": "5e079fdd-9c7f-404d-9dbf-969d650838b5",
        //       "request": { op: '', args: null }
        //   }
        //
        // auth error
        //
        //   {
        //       "success": false,
        //       "ret_msg": "error:USVC1111",
        //       "conn_id": "e73770fb-a0dc-45bd-8028-140e20958090",
        //       "request": {
        //         "op": "auth",
        //         "args": [
        //           "9rFT6uR4uz9Imkw4Wx",
        //           "1653405853543",
        //           "542e71bd85597b4db0290f0ce2d13ed1fd4bb5df3188716c1e9cc69a879f7889"
        //         ]
        //   }
        //
        //   { code: '-10009', desc: "Invalid period!" }
        //
        //   {
        //       "reqId":"1",
        //       "retCode":170131,
        //       "retMsg":"Insufficient balance.",
        //       "op":"order.create",
        //       "data":{
        //
        //       },
        //       "header":{
        //           "X-Bapi-Limit":"20",
        //           "X-Bapi-Limit-Status":"19",
        //           "X-Bapi-Limit-Reset-Timestamp":"1714236608944",
        //           "Traceid":"3d7168a137bf32a947b7e5e6a575ac7f",
        //           "Timenow":"1714236608946"
        //       },
        //       "connId":"cojifin88smerbj9t560-406"
        //   }
        //
        object code = this.safeStringN(message, new List<object>() {"code", "ret_code", "retCode"});
        try
        {
            if (isTrue(isTrue(!isEqual(code, null)) && isTrue(!isEqual(code, "0"))))
            {
                object feedback = add(add(this.id, " "), this.json(message));
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
                object msg = this.safeString2(message, "retMsg", "ret_msg");
                this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), msg, feedback);
                throw new ExchangeError ((string)feedback) ;
            }
            object success = this.safeValue(message, "success");
            if (isTrue(isTrue(!isEqual(success, null)) && !isTrue(success)))
            {
                object ret_msg = this.safeString(message, "ret_msg");
                object request = this.safeValue(message, "request", new Dictionary<string, object>() {});
                object op = this.safeString(request, "op");
                if (isTrue(isEqual(op, "auth")))
                {
                    throw new AuthenticationError ((string)add("Authentication failed: ", ret_msg)) ;
                } else
                {
                    throw new ExchangeError ((string)add(add(this.id, " "), ret_msg)) ;
                }
            }
            return false;
        } catch(Exception error)
        {
            if (isTrue(error is AuthenticationError))
            {
                object messageHash = "authenticated";
                ((WebSocketClient)client).reject(error, messageHash);
                if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
                {

                }
            } else
            {
                object messageHash = this.safeString(message, "reqId");
                ((WebSocketClient)client).reject(error, messageHash);
            }
            return true;
        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            return;
        }
        // contract pong
        object ret_msg = this.safeString(message, "ret_msg");
        if (isTrue(isEqual(ret_msg, "pong")))
        {
            this.handlePong(client as WebSocketClient, message);
            return;
        }
        // spot pong
        object pong = this.safeInteger(message, "pong");
        if (isTrue(!isEqual(pong, null)))
        {
            this.handlePong(client as WebSocketClient, message);
            return;
        }
        // pong
        object eventVar = this.safeString(message, "event");
        if (isTrue(isEqual(eventVar, "sub")))
        {
            this.handleSubscriptionStatus(client as WebSocketClient, message);
            return;
        }
        object topic = this.safeString2(message, "topic", "op");
        object methods = new Dictionary<string, object>() {
            { "orderbook", this.handleOrderBook },
            { "kline", this.handleOHLCV },
            { "order", this.handleOrder },
            { "stopOrder", this.handleOrder },
            { "ticker", this.handleTicker },
            { "trade", this.handleTrades },
            { "publicTrade", this.handleTrades },
            { "depth", this.handleOrderBook },
            { "wallet", this.handleBalance },
            { "outboundAccountInfo", this.handleBalance },
            { "execution", this.handleMyTrades },
            { "ticketInfo", this.handleMyTrades },
            { "user.openapi.perp.trade", this.handleMyTrades },
            { "position", this.handlePositions },
            { "pong", this.handlePong },
            { "order.create", this.handleOrderWs },
            { "order.amend", this.handleOrderWs },
            { "order.cancel", this.handleOrderWs },
            { "auth", this.handleAuthenticate },
        };
        object exacMethod = this.safeValue(methods, topic);
        if (isTrue(!isEqual(exacMethod, null)))
        {
            DynamicInvoker.InvokeMethod(exacMethod, new object[] { client, message});
            return;
        }
        object keys = new List<object>(((IDictionary<string,object>)methods).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            if (isTrue(isGreaterThanOrEqual(getIndexOf(topic, getValue(keys, i)), 0)))
            {
                object method = getValue(methods, key);
                DynamicInvoker.InvokeMethod(method, new object[] { client, message});
                return;
            }
        }
        // unified auth acknowledgement
        object type = this.safeString(message, "type");
        if (isTrue(isEqual(type, "AUTH_RESP")))
        {
            this.handleAuthenticate(client as WebSocketClient, message);
        }
    }

    public override object ping(WebSocketClient client)
    {
        return new Dictionary<string, object>() {
            { "req_id", this.requestId() },
            { "op", "ping" },
        };
    }

    public virtual object handlePong(WebSocketClient client, object message)
    {
        //
        //   {
        //       "success": true,
        //       "ret_msg": "pong",
        //       "conn_id": "db3158a0-8960-44b9-a9de-ac350ee13158",
        //       "request": { op: "ping", args: null }
        //   }
        //
        //   { pong: 1653296711335 }
        //
        client.lastPong = this.safeInteger(message, "pong");
        return message;
    }

    public virtual object handleAuthenticate(WebSocketClient client, object message)
    {
        //
        //    {
        //        "success": true,
        //        "ret_msg": '',
        //        "op": "auth",
        //        "conn_id": "ce3dpomvha7dha97tvp0-2xh"
        //    }
        //
        //    {
        //        "retCode":0,
        //        "retMsg":"OK",
        //        "op":"auth",
        //        "connId":"cojifin88smerbj9t560-404"
        //    }
        //
        object success = this.safeValue(message, "success");
        object code = this.safeInteger(message, "retCode");
        object messageHash = "authenticated";
        if (isTrue(isTrue(success) || isTrue(isEqual(code, 0))))
        {
            var future = this.safeValue((client as WebSocketClient).futures, messageHash);
            (future as Future).resolve(true);
        } else
        {
            var error = new AuthenticationError(add(add(this.id, " "), this.json(message)));
            ((WebSocketClient)client).reject(error, messageHash);
            if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
            {

            }
        }
        return message;
    }

    public virtual object handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //    {
        //        "topic": "kline",
        //        "event": "sub",
        //        "params": {
        //          "symbol": "LTCUSDT",
        //          "binary": "false",
        //          "klineType": "1m",
        //          "symbolName": "LTCUSDT"
        //        },
        //        "code": "0",
        //        "msg": "Success"
        //    }
        //
        return message;
    }
}
