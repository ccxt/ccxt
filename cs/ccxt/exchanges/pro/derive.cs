namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class derive { public derive(object args = null) : base(args) { } }
public partial class derive : ccxt.derive
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", false },
                { "watchBalance", false },
                { "watchMyTrades", true },
                { "watchOHLCV", false },
                { "watchOrderBook", true },
                { "watchOrders", true },
                { "watchTicker", true },
                { "watchTickers", false },
                { "watchBidsAsks", false },
                { "watchTrades", true },
                { "watchTradesForSymbols", false },
                { "watchPositions", false },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", "wss://api.lyra.finance/ws" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "ws", "wss://api-demo.lyra.finance/ws" },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "tradesLimit", 1000 },
                { "ordersLimit", 1000 },
                { "requestId", new Dictionary<string, object>() {} },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "keepAlive", 9000 },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "ws", new Dictionary<string, object>() {
                    { "exact", new Dictionary<string, object>() {} },
                } },
            } },
        });
    }

    public virtual object requestId(object url)
    {
        object options = this.safeValue(this.options, "requestId", new Dictionary<string, object>() {});
        object previousValue = this.safeInteger(options, url, 0);
        object newValue = this.sum(previousValue, 1);
        ((IDictionary<string,object>)getValue(this.options, "requestId"))[(string)url] = newValue;
        return newValue;
    }

    public async virtual Task<object> watchPublic(object messageHash, object message, object subscription)
    {
        object url = getValue(getValue(this.urls, "api"), "ws");
        object requestId = this.requestId(url);
        object request = this.extend(message, new Dictionary<string, object>() {
            { "id", requestId },
        });
        subscription = this.extend(subscription, new Dictionary<string, object>() {
            { "id", requestId },
            { "method", "subscribe" },
        });
        return await this.watch(url, messageHash, request, messageHash, subscription);
    }

    /**
     * @method
     * @name derive#watchOrderBook
     * @see https://docs.derive.xyz/reference/orderbook-instrument_name-group-depth
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return.
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(limit, null)))
        {
            limit = 10;
        }
        object market = this.market(symbol);
        object topic = add(add(add("orderbook.", getValue(market, "id")), ".10."), this.numberToString(limit));
        object request = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "params", new Dictionary<string, object>() {
                { "channels", new List<object>() {topic} },
            } },
        };
        object subscription = new Dictionary<string, object>() {
            { "name", topic },
            { "symbol", symbol },
            { "limit", limit },
            { "params", parameters },
        };
        object orderbook = await this.watchPublic(topic, request, subscription);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        // {
        //     method: 'subscription',
        //     params: {
        //       channel: 'orderbook.BTC-PERP.10.1',
        //       data: {
        //         timestamp: 1738331231506,
        //         instrument_name: 'BTC-PERP',
        //         publish_id: 628419,
        //         bids: [ [ '104669', '40' ] ],
        //         asks: [ [ '104736', '40' ] ]
        //       }
        //     }
        // }
        //
        object parameters = this.safeDict(message, "params");
        object data = this.safeDict(parameters, "data");
        object marketId = this.safeString(data, "instrument_name");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object topic = this.safeString(parameters, "channel");
        if (!isTrue((inOp(this.orderbooks, symbol))))
        {
            object defaultLimit = this.safeInteger(this.options, "watchOrderBookLimit", 1000);
            object subscription = getValue(((WebSocketClient)client).subscriptions, topic);
            object limit = this.safeInteger(subscription, "limit", defaultLimit);
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
        }
        object orderbook = getValue(this.orderbooks, symbol);
        object timestamp = this.safeInteger(data, "timestamp");
        object snapshot = this.parseOrderBook(data, symbol, timestamp, "bids", "asks");
        (orderbook as IOrderBook).reset(snapshot);
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, topic});
    }

    /**
     * @method
     * @name derive#watchTicker
     * @see https://docs.derive.xyz/reference/ticker-instrument_name-interval
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object topic = add(add("ticker.", getValue(market, "id")), ".100");
        object request = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "params", new Dictionary<string, object>() {
                { "channels", new List<object>() {topic} },
            } },
        };
        object subscription = new Dictionary<string, object>() {
            { "name", topic },
            { "symbol", symbol },
            { "params", parameters },
        };
        return await this.watchPublic(topic, request, subscription);
    }

    public virtual object handleTicker(WebSocketClient client, object message)
    {
        //
        // {
        //     method: 'subscription',
        //     params: {
        //       channel: 'ticker.BTC-PERP.100',
        //       data: {
        //         timestamp: 1738485104439,
        //         instrument_ticker: {
        //           instrument_type: 'perp',
        //           instrument_name: 'BTC-PERP',
        //           scheduled_activation: 1701840228,
        //           scheduled_deactivation: '9223372036854775807',
        //           is_active: true,
        //           tick_size: '0.1',
        //           minimum_amount: '0.01',
        //           maximum_amount: '10000',
        //           amount_step: '0.001',
        //           mark_price_fee_rate_cap: '0',
        //           maker_fee_rate: '0.0001',
        //           taker_fee_rate: '0.0003',
        //           base_fee: '0.1',
        //           base_currency: 'BTC',
        //           quote_currency: 'USD',
        //           option_details: null,
        //           perp_details: {
        //             index: 'BTC-USD',
        //             max_rate_per_hour: '0.004',
        //             min_rate_per_hour: '-0.004',
        //             static_interest_rate: '0.0000125',
        //             aggregate_funding: '10581.779418721074588722',
        //             funding_rate: '0.000024792239208858'
        //           },
        //           erc20_details: null,
        //           base_asset_address: '0xDBa83C0C654DB1cd914FA2710bA743e925B53086',
        //           base_asset_sub_id: '0',
        //           pro_rata_fraction: '0',
        //           fifo_min_allocation: '0',
        //           pro_rata_amount_step: '0.1',
        //           best_ask_amount: '0.131',
        //           best_ask_price: '99898.6',
        //           best_bid_amount: '0.056',
        //           best_bid_price: '99889.1',
        //           five_percent_bid_depth: '11.817',
        //           five_percent_ask_depth: '9.116',
        //           option_pricing: null,
        //           index_price: '99883.8',
        //           mark_price: '99897.52408421244763303548098',
        //           stats: {
        //             contract_volume: '92.395',
        //             num_trades: '2924',
        //             open_interest: '33.743468027373780786',
        //             high: '102320.4',
        //             low: '99064.3',
        //             percent_change: '-0.021356',
        //             usd_change: '-2178'
        //           },
        //           timestamp: 1738485165881,
        //           min_price: '97939.1',
        //           max_price: '101895.2'
        //         }
        //       }
        //     }
        // }
        //
        object parameters = this.safeDict(message, "params");
        object rawData = this.safeDict(parameters, "data");
        object data = this.safeDict(rawData, "instrument_ticker");
        object topic = this.safeValue(parameters, "channel");
        object ticker = this.parseTicker(data);
        ((IDictionary<string,object>)this.tickers)[(string)getValue(ticker, "symbol")] = ticker;
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, topic});
        return message;
    }

    /**
     * @method
     * @name derive#unWatchOrderBook
     * @description unsubscribe from the orderbook channel
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.limit] orderbook limit, default is undefined
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> unWatchOrderBook(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object limit = this.safeInteger(parameters, "limit");
        if (isTrue(isEqual(limit, null)))
        {
            limit = 10;
        }
        object market = this.market(symbol);
        object topic = add(add(add("orderbook.", getValue(market, "id")), ".10."), this.numberToString(limit));
        object messageHash = add("unwatch", topic);
        object request = new Dictionary<string, object>() {
            { "method", "unsubscribe" },
            { "params", new Dictionary<string, object>() {
                { "channels", new List<object>() {topic} },
            } },
        };
        object subscription = new Dictionary<string, object>() {
            { "name", topic },
        };
        return await this.unWatchPublic(messageHash, request, subscription);
    }

    /**
     * @method
     * @name derive#unWatchTrades
     * @description unsubscribe from the trades channel
     * @param {string} symbol unified symbol of the market to unwatch the trades for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {any} status of the unwatch request
     */
    public async override Task<object> unWatchTrades(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object topic = add("trades.", getValue(market, "id"));
        object messageHah = add("unwatch", topic);
        object request = new Dictionary<string, object>() {
            { "method", "unsubscribe" },
            { "params", new Dictionary<string, object>() {
                { "channels", new List<object>() {topic} },
            } },
        };
        object subscription = new Dictionary<string, object>() {
            { "name", topic },
        };
        return await this.unWatchPublic(messageHah, request, subscription);
    }

    public async virtual Task<object> unWatchPublic(object messageHash, object message, object subscription)
    {
        object url = getValue(getValue(this.urls, "api"), "ws");
        object requestId = this.requestId(url);
        object request = this.extend(message, new Dictionary<string, object>() {
            { "id", requestId },
        });
        subscription = this.extend(subscription, new Dictionary<string, object>() {
            { "id", requestId },
            { "method", "unsubscribe" },
        });
        return await this.watch(url, messageHash, request, messageHash, subscription);
    }

    public virtual void handleOrderBookUnSubscription(WebSocketClient client, object topic)
    {
        object parsedTopic = ((string)topic).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(parsedTopic, 1);
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        if (isTrue(inOp(this.orderbooks, symbol)))
        {
            ((IDictionary<string,object>)this.orderbooks).Remove((string)symbol);
        }
        if (isTrue(inOp(((WebSocketClient)client).subscriptions, topic)))
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)topic);
        }
        var error = new UnsubscribeError(add(add(this.id, " orderbook "), symbol));
        ((WebSocketClient)client).reject(error, topic);
        callDynamically(client as WebSocketClient, "resolve", new object[] {error, add("unwatch", topic)});
    }

    public virtual void handleTradesUnSubscription(WebSocketClient client, object topic)
    {
        object parsedTopic = ((string)topic).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(parsedTopic, 1);
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        if (isTrue(inOp(this.orderbooks, symbol)))
        {
            ((IDictionary<string,object>)this.trades).Remove((string)symbol);
        }
        if (isTrue(inOp(((WebSocketClient)client).subscriptions, topic)))
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)topic);
        }
        var error = new UnsubscribeError(add(add(this.id, " trades "), symbol));
        ((WebSocketClient)client).reject(error, topic);
        callDynamically(client as WebSocketClient, "resolve", new object[] {error, add("unwatch", topic)});
    }

    public virtual object handleUnSubscribe(WebSocketClient client, object message)
    {
        //
        // {
        //     id: 1,
        //     result: {
        //       status: { 'orderbook.BTC-PERP.10.10': 'ok' },
        //       remaining_subscriptions: []
        //     }
        // }
        //
        object result = this.safeDict(message, "result");
        object status = this.safeDict(result, "status");
        if (isTrue(!isEqual(status, null)))
        {
            object topics = new List<object>(((IDictionary<string,object>)status).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(topics)); postFixIncrement(ref i))
            {
                object topic = getValue(topics, i);
                if (isTrue(isGreaterThanOrEqual(getIndexOf(topic, "orderbook"), 0)))
                {
                    this.handleOrderBookUnSubscription(client as WebSocketClient, topic);
                } else if (isTrue(isGreaterThanOrEqual(getIndexOf(topic, "trades"), 0)))
                {
                    this.handleTradesUnSubscription(client as WebSocketClient, topic);
                }
            }
        }
        return message;
    }

    /**
     * @method
     * @name derive#watchTrades
     * @description watches information on multiple trades made in a market
     * @see https://docs.derive.xyz/reference/trades-instrument_name
     * @param {string} symbol unified market symbol of the market trades were made in
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trade structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object topic = add("trades.", getValue(market, "id"));
        object request = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "params", new Dictionary<string, object>() {
                { "channels", new List<object>() {topic} },
            } },
        };
        object subscription = new Dictionary<string, object>() {
            { "name", topic },
            { "symbol", symbol },
            { "params", parameters },
        };
        object trades = await this.watchPublic(topic, request, subscription);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {getValue(market, "symbol"), limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleTrade(WebSocketClient client, object message)
    {
        //
        //
        object parameters = this.safeDict(message, "params");
        object data = this.safeDict(parameters, "data");
        object topic = this.safeValue(parameters, "channel");
        object parsedTopic = ((string)topic).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(parsedTopic, 1);
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object tradesArray = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(tradesArray, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            tradesArray = new ArrayCache(limit);
        }
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object trade = this.parseTrade(getValue(data, i));
            callDynamically(tradesArray, "append", new object[] {trade});
        }
        ((IDictionary<string,object>)this.trades)[(string)symbol] = tradesArray;
        callDynamically(client as WebSocketClient, "resolve", new object[] {tradesArray, topic});
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object url = getValue(getValue(this.urls, "api"), "ws");
        var client = this.client(url);
        object messageHash = "authenticated";
        var future = client.future(messageHash);
        object authenticated = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(authenticated, null)))
        {
            object requestId = this.requestId(url);
            object now = ((object)this.milliseconds()).ToString();
            object signature = this.signMessage(now, this.privateKey);
            object contractWalletAddress = this.safeString(this.options, "contractWalletAddress");
            object request = new Dictionary<string, object>() {
                { "id", requestId },
                { "method", "public/login" },
                { "params", new Dictionary<string, object>() {
                    { "wallet", contractWalletAddress },
                    { "timestamp", now },
                    { "signature", signature },
                } },
            };
            // const subscription: Dict = {
            //     'name': topic,
            //     'symbol': symbol,
            //     'params': params,
            // };
            object message = this.extend(request, parameters);
            this.watch(url, messageHash, message, messageHash, message);
        }
        return await (future as Exchange.Future);
    }

    public async virtual Task<object> watchPrivate(object messageHash, object message, object subscription)
    {
        await this.authenticate();
        object url = getValue(getValue(this.urls, "api"), "ws");
        object requestId = this.requestId(url);
        object request = this.extend(message, new Dictionary<string, object>() {
            { "id", requestId },
        });
        subscription = this.extend(subscription, new Dictionary<string, object>() {
            { "id", requestId },
            { "method", "subscribe" },
        });
        return await this.watch(url, messageHash, request, messageHash, subscription);
    }

    /**
     * @method
     * @name derive#watchOrders
     * @see https://docs.derive.xyz/reference/subaccount_id-orders
     * @description watches information on multiple orders made by the user
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subaccount_id] *required* the subaccount id
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object subaccountId = null;
        var subaccountIdparametersVariable = this.handleDeriveSubaccountId("watchOrders", parameters);
        subaccountId = ((IList<object>)subaccountIdparametersVariable)[0];
        parameters = ((IList<object>)subaccountIdparametersVariable)[1];
        object topic = add(this.numberToString(subaccountId), ".orders");
        object messageHash = topic;
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            symbol = getValue(market, "symbol");
            messageHash = add(messageHash, add(":", symbol));
        }
        object request = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "params", new Dictionary<string, object>() {
                { "channels", new List<object>() {topic} },
            } },
        };
        object subscription = new Dictionary<string, object>() {
            { "name", topic },
            { "params", parameters },
        };
        object message = this.extend(request, parameters);
        object orders = await this.watchPrivate(messageHash, message, subscription);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        //
        // {
        //     method: 'subscription',
        //     params: {
        //         channel: '130837.orders',
        //         data: [
        //             {
        //                 subaccount_id: 130837,
        //                 order_id: '1f44c564-5658-4b69-b8c4-4019924207d5',
        //                 instrument_name: 'BTC-PERP',
        //                 direction: 'buy',
        //                 label: 'test1234',
        //                 quote_id: null,
        //                 creation_timestamp: 1738578974146,
        //                 last_update_timestamp: 1738578974146,
        //                 limit_price: '10000',
        //                 amount: '0.01',
        //                 filled_amount: '0',
        //                 average_price: '0',
        //                 order_fee: '0',
        //                 order_type: 'limit',
        //                 time_in_force: 'post_only',
        //                 order_status: 'untriggered',
        //                 max_fee: '219',
        //                 signature_expiry_sec: 1746354973,
        //                 nonce: 1738578973570,
        //                 signer: '0x30CB7B06AdD6749BbE146A6827502B8f2a79269A',
        //                 signature: '0xc6927095f74a0d3b1aeef8c0579d120056530479f806e9d2e6616df742a8934c69046361beae833b32b25c0145e318438d7d1624bb835add956f63aa37192f571c',
        //                 cancel_reason: '',
        //                 mmp: false,
        //                 is_transfer: false,
        //                 replaced_order_id: null,
        //                 trigger_type: 'stoploss',
        //                 trigger_price_type: 'mark',
        //                 trigger_price: '102800',
        //                 trigger_reject_message: null
        //             }
        //         ]
        //     }
        // }
        //
        object parameters = this.safeDict(message, "params");
        object topic = this.safeString(parameters, "channel");
        object rawOrders = this.safeList(parameters, "data");
        for (object i = 0; isLessThan(i, getArrayLength(rawOrders)); postFixIncrement(ref i))
        {
            object data = getValue(rawOrders, i);
            object parsed = this.parseOrder(data);
            object symbol = this.safeString(parsed, "symbol");
            object orderId = this.safeString(parsed, "id");
            if (isTrue(!isEqual(symbol, null)))
            {
                if (isTrue(isEqual(this.orders, null)))
                {
                    object limit = this.safeInteger(this.options, "ordersLimit", 1000);
                    this.orders = new ArrayCacheBySymbolById(limit);
                }
                object cachedOrders = this.orders;
                object orders = this.safeValue((cachedOrders as ArrayCacheBySymbolById).hashmap, symbol, new Dictionary<string, object>() {});
                object order = this.safeValue(orders, orderId);
                if (isTrue(!isEqual(order, null)))
                {
                    object fee = this.safeValue(order, "fee");
                    if (isTrue(!isEqual(fee, null)))
                    {
                        ((IDictionary<string,object>)parsed)["fee"] = fee;
                    }
                    object fees = this.safeValue(order, "fees");
                    if (isTrue(!isEqual(fees, null)))
                    {
                        ((IDictionary<string,object>)parsed)["fees"] = fees;
                    }
                    ((IDictionary<string,object>)parsed)["trades"] = this.safeValue(order, "trades");
                    ((IDictionary<string,object>)parsed)["timestamp"] = this.safeInteger(order, "timestamp");
                    ((IDictionary<string,object>)parsed)["datetime"] = this.safeString(order, "datetime");
                }
                callDynamically(cachedOrders, "append", new object[] {parsed});
                object messageHashSymbol = add(add(topic, ":"), symbol);
                callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageHashSymbol});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, topic});
    }

    /**
     * @method
     * @name derive#watchMyTrades
     * @see https://docs.derive.xyz/reference/subaccount_id-trades
     * @description watches information on multiple trades made by the user
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subaccount_id] *required* the subaccount id
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object subaccountId = null;
        var subaccountIdparametersVariable = this.handleDeriveSubaccountId("watchMyTrades", parameters);
        subaccountId = ((IList<object>)subaccountIdparametersVariable)[0];
        parameters = ((IList<object>)subaccountIdparametersVariable)[1];
        object topic = add(this.numberToString(subaccountId), ".trades");
        object messageHash = topic;
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            symbol = getValue(market, "symbol");
            messageHash = add(messageHash, add(":", symbol));
        }
        object request = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "params", new Dictionary<string, object>() {
                { "channels", new List<object>() {topic} },
            } },
        };
        object subscription = new Dictionary<string, object>() {
            { "name", topic },
            { "params", parameters },
        };
        object message = this.extend(request, parameters);
        object trades = await this.watchPrivate(messageHash, message, subscription);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleMyTrade(WebSocketClient client, object message)
    {
        //
        //
        object myTrades = this.myTrades;
        if (isTrue(isEqual(myTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            myTrades = new ArrayCacheBySymbolById(limit);
        }
        object parameters = this.safeDict(message, "params");
        object topic = this.safeString(parameters, "channel");
        object rawTrades = this.safeList(parameters, "data");
        for (object i = 0; isLessThan(i, getArrayLength(rawTrades)); postFixIncrement(ref i))
        {
            object trade = this.parseTrade(message);
            callDynamically(myTrades, "append", new object[] {trade});
            callDynamically(client as WebSocketClient, "resolve", new object[] {myTrades, topic});
            object messageHash = add(topic, getValue(trade, "symbol"));
            callDynamically(client as WebSocketClient, "resolve", new object[] {myTrades, messageHash});
        }
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        //
        // {
        //     id: '690c6276-0fc6-4121-aafa-f28bf5adedcb',
        //     error: { code: -32600, message: 'Invalid Request' }
        // }
        //
        if (!isTrue((inOp(message, "error"))))
        {
            return false;
        }
        object errorMessage = this.safeDict(message, "error");
        object errorCode = this.safeString(errorMessage, "code");
        try
        {
            if (isTrue(!isEqual(errorCode, null)))
            {
                object feedback = add(add(this.id, " "), this.json(message));
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
                throw new ExchangeError ((string)feedback) ;
            }
            return false;
        } catch(Exception error)
        {
            if (isTrue(error is AuthenticationError))
            {
                object messageHash = "authenticated";
                ((WebSocketClient)client).reject(error, messageHash);
                if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
                {
                    ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
                }
            } else
            {
                ((WebSocketClient)client).reject(error);
            }
            return true;
        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            return;
        }
        object methods = new Dictionary<string, object>() {
            { "orderbook", this.handleOrderBook },
            { "ticker", this.handleTicker },
            { "trades", this.handleTrade },
            { "orders", this.handleOrder },
            { "mytrades", this.handleMyTrade },
        };
        object eventVar = null;
        object parameters = this.safeDict(message, "params");
        if (isTrue(!isEqual(parameters, null)))
        {
            object channel = this.safeString(parameters, "channel");
            if (isTrue(!isEqual(channel, null)))
            {
                object parsedChannel = ((string)channel).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
                if (isTrue(isTrue((isGreaterThanOrEqual(getIndexOf(channel, "orders"), 0))) || isTrue(isGreaterThan(getIndexOf(channel, "trades"), 0))))
                {
                    eventVar = this.safeString(parsedChannel, 1);
                    // {subaccounr_id}.trades
                    if (isTrue(isEqual(eventVar, "trades")))
                    {
                        eventVar = "mytrades";
                    }
                } else
                {
                    eventVar = this.safeString(parsedChannel, 0);
                }
            }
        }
        object method = this.safeValue(methods, eventVar);
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
            return;
        }
        if (isTrue(inOp(message, "id")))
        {
            object id = this.safeString(message, "id");
            object subscriptionsById = this.indexBy(((WebSocketClient)client).subscriptions, "id");
            object subscription = this.safeValue(subscriptionsById, id, new Dictionary<string, object>() {});
            if (isTrue(inOp(subscription, "method")))
            {
                if (isTrue(isEqual(getValue(subscription, "method"), "public/login")))
                {
                    this.handleAuth(client as WebSocketClient, message);
                } else if (isTrue(isEqual(getValue(subscription, "method"), "unsubscribe")))
                {
                    this.handleUnSubscribe(client as WebSocketClient, message);
                }
            }
        }
    }

    public virtual void handleAuth(WebSocketClient client, object message)
    {
        //
        // {
        //     id: 1,
        //     result: [ 130837 ]
        // }
        //
        object messageHash = "authenticated";
        object ids = this.safeList(message, "result");
        if (isTrue(isGreaterThan(getArrayLength(ids), 0)))
        {
            // client.resolve (message, messageHash);
            var future = this.safeValue((client as WebSocketClient).futures, "authenticated");
            (future as Future).resolve(true);
        } else
        {
            var error = new AuthenticationError(this.json(message));
            ((WebSocketClient)client).reject(error, messageHash);
            // allows further authentication attempts
            if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
            {
                ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)"authenticated");
            }
        }
    }
}
