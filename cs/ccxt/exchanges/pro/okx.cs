namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class okx { public okx(object args = null) : base(args) { } }
public partial class okx : ccxt.okx
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchTicker", true },
                { "watchMarkPrice", true },
                { "watchMarkPrices", true },
                { "watchTickers", true },
                { "watchBidsAsks", true },
                { "watchOrderBook", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
                { "watchOrderBookForSymbols", true },
                { "watchBalance", true },
                { "watchLiquidations", "emulated" },
                { "watchLiquidationsForSymbols", true },
                { "watchMyLiquidations", "emulated" },
                { "watchMyLiquidationsForSymbols", true },
                { "watchOHLCV", true },
                { "watchOHLCVForSymbols", true },
                { "watchOrders", true },
                { "watchMyTrades", true },
                { "watchPositions", true },
                { "watchFundingRate", true },
                { "watchFundingRates", true },
                { "createOrderWs", true },
                { "editOrderWs", true },
                { "cancelOrderWs", true },
                { "cancelOrdersWs", true },
                { "cancelAllOrdersWs", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", "wss://ws.okx.com:8443/ws/v5" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "ws", "wss://wspap.okx.com:8443/ws/v5" },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "checksum", true },
                    { "depth", "books" },
                } },
                { "watchBalance", "spot" },
                { "watchTicker", new Dictionary<string, object>() {
                    { "channel", "tickers" },
                } },
                { "watchTickers", new Dictionary<string, object>() {
                    { "channel", "tickers" },
                } },
                { "watchOrders", new Dictionary<string, object>() {
                    { "type", "ANY" },
                } },
                { "watchMyTrades", new Dictionary<string, object>() {
                    { "type", "ANY" },
                } },
                { "createOrderWs", new Dictionary<string, object>() {
                    { "op", "batch-orders" },
                } },
                { "editOrderWs", new Dictionary<string, object>() {
                    { "op", "amend-order" },
                } },
                { "ws", new Dictionary<string, object>() {} },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "ping", this.ping },
                { "keepAlive", 18000 },
            } },
        });
    }

    public virtual object getUrl(object channel, object access = null)
    {
        // for context: https://www.okx.com/help-center/changes-to-v5-api-websocket-subscription-parameter-and-url
        access ??= "public";
        object isSandbox = getValue(this.options, "sandboxMode");
        object sandboxSuffix = ((bool) isTrue(isSandbox)) ? "?brokerId=9999" : "";
        object isBusiness = (isEqual(access, "business"));
        object isPublic = (isEqual(access, "public"));
        object url = getValue(getValue(this.urls, "api"), "ws");
        if (isTrue(isTrue(isTrue(isBusiness) || isTrue((isGreaterThan(getIndexOf(channel, "candle"), -1)))) || isTrue((isEqual(channel, "orders-algo")))))
        {
            return add(add(url, "/business"), sandboxSuffix);
        } else if (isTrue(isPublic))
        {
            return add(add(url, "/public"), sandboxSuffix);
        }
        return add(add(url, "/private"), sandboxSuffix);
    }

    public async virtual Task<object> subscribeMultiple(object access, object channel, object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbols, null)))
        {
            symbols = this.symbols;
        }
        symbols = this.marketSymbols(symbols);
        object url = this.getUrl(channel, access);
        object messageHashes = new List<object>() {};
        object args = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object marketId = this.marketId(getValue(symbols, i));
            object arg = new Dictionary<string, object>() {
                { "channel", channel },
                { "instId", marketId },
            };
            ((IList<object>)args).Add(this.extend(arg, parameters));
            ((IList<object>)messageHashes).Add(add(add(channel, "::"), getValue(symbols, i)));
        }
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", args },
        };
        return await this.watchMultiple(url, messageHashes, request, messageHashes);
    }

    public async virtual Task<object> subscribe(object access, object messageHash, object channel, object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object url = this.getUrl(channel, access);
        object firstArgument = new Dictionary<string, object>() {
            { "channel", channel },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            messageHash = add(messageHash, add(":", getValue(market, "id")));
            ((IDictionary<string,object>)firstArgument)["instId"] = getValue(market, "id");
        }
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", new List<object> {this.deepExtend(firstArgument, parameters)} },
        };
        return await this.watch(url, messageHash, request, messageHash);
    }

    /**
     * @method
     * @name okx#watchTrades
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-trades-channel
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-all-trades-channel
     * @description get the list of most recent trades for a particular symbol
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    /**
     * @method
     * @name okx#watchTradesForSymbols
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-trades-channel
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-all-trades-channel
     * @description get the list of most recent trades for a particular symbol
     * @param {string} symbols
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.channel] the channel to subscribe to, trades by default. Can be 'trades' and 'trades-all'
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object symbolsLength = getArrayLength(symbols);
        if (isTrue(isEqual(symbolsLength, 0)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchTradesForSymbols() requires a non-empty array of symbols")) ;
        }
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object channel = null;
        var channelparametersVariable = this.handleOptionAndParams(parameters, "watchTrades", "channel", "trades");
        channel = ((IList<object>)channelparametersVariable)[0];
        parameters = ((IList<object>)channelparametersVariable)[1];
        object topics = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            ((IList<object>)messageHashes).Add(add(add(channel, ":"), symbol));
            object marketId = this.marketId(symbol);
            object topic = new Dictionary<string, object>() {
                { "channel", channel },
                { "instId", marketId },
            };
            ((IList<object>)topics).Add(topic);
        }
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", topics },
        };
        object access = "public";
        if (isTrue(isEqual(channel, "trades-all")))
        {
            access = "business";
            await this.authenticate(new Dictionary<string, object>() {
                { "access", access },
            });
        }
        object url = this.getUrl(channel, access);
        object trades = await this.watchMultiple(url, messageHashes, request, messageHashes);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeValue(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    /**
     * @method
     * @name okx#unWatchTradesForSymbols
     * @description unWatches from the stream channel
     * @param {string[]} symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.channel] the channel to subscribe to, trades by default. Can be trades, trades-all
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> unWatchTradesForSymbols(object symbols, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object channel = null;
        var channelparametersVariable = this.handleOptionAndParams(parameters, "watchTrades", "channel", "trades");
        channel = ((IList<object>)channelparametersVariable)[0];
        parameters = ((IList<object>)channelparametersVariable)[1];
        object topics = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            ((IList<object>)messageHashes).Add(add(add("unsubscribe:", channel), symbol));
            object marketId = this.marketId(symbol);
            object topic = new Dictionary<string, object>() {
                { "channel", channel },
                { "instId", marketId },
            };
            ((IList<object>)topics).Add(topic);
        }
        object request = new Dictionary<string, object>() {
            { "op", "unsubscribe" },
            { "args", topics },
        };
        object access = "public";
        if (isTrue(isEqual(channel, "trades-all")))
        {
            access = "business";
            await this.authenticate(new Dictionary<string, object>() {
                { "access", access },
            });
        }
        object url = this.getUrl(channel, access);
        return await this.watchMultiple(url, messageHashes, request, messageHashes);
    }

    /**
     * @method
     * @name okx#unWatchTrades
     * @description unWatches from the stream channel
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> unWatchTrades(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.unWatchTradesForSymbols(new List<object>() {symbol}, parameters);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //         "arg": { channel: "trades", instId: "BTC-USDT" },
        //         "data": [
        //             {
        //                 "instId": "BTC-USDT",
        //                 "tradeId": "216970876",
        //                 "px": "31684.5",
        //                 "sz": "0.00001186",
        //                 "side": "buy",
        //                 "ts": "1626531038288"
        //             }
        //         ]
        //     }
        //     {
        //         "arg": {
        //             "channel": "trades-all",
        //             "instId": "BTC-USDT"
        //         },
        //         "data": [
        //             {
        //                 "instId": "BTC-USDT",
        //                 "tradeId": "130639474",
        //                 "px": "42219.9",
        //                 "sz": "0.12060306",
        //                 "side": "buy",
        //                 "source": "0",
        //                 "ts": "1630048897897"
        //             }
        //         ]
        //     }
        //
        object arg = this.safeValue(message, "arg", new Dictionary<string, object>() {});
        object channel = this.safeString(arg, "channel");
        object marketId = this.safeString(arg, "instId");
        object symbol = this.safeSymbol(marketId);
        object data = this.safeValue(message, "data", new List<object>() {});
        object tradesLimit = this.safeInteger(this.options, "tradesLimit", 1000);
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object trade = this.parseTrade(getValue(data, i));
            object messageHash = add(add(channel, ":"), symbol);
            object stored = this.safeValue(this.trades, symbol);
            if (isTrue(isEqual(stored, null)))
            {
                stored = new ArrayCache(tradesLimit);
                ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
            }
            callDynamically(stored, "append", new object[] {trade});
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        }
    }

    /**
     * @method
     * @name okx#watchFundingRate
     * @description watch the current funding rate
     * @see https://www.okx.com/docs-v5/en/#public-data-websocket-funding-rate-channel
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> watchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        symbol = this.symbol(symbol);
        object fr = await this.watchFundingRates(new List<object>() {symbol}, parameters);
        return getValue(fr, symbol);
    }

    /**
     * @method
     * @name coinbaseinternational#watchFundingRates
     * @description watch the funding rate for multiple markets
     * @see https://www.okx.com/docs-v5/en/#public-data-websocket-funding-rate-channel
     * @param {string[]} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [funding rates structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexe by market symbols
     */
    public async override Task<object> watchFundingRates(object symbols, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object channel = "funding-rate";
        object topics = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            ((IList<object>)messageHashes).Add(add(add(channel, ":"), symbol));
            object marketId = this.marketId(symbol);
            object topic = new Dictionary<string, object>() {
                { "channel", channel },
                { "instId", marketId },
            };
            ((IList<object>)topics).Add(topic);
        }
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", topics },
        };
        object url = this.getUrl(channel, "public");
        object fundingRate = await this.watchMultiple(url, messageHashes, request, messageHashes);
        if (isTrue(this.newUpdates))
        {
            object symbol = this.safeString(fundingRate, "symbol");
            object result = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)result)[(string)symbol] = fundingRate;
            return result;
        }
        return this.filterByArray(this.fundingRates, "symbol", symbols);
    }

    public virtual void handleFundingRate(WebSocketClient client, object message)
    {
        //
        // "data":[
        //     {
        //        "fundingRate":"0.0001875391284828",
        //        "fundingTime":"1700726400000",
        //        "instId":"BTC-USD-SWAP",
        //        "instType":"SWAP",
        //        "method": "next_period",
        //        "maxFundingRate":"0.00375",
        //        "minFundingRate":"-0.00375",
        //        "nextFundingRate":"0.0002608059239328",
        //        "nextFundingTime":"1700755200000",
        //        "premium": "0.0001233824646391",
        //        "settFundingRate":"0.0001699799259033",
        //        "settState":"settled",
        //        "ts":"1700724675402"
        //     }
        // ]
        //
        object data = this.safeList(message, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object rawfr = getValue(data, i);
            object fundingRate = this.parseFundingRate(rawfr);
            object symbol = getValue(fundingRate, "symbol");
            ((IDictionary<string,object>)this.fundingRates)[(string)symbol] = fundingRate;
            callDynamically(client as WebSocketClient, "resolve", new object[] {fundingRate, add(add("funding-rate", ":"), getValue(fundingRate, "symbol"))});
        }
    }

    /**
     * @method
     * @name okx#watchTicker
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-tickers-channel
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.channel] the channel to subscribe to, tickers by default. Can be tickers, sprd-tickers, index-tickers, block-tickers
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object channel = null;
        var channelparametersVariable = this.handleOptionAndParams(parameters, "watchTicker", "channel", "tickers");
        channel = ((IList<object>)channelparametersVariable)[0];
        parameters = ((IList<object>)channelparametersVariable)[1];
        ((IDictionary<string,object>)parameters)["channel"] = channel;
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object ticker = await this.watchTickers(new List<object>() {symbol}, parameters);
        return this.safeValue(ticker, symbol);
    }

    /**
     * @method
     * @name okx#unWatchTicker
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-tickers-channel
     * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.channel] the channel to subscribe to, tickers by default. Can be tickers, sprd-tickers, index-tickers, block-tickers
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> unWatchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.unWatchTickers(new List<object>() {symbol}, parameters);
    }

    /**
     * @method
     * @name okx#watchTickers
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-tickers-channel
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
     * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.channel] the channel to subscribe to, tickers by default. Can be tickers, sprd-tickers, index-tickers, block-tickers
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object channel = null;
        var channelparametersVariable = this.handleOptionAndParams(parameters, "watchTickers", "channel", "tickers");
        channel = ((IList<object>)channelparametersVariable)[0];
        parameters = ((IList<object>)channelparametersVariable)[1];
        object newTickers = await this.subscribeMultiple("public", channel, symbols, parameters);
        if (isTrue(this.newUpdates))
        {
            return newTickers;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    /**
     * @method
     * @name okx#watchMarkPrice
     * @see https://www.okx.com/docs-v5/en/#public-data-websocket-mark-price-channel
     * @description watches a mark price
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.channel] the channel to subscribe to, tickers by default. Can be tickers, sprd-tickers, index-tickers, block-tickers
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async virtual Task<object> watchMarkPrice(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object channel = null;
        var channelparametersVariable = this.handleOptionAndParams(parameters, "watchMarkPrice", "channel", "mark-price");
        channel = ((IList<object>)channelparametersVariable)[0];
        parameters = ((IList<object>)channelparametersVariable)[1];
        ((IDictionary<string,object>)parameters)["channel"] = channel;
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object ticker = await this.watchMarkPrices(new List<object>() {symbol}, parameters);
        return getValue(ticker, symbol);
    }

    /**
     * @method
     * @name okx#watchMarkPrices
     * @see https://www.okx.com/docs-v5/en/#public-data-websocket-mark-price-channel
     * @description watches mark prices
     * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.channel] the channel to subscribe to, tickers by default. Can be tickers, sprd-tickers, index-tickers, block-tickers
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async virtual Task<object> watchMarkPrices(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object channel = null;
        var channelparametersVariable = this.handleOptionAndParams(parameters, "watchMarkPrices", "channel", "mark-price");
        channel = ((IList<object>)channelparametersVariable)[0];
        parameters = ((IList<object>)channelparametersVariable)[1];
        object newTickers = await this.subscribeMultiple("public", channel, symbols, parameters);
        if (isTrue(this.newUpdates))
        {
            return newTickers;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    /**
     * @method
     * @name okx#unWatchTickers
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-tickers-channel
     * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
     * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.channel] the channel to subscribe to, tickers by default. Can be tickers, sprd-tickers, index-tickers, block-tickers
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> unWatchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object channel = null;
        var channelparametersVariable = this.handleOptionAndParams(parameters, "watchTickers", "channel", "tickers");
        channel = ((IList<object>)channelparametersVariable)[0];
        parameters = ((IList<object>)channelparametersVariable)[1];
        object topics = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            ((IList<object>)messageHashes).Add(add("unsubscribe:ticker:", symbol));
            object marketId = this.marketId(symbol);
            object topic = new Dictionary<string, object>() {
                { "channel", channel },
                { "instId", marketId },
            };
            ((IList<object>)topics).Add(topic);
        }
        object request = new Dictionary<string, object>() {
            { "op", "unsubscribe" },
            { "args", topics },
        };
        object url = this.getUrl(channel, "public");
        return await this.watchMultiple(url, messageHashes, request, messageHashes);
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        //     {
        //         "arg": { channel: "tickers", instId: "BTC-USDT" },
        //         "data": [
        //             {
        //                 "instType": "SPOT",
        //                 "instId": "BTC-USDT",
        //                 "last": "31500.1",
        //                 "lastSz": "0.00001754",
        //                 "askPx": "31500.1",
        //                 "askSz": "0.00998144",
        //                 "bidPx": "31500",
        //                 "bidSz": "3.05652439",
        //                 "open24h": "31697",
        //                 "high24h": "32248",
        //                 "low24h": "31165.6",
        //                 "sodUtc0": "31385.5",
        //                 "sodUtc8": "32134.9",
        //                 "volCcy24h": "503403597.38138519",
        //                 "vol24h": "15937.10781721",
        //                 "ts": "1626526618762"
        //             }
        //         ]
        //     }
        //
        this.handleBidAsk(client as WebSocketClient, message);
        object arg = this.safeValue(message, "arg", new Dictionary<string, object>() {});
        object marketId = this.safeString(arg, "instId");
        object market = this.safeMarket(marketId, null, "-");
        object symbol = getValue(market, "symbol");
        object channel = this.safeString(arg, "channel");
        object data = this.safeValue(message, "data", new List<object>() {});
        object newTickers = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object ticker = this.parseTicker(getValue(data, i));
            ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
            ((IDictionary<string,object>)newTickers)[(string)symbol] = ticker;
        }
        object messageHash = add(add(channel, "::"), symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {newTickers, messageHash});
    }

    /**
     * @method
     * @name okx#watchBidsAsks
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-tickers-channel
     * @description watches best bid & ask for symbols
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchBidsAsks(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object channel = null;
        var channelparametersVariable = this.handleOptionAndParams(parameters, "watchBidsAsks", "channel", "tickers");
        channel = ((IList<object>)channelparametersVariable)[0];
        parameters = ((IList<object>)channelparametersVariable)[1];
        object url = this.getUrl(channel, "public");
        object messageHashes = new List<object>() {};
        object args = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object marketId = this.marketId(getValue(symbols, i));
            object arg = new Dictionary<string, object>() {
                { "channel", channel },
                { "instId", marketId },
            };
            ((IList<object>)args).Add(this.extend(arg, parameters));
            ((IList<object>)messageHashes).Add(add("bidask::", getValue(symbols, i)));
        }
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", args },
        };
        object newTickers = await this.watchMultiple(url, messageHashes, request, messageHashes);
        if (isTrue(this.newUpdates))
        {
            object tickers = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)tickers)[(string)getValue(newTickers, "symbol")] = newTickers;
            return tickers;
        }
        return this.filterByArray(this.bidsasks, "symbol", symbols);
    }

    public virtual void handleBidAsk(WebSocketClient client, object message)
    {
        //
        //     {
        //         "arg": { channel: "tickers", instId: "BTC-USDT" },
        //         "data": [
        //             {
        //                 "instType": "SPOT",
        //                 "instId": "BTC-USDT",
        //                 "last": "31500.1",
        //                 "lastSz": "0.00001754",
        //                 "askPx": "31500.1",
        //                 "askSz": "0.00998144",
        //                 "bidPx": "31500",
        //                 "bidSz": "3.05652439",
        //                 "open24h": "31697",
        //                 "high24h": "32248",
        //                 "low24h": "31165.6",
        //                 "sodUtc0": "31385.5",
        //                 "sodUtc8": "32134.9",
        //                 "volCcy24h": "503403597.38138519",
        //                 "vol24h": "15937.10781721",
        //                 "ts": "1626526618762"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(message, "data", new List<object>() {});
        object ticker = this.safeDict(data, 0, new Dictionary<string, object>() {});
        object parsedTicker = this.parseWsBidAsk(ticker);
        object symbol = getValue(parsedTicker, "symbol");
        ((IDictionary<string,object>)this.bidsasks)[(string)symbol] = parsedTicker;
        object messageHash = add("bidask::", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {parsedTicker, messageHash});
    }

    public virtual object parseWsBidAsk(object ticker, object market = null)
    {
        object marketId = this.safeString(ticker, "instId");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeString(market, "symbol");
        object timestamp = this.safeInteger(ticker, "ts");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "ask", this.safeString(ticker, "askPx") },
            { "askVolume", this.safeString(ticker, "askSz") },
            { "bid", this.safeString(ticker, "bidPx") },
            { "bidVolume", this.safeString(ticker, "bidSz") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name okx#watchLiquidationsForSymbols
     * @description watch the public liquidations of a trading pair
     * @see https://www.okx.com/docs-v5/en/#public-data-websocket-liquidation-orders-channel
     * @param {string} symbols
     * @param {int} [since] the earliest time in ms to fetch liquidations for
     * @param {int} [limit] the maximum number of liquidation structures to retrieve
     * @param {object} [params] exchange specific parameters for the okx api endpoint
     * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
     */
    public async override Task<object> watchLiquidationsForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, true, true);
        object messageHash = "liquidations";
        object messageHashes = new List<object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                ((IList<object>)messageHashes).Add(add(add(messageHash, "::"), symbol));
            }
        } else
        {
            ((IList<object>)messageHashes).Add(messageHash);
        }
        object market = this.getMarketFromSymbols(symbols);
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchliquidationsForSymbols", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object channel = "liquidation-orders";
        if (isTrue(isEqual(type, "spot")))
        {
            type = "SWAP";
        } else if (isTrue(isEqual(type, "future")))
        {
            type = "futures";
        }
        object uppercaseType = ((string)type).ToUpper();
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", new List<object>() {new Dictionary<string, object>() {
    { "channel", channel },
    { "instType", uppercaseType },
}} },
        };
        object url = this.getUrl(channel, "public");
        object newLiquidations = await this.watchMultiple(url, messageHashes, request, messageHashes);
        if (isTrue(this.newUpdates))
        {
            return newLiquidations;
        }
        return this.filterBySymbolsSinceLimit(this.liquidations, symbols, since, limit, true);
    }

    public virtual void handleLiquidation(WebSocketClient client, object message)
    {
        //
        //    {
        //        "arg": {
        //            "channel": "liquidation-orders",
        //            "instType": "SWAP"
        //        },
        //        "data": [
        //            {
        //                "details": [
        //                    {
        //                        "bkLoss": "0",
        //                        "bkPx": "0.007831",
        //                        "ccy": "",
        //                        "posSide": "short",
        //                        "side": "buy",
        //                        "sz": "13",
        //                        "ts": "1692266434010"
        //                    }
        //                ],
        //                "instFamily": "IOST-USDT",
        //                "instId": "IOST-USDT-SWAP",
        //                "instType": "SWAP",
        //                "uly": "IOST-USDT"
        //            }
        //        ]
        //    }
        //
        object rawLiquidations = this.safeList(message, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(rawLiquidations)); postFixIncrement(ref i))
        {
            object rawLiquidation = getValue(rawLiquidations, i);
            object liquidation = this.parseWsLiquidation(rawLiquidation);
            object symbol = this.safeString(liquidation, "symbol");
            object liquidations = this.safeValue(this.liquidations, symbol);
            if (isTrue(isEqual(liquidations, null)))
            {
                object limit = this.safeInteger(this.options, "liquidationsLimit", 1000);
                liquidations = new ArrayCache(limit);
            }
            callDynamically(liquidations, "append", new object[] {liquidation});
            ((IDictionary<string,object>)this.liquidations)[(string)symbol] = liquidations;
            callDynamically(client as WebSocketClient, "resolve", new object[] {new List<object>() {liquidation}, "liquidations"});
            callDynamically(client as WebSocketClient, "resolve", new object[] {new List<object>() {liquidation}, add("liquidations::", symbol)});
        }
    }

    /**
     * @method
     * @name okx#watchMyLiquidationsForSymbols
     * @description watch the private liquidations of a trading pair
     * @see https://www.okx.com/docs-v5/en/#trading-account-websocket-balance-and-position-channel
     * @param {string[]} symbols
     * @param {int} [since] the earliest time in ms to fetch liquidations for
     * @param {int} [limit] the maximum number of liquidation structures to retrieve
     * @param {object} [params] exchange specific parameters for the okx api endpoint
     * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
     */
    public async override Task<object> watchMyLiquidationsForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object isTrigger = this.safeValue2(parameters, "stop", "trigger", false);
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        await this.authenticate(new Dictionary<string, object>() {
            { "access", ((bool) isTrue(isTrigger)) ? "business" : "private" },
        });
        symbols = this.marketSymbols(symbols, null, true, true);
        object messageHash = "myLiquidations";
        object messageHashes = new List<object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                ((IList<object>)messageHashes).Add(add(add(messageHash, "::"), symbol));
            }
        } else
        {
            ((IList<object>)messageHashes).Add(messageHash);
        }
        object channel = "balance_and_position";
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", new List<object>() {new Dictionary<string, object>() {
    { "channel", channel },
}} },
        };
        object url = this.getUrl(channel, "private");
        object newLiquidations = await this.watchMultiple(url, messageHashes, this.deepExtend(request, parameters), messageHashes);
        if (isTrue(this.newUpdates))
        {
            return newLiquidations;
        }
        return this.filterBySymbolsSinceLimit(this.liquidations, symbols, since, limit, true);
    }

    public virtual void handleMyLiquidation(WebSocketClient client, object message)
    {
        //
        //    {
        //        "arg": {
        //            "channel": "balance_and_position",
        //            "uid": "77982378738415879"
        //        },
        //        "data": [{
        //            "pTime": "1597026383085",
        //            "eventType": "snapshot",
        //            "balData": [{
        //                "ccy": "BTC",
        //                "cashBal": "1",
        //                "uTime": "1597026383085"
        //            }],
        //            "posData": [{
        //                "posId": "1111111111",
        //                "tradeId": "2",
        //                "instId": "BTC-USD-191018",
        //                "instType": "FUTURES",
        //                "mgnMode": "cross",
        //                "posSide": "long",
        //                "pos": "10",
        //                "ccy": "BTC",
        //                "posCcy": "",
        //                "avgPx": "3320",
        //                "uTIme": "1597026383085"
        //            }],
        //            "trades": [{
        //                "instId": "BTC-USD-191018",
        //                "tradeId": "2",
        //            }]
        //        }]
        //    }
        //
        object rawLiquidations = this.safeList(message, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(rawLiquidations)); postFixIncrement(ref i))
        {
            object rawLiquidation = getValue(rawLiquidations, i);
            object eventType = this.safeString(rawLiquidation, "eventType");
            if (isTrue(!isEqual(eventType, "liquidation")))
            {
                return;
            }
            object liquidation = this.parseWsMyLiquidation(rawLiquidation);
            object symbol = this.safeString(liquidation, "symbol");
            object liquidations = this.safeValue(this.liquidations, symbol);
            if (isTrue(isEqual(liquidations, null)))
            {
                object limit = this.safeInteger(this.options, "myLiquidationsLimit", 1000);
                liquidations = new ArrayCache(limit);
            }
            callDynamically(liquidations, "append", new object[] {liquidation});
            ((IDictionary<string,object>)this.liquidations)[(string)symbol] = liquidations;
            callDynamically(client as WebSocketClient, "resolve", new object[] {new List<object>() {liquidation}, "myLiquidations"});
            callDynamically(client as WebSocketClient, "resolve", new object[] {new List<object>() {liquidation}, add("myLiquidations::", symbol)});
        }
    }

    public virtual object parseWsMyLiquidation(object liquidation, object market = null)
    {
        //
        //    {
        //        "pTime": "1597026383085",
        //        "eventType": "snapshot",
        //        "balData": [{
        //            "ccy": "BTC",
        //            "cashBal": "1",
        //            "uTime": "1597026383085"
        //        }],
        //        "posData": [{
        //            "posId": "1111111111",
        //            "tradeId": "2",
        //            "instId": "BTC-USD-191018",
        //            "instType": "FUTURES",
        //            "mgnMode": "cross",
        //            "posSide": "long",
        //            "pos": "10",
        //            "ccy": "BTC",
        //            "posCcy": "",
        //            "avgPx": "3320",
        //            "uTIme": "1597026383085"
        //        }],
        //        "trades": [{
        //            "instId": "BTC-USD-191018",
        //            "tradeId": "2",
        //        }]
        //    }
        //
        object posData = this.safeList(liquidation, "posData", new List<object>() {});
        object firstPosData = this.safeDict(posData, 0, new Dictionary<string, object>() {});
        object marketId = this.safeString(firstPosData, "instId");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(firstPosData, "uTIme");
        return this.safeLiquidation(new Dictionary<string, object>() {
            { "info", liquidation },
            { "symbol", this.safeSymbol(marketId, market) },
            { "contracts", this.safeNumber(firstPosData, "pos") },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "price", this.safeNumber(liquidation, "avgPx") },
            { "baseValue", null },
            { "quoteValue", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        });
    }

    public virtual object parseWsLiquidation(object liquidation, object market = null)
    {
        //
        // public liquidation
        //    {
        //        "details": [
        //            {
        //                "bkLoss": "0",
        //                "bkPx": "0.007831",
        //                "ccy": "",
        //                "posSide": "short",
        //                "side": "buy",
        //                "sz": "13",
        //                "ts": "1692266434010"
        //            }
        //        ],
        //        "instFamily": "IOST-USDT",
        //        "instId": "IOST-USDT-SWAP",
        //        "instType": "SWAP",
        //        "uly": "IOST-USDT"
        //    }
        //
        object details = this.safeList(liquidation, "details", new List<object>() {});
        object liquidationDetails = this.safeDict(details, 0, new Dictionary<string, object>() {});
        object marketId = this.safeString(liquidation, "instId");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(liquidationDetails, "ts");
        return this.safeLiquidation(new Dictionary<string, object>() {
            { "info", liquidation },
            { "symbol", this.safeSymbol(marketId, market) },
            { "contracts", this.safeNumber(liquidationDetails, "sz") },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "price", this.safeNumber(liquidationDetails, "bkPx") },
            { "side", this.safeString(liquidationDetails, "side") },
            { "baseValue", null },
            { "quoteValue", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        });
    }

    /**
     * @method
     * @name okx#watchOHLCV
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbol = this.symbol(symbol);
        object interval = this.safeString(this.timeframes, timeframe, timeframe);
        object name = add("candle", interval);
        object ohlcv = await this.subscribe("public", name, name, symbol, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    /**
     * @method
     * @name okx#unWatchOHLCV
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async virtual Task<object> unWatchOHLCV(object symbol, object timeframe = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        return await this.unWatchOHLCVForSymbols(new List<object>() {new List<object>() {symbol, timeframe}}, parameters);
    }

    /**
     * @method
     * @name okx#watchOHLCVForSymbols
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCVForSymbols(object symbolsAndTimeframes, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object symbolsLength = getArrayLength(symbolsAndTimeframes);
        if (isTrue(isTrue(isEqual(symbolsLength, 0)) || !isTrue(((getValue(symbolsAndTimeframes, 0) is IList<object>) || (getValue(symbolsAndTimeframes, 0).GetType().IsGenericType && getValue(symbolsAndTimeframes, 0).GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]")) ;
        }
        await this.loadMarkets();
        object topics = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbolsAndTimeframes)); postFixIncrement(ref i))
        {
            object symbolAndTimeframe = getValue(symbolsAndTimeframes, i);
            object sym = getValue(symbolAndTimeframe, 0);
            object tf = getValue(symbolAndTimeframe, 1);
            object marketId = this.marketId(sym);
            object interval = this.safeString(this.timeframes, tf, tf);
            object channel = add("candle", interval);
            object topic = new Dictionary<string, object>() {
                { "channel", channel },
                { "instId", marketId },
            };
            ((IList<object>)topics).Add(topic);
            ((IList<object>)messageHashes).Add(add(add(add("multi:", channel), ":"), sym));
        }
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", topics },
        };
        object url = this.getUrl("candle", "public");
        var symboltimeframecandlesVariable = await this.watchMultiple(url, messageHashes, request, messageHashes);
        var symbol = ((IList<object>) symboltimeframecandlesVariable)[0];
        var timeframe = ((IList<object>) symboltimeframecandlesVariable)[1];
        var candles = ((IList<object>) symboltimeframecandlesVariable)[2];
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(candles, "getLimit", new object[] {symbol, limit});
        }
        object filtered = this.filterBySinceLimit(candles, since, limit, 0, true);
        return this.createOHLCVObject(symbol, timeframe, filtered);
    }

    /**
     * @method
     * @name okx#unWatchOHLCVForSymbols
     * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> unWatchOHLCVForSymbols(object symbolsAndTimeframes, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object symbolsLength = getArrayLength(symbolsAndTimeframes);
        if (isTrue(isTrue(isEqual(symbolsLength, 0)) || !isTrue(((getValue(symbolsAndTimeframes, 0) is IList<object>) || (getValue(symbolsAndTimeframes, 0).GetType().IsGenericType && getValue(symbolsAndTimeframes, 0).GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]")) ;
        }
        await this.loadMarkets();
        object topics = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbolsAndTimeframes)); postFixIncrement(ref i))
        {
            object symbolAndTimeframe = getValue(symbolsAndTimeframes, i);
            object sym = getValue(symbolAndTimeframe, 0);
            object tf = getValue(symbolAndTimeframe, 1);
            object marketId = this.marketId(sym);
            object interval = this.safeString(this.timeframes, tf, tf);
            object channel = add("candle", interval);
            object topic = new Dictionary<string, object>() {
                { "channel", channel },
                { "instId", marketId },
            };
            ((IList<object>)topics).Add(topic);
            ((IList<object>)messageHashes).Add(add(add(add("unsubscribe:multi:", channel), ":"), sym));
        }
        object request = new Dictionary<string, object>() {
            { "op", "unsubscribe" },
            { "args", topics },
        };
        object url = this.getUrl("candle", "public");
        return await this.watchMultiple(url, messageHashes, request, messageHashes);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "arg": { channel: "candle1m", instId: "BTC-USDT" },
        //         "data": [
        //             [
        //                 "1626690720000",
        //                 "31334",
        //                 "31334",
        //                 "31334",
        //                 "31334",
        //                 "0.0077",
        //                 "241.2718"
        //             ]
        //         ]
        //     }
        //
        object arg = this.safeValue(message, "arg", new Dictionary<string, object>() {});
        object channel = this.safeString(arg, "channel");
        object data = this.safeValue(message, "data", new List<object>() {});
        object marketId = this.safeString(arg, "instId");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object interval = ((string)channel).Replace((string)"candle", (string)"");
        // use a reverse lookup in a static map instead
        object timeframe = this.findTimeframe(interval);
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object parsed = this.parseOHLCV(getValue(data, i), market);
            ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
            object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
            if (isTrue(isEqual(stored, null)))
            {
                object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
                stored = new ArrayCacheByTimestamp(limit);
                ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
            }
            callDynamically(stored, "append", new object[] {parsed});
            object messageHash = add(add(channel, ":"), getValue(market, "id"));
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
            // for multiOHLCV we need special object, as opposed to other "multi"
            // methods, because OHLCV response item does not contain symbol
            // or timeframe, thus otherwise it would be unrecognizable
            object messageHashForMulti = add(add(add("multi:", channel), ":"), symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {new List<object>() {symbol, timeframe, stored}, messageHashForMulti});
        }
    }

    /**
     * @method
     * @name okx#watchOrderBook
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-order-book-channel
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.depth] okx order book depth, can be books, books5, books-l2-tbt, books50-l2-tbt, bbo-tbt
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        //
        // bbo-tbt
        // 1. Newly added channel that sends tick-by-tick Level 1 data
        // 2. All API users can subscribe
        // 3. Public depth channel, verification not required
        //
        // books-l2-tbt
        // 1. Only users who're VIP5 and above can subscribe
        // 2. Identity verification required before subscription
        //
        // books50-l2-tbt
        // 1. Only users who're VIP4 and above can subscribe
        // 2. Identity verification required before subscription
        //
        // books
        // 1. All API users can subscribe
        // 2. Public depth channel, verification not required
        //
        // books5
        // 1. All API users can subscribe
        // 2. Public depth channel, verification not required
        // 3. Data feeds will be delivered every 100ms (vs. every 200ms now)
        //
        parameters ??= new Dictionary<string, object>();
        return await this.watchOrderBookForSymbols(new List<object>() {symbol}, limit, parameters);
    }

    /**
     * @method
     * @name okx#watchOrderBookForSymbols
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-order-book-channel
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @param {string[]} symbols unified array of symbols
     * @param {int} [limit] 1,5, 400, 50 (l2-tbt, vip4+) or 40000 (vip5+) the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.depth] okx order book depth, can be books, books5, books-l2-tbt, books50-l2-tbt, bbo-tbt
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object depth = null;
        var depthparametersVariable = this.handleOptionAndParams(parameters, "watchOrderBook", "depth", "books");
        depth = ((IList<object>)depthparametersVariable)[0];
        parameters = ((IList<object>)depthparametersVariable)[1];
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(isEqual(limit, 1)))
            {
                depth = "bbo-tbt";
            } else if (isTrue(isTrue(isGreaterThan(limit, 1)) && isTrue(isLessThanOrEqual(limit, 5))))
            {
                depth = "books5";
            } else if (isTrue(isEqual(limit, 50)))
            {
                depth = "books50-l2-tbt"; // Make sure you have VIP4 and above
            } else if (isTrue(isEqual(limit, 400)))
            {
                depth = "books";
            }
        }
        if (isTrue(isTrue((isEqual(depth, "books-l2-tbt"))) || isTrue((isEqual(depth, "books50-l2-tbt")))))
        {
            if (!isTrue(this.checkRequiredCredentials(false)))
            {
                throw new AuthenticationError ((string)add(this.id, " watchOrderBook/watchOrderBookForSymbols requires authentication for this depth. Add credentials or change the depth option to books or books5")) ;
            }
            await this.authenticate(new Dictionary<string, object>() {
                { "access", "public" },
            });
        }
        object topics = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            ((IList<object>)messageHashes).Add(add(add(depth, ":"), symbol));
            object marketId = this.marketId(symbol);
            object topic = new Dictionary<string, object>() {
                { "channel", depth },
                { "instId", marketId },
            };
            ((IList<object>)topics).Add(topic);
        }
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", topics },
        };
        object url = this.getUrl(depth, "public");
        object orderbook = await this.watchMultiple(url, messageHashes, request, messageHashes);
        return (orderbook as IOrderBook).limit();
    }

    /**
     * @method
     * @name okx#unWatchOrderBookForSymbols
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-order-book-channel
     * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @param {string[]} symbols unified array of symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.limit] the maximum amount of order book entries to return
     * @param {string} [params.depth] okx order book depth, can be books, books5, books-l2-tbt, books50-l2-tbt, bbo-tbt
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> unWatchOrderBookForSymbols(object symbols, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object depth = null;
        var depthparametersVariable = this.handleOptionAndParams(parameters, "watchOrderBook", "depth", "books");
        depth = ((IList<object>)depthparametersVariable)[0];
        parameters = ((IList<object>)depthparametersVariable)[1];
        object limit = this.safeInteger(parameters, "limit");
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(isEqual(limit, 1)))
            {
                depth = "bbo-tbt";
            } else if (isTrue(isTrue(isGreaterThan(limit, 1)) && isTrue(isLessThanOrEqual(limit, 5))))
            {
                depth = "books5";
            } else if (isTrue(isEqual(limit, 50)))
            {
                depth = "books50-l2-tbt"; // Make sure you have VIP4 and above
            } else if (isTrue(isEqual(limit, 400)))
            {
                depth = "books";
            }
        }
        object topics = new List<object>() {};
        object subMessageHashes = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            ((IList<object>)subMessageHashes).Add(add(add(depth, ":"), symbol));
            ((IList<object>)messageHashes).Add(add("unsubscribe:orderbook:", symbol));
            object marketId = this.marketId(symbol);
            object topic = new Dictionary<string, object>() {
                { "channel", depth },
                { "instId", marketId },
            };
            ((IList<object>)topics).Add(topic);
        }
        object request = new Dictionary<string, object>() {
            { "op", "unsubscribe" },
            { "args", topics },
        };
        object url = this.getUrl(depth, "public");
        return await this.watchMultiple(url, messageHashes, request, messageHashes);
    }

    /**
     * @method
     * @name okx#unWatchOrderBook
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-order-book-channel
     * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @param {string} symbol unified array of symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.limit] the maximum amount of order book entries to return
     * @param {string} [params.depth] okx order book depth, can be books, books5, books-l2-tbt, books50-l2-tbt, bbo-tbt
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> unWatchOrderBook(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.unWatchOrderBookForSymbols(new List<object>() {symbol}, parameters);
    }

    public override void handleDelta(object bookside, object delta)
    {
        //
        //     [
        //         "31685", // price
        //         "0.78069158", // amount
        //         "0", // liquidated orders
        //         "17" // orders
        //     ]
        //
        object price = this.safeFloat(delta, 0);
        object amount = this.safeFloat(delta, 1);
        (bookside as IOrderBookSide).store(price, amount);
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    public virtual object handleOrderBookMessage(WebSocketClient client, object message, object orderbook, object messageHash, object market = null)
    {
        //
        //     {
        //         "asks": [
        //             [ '31738.3', '0.05973179', "0", "3" ],
        //             [ '31738.5', '0.11035404', "0", "2" ],
        //             [ '31739.6', '0.01', "0", "1" ],
        //         ],
        //         "bids": [
        //             [ '31738.2', '0.67557666', "0", "9" ],
        //             [ '31738', '0.02466947', "0", "2" ],
        //             [ '31736.3', '0.01705046', "0", "2" ],
        //         ],
        //         "instId": "BTC-USDT",
        //         "ts": "1626537446491"
        //         "checksum": -855196043,
        //         "prevSeqId": 123456,
        //         "seqId": 123457
        //     }
        //
        object asks = this.safeValue(message, "asks", new List<object>() {});
        object bids = this.safeValue(message, "bids", new List<object>() {});
        object storedAsks = getValue(orderbook, "asks");
        object storedBids = getValue(orderbook, "bids");
        this.handleDeltas(storedAsks, asks);
        this.handleDeltas(storedBids, bids);
        object marketId = this.safeString(message, "instId");
        object symbol = this.safeSymbol(marketId, market);
        object checksum = this.handleOption("watchOrderBook", "checksum", true);
        object seqId = this.safeInteger(message, "seqId");
        if (isTrue(checksum))
        {
            object prevSeqId = this.safeInteger(message, "prevSeqId");
            object nonce = getValue(orderbook, "nonce");
            object asksLength = getArrayLength(storedAsks);
            object bidsLength = getArrayLength(storedBids);
            object payloadArray = new List<object>() {};
            for (object i = 0; isLessThan(i, 25); postFixIncrement(ref i))
            {
                if (isTrue(isLessThan(i, bidsLength)))
                {
                    ((IList<object>)payloadArray).Add(this.numberToString(getValue(getValue(storedBids, i), 0)));
                    ((IList<object>)payloadArray).Add(this.numberToString(getValue(getValue(storedBids, i), 1)));
                }
                if (isTrue(isLessThan(i, asksLength)))
                {
                    ((IList<object>)payloadArray).Add(this.numberToString(getValue(getValue(storedAsks, i), 0)));
                    ((IList<object>)payloadArray).Add(this.numberToString(getValue(getValue(storedAsks, i), 1)));
                }
            }
            object payload = String.Join(":", ((IList<object>)payloadArray).ToArray());
            object responseChecksum = this.safeInteger(message, "checksum");
            object localChecksum = this.crc32(payload, true);
            object error = null;
            if (isTrue(isTrue(!isEqual(prevSeqId, -1)) && isTrue(!isEqual(nonce, prevSeqId))))
            {
                error = new InvalidNonce(add(this.id, " watchOrderBook received invalid nonce"));
            }
            if (isTrue(!isEqual(responseChecksum, localChecksum)))
            {
                error = new ChecksumError(add(add(this.id, " "), this.orderbookChecksumMessage(symbol)));
            }
            if (isTrue(!isEqual(error, null)))
            {
                ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
                ((IDictionary<string,object>)this.orderbooks).Remove((string)symbol);
                ((WebSocketClient)client).reject(error, messageHash);
            }
        }
        object timestamp = this.safeInteger(message, "ts");
        ((IDictionary<string,object>)orderbook)["nonce"] = seqId;
        ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
        ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        return orderbook;
    }

    public virtual object handleOrderBook(WebSocketClient client, object message)
    {
        //
        // snapshot
        //
        //     {
        //         "arg": { channel: 'books-l2-tbt', instId: "BTC-USDT" },
        //         "action": "snapshot",
        //         "data": [
        //             {
        //                 "asks": [
        //                     [ '31685', '0.78069158', "0", "17" ],
        //                     [ '31685.1', '0.0001', "0", "1" ],
        //                     [ '31685.6', '0.04543165', "0", "1" ],
        //                 ],
        //                 "bids": [
        //                     [ '31684.9', '0.01', "0", "1" ],
        //                     [ '31682.9', '0.0001', "0", "1" ],
        //                     [ '31680.7', '0.01', "0", "1" ],
        //                 ],
        //                 "ts": "1626532416403",
        //                 "checksum": -1023440116
        //             }
        //         ]
        //     }
        //
        // update
        //
        //     {
        //         "arg": { channel: 'books-l2-tbt', instId: "BTC-USDT" },
        //         "action": "update",
        //         "data": [
        //             {
        //                 "asks": [
        //                     [ '31657.7', '0', "0", "0" ],
        //                     [ '31659.7', '0.01', "0", "1" ],
        //                     [ '31987.3', '0.01', "0", "1" ]
        //                 ],
        //                 "bids": [
        //                     [ '31642.9', '0.50296385', "0", "4" ],
        //                     [ '31639.9', '0', "0", "0" ],
        //                     [ '31638.7', '0.01', "0", "1" ],
        //                 ],
        //                 "ts": "1626535709008",
        //                 "checksum": 830931827
        //             }
        //         ]
        //     }
        //
        // books5
        //
        //     {
        //         "arg": { channel: "books5", instId: "BTC-USDT" },
        //         "data": [
        //             {
        //                 "asks": [
        //                     [ '31738.3', '0.05973179', "0", "3" ],
        //                     [ '31738.5', '0.11035404', "0", "2" ],
        //                     [ '31739.6', '0.01', "0", "1" ],
        //                 ],
        //                 "bids": [
        //                     [ '31738.2', '0.67557666', "0", "9" ],
        //                     [ '31738', '0.02466947', "0", "2" ],
        //                     [ '31736.3', '0.01705046', "0", "2" ],
        //                 ],
        //                 "instId": "BTC-USDT",
        //                 "ts": "1626537446491"
        //             }
        //         ]
        //     }
        //
        // bbo-tbt
        //
        //     {
        //         "arg":{
        //             "channel":"bbo-tbt",
        //             "instId":"BTC-USDT"
        //         },
        //         "data":[
        //             {
        //                 "asks":[["36232.2","1.8826134","0","17"]],
        //                 "bids":[["36232.1","0.00572212","0","2"]],
        //                 "ts":"1651826598363"
        //             }
        //         ]
        //     }
        //
        object arg = this.safeDict(message, "arg", new Dictionary<string, object>() {});
        object channel = this.safeString(arg, "channel");
        object action = this.safeString(message, "action");
        object data = this.safeList(message, "data", new List<object>() {});
        object marketId = this.safeString(arg, "instId");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object depths = new Dictionary<string, object>() {
            { "bbo-tbt", 1 },
            { "books", 400 },
            { "books5", 5 },
            { "books-l2-tbt", 400 },
            { "books50-l2-tbt", 50 },
        };
        object limit = this.safeInteger(depths, channel);
        object messageHash = add(add(channel, ":"), symbol);
        if (isTrue(isEqual(action, "snapshot")))
        {
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object update = getValue(data, i);
                object orderbook = this.orderBook(new Dictionary<string, object>() {}, limit);
                ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
                ((IDictionary<string,object>)orderbook)["symbol"] = symbol;
                this.handleOrderBookMessage(client as WebSocketClient, update, orderbook, messageHash);
                callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
            }
        } else if (isTrue(isEqual(action, "update")))
        {
            if (isTrue(inOp(this.orderbooks, symbol)))
            {
                object orderbook = getValue(this.orderbooks, symbol);
                for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
                {
                    object update = getValue(data, i);
                    this.handleOrderBookMessage(client as WebSocketClient, update, orderbook, messageHash, market);
                    callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
                }
            }
        } else if (isTrue(isTrue((isEqual(channel, "books5"))) || isTrue((isEqual(channel, "bbo-tbt")))))
        {
            if (!isTrue((inOp(this.orderbooks, symbol))))
            {
                ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
            }
            object orderbook = getValue(this.orderbooks, symbol);
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object update = getValue(data, i);
                object timestamp = this.safeInteger(update, "ts");
                object snapshot = this.parseOrderBook(update, symbol, timestamp, "bids", "asks", 0, 1);
                (orderbook as IOrderBook).reset(snapshot);
                callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
            }
        }
        return message;
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object access = this.safeString(parameters, "access", "private");
        parameters = this.omit(parameters, new List<object>() {"access"});
        object url = this.getUrl("users", access);
        object messageHash = "authenticated";
        var client = this.client(url);
        var future = client.future(messageHash);
        object authenticated = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(authenticated, null)))
        {
            object timestamp = ((object)this.seconds()).ToString();
            object method = "GET";
            object path = "/users/self/verify";
            object auth = add(add(timestamp, method), path);
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256, "base64");
            object operation = "login";
            object request = new Dictionary<string, object>() {
                { "op", operation },
                { "args", new List<object>() {new Dictionary<string, object>() {
    { "apiKey", this.apiKey },
    { "passphrase", this.password },
    { "timestamp", timestamp },
    { "sign", signature },
}} },
            };
            // Only add params['access'] to prevent sending custom parameters, such as extraParams.
            if (isTrue(inOp(parameters, "access")))
            {
                ((IDictionary<string,object>)request)["access"] = getValue(parameters, "access");
            }
            this.watch(url, messageHash, request, messageHash);
        }
        return await (future as Exchange.Future);
    }

    /**
     * @method
     * @name okx#watchBalance
     * @description watch balance and get the amount of funds available for trading or funds locked in orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        return await this.subscribe("private", "account", "account", null, parameters);
    }

    public virtual void handleBalanceAndPosition(WebSocketClient client, object message)
    {
        this.handleMyLiquidation(client as WebSocketClient, message);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        //     {
        //         "arg": { channel: "account" },
        //         "data": [
        //             {
        //                 "adjEq": '',
        //                 "details": [
        //                     {
        //                         "availBal": '',
        //                         "availEq": "8.21009913",
        //                         "cashBal": "8.21009913",
        //                         "ccy": "USDT",
        //                         "coinUsdPrice": "0.99994",
        //                         "crossLiab": '',
        //                         "disEq": "8.2096065240522",
        //                         "eq": "8.21009913",
        //                         "eqUsd": "8.2096065240522",
        //                         "frozenBal": "0",
        //                         "interest": '',
        //                         "isoEq": "0",
        //                         "isoLiab": '',
        //                         "liab": '',
        //                         "maxLoan": '',
        //                         "mgnRatio": '',
        //                         "notionalLever": "0",
        //                         "ordFrozen": "0",
        //                         "twap": "0",
        //                         "uTime": "1621927314996",
        //                         "upl": "0"
        //                     },
        //                 ],
        //                 "imr": '',
        //                 "isoEq": "0",
        //                 "mgnRatio": '',
        //                 "mmr": '',
        //                 "notionalUsd": '',
        //                 "ordFroz": '',
        //                 "totalEq": "22.1930992296832",
        //                 "uTime": "1626692120916"
        //             }
        //         ]
        //     }
        //
        object arg = this.safeValue(message, "arg", new Dictionary<string, object>() {});
        object channel = this.safeString(arg, "channel");
        object type = "spot";
        object balance = this.parseTradingBalance(message);
        object oldBalance = this.safeValue(this.balance, type, new Dictionary<string, object>() {});
        object newBalance = this.deepExtend(oldBalance, balance);
        ((IDictionary<string,object>)this.balance)[(string)type] = this.safeBalance(newBalance);
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, type), channel});
    }

    public virtual object orderToTrade(object order, object market = null)
    {
        object info = this.safeValue(order, "info", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(info, "fillTime");
        object feeMarketId = this.safeString(info, "fillFeeCcy");
        object isTaker = isEqual(this.safeString(info, "execType", ""), "T");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", info },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", this.safeString(order, "symbol") },
            { "id", this.safeString(info, "tradeId") },
            { "order", this.safeString(order, "id") },
            { "type", this.safeString(order, "type") },
            { "takerOrMaker", ((bool) isTrue((isTaker))) ? "taker" : "maker" },
            { "side", this.safeString(order, "side") },
            { "price", this.safeNumber(info, "fillPx") },
            { "amount", this.safeNumber(info, "fillSz") },
            { "cost", this.safeNumber(order, "cost") },
            { "fee", new Dictionary<string, object>() {
                { "cost", this.safeNumber(info, "fillFee") },
                { "currency", this.safeCurrencyCode(feeMarketId) },
            } },
        }, market);
    }

    /**
     * @method
     * @name okx#watchMyTrades
     * @description watches information on multiple trades made by the user
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-ws-order-channel
     * @param {string} [symbol] unified market symbol of the market trades were made in
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trade structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.trigger] true if fetching trigger or conditional trades
     * @param {string} [params.type] 'spot', 'swap', 'future', 'option', 'ANY', 'SPOT', 'MARGIN', 'SWAP', 'FUTURES' or 'OPTION'
     * @param {string} [params.marginMode] 'cross' or 'isolated', for automatically setting the type to spot margin
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        // By default, receive order updates from any instrument type
        parameters ??= new Dictionary<string, object>();
        object type = null;
        var typeparametersVariable = this.handleOptionAndParams(parameters, "watchMyTrades", "type", "ANY");
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object isTrigger = this.safeBool2(parameters, "trigger", "stop", false);
        parameters = this.omit(parameters, new List<object>() {"trigger", "stop"});
        await this.loadMarkets();
        await this.authenticate(new Dictionary<string, object>() {
            { "access", ((bool) isTrue(isTrigger)) ? "business" : "private" },
        });
        object channel = ((bool) isTrue(isTrigger)) ? "orders-algo" : "orders";
        object messageHash = add(channel, "::myTrades");
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            type = getValue(market, "type");
            messageHash = add(add(messageHash, "::"), symbol);
        }
        if (isTrue(isEqual(type, "future")))
        {
            type = "futures";
        }
        object uppercaseType = ((string)type).ToUpper();
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("watchMyTrades", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(uppercaseType, "SPOT")))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                uppercaseType = "MARGIN";
            }
        }
        object request = new Dictionary<string, object>() {
            { "instType", uppercaseType },
        };
        object orders = await this.subscribe("private", messageHash, channel, null, this.extend(request, parameters));
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    /**
     * @method
     * @name okx#watchPositions
     * @see https://www.okx.com/docs-v5/en/#trading-account-websocket-positions-channel
     * @description watch all open positions
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param since
     * @param limit
     * @param {object} params extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
     */
    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate(parameters);
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {
            { "instType", "ANY" },
        };
        object channel = "positions";
        object newPositions = null;
        if (isTrue(isEqual(symbols, null)))
        {
            object arg = new Dictionary<string, object>() {
                { "channel", "positions" },
                { "instType", "ANY" },
            };
            object args = new List<object> {this.extend(arg, parameters)};
            object nonSymbolRequest = new Dictionary<string, object>() {
                { "op", "subscribe" },
                { "args", args },
            };
            object url = this.getUrl(channel, "private");
            newPositions = await this.watch(url, channel, nonSymbolRequest, channel);
        } else
        {
            newPositions = await this.subscribeMultiple("private", channel, symbols, this.extend(request, parameters));
        }
        if (isTrue(this.newUpdates))
        {
            return newPositions;
        }
        return this.filterBySymbolsSinceLimit(this.positions, symbols, since, limit, true);
    }

    public virtual void handlePositions(WebSocketClient client, object message)
    {
        //
        //    {
        //        arg: {
        //            channel: 'positions',
        //            instType: 'ANY',
        //            instId: 'XRP-USDT-SWAP',
        //            uid: '464737184507959869'
        //        },
        //        data: [{
        //            adl: '1',
        //            availPos: '',
        //            avgPx: '0.52668',
        //            baseBal: '',
        //            baseBorrowed: '',
        //            baseInterest: '',
        //            bizRefId: '',
        //            bizRefType: '',
        //            cTime: '1693151444408',
        //            ccy: 'USDT',
        //            closeOrderAlgo: [],
        //            deltaBS: '',
        //            deltaPA: '',
        //            gammaBS: '',
        //            gammaPA: '',
        //            idxPx: '0.52683',
        //            imr: '17.564000000000004',
        //            instId: 'XRP-USDT-SWAP',
        //            instType: 'SWAP',
        //            interest: '',
        //            last: '0.52691',
        //            lever: '3',
        //            liab: '',
        //            liabCcy: '',
        //            liqPx: '0.3287514731020614',
        //            margin: '',
        //            markPx: '0.52692',
        //            mgnMode: 'cross',
        //            mgnRatio: '69.00363001456147',
        //            mmr: '0.26346',
        //            notionalUsd: '52.68620388000001',
        //            optVal: '',
        //            pTime: '1693151906023',
        //            pendingCloseOrdLiabVal: '',
        //            pos: '1',
        //            posCcy: '',
        //            posId: '616057041198907393',
        //            posSide: 'net',
        //            quoteBal: '',
        //            quoteBorrowed: '',
        //            quoteInterest: '',
        //            spotInUseAmt: '',
        //            spotInUseCcy: '',
        //            thetaBS: '',
        //            thetaPA: '',
        //            tradeId: '138745402',
        //            uTime: '1693151444408',
        //            upl: '0.0240000000000018',
        //            uplLastPx: '0.0229999999999952',
        //            uplRatio: '0.0013670539986328',
        //            uplRatioLastPx: '0.001310093415356',
        //            usdPx: '',
        //            vegaBS: '',
        //            vegaPA: ''
        //        }]
        //    }
        //
        object arg = this.safeValue(message, "arg", new Dictionary<string, object>() {});
        object marketId = this.safeString(arg, "instId");
        object market = this.safeMarket(marketId, null, "-");
        object symbol = getValue(market, "symbol");
        object channel = this.safeString(arg, "channel", "");
        object data = this.safeValue(message, "data", new List<object>() {});
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new ArrayCacheBySymbolBySide();
        }
        object cache = this.positions;
        object newPositions = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object rawPosition = getValue(data, i);
            object position = this.parsePosition(rawPosition);
            if (isTrue(isEqual(getValue(position, "contracts"), 0)))
            {
                ((IDictionary<string,object>)position)["side"] = "long";
                object shortPosition = this.clone(position);
                ((IDictionary<string,object>)shortPosition)["side"] = "short";
                callDynamically(cache, "append", new object[] {shortPosition});
                ((IList<object>)newPositions).Add(shortPosition);
            }
            ((IList<object>)newPositions).Add(position);
            callDynamically(cache, "append", new object[] {position});
        }
        object messageHash = channel;
        if (isTrue(!isEqual(symbol, null)))
        {
            messageHash = add(add(channel, "::"), symbol);
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newPositions, messageHash});
    }

    /**
     * @method
     * @name okx#watchOrders
     * @description watches information on multiple orders made by the user
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-ws-order-channel
     * @param {string} [symbol] unified market symbol of the market the orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.trigger] true if fetching trigger or conditional orders
     * @param {string} [params.type] 'spot', 'swap', 'future', 'option', 'ANY', 'SPOT', 'MARGIN', 'SWAP', 'FUTURES' or 'OPTION'
     * @param {string} [params.marginMode] 'cross' or 'isolated', for automatically setting the type to spot margin
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object type = null;
        // By default, receive order updates from any instrument type
        var typeparametersVariable = this.handleOptionAndParams(parameters, "watchOrders", "type", "ANY");
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object isTrigger = this.safeValue2(parameters, "stop", "trigger", false);
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        await this.loadMarkets();
        await this.authenticate(new Dictionary<string, object>() {
            { "access", ((bool) isTrue(isTrigger)) ? "business" : "private" },
        });
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            type = getValue(market, "type");
        }
        if (isTrue(isEqual(type, "future")))
        {
            type = "futures";
        }
        object uppercaseType = ((string)type).ToUpper();
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("watchOrders", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(uppercaseType, "SPOT")))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                uppercaseType = "MARGIN";
            }
        }
        object request = new Dictionary<string, object>() {
            { "instType", uppercaseType },
        };
        object channel = ((bool) isTrue(isTrigger)) ? "orders-algo" : "orders";
        object orders = await this.subscribe("private", channel, channel, symbol, this.extend(request, parameters));
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleOrders(WebSocketClient client, object message, object subscription = null)
    {
        //
        //     {
        //         "arg":{
        //             "channel":"orders",
        //             "instType":"SPOT"
        //         },
        //         "data":[
        //             {
        //                 "accFillSz":"0",
        //                 "amendResult":"",
        //                 "avgPx":"",
        //                 "cTime":"1634548275191",
        //                 "category":"normal",
        //                 "ccy":"",
        //                 "clOrdId":"e847386590ce4dBC330547db94a08ba0",
        //                 "code":"0",
        //                 "execType":"",
        //                 "fee":"0",
        //                 "feeCcy":"USDT",
        //                 "fillFee":"0",
        //                 "fillFeeCcy":"",
        //                 "fillNotionalUsd":"",
        //                 "fillPx":"",
        //                 "fillSz":"0",
        //                 "fillTime":"",
        //                 "instId":"ETH-USDT",
        //                 "instType":"SPOT",
        //                 "lever":"",
        //                 "msg":"",
        //                 "notionalUsd":"451.4516256",
        //                 "ordId":"370257534141235201",
        //                 "ordType":"limit",
        //                 "pnl":"0",
        //                 "posSide":"",
        //                 "px":"60000",
        //                 "rebate":"0",
        //                 "rebateCcy":"ETH",
        //                 "reqId":"",
        //                 "side":"sell",
        //                 "slOrdPx":"",
        //                 "slTriggerPx":"",
        //                 "state":"live",
        //                 "sz":"0.007526",
        //                 "tag":"",
        //                 "tdMode":"cash",
        //                 "tgtCcy":"",
        //                 "tpOrdPx":"",
        //                 "tpTriggerPx":"",
        //                 "tradeId":"",
        //                 "uTime":"1634548275191"
        //             }
        //         ]
        //     }
        //
        this.handleMyTrades(client as WebSocketClient, message);
        object arg = this.safeValue(message, "arg", new Dictionary<string, object>() {});
        object channel = this.safeString(arg, "channel");
        object orders = this.safeValue(message, "data", new List<object>() {});
        object ordersLength = getArrayLength(orders);
        if (isTrue(isGreaterThan(ordersLength, 0)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            if (isTrue(isEqual(this.orders, null)))
            {
                this.orders = new ArrayCacheBySymbolById(limit);
                this.triggerOrders = new ArrayCacheBySymbolById(limit);
            }
            object stored = ((bool) isTrue((isEqual(channel, "orders-algo")))) ? this.triggerOrders : this.orders;
            object marketIds = new List<object>() {};
            object parsed = this.parseOrders(orders);
            for (object i = 0; isLessThan(i, getArrayLength(parsed)); postFixIncrement(ref i))
            {
                object order = getValue(parsed, i);
                callDynamically(stored, "append", new object[] {order});
                object symbol = getValue(order, "symbol");
                object market = this.market(symbol);
                ((IList<object>)marketIds).Add(getValue(market, "id"));
            }
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, channel});
            for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
            {
                object messageHash = add(add(channel, ":"), getValue(marketIds, i));
                callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
            }
        }
    }

    public virtual void handleMyTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //         "arg":{
        //             "channel":"orders",
        //             "instType":"SPOT"
        //         },
        //         "data":[
        //             {
        //                 "accFillSz":"0",
        //                 "amendResult":"",
        //                 "avgPx":"",
        //                 "cTime":"1634548275191",
        //                 "category":"normal",
        //                 "ccy":"",
        //                 "clOrdId":"e847386590ce4dBC330547db94a08ba0",
        //                 "code":"0",
        //                 "execType":"",
        //                 "fee":"0",
        //                 "feeCcy":"USDT",
        //                 "fillFee":"0",
        //                 "fillFeeCcy":"",
        //                 "fillNotionalUsd":"",
        //                 "fillPx":"",
        //                 "fillSz":"0",
        //                 "fillTime":"",
        //                 "instId":"ETH-USDT",
        //                 "instType":"SPOT",
        //                 "lever":"",
        //                 "msg":"",
        //                 "notionalUsd":"451.4516256",
        //                 "ordId":"370257534141235201",
        //                 "ordType":"limit",
        //                 "pnl":"0",
        //                 "posSide":"",
        //                 "px":"60000",
        //                 "rebate":"0",
        //                 "rebateCcy":"ETH",
        //                 "reqId":"",
        //                 "side":"sell",
        //                 "slOrdPx":"",
        //                 "slTriggerPx":"",
        //                 "state":"live",
        //                 "sz":"0.007526",
        //                 "tag":"",
        //                 "tdMode":"cash",
        //                 "tgtCcy":"",
        //                 "tpOrdPx":"",
        //                 "tpTriggerPx":"",
        //                 "tradeId":"",
        //                 "uTime":"1634548275191"
        //             }
        //         ]
        //     }
        //
        object arg = this.safeValue(message, "arg", new Dictionary<string, object>() {});
        object channel = this.safeString(arg, "channel");
        object rawOrders = this.safeValue(message, "data", new List<object>() {});
        object filteredOrders = new List<object>() {};
        // filter orders with no last trade id
        for (object i = 0; isLessThan(i, getArrayLength(rawOrders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(rawOrders, i);
            object tradeId = this.safeString(rawOrder, "tradeId", "");
            if (isTrue(isGreaterThan(((string)tradeId).Length, 0)))
            {
                object order = this.parseOrder(rawOrder);
                ((IList<object>)filteredOrders).Add(order);
            }
        }
        object tradesLength = getArrayLength(filteredOrders);
        if (isTrue(isEqual(tradesLength, 0)))
        {
            return;
        }
        if (isTrue(isEqual(this.myTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            this.myTrades = new ArrayCacheBySymbolById(limit);
        }
        object myTrades = this.myTrades;
        object symbols = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(filteredOrders)); postFixIncrement(ref i))
        {
            object rawTrade = getValue(filteredOrders, i);
            object trade = this.orderToTrade(rawTrade);
            callDynamically(myTrades, "append", new object[] {trade});
            object symbol = getValue(trade, "symbol");
            ((IDictionary<string,object>)symbols)[(string)symbol] = true;
        }
        object messageHash = add(channel, "::myTrades");
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.myTrades, messageHash});
        object tradeSymbols = new List<object>(((IDictionary<string,object>)symbols).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(tradeSymbols)); postFixIncrement(ref i))
        {
            object symbolMessageHash = add(add(messageHash, "::"), getValue(tradeSymbols, i));
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.myTrades, symbolMessageHash});
        }
    }

    public virtual object requestId()
    {
        object ts = ((object)this.milliseconds()).ToString();
        object randomNumber = this.randNumber(4);
        object randomPart = ((object)randomNumber).ToString();
        return add(ts, randomPart);
    }

    /**
     * @method
     * @name okx#createOrderWs
     * @see https://www.okx.com/docs-v5/en/#websocket-api-trade-place-order
     * @description create a trade order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float|undefined} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} params.test test order, default false
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrderWs(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object url = this.getUrl("private", "private");
        object messageHash = this.requestId();
        object op = null;
        var opparametersVariable = this.handleOptionAndParams(parameters, "createOrderWs", "op", "batch-orders");
        op = ((IList<object>)opparametersVariable)[0];
        parameters = ((IList<object>)opparametersVariable)[1];
        object args = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object ordType = this.safeString(args, "ordType");
        if (isTrue(isTrue(isTrue(isTrue(isTrue(isTrue((isEqual(ordType, "trigger"))) || isTrue((isEqual(ordType, "conditional")))) || isTrue((isEqual(type, "oco")))) || isTrue((isEqual(type, "move_order_stop")))) || isTrue((isEqual(type, "iceberg")))) || isTrue((isEqual(type, "twap")))))
        {
            throw new BadRequest ((string)add(this.id, " createOrderWs() does not support algo trading. this.options[\"createOrderWs\"][\"op\"] must be either order or batch-order")) ;
        }
        if (isTrue(isTrue((!isEqual(op, "order"))) && isTrue((!isEqual(op, "batch-orders")))))
        {
            throw new BadRequest ((string)add(this.id, " createOrderWs() does not support algo trading. this.options[\"createOrderWs\"][\"op\"] must be either order or privatePostTradeOrder or privatePostTradeOrderAlgo")) ;
        }
        object request = new Dictionary<string, object>() {
            { "id", messageHash },
            { "op", op },
            { "args", new List<object>() {args} },
        };
        return await this.watch(url, messageHash, request, messageHash);
    }

    public virtual void handlePlaceOrders(WebSocketClient client, object message)
    {
        //
        //  batch-orders/order/cancel-order
        //    {
        //        "id": "1689281055",
        //        "op": "batch-orders",
        //        "code": "0",
        //        "msg": '',
        //        "data": [{
        //            "tag": "e847386590ce4dBC",
        //            "ordId": "599823446566084608",
        //            "clOrdId": "e847386590ce4dBCb939511604f394b0",
        //            "sCode": "0",
        //            "sMsg": "Order successfully placed."
        //        },
        //        ...
        //        ]
        //    }
        //
        object messageHash = this.safeString(message, "id");
        object args = this.safeValue(message, "data", new List<object>() {});
        // filter out partial errors
        args = this.filterBy(args, "sCode", "0");
        // if empty means request failed and handle error
        if (isTrue(this.isEmpty(args)))
        {
            object method = this.safeString(message, "op");
            object stringMsg = this.json(message);
            this.handleErrors(1, "", client.url, method, new Dictionary<string, object>() {}, stringMsg, message, new Dictionary<string, object>() {}, new Dictionary<string, object>() {});
        }
        object orders = this.parseOrders(args, null, null, null);
        object first = this.safeDict(orders, 0, new Dictionary<string, object>() {});
        callDynamically(client as WebSocketClient, "resolve", new object[] {first, messageHash});
    }

    /**
     * @method
     * @name okx#editOrderWs
     * @description edit a trade order
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-ws-amend-order
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-ws-amend-multiple-orders
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of the currency you want to trade in units of the base currency
     * @param {float|undefined} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> editOrderWs(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object url = this.getUrl("private", "private");
        object messageHash = this.requestId();
        object op = null;
        var opparametersVariable = this.handleOptionAndParams(parameters, "editOrderWs", "op", "amend-order");
        op = ((IList<object>)opparametersVariable)[0];
        parameters = ((IList<object>)opparametersVariable)[1];
        object args = this.editOrderRequest(id, symbol, type, side, amount, price, parameters);
        object request = new Dictionary<string, object>() {
            { "id", messageHash },
            { "op", op },
            { "args", new List<object>() {args} },
        };
        return await this.watch(url, messageHash, this.extend(request, parameters), messageHash);
    }

    /**
     * @method
     * @name okx#cancelOrderWs
     * @see https://okx-docs.github.io/apidocs/websocket_api/en/#cancel-order-trade
     * @description cancel multiple orders
     * @param {string} id order id
     * @param {string} symbol unified market symbol, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clOrdId] client order id
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrderWs(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new BadRequest ((string)add(this.id, " cancelOrderWs() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        await this.authenticate();
        object url = this.getUrl("private", "private");
        object messageHash = this.requestId();
        object clientOrderId = this.safeString2(parameters, "clOrdId", "clientOrderId");
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "clOrdId"});
        object arg = new Dictionary<string, object>() {
            { "instId", this.marketId(symbol) },
        };
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)arg)["clOrdId"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)arg)["ordId"] = id;
        }
        object request = new Dictionary<string, object>() {
            { "id", messageHash },
            { "op", "cancel-order" },
            { "args", new List<object> {this.extend(arg, parameters)} },
        };
        return await this.watch(url, messageHash, request, messageHash);
    }

    /**
     * @method
     * @name okx#cancelOrdersWs
     * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-ws-mass-cancel-order
     * @description cancel multiple orders
     * @param {string[]} ids order ids
     * @param {string} symbol unified market symbol, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrdersWs(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object idsLength = getArrayLength(ids);
        if (isTrue(isGreaterThan(idsLength, 20)))
        {
            throw new BadRequest ((string)add(this.id, " cancelOrdersWs() accepts up to 20 ids at a time")) ;
        }
        if (isTrue(isEqual(symbol, null)))
        {
            throw new BadRequest ((string)add(this.id, " cancelOrdersWs() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        await this.authenticate();
        object url = this.getUrl("private", "private");
        object messageHash = this.requestId();
        object args = new List<object>() {};
        for (object i = 0; isLessThan(i, idsLength); postFixIncrement(ref i))
        {
            object arg = new Dictionary<string, object>() {
                { "instId", this.marketId(symbol) },
                { "ordId", getValue(ids, i) },
            };
            ((IList<object>)args).Add(arg);
        }
        object request = new Dictionary<string, object>() {
            { "id", messageHash },
            { "op", "batch-cancel-orders" },
            { "args", args },
        };
        return await this.watch(url, messageHash, this.deepExtend(request, parameters), messageHash);
    }

    /**
     * @method
     * @name okx#cancelAllOrdersWs
     * @see https://docs.okx.com/websockets/#message-cancelAll
     * @description cancel all open orders of a type. Only applicable to Option in Portfolio Margin mode, and MMP privilege is required.
     * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrdersWs(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new BadRequest ((string)add(this.id, " cancelAllOrdersWs() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        await this.authenticate();
        object market = this.market(symbol);
        if (isTrue(!isEqual(getValue(market, "type"), "option")))
        {
            throw new BadRequest ((string)add(this.id, " cancelAllOrdersWs is only applicable to Option in Portfolio Margin mode, and MMP privilege is required.")) ;
        }
        object url = this.getUrl("private", "private");
        object messageHash = this.requestId();
        object request = new Dictionary<string, object>() {
            { "id", messageHash },
            { "op", "mass-cancel" },
            { "args", new List<object> {this.extend(new Dictionary<string, object>() {
    { "instType", "OPTION" },
    { "instFamily", getValue(market, "id") },
}, parameters)} },
        };
        return await this.watch(url, messageHash, request, messageHash);
    }

    public virtual void handleCancelAllOrders(WebSocketClient client, object message)
    {
        //
        //    {
        //        "id": "1512",
        //        "op": "mass-cancel",
        //        "data": [
        //            {
        //                "result": true
        //            }
        //        ],
        //        "code": "0",
        //        "msg": ""
        //    }
        //
        object messageHash = this.safeString(message, "id");
        object data = this.safeValue(message, "data", new List<object>() {});
        callDynamically(client as WebSocketClient, "resolve", new object[] {data, messageHash});
    }

    public virtual object handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //     { event: 'subscribe', arg: { channel: "tickers", instId: "BTC-USDT" } }
        //
        // const channel = this.safeString (message, "channel");
        // ((WebSocketClient)client).subscriptions[channel] = message;
        return message;
    }

    public virtual void handleAuthenticate(WebSocketClient client, object message)
    {
        //
        //     { event: "login", success: true }
        //
        var future = this.safeValue((client as WebSocketClient).futures, "authenticated");
        (future as Future).resolve(true);
    }

    public override object ping(WebSocketClient client)
    {
        // OKX does not support the built-in WebSocket protocol-level ping-pong.
        // Instead, it requires a custom text-based ping-pong mechanism.
        return "ping";
    }

    public virtual object handlePong(WebSocketClient client, object message)
    {
        client.lastPong = this.milliseconds();
        return message;
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //     { event: 'error', msg: "Illegal request: {"op":"subscribe","args":["spot/ticker:BTC-USDT"]}", code: "60012" }
        //     { event: 'error", msg: "channel:ticker,instId:BTC-USDT doesn"t exist", code: "60018" }
        //     {"event":"error","msg":"Illegal request: {\\"id\\":\\"17321173472466905\\",\\"op\\":\\"amend-order\\",\\"args\\":[{\\"instId\\":\\"ETH-USDC\\",\\"ordId\\":\\"2000345622407479296\\",\\"newSz\\":\\"0.050857\\",\\"newPx\\":\\"2949.4\\",\\"postOnly\\":true}],\\"postOnly\\":true}","code":"60012","connId":"0808af6c"}
        //
        object errorCode = this.safeString(message, "code");
        try
        {
            if (isTrue(isTrue(errorCode) && isTrue(!isEqual(errorCode, "0"))))
            {
                object feedback = add(add(this.id, " "), this.json(message));
                if (isTrue(!isEqual(errorCode, "1")))
                {
                    this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
                }
                object messageString = this.safeValue(message, "msg");
                if (isTrue(!isEqual(messageString, null)))
                {
                    this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), messageString, feedback);
                } else
                {
                    object data = this.safeList(message, "data", new List<object>() {});
                    for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
                    {
                        object d = getValue(data, i);
                        errorCode = this.safeString(d, "sCode");
                        if (isTrue(!isEqual(errorCode, null)))
                        {
                            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
                        }
                        messageString = this.safeValue(message, "sMsg");
                        if (isTrue(!isEqual(messageString, null)))
                        {
                            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), messageString, feedback);
                        }
                    }
                }
                throw new ExchangeError ((string)feedback) ;
            }
        } catch(Exception e)
        {
            // if the message contains an id, it means it is a response to a request
            // so we only reject that promise, instead of deleting all futures, destroying the authentication future
            object id = this.safeString(message, "id");
            if (isTrue(isEqual(id, null)))
            {
                // try to parse it from the stringified json inside msg
                object msg = this.safeString(message, "msg");
                if (isTrue(isTrue(!isEqual(msg, null)) && isTrue(((string)msg).StartsWith(((string)"Illegal request: {")))))
                {
                    object stringifiedJson = ((string)msg).Replace((string)"Illegal request: ", (string)"");
                    object parsedJson = this.parseJson(stringifiedJson);
                    id = this.safeString(parsedJson, "id");
                }
            }
            if (isTrue(!isEqual(id, null)))
            {
                ((WebSocketClient)client).reject(e, id);
                return false;
            }
            ((WebSocketClient)client).reject(e);
            return false;
        }
        return true;
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (!isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            return;
        }
        //
        //     { event: 'subscribe', arg: { channel: "tickers", instId: "BTC-USDT" } }
        //     { event: 'login", msg: '", code: "0" }
        //
        //     {
        //         "arg": { channel: "tickers", instId: "BTC-USDT" },
        //         "data": [
        //             {
        //                 "instType": "SPOT",
        //                 "instId": "BTC-USDT",
        //                 "last": "31500.1",
        //                 "lastSz": "0.00001754",
        //                 "askPx": "31500.1",
        //                 "askSz": "0.00998144",
        //                 "bidPx": "31500",
        //                 "bidSz": "3.05652439",
        //                 "open24h": "31697",
        //                 "high24h": "32248",
        //                 "low24h": "31165.6",
        //                 "sodUtc0": "31385.5",
        //                 "sodUtc8": "32134.9",
        //                 "volCcy24h": "503403597.38138519",
        //                 "vol24h": "15937.10781721",
        //                 "ts": "1626526618762"
        //             }
        //         ]
        //     }
        //
        //     { event: 'error', msg: "Illegal request: {"op":"subscribe","args":["spot/ticker:BTC-USDT"]}", code: "60012" }
        //     { event: 'error", msg: "channel:ticker,instId:BTC-USDT doesn"t exist", code: "60018" }
        //     { event: 'error', msg: "Invalid OK_ACCESS_KEY", code: "60005" }
        //     {
        //         "event": "error",
        //         "msg": "Illegal request: {"op":"login","args":["de89b035-b233-44b2-9a13-0ccdd00bda0e","7KUcc8YzQhnxBE3K","1626691289","H57N99mBt5NvW8U19FITrPdOxycAERFMaapQWRqLaSE="]}",
        //         "code": "60012"
        //     }
        //
        //
        //
        if (isTrue(isEqual(message, "pong")))
        {
            this.handlePong(client as WebSocketClient, message);
            return;
        }
        // const table = this.safeString (message, 'table');
        // if (table === undefined) {
        object eventVar = this.safeString2(message, "event", "op");
        if (isTrue(!isEqual(eventVar, null)))
        {
            object methods = new Dictionary<string, object>() {
                { "login", this.handleAuthenticate },
                { "subscribe", this.handleSubscriptionStatus },
                { "unsubscribe", this.handleUnsubscription },
                { "order", this.handlePlaceOrders },
                { "batch-orders", this.handlePlaceOrders },
                { "amend-order", this.handlePlaceOrders },
                { "batch-amend-orders", this.handlePlaceOrders },
                { "cancel-order", this.handlePlaceOrders },
                { "mass-cancel", this.handleCancelAllOrders },
            };
            object method = this.safeValue(methods, eventVar);
            if (isTrue(!isEqual(method, null)))
            {
                DynamicInvoker.InvokeMethod(method, new object[] { client, message});
            }
        } else
        {
            object arg = this.safeValue(message, "arg", new Dictionary<string, object>() {});
            object channel = this.safeString(arg, "channel");
            object methods = new Dictionary<string, object>() {
                { "bbo-tbt", this.handleOrderBook },
                { "books", this.handleOrderBook },
                { "books5", this.handleOrderBook },
                { "books50-l2-tbt", this.handleOrderBook },
                { "books-l2-tbt", this.handleOrderBook },
                { "tickers", this.handleTicker },
                { "mark-price", this.handleTicker },
                { "positions", this.handlePositions },
                { "index-tickers", this.handleTicker },
                { "sprd-tickers", this.handleTicker },
                { "block-tickers", this.handleTicker },
                { "trades", this.handleTrades },
                { "trades-all", this.handleTrades },
                { "account", this.handleBalance },
                { "funding-rate", this.handleFundingRate },
                { "orders", this.handleOrders },
                { "orders-algo", this.handleOrders },
                { "liquidation-orders", this.handleLiquidation },
                { "balance_and_position", this.handleBalanceAndPosition },
            };
            object method = this.safeValue(methods, channel);
            if (isTrue(isEqual(method, null)))
            {
                if (isTrue(isEqual(getIndexOf(channel, "candle"), 0)))
                {
                    this.handleOHLCV(client as WebSocketClient, message);
                }
            } else
            {
                DynamicInvoker.InvokeMethod(method, new object[] { client, message});
            }
        }
    }

    public virtual void handleUnSubscriptionTrades(WebSocketClient client, object symbol, object channel)
    {
        object subMessageHash = add(add(channel, ":"), symbol);
        object messageHash = add("unsubscribe:", subMessageHash);
        this.cleanUnsubscription(client as WebSocketClient, subMessageHash, messageHash);
        if (isTrue(inOp(this.trades, symbol)))
        {
            ((IDictionary<string,object>)this.trades).Remove((string)symbol);
        }
    }

    public virtual void handleUnsubscriptionOrderBook(WebSocketClient client, object symbol, object channel)
    {
        object subMessageHash = add(add(channel, ":"), symbol);
        object messageHash = add("unsubscribe:orderbook:", symbol);
        this.cleanUnsubscription(client as WebSocketClient, subMessageHash, messageHash);
        if (isTrue(inOp(this.orderbooks, symbol)))
        {
            ((IDictionary<string,object>)this.orderbooks).Remove((string)symbol);
        }
    }

    public virtual void handleUnsubscriptionOHLCV(WebSocketClient client, object symbol, object channel)
    {
        object tf = ((string)channel).Replace((string)"candle", (string)"");
        object timeframe = this.findTimeframe(tf);
        object subMessageHash = add(add(add("multi:", channel), ":"), symbol);
        object messageHash = add("unsubscribe:", subMessageHash);
        this.cleanUnsubscription(client as WebSocketClient, subMessageHash, messageHash);
        if (isTrue(inOp(getValue(this.ohlcvs, symbol), timeframe)))
        {
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol)).Remove((string)timeframe);
        }
    }

    public virtual void handleUnsubscriptionTicker(WebSocketClient client, object symbol, object channel)
    {
        object subMessageHash = add(add(channel, "::"), symbol);
        object messageHash = add("unsubscribe:ticker:", symbol);
        this.cleanUnsubscription(client as WebSocketClient, subMessageHash, messageHash);
        if (isTrue(inOp(this.tickers, symbol)))
        {
            ((IDictionary<string,object>)this.tickers).Remove((string)symbol);
        }
    }

    public virtual void handleUnsubscription(WebSocketClient client, object message)
    {
        //
        // {
        //     "event": "unsubscribe",
        //     "arg": {
        //       "channel": "tickers",
        //       "instId": "LTC-USD-200327"
        //     },
        //     "connId": "a4d3ae55"
        // }
        // arg might be an array or list
        object arg = this.safeDict(message, "arg", new Dictionary<string, object>() {});
        object channel = this.safeString(arg, "channel", "");
        object marketId = this.safeString(arg, "instId");
        object symbol = this.safeSymbol(marketId);
        if (isTrue(isTrue(isEqual(channel, "trades")) || isTrue(isEqual(channel, "trades-all"))))
        {
            this.handleUnSubscriptionTrades(client as WebSocketClient, symbol, channel);
        } else if (isTrue(isTrue(((string)channel).StartsWith(((string)"bbo"))) || isTrue(((string)channel).StartsWith(((string)"book")))))
        {
            this.handleUnsubscriptionOrderBook(client as WebSocketClient, symbol, channel);
        } else if (isTrue(isGreaterThan(getIndexOf(channel, "tickers"), -1)))
        {
            this.handleUnsubscriptionTicker(client as WebSocketClient, symbol, channel);
        } else if (isTrue(((string)channel).StartsWith(((string)"candle"))))
        {
            this.handleUnsubscriptionOHLCV(client as WebSocketClient, symbol, channel);
        }
    }
}
