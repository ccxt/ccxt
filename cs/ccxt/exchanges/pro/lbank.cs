namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class lbank { public lbank(object args = null) : base(args) { } }
public partial class lbank : ccxt.lbank
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "fetchOHLCVWs", true },
                { "fetchOrderBookWs", true },
                { "fetchTickerWs", true },
                { "fetchTradesWs", true },
                { "watchBalance", false },
                { "watchTicker", true },
                { "watchTickers", false },
                { "watchTrades", true },
                { "watchMyTrades", false },
                { "watchOrders", true },
                { "watchOrderBook", true },
                { "watchOHLCV", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", "wss://www.lbkex.net/ws/V2/" },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "watchOHLCV", new Dictionary<string, object>() {
                    { "timeframes", new Dictionary<string, object>() {
                        { "1m", "1min" },
                        { "5m", "5min" },
                        { "15m", "15min" },
                        { "30m", "30min" },
                        { "1h", "1hr" },
                        { "4h", "4hr" },
                        { "1d", "day" },
                        { "1w", "week" },
                        { "1M", "month" },
                        { "1y", "year" },
                    } },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {} },
            { "exceptions", new Dictionary<string, object>() {} },
        });
    }

    public virtual object requestId()
    {
        object previousValue = this.safeInteger(this.options, "requestId", 0);
        object newValue = this.sum(previousValue, 1);
        ((IDictionary<string,object>)this.options)["requestId"] = newValue;
        return newValue;
    }

    public async override Task<object> fetchOHLCVWs(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name lbank#fetchOHLCVWs
        * @see https://www.lbank.com/en-US/docs/index.html#request-amp-subscription-instruction
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object watchOHLCVOptions = this.safeValue(this.options, "watchOHLCV", new Dictionary<string, object>() {});
        object timeframes = this.safeValue(watchOHLCVOptions, "timeframes", new Dictionary<string, object>() {});
        object timeframeId = this.safeString(timeframes, timeframe, timeframe);
        object messageHash = add(add(add("fetchOHLCV:", getValue(market, "symbol")), ":"), timeframeId);
        object message = new Dictionary<string, object>() {
            { "action", "request" },
            { "request", "kbar" },
            { "kbar", timeframeId },
            { "pair", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)message)["start"] = this.parseToInt((Math.Floor(Double.Parse((divide(since, 1000)).ToString()))));
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)message)["size"] = limit;
        }
        object request = this.deepExtend(message, parameters);
        object requestId = this.requestId();
        return await this.watch(url, messageHash, request, requestId, request);
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name lbank#watchOHLCV
        * @see https://www.lbank.com/en-US/docs/index.html#subscription-of-k-line-data
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object watchOHLCVOptions = this.safeValue(this.options, "watchOHLCV", new Dictionary<string, object>() {});
        object timeframes = this.safeValue(watchOHLCVOptions, "timeframes", new Dictionary<string, object>() {});
        object timeframeId = this.safeString(timeframes, timeframe, timeframe);
        object messageHash = add(add(add("ohlcv:", getValue(market, "symbol")), ":"), timeframeId);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object subscribe = new Dictionary<string, object>() {
            { "action", "subscribe" },
            { "subscribe", "kbar" },
            { "kbar", timeframeId },
            { "pair", getValue(market, "id") },
        };
        object request = this.deepExtend(subscribe, parameters);
        object ohlcv = await this.watch(url, messageHash, request, messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        // request
        //    {
        //        "records":[
        //           [
        //              1705364400,
        //              42614,
        //              42624.57,
        //              42532.15,
        //              42537.43,
        //              13.2615,
        //              564568.931565,
        //              433
        //           ]
        //        ],
        //        "columns":[
        //           "timestamp",
        //           "open",
        //           "high",
        //           "low",
        //           "close",
        //           "volume",
        //           "turnover",
        //           "count"
        //        ],
        //        "SERVER":"V2",
        //        "count":1,
        //        "kbar":"5min",
        //        "type":"kbar",
        //        "pair":"btc_usdt",
        //        "TS":"2024-01-16T08:29:41.718"
        //    }
        // subscribe
        //      {
        //          SERVER: 'V2',
        //          kbar: {
        //              a: 26415.891476,
        //              c: 19315.51,
        //              t: '2022-10-02T12:44:00.000',
        //              v: 1.3676,
        //              h: 19316.66,
        //              slot: '1min',
        //              l: 19315.51,
        //              n: 1,
        //              o: 19316.66
        //          },
        //          type: 'kbar',
        //          pair: 'btc_usdt',
        //          TS: '2022-10-02T12:44:15.865'
        //      }
        //
        object marketId = this.safeString(message, "pair");
        object symbol = this.safeSymbol(marketId, null, "_");
        object watchOHLCVOptions = this.safeValue(this.options, "watchOHLCV", new Dictionary<string, object>() {});
        object timeframes = this.safeValue(watchOHLCVOptions, "timeframes", new Dictionary<string, object>() {});
        object records = this.safeValue(message, "records");
        if (isTrue(!isEqual(records, null)))
        {
            object rawOHLCV = this.safeValue(records, 0, new List<object>() {});
            object parsed = new List<object> {this.safeInteger(rawOHLCV, 0), this.safeNumber(rawOHLCV, 1), this.safeNumber(rawOHLCV, 2), this.safeNumber(rawOHLCV, 3), this.safeNumber(rawOHLCV, 4), this.safeNumber(rawOHLCV, 5)};
            object timeframeId = this.safeString(message, "kbar");
            object timeframe = this.findTimeframe(timeframeId, timeframes);
            ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
            object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
            if (isTrue(isEqual(stored, null)))
            {
                object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
                stored = new ArrayCacheByTimestamp(limit);
                ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
            }
            callDynamically(stored, "append", new object[] {parsed});
            object messageHash = add(add(add("fetchOHLCV:", symbol), ":"), timeframeId);
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        } else
        {
            object rawOHLCV = this.safeValue(message, "kbar", new Dictionary<string, object>() {});
            object timeframeId = this.safeString(rawOHLCV, "slot");
            object datetime = this.safeString(rawOHLCV, "t");
            object parsed = new List<object> {this.parse8601(datetime), this.safeNumber(rawOHLCV, "o"), this.safeNumber(rawOHLCV, "h"), this.safeNumber(rawOHLCV, "l"), this.safeNumber(rawOHLCV, "c"), this.safeNumber(rawOHLCV, "v")};
            object timeframe = this.findTimeframe(timeframeId, timeframes);
            ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
            object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
            if (isTrue(isEqual(stored, null)))
            {
                object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
                stored = new ArrayCacheByTimestamp(limit);
                ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
            }
            callDynamically(stored, "append", new object[] {parsed});
            object messageHash = add(add(add("ohlcv:", symbol), ":"), timeframeId);
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        }
    }

    public async override Task<object> fetchTickerWs(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name lbank#fetchTickerWs
        * @see https://www.lbank.com/en-US/docs/index.html#request-amp-subscription-instruction
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the cex api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object messageHash = add("fetchTicker:", getValue(market, "symbol"));
        object message = new Dictionary<string, object>() {
            { "action", "request" },
            { "request", "tick" },
            { "pair", getValue(market, "id") },
        };
        object request = this.deepExtend(message, parameters);
        object requestId = this.requestId();
        return await this.watch(url, messageHash, request, requestId, request);
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name lbank#watchTicker
        * @see https://www.lbank.com/en-US/docs/index.html#market
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the lbank api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object messageHash = add("ticker:", getValue(market, "symbol"));
        object message = new Dictionary<string, object>() {
            { "action", "subscribe" },
            { "subscribe", "tick" },
            { "pair", getValue(market, "id") },
        };
        object request = this.deepExtend(message, parameters);
        return await this.watch(url, messageHash, request, messageHash, request);
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        //     {
        //         "tick":{
        //             "to_cny":76643.5,
        //             "high":0.02719761,
        //             "vol":497529.7686,
        //             "low":0.02603071,
        //             "change":2.54,
        //             "usd":299.12,
        //             "to_usd":11083.66,
        //             "dir":"sell",
        //             "turnover":13224.0186,
        //             "latest":0.02698749,
        //             "cny":2068.41
        //         },
        //         "type":"tick",
        //         "pair":"eth_btc",
        //         "SERVER":"V2",
        //         "TS":"2019-07-01T11:33:55.188"
        //     }
        //
        object marketId = this.safeString(message, "pair");
        object symbol = this.safeSymbol(marketId);
        object market = this.safeMarket(marketId);
        object parsedTicker = this.parseWsTicker(message, market);
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = parsedTicker;
        object messageHash = add("ticker:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {parsedTicker, messageHash});
        messageHash = add("fetchTicker:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {parsedTicker, messageHash});
    }

    public virtual object parseWsTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "tick":{
        //             "to_cny":76643.5,
        //             "high":0.02719761,
        //             "vol":497529.7686,
        //             "low":0.02603071,
        //             "change":2.54,
        //             "usd":299.12,
        //             "to_usd":11083.66,
        //             "dir":"sell",
        //             "turnover":13224.0186,
        //             "latest":0.02698749,
        //             "cny":2068.41
        //         },
        //         "type":"tick",
        //         "pair":"eth_btc",
        //         "SERVER":"V2",
        //         "TS":"2019-07-01T11:33:55.188"
        //     }
        //
        object marketId = this.safeString(ticker, "pair");
        object symbol = this.safeSymbol(marketId, market);
        object datetime = this.safeString(ticker, "TS");
        object tickerData = this.safeValue(ticker, "tick");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "high", this.safeString(tickerData, "high") },
            { "low", this.safeString(tickerData, "low") },
            { "bid", null },
            { "bidVolume", null },
            { "ask", null },
            { "askVolume", null },
            { "vwap", null },
            { "open", null },
            { "close", null },
            { "last", this.safeString(tickerData, "latest") },
            { "previousClose", null },
            { "change", null },
            { "percentage", this.safeString(tickerData, "change") },
            { "average", null },
            { "baseVolume", this.safeString(tickerData, "vol") },
            { "quoteVolume", this.safeString(tickerData, "turnover") },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTradesWs(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name lbank#fetchTradesWs
        * @description get the list of most recent trades for a particular symbol
        * @see https://www.lbank.com/en-US/docs/index.html#request-amp-subscription-instruction
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object messageHash = add("fetchTrades:", getValue(market, "symbol"));
        if (isTrue(isEqual(limit, null)))
        {
            limit = 10;
        }
        object message = new Dictionary<string, object>() {
            { "action", "request" },
            { "request", "trade" },
            { "pair", getValue(market, "id") },
            { "size", limit },
        };
        object request = this.deepExtend(message, parameters);
        object requestId = this.requestId();
        return await this.watch(url, messageHash, request, requestId, request);
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name lbank#watchTrades
        * @see https://www.lbank.com/en-US/docs/index.html#trade-record
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object messageHash = add("trades:", getValue(market, "symbol"));
        object message = new Dictionary<string, object>() {
            { "action", "subscribe" },
            { "subscribe", "trade" },
            { "pair", getValue(market, "id") },
        };
        object request = this.deepExtend(message, parameters);
        object trades = await this.watch(url, messageHash, request, messageHash, request);
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        // request
        //     {
        //         columns: [ 'timestamp', 'price', 'volume', 'direction' ],
        //         SERVER: 'V2',
        //         count: 100,
        //         trades: [],
        //         type: 'trade',
        //         pair: 'btc_usdt',
        //         TS: '2024-01-16T08:48:24.470'
        //     }
        // subscribe
        //     {
        //         "trade":{
        //             "volume":6.3607,
        //             "amount":77148.9303,
        //             "price":12129,
        //             "direction":"sell", // or "sell_market"
        //             "TS":"2019-06-28T19:55:49.460"
        //         },
        //         "type":"trade",
        //         "pair":"btc_usdt",
        //         "SERVER":"V2",
        //         "TS":"2019-06-28T19:55:49.466"
        //     }
        //
        object marketId = this.safeString(message, "pair");
        object symbol = this.safeSymbol(marketId);
        object market = this.safeMarket(marketId);
        object stored = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        object rawTrade = this.safeValue(message, "trade");
        object rawTrades = this.safeValue(message, "trades", new List<object>() {rawTrade});
        for (object i = 0; isLessThan(i, getArrayLength(rawTrades)); postFixIncrement(ref i))
        {
            object trade = this.parseWsTrade(getValue(rawTrades, i), market);
            ((IDictionary<string,object>)trade)["symbol"] = symbol;
            callDynamically(stored, "append", new object[] {trade});
        }
        ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        object messageHash = add("trades:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.trades, symbol), messageHash});
        messageHash = add("fetchTrades:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.trades, symbol), messageHash});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        // request
        //    [ 'timestamp', 'price', 'volume', 'direction' ]
        // subscribe
        //    {
        //        "volume":6.3607,
        //        "amount":77148.9303,
        //        "price":12129,
        //        "direction":"sell", // or "sell_market"
        //        "TS":"2019-06-28T19:55:49.460"
        //    }
        //
        object timestamp = this.safeInteger(trade, 0);
        object datetime = ((bool) isTrue((!isEqual(timestamp, null)))) ? (this.iso8601(timestamp)) : (this.safeString(trade, "TS"));
        if (isTrue(isEqual(timestamp, null)))
        {
            timestamp = this.parse8601(datetime);
        }
        object side = this.safeString2(trade, "direction", 3);
        side = ((string)side).Replace((string)"_market", (string)"");
        return this.safeTrade(new Dictionary<string, object>() {
            { "timestamp", timestamp },
            { "datetime", datetime },
            { "symbol", null },
            { "id", null },
            { "order", null },
            { "type", null },
            { "takerOrMaker", null },
            { "side", side },
            { "price", this.safeString2(trade, "price", 1) },
            { "amount", this.safeString2(trade, "volume", 2) },
            { "cost", this.safeString(trade, "amount") },
            { "fee", null },
            { "info", trade },
        }, market);
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name lbank#watchOrders
        * @see https://github.com/LBank-exchange/lbank-official-api-docs/blob/master/API-For-Spot-EN/WebSocket%20API(Asset%20%26%20Order).md#websocketsubscribeunsubscribe
        * @description get the list of trades associated with the user
        * @param {string} [symbol] unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the lbank api endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object key = await this.authenticate(parameters);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object messageHash = null;
        object pair = "all";
        if (isTrue(isEqual(symbol, null)))
        {
            messageHash = "orders:all";
        } else
        {
            object market = this.market(symbol);
            symbol = this.symbol(symbol);
            messageHash = add("orders:", getValue(market, "symbol"));
            pair = getValue(market, "id");
        }
        object message = new Dictionary<string, object>() {
            { "action", "subscribe" },
            { "subscribe", "orderUpdate" },
            { "subscribeKey", key },
            { "pair", pair },
        };
        object request = this.deepExtend(message, parameters);
        object orders = await this.watch(url, messageHash, request, messageHash, request);
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleOrders(WebSocketClient client, object message)
    {
        //
        //     {
        //         "orderUpdate":{
        //             "amount":"0.003",
        //             "orderStatus":2,
        //             "price":"0.02455211",
        //             "role":"maker",
        //             "updateTime":1561704577786,
        //             "uuid":"d0db191d-xxxxx-4418-xxxxx-fbb1xxxx2ea9",
        //             "txUuid":"da88f354d5xxxxxxa12128aa5bdcb3",
        //             "volumePrice":"0.00007365633"
        //         },
        //         "pair":"eth_btc",
        //         "type":"orderUpdate",
        //         "SERVER":"V2",
        //         "TS":"2019-06-28T14:49:37.816"
        //     }
        //
        object marketId = this.safeString(message, "pair");
        object symbol = this.safeSymbol(marketId, null, "_");
        object myOrders = null;
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            myOrders = new ArrayCacheBySymbolById(limit);
        } else
        {
            myOrders = this.orders;
        }
        object order = this.parseWsOrder(message);
        callDynamically(myOrders, "append", new object[] {order});
        this.orders = myOrders;
        callDynamically(client as WebSocketClient, "resolve", new object[] {myOrders, "orders"});
        object messageHash = add("orders:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {myOrders, messageHash});
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        //     {
        //         "orderUpdate":{
        //             "amount":"0.003",
        //             "orderStatus":2,
        //             "price":"0.02455211",
        //             "role":"maker",
        //             "updateTime":1561704577786,
        //             "uuid":"d0db191d-xxxxx-4418-xxxxx-fbb1xxxx2ea9",
        //             "txUuid":"da88f354d5xxxxxxa12128aa5bdcb3",
        //             "volumePrice":"0.00007365633"
        //         },
        //         "pair":"eth_btc",
        //         "type":"orderUpdate",
        //         "SERVER":"V2",
        //         "TS":"2019-06-28T14:49:37.816"
        //     }
        //     {
        //         "SERVER": "V2",
        //         "orderUpdate": {
        //            "accAmt": "0",
        //            "amount": "0",
        //            "avgPrice": "0",
        //            "customerID": "",
        //            "orderAmt": "5",
        //            "orderPrice": "0.009834",
        //            "orderStatus": 0,
        //            "price": "0.009834",
        //            "remainAmt": "5",
        //            "role": "taker",
        //            "symbol": "lbk_usdt",
        //            "type": "buy_market",
        //            "updateTime": 1705676718532,
        //            "uuid": "9b94ab2d-a510-4abe-a784-44a9d9c38ec7",
        //            "volumePrice": "0"
        //         },
        //         "type": "orderUpdate",
        //         "pair": "lbk_usdt",
        //         "TS": "2024-01-19T23:05:18.548"
        //     }
        //
        object orderUpdate = this.safeValue(order, "orderUpdate", new Dictionary<string, object>() {});
        object rawType = this.safeString(orderUpdate, "type", "");
        object typeParts = ((string)rawType).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
        object side = this.safeString(typeParts, 0);
        object exchangeType = this.safeString(typeParts, 1);
        object type = null;
        if (isTrue(isTrue(!isEqual(rawType, "buy")) && isTrue(!isEqual(rawType, "sell"))))
        {
            type = ((bool) isTrue((isEqual(exchangeType, "market")))) ? "market" : "limit";
        }
        object marketId = this.safeString(order, "pair");
        object symbol = this.safeSymbol(marketId, market, "_");
        object timestamp = this.safeInteger(orderUpdate, "updateTime");
        object status = this.safeString(orderUpdate, "orderStatus");
        object orderAmount = this.safeString(orderUpdate, "orderAmt");
        object cost = null;
        if (isTrue(isTrue((isEqual(type, "market"))) && isTrue((isEqual(side, "buy")))))
        {
            cost = orderAmount;
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString(orderUpdate, "uuid") },
            { "clientOrderId", this.safeString(orderUpdate, "customerID") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", this.safeInteger(orderUpdate, "updateTime") },
            { "symbol", symbol },
            { "type", type },
            { "side", side },
            { "price", this.safeString2(orderUpdate, "price", "orderPrice") },
            { "stopPrice", null },
            { "average", this.safeString(orderUpdate, "avgPrice") },
            { "amount", this.safeString2(orderUpdate, "amount", "orderAmt") },
            { "remaining", this.safeString(orderUpdate, "remainAmt") },
            { "filled", this.safeString(orderUpdate, "accAmt") },
            { "status", this.parseWsOrderStatus(status) },
            { "fee", null },
            { "cost", cost },
            { "trades", null },
        }, market);
    }

    public virtual object parseWsOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "-1", "canceled" },
            { "0", "open" },
            { "1", "open" },
            { "2", "closed" },
            { "4", "closed" },
        };
        return this.safeString(statuses, status, status);
    }

    public async virtual Task<object> fetchOrderBookWs(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name lbank#watchOrderBook
        * @see https://www.lbank.com/en-US/docs/index.html#request-amp-subscription-instruction
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the lbank api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object messageHash = add("fetchOrderbook:", getValue(market, "symbol"));
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100;
        }
        object subscribe = new Dictionary<string, object>() {
            { "action", "request" },
            { "request", "depth" },
            { "depth", limit },
            { "pair", getValue(market, "id") },
        };
        object request = this.deepExtend(subscribe, parameters);
        object orderbook = await this.watch(url, messageHash, request, messageHash);
        return (orderbook as IOrderBook).limit();
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name lbank#watchOrderBook
        * @see https://www.lbank.com/en-US/docs/index.html#market-depth
        * @see https://www.lbank.com/en-US/docs/index.html#market-increment-depth
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the lbank api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object messageHash = add("orderbook:", getValue(market, "symbol"));
        parameters = this.omit(parameters, "aggregation");
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100;
        }
        object subscribe = new Dictionary<string, object>() {
            { "action", "subscribe" },
            { "subscribe", "depth" },
            { "depth", limit },
            { "pair", getValue(market, "id") },
        };
        object request = this.deepExtend(subscribe, parameters);
        object orderbook = await this.watch(url, messageHash, request, messageHash);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        // request
        //    {
        //        "SERVER":"V2",
        //        "asks":[
        //           [
        //              42585.84,
        //              1.4422
        //           ],
        //           ...
        //        ],
        //        "bids":[
        //           [
        //              42585.83,
        //              1.8054
        //           ],
        //          ,,,
        //        ],
        //        "count":100,
        //        "type":"depth",
        //        "pair":"btc_usdt",
        //        "TS":"2024-01-16T08:26:00.413"
        //    }
        // subscribe
        //     {
        //         "depth": {
        //             "asks": [
        //                 [
        //                     0.0252,
        //                     0.5833
        //                 ],
        //                 [
        //                     0.025215,
        //                     4.377
        //                 ],
        //                 ...
        //             ],
        //             "bids": [
        //                 [
        //                     0.025135,
        //                     3.962
        //                 ],
        //                 [
        //                     0.025134,
        //                     3.46
        //                 ],
        //                 ...
        //             ]
        //         },
        //         "count": 100,
        //         "type": "depth",
        //         "pair": "eth_btc",
        //         "SERVER": "V2",
        //         "TS": "2019-06-28T17:49:22.722"
        //     }
        //
        object marketId = this.safeString(message, "pair");
        object symbol = this.safeSymbol(marketId);
        object orderBook = this.safeValue(message, "depth", message);
        object datetime = this.safeString(message, "TS");
        object timestamp = this.parse8601(datetime);
        // let orderbook = this.safeValue (this.orderbooks, symbol);
        if (!isTrue((inOp(this.orderbooks, symbol))))
        {
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {});
        }
        object orderbook = getValue(this.orderbooks, symbol);
        object snapshot = this.parseOrderBook(orderBook, symbol, timestamp, "bids", "asks");
        (orderbook as IOrderBook).reset(snapshot);
        object messageHash = add("orderbook:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
        messageHash = add("fetchOrderbook:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public virtual void handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //    {
        //        SERVER: 'V2',
        //        message: "Missing parameter ['kbar']",
        //        status: 'error',
        //        TS: '2024-01-16T08:09:43.314'
        //    }
        //
        object errMsg = this.safeString(message, "message", "");
        var error = new ExchangeError(add(add(this.id, " "), errMsg));
        ((WebSocketClient)client).reject(error);
    }

    public async virtual Task handlePing(WebSocketClient client, object message)
    {
        //
        //  { ping: 'a13a939c-5f25-4e06-9981-93cb3b890707', action: 'ping' }
        //
        object pingId = this.safeString(message, "ping");
        await client.send(new Dictionary<string, object>() {
            { "action", "pong" },
            { "pong", pingId },
        });
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        object status = this.safeString(message, "status");
        if (isTrue(isEqual(status, "error")))
        {
            this.handleErrorMessage(client as WebSocketClient, message);
            return;
        }
        object type = this.safeString2(message, "type", "action");
        if (isTrue(isEqual(type, "ping")))
        {
            this.spawn(this.handlePing, new object[] { client, message});
            return;
        }
        object handlers = new Dictionary<string, object>() {
            { "kbar", this.handleOHLCV },
            { "depth", this.handleOrderBook },
            { "trade", this.handleTrades },
            { "tick", this.handleTicker },
            { "orderUpdate", this.handleOrders },
        };
        object handler = this.safeValue(handlers, type);
        if (isTrue(!isEqual(handler, null)))
        {
            DynamicInvoker.InvokeMethod(handler, new object[] { client, message});
        }
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        // when we implement more private streams, we need to refactor the authentication
        // to be concurent-safe and respect the same authentication token
        parameters ??= new Dictionary<string, object>();
        object url = getValue(getValue(this.urls, "api"), "ws");
        var client = this.client(url);
        object now = this.milliseconds();
        object messageHash = "authenticated";
        object authenticated = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(authenticated, null)))
        {
            this.checkRequiredCredentials();
            object response = await this.spotPrivatePostSubscribeGetKey(parameters);
            //
            // {"result":true,"data":"4e9958623e6006bd7b13ff9f36c03b36132f0f8da37f70b14ff2c4eab1fe0c97","error_code":0,"ts":1705602277198}
            //
            object result = this.safeValue(response, "result");
            if (isTrue(!isEqual(result, true)))
            {
                throw new ExchangeError ((string)add(this.id, " failed to get subscribe key")) ;
            }
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)["authenticated"] = new Dictionary<string, object>() {
                { "key", this.safeString(response, "data") },
                { "expires", this.sum(now, 3300000) },
            };
        } else
        {
            object expires = this.safeInteger(authenticated, "expires", 0);
            if (isTrue(isLessThan(expires, now)))
            {
                object request = new Dictionary<string, object>() {
                    { "subscribeKey", getValue(authenticated, "key") },
                };
                object response = await this.spotPrivatePostSubscribeRefreshKey(this.extend(request, parameters));
                //
                //    {"result": "true"}
                //
                object result = this.safeString(response, "result");
                if (isTrue(!isEqual(result, "true")))
                {
                    throw new ExchangeError ((string)add(this.id, " failed to refresh the SubscribeKey")) ;
                }
                ((IDictionary<string,object>)getValue(getValue(client as WebSocketClient, "subscriptions"), "authenticated"))["expires"] = this.sum(now, 3300000); // SubscribeKey lasts one hour, refresh it 5 minutes before it expires
            }
        }
        return getValue(getValue(((WebSocketClient)client).subscriptions, "authenticated"), "key");
    }
}
