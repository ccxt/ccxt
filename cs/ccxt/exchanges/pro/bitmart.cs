namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class bitmart { public bitmart(object args = null) : base(args) { } }
public partial class bitmart : ccxt.bitmart
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "createOrderWs", false },
                { "editOrderWs", false },
                { "fetchOpenOrdersWs", false },
                { "fetchOrderWs", false },
                { "cancelOrderWs", false },
                { "cancelOrdersWs", false },
                { "cancelAllOrdersWs", false },
                { "ws", true },
                { "watchBalance", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchBidsAsks", true },
                { "watchOrderBook", true },
                { "watchOrderBookForSymbols", true },
                { "watchOrders", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
                { "watchOHLCV", true },
                { "watchPosition", "emulated" },
                { "watchPositions", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "spot", new Dictionary<string, object>() {
                            { "public", "wss://ws-manager-compress.{hostname}/api?protocol=1.1" },
                            { "private", "wss://ws-manager-compress.{hostname}/user?protocol=1.1" },
                        } },
                        { "swap", new Dictionary<string, object>() {
                            { "public", "wss://openapi-ws-v2.{hostname}/api?protocol=1.1" },
                            { "private", "wss://openapi-ws-v2.{hostname}/user?protocol=1.1" },
                        } },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "defaultType", "spot" },
                { "watchBalance", new Dictionary<string, object>() {
                    { "fetchBalanceSnapshot", true },
                    { "awaitBalanceSnapshot", false },
                } },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "depth", "depth/increase100" },
                } },
                { "watchOrderBookForSymbols", new Dictionary<string, object>() {
                    { "depth", "depth/increase100" },
                } },
                { "ws", new Dictionary<string, object>() {
                    { "inflate", true },
                } },
                { "timeframes", new Dictionary<string, object>() {
                    { "1m", "1m" },
                    { "3m", "3m" },
                    { "5m", "5m" },
                    { "15m", "15m" },
                    { "30m", "30m" },
                    { "45m", "45m" },
                    { "1h", "1H" },
                    { "2h", "2H" },
                    { "3h", "3H" },
                    { "4h", "4H" },
                    { "1d", "1D" },
                    { "1w", "1W" },
                    { "1M", "1M" },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "keepAlive", 15000 },
            } },
        });
    }

    public async virtual Task<object> subscribe(object channel, object symbol, object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object url = this.implodeHostname(getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "public"));
        object request = new Dictionary<string, object>() {};
        object messageHash = null;
        if (isTrue(isEqual(type, "spot")))
        {
            messageHash = add(add(add("spot/", channel), ":"), getValue(market, "id"));
            request = new Dictionary<string, object>() {
                { "op", "subscribe" },
                { "args", new List<object>() {messageHash} },
            };
        } else
        {
            messageHash = add(add(add("futures/", channel), ":"), getValue(market, "id"));
            request = new Dictionary<string, object>() {
                { "action", "subscribe" },
                { "args", new List<object>() {messageHash} },
            };
        }
        return await this.watch(url, messageHash, this.deepExtend(request, parameters), messageHash);
    }

    public async virtual Task<object> subscribeMultiple(object channel, object type, object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        symbols = this.marketSymbols(symbols, type, false, true);
        object url = this.implodeHostname(getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "public"));
        object channelType = ((bool) isTrue((isEqual(type, "spot")))) ? "spot" : "futures";
        object actionType = ((bool) isTrue((isEqual(type, "spot")))) ? "op" : "action";
        object rawSubscriptions = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object market = this.market(getValue(symbols, i));
            object message = add(add(add(add(channelType, "/"), channel), ":"), getValue(market, "id"));
            ((IList<object>)rawSubscriptions).Add(message);
            ((IList<object>)messageHashes).Add(add(add(channel, ":"), getValue(market, "symbol")));
        }
        // as an exclusion, futures "tickers" need one generic request for all symbols
        if (isTrue(isTrue((!isEqual(type, "spot"))) && isTrue((isEqual(channel, "ticker")))))
        {
            rawSubscriptions = new List<object>() {add(add(channelType, "/"), channel)};
        }
        object request = new Dictionary<string, object>() {
            { "args", rawSubscriptions },
        };
        ((IDictionary<string,object>)request)[(string)actionType] = "subscribe";
        return await this.watchMultiple(url, messageHashes, this.deepExtend(request, parameters), rawSubscriptions);
    }

    /**
     * @method
     * @name bitmart#watchBalance
     * @see https://developer-pro.bitmart.com/en/spot/#private-balance-change
     * @see https://developer-pro.bitmart.com/en/futuresv2/#private-assets-channel
     * @description watch balance and get the amount of funds available for trading or funds locked in orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = "spot";
        var typeparametersVariable = this.handleMarketTypeAndParams("watchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        await this.authenticate(type, parameters);
        object request = new Dictionary<string, object>() {};
        if (isTrue(isEqual(type, "spot")))
        {
            request = new Dictionary<string, object>() {
                { "op", "subscribe" },
                { "args", new List<object>() {"spot/user/balance:BALANCE_UPDATE"} },
            };
        } else
        {
            request = new Dictionary<string, object>() {
                { "action", "subscribe" },
                { "args", new List<object>() {"futures/asset:USDT", "futures/asset:BTC", "futures/asset:ETH"} },
            };
        }
        object messageHash = add("balance:", type);
        object url = this.implodeHostname(getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "private"));
        var client = this.client(url);
        this.setBalanceCache(client as WebSocketClient, type, messageHash);
        object fetchBalanceSnapshot = null;
        object awaitBalanceSnapshot = null;
        var fetchBalanceSnapshotparametersVariable = this.handleOptionAndParams(this.options, "watchBalance", "fetchBalanceSnapshot", true);
        fetchBalanceSnapshot = ((IList<object>)fetchBalanceSnapshotparametersVariable)[0];
        parameters = ((IList<object>)fetchBalanceSnapshotparametersVariable)[1];
        var awaitBalanceSnapshotparametersVariable = this.handleOptionAndParams(this.options, "watchBalance", "awaitBalanceSnapshot", false);
        awaitBalanceSnapshot = ((IList<object>)awaitBalanceSnapshotparametersVariable)[0];
        parameters = ((IList<object>)awaitBalanceSnapshotparametersVariable)[1];
        if (isTrue(isTrue(fetchBalanceSnapshot) && isTrue(awaitBalanceSnapshot)))
        {
            await client.future(add(type, ":fetchBalanceSnapshot"));
        }
        return await this.watch(url, messageHash, this.deepExtend(request, parameters), messageHash);
    }

    public virtual void setBalanceCache(WebSocketClient client, object type, object subscribeHash)
    {
        if (isTrue(inOp(((WebSocketClient)client).subscriptions, subscribeHash)))
        {
            return;
        }
        object options = this.safeValue(this.options, "watchBalance");
        object snapshot = this.safeBool(options, "fetchBalanceSnapshot", true);
        if (isTrue(snapshot))
        {
            object messageHash = add(add(type, ":"), "fetchBalanceSnapshot");
            if (!isTrue((inOp(client.futures, messageHash))))
            {
                client.future(messageHash);
                this.spawn(this.loadBalanceSnapshot, new object[] { client, messageHash, type});
            }
        }
        ((IDictionary<string,object>)this.balance)[(string)type] = new Dictionary<string, object>() {};
    }

    public async virtual Task loadBalanceSnapshot(WebSocketClient client, object messageHash, object type)
    {
        object response = await this.fetchBalance(new Dictionary<string, object>() {
            { "type", type },
        });
        ((IDictionary<string,object>)this.balance)[(string)type] = this.extend(response, this.safeValue(this.balance, type, new Dictionary<string, object>() {}));
        // don't remove the future from the .futures cache
        var future = getValue(client.futures, messageHash);
        (future as Future).resolve();
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, type), add("balance:", type)});
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        // spot
        //    {
        //        "data":[
        //           {
        //              "balance_details":[
        //                 {
        //                    "av_bal":"0.206000000000000000000000000000",
        //                    "ccy":"LTC",
        //                    "fz_bal":"0.100000000000000000000000000000"
        //                 }
        //              ],
        //              "event_time":"1701632345415",
        //              "event_type":"TRANSACTION_COMPLETED"
        //           }
        //        ],
        //        "table":"spot/user/balance"
        //    }
        // swap
        //    {
        //        group: 'futures/asset:USDT',
        //        data: {
        //            currency: 'USDT',
        //            available_balance: '37.19688649135',
        //            position_deposit: '0.788687546',
        //            frozen_balance: '0'
        //        }
        //    }
        //
        object channel = this.safeString2(message, "table", "group");
        object data = this.safeValue(message, "data");
        if (isTrue(isEqual(data, null)))
        {
            return;
        }
        object isSpot = (isGreaterThanOrEqual(getIndexOf(channel, "spot"), 0));
        object type = ((bool) isTrue(isSpot)) ? "spot" : "swap";
        ((IDictionary<string,object>)getValue(this.balance, type))["info"] = message;
        if (isTrue(isSpot))
        {
            if (!isTrue(((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                return;
            }
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object timestamp = this.safeInteger(message, "event_time");
                ((IDictionary<string,object>)getValue(this.balance, type))["timestamp"] = timestamp;
                ((IDictionary<string,object>)getValue(this.balance, type))["datetime"] = this.iso8601(timestamp);
                object balanceDetails = this.safeValue(getValue(data, i), "balance_details", new List<object>() {});
                for (object ii = 0; isLessThan(ii, getArrayLength(balanceDetails)); postFixIncrement(ref ii))
                {
                    object rawBalance = getValue(balanceDetails, i);
                    object account = this.account();
                    object currencyId = this.safeString(rawBalance, "ccy");
                    object code = this.safeCurrencyCode(currencyId);
                    ((IDictionary<string,object>)account)["free"] = this.safeString(rawBalance, "av_bal");
                    ((IDictionary<string,object>)account)["used"] = this.safeString(rawBalance, "fz_bal");
                    ((IDictionary<string,object>)getValue(this.balance, type))[(string)code] = account;
                }
            }
        } else
        {
            object currencyId = this.safeString(data, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(data, "available_balance");
            ((IDictionary<string,object>)account)["used"] = this.safeString(data, "frozen_balance");
            ((IDictionary<string,object>)getValue(this.balance, type))[(string)code] = account;
        }
        ((IDictionary<string,object>)this.balance)[(string)type] = this.safeBalance(getValue(this.balance, type));
        object messageHash = add("balance:", type);
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, type), messageHash});
    }

    /**
     * @method
     * @name bitmart#watchTrades
     * @see https://developer-pro.bitmart.com/en/spot/#public-trade-channel
     * @see https://developer-pro.bitmart.com/en/futuresv2/#public-trade-channel
     * @description get the list of most recent trades for a particular symbol
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    /**
     * @method
     * @name bitmart#watchTradesForSymbols
     * @see https://developer-pro.bitmart.com/en/spot/#public-trade-channel
     * @description get the list of most recent trades for a list of symbols
     * @param {string[]} symbols unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketType = null;
        var symbolsmarketTypeparametersVariable = this.getParamsForMultipleSub("watchTradesForSymbols", symbols, limit, parameters);
        symbols = ((IList<object>)symbolsmarketTypeparametersVariable)[0];
        marketType = ((IList<object>)symbolsmarketTypeparametersVariable)[1];
        parameters = ((IList<object>)symbolsmarketTypeparametersVariable)[2];
        object channelName = "trade";
        object trades = await this.subscribeMultiple(channelName, marketType, symbols, parameters);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeDict(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual object getParamsForMultipleSub(object methodName, object symbols, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        symbols = this.marketSymbols(symbols, null, false, true);
        object length = getArrayLength(symbols);
        if (isTrue(isGreaterThan(length, 20)))
        {
            throw new NotSupported ((string)add(add(add(this.id, " "), methodName), "() accepts a maximum of 20 symbols in one request")) ;
        }
        object market = this.market(getValue(symbols, 0));
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams(methodName, market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        return new List<object>() {symbols, marketType, parameters};
    }

    /**
     * @method
     * @name bitmart#watchTicker
     * @see https://developer-pro.bitmart.com/en/spot/#public-ticker-channel
     * @see https://developer-pro.bitmart.com/en/futuresv2/#public-ticker-channel
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbol = this.symbol(symbol);
        object tickers = await this.watchTickers(new List<object>() {symbol}, parameters);
        return getValue(tickers, symbol);
    }

    /**
     * @method
     * @name bitmart#watchTickers
     * @see https://developer-pro.bitmart.com/en/spot/#public-ticker-channel
     * @see https://developer-pro.bitmart.com/en/futuresv2/#public-ticker-channel
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.getMarketFromSymbols(symbols);
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("watchTickers", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object ticker = await this.subscribeMultiple("ticker", marketType, symbols, parameters);
        if (isTrue(this.newUpdates))
        {
            object tickers = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)tickers)[(string)getValue(ticker, "symbol")] = ticker;
            return tickers;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    /**
     * @method
     * @name bitmart#watchBidsAsks
     * @see https://developer-pro.bitmart.com/en/spot/#public-ticker-channel
     * @see https://developer-pro.bitmart.com/en/futuresv2/#public-ticker-channel
     * @description watches best bid & ask for symbols
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchBidsAsks(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object firstMarket = this.getMarketFromSymbols(symbols);
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("watchBidsAsks", firstMarket, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object url = this.implodeHostname(getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), marketType), "public"));
        object channelType = ((bool) isTrue((isEqual(marketType, "spot")))) ? "spot" : "futures";
        object actionType = ((bool) isTrue((isEqual(marketType, "spot")))) ? "op" : "action";
        object rawSubscriptions = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object market = this.market(getValue(symbols, i));
            ((IList<object>)rawSubscriptions).Add(add(add(channelType, "/ticker:"), getValue(market, "id")));
            ((IList<object>)messageHashes).Add(add("bidask:", getValue(symbols, i)));
        }
        if (isTrue(!isEqual(marketType, "spot")))
        {
            rawSubscriptions = new List<object>() {add(channelType, "/ticker")};
        }
        object request = new Dictionary<string, object>() {
            { "args", rawSubscriptions },
        };
        ((IDictionary<string,object>)request)[(string)actionType] = "subscribe";
        object newTickers = await this.watchMultiple(url, messageHashes, request, rawSubscriptions);
        if (isTrue(this.newUpdates))
        {
            object tickers = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)tickers)[(string)getValue(newTickers, "symbol")] = newTickers;
            return tickers;
        }
        return this.filterByArray(this.bidsasks, "symbol", symbols);
    }

    public virtual void handleBidAsk(WebSocketClient client, object message)
    {
        object table = this.safeString(message, "table");
        object isSpot = (!isEqual(table, null));
        object rawTickers = new List<object>() {};
        if (isTrue(isSpot))
        {
            rawTickers = this.safeList(message, "data", new List<object>() {});
        } else
        {
            rawTickers = new List<object> {this.safeValue(message, "data", new Dictionary<string, object>() {})};
        }
        if (!isTrue(getArrayLength(rawTickers)))
        {
            return;
        }
        for (object i = 0; isLessThan(i, getArrayLength(rawTickers)); postFixIncrement(ref i))
        {
            object ticker = this.parseWsBidAsk(getValue(rawTickers, i));
            object symbol = getValue(ticker, "symbol");
            ((IDictionary<string,object>)this.bidsasks)[(string)symbol] = ticker;
            object messageHash = add("bidask:", symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
        }
    }

    public virtual object parseWsBidAsk(object ticker, object market = null)
    {
        object marketId = this.safeString(ticker, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeString(market, "symbol");
        object timestamp = this.safeInteger(ticker, "ms_t");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "ask", this.safeString2(ticker, "ask_px", "ask_price") },
            { "askVolume", this.safeString2(ticker, "ask_sz", "ask_vol") },
            { "bid", this.safeString2(ticker, "bid_px", "bid_price") },
            { "bidVolume", this.safeString2(ticker, "bid_sz", "bid_vol") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name bitmart#watchOrders
     * @description watches information on multiple orders made by the user
     * @see https://developer-pro.bitmart.com/en/spot/#private-order-progress
     * @see https://developer-pro.bitmart.com/en/futuresv2/#private-order-channel
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object messageHash = "orders";
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
            market = this.market(symbol);
            messageHash = add("orders::", symbol);
        }
        object type = "spot";
        var typeparametersVariable = this.handleMarketTypeAndParams("watchOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        await this.authenticate(type, parameters);
        object request = null;
        if (isTrue(isEqual(type, "spot")))
        {
            object argsRequest = "spot/user/order:";
            if (isTrue(!isEqual(symbol, null)))
            {
                argsRequest = add(argsRequest, getValue(market, "id"));
            } else
            {
                argsRequest = "spot/user/orders:ALL_SYMBOLS";
            }
            request = new Dictionary<string, object>() {
                { "op", "subscribe" },
                { "args", new List<object>() {argsRequest} },
            };
        } else
        {
            request = new Dictionary<string, object>() {
                { "action", "subscribe" },
                { "args", new List<object>() {"futures/order"} },
            };
        }
        object url = this.implodeHostname(getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "private"));
        object newOrders = await this.watch(url, messageHash, this.deepExtend(request, parameters), messageHash);
        if (isTrue(this.newUpdates))
        {
            return newOrders;
        }
        return this.filterBySymbolSinceLimit(this.orders, symbol, since, limit, true);
    }

    public virtual void handleOrders(WebSocketClient client, object message)
    {
        //
        // spot
        //    {
        //        "data":[
        //            {
        //                "symbol": "LTC_USDT",
        //                "notional": '',
        //                "side": "buy",
        //                "last_fill_time": "0",
        //                "ms_t": "1646216634000",
        //                "type": "limit",
        //                "filled_notional": "0.000000000000000000000000000000",
        //                "last_fill_price": "0",
        //                "size": "0.500000000000000000000000000000",
        //                "price": "50.000000000000000000000000000000",
        //                "last_fill_count": "0",
        //                "filled_size": "0.000000000000000000000000000000",
        //                "margin_trading": "0",
        //                "state": "8",
        //                "order_id": "24807076628",
        //                "order_type": "0"
        //              }
        //        ],
        //        "table":"spot/user/order"
        //    }
        // swap
        //    {
        //        "group":"futures/order",
        //        "data":[
        //           {
        //              "action":2,
        //              "order":{
        //                 "order_id":"2312045036986775",
        //                 "client_order_id":"",
        //                 "price":"71.61707928",
        //                 "size":"1",
        //                 "symbol":"LTCUSDT",
        //                 "state":1,
        //                 "side":4,
        //                 "type":"market",
        //                 "leverage":"1",
        //                 "open_type":"cross",
        //                 "deal_avg_price":"0",
        //                 "deal_size":"0",
        //                 "create_time":1701625324646,
        //                 "update_time":1701625324640,
        //                 "plan_order_id":"",
        //                 "last_trade":null
        //              }
        //           }
        //        ]
        //    }
        //
        object orders = this.safeValue(message, "data");
        if (isTrue(isEqual(orders, null)))
        {
            return;
        }
        object ordersLength = getArrayLength(orders);
        object newOrders = new List<object>() {};
        object symbols = new Dictionary<string, object>() {};
        if (isTrue(isGreaterThan(ordersLength, 0)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            if (isTrue(isEqual(this.orders, null)))
            {
                this.orders = new ArrayCacheBySymbolById(limit);
            }
            object stored = this.orders;
            for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
            {
                object order = this.parseWsOrder(getValue(orders, i));
                callDynamically(stored, "append", new object[] {order});
                ((IList<object>)newOrders).Add(order);
                object symbol = getValue(order, "symbol");
                ((IDictionary<string,object>)symbols)[(string)symbol] = true;
            }
        }
        object messageHash = "orders";
        object symbolKeys = new List<object>(((IDictionary<string,object>)symbols).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(symbolKeys)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbolKeys, i);
            object symbolSpecificMessageHash = add(add(messageHash, "::"), symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {newOrders, symbolSpecificMessageHash});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newOrders, messageHash});
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        // spot
        //    {
        //        "symbol": "LTC_USDT",
        //        "notional": '',
        //        "side": "buy",
        //        "last_fill_time": "0",
        //        "ms_t": "1646216634000",
        //        "type": "limit",
        //        "filled_notional": "0.000000000000000000000000000000",
        //        "last_fill_price": "0",
        //        "size": "0.500000000000000000000000000000",
        //        "price": "50.000000000000000000000000000000",
        //        "last_fill_count": "0",
        //        "filled_size": "0.000000000000000000000000000000",
        //        "margin_trading": "0",
        //        "state": "8",
        //        "order_id": "24807076628",
        //        "order_type": "0"
        //    }
        // swap
        //    {
        //       "action":2,
        //       "order":{
        //          "order_id":"2312045036986775",
        //          "client_order_id":"",
        //          "price":"71.61707928",
        //          "size":"1",
        //          "symbol":"LTCUSDT",
        //          "state":1,
        //          "side":4,
        //          "type":"market",
        //          "leverage":"1",
        //          "open_type":"cross",
        //          "deal_avg_price":"0",
        //          "deal_size":"0",
        //          "create_time":1701625324646,
        //          "update_time":1701625324640,
        //          "plan_order_id":"",
        //          "last_trade":null
        //       }
        //    }
        //
        object action = this.safeNumber(order, "action");
        object isSpot = (isEqual(action, null));
        if (isTrue(isSpot))
        {
            object marketId = this.safeString(order, "symbol");
            market = this.safeMarket(marketId, market, "_", "spot");
            object id = this.safeString(order, "order_id");
            object clientOrderId = this.safeString(order, "clientOid");
            object price = this.safeString(order, "price");
            object filled = this.safeString(order, "filled_size");
            object amount = this.safeString(order, "size");
            object type = this.safeString(order, "type");
            object rawState = this.safeString(order, "state");
            object status = this.parseOrderStatusByType(getValue(market, "type"), rawState);
            object timestamp = this.safeInteger(order, "ms_t");
            object symbol = getValue(market, "symbol");
            object side = this.safeStringLower(order, "side");
            return this.safeOrder(new Dictionary<string, object>() {
                { "info", order },
                { "symbol", symbol },
                { "id", id },
                { "clientOrderId", clientOrderId },
                { "timestamp", null },
                { "datetime", null },
                { "lastTradeTimestamp", timestamp },
                { "type", type },
                { "timeInForce", null },
                { "postOnly", null },
                { "side", side },
                { "price", price },
                { "stopPrice", null },
                { "triggerPrice", null },
                { "amount", amount },
                { "cost", null },
                { "average", null },
                { "filled", filled },
                { "remaining", null },
                { "status", status },
                { "fee", null },
                { "trades", null },
            }, market);
        } else
        {
            object orderInfo = this.safeValue(order, "order");
            object marketId = this.safeString(orderInfo, "symbol");
            object symbol = this.safeSymbol(marketId, market, "", "swap");
            object orderId = this.safeString(orderInfo, "order_id");
            object timestamp = this.safeInteger(orderInfo, "create_time");
            object updatedTimestamp = this.safeInteger(orderInfo, "update_time");
            object lastTrade = this.safeValue(orderInfo, "last_trade");
            object cachedOrders = this.orders;
            object orders = this.safeValue((cachedOrders as ArrayCacheBySymbolById).hashmap, symbol, new Dictionary<string, object>() {});
            object cachedOrder = this.safeValue(orders, orderId);
            object trades = null;
            if (isTrue(!isEqual(cachedOrder, null)))
            {
                trades = this.safeValue(order, "trades");
            }
            if (isTrue(!isEqual(lastTrade, null)))
            {
                if (isTrue(isEqual(trades, null)))
                {
                    trades = new List<object>() {};
                }
                ((IList<object>)trades).Add(lastTrade);
            }
            return this.safeOrder(new Dictionary<string, object>() {
                { "info", order },
                { "symbol", symbol },
                { "id", orderId },
                { "clientOrderId", this.safeString(orderInfo, "client_order_id") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
                { "lastTradeTimestamp", updatedTimestamp },
                { "type", this.safeString(orderInfo, "type") },
                { "timeInForce", null },
                { "postOnly", null },
                { "side", this.parseWsOrderSide(this.safeString(orderInfo, "side")) },
                { "price", this.safeString(orderInfo, "price") },
                { "stopPrice", null },
                { "triggerPrice", null },
                { "amount", this.safeString(orderInfo, "size") },
                { "cost", null },
                { "average", this.safeString(orderInfo, "deal_avg_price") },
                { "filled", this.safeString(orderInfo, "deal_size") },
                { "remaining", null },
                { "status", this.parseWsOrderStatus(this.safeString(order, "action")) },
                { "fee", null },
                { "trades", trades },
            }, market);
        }
    }

    public virtual object parseWsOrderStatus(object statusId)
    {
        object statuses = new Dictionary<string, object>() {
            { "1", "closed" },
            { "2", "open" },
            { "3", "canceled" },
            { "4", "closed" },
            { "5", "canceled" },
            { "6", "open" },
            { "7", "open" },
            { "8", "closed" },
            { "9", "closed" },
        };
        return this.safeString(statuses, statusId, statusId);
    }

    public virtual object parseWsOrderSide(object sideId)
    {
        object sides = new Dictionary<string, object>() {
            { "1", "buy" },
            { "2", "buy" },
            { "3", "sell" },
            { "4", "sell" },
        };
        return this.safeString(sides, sideId, sideId);
    }

    /**
     * @method
     * @name bitmart#watchPositions
     * @see https://developer-pro.bitmart.com/en/futures/#private-position-channel
     * @description watch all open positions
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {int} [since] the earliest time in ms to fetch positions
     * @param {int} [limit] the maximum number of positions to retrieve
     * @param {object} params extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
     */
    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = "swap";
        await this.authenticate(type, parameters);
        symbols = this.marketSymbols(symbols, "swap", true, true, false);
        object messageHash = "positions";
        if (isTrue(!isEqual(symbols, null)))
        {
            messageHash = add(messageHash, add("::", String.Join(",", ((IList<object>)symbols).ToArray())));
        }
        object subscriptionHash = "futures/position";
        object request = new Dictionary<string, object>() {
            { "action", "subscribe" },
            { "args", new List<object>() {"futures/position"} },
        };
        object url = this.implodeHostname(getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "private"));
        object newPositions = await this.watch(url, messageHash, this.deepExtend(request, parameters), subscriptionHash);
        if (isTrue(this.newUpdates))
        {
            return newPositions;
        }
        return this.filterBySymbolsSinceLimit(this.positions, symbols, since, limit);
    }

    public virtual void handlePositions(WebSocketClient client, object message)
    {
        //
        //    {
        //        "group":"futures/position",
        //        "data":[
        //           {
        //              "symbol":"LTCUSDT",
        //              "hold_volume":"5",
        //              "position_type":2,
        //              "open_type":2,
        //              "frozen_volume":"0",
        //              "close_volume":"0",
        //              "hold_avg_price":"71.582",
        //              "close_avg_price":"0",
        //              "open_avg_price":"71.582",
        //              "liquidate_price":"0",
        //              "create_time":1701623327513,
        //              "update_time":1701627620439
        //           },
        //           {
        //              "symbol":"LTCUSDT",
        //              "hold_volume":"6",
        //              "position_type":1,
        //              "open_type":2,
        //              "frozen_volume":"0",
        //              "close_volume":"0",
        //              "hold_avg_price":"71.681666666666666667",
        //              "close_avg_price":"0",
        //              "open_avg_price":"71.681666666666666667",
        //              "liquidate_price":"0",
        //              "create_time":1701621167225,
        //              "update_time":1701628152614
        //           }
        //        ]
        //    }
        //
        object data = this.safeValue(message, "data", new List<object>() {});
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new ArrayCacheBySymbolBySide();
        }
        object cache = this.positions;
        object newPositions = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object rawPosition = getValue(data, i);
            object position = this.parseWsPosition(rawPosition);
            ((IList<object>)newPositions).Add(position);
            callDynamically(cache, "append", new object[] {position});
        }
        object messageHashes = this.findMessageHashes(client as WebSocketClient, "positions::");
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object positions = this.filterByArray(newPositions, "symbol", symbols, false);
            if (!isTrue(this.isEmpty(positions)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {positions, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newPositions, "positions"});
    }

    public virtual object parseWsPosition(object position, object market = null)
    {
        //
        //    {
        //       "symbol":"LTCUSDT",
        //       "hold_volume":"6",
        //       "position_type":1,
        //       "open_type":2,
        //       "frozen_volume":"0",
        //       "close_volume":"0",
        //       "hold_avg_price":"71.681666666666666667",
        //       "close_avg_price":"0",
        //       "open_avg_price":"71.681666666666666667",
        //       "liquidate_price":"0",
        //       "create_time":1701621167225,
        //       "update_time":1701628152614
        //    }
        //
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market, null, "swap");
        object symbol = getValue(market, "symbol");
        object openTimestamp = this.safeInteger(position, "create_time");
        object timestamp = this.safeInteger(position, "update_time");
        object side = this.safeInteger(position, "position_type");
        object marginModeId = this.safeInteger(position, "open_type");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "timestamp", openTimestamp },
            { "datetime", this.iso8601(openTimestamp) },
            { "lastUpdateTimestamp", timestamp },
            { "hedged", null },
            { "side", ((bool) isTrue((isEqual(side, 1)))) ? "long" : "short" },
            { "contracts", this.safeNumber(position, "hold_volume") },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "entryPrice", this.safeNumber(position, "open_avg_price") },
            { "markPrice", this.safeNumber(position, "hold_avg_price") },
            { "lastPrice", null },
            { "notional", null },
            { "leverage", null },
            { "collateral", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "unrealizedPnl", null },
            { "realizedPnl", null },
            { "liquidationPrice", this.safeNumber(position, "liquidate_price") },
            { "marginMode", ((bool) isTrue((isEqual(marginModeId, 1)))) ? "isolated" : "cross" },
            { "percentage", null },
            { "marginRatio", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    public virtual void handleTrade(WebSocketClient client, object message)
    {
        //
        // spot
        //    {
        //        "table": "spot/trade",
        //        "data": [
        //            {
        //                "price": "52700.50",
        //                "s_t": 1630982050,
        //                "side": "buy",
        //                "size": "0.00112",
        //                "symbol": "BTC_USDT"
        //            },
        //        ]
        //    }
        //
        // swap
        //    {
        //        "group":"futures/trade:BTCUSDT",
        //        "data":[
        //           {
        //              "trade_id":6798697637,
        //              "contract_id":1,
        //              "symbol":"BTCUSDT",
        //              "deal_price":"39735.8",
        //              "deal_vol":"2",
        //              "type":0,
        //              "way":1,
        //              "create_time":1701618503,
        //              "create_time_mill":1701618503517,
        //              "created_at":"2023-12-03T15:48:23.517518538Z"
        //           }
        //        ]
        //    }
        //
        object data = this.safeValue(message, "data");
        if (isTrue(isEqual(data, null)))
        {
            return;
        }
        object symbol = null;
        object length = getArrayLength(data);
        object isSwap = (inOp(message, "group"));
        if (isTrue(isSwap))
        {
            // in swap, chronologically decreasing: 1709536849322, 1709536848954,
            for (object i = 0; isLessThan(i, length); postFixIncrement(ref i))
            {
                object index = subtract(subtract(length, i), 1);
                symbol = this.handleTradeLoop(getValue(data, index));
            }
        } else
        {
            // in spot, chronologically increasing: 1709536771200, 1709536771226,
            for (object i = 0; isLessThan(i, length); postFixIncrement(ref i))
            {
                symbol = this.handleTradeLoop(getValue(data, i));
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.trades, symbol), add("trade:", symbol)});
    }

    public virtual object handleTradeLoop(object entry)
    {
        object trade = this.parseWsTrade(entry);
        object symbol = getValue(trade, "symbol");
        object tradesLimit = this.safeInteger(this.options, "tradesLimit", 1000);
        if (isTrue(isEqual(this.safeValue(this.trades, symbol), null)))
        {
            ((IDictionary<string,object>)this.trades)[(string)symbol] = new ArrayCache(tradesLimit);
        }
        object stored = getValue(this.trades, symbol);
        callDynamically(stored, "append", new object[] {trade});
        return symbol;
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        // spot
        //    {
        //        "price": "52700.50",
        //        "s_t": 1630982050,
        //        "side": "buy",
        //        "size": "0.00112",
        //        "symbol": "BTC_USDT"
        //    }
        // swap
        //    {
        //       "trade_id":6798697637,
        //       "contract_id":1,
        //       "symbol":"BTCUSDT",
        //       "deal_price":"39735.8",
        //       "deal_vol":"2",
        //       "type":0,
        //       "way":1,
        //       "create_time":1701618503,
        //       "create_time_mill":1701618503517,
        //       "created_at":"2023-12-03T15:48:23.517518538Z"
        //    }
        //
        object contractId = this.safeString(trade, "contract_id");
        object marketType = ((bool) isTrue((isEqual(contractId, null)))) ? "spot" : "swap";
        object marketDelimiter = ((bool) isTrue((isEqual(marketType, "spot")))) ? "_" : "";
        object timestamp = this.safeInteger(trade, "create_time_mill", this.safeTimestamp(trade, "s_t"));
        object marketId = this.safeString(trade, "symbol");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString(trade, "trade_id") },
            { "order", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", this.safeSymbol(marketId, market, marketDelimiter, marketType) },
            { "type", null },
            { "side", this.safeString(trade, "side") },
            { "price", this.safeString2(trade, "price", "deal_price") },
            { "amount", this.safeString2(trade, "size", "deal_vol") },
            { "cost", null },
            { "takerOrMaker", null },
            { "fee", null },
        }, market);
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        //    {
        //        "data": [
        //            {
        //                "base_volume_24h": "78615593.81",
        //                "high_24h": "52756.97",
        //                "last_price": "52638.31",
        //                "low_24h": "50991.35",
        //                "open_24h": "51692.03",
        //                "s_t": 1630981727,
        //                "symbol": "BTC_USDT"
        //            }
        //        ],
        //        "table": "spot/ticker"
        //    }
        //    {
        //        "group":"futures/ticker",
        //        "data":{
        //              "symbol":"BTCUSDT",
        //              "volume_24":"117387.58",
        //              "fair_price":"146.24",
        //              "last_price":"146.24",
        //              "range":"147.17",
        //              "ask_price": "147.11",
        //              "ask_vol": "1",
        //              "bid_price": "142.11",
        //              "bid_vol": "1"
        //            }
        //    }
        //
        this.handleBidAsk(client as WebSocketClient, message);
        object table = this.safeString(message, "table");
        object isSpot = (!isEqual(table, null));
        object rawTickers = new List<object>() {};
        if (isTrue(isSpot))
        {
            rawTickers = this.safeList(message, "data", new List<object>() {});
        } else
        {
            rawTickers = new List<object> {this.safeValue(message, "data", new Dictionary<string, object>() {})};
        }
        if (!isTrue(getArrayLength(rawTickers)))
        {
            return;
        }
        for (object i = 0; isLessThan(i, getArrayLength(rawTickers)); postFixIncrement(ref i))
        {
            object ticker = ((bool) isTrue(isSpot)) ? this.parseTicker(getValue(rawTickers, i)) : this.parseWsSwapTicker(getValue(rawTickers, i));
            object symbol = getValue(ticker, "symbol");
            ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
            object messageHash = add("ticker:", symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
        }
    }

    public virtual object parseWsSwapTicker(object ticker, object market = null)
    {
        //
        //    {
        //        "symbol":"BTCUSDT",
        //        "volume_24":"117387.58",
        //        "fair_price":"146.24",
        //        "last_price":"146.24",
        //        "range":"147.17",
        //        "ask_price": "147.11",
        //        "ask_vol": "1",
        //        "bid_price": "142.11",
        //        "bid_vol": "1"
        //    }
        object marketId = this.safeString(ticker, "symbol");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(marketId, market, "", "swap") },
            { "timestamp", null },
            { "datetime", null },
            { "high", null },
            { "low", null },
            { "bid", this.safeString(ticker, "bid_price") },
            { "bidVolume", this.safeString(ticker, "bid_vol") },
            { "ask", this.safeString(ticker, "ask_price") },
            { "askVolume", this.safeString(ticker, "ask_vol") },
            { "vwap", null },
            { "open", null },
            { "close", null },
            { "last", this.safeString(ticker, "last_price") },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", this.safeString(ticker, "fair_price") },
            { "baseVolume", null },
            { "quoteVolume", this.safeString(ticker, "volume_24") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name bitmart#watchOHLCV
     * @see https://developer-pro.bitmart.com/en/spot/#public-kline-channel
     * @see https://developer-pro.bitmart.com/en/futuresv2/#public-klinebin-channel
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbol = this.symbol(symbol);
        object market = this.market(symbol);
        object type = "spot";
        var typeparametersVariable = this.handleMarketTypeAndParams("watchOrderBook", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object timeframes = this.safeValue(this.options, "timeframes", new Dictionary<string, object>() {});
        object interval = this.safeString(timeframes, timeframe);
        object name = null;
        if (isTrue(isEqual(type, "spot")))
        {
            name = add("kline", interval);
        } else
        {
            name = add("klineBin", interval);
        }
        object ohlcv = await this.subscribe(name, symbol, type, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //    {
        //        "data": [
        //            {
        //                "candle": [
        //                    1631056350,
        //                    "46532.83",
        //                    "46555.71",
        //                    "46511.41",
        //                    "46555.71",
        //                    "0.25"
        //                ],
        //                "symbol": "BTC_USDT"
        //            }
        //        ],
        //        "table": "spot/kline1m"
        //    }
        // swap
        //    {
        //        "group":"futures/klineBin1m:BTCUSDT",
        //        "data":{
        //           "symbol":"BTCUSDT",
        //           "items":[
        //              {
        //                 "o":"39635.8",
        //                 "h":"39636",
        //                 "l":"39614.4",
        //                 "c":"39629.7",
        //                 "v":"31852",
        //                 "ts":1701617761
        //              }
        //           ]
        //        }
        //    }
        //
        object channel = this.safeString2(message, "table", "group");
        object isSpot = (isGreaterThanOrEqual(getIndexOf(channel, "spot"), 0));
        object data = this.safeValue(message, "data");
        if (isTrue(isEqual(data, null)))
        {
            return;
        }
        object parts = ((string)channel).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
        object part1 = this.safeString(parts, 1, "");
        object interval = ((string)part1).Replace((string)"kline", (string)"");
        interval = ((string)interval).Replace((string)"Bin", (string)"");
        object intervalParts = ((string)interval).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
        interval = this.safeString(intervalParts, 0);
        // use a reverse lookup in a static map instead
        object timeframes = this.safeValue(this.options, "timeframes", new Dictionary<string, object>() {});
        object timeframe = this.findTimeframe(interval, timeframes);
        object duration = this.parseTimeframe(timeframe);
        object durationInMs = multiply(duration, 1000);
        if (isTrue(isSpot))
        {
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object marketId = this.safeString(getValue(data, i), "symbol");
                object market = this.safeMarket(marketId);
                object symbol = getValue(market, "symbol");
                object rawOHLCV = this.safeValue(getValue(data, i), "candle");
                object parsed = this.parseOHLCV(rawOHLCV, market);
                ((List<object>)parsed)[Convert.ToInt32(0)] = multiply(this.parseToInt(divide(getValue(parsed, 0), durationInMs)), durationInMs);
                ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
                object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
                if (isTrue(isEqual(stored, null)))
                {
                    object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
                    stored = new ArrayCacheByTimestamp(limit);
                    ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
                }
                callDynamically(stored, "append", new object[] {parsed});
                object messageHash = add(add(channel, ":"), marketId);
                callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
            }
        } else
        {
            object marketId = this.safeString(data, "symbol");
            object market = this.safeMarket(marketId, null, null, "swap");
            object symbol = getValue(market, "symbol");
            object items = this.safeValue(data, "items", new List<object>() {});
            ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
            object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
            if (isTrue(isEqual(stored, null)))
            {
                object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
                stored = new ArrayCacheByTimestamp(limit);
                ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
            }
            for (object i = 0; isLessThan(i, getArrayLength(items)); postFixIncrement(ref i))
            {
                object candle = getValue(items, i);
                object parsed = this.parseOHLCV(candle, market);
                callDynamically(stored, "append", new object[] {parsed});
            }
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, channel});
        }
    }

    /**
     * @method
     * @name bitmart#watchOrderBook
     * @see https://developer-pro.bitmart.com/en/spot/#public-depth-all-channel
     * @see https://developer-pro.bitmart.com/en/spot/#public-depth-increase-channel
     * @see https://developer-pro.bitmart.com/en/futuresv2/#public-depth-channel
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object options = this.safeValue(this.options, "watchOrderBook", new Dictionary<string, object>() {});
        object depth = this.safeString(options, "depth", "depth/increase100");
        symbol = this.symbol(symbol);
        object market = this.market(symbol);
        object type = "spot";
        var typeparametersVariable = this.handleMarketTypeAndParams("watchOrderBook", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(isTrue(isEqual(type, "swap")) && isTrue(isEqual(depth, "depth/increase100"))))
        {
            depth = "depth50";
        }
        object orderbook = await this.subscribe(depth, symbol, type, parameters);
        return (orderbook as IOrderBook).limit();
    }

    public override void handleDelta(object bookside, object delta)
    {
        object price = this.safeFloat(delta, 0);
        object amount = this.safeFloat(delta, 1);
        (bookside as IOrderBookSide).store(price, amount);
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    public virtual object handleOrderBookMessage(WebSocketClient client, object message, object orderbook)
    {
        //
        //     {
        //         "asks": [
        //             [ '46828.38', "0.21847" ],
        //             [ '46830.68', "0.08232" ],
        //             [ '46832.08', "0.09285" ],
        //             [ '46837.82', "0.02028" ],
        //             [ '46839.43', "0.15068" ]
        //         ],
        //         "bids": [
        //             [ '46820.78', "0.00444" ],
        //             [ '46814.33', "0.00234" ],
        //             [ '46813.50', "0.05021" ],
        //             [ '46808.14', "0.00217" ],
        //             [ '46808.04', "0.00013" ]
        //         ],
        //         "ms_t": 1631044962431,
        //         "symbol": "BTC_USDT"
        //     }
        //
        object asks = this.safeList(message, "asks", new List<object>() {});
        object bids = this.safeList(message, "bids", new List<object>() {});
        this.handleDeltas(getValue(orderbook, "asks"), asks);
        this.handleDeltas(getValue(orderbook, "bids"), bids);
        object timestamp = this.safeInteger(message, "ms_t");
        object marketId = this.safeString(message, "symbol");
        object symbol = this.safeSymbol(marketId);
        ((IDictionary<string,object>)orderbook)["symbol"] = symbol;
        ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
        ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        return orderbook;
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        // spot depth-all
        //
        //    {
        //        "data": [
        //            {
        //                "asks": [
        //                    [ '46828.38', "0.21847" ],
        //                    [ '46830.68', "0.08232" ],
        //                    ...
        //                ],
        //                "bids": [
        //                    [ '46820.78', "0.00444" ],
        //                    [ '46814.33', "0.00234" ],
        //                    ...
        //                ],
        //                "ms_t": 1631044962431,
        //                "symbol": "BTC_USDT"
        //            }
        //        ],
        //        "table": "spot/depth5"
        //    }
        //
        // spot increse depth snapshot
        //
        //    {
        //        "data":[
        //           {
        //               "asks":[
        //                   [ "43652.52", "0.02039" ],
        //                   ...
        //                ],
        //                "bids":[
        //                   [ "43652.51", "0.00500" ],
        //                   ...
        //                ],
        //                "ms_t":1703376836487,
        //                "symbol":"BTC_USDT",
        //                "type":"snapshot", // or update
        //                "version":2141731
        //           }
        //        ],
        //        "table":"spot/depth/increase100"
        //    }
        //
        // swap
        //
        //    {
        //        "group":"futures/depth50:BTCUSDT",
        //        "data":{
        //           "symbol":"BTCUSDT",
        //           "way":1,
        //           "depths":[
        //              {
        //                 "price":"39509.8",
        //                 "vol":"2379"
        //              },
        //              {
        //                 "price":"39509.6",
        //                 "vol":"6815"
        //              },
        //              ...
        //           ],
        //           "ms_t":1701566021194
        //        }
        //    }
        //
        object isSpot = (inOp(message, "table"));
        object datas = new List<object>() {};
        if (isTrue(isSpot))
        {
            datas = this.safeList(message, "data", datas);
        } else
        {
            object orderBookEntry = this.safeDict(message, "data");
            if (isTrue(!isEqual(orderBookEntry, null)))
            {
                ((IList<object>)datas).Add(orderBookEntry);
            }
        }
        object length = getArrayLength(datas);
        if (isTrue(isLessThanOrEqual(length, 0)))
        {
            return;
        }
        object channelName = this.safeString2(message, "table", "group");
        // find limit subscribed to
        object limitsToCheck = new List<object>() {"100", "50", "20", "10", "5"};
        object limit = 0;
        for (object i = 0; isLessThan(i, getArrayLength(limitsToCheck)); postFixIncrement(ref i))
        {
            object limitString = getValue(limitsToCheck, i);
            if (isTrue(isGreaterThanOrEqual(getIndexOf(channelName, limitString), 0)))
            {
                limit = this.parseToInt(limitString);
                break;
            }
        }
        if (isTrue(isSpot))
        {
            object channel = ((string)channelName).Replace((string)"spot/", (string)"");
            for (object i = 0; isLessThan(i, getArrayLength(datas)); postFixIncrement(ref i))
            {
                object update = getValue(datas, i);
                object marketId = this.safeString(update, "symbol");
                object symbol = this.safeSymbol(marketId);
                if (!isTrue((inOp(this.orderbooks, symbol))))
                {
                    object ob = this.orderBook(new Dictionary<string, object>() {}, limit);
                    ((IDictionary<string,object>)ob)["symbol"] = symbol;
                    ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = ob;
                }
                object orderbook = getValue(this.orderbooks, symbol);
                object type = this.safeString(update, "type");
                if (isTrue(isTrue((isEqual(type, "snapshot"))) || isTrue((!isTrue((isGreaterThanOrEqual(getIndexOf(channelName, "increase"), 0)))))))
                {
                    (orderbook as IOrderBook).reset(new Dictionary<string, object>() {});
                }
                this.handleOrderBookMessage(client as WebSocketClient, update, orderbook);
                object timestamp = this.safeInteger(update, "ms_t");
                if (isTrue(isEqual(getValue(orderbook, "timestamp"), null)))
                {
                    ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
                    ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
                }
                object messageHash = add(add(channelName, ":"), marketId);
                callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
                // resolve ForSymbols
                object messageHashForMulti = add(add(channel, ":"), symbol);
                callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHashForMulti});
            }
        } else
        {
            object tableParts = ((string)channelName).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
            object channel = ((string)getValue(tableParts, 0)).Replace((string)"futures/", (string)"");
            object data = getValue(datas, 0); // contract markets always contain only one member
            object depths = getValue(data, "depths");
            object marketId = this.safeString(data, "symbol");
            object symbol = this.safeSymbol(marketId);
            if (!isTrue((inOp(this.orderbooks, symbol))))
            {
                object ob = this.orderBook(new Dictionary<string, object>() {}, limit);
                ((IDictionary<string,object>)ob)["symbol"] = symbol;
                ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = ob;
            }
            object orderbook = getValue(this.orderbooks, symbol);
            object way = this.safeInteger(data, "way");
            object side = ((bool) isTrue((isEqual(way, 1)))) ? "bids" : "asks";
            if (isTrue(isEqual(way, 1)))
            {
                ((IDictionary<string,object>)orderbook)[(string)side] = new Bids(new List<object>() {}, limit);
            } else
            {
                ((IDictionary<string,object>)orderbook)[(string)side] = new Asks(new List<object>() {}, limit);
            }
            for (object i = 0; isLessThan(i, getArrayLength(depths)); postFixIncrement(ref i))
            {
                object depth = getValue(depths, i);
                object price = this.safeNumber(depth, "price");
                object amount = this.safeNumber(depth, "vol");
                object orderbookSide = this.safeValue(orderbook, side);
                (orderbookSide as IOrderBookSide).store(price, amount);
            }
            object bidsLength = getArrayLength(getValue(orderbook, "bids"));
            object asksLength = getArrayLength(getValue(orderbook, "asks"));
            if (isTrue(isTrue((isEqual(bidsLength, 0))) || isTrue((isEqual(asksLength, 0)))))
            {
                return;
            }
            object timestamp = this.safeInteger(data, "ms_t");
            ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
            object messageHash = channelName;
            callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
            // resolve ForSymbols
            object messageHashForMulti = add(add(channel, ":"), symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHashForMulti});
        }
    }

    /**
     * @method
     * @name bitmart#watchOrderBookForSymbols
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://developer-pro.bitmart.com/en/spot/#public-depth-increase-channel
     * @param {string[]} symbols unified array of symbols
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.depth] the type of order book to subscribe to, default is 'depth/increase100', also accepts 'depth5' or 'depth20' or depth50
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
        var symbolstypeparametersVariable = this.getParamsForMultipleSub("watchOrderBookForSymbols", symbols, limit, parameters);
        symbols = ((IList<object>)symbolstypeparametersVariable)[0];
        type = ((IList<object>)symbolstypeparametersVariable)[1];
        parameters = ((IList<object>)symbolstypeparametersVariable)[2];
        object channel = null;
        var channelparametersVariable = this.handleOptionAndParams(parameters, "watchOrderBookForSymbols", "depth", "depth/increase100");
        channel = ((IList<object>)channelparametersVariable)[0];
        parameters = ((IList<object>)channelparametersVariable)[1];
        if (isTrue(isTrue(isEqual(type, "swap")) && isTrue(isEqual(channel, "depth/increase100"))))
        {
            channel = "depth50";
        }
        object orderbook = await this.subscribeMultiple(channel, type, symbols, parameters);
        return (orderbook as IOrderBook).limit();
    }

    public async virtual Task<object> authenticate(object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object url = this.implodeHostname(getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "private"));
        object messageHash = "authenticated";
        var client = this.client(url);
        var future = client.future(messageHash);
        object authenticated = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(authenticated, null)))
        {
            object timestamp = ((object)this.milliseconds()).ToString();
            object memo = this.uid;
            object path = "bitmart.WebSocket";
            object auth = add(add(add(add(timestamp, "#"), memo), "#"), path);
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
            object request = null;
            if (isTrue(isEqual(type, "spot")))
            {
                request = new Dictionary<string, object>() {
                    { "op", "login" },
                    { "args", new List<object>() {this.apiKey, timestamp, signature} },
                };
            } else
            {
                request = new Dictionary<string, object>() {
                    { "action", "access" },
                    { "args", new List<object>() {this.apiKey, timestamp, signature, "web"} },
                };
            }
            object message = this.extend(request, parameters);
            this.watch(url, messageHash, message, messageHash);
        }
        return await (future as Exchange.Future);
    }

    public virtual object handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //    {"event":"subscribe","channel":"spot/depth:BTC-USDT"}
        //
        return message;
    }

    public virtual void handleAuthenticate(WebSocketClient client, object message)
    {
        //
        // spot
        //    { event: "login" }
        // swap
        //    { action: 'access', success: true }
        //
        object messageHash = "authenticated";
        var future = this.safeValue((client as WebSocketClient).futures, messageHash);
        (future as Future).resolve(true);
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //    { event: "error", message: "Invalid sign", errorCode: 30013 }
        //    {"event":"error","message":"Unrecognized request: {\"event\":\"subscribe\",\"channel\":\"spot/depth:BTC-USDT\"}","errorCode":30039}
        //    {
        //        action: '',
        //        group: 'futures/trade:BTCUSDT',
        //        success: false,
        //        request: { action: '', args: [ 'futures/trade:BTCUSDT' ] },
        //        error: 'Invalid action [] for group [futures/trade:BTCUSDT]'
        //    }
        //
        object errorCode = this.safeString(message, "errorCode");
        object error = this.safeString(message, "error");
        try
        {
            if (isTrue(isTrue(!isEqual(errorCode, null)) || isTrue(!isEqual(error, null))))
            {
                object feedback = add(add(this.id, " "), this.json(message));
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
                object messageString = this.safeValue(message, "message", error);
                this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), messageString, feedback);
                object action = this.safeString(message, "action");
                if (isTrue(isEqual(action, "access")))
                {
                    throw new AuthenticationError ((string)feedback) ;
                }
                throw new ExchangeError ((string)feedback) ;
            }
            return false;
        } catch(Exception e)
        {
            if (isTrue((e is AuthenticationError)))
            {
                object messageHash = "authenticated";
                ((WebSocketClient)client).reject(e, messageHash);
                if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
                {
                    ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
                }
            }
            ((WebSocketClient)client).reject(e);
            return true;
        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            return;
        }
        //
        //     {"event":"error","message":"Unrecognized request: {\"event\":\"subscribe\",\"channel\":\"spot/depth:BTC-USDT\"}","errorCode":30039}
        //
        // subscribe events on spot:
        //
        //     {"event":"subscribe", "topic":"spot/kline1m:BTC_USDT" }
        //
        // subscribe on contracts:
        //
        //     {"action":"subscribe", "group":"futures/klineBin1m:BTCUSDT", "success":true, "request":{"action":"subscribe", "args":[ "futures/klineBin1m:BTCUSDT" ] } }
        //
        // regular updates - spot
        //
        //     {
        //         "table": "spot/depth",
        //         "action": "partial",
        //         "data": [
        //             {
        //                 "instrument_id":   "BTC-USDT",
        //                 "asks": [
        //                     ["5301.8", "0.03763319", "1"],
        //                     ["5302.4", "0.00305", "2"],
        //                 ],
        //                 "bids": [
        //                     ["5301.7", "0.58911427", "6"],
        //                     ["5301.6", "0.01222922", "4"],
        //                 ],
        //                 "timestamp": "2020-03-16T03:25:00.440Z",
        //                 "checksum": -2088736623
        //             }
        //         ]
        //     }
        //
        // regular updates - contracts
        //
        //     {
        //         group: "futures/klineBin1m:BTCUSDT",
        //         data: {
        //           symbol: "BTCUSDT",
        //           items: [ { o: "67944.7", "h": .... } ],
        //         },
        //       }
        //
        //     { data: '', table: "spot/user/order" }
        //
        // the only realiable way (for both spot & swap) is to check 'data' key
        object isDataUpdate = (inOp(message, "data"));
        if (!isTrue(isDataUpdate))
        {
            object eventVar = this.safeString2(message, "event", "action");
            if (isTrue(!isEqual(eventVar, null)))
            {
                object methods = new Dictionary<string, object>() {
                    { "login", this.handleAuthenticate },
                    { "access", this.handleAuthenticate },
                    { "subscribe", this.handleSubscriptionStatus },
                };
                object method = this.safeValue(methods, eventVar);
                if (isTrue(!isEqual(method, null)))
                {
                    DynamicInvoker.InvokeMethod(method, new object[] { client, message});
                }
            }
        } else
        {
            object channel = this.safeString2(message, "table", "group");
            object methods = new Dictionary<string, object>() {
                { "depth", this.handleOrderBook },
                { "ticker", this.handleTicker },
                { "trade", this.handleTrade },
                { "kline", this.handleOHLCV },
                { "order", this.handleOrders },
                { "position", this.handlePositions },
                { "balance", this.handleBalance },
                { "asset", this.handleBalance },
            };
            object keys = new List<object>(((IDictionary<string,object>)methods).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
            {
                object key = getValue(keys, i);
                if (isTrue(isGreaterThanOrEqual(getIndexOf(channel, key), 0)))
                {
                    object method = this.safeValue(methods, key);
                    DynamicInvoker.InvokeMethod(method, new object[] { client, message});
                }
            }
        }
    }
}
