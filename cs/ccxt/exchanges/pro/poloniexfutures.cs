namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class poloniexfutures { public poloniexfutures(object args = null) : base(args) { } }
public partial class poloniexfutures : ccxt.poloniexfutures
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "cancelAllOrdersWs", false },
                { "cancelOrdersWs", false },
                { "cancelOrderWs", false },
                { "createOrderWs", false },
                { "editOrderWs", false },
                { "fetchBalanceWs", false },
                { "fetchOpenOrdersWs", false },
                { "fetchOrderWs", false },
                { "fetchTradesWs", false },
                { "watchOHLCV", false },
                { "watchOrderBook", true },
                { "watchTicker", true },
                { "watchTickers", false },
                { "watchTrades", true },
                { "watchBalance", true },
                { "watchOrders", true },
                { "watchMyTrades", false },
                { "watchPosition", null },
                { "watchPositions", false },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", "wss://futures-apiws.poloniex.com/endpoint" },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "tradesLimit", 1000 },
                { "ordersLimit", 1000 },
                { "watchTicker", new Dictionary<string, object>() {
                    { "method", "/contractMarket/ticker" },
                } },
                { "watchOrders", new Dictionary<string, object>() {
                    { "method", "/contractMarket/tradeOrders" },
                } },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "method", "/contractMarket/level2" },
                    { "snapshotDelay", 5 },
                    { "snapshotMaxRetries", 3 },
                } },
                { "streamLimit", 5 },
                { "streamBySubscriptionsHash", new Dictionary<string, object>() {} },
                { "streamIndex", -1 },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "keepAlive", 30000 },
                { "maxPingPongMisses", 2 },
            } },
        });
    }

    public async virtual Task<object> negotiate(object privateChannel, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object connectId = ((bool) isTrue(privateChannel)) ? "private" : "public";
        object urls = this.safeValue(this.options, "urls", new Dictionary<string, object>() {});
        if (isTrue(inOp(urls, connectId)))
        {
            // return urls[connectId];
            object storedFuture = getValue(urls, connectId);
            return await (storedFuture as Exchange.Future);
        }
        // we store an awaitable to the url
        // so that multiple calls don't asynchronously
        // fetch different urls and overwrite each other
        ((IDictionary<string,object>)urls)[(string)connectId] = this.spawn(this.negotiateHelper, new object[] { privateChannel, parameters});
        ((IDictionary<string,object>)this.options)["urls"] = urls;
        var future = getValue(urls, connectId);
        return await (future as Exchange.Future);
    }

    public async virtual Task<object> negotiateHelper(object privateChannel, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = null;
        object connectId = ((bool) isTrue(privateChannel)) ? "private" : "public";
        try
        {
            if (isTrue(privateChannel))
            {
                response = await this.privatePostBulletPrivate(parameters);
            } else
            {
                response = await this.publicPostBulletPublic(parameters);
            }
            object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
            object instanceServers = this.safeValue(data, "instanceServers", new List<object>() {});
            object firstInstanceServer = this.safeValue(instanceServers, 0);
            object pingInterval = this.safeInteger(firstInstanceServer, "pingInterval");
            object endpoint = this.safeString(firstInstanceServer, "endpoint");
            object token = this.safeString(data, "token");
            object result = add(add(endpoint, "?"), this.urlencode(new Dictionary<string, object>() {
    { "token", token },
    { "privateChannel", privateChannel },
    { "connectId", connectId },
}));
            var client = this.client(result);
            client.keepAlive = pingInterval;
            return result;
        } catch(Exception e)
        {
            var future = this.safeValue(getValue(this.options, "urls"), connectId);
            ((Future)future).reject(e);

        }
        return null;
    }

    public virtual object requestId()
    {
        object requestId = this.sum(this.safeInteger(this.options, "requestId", 0), 1);
        ((IDictionary<string,object>)this.options)["requestId"] = requestId;
        return requestId;
    }

    public async virtual Task<object> subscribe(object name, object isPrivate, object symbol = null, object subscription = null, object parameters = null)
    {
        /**
        * @ignore
        * @method
        * @description Connects to a websocket channel
        * @param {string} name name of the channel and suscriptionHash
        * @param {bool} isPrivate true for the authenticated url, false for the public url
        * @param {string} symbol is required for all public channels, not required for private channels (except position)
        * @param {object} subscription subscription parameters
        * @param {object} [params] extra parameters specific to the poloniex api
        * @returns {object} data from the websocket stream
        */
        parameters ??= new Dictionary<string, object>();
        object url = await this.negotiate(isPrivate);
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            object marketId = getValue(market, "id");
            name = add(name, add(":", marketId));
        }
        object messageHash = name;
        object tunnelId = await this.stream(url, messageHash);
        object requestId = this.requestId();
        object subscribe = new Dictionary<string, object>() {
            { "id", requestId },
            { "type", "subscribe" },
            { "topic", name },
            { "privateChannel", isPrivate },
            { "response", true },
            { "tunnelId", tunnelId },
        };
        object subscriptionRequest = new Dictionary<string, object>() {
            { "id", requestId },
        };
        if (isTrue(isEqual(subscription, null)))
        {
            subscription = subscriptionRequest;
        } else
        {
            subscription = this.extend(subscriptionRequest, subscription);
        }
        object request = this.extend(subscribe, parameters);
        return await this.watch(url, messageHash, request, name, subscriptionRequest);
    }

    public override void onClose(WebSocketClient client, object error)
    {
        ((IDictionary<string,object>)this.options)["streamBySubscriptionsHash"] = new Dictionary<string, object>() {};
        base.onClose(client as WebSocketClient, error);
    }

    public async virtual Task<object> stream(object url, object subscriptionHash)
    {
        object streamBySubscriptionsHash = this.safeValue(this.options, "streamBySubscriptionsHash", new Dictionary<string, object>() {});
        object stream = this.safeString(streamBySubscriptionsHash, subscriptionHash);
        if (isTrue(isEqual(stream, null)))
        {
            object streamIndex = this.safeInteger(this.options, "streamIndex", -1);
            object streamLimit = this.safeValue(this.options, "streamLimit");
            streamIndex = add(streamIndex, 1);
            object normalizedIndex = mod(streamIndex, streamLimit);
            ((IDictionary<string,object>)this.options)["streamIndex"] = streamIndex;
            object streamIndexString = this.numberToString(normalizedIndex);
            stream = add("stream-", streamIndexString);
            ((IDictionary<string,object>)getValue(this.options, "streamBySubscriptionsHash"))[(string)subscriptionHash] = stream;
            object messageHash = add("tunnel:", stream);
            object request = new Dictionary<string, object>() {
                { "id", messageHash },
                { "type", "openTunnel" },
                { "newTunnelId", stream },
                { "response", true },
            };
            object subscription = new Dictionary<string, object>() {
                { "id", messageHash },
                { "method", this.handleNewStream },
            };
            await this.watch(url, messageHash, request, messageHash, subscription);
        }
        return stream;
    }

    public virtual void handleOrderBookSubscription(WebSocketClient client, object message, object subscription)
    {
        object symbol = this.safeString(subscription, "symbol");
        object limit = this.safeInteger(subscription, "limit");
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
    }

    public virtual object handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //     {
        //         "id": "1578090438322",
        //         "type": "ack"
        //     }
        //
        object id = this.safeString(message, "id");
        object subscriptionsById = this.indexBy(((WebSocketClient)client).subscriptions, "id");
        object subscription = this.safeValue(subscriptionsById, id, new Dictionary<string, object>() {});
        object method = this.safeValue(subscription, "method");
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message, subscription});
        }
        return message;
    }

    public virtual void handleNewStream(WebSocketClient client, object message, object subscription)
    {
        //
        //    {
        //        "id": "1545910840805",
        //        "type": "ack"
        //    }
        //
        object messageHash = this.safeString(message, "id");
        callDynamically(client as WebSocketClient, "resolve", new object[] {message, messageHash});
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name poloniexfutures#watchTicker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://futures-docs.poloniex.com/#get-real-time-symbol-ticker
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbol = this.symbol(symbol);
        object name = "/contractMarket/ticker";
        return await this.subscribe(name, false, symbol, null, parameters);
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name poloniexfutures#watchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://futures-docs.poloniex.com/#full-matching-engine-data-level-3
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object options = this.safeValue(this.options, "watchTrades");
        object name = this.safeString(options, "method", "/contractMarket/execution"); // can also be /contractMarket/snapshot
        var nameparametersVariable = this.handleOptionAndParams(parameters, "method", "name", name);
        name = ((IList<object>)nameparametersVariable)[0];
        parameters = ((IList<object>)nameparametersVariable)[1];
        symbol = this.symbol(symbol);
        object trades = await this.subscribe(name, false, symbol, null, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name poloniexfutures#watchOrderBook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://futures-docs.poloniex.com/#level-2-market-data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] not used by poloniexfutures watchOrderBook
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.method] the method to use. Defaults to /contractMarket/level2 can also be /contractMarket/level3v2 to receive the raw stream of orders
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object options = this.safeValue(this.options, "watchOrderBook");
        object name = this.safeString(options, "method", "/contractMarket/level2"); // can also be /contractMarket/level2, /contractMarket/level2Depth5:{symbol}, /contractMarket/level2Depth50:{symbol}
        var nameparametersVariable = this.handleOptionAndParams(parameters, "method", "name", name);
        name = ((IList<object>)nameparametersVariable)[0];
        parameters = ((IList<object>)nameparametersVariable)[1];
        if (isTrue(isTrue(isEqual(name, "/contractMarket/level2")) && isTrue(!isEqual(limit, null))))
        {
            if (isTrue(isTrue(!isEqual(limit, 5)) && isTrue(!isEqual(limit, 50))))
            {
                throw new BadRequest ((string)add(this.id, " watchOrderBook limit argument must be none, 5 or 50 if using method /contractMarket/level2")) ;
            }
            name = add(name, add("Depth", this.numberToString(limit)));
        }
        object subscription = new Dictionary<string, object>() {
            { "symbol", symbol },
            { "limit", limit },
            { "method", this.handleOrderBookSubscription },
        };
        object orderbook = await this.subscribe(name, false, symbol, subscription, parameters);
        return (orderbook as IOrderBook).limit();
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name poloniexfutures#watchOrders
        * @description watches information on multiple orders made by the user
        * @see https://futures-docs.poloniex.com/#private-messages
        * @param {string} symbol filter by unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.method] the method to use will default to /contractMarket/tradeOrders. Set to /contractMarket/advancedOrders to watch stop orders
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object options = this.safeValue(this.options, "watchOrders");
        object name = this.safeString(options, "method", "/contractMarket/tradeOrders");
        object orders = await this.subscribe(name, true, null, null, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        orders = this.filterBySymbolSinceLimit(orders, symbol, since, limit);
        object length = getArrayLength(orders);
        if (isTrue(isEqual(length, 0)))
        {
            return await this.watchOrders(symbol, since, limit, parameters);
        }
        return orders;
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @name poloniexfutures#watchBalance
        * @description watch balance and get the amount of funds available for trading or funds locked in orders
        * @see https://futures-docs.poloniex.com/#account-balance-events
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "/contractAccount/wallet";
        return await this.subscribe(name, true, null, null, parameters);
    }

    public virtual object handleTrade(WebSocketClient client, object message)
    {
        //
        //    {
        //        "data": {
        //            "makerUserId": "1410336",
        //            "symbol": "BTCUSDTPERP",
        //            "sequence": 267913,
        //            "side": "buy",
        //            "size": 2,
        //            "price": 28409.5,
        //            "takerOrderId": "6426f9f15782c8000776995f",
        //            "makerOrderId": "6426f9f141406b0008df976e",
        //            "takerUserId": "1410880",
        //            "tradeId": "6426f9f1de029f0001e334dd",
        //            "ts": 1680275953739092500,
        //        },
        //        "subject": "match",
        //        "topic": "/contractMarket/execution:BTCUSDTPERP",
        //        "type": "message",
        //    }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "symbol");
        if (isTrue(!isEqual(marketId, null)))
        {
            object trade = this.parseWsTrade(data);
            object symbol = getValue(trade, "symbol");
            object messageHash = add("/contractMarket/execution:", marketId);
            object stored = this.safeValue(this.trades, symbol);
            if (isTrue(isEqual(stored, null)))
            {
                object tradesLimit = this.safeInteger(this.options, "tradesLimit", 1000);
                stored = new ArrayCache(tradesLimit);
                ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
            }
            callDynamically(stored, "append", new object[] {trade});
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        }
        return message;
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        // handleTrade
        //
        //    {
        //        "makerUserId": "1410880",
        //        "symbol": "BTCUSDTPERP",
        //        "sequence": 731390,
        //        "side": "sell",
        //        "size": 2,
        //        "price": 29372.4,
        //        "takerOrderId": "644ef0fdd64748000759218a",
        //        "makerOrderId": "644ef0fd25f4a50007f12fc5",
        //        "takerUserId": "1410880",
        //        "tradeId": "644ef0fdde029f0001eec346",
        //        "ts": 1682895101923194000
        //    }
        //
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeIntegerProduct(trade, "ts", 0.000001);
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString(trade, "tradeId") },
            { "symbol", this.safeString(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "order", this.safeString2(trade, "takerOrderId", "makerOrderId") },
            { "type", null },
            { "side", this.safeString(trade, "side") },
            { "takerOrMaker", null },
            { "price", this.safeString(trade, "price") },
            { "amount", this.safeString2(trade, "matchSize", "size") },
            { "cost", null },
            { "fee", null },
        }, market);
    }

    public override object parseWsOrderTrade(object trade, object market = null)
    {
        //
        //    {
        //        "symbol": "BTC_USDT",
        //        "type": "LIMIT",
        //        "quantity": "1",
        //        "orderId": "32471407854219264",
        //        "tradeFee": "0",
        //        "clientOrderId": "",
        //        "accountType": "SPOT",
        //        "feeCurrency": "",
        //        "eventType": "place",
        //        "source": "API",
        //        "side": "BUY",
        //        "filledQuantity": "0",
        //        "filledAmount": "0",
        //        "matchRole": "MAKER",
        //        "state": "NEW",
        //        "tradeTime": 0,
        //        "tradeAmount": "0",
        //        "orderAmount": "0",
        //        "createTime": 1648708186922,
        //        "price": "47112.1",
        //        "tradeQty": "0",
        //        "tradePrice": "0",
        //        "tradeId": "0",
        //        "ts": 1648708187469
        //    }
        //
        object timestamp = this.safeInteger(trade, "tradeTime");
        object marketId = this.safeString(trade, "symbol");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString(trade, "tradeId") },
            { "symbol", this.safeSymbol(marketId, market) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "order", this.safeString(trade, "orderId") },
            { "type", this.safeStringLower(trade, "type") },
            { "side", this.safeString(trade, "side") },
            { "takerOrMaker", this.safeStringLower(trade, "matchRole") },
            { "price", this.safeString(trade, "price") },
            { "amount", this.safeString(trade, "tradeAmount") },
            { "cost", null },
            { "fee", new Dictionary<string, object>() {
                { "rate", null },
                { "cost", this.safeString(trade, "tradeFee") },
                { "currency", this.safeString(trade, "feeCurrency") },
            } },
        }, market);
    }

    public virtual object handleOrder(WebSocketClient client, object message)
    {
        //
        //    {
        //        "data": {
        //          "symbol": "ADAUSDTPERP",
        //          "orderType": "limit",
        //          "side": "buy",
        //          "canceledSize": "1",
        //          "orderId": "642b4d4c0494cd0007c76813",
        //          "type": "canceled",
        //          "orderTime": "1680559436101909048",
        //          "size": "1",
        //          "filledSize": "0",
        //          "marginType": 1,
        //          "price": "0.25",
        //          "remainSize": "0",
        //          "clientOid": "112cbbf1-95a3-4917-957c-d3a87d81f853",
        //          "status": "done",
        //          "ts": 1680559677560686600
        //        },
        //        "subject": "orderChange",
        //        "topic": "/contractMarket/tradeOrders",
        //        "channelType": "private",
        //        "type": "message",
        //        "userId": "1139790"
        //    }
        // stop order
        //    {
        //        "data": {
        //            "orderType": "stop",
        //            "symbol": "BTCUSDTPERP",
        //            "side": "buy",
        //            "stopPriceType": "TP",
        //            "orderId": "64514fe1850d2100074378f6",
        //            "type": "open",
        //            "createdAt": 1683050465847,
        //            "stopPrice": "29000",
        //            "size": 2,
        //            "stop": "up",
        //            "marginType": 0,
        //            "orderPrice": "28552.9",
        //            "ts": 1683050465847597300
        //        },
        //        "subject": "stopOrder",
        //        "topic": "/contractMarket/advancedOrders",
        //        "channelType": "private",
        //        "id": "64514fe1850d2100074378fa",
        //        "type": "message",
        //        "userId": "1160396"
        //    }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object orders = this.orders;
        if (isTrue(isEqual(orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit");
            orders = new ArrayCacheBySymbolById(limit);
            this.orders = orders;
        }
        object messageHash = "/contractMarket/tradeOrders";
        object parsed = this.parseWsOrder(data);
        callDynamically(orders, "append", new object[] {parsed});
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
        return message;
    }

    public virtual object parseOrderStatus(object status, object type)
    {
        /**
         * @ignore
         * @method
         * @param {string} status "match", "open", "done"
         * @param {string} type "open", "match", "filled", "canceled", "update"
         * @returns {string}
         */
        object types = new Dictionary<string, object>() {
            { "canceled", "canceled" },
            { "cancel", "canceled" },
            { "filled", "closed" },
        };
        object parsedStatus = this.safeString(types, type);
        if (isTrue(isEqual(parsedStatus, null)))
        {
            object statuses = new Dictionary<string, object>() {
                { "open", "open" },
                { "match", "open" },
                { "done", "closed" },
            };
            parsedStatus = this.safeString(statuses, status, status);
        }
        return parsedStatus;
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        //    {
        //        "symbol": "ADAUSDTPERP",
        //        "orderType": "limit",
        //        "side": "buy",
        //        "canceledSize": "1",
        //        "orderId": "642b4d4c0494cd0007c76813",
        //        "type": "canceled",
        //        "orderTime": "1680559436101909048",
        //        "size": "1",
        //        "filledSize": "0",
        //        "marginType": 1,
        //        "price": "0.25",
        //        "remainSize": "0",
        //        "clientOid": "112cbbf1-95a3-4917-957c-d3a87d81f853",
        //        "status": "done",
        //        "ts": 1680559677560686600
        //    }
        // stop
        //    {
        //        "orderType": "stop",
        //        "symbol": "BTCUSDTPERP",
        //        "side": "buy",
        //        "stopPriceType": "TP",
        //        "orderId": "64514fe1850d2100074378f6",
        //        "type": "open",
        //        "createdAt": 1683050465847,
        //        "stopPrice": "29000",
        //        "size": 2,
        //        "stop": "up",
        //        "marginType": 0,
        //        "orderPrice": "28552.9",
        //        "ts": 1683050465847597300
        //    }
        //
        object id = this.safeString(order, "orderId");
        object clientOrderId = this.safeString(order, "clientOid");
        object marketId = this.safeString(order, "symbol");
        object timestamp = this.safeIntegerProduct2(order, "orderTime", "ts", 0.000001);
        object status = this.safeString(order, "status");
        object messageType = this.safeString(order, "type");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "symbol", this.safeSymbol(marketId, market) },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "type", this.safeString(order, "orderType") },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", this.safeString(order, "side") },
            { "price", this.safeString2(order, "price", "orderPrice") },
            { "stopPrice", this.safeString(order, "stopPrice") },
            { "triggerPrice", null },
            { "amount", this.safeString(order, "size") },
            { "cost", null },
            { "average", null },
            { "filled", this.safeString(order, "filledSize") },
            { "remaining", this.safeString(order, "remainSize") },
            { "status", this.parseOrderStatus(status, messageType) },
            { "fee", null },
            { "trades", null },
        });
    }

    public virtual object handleTicker(WebSocketClient client, object message)
    {
        //
        //    {
        //        "subject": "ticker",
        //        "topic": "/contractMarket/ticker:BTCUSDTPERP",
        //        "data": {
        //            "symbol": "BTCUSDTPERP",                   // Market of the symbol
        //            "sequence": 45,                            // Sequence number which is used to judge the continuity of the pushed messages
        //            "side": "sell",                            // Transaction side of the last traded taker order
        //            "price": 3600.00,                          // Filled price
        //            "size": 16,                                // Filled quantity
        //            "tradeId": "5c9dcf4170744d6f5a3d32fb",     // Order ID
        //            "bestBidSize": 795,                        // Best bid size
        //            "bestBidPrice": 3200.00,                   // Best bid
        //            "bestAskPrice": 3600.00,                   // Best ask size
        //            "bestAskSize": 284,                        // Best ask
        //            "ts": 1553846081210004941                  // Filled time - nanosecond
        //        },
        //        "type": "message",
        //    }
        //
        //    {
        //        "topic": "/contractMarket/snapshot:BTCUSDTPERP",
        //        "subject": "snapshot.24h",
        //        "data": {
        //            "volume": 30449670,            //24h Volume
        //            "turnover": 845169919063,      //24h Turnover
        //            "lastPrice": 3551,           //Last price
        //            "priceChgPct": 0.0043,         //24h Change
        //            "ts": 1547697294838004923      //Snapshot time (nanosecond)
        //        }
        //    }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object messageHash = this.safeString(message, "topic");
        object symbol = this.getSymbolFromTopic(messageHash);
        if (isTrue(!isEqual(symbol, null)))
        {
            object ticker = this.parseTicker(data);
            ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
            callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
        }
        return message;
    }

    public virtual void handleL3OrderBook(WebSocketClient client, object message)
    {
        //
        //    {
        //        "data": {
        //            "symbol": "BTCUSDTPERP",
        //            "sequence": 1679593048010,
        //            "orderId": "6426fec8586b9500089d64d8",
        //            "clientOid": "14e6ee8e-8757-462c-84db-ed12c2b62f55",
        //            "ts": 1680277192127513900
        //        },
        //        "subject": "received",
        //        "topic": "/contractMarket/level3v2:BTCUSDTPERP",
        //        "type": "message"
        //    }
        //
        //    {
        //        "data": {
        //            "symbol": "BTCUSDTPERP",
        //            "sequence": 1679593047982,
        //            "side": "sell",
        //            "orderTime": "1680277191900131371",
        //            "size": "1",
        //            "orderId": "6426fec7d32b6e000790268b",
        //            "price": "28376.4",
        //            "ts": 1680277191939042300
        //        },
        //        "subject": "open",
        //        "topic": "/contractMarket/level3v2:BTCUSDTPERP",
        //        "type": "message"
        //    }
        //
        //    {
        //        "data": {
        //            "symbol": "BTCUSDTPERP",
        //            "reason": "canceled",   // or "filled"
        //            "sequence": 1679593047983,
        //            "orderId": "6426fec74026fa0008e7046f",
        //            "ts": 1680277191949842000
        //        },
        //        "subject": "done",
        //        "topic": "/contractMarket/level3v2:BTCUSDTPERP",
        //        "type": "message"
        //    }
        //
        object messageHash = this.safeString(message, "topic");
        object subject = this.safeString(message, "subject");
        if (isTrue(isEqual(subject, "received")))
        {
            return;
        }
        // At the time of writting this, there is no implementation to easily convert each order into the orderbook so raw messages are returned
        callDynamically(client as WebSocketClient, "resolve", new object[] {message, messageHash});
    }

    public virtual void handleLevel2(WebSocketClient client, object message)
    {
        //    {
        //        "subject": "level2",
        //        "topic": "/contractMarket/level2:BTCUSDTPERP",
        //        "type": "message",
        //        "data": {
        //            "sequence": 18,                   // Sequence number which is used to judge the continuity of pushed messages
        //            "change": "5000.0,sell,83"        // Price, side, quantity
        //            "timestamp": 1551770400000
        //        }
        //    }
        object topic = this.safeString(message, "topic");
        object isSnapshot = isGreaterThanOrEqual(getIndexOf(topic, "Depth"), 0);
        if (isTrue(isSnapshot))
        {
            this.handeL2Snapshot(client as WebSocketClient, message);
            return;
        }
        this.handleL2OrderBook(client as WebSocketClient, message);
    }

    public virtual void handleL2OrderBook(WebSocketClient client, object message)
    {
        //
        //    {
        //        "id": 1545910660740,
        //        "type": "subscribe",
        //        "topic": "/contractMarket/level2:BTCUSDTPERP",
        //        "response": true
        //    }
        //
        //    {
        //        "subject": "level2",
        //        "topic": "/contractMarket/level2:BTCUSDTPERP",
        //        "type": "message",
        //        "data": {
        //            "sequence": 18,                   // Sequence number which is used to judge the continuity of pushed messages
        //            "change": "5000.0,sell,83"        // Price, side, quantity
        //            "timestamp": 1551770400000
        //        }
        //    }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object messageHash = this.safeString(message, "topic", "");
        object symbol = this.getSymbolFromTopic(messageHash);
        object orderBook = this.safeValue(this.orderbooks, symbol);
        if (isTrue(isEqual(orderBook, null)))
        {
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {});
            orderBook = getValue(this.orderbooks, symbol);
            ((IDictionary<string,object>)orderBook)["symbol"] = symbol;
        }
        object nonce = this.safeInteger(orderBook, "nonce");
        if (isTrue(isEqual(nonce, null)))
        {
            object cacheLength = getArrayLength((orderBook as ccxt.pro.OrderBook).cache);
            object snapshotDelay = this.handleOption("watchOrderBook", "snapshotDelay", 5);
            if (isTrue(isEqual(cacheLength, snapshotDelay)))
            {
                object limit = 0;
                this.spawn(this.loadOrderBook, new object[] { client, messageHash, symbol, limit, new Dictionary<string, object>() {}});
            }
            ((IList<object>)(orderBook as ccxt.pro.OrderBook).cache).Add(data);
            return;
        }
        try
        {
            this.handleDelta(orderBook, data);
            callDynamically(client as WebSocketClient, "resolve", new object[] {orderBook, messageHash});
        } catch(Exception e)
        {

            ((WebSocketClient)client).reject(e, messageHash);
        }
    }

    public virtual void handeL2Snapshot(WebSocketClient client, object message)
    {
        //
        //    {
        //        "type": "message",
        //        "topic": "/contractMarket/level2Depth5:BTCUSDTPERP",
        //        "subject": "level2",
        //        "data": {
        //            "asks": [
        //                ["9993", "3"],
        //                ["9992", "3"],
        //                ["9991", "47"],
        //                ["9990", "32"],
        //                ["9989", "8"]
        //            ],
        //            "bids": [
        //                ["9988", "56"],
        //                ["9987", "15"],
        //                ["9986", "100"],
        //                ["9985", "10"],
        //                ["9984", "10"]
        //            ],
        //            "timestamp": 1682993050531,
        //        }
        //    }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object messageHash = this.safeString(message, "topic", "");
        object symbol = this.getSymbolFromTopic(messageHash);
        object timestamp = this.safeInteger(data, "timestamp");
        object snapshot = this.parseOrderBook(data, symbol, timestamp, "bids", "asks");
        object orderbook = this.orderBook(snapshot);
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public virtual object getSymbolFromTopic(object topic)
    {
        object splitTopic = ((string)topic).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(splitTopic, 1);
        return this.safeSymbol(marketId);
    }

    public override object getCacheIndex(object orderbook, object cache)
    {
        object firstDelta = this.safeValue(cache, 0);
        object nonce = this.safeInteger(orderbook, "nonce");
        object firstDeltaSequence = this.safeInteger(firstDelta, "sequence");
        if (isTrue(isGreaterThan(firstDeltaSequence, add(nonce, 1))))
        {
            return -1;
        }
        for (object i = 0; isLessThan(i, getArrayLength(cache)); postFixIncrement(ref i))
        {
            object delta = getValue(cache, i);
            object sequence = this.safeInteger(delta, "sequence");
            if (isTrue(isEqual(nonce, subtract(sequence, 1))))
            {
                return i;
            }
        }
        return getArrayLength(cache);
    }

    public override void handleDelta(object orderbook, object delta)
    {
        //
        //    {
        //      sequence: 123677914,
        //      lastSequence: 123677913,
        //      change: '80.36,buy,4924',
        //      changes: [ '80.19,buy,0',"80.15,buy,10794" ],
        //      timestamp: 1715643483528
        //    },
        //
        object sequence = this.safeInteger(delta, "sequence");
        object lastSequence = this.safeInteger(delta, "lastSequence");
        object nonce = this.safeInteger(orderbook, "nonce");
        if (isTrue(isGreaterThan(nonce, sequence)))
        {
            return;
        }
        if (isTrue(!isEqual(nonce, lastSequence)))
        {
            throw new InvalidNonce ((string)add(this.id, " watchOrderBook received an out-of-order nonce")) ;
        }
        object changes = this.safeList(delta, "changes");
        for (object i = 0; isLessThan(i, getArrayLength(changes)); postFixIncrement(ref i))
        {
            object change = getValue(changes, i);
            object splitChange = ((string)change).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object price = this.safeNumber(splitChange, 0);
            object side = this.safeString(splitChange, 1);
            object size = this.safeNumber(splitChange, 2);
            object orderBookSide = ((bool) isTrue((isEqual(side, "buy")))) ? getValue(orderbook, "bids") : getValue(orderbook, "asks");
            (orderBookSide as IOrderBookSide).store(price, size);
        }
        object timestamp = this.safeInteger(delta, "timestamp");
        ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
        ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        ((IDictionary<string,object>)orderbook)["nonce"] = sequence;
    }

    public virtual object handleBalance(WebSocketClient client, object message)
    {
        //
        //    {
        //        "data": {
        //          "currency": "USDT",
        //          "availableBalance": "4.0000000000",
        //          "timestamp": "1680557568670"
        //        },
        //        "subject": "availableBalance.change",
        //        "topic": "/contractAccount/wallet",
        //        "channelType": "private",
        //        "id": "642b4600cae86800074b5ab7",
        //        "type": "message",
        //        "userId": "1139790"
        //    }
        //
        //    {
        //        "data": {
        //          "currency": "USDT",
        //          "orderMargin": "0.0000000000",
        //          "timestamp": "1680558743307"
        //        },
        //        "subject": "orderMargin.change",
        //        "topic": "/contractAccount/wallet",
        //        "channelType": "private",
        //        "id": "642b4a97b58e360007c3a237",
        //        "type": "message",
        //        "userId": "1139790"
        //    }
        //
        object data = this.safeValue(message, "data", new List<object>() {});
        object messageHash = "/contractAccount/wallet";
        object currencyId = this.safeString(data, "currency");
        object currency = this.currency(currencyId);
        object code = getValue(currency, "code");
        ((IDictionary<string,object>)this.balance)[(string)code] = this.parseWsBalance(data);
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, code), messageHash});
        return message;
    }

    public virtual object parseWsBalance(object response)
    {
        //
        //    {
        //        "currency": "USDT",
        //        "availableBalance": "4.0000000000",
        //        "timestamp": "1680557568670"
        //    }
        //
        //    {
        //        "currency": "USDT",
        //        "orderMargin": "0.0000000000",
        //        "timestamp": "1680558743307"
        //    }
        //
        object timestamp = this.safeInteger(response, "timestamp");
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
        object currencyId = this.safeString(response, "currency");
        object code = this.safeCurrencyCode(currencyId);
        object newAccount = this.account();
        ((IDictionary<string,object>)newAccount)["free"] = this.safeString(response, "availableBalance");
        ((IDictionary<string,object>)result)[(string)code] = newAccount;
        return this.safeBalance(result);
    }

    public virtual object handleSystemStatus(WebSocketClient client, object message)
    {
        //
        //     {
        //         "id": "1578090234088", // connectId
        //         "type": "welcome",
        //     }
        //
        return message;
    }

    public virtual void handleSubject(WebSocketClient client, object message)
    {
        object subject = this.safeString(message, "subject");
        object methods = new Dictionary<string, object>() {
            { "auth", this.handleAuthenticate },
            { "received", this.handleL3OrderBook },
            { "open", this.handleL3OrderBook },
            { "update", this.handleL3OrderBook },
            { "done", this.handleL3OrderBook },
            { "level2", this.handleLevel2 },
            { "ticker", this.handleTicker },
            { "snapshot.24h", this.handleTicker },
            { "match", this.handleTrade },
            { "orderChange", this.handleOrder },
            { "stopOrder", this.handleOrder },
            { "availableBalance.change", this.handleBalance },
            { "orderMargin.change", this.handleBalance },
        };
        object method = this.safeValue(methods, subject);
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
    }

    public override object ping(WebSocketClient client)
    {
        object id = ((object)this.requestId()).ToString();
        return new Dictionary<string, object>() {
            { "id", id },
            { "type", "ping" },
        };
    }

    public virtual object handlePong(WebSocketClient client, object message)
    {
        client.lastPong = this.milliseconds();
        return message;
    }

    public virtual void handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //    {
        //        "code": 404,
        //        "data": "tunnel stream-0 is not exist",
        //        "id": "3",
        //        "type": "error"
        //    }
        //
        ((WebSocketClient)client).reject(message);
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        object type = this.safeString(message, "type");
        object methods = new Dictionary<string, object>() {
            { "welcome", this.handleSystemStatus },
            { "ack", this.handleSubscriptionStatus },
            { "message", this.handleSubject },
            { "pong", this.handlePong },
            { "error", this.handleErrorMessage },
        };
        object method = this.safeValue(methods, type);
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
    }

    public virtual object handleAuthenticate(WebSocketClient client, object message)
    {
        //
        //    {
        //        "success": true,
        //        "ret_msg": '',
        //        "op": "auth",
        //        "conn_id": "ce3dpomvha7dha97tvp0-2xh"
        //    }
        //
        object data = this.safeValue(message, "data");
        object success = this.safeValue(data, "success");
        object messageHash = "authenticated";
        if (isTrue(success))
        {
            callDynamically(client as WebSocketClient, "resolve", new object[] {message, messageHash});
        } else
        {
            var error = new AuthenticationError(add(add(this.id, " "), this.json(message)));
            ((WebSocketClient)client).reject(error, messageHash);
            if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
            {

            }
        }
        return message;
    }
}
