namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class hitbtc { public hitbtc(object args = null) : base(args) { } }
public partial class hitbtc : ccxt.hitbtc
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchTrades", true },
                { "watchOrderBook", true },
                { "watchBalance", true },
                { "watchOrders", true },
                { "watchOHLCV", true },
                { "watchMyTrades", false },
                { "createOrderWs", true },
                { "cancelOrderWs", true },
                { "fetchOpenOrdersWs", true },
                { "cancelAllOrdersWs", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://api.hitbtc.com/api/3/ws/public" },
                        { "private", "wss://api.hitbtc.com/api/3/ws/trading" },
                    } },
                } },
                { "test", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://api.demo.hitbtc.com/api/3/ws/public" },
                        { "private", "wss://api.demo.hitbtc.com/api/3/ws/trading" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "tradesLimit", 1000 },
                { "watchTicker", new Dictionary<string, object>() {
                    { "method", "ticker/{speed}" },
                } },
                { "watchTickers", new Dictionary<string, object>() {
                    { "method", "ticker/{speed}" },
                } },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "method", "orderbook/full" },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "M1" },
                { "3m", "M3" },
                { "5m", "M5" },
                { "15m", "M15" },
                { "30m", "M30" },
                { "1h", "H1" },
                { "4h", "H4" },
                { "1d", "D1" },
                { "1w", "D7" },
                { "1M", "1M" },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "keepAlive", 4000 },
            } },
        });
    }

    public async virtual Task<object> authenticate()
    {
        /**
         * @ignore
         * @method
         * @description authenticates the user to access private web socket channels
         * @see https://api.hitbtc.com/#socket-authentication
         * @returns {object} response from exchange
         */
        this.checkRequiredCredentials();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        object messageHash = "authenticated";
        var client = this.client(url);
        var future = client.future(messageHash);
        object authenticated = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(authenticated, null)))
        {
            object timestamp = this.milliseconds();
            object signature = this.hmac(this.encode(this.numberToString(timestamp)), this.encode(this.secret), sha256, "hex");
            object request = new Dictionary<string, object>() {
                { "method", "login" },
                { "params", new Dictionary<string, object>() {
                    { "type", "HS256" },
                    { "api_key", this.apiKey },
                    { "timestamp", timestamp },
                    { "signature", signature },
                } },
            };
            this.watch(url, messageHash, request, messageHash);
        }
        return await (future as Exchange.Future);
    }

    public async virtual Task<object> subscribePublic(object name, object messageHashPrefix, object symbols = null, object parameters = null)
    {
        /**
        * @ignore
        * @method
        * @param {string} name websocket endpoint name
        * @param {string[]} [symbols] unified CCXT symbol(s)
        * @param {object} [params] extra parameters specific to the hitbtc api
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "public");
        object messageHash = messageHashPrefix;
        if (isTrue(!isEqual(symbols, null)))
        {
            messageHash = add(add(messageHash, "::"), String.Join(",", ((IList<object>)symbols).ToArray()));
        }
        object subscribe = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "id", this.nonce() },
            { "ch", name },
        };
        object request = this.extend(subscribe, parameters);
        return await this.watch(url, messageHash, request, messageHash);
    }

    public async virtual Task<object> subscribePrivate(object name, object symbol = null, object parameters = null)
    {
        /**
        * @ignore
        * @method
        * @param {string} name websocket endpoint name
        * @param {string} [symbol] unified CCXT symbol
        * @param {object} [params] extra parameters specific to the hitbtc api
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        object splitName = ((string)name).Split(new [] {((string)"_subscribe")}, StringSplitOptions.None).ToList<object>();
        object messageHash = this.safeString(splitName, 0);
        if (isTrue(!isEqual(symbol, null)))
        {
            messageHash = add(add(messageHash, "::"), symbol);
        }
        object subscribe = new Dictionary<string, object>() {
            { "method", name },
            { "params", parameters },
            { "id", this.nonce() },
        };
        return await this.watch(url, messageHash, subscribe, messageHash);
    }

    public async virtual Task<object> tradeRequest(object name, object parameters = null)
    {
        /**
        * @ignore
        * @method
        * @param {string} name websocket endpoint name
        * @param {string} [symbol] unified CCXT symbol
        * @param {object} [params] extra parameters specific to the hitbtc api
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        object messageHash = ((object)this.nonce()).ToString();
        object subscribe = new Dictionary<string, object>() {
            { "method", name },
            { "params", parameters },
            { "id", messageHash },
        };
        return await this.watch(url, messageHash, subscribe, messageHash);
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc#watchOrderBook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://api.hitbtc.com/#subscribe-to-full-order-book
        * @see https://api.hitbtc.com/#subscribe-to-partial-order-book
        * @see https://api.hitbtc.com/#subscribe-to-partial-order-book-in-batches
        * @see https://api.hitbtc.com/#subscribe-to-top-of-book
        * @see https://api.hitbtc.com/#subscribe-to-top-of-book-in-batches
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.method] 'orderbook/full', 'orderbook/{depth}/{speed}', 'orderbook/{depth}/{speed}/batch', 'orderbook/top/{speed}', or 'orderbook/top/{speed}/batch'
        * @param {int} [params.depth] 5 , 10, or 20 (default)
        * @param {int} [params.speed] 100 (default), 500, or 1000
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        object options = this.safeValue(this.options, "watchOrderBook");
        object defaultMethod = this.safeString(options, "method", "orderbook/full");
        object name = this.safeString2(parameters, "method", "defaultMethod", defaultMethod);
        object depth = this.safeString(parameters, "depth", "20");
        object speed = this.safeString(parameters, "depth", "100");
        if (isTrue(isEqual(name, "orderbook/{depth}/{speed}")))
        {
            name = add(add(add(add("orderbook/D", depth), "/"), speed), "ms");
        } else if (isTrue(isEqual(name, "orderbook/{depth}/{speed}/batch")))
        {
            name = add(add(add(add("orderbook/D", depth), "/"), speed), "ms/batch");
        } else if (isTrue(isEqual(name, "orderbook/top/{speed}")))
        {
            name = add(add("orderbook/top/", speed), "ms");
        } else if (isTrue(isEqual(name, "orderbook/top/{speed}/batch")))
        {
            name = add(add("orderbook/top/", speed), "ms/batch");
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "params", new Dictionary<string, object>() {
                { "symbols", new List<object>() {getValue(market, "id")} },
            } },
        };
        object orderbook = await this.subscribePublic(name, "orderbooks", new List<object>() {symbol}, this.deepExtend(request, parameters));
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //    {
        //        "ch": "orderbook/full",                 // Channel
        //        "snapshot": {
        //            "ETHBTC": {
        //                "t": 1626866578796,             // Timestamp in milliseconds
        //                "s": 27617207,                  // Sequence number
        //                "a": [                          // Asks
        //                    ["0.060506", "0"],
        //                    ["0.060549", "12.6431"],
        //                    ["0.060570", "0"],
        //                    ["0.060612", "0"]
        //                ],
        //                "b": [                          // Bids
        //                    ["0.060439", "4.4095"],
        //                    ["0.060414", "0"],
        //                    ["0.060407", "7.3349"],
        //                    ["0.060390", "0"]
        //                ]
        //            }
        //        }
        //    }
        //
        object snapshot = this.safeDict(message, "snapshot");
        object update = this.safeDict(message, "update");
        object data = ((bool) isTrue(snapshot)) ? snapshot : update;
        object type = ((bool) isTrue(snapshot)) ? "snapshot" : "update";
        object marketIds = new List<object>(((IDictionary<string,object>)data).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = getValue(marketIds, i);
            object market = this.safeMarket(marketId);
            object symbol = getValue(market, "symbol");
            object item = getValue(data, marketId);
            object messageHash = add("orderbooks::", symbol);
            if (!isTrue((inOp(this.orderbooks, symbol))))
            {
                object subscription = this.safeDict(((WebSocketClient)client).subscriptions, messageHash, new Dictionary<string, object>() {});
                object limit = this.safeInteger(subscription, "limit");
                ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
            }
            object orderbook = getValue(this.orderbooks, symbol);
            object timestamp = this.safeInteger(item, "t");
            object nonce = this.safeInteger(item, "s");
            if (isTrue(isEqual(type, "snapshot")))
            {
                object parsedSnapshot = this.parseOrderBook(item, symbol, timestamp, "b", "a");
                (orderbook as IOrderBook).reset(parsedSnapshot);
            } else
            {
                object asks = this.safeList(item, "a", new List<object>() {});
                object bids = this.safeList(item, "b", new List<object>() {});
                this.handleDeltas(getValue(orderbook, "asks"), asks);
                this.handleDeltas(getValue(orderbook, "bids"), bids);
            }
            ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
            ((IDictionary<string,object>)orderbook)["nonce"] = nonce;
            ((IDictionary<string,object>)orderbook)["symbol"] = symbol;
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
            callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
        }
    }

    public override void handleDelta(object bookside, object delta)
    {
        object price = this.safeNumber(delta, 0);
        object amount = this.safeNumber(delta, 1);
        (bookside as IOrderBookSide).store(price, amount);
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc#watchTicker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://api.hitbtc.com/#subscribe-to-ticker
        * @see https://api.hitbtc.com/#subscribe-to-ticker-in-batches
        * @see https://api.hitbtc.com/#subscribe-to-mini-ticker
        * @see https://api.hitbtc.com/#subscribe-to-mini-ticker-in-batches
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.method] 'ticker/{speed}' (default), or 'ticker/price/{speed}'
        * @param {string} [params.speed] '1s' (default), or '3s'
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object options = this.safeValue(this.options, "watchTicker");
        object defaultMethod = this.safeString(options, "method", "ticker/{speed}");
        object method = this.safeString2(parameters, "method", "defaultMethod", defaultMethod);
        object speed = this.safeString(parameters, "speed", "1s");
        object name = this.implodeParams(method, new Dictionary<string, object>() {
            { "speed", speed },
        });
        parameters = this.omit(parameters, new List<object>() {"method", "speed"});
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "params", new Dictionary<string, object>() {
                { "symbols", new List<object>() {getValue(market, "id")} },
            } },
        };
        object result = await this.subscribePublic(name, "tickers", new List<object>() {symbol}, this.deepExtend(request, parameters));
        return this.safeValue(result, symbol);
    }

    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc#watchTicker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the exchange API endpoint
        * @param {string} params.method 'ticker/{speed}' (default),'ticker/price/{speed}', 'ticker/{speed}/batch', or 'ticker/{speed}/price/batch''
        * @param {string} params.speed '1s' (default), or '3s'
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object options = this.safeValue(this.options, "watchTicker");
        object defaultMethod = this.safeString(options, "method", "ticker/{speed}");
        object method = this.safeString2(parameters, "method", "defaultMethod", defaultMethod);
        object speed = this.safeString(parameters, "speed", "1s");
        object name = this.implodeParams(method, new Dictionary<string, object>() {
            { "speed", speed },
        });
        parameters = this.omit(parameters, new List<object>() {"method", "speed"});
        object marketIds = new List<object>() {};
        if (isTrue(isEqual(symbols, null)))
        {
            ((IList<object>)marketIds).Add("*");
        } else
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object marketId = this.marketId(getValue(symbols, i));
                ((IList<object>)marketIds).Add(marketId);
            }
        }
        object request = new Dictionary<string, object>() {
            { "params", new Dictionary<string, object>() {
                { "symbols", marketIds },
            } },
        };
        object tickers = await this.subscribePublic(name, "tickers", symbols, this.deepExtend(request, parameters));
        if (isTrue(this.newUpdates))
        {
            return tickers;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    public virtual object handleTicker(WebSocketClient client, object message)
    {
        //
        //    {
        //        "ch": "ticker/1s",
        //        "data": {
        //            "ETHBTC": {
        //                "t": 1614815872000,             // Timestamp in milliseconds
        //                "a": "0.031175",                // Best ask
        //                "A": "0.03329",                 // Best ask quantity
        //                "b": "0.031148",                // Best bid
        //                "B": "0.10565",                 // Best bid quantity
        //                "c": "0.031210",                // Last price
        //                "o": "0.030781",                // Open price
        //                "h": "0.031788",                // High price
        //                "l": "0.030733",                // Low price
        //                "v": "62.587",                  // Base asset volume
        //                "q": "1.951420577",             // Quote asset volume
        //                "p": "0.000429",                // Price change
        //                "P": "1.39",                    // Price change percent
        //                "L": 1182694927                 // Last trade identifier
        //            }
        //        }
        //    }
        //
        //    {
        //        "ch": "ticker/price/1s",
        //        "data": {
        //            "BTCUSDT": {
        //                "t": 1614815872030,
        //                "o": "32636.79",
        //                "c": "32085.51",
        //                "h": "33379.92",
        //                "l": "30683.28",
        //                "v": "11.90667",
        //                "q": "384081.1955629"
        //            }
        //        }
        //    }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object marketIds = new List<object>(((IDictionary<string,object>)data).Keys);
        object newTickers = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = getValue(marketIds, i);
            object market = this.safeMarket(marketId);
            object symbol = getValue(market, "symbol");
            object ticker = this.parseWsTicker(getValue(data, marketId), market);
            ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
            ((IDictionary<string,object>)newTickers)[(string)symbol] = ticker;
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newTickers, "tickers"});
        object messageHashes = this.findMessageHashes(client as WebSocketClient, "tickers::");
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object tickers = this.filterByArray(newTickers, "symbol", symbols);
            object tickersSymbols = new List<object>(((IDictionary<string,object>)tickers).Keys);
            object numTickers = getArrayLength(tickersSymbols);
            if (isTrue(isGreaterThan(numTickers, 0)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {tickers, messageHash});
            }
        }
        return message;
    }

    public virtual object parseWsTicker(object ticker, object market = null)
    {
        //
        //    {
        //        "t": 1614815872000,             // Timestamp in milliseconds
        //        "a": "0.031175",                // Best ask
        //        "A": "0.03329",                 // Best ask quantity
        //        "b": "0.031148",                // Best bid
        //        "B": "0.10565",                 // Best bid quantity
        //        "c": "0.031210",                // Last price
        //        "o": "0.030781",                // Open price
        //        "h": "0.031788",                // High price
        //        "l": "0.030733",                // Low price
        //        "v": "62.587",                  // Base asset volume
        //        "q": "1.951420577",             // Quote asset volume
        //        "p": "0.000429",                // Price change
        //        "P": "1.39",                    // Price change percent
        //        "L": 1182694927                 // Last trade identifier
        //    }
        //
        //    {
        //        "t": 1614815872030,
        //        "o": "32636.79",
        //        "c": "32085.51",
        //        "h": "33379.92",
        //        "l": "30683.28",
        //        "v": "11.90667",
        //        "q": "384081.1955629"
        //    }
        //
        object timestamp = this.safeInteger(ticker, "t");
        object symbol = this.safeSymbol(null, market);
        object last = this.safeString(ticker, "c");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "h") },
            { "low", this.safeString(ticker, "l") },
            { "bid", this.safeString(ticker, "b") },
            { "bidVolume", this.safeString(ticker, "B") },
            { "ask", this.safeString(ticker, "a") },
            { "askVolume", this.safeString(ticker, "A") },
            { "vwap", null },
            { "open", this.safeString(ticker, "o") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "v") },
            { "quoteVolume", this.safeString(ticker, "q") },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc#watchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://api.hitbtc.com/#subscribe-to-trades
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "params", new Dictionary<string, object>() {
                { "symbols", new List<object>() {getValue(market, "id")} },
            } },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object name = "trades";
        object trades = await this.subscribePublic(name, "trades", new List<object>() {symbol}, this.deepExtend(request, parameters));
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp");
    }

    public virtual object handleTrades(WebSocketClient client, object message)
    {
        //
        //    {
        //        "result": {
        //            "ch": "trades",                           // Channel
        //            "subscriptions": ["ETHBTC", "BTCUSDT"]
        //        },
        //        "id": 123
        //    }
        //
        // Notification snapshot
        //
        //    {
        //        "ch": "trades",                               // Channel
        //        "snapshot": {
        //            "BTCUSDT": [{
        //                "t": 1626861109494,                   // Timestamp in milliseconds
        //                "i": 1555634969,                      // Trade identifier
        //                "p": "30881.96",                      // Price
        //                "q": "12.66828",                      // Quantity
        //                "s": "buy"                            // Side
        //            }]
        //        }
        //    }
        //
        // Notification update
        //
        //    {
        //        "ch": "trades",
        //        "update": {
        //            "BTCUSDT": [{
        //                "t": 1626861123552,
        //                "i": 1555634969,
        //                "p": "30877.68",
        //                "q": "0.00006",
        //                "s": "sell"
        //            }]
        //        }
        //    }
        //
        object data = this.safeValue2(message, "snapshot", "update", new Dictionary<string, object>() {});
        object marketIds = new List<object>(((IDictionary<string,object>)data).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = getValue(marketIds, i);
            object market = this.safeMarket(marketId);
            object tradesLimit = this.safeInteger(this.options, "tradesLimit", 1000);
            object symbol = getValue(market, "symbol");
            object stored = this.safeValue(this.trades, symbol);
            if (isTrue(isEqual(stored, null)))
            {
                stored = new ArrayCache(tradesLimit);
                ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
            }
            object trades = this.parseWsTrades(getValue(data, marketId), market);
            for (object j = 0; isLessThan(j, getArrayLength(trades)); postFixIncrement(ref j))
            {
                callDynamically(stored, "append", new object[] {getValue(trades, j)});
            }
            object messageHash = add("trades::", symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        }
        return message;
    }

    public virtual object parseWsTrades(object trades, object market = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        trades = this.toArray(trades);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
        {
            object trade = this.extend(this.parseWsTrade(getValue(trades, i), market), parameters);
            ((IList<object>)result).Add(trade);
        }
        result = this.sortBy2(result, "timestamp", "id");
        object symbol = this.safeString(market, "symbol");
        return this.filterBySymbolSinceLimit(result, symbol, since, limit);
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        //    {
        //        "t": 1626861123552,       // Timestamp in milliseconds
        //        "i": 1555634969,          // Trade identifier
        //        "p": "30877.68",          // Price
        //        "q": "0.00006",           // Quantity
        //        "s": "sell"               // Side
        //    }
        //
        object timestamp = this.safeInteger(trade, "t");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString(trade, "i") },
            { "order", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", this.safeString(market, "symbol") },
            { "type", null },
            { "side", this.safeString(trade, "s") },
            { "takerOrMaker", null },
            { "price", this.safeString(trade, "p") },
            { "amount", this.safeString(trade, "q") },
            { "cost", null },
            { "fee", null },
        }, market);
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc#watchOHLCV
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://api.hitbtc.com/#subscribe-to-candles
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} [timeframe] the length of time each candle represents
        * @param {int} [since] not used by hitbtc watchOHLCV
        * @param {int} [limit] 0 – 1000, default value = 0 (no history returned)
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        object period = this.safeString(this.timeframes, timeframe, timeframe);
        object name = add("candles/", period);
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "params", new Dictionary<string, object>() {
                { "symbols", new List<object>() {getValue(market, "id")} },
            } },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)getValue(request, "params"))["limit"] = limit;
        }
        object ohlcv = await this.subscribePublic(name, "candles", new List<object>() {symbol}, this.deepExtend(request, parameters));
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0);
    }

    public virtual object handleOHLCV(WebSocketClient client, object message)
    {
        //
        //    {
        //        "ch": "candles/M1",                     // Channel
        //        "snapshot": {
        //            "BTCUSDT": [{
        //                "t": 1626860340000,             // Message timestamp
        //                "o": "30881.95",                // Open price
        //                "c": "30890.96",                // Last price
        //                "h": "30900.8",                 // High price
        //                "l": "30861.27",                // Low price
        //                "v": "1.27852",                 // Base asset volume
        //                "q": "39493.9021811"            // Quote asset volume
        //            }
        //            ...
        //            ]
        //        }
        //    }
        //
        //    {
        //        "ch": "candles/M1",
        //        "update": {
        //            "ETHBTC": [{
        //                "t": 1626860880000,
        //                "o": "0.060711",
        //                "c": "0.060749",
        //                "h": "0.060749",
        //                "l": "0.060711",
        //                "v": "12.2800",
        //                "q": "0.7455339675"
        //          }]
        //        }
        //    }
        //
        object data = this.safeValue2(message, "snapshot", "update", new Dictionary<string, object>() {});
        object marketIds = new List<object>(((IDictionary<string,object>)data).Keys);
        object channel = this.safeString(message, "ch");
        object splitChannel = ((string)channel).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
        object period = this.safeString(splitChannel, 1);
        object timeframe = this.findTimeframe(period);
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = getValue(marketIds, i);
            object market = this.safeMarket(marketId);
            object symbol = getValue(market, "symbol");
            ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
            object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
            if (isTrue(isEqual(stored, null)))
            {
                object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
                stored = new ArrayCacheByTimestamp(limit);
                ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
            }
            object ohlcvs = this.parseWsOHLCVs(getValue(data, marketId), market);
            for (object j = 0; isLessThan(j, getArrayLength(ohlcvs)); postFixIncrement(ref j))
            {
                callDynamically(stored, "append", new object[] {getValue(ohlcvs, j)});
            }
            object messageHash = add("candles::", symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        }
        return message;
    }

    public override object parseWsOHLCV(object ohlcv, object market = null)
    {
        //
        //    {
        //        "t": 1626860340000,             // Message timestamp
        //        "o": "30881.95",                // Open price
        //        "c": "30890.96",                // Last price
        //        "h": "30900.8",                 // High price
        //        "l": "30861.27",                // Low price
        //        "v": "1.27852",                 // Base asset volume
        //        "q": "39493.9021811"            // Quote asset volume
        //    }
        //
        return new List<object> {this.safeInteger(ohlcv, "t"), this.safeNumber(ohlcv, "o"), this.safeNumber(ohlcv, "h"), this.safeNumber(ohlcv, "l"), this.safeNumber(ohlcv, "c"), this.safeNumber(ohlcv, "v")};
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc#watchOrders
        * @description watches information on multiple orders made by the user
        * @see https://api.hitbtc.com/#subscribe-to-reports
        * @see https://api.hitbtc.com/#subscribe-to-reports-2
        * @see https://api.hitbtc.com/#subscribe-to-reports-3
        * @param {string} [symbol] unified CCXT market symbol
        * @param {int} [since] timestamp in ms of the earliest order to fetch
        * @param {int} [limit] the maximum amount of orders to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketType = null;
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("watchOrders", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object name = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "spot_subscribe" },
            { "margin", "margin_subscribe" },
            { "swap", "futures_subscribe" },
            { "future", "futures_subscribe" },
        });
        object orders = await this.subscribePrivate(name, symbol, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(orders, since, limit, "timestamp");
    }

    public virtual object handleOrder(WebSocketClient client, object message)
    {
        //
        //    {
        //        "jsonrpc": "2.0",
        //        "method": "spot_order",                            // "margin_order", "future_order"
        //        "params": {
        //            "id": 584244931496,
        //            "client_order_id": "b5acd79c0a854b01b558665bcf379456",
        //            "symbol": "BTCUSDT",
        //            "side": "buy",
        //            "status": "new",
        //            "type": "limit",
        //            "time_in_force": "GTC",
        //            "quantity": "0.01000",
        //            "quantity_cumulative": "0",
        //            "price": "0.01",                              // only updates and snapshots
        //            "post_only": false,
        //            "reduce_only": false,                         // only margin and contract
        //            "display_quantity": "0",                      // only updates and snapshot
        //            "created_at": "2021-07-02T22:52:32.864Z",
        //            "updated_at": "2021-07-02T22:52:32.864Z",
        //            "trade_id": 1361977606,                       // only trades
        //            "trade_quantity": "0.00001",                  // only trades
        //            "trade_price": "49595.04",                    // only trades
        //            "trade_fee": "0.001239876000",                // only trades
        //            "trade_taker": true,                          // only trades, only spot
        //            "trade_position_id": 485308,                  // only trades, only margin
        //            "report_type": "new"                          // "trade", "status" (snapshot)
        //        }
        //    }
        //
        //    {
        //       "jsonrpc": "2.0",
        //       "method": "spot_orders",                            // "margin_orders", "future_orders"
        //       "params": [
        //            {
        //                "id": 584244931496,
        //                "client_order_id": "b5acd79c0a854b01b558665bcf379456",
        //                "symbol": "BTCUSDT",
        //                "side": "buy",
        //                "status": "new",
        //                "type": "limit",
        //                "time_in_force": "GTC",
        //                "quantity": "0.01000",
        //                "quantity_cumulative": "0",
        //                "price": "0.01",                              // only updates and snapshots
        //                "post_only": false,
        //                "reduce_only": false,                         // only margin and contract
        //                "display_quantity": "0",                      // only updates and snapshot
        //                "created_at": "2021-07-02T22:52:32.864Z",
        //                "updated_at": "2021-07-02T22:52:32.864Z",
        //                "trade_id": 1361977606,                       // only trades
        //                "trade_quantity": "0.00001",                  // only trades
        //                "trade_price": "49595.04",                    // only trades
        //                "trade_fee": "0.001239876000",                // only trades
        //                "trade_taker": true,                          // only trades, only spot
        //                "trade_position_id": 485308,                  // only trades, only margin
        //                "report_type": "new"                          // "trade", "status" (snapshot)
        //            }
        //        ]
        //    }
        //
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit");
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object data = this.safeValue(message, "params", new List<object>() {});
        if (isTrue(((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object order = getValue(data, i);
                this.handleOrderHelper(client as WebSocketClient, message, order);
            }
        } else
        {
            this.handleOrderHelper(client as WebSocketClient, message, data);
        }
        return message;
    }

    public virtual void handleOrderHelper(WebSocketClient client, object message, object order)
    {
        object orders = this.orders;
        object marketId = this.safeStringLower2(order, "instrument", "symbol");
        object method = this.safeString(message, "method");
        object splitMethod = ((string)method).Split(new [] {((string)"_order")}, StringSplitOptions.None).ToList<object>();
        object messageHash = this.safeString(splitMethod, 0);
        object symbol = this.safeSymbol(marketId);
        object parsed = this.parseOrder(order);
        callDynamically(orders, "append", new object[] {parsed});
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, add(add(messageHash, "::"), symbol)});
    }

    public override object parseWsOrderTrade(object trade, object market = null)
    {
        //
        //    {
        //        "id": 584244931496,
        //        "client_order_id": "b5acd79c0a854b01b558665bcf379456",
        //        "symbol": "BTCUSDT",
        //        "side": "buy",
        //        "status": "new",
        //        "type": "limit",
        //        "time_in_force": "GTC",
        //        "quantity": "0.01000",
        //        "quantity_cumulative": "0",
        //        "price": "0.01",                              // only updates and snapshots
        //        "post_only": false,
        //        "reduce_only": false,                         // only margin and contract
        //        "display_quantity": "0",                      // only updates and snapshot
        //        "created_at": "2021-07-02T22:52:32.864Z",
        //        "updated_at": "2021-07-02T22:52:32.864Z",
        //        "trade_id": 1361977606,                       // only trades
        //        "trade_quantity": "0.00001",                  // only trades
        //        "trade_price": "49595.04",                    // only trades
        //        "trade_fee": "0.001239876000",                // only trades
        //        "trade_taker": true,                          // only trades, only spot
        //        "trade_position_id": 485308,                  // only trades, only margin
        //        "report_type": "new"                          // "trade", "status" (snapshot)
        //    }
        //
        object timestamp = this.safeInteger(trade, "created_at");
        object marketId = this.safeString(trade, "symbol");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString(trade, "trade_id") },
            { "order", this.safeString(trade, "id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", this.safeMarket(marketId, market) },
            { "type", null },
            { "side", this.safeString(trade, "side") },
            { "takerOrMaker", this.safeString(trade, "trade_taker") },
            { "price", this.safeString(trade, "trade_price") },
            { "amount", this.safeString(trade, "trade_quantity") },
            { "cost", null },
            { "fee", new Dictionary<string, object>() {
                { "cost", this.safeString(trade, "trade_fee") },
                { "currency", null },
                { "rate", null },
            } },
        }, market);
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        //    {
        //        "id": 584244931496,
        //        "client_order_id": "b5acd79c0a854b01b558665bcf379456",
        //        "symbol": "BTCUSDT",
        //        "side": "buy",
        //        "status": "new",
        //        "type": "limit",
        //        "time_in_force": "GTC",
        //        "quantity": "0.01000",
        //        "quantity_cumulative": "0",
        //        "price": "0.01",                              // only updates and snapshots
        //        "post_only": false,
        //        "reduce_only": false,                         // only margin and contract
        //        "display_quantity": "0",                      // only updates and snapshot
        //        "created_at": "2021-07-02T22:52:32.864Z",
        //        "updated_at": "2021-07-02T22:52:32.864Z",
        //        "trade_id": 1361977606,                       // only trades
        //        "trade_quantity": "0.00001",                  // only trades
        //        "trade_price": "49595.04",                    // only trades
        //        "trade_fee": "0.001239876000",                // only trades
        //        "trade_taker": true,                          // only trades, only spot
        //        "trade_position_id": 485308,                  // only trades, only margin
        //        "report_type": "new"                          // "trade", "status" (snapshot)
        //    }
        //
        object timestamp = this.safeString(order, "created_at");
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object tradeId = this.safeString(order, "trade_id");
        object trades = null;
        if (isTrue(!isEqual(tradeId, null)))
        {
            object trade = this.parseWsOrderTrade(order, market);
            trades = new List<object>() {trade};
        }
        object rawStatus = this.safeString(order, "status");
        object report_type = this.safeString(order, "report_type");
        object parsedStatus = null;
        if (isTrue(isEqual(report_type, "canceled")))
        {
            parsedStatus = this.parseOrderStatus(report_type);
        } else
        {
            parsedStatus = this.parseOrderStatus(rawStatus);
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString(order, "id") },
            { "clientOrderId", this.safeString(order, "client_order_id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", getValue(market, "symbol") },
            { "price", this.safeString(order, "price") },
            { "amount", this.safeString(order, "quantity") },
            { "type", this.safeString(order, "type") },
            { "side", this.safeStringUpper(order, "side") },
            { "timeInForce", this.safeString(order, "time_in_force") },
            { "postOnly", this.safeString(order, "post_only") },
            { "reduceOnly", this.safeValue(order, "reduce_only") },
            { "filled", null },
            { "remaining", null },
            { "cost", null },
            { "status", parsedStatus },
            { "average", null },
            { "trades", trades },
            { "fee", null },
        }, market);
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @name hitbtc#watchBalance
        * @description watches balance updates, cannot subscribe to margin account balances
        * @see https://api.hitbtc.com/#subscribe-to-spot-balances
        * @see https://api.hitbtc.com/#subscribe-to-futures-balances
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.type] 'spot', 'swap', or 'future'
        *
        * EXCHANGE SPECIFIC PARAMETERS
        * @param {string} [params.mode] 'updates' or 'batches' (default), 'updates' = messages arrive after balance updates, 'batches' = messages arrive at equal intervals if there were any updates
        * @returns {object[]} a list of [balance structures]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object name = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "spot", "spot_balance_subscribe" },
            { "swap", "futures_balance_subscribe" },
            { "future", "futures_balance_subscribe" },
        });
        object mode = this.safeString(parameters, "mode", "batches");
        parameters = this.omit(parameters, "mode");
        object request = new Dictionary<string, object>() {
            { "mode", mode },
        };
        return await this.subscribePrivate(name, null, this.extend(request, parameters));
    }

    public async override Task<object> createOrderWs(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc#createOrder
        * @description create a trade order
        * @see https://api.hitbtc.com/#create-new-spot-order
        * @see https://api.hitbtc.com/#create-margin-order
        * @see https://api.hitbtc.com/#create-futures-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported for spot-margin, swap supports both, default is 'cross'
        * @param {bool} [params.margin] true for creating a margin order
        * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
        * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
        * @param {string} [params.timeInForce] "GTC", "IOC", "FOK", "Day", "GTD"
        * @returns {object} an [order structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = null;
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("createOrder", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        var requestparametersVariable = this.createOrderRequest(market, marketType, type, side, amount, price, marginMode, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        request = this.extend(request, parameters);
        if (isTrue(isEqual(marketType, "swap")))
        {
            return await this.tradeRequest("futures_new_order", request);
        } else if (isTrue(isTrue((isEqual(marketType, "margin"))) || isTrue((!isEqual(marginMode, null)))))
        {
            return await this.tradeRequest("margin_new_order", request);
        } else
        {
            return await this.tradeRequest("spot_new_order", request);
        }
    }

    public async override Task<object> cancelOrderWs(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc#cancelOrderWs
        * @see https://api.hitbtc.com/#cancel-spot-order-2
        * @see https://api.hitbtc.com/#cancel-futures-order-2
        * @see https://api.hitbtc.com/#cancel-margin-order-2
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported
        * @param {bool} [params.margin] true for canceling a margin order
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {
            { "client_order_id", id },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("cancelOrderWs", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        var marginModequeryVariable = this.handleMarginModeAndParams("cancelOrderWs", parameters);
        var marginMode = ((IList<object>) marginModequeryVariable)[0];
        var query = ((IList<object>) marginModequeryVariable)[1];
        request = this.extend(request, query);
        if (isTrue(isEqual(marketType, "swap")))
        {
            return await this.tradeRequest("futures_cancel_order", request);
        } else if (isTrue(isTrue((isEqual(marketType, "margin"))) || isTrue((!isEqual(marginMode, null)))))
        {
            return await this.tradeRequest("margin_cancel_order", request);
        } else
        {
            return await this.tradeRequest("spot_cancel_order", request);
        }
    }

    public async override Task<object> cancelAllOrdersWs(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc#cancelAllOrdersWs
        * @see https://api.hitbtc.com/#cancel-spot-orders
        * @see https://api.hitbtc.com/#cancel-futures-order-3
        * @description cancel all open orders
        * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported
        * @param {bool} [params.margin] true for canceling margin orders
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("cancelAllOrdersWs", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("cancelAllOrdersWs", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "swap")))
        {
            return await this.tradeRequest("futures_cancel_orders", parameters);
        } else if (isTrue(isTrue((isEqual(marketType, "margin"))) || isTrue((!isEqual(marginMode, null)))))
        {
            throw new NotSupported ((string)add(this.id, " cancelAllOrdersWs is not supported for margin orders")) ;
        } else
        {
            return await this.tradeRequest("spot_cancel_orders", parameters);
        }
    }

    public async override Task<object> fetchOpenOrdersWs(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hitbtc#fetchOpenOrdersWs
        * @see https://api.hitbtc.com/#get-active-futures-orders-2
        * @see https://api.hitbtc.com/#get-margin-orders
        * @see https://api.hitbtc.com/#get-active-spot-orders
        * @description fetch all unfilled currently open orders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported
        * @param {bool} [params.margin] true for fetching open margin orders
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOpenOrdersWs", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOpenOrdersWs", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "swap")))
        {
            return await this.tradeRequest("futures_get_orders", request);
        } else if (isTrue(isTrue((isEqual(marketType, "margin"))) || isTrue((!isEqual(marginMode, null)))))
        {
            return await this.tradeRequest("margin_get_orders", request);
        } else
        {
            return await this.tradeRequest("spot_get_orders", request);
        }
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        //    {
        //        "jsonrpc": "2.0",
        //        "method": "futures_balance",
        //        "params": [
        //            {
        //                "currency": "BCN",
        //                "available": "100.000000000000",
        //                "reserved": "0",
        //                "reserved_margin": "0"
        //            },
        //            ...
        //        ]
        //    }
        //
        object messageHash = this.safeString(message, "method");
        object parameters = this.safeValue(message, "params");
        object balance = this.parseBalance(parameters);
        this.balance = this.deepExtend(this.balance, balance);
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, messageHash});
    }

    public virtual object handleNotification(WebSocketClient client, object message)
    {
        //
        //     { jsonrpc: "2.0", result: true, id: null }
        //
        return message;
    }

    public virtual object handleOrderRequest(WebSocketClient client, object message)
    {
        //
        // createOrderWs, cancelOrderWs
        //
        //    {
        //        "jsonrpc": "2.0",
        //        "result": {
        //            "id": 1130310696965,
        //            "client_order_id": "OPC2oyHSkEBqIpPtniLqeW-597hUL3Yo",
        //            "symbol": "ADAUSDT",
        //            "side": "buy",
        //            "status": "new",
        //            "type": "limit",
        //            "time_in_force": "GTC",
        //            "quantity": "4",
        //            "quantity_cumulative": "0",
        //            "price": "0.3300000",
        //            "post_only": false,
        //            "created_at": "2023-11-17T14:58:15.903Z",
        //            "updated_at": "2023-11-17T14:58:15.903Z",
        //            "original_client_order_id": "d6b645556af740b1bd1683400fd9cbce",       // spot_replace_order only
        //            "report_type": "new"
        //            "margin_mode": "isolated",                                            // margin and future only
        //            "reduce_only": false,                                                 // margin and future only
        //        },
        //        "id": 1700233093414
        //    }
        //
        object messageHash = this.safeString(message, "id");
        object result = this.safeValue(message, "result", new Dictionary<string, object>() {});
        if (isTrue(((result is IList<object>) || (result.GetType().IsGenericType && result.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            object parsedOrders = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
            {
                object parsedOrder = this.parseWsOrder(getValue(result, i));
                ((IList<object>)parsedOrders).Add(parsedOrder);
            }
            callDynamically(client as WebSocketClient, "resolve", new object[] {parsedOrders, messageHash});
        } else
        {
            object parsedOrder = this.parseWsOrder(result);
            callDynamically(client as WebSocketClient, "resolve", new object[] {parsedOrder, messageHash});
        }
        return message;
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        this.handleError(client as WebSocketClient, message);
        object channel = this.safeString2(message, "ch", "method");
        if (isTrue(!isEqual(channel, null)))
        {
            object splitChannel = ((string)channel).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
            channel = this.safeString(splitChannel, 0);
            object methods = new Dictionary<string, object>() {
                { "candles", this.handleOHLCV },
                { "ticker", this.handleTicker },
                { "trades", this.handleTrades },
                { "orderbook", this.handleOrderBook },
                { "spot_order", this.handleOrder },
                { "spot_orders", this.handleOrder },
                { "margin_order", this.handleOrder },
                { "margin_orders", this.handleOrder },
                { "futures_order", this.handleOrder },
                { "futures_orders", this.handleOrder },
                { "spot_balance", this.handleBalance },
                { "futures_balance", this.handleBalance },
            };
            object method = this.safeValue(methods, channel);
            if (isTrue(!isEqual(method, null)))
            {
                DynamicInvoker.InvokeMethod(method, new object[] { client, message});
            }
        } else
        {
            object result = this.safeValue(message, "result");
            object clientOrderId = this.safeString(result, "client_order_id");
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                this.handleOrderRequest(client as WebSocketClient, message);
            }
            if (isTrue(isTrue((isEqual(result, true))) && !isTrue((inOp(message, "id")))))
            {
                this.handleAuthenticate(client as WebSocketClient, message);
            }
            if (isTrue(((result is IList<object>) || (result.GetType().IsGenericType && result.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                // to do improve this, not very reliable right now
                object first = this.safeValue(result, 0, new Dictionary<string, object>() {});
                object arrayLength = getArrayLength(result);
                if (isTrue(isTrue((isEqual(arrayLength, 0))) || isTrue((inOp(first, "client_order_id")))))
                {
                    this.handleOrderRequest(client as WebSocketClient, message);
                }
            }
        }
    }

    public virtual object handleAuthenticate(WebSocketClient client, object message)
    {
        //
        //    {
        //        "jsonrpc": "2.0",
        //        "result": true
        //    }
        //
        object success = this.safeValue(message, "result");
        object messageHash = "authenticated";
        if (isTrue(success))
        {
            var future = this.safeValue((client as WebSocketClient).futures, messageHash);
            (future as Future).resolve(true);
        } else
        {
            var error = new AuthenticationError(add(add(this.id, " "), this.json(message)));
            ((WebSocketClient)client).reject(error, messageHash);
            if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
            {

            }
        }
        return message;
    }

    public virtual object handleError(WebSocketClient client, object message)
    {
        //
        //    {
        //        jsonrpc: '2.0',
        //        error: {
        //          code: 20001,
        //          message: 'Insufficient funds',
        //          description: 'Check that the funds are sufficient, given commissions'
        //        },
        //        id: 1700228604325
        //    }
        //
        object error = this.safeValue(message, "error");
        if (isTrue(!isEqual(error, null)))
        {
            object code = this.safeValue(error, "code");
            object errorMessage = this.safeString(error, "message");
            object description = this.safeString(error, "description");
            object feedback = add(add(this.id, " "), description);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), errorMessage, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
