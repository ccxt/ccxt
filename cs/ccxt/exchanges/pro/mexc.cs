namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class mexc { public mexc(object args = null) : base(args) { } }
public partial class mexc : ccxt.mexc
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "cancelAllOrdersWs", false },
                { "cancelOrdersWs", false },
                { "cancelOrderWs", false },
                { "createOrderWs", false },
                { "editOrderWs", false },
                { "fetchBalanceWs", false },
                { "fetchOpenOrdersWs", false },
                { "fetchOrderWs", false },
                { "fetchTradesWs", false },
                { "watchBalance", true },
                { "watchMyTrades", true },
                { "watchOHLCV", true },
                { "watchOrderBook", true },
                { "watchOrders", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchBidsAsks", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", false },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "spot", "wss://wbs.mexc.com/ws" },
                        { "swap", "wss://contract.mexc.com/edge" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "listenKeyRefreshRate", 1200000 },
                { "timeframes", new Dictionary<string, object>() {
                    { "1m", "Min1" },
                    { "5m", "Min5" },
                    { "15m", "Min15" },
                    { "30m", "Min30" },
                    { "1h", "Min60" },
                    { "4h", "Hour4" },
                    { "8h", "Hour8" },
                    { "1d", "Day1" },
                    { "1w", "Week1" },
                    { "1M", "Month1" },
                } },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "snapshotDelay", 25 },
                    { "snapshotMaxRetries", 3 },
                } },
                { "listenKey", null },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "ping", this.ping },
                { "keepAlive", 8000 },
            } },
            { "exceptions", new Dictionary<string, object>() {} },
        });
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name mexc#watchTicker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#individual-symbol-book-ticker-streams
        * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#public-channels
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object messageHash = add("ticker:", getValue(market, "symbol"));
        if (isTrue(getValue(market, "spot")))
        {
            object channel = add("spot@public.bookTicker.v3.api@", getValue(market, "id"));
            return await this.watchSpotPublic(channel, messageHash, parameters);
        } else
        {
            object channel = "sub.ticker";
            object requestParams = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
            };
            return await this.watchSwapPublic(channel, messageHash, requestParams, parameters);
        }
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        //    {
        //        "c": "spot@public.bookTicker.v3.api@BTCUSDT",
        //        "d": {
        //            "A": "4.70432",
        //            "B": "6.714863",
        //            "a": "20744.54",
        //            "b": "20744.17"
        //        },
        //        "s": "BTCUSDT",
        //        "t": 1678643605721
        //    }
        //
        this.handleBidAsk(client as WebSocketClient, message);
        object rawTicker = this.safeValue2(message, "d", "data");
        object marketId = this.safeString2(message, "s", "symbol");
        object timestamp = this.safeInteger(message, "t");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object ticker = null;
        if (isTrue(getValue(market, "spot")))
        {
            ticker = this.parseWsTicker(rawTicker, market);
            ((IDictionary<string,object>)ticker)["timestamp"] = timestamp;
            ((IDictionary<string,object>)ticker)["datetime"] = this.iso8601(timestamp);
        } else
        {
            ticker = this.parseTicker(rawTicker, market);
        }
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
        object messageHash = add("ticker:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
    }

    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name mexc#watchTickers
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
        * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#individual-symbol-book-ticker-streams
        * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#public-channels
        * @param {string[]} symbols unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object messageHashes = new List<object>() {};
        object marketIds = this.marketIds(symbols);
        object firstMarket = this.market(getValue(symbols, 0));
        object isSpot = getValue(firstMarket, "spot");
        object url = ((bool) isTrue((isSpot))) ? getValue(getValue(getValue(this.urls, "api"), "ws"), "spot") : getValue(getValue(getValue(this.urls, "api"), "ws"), "swap");
        object request = new Dictionary<string, object>() {};
        if (isTrue(isSpot))
        {
            object topics = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
            {
                object marketId = getValue(marketIds, i);
                ((IList<object>)messageHashes).Add(add("ticker:", getValue(symbols, i)));
                ((IList<object>)topics).Add(add("spot@public.bookTicker.v3.api@", marketId));
            }
            ((IDictionary<string,object>)request)["method"] = "SUBSCRIPTION";
            ((IDictionary<string,object>)request)["params"] = topics;
        } else
        {
            ((IDictionary<string,object>)request)["method"] = "sub.tickers";
            ((IDictionary<string,object>)request)["params"] = new Dictionary<string, object>() {};
            ((IList<object>)messageHashes).Add("ticker");
        }
        object ticker = await this.watchMultiple(url, messageHashes, this.extend(request, parameters), messageHashes);
        if (isTrue(isTrue(isSpot) && isTrue(this.newUpdates)))
        {
            object result = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)result)[(string)getValue(ticker, "symbol")] = ticker;
            return result;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    public virtual void handleTickers(WebSocketClient client, object message)
    {
        //
        //     {
        //       "channel": "push.tickers",
        //       "data": [
        //         {
        //           "symbol": "ETH_USDT",
        //           "lastPrice": 2324.5,
        //           "riseFallRate": 0.0356,
        //           "fairPrice": 2324.32,
        //           "indexPrice": 2325.44,
        //           "volume24": 25868309,
        //           "amount24": 591752573.9792,
        //           "maxBidPrice": 2557.98,
        //           "minAskPrice": 2092.89,
        //           "lower24Price": 2239.39,
        //           "high24Price": 2332.59,
        //           "timestamp": 1725872514111
        //         }
        //       ],
        //       "ts": 1725872514111
        //     }
        //
        object data = this.safeList(message, "data");
        object topic = "ticker";
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object ticker = this.parseTicker(getValue(data, i));
            object symbol = getValue(ticker, "symbol");
            ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
            ((IList<object>)result).Add(ticker);
            object messageHash = add(add(topic, ":"), symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {result, topic});
    }

    public virtual object parseWsTicker(object ticker, object market = null)
    {
        //
        // spot
        //    {
        //        "A": "4.70432",
        //        "B": "6.714863",
        //        "a": "20744.54",
        //        "b": "20744.17"
        //    }
        //
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(null, market) },
            { "timestamp", null },
            { "datetime", null },
            { "open", null },
            { "high", null },
            { "low", null },
            { "close", null },
            { "bid", this.safeNumber(ticker, "b") },
            { "bidVolume", this.safeNumber(ticker, "B") },
            { "ask", this.safeNumber(ticker, "a") },
            { "askVolume", this.safeNumber(ticker, "A") },
            { "vwap", null },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", null },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> watchBidsAsks(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name mexc#watchBidsAsks
        * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#individual-symbol-book-ticker-streams
        * @description watches best bid & ask for symbols
        * @param {string[]} symbols unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, true, false, true);
        object marketType = null;
        if (isTrue(isEqual(symbols, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, "watchBidsAsks required symbols argument")) ;
        }
        object markets = this.marketsForSymbols(symbols);
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("watchBidsAsks", getValue(markets, 0), parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object isSpot = isEqual(marketType, "spot");
        if (!isTrue(isSpot))
        {
            throw new NotSupported ((string)add(this.id, "watchBidsAsks only support spot market")) ;
        }
        object messageHashes = new List<object>() {};
        object topics = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            if (isTrue(isSpot))
            {
                object market = this.market(getValue(symbols, i));
                ((IList<object>)topics).Add(add("spot@public.bookTicker.v3.api@", getValue(market, "id")));
            }
            ((IList<object>)messageHashes).Add(add("bidask:", getValue(symbols, i)));
        }
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "spot");
        object request = new Dictionary<string, object>() {
            { "method", "SUBSCRIPTION" },
            { "params", topics },
        };
        object ticker = await this.watchMultiple(url, messageHashes, this.extend(request, parameters), messageHashes);
        if (isTrue(this.newUpdates))
        {
            object tickers = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)tickers)[(string)getValue(ticker, "symbol")] = ticker;
            return tickers;
        }
        return this.filterByArray(this.bidsasks, "symbol", symbols);
    }

    public virtual void handleBidAsk(WebSocketClient client, object message)
    {
        //
        //    {
        //        "c": "spot@public.bookTicker.v3.api@BTCUSDT",
        //        "d": {
        //            "A": "4.70432",
        //            "B": "6.714863",
        //            "a": "20744.54",
        //            "b": "20744.17"
        //        },
        //        "s": "BTCUSDT",
        //        "t": 1678643605721
        //    }
        //
        object parsedTicker = this.parseWsBidAsk(message);
        object symbol = getValue(parsedTicker, "symbol");
        ((IDictionary<string,object>)this.bidsasks)[(string)symbol] = parsedTicker;
        object messageHash = add("bidask:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {parsedTicker, messageHash});
    }

    public virtual object parseWsBidAsk(object ticker, object market = null)
    {
        object data = this.safeDict(ticker, "d");
        object marketId = this.safeString(ticker, "s");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeString(market, "symbol");
        object timestamp = this.safeInteger(ticker, "t");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "ask", this.safeNumber(data, "a") },
            { "askVolume", this.safeNumber(data, "A") },
            { "bid", this.safeNumber(data, "b") },
            { "bidVolume", this.safeNumber(data, "B") },
            { "info", ticker },
        }, market);
    }

    public async virtual Task<object> watchSpotPublic(object channel, object messageHash, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "spot");
        object request = new Dictionary<string, object>() {
            { "method", "SUBSCRIPTION" },
            { "params", new List<object>() {channel} },
        };
        return await this.watch(url, messageHash, this.extend(request, parameters), channel);
    }

    public async virtual Task<object> watchSpotPrivate(object channel, object messageHash, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object listenKey = await this.authenticate(channel);
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "spot"), "?listenKey="), listenKey);
        object request = new Dictionary<string, object>() {
            { "method", "SUBSCRIPTION" },
            { "params", new List<object>() {channel} },
        };
        return await this.watch(url, messageHash, this.extend(request, parameters), channel);
    }

    public async virtual Task<object> watchSwapPublic(object channel, object messageHash, object requestParams, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "swap");
        object request = new Dictionary<string, object>() {
            { "method", channel },
            { "param", requestParams },
        };
        object message = this.extend(request, parameters);
        return await this.watch(url, messageHash, message, messageHash);
    }

    public async virtual Task<object> watchSwapPrivate(object messageHash, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object channel = "login";
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "swap");
        object timestamp = ((object)this.milliseconds()).ToString();
        object payload = add(this.apiKey, timestamp);
        object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha256);
        object request = new Dictionary<string, object>() {
            { "method", channel },
            { "param", new Dictionary<string, object>() {
                { "apiKey", this.apiKey },
                { "signature", signature },
                { "reqTime", timestamp },
            } },
        };
        object message = this.extend(request, parameters);
        return await this.watch(url, messageHash, message, channel);
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name mexc#watchOHLCV
        * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#kline-streams
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object timeframes = this.safeValue(this.options, "timeframes", new Dictionary<string, object>() {});
        object timeframeId = this.safeString(timeframes, timeframe);
        object messageHash = add(add(add("candles:", symbol), ":"), timeframe);
        object ohlcv = null;
        if (isTrue(getValue(market, "spot")))
        {
            object channel = add(add(add("spot@public.kline.v3.api@", getValue(market, "id")), "@"), timeframeId);
            ohlcv = await this.watchSpotPublic(channel, messageHash, parameters);
        } else
        {
            object channel = "sub.kline";
            object requestParams = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
                { "interval", timeframeId },
            };
            ohlcv = await this.watchSwapPublic(channel, messageHash, requestParams, parameters);
        }
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //    {
        //        "d": {
        //            "e": "spot@public.kline.v3.api",
        //            "k": {
        //                "t": 1678642261,
        //                "o": 20626.94,
        //                "c": 20599.69,
        //                "h": 20626.94,
        //                "l": 20597.06,
        //                "v": 27.678686,
        //                "a": 570332.77,
        //                "T": 1678642320,
        //                "i": "Min1"
        //            }
        //        },
        //        "c": "spot@public.kline.v3.api@BTCUSDT@Min1",
        //        "t": 1678642276459,
        //        "s": "BTCUSDT"
        //    }
        //
        // swap
        //
        //   {
        //       "channel": "push.kline",
        //       "data": {
        //         "a": 325653.3287,
        //         "c": 38839,
        //         "h": 38909.5,
        //         "interval": "Min1",
        //         "l": 38833,
        //         "o": 38901.5,
        //         "q": 83808,
        //         "rc": 38839,
        //         "rh": 38909.5,
        //         "rl": 38833,
        //         "ro": 38909.5,
        //         "symbol": "BTC_USDT",
        //         "t": 1651230660
        //       },
        //       "symbol": "BTC_USDT",
        //       "ts": 1651230713067
        //   }
        //
        object d = this.safeValue2(message, "d", "data", new Dictionary<string, object>() {});
        object rawOhlcv = this.safeValue(d, "k", d);
        object timeframeId = this.safeString2(rawOhlcv, "i", "interval");
        object timeframes = this.safeValue(this.options, "timeframes", new Dictionary<string, object>() {});
        object timeframe = this.findTimeframe(timeframeId, timeframes);
        object marketId = this.safeString2(message, "s", "symbol");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object messageHash = add(add(add("candles:", symbol), ":"), timeframe);
        object parsed = this.parseWsOHLCV(rawOhlcv, market);
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
        }
        callDynamically(stored, "append", new object[] {parsed});
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public override object parseWsOHLCV(object ohlcv, object market = null)
    {
        //
        // spot
        //
        //    {
        //        "t": 1678642260,
        //        "o": 20626.94,
        //        "c": 20599.69,
        //        "h": 20626.94,
        //        "l": 20597.06,
        //        "v": 27.678686,
        //        "a": 570332.77,
        //        "T": 1678642320,
        //        "i": "Min1"
        //    }
        //
        // swap
        //    {
        //       "symbol": "BTC_USDT",
        //       "interval": "Min1",
        //       "t": 1680055080,
        //       "o": 27301.9,
        //       "c": 27301.8,
        //       "h": 27301.9,
        //       "l": 27301.8,
        //       "a": 8.19054,
        //       "q": 3,
        //       "ro": 27301.8,
        //       "rc": 27301.8,
        //       "rh": 27301.8,
        //       "rl": 27301.8
        //     }
        //
        return new List<object> {this.safeTimestamp(ohlcv, "t"), this.safeNumber(ohlcv, "o"), this.safeNumber(ohlcv, "h"), this.safeNumber(ohlcv, "l"), this.safeNumber(ohlcv, "c"), this.safeNumber2(ohlcv, "v", "q")};
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name mexc#watchOrderBook
        * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#diff-depth-stream
        * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#public-channels
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object messageHash = add("orderbook:", symbol);
        object orderbook = null;
        if (isTrue(getValue(market, "spot")))
        {
            object channel = add("spot@public.increase.depth.v3.api@", getValue(market, "id"));
            orderbook = await this.watchSpotPublic(channel, messageHash, parameters);
        } else
        {
            object channel = "sub.depth";
            object requestParams = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
            };
            orderbook = await this.watchSwapPublic(channel, messageHash, requestParams, parameters);
        }
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBookSubscription(WebSocketClient client, object message)
    {
        // spot
        //     { id: 0, code: 0, msg: "spot@public.increase.depth.v3.api@BTCUSDT" }
        //
        object msg = this.safeString(message, "msg");
        object parts = ((string)msg).Split(new [] {((string)"@")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(parts, 2);
        object symbol = this.safeSymbol(marketId);
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {});
    }

    public override object getCacheIndex(object orderbook, object cache)
    {
        // return the first index of the cache that can be applied to the orderbook or -1 if not possible
        object nonce = this.safeInteger(orderbook, "nonce");
        object firstDelta = this.safeValue(cache, 0);
        object firstDeltaNonce = this.safeInteger2(firstDelta, "r", "version");
        if (isTrue(isLessThan(nonce, subtract(firstDeltaNonce, 1))))
        {
            return -1;
        }
        for (object i = 0; isLessThan(i, getArrayLength(cache)); postFixIncrement(ref i))
        {
            object delta = getValue(cache, i);
            object deltaNonce = this.safeInteger2(delta, "r", "version");
            if (isTrue(isGreaterThanOrEqual(deltaNonce, nonce)))
            {
                return i;
            }
        }
        return getArrayLength(cache);
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        // spot
        //    {
        //        "c": "spot@public.increase.depth.v3.api@BTCUSDT",
        //        "d": {
        //            "asks": [{
        //                "p": "20290.89",
        //                "v": "0.000000"
        //            }],
        //            "e": "spot@public.increase.depth.v3.api",
        //            "r": "3407459756"
        //        },
        //        "s": "BTCUSDT",
        //        "t": 1661932660144
        //    }
        //
        //
        //
        // swap
        //  {
        //      "channel":"push.depth",
        //      "data":{
        //         "asks":[
        //            [
        //               39146.5,
        //               11264,
        //               1
        //            ]
        //         ],
        //         "bids":[
        //            [
        //               39144,
        //               35460,
        //               1
        //            ]
        //         ],
        //         "end":4895965272,
        //         "begin":4895965271
        //      },
        //      "symbol":"BTC_USDT",
        //      "ts":1651239652372
        //  }
        //
        object data = this.safeValue2(message, "d", "data");
        object marketId = this.safeString2(message, "s", "symbol");
        object symbol = this.safeSymbol(marketId);
        object messageHash = add("orderbook:", symbol);
        object subscription = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        object limit = this.safeInteger(subscription, "limit");
        if (isTrue(isEqual(subscription, true)))
        {
            // we set ((WebSocketClient)client).subscriptions[messageHash] to 1
            // once we have received the first delta and initialized the orderbook
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)messageHash] = 1;
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.countedOrderBook(new Dictionary<string, object>() {});
        }
        object storedOrderBook = getValue(this.orderbooks, symbol);
        object nonce = this.safeInteger(storedOrderBook, "nonce");
        if (isTrue(isEqual(nonce, null)))
        {
            object cacheLength = getArrayLength((storedOrderBook as ccxt.pro.OrderBook).cache);
            object snapshotDelay = this.handleOption("watchOrderBook", "snapshotDelay", 25);
            if (isTrue(isEqual(cacheLength, snapshotDelay)))
            {
                this.spawn(this.loadOrderBook, new object[] { client, messageHash, symbol, limit, new Dictionary<string, object>() {}});
            }
            ((IList<object>)(storedOrderBook as ccxt.pro.OrderBook).cache).Add(data);
            return;
        }
        try
        {
            this.handleDelta(storedOrderBook, data);
            object timestamp = this.safeInteger2(message, "t", "ts");
            ((IDictionary<string,object>)storedOrderBook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)storedOrderBook)["datetime"] = this.iso8601(timestamp);
        } catch(Exception e)
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
            ((WebSocketClient)client).reject(e, messageHash);
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {storedOrderBook, messageHash});
    }

    public virtual void handleBooksideDelta(object bookside, object bidasks)
    {
        //
        //    [{
        //        "p": "20290.89",
        //        "v": "0.000000"
        //    }]
        //
        for (object i = 0; isLessThan(i, getArrayLength(bidasks)); postFixIncrement(ref i))
        {
            object bidask = getValue(bidasks, i);
            if (isTrue(((bidask is IList<object>) || (bidask.GetType().IsGenericType && bidask.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                (bookside as IOrderBookSide).storeArray(bidask);
            } else
            {
                object price = this.safeFloat(bidask, "p");
                object amount = this.safeFloat(bidask, "v");
                (bookside as IOrderBookSide).store(price, amount);
            }
        }
    }

    public override void handleDelta(object orderbook, object delta)
    {
        object existingNonce = this.safeInteger(orderbook, "nonce");
        object deltaNonce = this.safeInteger2(delta, "r", "version");
        if (isTrue(isLessThan(deltaNonce, existingNonce)))
        {
            // even when doing < comparison, this happens: https://app.travis-ci.com/github/ccxt/ccxt/builds/269234741#L1809
            // so, we just skip old updates
            return;
        }
        ((IDictionary<string,object>)orderbook)["nonce"] = deltaNonce;
        object asks = this.safeList(delta, "asks", new List<object>() {});
        object bids = this.safeList(delta, "bids", new List<object>() {});
        object asksOrderSide = getValue(orderbook, "asks");
        object bidsOrderSide = getValue(orderbook, "bids");
        this.handleBooksideDelta(asksOrderSide, asks);
        this.handleBooksideDelta(bidsOrderSide, bids);
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name mexc#watchTrades
        * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#trade-streams
        * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#public-channels
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object messageHash = add("trades:", symbol);
        object trades = null;
        if (isTrue(getValue(market, "spot")))
        {
            object channel = add("spot@public.deals.v3.api@", getValue(market, "id"));
            trades = await this.watchSpotPublic(channel, messageHash, parameters);
        } else
        {
            object channel = "sub.deal";
            object requestParams = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
            };
            trades = await this.watchSwapPublic(channel, messageHash, requestParams, parameters);
        }
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        //    {
        //        "c": "spot@public.deals.v3.api@BTCUSDT",
        //        "d": {
        //            "deals": [{
        //                "p": "20382.70",
        //                "v": "0.043800",
        //                "S": 1,
        //                "t": 1678593222456,
        //            }, ],
        //            "e": "spot@public.deals.v3.api",
        //        },
        //        "s": "BTCUSDT",
        //        "t": 1678593222460,
        //    }
        //
        // swap
        //     {
        //         "symbol": "BTC_USDT",
        //         "data": {
        //             "p": 27307.3,
        //             "v": 5,
        //             "T": 2,
        //             "O": 3,
        //             "M": 1,
        //             "t": 1680055941870
        //         },
        //         "channel": "push.deal",
        //         "ts": 1680055941870
        //     }
        //
        object marketId = this.safeString2(message, "s", "symbol");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object messageHash = add("trades:", symbol);
        object stored = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        object d = this.safeValue2(message, "d", "data");
        object trades = this.safeValue(d, "deals", new List<object>() {d});
        for (object j = 0; isLessThan(j, getArrayLength(trades)); postFixIncrement(ref j))
        {
            object parsedTrade = null;
            if (isTrue(getValue(market, "spot")))
            {
                parsedTrade = this.parseWsTrade(getValue(trades, j), market);
            } else
            {
                parsedTrade = this.parseTrade(getValue(trades, j), market);
            }
            callDynamically(stored, "append", new object[] {parsedTrade});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name mexc#watchMyTrades
        * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#spot-account-deals
        * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#private-channels
        * @description watches information on multiple trades made by the user
        * @param {string} symbol unified market symbol of the market trades were made in
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trade structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object messageHash = "myTrades";
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            messageHash = add(add(messageHash, ":"), symbol);
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchMyTrades", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object trades = null;
        if (isTrue(isEqual(type, "spot")))
        {
            object channel = "spot@private.deals.v3.api";
            trades = await this.watchSpotPrivate(channel, messageHash, parameters);
        } else
        {
            trades = await this.watchSwapPrivate(messageHash, parameters);
        }
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleMyTrade(WebSocketClient client, object message, object subscription = null)
    {
        //
        //    {
        //        "c": "spot@private.deals.v3.api",
        //        "d": {
        //            "p": "22339.99",
        //            "v": "0.000235",
        //            "S": 1,
        //            "T": 1678670940695,
        //            "t": "9f6a47fb926442e496c5c4c104076ae3",
        //            "c": '',
        //            "i": "e2b9835d1b6745f8a10ab74a81a16d50",
        //            "m": 0,
        //            "st": 0
        //        },
        //        "s": "BTCUSDT",
        //        "t": 1678670940700
        //    }
        //
        object messageHash = "myTrades";
        object data = this.safeValue2(message, "d", "data");
        object futuresMarketId = this.safeString(data, "symbol");
        object marketId = this.safeString(message, "s", futuresMarketId);
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object trade = null;
        if (isTrue(getValue(market, "spot")))
        {
            trade = this.parseWsTrade(data, market);
        } else
        {
            trade = this.parseTrade(data, market);
        }
        object trades = this.myTrades;
        if (isTrue(isEqual(trades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            trades = new ArrayCacheBySymbolById(limit);
            this.myTrades = trades;
        }
        callDynamically(trades, "append", new object[] {trade});
        callDynamically(client as WebSocketClient, "resolve", new object[] {trades, messageHash});
        object symbolSpecificMessageHash = add(add(messageHash, ":"), symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {trades, symbolSpecificMessageHash});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        // public trade
        //    {
        //        "p": "20382.70",
        //        "v": "0.043800",
        //        "S": 1,
        //        "t": 1678593222456,
        //    }
        // private trade
        //    {
        //        "S": 1,
        //        "T": 1661938980268,
        //        "c": "",
        //        "i": "c079b0fcb80a46e8b128b281ce4e4f38",
        //        "m": 1,
        //        "p": "1.008",
        //        "st": 0,
        //        "t": "4079b1522a0b40e7919f609e1ea38d44",
        //        "v": "5"
        //    }
        //
        //
        //   d: {
        //       p: '1.0005',
        //       v: '5.71',
        //       a: '5.712855',
        //       S: 1,
        //       T: 1714325698237,
        //       t: 'edafcd9fdc2f426e82443d114691f724',
        //       c: '',
        //       i: 'C02__413321238354677760043',
        //       m: 0,
        //       st: 0,
        //       n: '0.005712855',
        //       N: 'USDT'
        //   }
        object timestamp = this.safeInteger(trade, "T");
        object tradeId = this.safeString(trade, "t");
        if (isTrue(isEqual(timestamp, null)))
        {
            timestamp = this.safeInteger(trade, "t");
            tradeId = null;
        }
        object priceString = this.safeString(trade, "p");
        object amountString = this.safeString(trade, "v");
        object rawSide = this.safeString(trade, "S");
        object side = ((bool) isTrue((isEqual(rawSide, "1")))) ? "buy" : "sell";
        object isMaker = this.safeInteger(trade, "m");
        object feeAmount = this.safeNumber(trade, "n");
        object feeCurrencyId = this.safeString(trade, "N");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", tradeId },
            { "order", this.safeString(trade, "i") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", this.safeSymbol(null, market) },
            { "type", null },
            { "side", side },
            { "takerOrMaker", ((bool) isTrue((isMaker))) ? "maker" : "taker" },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "fee", new Dictionary<string, object>() {
                { "cost", feeAmount },
                { "currency", this.safeCurrencyCode(feeCurrencyId) },
            } },
        }, market);
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name mexc#watchOrders
        * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#spot-account-orders
        * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#margin-account-orders
        * @description watches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string|undefined} params.type the type of orders to retrieve, can be 'spot' or 'margin'
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        parameters = this.omit(parameters, "type");
        object messageHash = "orders";
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            messageHash = add(add(messageHash, ":"), symbol);
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object orders = null;
        if (isTrue(isEqual(type, "spot")))
        {
            object channel = add(type, "@private.orders.v3.api");
            orders = await this.watchSpotPrivate(channel, messageHash, parameters);
        } else
        {
            orders = await this.watchSwapPrivate(messageHash, parameters);
        }
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        //
        // spot
        //    {
        //        "c": "spot@private.orders.v3.api",
        //        "d": {
        //              "A":8.0,
        //              "O":1661938138000,
        //              "S":1,
        //              "V":10,
        //              "a":8,
        //              "c":"",
        //              "i":"e03a5c7441e44ed899466a7140b71391",
        //              "m":0,
        //              "o":1,
        //              "p":0.8,
        //              "s":1,
        //              "v":10,
        //              "ap":0,
        //              "cv":0,
        //              "ca":0
        //        },
        //        "s": "MXUSDT",
        //        "t": 1661938138193
        //    }
        // spot - stop
        //    {
        //        "c": "spot@private.orders.v3.api",
        //        "d": {
        //              "N":"USDT",
        //              "O":1661938853715,
        //              "P":0.9,
        //              "S":1,
        //              "T":"LE",
        //              "i":"f6d82e5f41d745f59fe9d3cafffd80b5",
        //              "o":100,
        //              "p":1.01,
        //              "s":"NEW",
        //              "v":6
        //        },
        //        "s": "MXUSDT",
        //        "t": 1661938853727
        //    }
        // margin
        //    {
        //        "c": "margin@private.orders.v3.api",
        //        "d":{
        //             "O":1661938138000,
        //             "p":"0.8",
        //             "a":"8",
        //             "v":"10",
        //            "da":"0",
        //            "dv":"0",
        //             "A":"8.0",
        //             "V":"10",
        //             "n": "0",
        //             "N": "USDT",
        //             "S":1,
        //             "o":1,
        //             "s":1,
        //             "i":"e03a5c7441e44ed899466a7140b71391",
        //        },
        //        "s": "MXUSDT",
        //        "t":1661938138193
        //    }
        //
        object messageHash = "orders";
        object data = this.safeValue2(message, "d", "data");
        object futuresMarketId = this.safeString(data, "symbol");
        object marketId = this.safeString(message, "s", futuresMarketId);
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object parsed = null;
        if (isTrue(getValue(market, "spot")))
        {
            parsed = this.parseWsOrder(data, market);
        } else
        {
            parsed = this.parseOrder(data, market);
        }
        object orders = this.orders;
        if (isTrue(isEqual(orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            orders = new ArrayCacheBySymbolById(limit);
            this.orders = orders;
        }
        callDynamically(orders, "append", new object[] {parsed});
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
        object symbolSpecificMessageHash = add(add(messageHash, ":"), symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, symbolSpecificMessageHash});
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        // spot
        //     {
        //          "A":8.0,
        //          "O":1661938138000,
        //          "S":1,
        //          "V":10,
        //          "a":8,
        //          "c":"",
        //          "i":"e03a5c7441e44ed899466a7140b71391",
        //          "m":0,
        //          "o":1,
        //          "p":0.8,
        //          "s":1,
        //          "v":10,
        //          "ap":0,
        //          "cv":0,
        //          "ca":0
        //    }
        // spot - stop
        //    {
        //        "N":"USDT",
        //        "O":1661938853715,
        //        "P":0.9,
        //        "S":1,
        //        "T":"LE",
        //        "i":"f6d82e5f41d745f59fe9d3cafffd80b5",
        //        "o":100,
        //        "p":1.01,
        //        "s":"NEW",
        //        "v":6
        //    }
        // margin
        //    {
        //        "O":1661938138000,
        //        "p":"0.8",
        //        "a":"8",
        //        "v":"10",
        //       "da":"0",
        //       "dv":"0",
        //        "A":"8.0",
        //        "V":"10",
        //        "n": "0",
        //        "N": "USDT",
        //        "S":1,
        //        "o":1,
        //        "s":1,
        //        "i":"e03a5c7441e44ed899466a7140b71391",
        //    }
        //
        object timestamp = this.safeInteger(order, "O");
        object side = this.safeString(order, "S");
        object status = this.safeString(order, "s");
        object type = this.safeString(order, "o");
        object fee = null;
        object feeCurrency = this.safeString(order, "N");
        if (isTrue(!isEqual(feeCurrency, null)))
        {
            fee = new Dictionary<string, object>() {
                { "currency", feeCurrency },
                { "cost", null },
            };
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(order, "i") },
            { "clientOrderId", this.safeString(order, "c") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "status", this.parseWsOrderStatus(status, market) },
            { "symbol", this.safeSymbol(null, market) },
            { "type", this.parseWsOrderType(type) },
            { "timeInForce", this.parseWsTimeInForce(type) },
            { "side", ((bool) isTrue((isEqual(side, "1")))) ? "buy" : "sell" },
            { "price", this.safeString(order, "p") },
            { "stopPrice", null },
            { "triggerPrice", this.safeNumber(order, "P") },
            { "average", this.safeString(order, "ap") },
            { "amount", this.safeString(order, "v") },
            { "cost", this.safeString(order, "a") },
            { "filled", this.safeString(order, "cv") },
            { "remaining", this.safeString(order, "V") },
            { "fee", fee },
            { "trades", null },
            { "info", order },
        }, market);
    }

    public virtual object parseWsOrderStatus(object status, object market = null)
    {
        object statuses = new Dictionary<string, object>() {
            { "1", "open" },
            { "2", "closed" },
            { "3", "open" },
            { "4", "canceled" },
            { "5", "open" },
            { "6", "closed" },
            { "NEW", "open" },
            { "CANCELED", "canceled" },
            { "EXECUTED", "closed" },
            { "FAILED", "rejected" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseWsOrderType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "1", "limit" },
            { "2", null },
            { "3", null },
            { "4", null },
            { "5", "market" },
            { "100", "limit" },
        };
        return this.safeString(types, type);
    }

    public virtual object parseWsTimeInForce(object timeInForce)
    {
        object timeInForceIds = new Dictionary<string, object>() {
            { "1", "GTC" },
            { "2", "PO" },
            { "3", "IOC" },
            { "4", "FOK" },
            { "5", "GTC" },
            { "100", "GTC" },
        };
        return this.safeString(timeInForceIds, timeInForce);
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @name mexc#watchBalance
        * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#spot-account-upadte
        * @description watch balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object messageHash = add("balance:", type);
        if (isTrue(isEqual(type, "spot")))
        {
            object channel = "spot@private.account.v3.api";
            return await this.watchSpotPrivate(channel, messageHash, parameters);
        } else
        {
            return await this.watchSwapPrivate(messageHash, parameters);
        }
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        // spot
        //    {
        //        "c": "spot@private.account.v3.api",
        //        "d": {
        //            "a": "USDT",
        //            "c": 1678185928428,
        //            "f": "302.185113007893322435",
        //            "fd": "-4.990689704",
        //            "l": "4.990689704",
        //            "ld": "4.990689704",
        //            "o": "ENTRUST_PLACE"
        //        },
        //        "t": 1678185928435
        //    }
        //
        //
        // swap balance
        //
        //     {
        //         "channel": "push.personal.asset",
        //         "data": {
        //             "availableBalance": 67.2426683348,
        //             "bonus": 0,
        //             "currency": "USDT",
        //             "frozenBalance": 0,
        //             "positionMargin": 1.36945756
        //         },
        //         "ts": 1680059188190
        //     }
        //
        object c = this.safeString(message, "c");
        object type = ((bool) isTrue((isEqual(c, null)))) ? "swap" : "spot";
        object messageHash = add("balance:", type);
        object data = this.safeValue2(message, "d", "data");
        object futuresTimestamp = this.safeInteger(message, "ts");
        object timestamp = this.safeInteger(data, "c", futuresTimestamp);
        if (!isTrue((inOp(this.balance, type))))
        {
            ((IDictionary<string,object>)this.balance)[(string)type] = new Dictionary<string, object>() {};
        }
        ((IDictionary<string,object>)getValue(this.balance, type))["info"] = data;
        ((IDictionary<string,object>)getValue(this.balance, type))["timestamp"] = timestamp;
        ((IDictionary<string,object>)getValue(this.balance, type))["datetime"] = this.iso8601(timestamp);
        object currencyId = this.safeString2(data, "a", "currency");
        object code = this.safeCurrencyCode(currencyId);
        object account = this.account();
        ((IDictionary<string,object>)account)["free"] = this.safeString2(data, "f", "availableBalance");
        ((IDictionary<string,object>)account)["used"] = this.safeString2(data, "l", "frozenBalance");
        ((IDictionary<string,object>)getValue(this.balance, type))[(string)code] = account;
        ((IDictionary<string,object>)this.balance)[(string)type] = this.safeBalance(getValue(this.balance, type));
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, type), messageHash});
    }

    public async virtual Task<object> authenticate(object subscriptionHash, object parameters = null)
    {
        // we only need one listenKey since ccxt shares connections
        parameters ??= new Dictionary<string, object>();
        object listenKey = this.safeString(this.options, "listenKey");
        if (isTrue(!isEqual(listenKey, null)))
        {
            return listenKey;
        }
        object response = await this.spotPrivatePostUserDataStream(parameters);
        //
        //    {
        //        "listenKey": "pqia91ma19a5s61cv6a81va65sdf19v8a65a1a5s61cv6a81va65sdf19v8a65a1"
        //    }
        //
        listenKey = this.safeString(response, "listenKey");
        ((IDictionary<string,object>)this.options)["listenKey"] = listenKey;
        object listenKeyRefreshRate = this.safeInteger(this.options, "listenKeyRefreshRate", 1200000);
        this.delay(listenKeyRefreshRate,  this.keepAliveListenKey, new object[] { listenKey, parameters});
        return listenKey;
    }

    public async virtual Task keepAliveListenKey(object listenKey, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(listenKey, null)))
        {
            return;
        }
        object request = new Dictionary<string, object>() {
            { "listenKey", listenKey },
        };
        try
        {
            await this.spotPrivatePutUserDataStream(this.extend(request, parameters));
            object listenKeyRefreshRate = this.safeInteger(this.options, "listenKeyRefreshRate", 1200000);
            this.delay(listenKeyRefreshRate,  this.keepAliveListenKey, new object[] { listenKey, parameters});
        } catch(Exception error)
        {
            object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "spot"), "?listenKey="), listenKey);
            var client = this.client(url);
            ((IDictionary<string,object>)this.options)["listenKey"] = null;
            ((WebSocketClient)client).reject(error);
            ((IDictionary<string, ccxt.Exchange.WebSocketClient>)this.clients).Remove((string)url);
        }
    }

    public virtual object handlePong(WebSocketClient client, object message)
    {
        client.lastPong = this.milliseconds();
        return message;
    }

    public virtual void handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //    {
        //        "id": 0,
        //        "code": 0,
        //        "msg": "spot@public.increase.depth.v3.api@BTCUSDT"
        //    }
        // Set the default to an empty string if the message is empty during the test.
        object msg = this.safeString(message, "msg", "");
        if (isTrue(isEqual(msg, "PONG")))
        {
            this.handlePong(client as WebSocketClient, message);
        } else if (isTrue(isGreaterThan(getIndexOf(msg, "@"), -1)))
        {
            object parts = ((string)msg).Split(new [] {((string)"@")}, StringSplitOptions.None).ToList<object>();
            object channel = this.safeString(parts, 1);
            object methods = new Dictionary<string, object>() {
                { "public.increase.depth.v3.api", this.handleOrderBookSubscription },
            };
            object method = this.safeValue(methods, channel);
            if (isTrue(!isEqual(method, null)))
            {
                DynamicInvoker.InvokeMethod(method, new object[] { client, message});
            }
        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (isTrue((message is string)))
        {
            if (isTrue(isEqual(message, "Invalid listen key")))
            {
                var error = new AuthenticationError(add(this.id, " invalid listen key"));
                ((WebSocketClient)client).reject(error);
            }
            return;
        }
        if (isTrue(inOp(message, "msg")))
        {
            this.handleSubscriptionStatus(client as WebSocketClient, message);
            return;
        }
        object c = this.safeString(message, "c");
        object channel = null;
        if (isTrue(isEqual(c, null)))
        {
            channel = this.safeString(message, "channel");
        } else
        {
            object parts = ((string)c).Split(new [] {((string)"@")}, StringSplitOptions.None).ToList<object>();
            channel = this.safeString(parts, 1);
        }
        object methods = new Dictionary<string, object>() {
            { "public.deals.v3.api", this.handleTrades },
            { "push.deal", this.handleTrades },
            { "public.kline.v3.api", this.handleOHLCV },
            { "push.kline", this.handleOHLCV },
            { "public.bookTicker.v3.api", this.handleTicker },
            { "push.ticker", this.handleTicker },
            { "push.tickers", this.handleTickers },
            { "public.increase.depth.v3.api", this.handleOrderBook },
            { "push.depth", this.handleOrderBook },
            { "private.orders.v3.api", this.handleOrder },
            { "push.personal.order", this.handleOrder },
            { "private.account.v3.api", this.handleBalance },
            { "push.personal.asset", this.handleBalance },
            { "private.deals.v3.api", this.handleMyTrade },
            { "push.personal.order.deal", this.handleMyTrade },
            { "pong", this.handlePong },
        };
        if (isTrue(inOp(methods, channel)))
        {
            object method = getValue(methods, channel);
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
    }

    public override object ping(WebSocketClient client)
    {
        return new Dictionary<string, object>() {
            { "method", "ping" },
        };
    }
}
