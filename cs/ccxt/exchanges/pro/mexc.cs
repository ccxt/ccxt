namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class mexc { public mexc(object args = null) : base(args) { } }
public partial class mexc : ccxt.mexc
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "cancelAllOrdersWs", false },
                { "cancelOrdersWs", false },
                { "cancelOrderWs", false },
                { "createOrderWs", false },
                { "editOrderWs", false },
                { "fetchBalanceWs", false },
                { "fetchOpenOrdersWs", false },
                { "fetchOrderWs", false },
                { "fetchTradesWs", false },
                { "watchBalance", true },
                { "watchMyTrades", true },
                { "watchOHLCV", true },
                { "watchOrderBook", true },
                { "watchOrders", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchBidsAsks", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", false },
                { "unWatchTicker", true },
                { "unWatchTickers", true },
                { "unWatchBidsAsks", true },
                { "unWatchOHLCV", true },
                { "unWatchOrderBook", true },
                { "unWatchTrades", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "spot", "wss://wbs-api.mexc.com/ws" },
                        { "swap", "wss://contract.mexc.com/edge" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "listenKeyRefreshRate", 1200000 },
                { "decompressBinary", false },
                { "timeframes", new Dictionary<string, object>() {
                    { "1m", "Min1" },
                    { "5m", "Min5" },
                    { "15m", "Min15" },
                    { "30m", "Min30" },
                    { "1h", "Min60" },
                    { "4h", "Hour4" },
                    { "8h", "Hour8" },
                    { "1d", "Day1" },
                    { "1w", "Week1" },
                    { "1M", "Month1" },
                } },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "snapshotDelay", 25 },
                    { "snapshotMaxRetries", 3 },
                } },
                { "listenKey", null },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "ping", this.ping },
                { "keepAlive", 8000 },
            } },
            { "exceptions", new Dictionary<string, object>() {} },
        });
    }

    /**
     * @method
     * @name mexc#watchTicker
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#individual-symbol-book-ticker-streams
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#public-channels
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#miniticker
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.miniTicker] set to true for using the miniTicker endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object messageHash = add("ticker:", getValue(market, "symbol"));
        if (isTrue(getValue(market, "spot")))
        {
            object channel = add("spot@public.aggre.bookTicker.v3.api.pb@100ms@", getValue(market, "id"));
            return await this.watchSpotPublic(channel, messageHash, parameters);
        } else
        {
            object channel = "sub.ticker";
            object requestParams = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
            };
            return await this.watchSwapPublic(channel, messageHash, requestParams, parameters);
        }
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        // swap
        //
        //     {
        //         "symbol": "BTC_USDT",
        //         "data": {
        //             "symbol": "BTC_USDT",
        //             "lastPrice": 76376.2,
        //             "riseFallRate": -0.0006,
        //             "fairPrice": 76374.4,
        //             "indexPrice": 76385.8,
        //             "volume24": 962062810,
        //             "amount24": 7344207079.96768,
        //             "maxBidPrice": 84024.3,
        //             "minAskPrice": 68747.2,
        //             "lower24Price": 75620.2,
        //             "high24Price": 77210,
        //             "timestamp": 1731137509138,
        //             "bid1": 76376.2,
        //             "ask1": 76376.3,
        //             "holdVol": 95479623,
        //             "riseFallValue": -46.5,
        //             "fundingRate": 0.0001,
        //             "zone": "UTC+8",
        //             "riseFallRates": [ -0.0006, 0.1008, 0.2262, 0.2628, 0.2439, 1.0564 ],
        //             "riseFallRatesOfTimezone": [ 0.0065, -0.0013, -0.0006 ]
        //         },
        //         "channel": "push.ticker",
        //         "ts": 1731137509138
        //     }
        //
        // spot
        //
        //    {
        //        "c": "spot@public.bookTicker.v3.api@BTCUSDT",
        //        "d": {
        //            "A": "4.70432",
        //            "B": "6.714863",
        //            "a": "20744.54",
        //            "b": "20744.17"
        //        },
        //        "s": "BTCUSDT",
        //        "t": 1678643605721
        //    }
        //
        // spot miniTicker
        //
        //     {
        //         "d": {
        //             "s": "BTCUSDT",
        //             "p": "76522",
        //             "r": "0.0012",
        //             "tr": "0.0012",
        //             "h": "77196.3",
        //             "l": "75630.77",
        //             "v": "584664223.92",
        //             "q": "7666.720258",
        //             "lastRT": "-1",
        //             "MT": "0",
        //             "NV": "--",
        //             "t": "1731135533126"
        //         },
        //         "c": "spot@public.miniTicker.v3.api@BTCUSDT@UTC+8",
        //         "t": 1731135533126,
        //         "s": "BTCUSDT"
        //     }
        //
        this.handleBidAsk(client as WebSocketClient, message);
        object rawTicker = this.safeDictN(message, new List<object>() {"d", "data", "publicAggreBookTicker"});
        object marketId = this.safeString2(message, "s", "symbol");
        object timestamp = this.safeInteger2(message, "t", "sendTime");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object ticker = null;
        if (isTrue(getValue(market, "spot")))
        {
            ticker = this.parseWsTicker(rawTicker, market);
            ((IDictionary<string,object>)ticker)["timestamp"] = timestamp;
            ((IDictionary<string,object>)ticker)["datetime"] = this.iso8601(timestamp);
        } else
        {
            ticker = this.parseTicker(rawTicker, market);
        }
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
        object messageHash = add("ticker:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
    }

    /**
     * @method
     * @name mexc#watchTickers
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#individual-symbol-book-ticker-streams
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#public-channels
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#minitickers
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.miniTicker] set to true for using the miniTicker endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null);
        object messageHashes = new List<object>() {};
        object firstSymbol = this.safeString(symbols, 0);
        object market = null;
        if (isTrue(!isEqual(firstSymbol, null)))
        {
            market = this.market(firstSymbol);
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchTickers", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object isSpot = (isEqual(type, "spot"));
        object url = ((bool) isTrue((isSpot))) ? getValue(getValue(getValue(this.urls, "api"), "ws"), "spot") : getValue(getValue(getValue(this.urls, "api"), "ws"), "swap");
        object request = new Dictionary<string, object>() {};
        if (isTrue(isSpot))
        {
            throw new NotSupported ((string)add(this.id, " watchTickers does not support spot markets")) ;
        } else
        {
            ((IDictionary<string,object>)request)["method"] = "sub.tickers";
            ((IDictionary<string,object>)request)["params"] = new Dictionary<string, object>() {};
            ((IList<object>)messageHashes).Add("ticker");
        }
        object ticker = await this.watchMultiple(url, messageHashes, this.extend(request, parameters), messageHashes);
        if (isTrue(isTrue(isSpot) && isTrue(this.newUpdates)))
        {
            object result = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)result)[(string)getValue(ticker, "symbol")] = ticker;
            return result;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    public virtual void handleTickers(WebSocketClient client, object message)
    {
        //
        // swap
        //
        //     {
        //       "channel": "push.tickers",
        //       "data": [
        //         {
        //           "symbol": "ETH_USDT",
        //           "lastPrice": 2324.5,
        //           "riseFallRate": 0.0356,
        //           "fairPrice": 2324.32,
        //           "indexPrice": 2325.44,
        //           "volume24": 25868309,
        //           "amount24": 591752573.9792,
        //           "maxBidPrice": 2557.98,
        //           "minAskPrice": 2092.89,
        //           "lower24Price": 2239.39,
        //           "high24Price": 2332.59,
        //           "timestamp": 1725872514111
        //         }
        //       ],
        //       "ts": 1725872514111
        //     }
        //
        // spot
        //
        //    {
        //        "c": "spot@public.bookTicker.v3.api@BTCUSDT",
        //        "d": {
        //            "A": "4.70432",
        //            "B": "6.714863",
        //            "a": "20744.54",
        //            "b": "20744.17"
        //        },
        //        "s": "BTCUSDT",
        //        "t": 1678643605721
        //    }
        //
        // spot miniTicker
        //
        //     {
        //         "d": {
        //             "s": "BTCUSDT",
        //             "p": "76522",
        //             "r": "0.0012",
        //             "tr": "0.0012",
        //             "h": "77196.3",
        //             "l": "75630.77",
        //             "v": "584664223.92",
        //             "q": "7666.720258",
        //             "lastRT": "-1",
        //             "MT": "0",
        //             "NV": "--",
        //             "t": "1731135533126"
        //         },
        //         "c": "spot@public.miniTicker.v3.api@BTCUSDT@UTC+8",
        //         "t": 1731135533126,
        //         "s": "BTCUSDT"
        //     }
        //
        object data = this.safeList2(message, "data", "d");
        object channel = this.safeString(message, "c", "");
        object marketId = this.safeString(message, "s");
        object market = this.safeMarket(marketId);
        object channelStartsWithSpot = ((string)channel).StartsWith(((string)"spot"));
        object marketIdIsUndefined = isEqual(marketId, null);
        object isSpot = ((bool) isTrue(marketIdIsUndefined)) ? channelStartsWithSpot : getValue(market, "spot");
        object spotPrefix = "spot:";
        object messageHashPrefix = ((bool) isTrue(isSpot)) ? spotPrefix : "";
        object topic = add(messageHashPrefix, "ticker");
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object ticker = null;
            if (isTrue(isSpot))
            {
                ticker = this.parseWsTicker(entry, market);
            } else
            {
                ticker = this.parseTicker(entry);
            }
            object symbol = getValue(ticker, "symbol");
            ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
            ((IList<object>)result).Add(ticker);
            object messageHash = add("ticker:", symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {result, topic});
    }

    public virtual object parseWsTicker(object ticker, object market = null)
    {
        // protobuf ticker
        // "bidprice": "93387.28",  // Best bid price
        // "bidquantity": "3.73485", // Best bid quantity
        // "askprice": "93387.29", // Best ask price
        // "askquantity": "7.669875" // Best ask quantity
        //
        // spot
        //
        //     {
        //         "A": "4.70432",
        //         "B": "6.714863",
        //         "a": "20744.54",
        //         "b": "20744.17"
        //     }
        //
        // spot miniTicker
        //
        //     {
        //         "s": "BTCUSDT",
        //         "p": "76521",
        //         "r": "0.0012",
        //         "tr": "0.0012",
        //         "h": "77196.3",
        //         "l": "75630.77",
        //         "v": "584664223.92",
        //         "q": "7666.720258",
        //         "lastRT": "-1",
        //         "MT": "0",
        //         "NV": "--",
        //         "t": "1731135533126"
        //     }
        //
        object marketId = this.safeString(ticker, "s");
        object timestamp = this.safeInteger(ticker, "t");
        object price = this.safeString(ticker, "p");
        return this.safeTicker(new Dictionary<string, object>() {
            { "info", ticker },
            { "symbol", this.safeSymbol(marketId, market) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "open", null },
            { "high", this.safeNumber(ticker, "h") },
            { "low", this.safeNumber(ticker, "l") },
            { "close", price },
            { "last", price },
            { "bid", this.safeNumber2(ticker, "b", "bidPrice") },
            { "bidVolume", this.safeNumber2(ticker, "B", "bidQuantity") },
            { "ask", this.safeNumber2(ticker, "a", "askPrice") },
            { "askVolume", this.safeNumber2(ticker, "A", "askQuantity") },
            { "vwap", null },
            { "previousClose", null },
            { "change", null },
            { "percentage", this.safeNumber(ticker, "tr") },
            { "average", null },
            { "baseVolume", this.safeNumber(ticker, "v") },
            { "quoteVolume", this.safeNumber(ticker, "q") },
        }, market);
    }

    /**
     * @method
     * @name mexc#watchBidsAsks
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#individual-symbol-book-ticker-streams
     * @description watches best bid & ask for symbols
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchBidsAsks(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, true, false, true);
        object marketType = null;
        if (isTrue(isEqual(symbols, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchBidsAsks required symbols argument")) ;
        }
        object markets = this.marketsForSymbols(symbols);
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("watchBidsAsks", getValue(markets, 0), parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object isSpot = isEqual(marketType, "spot");
        if (!isTrue(isSpot))
        {
            throw new NotSupported ((string)add(this.id, " watchBidsAsks only support spot market")) ;
        }
        object messageHashes = new List<object>() {};
        object topics = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            if (isTrue(isSpot))
            {
                object market = this.market(getValue(symbols, i));
                ((IList<object>)topics).Add(add("spot@public.aggre.bookTicker.v3.api.pb@100ms@", getValue(market, "id")));
            }
            ((IList<object>)messageHashes).Add(add("bidask:", getValue(symbols, i)));
        }
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "spot");
        object request = new Dictionary<string, object>() {
            { "method", "SUBSCRIPTION" },
            { "params", topics },
        };
        object ticker = await this.watchMultiple(url, messageHashes, this.extend(request, parameters), messageHashes);
        if (isTrue(this.newUpdates))
        {
            object tickers = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)tickers)[(string)getValue(ticker, "symbol")] = ticker;
            return tickers;
        }
        return this.filterByArray(this.bidsasks, "symbol", symbols);
    }

    public virtual void handleBidAsk(WebSocketClient client, object message)
    {
        //
        //    {
        //        "c": "spot@public.bookTicker.v3.api@BTCUSDT",
        //        "d": {
        //            "A": "4.70432",
        //            "B": "6.714863",
        //            "a": "20744.54",
        //            "b": "20744.17"
        //        },
        //        "s": "BTCUSDT",
        //        "t": 1678643605721
        //    }
        //
        object parsedTicker = this.parseWsBidAsk(message);
        object symbol = this.safeString(parsedTicker, "symbol");
        if (isTrue(isEqual(symbol, null)))
        {
            return;
        }
        ((IDictionary<string,object>)this.bidsasks)[(string)symbol] = parsedTicker;
        object messageHash = add("bidask:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {parsedTicker, messageHash});
    }

    public virtual object parseWsBidAsk(object ticker, object market = null)
    {
        object data = this.safeDict(ticker, "d");
        object marketId = this.safeString(ticker, "s");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeString(market, "symbol");
        object timestamp = this.safeInteger(ticker, "t");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "ask", this.safeNumber(data, "a") },
            { "askVolume", this.safeNumber(data, "A") },
            { "bid", this.safeNumber(data, "b") },
            { "bidVolume", this.safeNumber(data, "B") },
            { "info", ticker },
        }, market);
    }

    public async virtual Task<object> watchSpotPublic(object channel, object messageHash, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object unsubscribed = this.safeBool(parameters, "unsubscribed", false);
        parameters = this.omit(parameters, new List<object>() {"unsubscribed"});
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "spot");
        object method = ((bool) isTrue((unsubscribed))) ? "UNSUBSCRIPTION" : "SUBSCRIPTION";
        object request = new Dictionary<string, object>() {
            { "method", method },
            { "params", new List<object>() {channel} },
        };
        return await this.watch(url, messageHash, this.extend(request, parameters), messageHash);
    }

    public async virtual Task<object> watchSpotPrivate(object channel, object messageHash, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object listenKey = await this.authenticate(channel);
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "spot"), "?listenKey="), listenKey);
        object request = new Dictionary<string, object>() {
            { "method", "SUBSCRIPTION" },
            { "params", new List<object>() {channel} },
        };
        return await this.watch(url, messageHash, this.extend(request, parameters), channel);
    }

    public async virtual Task<object> watchSwapPublic(object channel, object messageHash, object requestParams, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "swap");
        object request = new Dictionary<string, object>() {
            { "method", channel },
            { "param", requestParams },
        };
        object message = this.extend(request, parameters);
        return await this.watch(url, messageHash, message, messageHash);
    }

    public async virtual Task<object> watchSwapPrivate(object messageHash, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object channel = "login";
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "swap");
        object timestamp = ((object)this.milliseconds()).ToString();
        object payload = add(this.apiKey, timestamp);
        object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha256);
        object request = new Dictionary<string, object>() {
            { "method", channel },
            { "param", new Dictionary<string, object>() {
                { "apiKey", this.apiKey },
                { "signature", signature },
                { "reqTime", timestamp },
            } },
        };
        object message = this.extend(request, parameters);
        return await this.watch(url, messageHash, message, channel);
    }

    /**
     * @method
     * @name mexc#watchOHLCV
     * @see https://www.mexc.com/api-docs/spot-v3/websocket-market-streams#trade-streams
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object timeframes = this.safeValue(this.options, "timeframes", new Dictionary<string, object>() {});
        object timeframeId = this.safeString(timeframes, timeframe);
        object messageHash = add(add(add("candles:", symbol), ":"), timeframe);
        object ohlcv = null;
        if (isTrue(getValue(market, "spot")))
        {
            object channel = add(add(add("spot@public.kline.v3.api.pb@", getValue(market, "id")), "@"), timeframeId);
            ohlcv = await this.watchSpotPublic(channel, messageHash, parameters);
        } else
        {
            object channel = "sub.kline";
            object requestParams = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
                { "interval", timeframeId },
            };
            ohlcv = await this.watchSwapPublic(channel, messageHash, requestParams, parameters);
        }
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //    {
        //        "d": {
        //            "e": "spot@public.kline.v3.api",
        //            "k": {
        //                "t": 1678642261,
        //                "o": 20626.94,
        //                "c": 20599.69,
        //                "h": 20626.94,
        //                "l": 20597.06,
        //                "v": 27.678686,
        //                "a": 570332.77,
        //                "T": 1678642320,
        //                "i": "Min1"
        //            }
        //        },
        //        "c": "spot@public.kline.v3.api@BTCUSDT@Min1",
        //        "t": 1678642276459,
        //        "s": "BTCUSDT"
        //    }
        //
        // swap
        //
        //   {
        //       "channel": "push.kline",
        //       "data": {
        //         "a": 325653.3287,
        //         "c": 38839,
        //         "h": 38909.5,
        //         "interval": "Min1",
        //         "l": 38833,
        //         "o": 38901.5,
        //         "q": 83808,
        //         "rc": 38839,
        //         "rh": 38909.5,
        //         "rl": 38833,
        //         "ro": 38909.5,
        //         "symbol": "BTC_USDT",
        //         "t": 1651230660
        //       },
        //       "symbol": "BTC_USDT",
        //       "ts": 1651230713067
        //   }
        // protobuf
        //  {
        //    "channel":"spot@public.kline.v3.api.pb@BTCUSDT@Min1",
        //    "symbol":"BTCUSDT",
        //    "symbolId":"2fb942154ef44a4ab2ef98c8afb6a4a7",
        //    "createTime":"1754737941062",
        //    "publicSpotKline":{
        //       "interval":"Min1",
        //       "windowStart":"1754737920",
        //       "openingPrice":"117317.31",
        //       "closingPrice":"117325.26",
        //       "highestPrice":"117341",
        //       "lowestPrice":"117317.3",
        //       "volume":"3.12599854",
        //       "amount":"366804.43",
        //       "windowEnd":"1754737980"
        //    }
        // }
        //
        object parsed = null;
        object symbol = null;
        object timeframe = null;
        if (isTrue(inOp(message, "publicSpotKline")))
        {
            symbol = this.symbol(this.safeString(message, "symbol"));
            object data = this.safeDict(message, "publicSpotKline", new Dictionary<string, object>() {});
            object timeframeId = this.safeString(data, "interval");
            timeframe = this.findTimeframe(timeframeId, getValue(this.options, "timeframes"));
            parsed = this.parseWsOHLCV(data, this.safeMarket(symbol));
        } else
        {
            object d = this.safeValue2(message, "d", "data", new Dictionary<string, object>() {});
            object rawOhlcv = this.safeValue(d, "k", d);
            object timeframeId = this.safeString2(rawOhlcv, "i", "interval");
            object timeframes = this.safeValue(this.options, "timeframes", new Dictionary<string, object>() {});
            timeframe = this.findTimeframe(timeframeId, timeframes);
            object marketId = this.safeString2(message, "s", "symbol");
            object market = this.safeMarket(marketId);
            symbol = getValue(market, "symbol");
            parsed = this.parseWsOHLCV(rawOhlcv, market);
        }
        object messageHash = add(add(add("candles:", symbol), ":"), timeframe);
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
        }
        callDynamically(stored, "append", new object[] {parsed});
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public override object parseWsOHLCV(object ohlcv, object market = null)
    {
        //
        // spot
        //
        //    {
        //        "t": 1678642260,
        //        "o": 20626.94,
        //        "c": 20599.69,
        //        "h": 20626.94,
        //        "l": 20597.06,
        //        "v": 27.678686,
        //        "a": 570332.77,
        //        "T": 1678642320,
        //        "i": "Min1"
        //    }
        //
        // swap
        //    {
        //       "symbol": "BTC_USDT",
        //       "interval": "Min1",
        //       "t": 1680055080,
        //       "o": 27301.9,
        //       "c": 27301.8,
        //       "h": 27301.9,
        //       "l": 27301.8,
        //       "a": 8.19054,
        //       "q": 3,
        //       "ro": 27301.8,
        //       "rc": 27301.8,
        //       "rh": 27301.8,
        //       "rl": 27301.8
        //     }
        // protobuf
        //
        //       "interval":"Min1",
        //       "windowStart":"1754737920",
        //       "openingPrice":"117317.31",
        //       "closingPrice":"117325.26",
        //       "highestPrice":"117341",
        //       "lowestPrice":"117317.3",
        //       "volume":"3.12599854",
        //       "amount":"366804.43",
        //       "windowEnd":"1754737980"
        //
        return new List<object> {this.safeTimestamp2(ohlcv, "t", "windowStart"), this.safeNumber2(ohlcv, "o", "openingPrice"), this.safeNumber2(ohlcv, "h", "highestPrice"), this.safeNumber2(ohlcv, "l", "lowestPrice"), this.safeNumber2(ohlcv, "c", "closingPrice"), this.safeNumber2(ohlcv, "v", "volume")};
    }

    /**
     * @method
     * @name mexc#watchOrderBook
     * @see https://www.mexc.com/api-docs/spot-v3/websocket-market-streams#trade-streams
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#public-channels
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.frequency] the frequency of the order book updates, default is '10ms', can be '100ms' or '10ms
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object messageHash = add("orderbook:", symbol);
        object orderbook = null;
        if (isTrue(getValue(market, "spot")))
        {
            object frequency = null;
            var frequencyparametersVariable = this.handleOptionAndParams(parameters, "watchOrderBook", "frequency", "100ms");
            frequency = ((IList<object>)frequencyparametersVariable)[0];
            parameters = ((IList<object>)frequencyparametersVariable)[1];
            object channel = add(add(add("spot@public.aggre.depth.v3.api.pb@", frequency), "@"), getValue(market, "id"));
            orderbook = await this.watchSpotPublic(channel, messageHash, parameters);
        } else
        {
            object channel = "sub.depth";
            object requestParams = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
            };
            orderbook = await this.watchSwapPublic(channel, messageHash, requestParams, parameters);
        }
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBookSubscription(WebSocketClient client, object message)
    {
        // spot
        //     { id: 0, code: 0, msg: "spot@public.increase.depth.v3.api@BTCUSDT" }
        //
        object msg = this.safeString(message, "msg");
        object parts = ((string)msg).Split(new [] {((string)"@")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(parts, 2);
        object symbol = this.safeSymbol(marketId);
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {});
    }

    public override object getCacheIndex(object orderbook, object cache)
    {
        // return the first index of the cache that can be applied to the orderbook or -1 if not possible
        object nonce = this.safeInteger(orderbook, "nonce");
        object firstDelta = this.safeValue(cache, 0);
        object firstDeltaNonce = this.safeIntegerN(firstDelta, new List<object>() {"r", "version", "fromVersion"});
        if (isTrue(isLessThan(nonce, subtract(firstDeltaNonce, 1))))
        {
            return -1;
        }
        for (object i = 0; isLessThan(i, getArrayLength(cache)); postFixIncrement(ref i))
        {
            object delta = getValue(cache, i);
            object deltaNonce = this.safeIntegerN(delta, new List<object>() {"r", "version", "fromVersion"});
            if (isTrue(isGreaterThanOrEqual(deltaNonce, nonce)))
            {
                return i;
            }
        }
        return getArrayLength(cache);
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        // spot
        //    {
        //        "c": "spot@public.increase.depth.v3.api@BTCUSDT",
        //        "d": {
        //            "asks": [{
        //                "p": "20290.89",
        //                "v": "0.000000"
        //            }],
        //            "e": "spot@public.increase.depth.v3.api",
        //            "r": "3407459756"
        //        },
        //        "s": "BTCUSDT",
        //        "t": 1661932660144
        //    }
        //
        //
        //
        // swap
        //  {
        //      "channel":"push.depth",
        //      "data":{
        //         "asks":[
        //            [
        //               39146.5,
        //               11264,
        //               1
        //            ]
        //         ],
        //         "bids":[
        //            [
        //               39144,
        //               35460,
        //               1
        //            ]
        //         ],
        //         "end":4895965272,
        //         "begin":4895965271
        //      },
        //      "symbol":"BTC_USDT",
        //      "ts":1651239652372
        //  }
        // protofbuf
        // {
        //      "channel":"spot@public.aggre.depth.v3.api.pb@100ms@BTCUSDT",
        //      "symbol":"BTCUSDT",
        //      "sendTime":"1754741322152",
        //      "publicAggreDepths":{
        //          "asks":[
        //              {
        //                  "price":"117145.49",
        //                  "quantity":"0"
        //              }
        //          ],
        //          "bids":[
        //              {
        //                  "price":"117053.41",
        //                  "quantity":"1.86837271"
        //              }
        //          ],
        //          "eventType":"spot@public.aggre.depth.v3.api.pb@100ms",
        //          "fromVersion":"43296363236",
        //          "toVersion":"43296363255"
        //      }
        // }
        //
        object data = this.safeDictN(message, new List<object>() {"d", "data", "publicAggreDepths"});
        object marketId = this.safeString2(message, "s", "symbol");
        object symbol = this.safeSymbol(marketId);
        object messageHash = add("orderbook:", symbol);
        object subscription = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        object limit = this.safeInteger(subscription, "limit");
        if (!isTrue((inOp(this.orderbooks, symbol))))
        {
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook();
        }
        object storedOrderBook = getValue(this.orderbooks, symbol);
        object nonce = this.safeInteger(storedOrderBook, "nonce");
        if (isTrue(isEqual(nonce, null)))
        {
            object cacheLength = getArrayLength((storedOrderBook as ccxt.pro.OrderBook).cache);
            object snapshotDelay = this.handleOption("watchOrderBook", "snapshotDelay", 25);
            if (isTrue(isEqual(cacheLength, snapshotDelay)))
            {
                this.spawn(this.loadOrderBook, new object[] { client, messageHash, symbol, limit, new Dictionary<string, object>() {}});
            }
            ((IList<object>)(storedOrderBook as ccxt.pro.OrderBook).cache).Add(data);
            return;
        }
        try
        {
            this.handleDelta(storedOrderBook, data);
            object timestamp = this.safeIntegerN(message, new List<object>() {"t", "ts", "sendTime"});
            ((IDictionary<string,object>)storedOrderBook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)storedOrderBook)["datetime"] = this.iso8601(timestamp);
        } catch(Exception e)
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
            ((WebSocketClient)client).reject(e, messageHash);
            return;
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {storedOrderBook, messageHash});
    }

    public virtual void handleBooksideDelta(object bookside, object bidasks)
    {
        //
        //    [{
        //        "p": "20290.89",
        //        "v": "0.000000"
        //    }]
        //
        for (object i = 0; isLessThan(i, getArrayLength(bidasks)); postFixIncrement(ref i))
        {
            object bidask = getValue(bidasks, i);
            if (isTrue(((bidask is IList<object>) || (bidask.GetType().IsGenericType && bidask.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                (bookside as IOrderBookSide).storeArray(bidask);
            } else
            {
                object price = this.safeFloat2(bidask, "p", "price");
                object amount = this.safeFloat2(bidask, "v", "quantity");
                (bookside as IOrderBookSide).store(price, amount);
            }
        }
    }

    public override void handleDelta(object orderbook, object delta)
    {
        object existingNonce = this.safeInteger(orderbook, "nonce");
        object deltaNonce = this.safeIntegerN(delta, new List<object>() {"r", "version", "fromVersion"});
        if (isTrue(isLessThan(deltaNonce, existingNonce)))
        {
            // even when doing < comparison, this happens: https://app.travis-ci.com/github/ccxt/ccxt/builds/269234741#L1809
            // so, we just skip old updates
            return;
        }
        ((IDictionary<string,object>)orderbook)["nonce"] = deltaNonce;
        object asks = this.safeList(delta, "asks", new List<object>() {});
        object bids = this.safeList(delta, "bids", new List<object>() {});
        object asksOrderSide = getValue(orderbook, "asks");
        object bidsOrderSide = getValue(orderbook, "bids");
        this.handleBooksideDelta(asksOrderSide, asks);
        this.handleBooksideDelta(bidsOrderSide, bids);
    }

    /**
     * @method
     * @name mexc#watchTrades
     * @see https://www.mexc.com/api-docs/spot-v3/websocket-market-streams#trade-streams
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#public-channels
     * @description get the list of most recent trades for a particular symbol
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object messageHash = add("trades:", symbol);
        object trades = null;
        if (isTrue(getValue(market, "spot")))
        {
            object channel = add("spot@public.aggre.deals.v3.api.pb@100ms@", getValue(market, "id"));
            trades = await this.watchSpotPublic(channel, messageHash, parameters);
        } else
        {
            object channel = "sub.deal";
            object requestParams = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
            };
            trades = await this.watchSwapPublic(channel, messageHash, requestParams, parameters);
        }
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        // protobuf
        // {
        // "channel": "spot@public.aggre.deals.v3.api.pb@100ms@BTCUSDT",
        // "publicdeals": {
        //     "dealsList": [
        //     {
        //         "price": "93220.00", // Trade price
        //         "quantity": "0.04438243", // Trade quantity
        //         "tradetype": 2, // Trade type (1: Buy, 2: Sell)
        //         "time": 1736409765051 // Trade time
        //     }
        //     ],
        //     "eventtype": "spot@public.aggre.deals.v3.api.pb@100ms" // Event type
        // },
        // "symbol": "BTCUSDT", // Trading pair
        // "sendtime": 1736409765052 // Event time
        // }
        //
        //    {
        //        "c": "spot@public.deals.v3.api@BTCUSDT",
        //        "d": {
        //            "deals": [{
        //                "p": "20382.70",
        //                "v": "0.043800",
        //                "S": 1,
        //                "t": 1678593222456,
        //            }, ],
        //            "e": "spot@public.deals.v3.api",
        //        },
        //        "s": "BTCUSDT",
        //        "t": 1678593222460,
        //    }
        //
        // swap
        //     {
        //         "symbol": "BTC_USDT",
        //         "data": {
        //             "p": 27307.3,
        //             "v": 5,
        //             "T": 2,
        //             "O": 3,
        //             "M": 1,
        //             "t": 1680055941870
        //         },
        //         "channel": "push.deal",
        //         "ts": 1680055941870
        //     }
        //
        object marketId = this.safeString2(message, "s", "symbol");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object messageHash = add("trades:", symbol);
        object stored = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        object d = this.safeDictN(message, new List<object>() {"d", "data", "publicAggreDeals"});
        object trades = this.safeList2(d, "deals", "dealsList", new List<object>() {d});
        for (object j = 0; isLessThan(j, getArrayLength(trades)); postFixIncrement(ref j))
        {
            object parsedTrade = null;
            if (isTrue(getValue(market, "spot")))
            {
                parsedTrade = this.parseWsTrade(getValue(trades, j), market);
            } else
            {
                parsedTrade = this.parseTrade(getValue(trades, j), market);
            }
            callDynamically(stored, "append", new object[] {parsedTrade});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    /**
     * @method
     * @name mexc#watchMyTrades
     * @see https://www.mexc.com/api-docs/spot-v3/websocket-user-data-streams#spot-account-deals
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#private-channels
     * @description watches information on multiple trades made by the user
     * @param {string} symbol unified market symbol of the market trades were made in
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trade structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object messageHash = "myTrades";
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            messageHash = add(add(messageHash, ":"), symbol);
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchMyTrades", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object trades = null;
        if (isTrue(isEqual(type, "spot")))
        {
            object channel = "spot@private.deals.v3.api.pb";
            trades = await this.watchSpotPrivate(channel, messageHash, parameters);
        } else
        {
            trades = await this.watchSwapPrivate(messageHash, parameters);
        }
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleMyTrade(WebSocketClient client, object message, object subscription = null)
    {
        //
        //    {
        //        "c": "spot@private.deals.v3.api",
        //        "d": {
        //            "p": "22339.99",
        //            "v": "0.000235",
        //            "S": 1,
        //            "T": 1678670940695,
        //            "t": "9f6a47fb926442e496c5c4c104076ae3",
        //            "c": '',
        //            "i": "e2b9835d1b6745f8a10ab74a81a16d50",
        //            "m": 0,
        //            "st": 0
        //        },
        //        "s": "BTCUSDT",
        //        "t": 1678670940700
        //    }
        //    {
        //      channel: "spot@private.deals.v3.api.pb",
        //      symbol: "MXUSDT",
        //      sendTime: 1736417034332,
        //      privateDeals {
        //        price: "3.6962",
        //        quantity: "1",
        //        amount: "3.6962",
        //        tradeType: 2,
        //        tradeId: "505979017439002624X1",
        //        orderId: "C02__505979017439002624115",
        //        feeAmount: "0.0003998377369698171",
        //        feeCurrency: "MX",
        //        time: 1736417034280
        //      }
        // }
        //
        object messageHash = "myTrades";
        object data = this.safeDictN(message, new List<object>() {"d", "data", "privateDeals"});
        object futuresMarketId = this.safeString(data, "symbol");
        object marketId = this.safeString2(message, "s", "symbol", futuresMarketId);
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object trade = null;
        if (isTrue(getValue(market, "spot")))
        {
            trade = this.parseWsTrade(data, market);
        } else
        {
            trade = this.parseTrade(data, market);
        }
        object trades = this.myTrades;
        if (isTrue(isEqual(trades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            trades = new ArrayCacheBySymbolById(limit);
            this.myTrades = trades;
        }
        callDynamically(trades, "append", new object[] {trade});
        callDynamically(client as WebSocketClient, "resolve", new object[] {trades, messageHash});
        object symbolSpecificMessageHash = add(add(messageHash, ":"), symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {trades, symbolSpecificMessageHash});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        // public trade (protobuf)
        //    {
        //        "p": "20382.70",
        //        "v": "0.043800",
        //        "S": 1,
        //        "t": 1678593222456,
        //    }
        // private trade
        //    {
        //        "S": 1,
        //        "T": 1661938980268,
        //        "c": "",
        //        "i": "c079b0fcb80a46e8b128b281ce4e4f38",
        //        "m": 1,
        //        "p": "1.008",
        //        "st": 0,
        //        "t": "4079b1522a0b40e7919f609e1ea38d44",
        //        "v": "5"
        //    }
        //
        //   d: {
        //       p: '1.0005',
        //       v: '5.71',
        //       a: '5.712855',
        //       S: 1,
        //       T: 1714325698237,
        //       t: 'edafcd9fdc2f426e82443d114691f724',
        //       c: '',
        //       i: 'C02__413321238354677760043',
        //       m: 0,
        //       st: 0,
        //       n: '0.005712855',
        //       N: 'USDT'
        //   }
        // protobuf
        //
        //     {
        //        price: "3.6962",
        //        quantity: "1",
        //        amount: "3.6962",
        //        tradeType: 2,
        //        tradeId: "505979017439002624X1",
        //        orderId: "C02__505979017439002624115",
        //        feeAmount: "0.0003998377369698171",
        //        feeCurrency: "MX",
        //        time: 1736417034280
        //      }
        //
        object timestamp = this.safeInteger2(trade, "T", "time");
        object tradeId = this.safeString2(trade, "t", "tradeId");
        if (isTrue(isEqual(timestamp, null)))
        {
            timestamp = this.safeInteger(trade, "t");
            tradeId = null;
        }
        object priceString = this.safeString2(trade, "p", "price");
        object amountString = this.safeString2(trade, "v", "quantity");
        object rawSide = this.safeString2(trade, "S", "tradeType");
        object side = ((bool) isTrue((isEqual(rawSide, "1")))) ? "buy" : "sell";
        object isMaker = this.safeInteger(trade, "m");
        object feeAmount = this.safeString2(trade, "n", "feeAmount");
        object feeCurrencyId = this.safeString2(trade, "N", "feeCurrency");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", tradeId },
            { "order", this.safeString2(trade, "i", "orderId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", this.safeSymbol(null, market) },
            { "type", null },
            { "side", side },
            { "takerOrMaker", ((bool) isTrue((isMaker))) ? "maker" : "taker" },
            { "price", priceString },
            { "amount", amountString },
            { "cost", this.safeString(trade, "amount") },
            { "fee", new Dictionary<string, object>() {
                { "cost", feeAmount },
                { "currency", this.safeCurrencyCode(feeCurrencyId) },
            } },
        }, market);
    }

    /**
     * @method
     * @name mexc#watchOrders
     * @see https://www.mexc.com/api-docs/spot-v3/websocket-user-data-streams#spot-account-orders
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#margin-account-orders
     * @description watches information on multiple orders made by the user
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string|undefined} params.type the type of orders to retrieve, can be 'spot' or 'margin'
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object messageHash = "orders";
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            messageHash = add(add(messageHash, ":"), symbol);
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object orders = null;
        if (isTrue(isEqual(type, "spot")))
        {
            object channel = "spot@private.orders.v3.api.pb";
            orders = await this.watchSpotPrivate(channel, messageHash, parameters);
        } else
        {
            orders = await this.watchSwapPrivate(messageHash, parameters);
        }
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        //
        // spot
        //    {
        //        "c": "spot@private.orders.v3.api",
        //        "d": {
        //              "A":8.0,
        //              "O":1661938138000,
        //              "S":1,
        //              "V":10,
        //              "a":8,
        //              "c":"",
        //              "i":"e03a5c7441e44ed899466a7140b71391",
        //              "m":0,
        //              "o":1,
        //              "p":0.8,
        //              "s":1,
        //              "v":10,
        //              "ap":0,
        //              "cv":0,
        //              "ca":0
        //        },
        //        "s": "MXUSDT",
        //        "t": 1661938138193
        //    }
        // spot - stop
        //    {
        //        "c": "spot@private.orders.v3.api",
        //        "d": {
        //              "N":"USDT",
        //              "O":1661938853715,
        //              "P":0.9,
        //              "S":1,
        //              "T":"LE",
        //              "i":"f6d82e5f41d745f59fe9d3cafffd80b5",
        //              "o":100,
        //              "p":1.01,
        //              "s":"NEW",
        //              "v":6
        //        },
        //        "s": "MXUSDT",
        //        "t": 1661938853727
        //    }
        // margin
        //    {
        //        "c": "margin@private.orders.v3.api",
        //        "d":{
        //             "O":1661938138000,
        //             "p":"0.8",
        //             "a":"8",
        //             "v":"10",
        //            "da":"0",
        //            "dv":"0",
        //             "A":"8.0",
        //             "V":"10",
        //             "n": "0",
        //             "N": "USDT",
        //             "S":1,
        //             "o":1,
        //             "s":1,
        //             "i":"e03a5c7441e44ed899466a7140b71391",
        //        },
        //        "s": "MXUSDT",
        //        "t":1661938138193
        //    }
        // protobuf
        //   {
        //      channel: "spot@private.orders.v3.api.pb",
        //      symbol: "MXUSDT",
        //      sendTime: 1736417034281,
        //      privateOrders {}
        //   }
        //
        object messageHash = "orders";
        object data = this.safeDictN(message, new List<object>() {"d", "data", "privateOrders"});
        object futuresMarketId = this.safeString(data, "symbol");
        object marketId = this.safeString2(message, "s", "symbol", futuresMarketId);
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object parsed = null;
        if (isTrue(getValue(market, "spot")))
        {
            parsed = this.parseWsOrder(data, market);
        } else
        {
            parsed = this.parseOrder(data, market);
        }
        object orders = this.orders;
        if (isTrue(isEqual(orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            orders = new ArrayCacheBySymbolById(limit);
            this.orders = orders;
        }
        callDynamically(orders, "append", new object[] {parsed});
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
        object symbolSpecificMessageHash = add(add(messageHash, ":"), symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, symbolSpecificMessageHash});
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        // spot
        //     {
        //          "A":8.0,
        //          "O":1661938138000,
        //          "S":1,
        //          "V":10,
        //          "a":8,
        //          "c":"",
        //          "i":"e03a5c7441e44ed899466a7140b71391",
        //          "m":0,
        //          "o":1,
        //          "p":0.8,
        //          "s":1,
        //          "v":10,
        //          "ap":0,
        //          "cv":0,
        //          "ca":0
        //    }
        // spot - stop
        //    {
        //        "N":"USDT",
        //        "O":1661938853715,
        //        "P":0.9,
        //        "S":1,
        //        "T":"LE",
        //        "i":"f6d82e5f41d745f59fe9d3cafffd80b5",
        //        "o":100,
        //        "p":1.01,
        //        "s":"NEW",
        //        "v":6
        //    }
        // margin
        //    {
        //        "O":1661938138000,
        //        "p":"0.8",
        //        "a":"8",
        //        "v":"10",
        //       "da":"0",
        //       "dv":"0",
        //        "A":"8.0",
        //        "V":"10",
        //        "n": "0",
        //        "N": "USDT",
        //        "S":1,
        //        "o":1,
        //        "s":1,
        //        "i":"e03a5c7441e44ed899466a7140b71391",
        //    }
        // protofbuf spot order
        // {
        //     "id":"C02__583905164440776704043",
        //     "price":"0.001053",
        //     "quantity":"2000",
        //     "amount":"0",
        //     "avgPrice":"0.001007",
        //     "orderType":5,
        //     "tradeType":1,
        //     "remainAmount":"0.092",
        //     "remainQuantity":"0",
        //     "lastDealQuantity":"2000",
        //     "cumulativeQuantity":"2000",
        //     "cumulativeAmount":"2.014",
        //     "status":2,
        //     "createTime":"1754996075502"
        // }
        //
        object timestamp = this.safeInteger(order, "createTime");
        object side = this.safeString(order, "tradeType");
        object status = this.safeString(order, "status");
        object type = this.safeString(order, "orderType");
        object fee = null;
        object feeCurrency = this.safeString(order, "N");
        if (isTrue(!isEqual(feeCurrency, null)))
        {
            fee = new Dictionary<string, object>() {
                { "currency", feeCurrency },
                { "cost", null },
            };
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(order, "id") },
            { "clientOrderId", this.safeString(order, "clientId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "status", this.parseWsOrderStatus(status, market) },
            { "symbol", this.safeSymbol(null, market) },
            { "type", this.parseWsOrderType(type) },
            { "timeInForce", this.parseWsTimeInForce(type) },
            { "side", ((bool) isTrue((isEqual(side, "1")))) ? "buy" : "sell" },
            { "price", this.safeString(order, "price") },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "average", this.safeString(order, "avgPrice") },
            { "amount", this.safeString(order, "quantity") },
            { "cost", this.safeString(order, "amount") },
            { "filled", this.safeString(order, "cumulativeQuantity") },
            { "remaining", this.safeString(order, "remainQuantity") },
            { "fee", fee },
            { "trades", null },
            { "info", order },
        }, market);
    }

    public virtual object parseWsOrderStatus(object status, object market = null)
    {
        object statuses = new Dictionary<string, object>() {
            { "1", "open" },
            { "2", "closed" },
            { "3", "open" },
            { "4", "canceled" },
            { "5", "closed" },
            { "NEW", "open" },
            { "CANCELED", "canceled" },
            { "EXECUTED", "closed" },
            { "FAILED", "rejected" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseWsOrderType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "1", "limit" },
            { "2", "limit" },
            { "3", null },
            { "4", null },
            { "5", "market" },
            { "100", "limit" },
        };
        return this.safeString(types, type);
    }

    public virtual object parseWsTimeInForce(object timeInForce)
    {
        object timeInForceIds = new Dictionary<string, object>() {
            { "1", "GTC" },
            { "2", "PO" },
            { "3", "IOC" },
            { "4", "FOK" },
            { "5", "GTC" },
            { "100", "GTC" },
        };
        return this.safeString(timeInForceIds, timeInForce);
    }

    /**
     * @method
     * @name mexc#watchBalance
     * @see https://www.mexc.com/api-docs/spot-v3/websocket-user-data-streams#spot-account-update
     * @description watch balance and get the amount of funds available for trading or funds locked in orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object messageHash = add("balance:", type);
        if (isTrue(isEqual(type, "spot")))
        {
            object channel = "spot@private.account.v3.api.pb";
            return await this.watchSpotPrivate(channel, messageHash, parameters);
        } else
        {
            return await this.watchSwapPrivate(messageHash, parameters);
        }
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //    {
        //        channel: "spot@private.account.v3.api.pb",
        //        createTime: "1758134605364",
        //        sendTime: "1758134605373",
        //        privateAccount: {
        //          vcoinName: "USDT",
        //          coinId: "128f589271cb4951b03e71e6323eb7be",
        //          balanceAmount: "0.006016465074677006",
        //          balanceAmountChange: "-4.4022",
        //          frozenAmount: "4.4022",
        //          frozenAmountChange: "4.4022",
        //          type: "ENTRUST_PLACE",
        //          time: "1758134605364",
        //       }
        //    }
        //
        //
        // swap balance
        //
        //     {
        //         "channel": "push.personal.asset",
        //         "data": {
        //             "availableBalance": 67.2426683348,
        //             "bonus": 0,
        //             "currency": "USDT",
        //             "frozenBalance": 0,
        //             "positionMargin": 1.36945756
        //         },
        //         "ts": 1680059188190
        //     }
        //
        object channel = this.safeString(message, "channel");
        object type = ((bool) isTrue((isEqual(channel, "spot@private.account.v3.api.pb")))) ? "spot" : "swap";
        object messageHash = add("balance:", type);
        object data = this.safeDictN(message, new List<object>() {"data", "privateAccount"});
        object futuresTimestamp = this.safeInteger2(message, "ts", "createTime");
        object timestamp = this.safeInteger2(data, "time", futuresTimestamp);
        if (!isTrue((inOp(this.balance, type))))
        {
            ((IDictionary<string,object>)this.balance)[(string)type] = new Dictionary<string, object>() {};
        }
        ((IDictionary<string,object>)getValue(this.balance, type))["info"] = data;
        ((IDictionary<string,object>)getValue(this.balance, type))["timestamp"] = timestamp;
        ((IDictionary<string,object>)getValue(this.balance, type))["datetime"] = this.iso8601(timestamp);
        object currencyId = this.safeStringN(data, new List<object>() {"currency", "vcoinName"});
        object code = this.safeCurrencyCode(currencyId);
        object account = this.account();
        ((IDictionary<string,object>)account)["free"] = this.safeString2(data, "balanceAmount", "availableBalance");
        ((IDictionary<string,object>)account)["used"] = this.safeStringN(data, new List<object>() {"frozenBalance", "frozenAmount"});
        ((IDictionary<string,object>)getValue(this.balance, type))[(string)code] = account;
        ((IDictionary<string,object>)this.balance)[(string)type] = this.safeBalance(getValue(this.balance, type));
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, type), messageHash});
    }

    /**
     * @method
     * @name mexc#unWatchTicker
     * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> unWatchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object messageHash = add("unsubscribe:ticker:", getValue(market, "symbol"));
        object url = null;
        object channel = null;
        if (isTrue(getValue(market, "spot")))
        {
            channel = add("spot@public.aggre.bookTicker.v3.api.pb@100ms@", getValue(market, "id"));
            url = getValue(getValue(getValue(this.urls, "api"), "ws"), "spot");
            ((IDictionary<string,object>)parameters)["unsubscribed"] = true;
            this.watchSpotPublic(channel, messageHash, parameters);
        } else
        {
            channel = "unsub.ticker";
            object requestParams = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
            };
            url = getValue(getValue(getValue(this.urls, "api"), "ws"), "swap");
            this.watchSwapPublic(channel, messageHash, requestParams, parameters);
        }
        var client = this.client(url);
        this.handleUnsubscriptions(client as WebSocketClient, new List<object>() {messageHash});
        return null;
    }

    /**
     * @method
     * @name mexc#unWatchTickers
     * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> unWatchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null);
        object messageHashes = new List<object>() {};
        object firstSymbol = this.safeString(symbols, 0);
        object market = null;
        if (isTrue(!isEqual(firstSymbol, null)))
        {
            market = this.market(firstSymbol);
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchTickers", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object isSpot = (isEqual(type, "spot"));
        object url = ((bool) isTrue((isSpot))) ? getValue(getValue(getValue(this.urls, "api"), "ws"), "spot") : getValue(getValue(getValue(this.urls, "api"), "ws"), "swap");
        object request = new Dictionary<string, object>() {};
        if (isTrue(isSpot))
        {
            throw new NotSupported ((string)add(this.id, " watchTickers does not support spot markets")) ;
        } else
        {
            ((IDictionary<string,object>)request)["method"] = "unsub.tickers";
            ((IDictionary<string,object>)request)["params"] = new Dictionary<string, object>() {};
            ((IList<object>)messageHashes).Add("unsubscribe:ticker");
        }
        var client = this.client(url);
        this.watchMultiple(url, messageHashes, this.extend(request, parameters), messageHashes);
        this.handleUnsubscriptions(client as WebSocketClient, messageHashes);
        return null;
    }

    /**
     * @method
     * @name mexc#unWatchBidsAsks
     * @description unWatches best bid & ask for symbols
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async virtual Task<object> unWatchBidsAsks(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, true, false, true);
        object marketType = null;
        if (isTrue(isEqual(symbols, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchBidsAsks required symbols argument")) ;
        }
        object markets = this.marketsForSymbols(symbols);
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("watchBidsAsks", getValue(markets, 0), parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object isSpot = isEqual(marketType, "spot");
        if (!isTrue(isSpot))
        {
            throw new NotSupported ((string)add(this.id, " watchBidsAsks only support spot market")) ;
        }
        object messageHashes = new List<object>() {};
        object topics = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            if (isTrue(isSpot))
            {
                object market = this.market(getValue(symbols, i));
                ((IList<object>)topics).Add(add("spot@public.aggre.bookTicker.v3.api.pb@100ms@", getValue(market, "id")));
            }
            ((IList<object>)messageHashes).Add(add("unsubscribe:bidask:", getValue(symbols, i)));
        }
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "spot");
        object request = new Dictionary<string, object>() {
            { "method", "UNSUBSCRIPTION" },
            { "params", topics },
        };
        var client = this.client(url);
        this.watchMultiple(url, messageHashes, this.extend(request, parameters), messageHashes);
        this.handleUnsubscriptions(client as WebSocketClient, messageHashes);
        return null;
    }

    /**
     * @method
     * @name mexc#unWatchOHLCV
     * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {object} [params.timezone] if provided, kline intervals are interpreted in that timezone instead of UTC, example '+08:00'
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async virtual Task<object> unWatchOHLCV(object symbol, object timeframe = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object timeframes = this.safeValue(this.options, "timeframes", new Dictionary<string, object>() {});
        object timeframeId = this.safeString(timeframes, timeframe);
        object messageHash = add(add(add("unsubscribe:candles:", symbol), ":"), timeframe);
        object url = null;
        if (isTrue(getValue(market, "spot")))
        {
            url = getValue(getValue(getValue(this.urls, "api"), "ws"), "spot");
            object channel = add(add(add("spot@public.kline.v3.api.pb@", getValue(market, "id")), "@"), timeframeId);
            ((IDictionary<string,object>)parameters)["unsubscribed"] = true;
            this.watchSpotPublic(channel, messageHash, parameters);
        } else
        {
            url = getValue(getValue(getValue(this.urls, "api"), "ws"), "swap");
            object channel = "unsub.kline";
            object requestParams = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
                { "interval", timeframeId },
            };
            this.watchSwapPublic(channel, messageHash, requestParams, parameters);
        }
        var client = this.client(url);
        this.handleUnsubscriptions(client as WebSocketClient, new List<object>() {messageHash});
        return null;
    }

    /**
     * @method
     * @name mexc#unWatchOrderBook
     * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @param {string} symbol unified array of symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.frequency] the frequency of the order book updates, default is '10ms', can be '100ms' or '10ms
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> unWatchOrderBook(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object messageHash = add("unsubscribe:orderbook:", symbol);
        object url = null;
        if (isTrue(getValue(market, "spot")))
        {
            url = getValue(getValue(getValue(this.urls, "api"), "ws"), "spot");
            object frequency = null;
            var frequencyparametersVariable = this.handleOptionAndParams(parameters, "watchOrderBook", "frequency", "100ms");
            frequency = ((IList<object>)frequencyparametersVariable)[0];
            parameters = ((IList<object>)frequencyparametersVariable)[1];
            object channel = add(add(add("spot@public.aggre.depth.v3.api.pb@", frequency), "@"), getValue(market, "id"));
            ((IDictionary<string,object>)parameters)["unsubscribed"] = true;
            this.watchSpotPublic(channel, messageHash, parameters);
        } else
        {
            url = getValue(getValue(getValue(this.urls, "api"), "ws"), "swap");
            object channel = "unsub.depth";
            object requestParams = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
            };
            this.watchSwapPublic(channel, messageHash, requestParams, parameters);
        }
        var client = this.client(url);
        this.handleUnsubscriptions(client as WebSocketClient, new List<object>() {messageHash});
        return null;
    }

    /**
     * @method
     * @name mexc#unWatchTrades
     * @description unsubscribes from the trades channel
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.name] the name of the method to call, 'trade' or 'aggTrade', default is 'trade'
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> unWatchTrades(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object messageHash = add("unsubscribe:trades:", symbol);
        object url = null;
        if (isTrue(getValue(market, "spot")))
        {
            url = getValue(getValue(getValue(this.urls, "api"), "ws"), "spot");
            object channel = add("spot@public.aggre.deals.v3.api.pb@100ms@", getValue(market, "id"));
            ((IDictionary<string,object>)parameters)["unsubscribed"] = true;
            this.watchSpotPublic(channel, messageHash, parameters);
        } else
        {
            url = getValue(getValue(getValue(this.urls, "api"), "ws"), "swap");
            object channel = "unsub.deal";
            object requestParams = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
            };
            this.watchSwapPublic(channel, messageHash, requestParams, parameters);
        }
        var client = this.client(url);
        this.handleUnsubscriptions(client as WebSocketClient, new List<object>() {messageHash});
        return null;
    }

    public virtual void handleUnsubscriptions(WebSocketClient client, object messageHashes)
    {
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object subMessageHash = ((string)messageHash).Replace((string)"unsubscribe:", (string)"");
            this.cleanUnsubscription(client as WebSocketClient, subMessageHash, messageHash);
            if (isTrue(isGreaterThanOrEqual(getIndexOf(messageHash, "ticker"), 0)))
            {
                object symbol = ((string)messageHash).Replace((string)"unsubscribe:ticker:", (string)"");
                if (isTrue(isGreaterThanOrEqual(getIndexOf(symbol, "unsubscribe"), 0)))
                {
                    // unWatchTickers
                    object symbols = new List<object>(((IDictionary<string,object>)this.tickers).Keys);
                    for (object j = 0; isLessThan(j, getArrayLength(symbols)); postFixIncrement(ref j))
                    {
                        ((IDictionary<string,object>)this.tickers).Remove((string)getValue(symbols, j));
                    }
                } else if (isTrue(inOp(this.tickers, symbol)))
                {
                    ((IDictionary<string,object>)this.tickers).Remove((string)symbol);
                }
            } else if (isTrue(isGreaterThanOrEqual(getIndexOf(messageHash, "bidask"), 0)))
            {
                object symbol = ((string)messageHash).Replace((string)"unsubscribe:bidask:", (string)"");
                if (isTrue(inOp(this.bidsasks, symbol)))
                {
                    ((IDictionary<string,object>)this.bidsasks).Remove((string)symbol);
                }
            } else if (isTrue(isGreaterThanOrEqual(getIndexOf(messageHash, "candles"), 0)))
            {
                object splitHashes = ((string)messageHash).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
                object symbol = this.safeString(splitHashes, 2);
                if (isTrue(isGreaterThan(getArrayLength(splitHashes), 4)))
                {
                    symbol = add(symbol, add(":", this.safeString(splitHashes, 3)));
                }
                if (isTrue(inOp(this.ohlcvs, symbol)))
                {
                    ((IDictionary<string,object>)this.ohlcvs).Remove((string)symbol);
                }
            } else if (isTrue(isGreaterThanOrEqual(getIndexOf(messageHash, "orderbook"), 0)))
            {
                object symbol = ((string)messageHash).Replace((string)"unsubscribe:orderbook:", (string)"");
                if (isTrue(inOp(this.orderbooks, symbol)))
                {
                    ((IDictionary<string,object>)this.orderbooks).Remove((string)symbol);
                }
            } else if (isTrue(isGreaterThanOrEqual(getIndexOf(messageHash, "trades"), 0)))
            {
                object symbol = ((string)messageHash).Replace((string)"unsubscribe:trades:", (string)"");
                if (isTrue(inOp(this.trades, symbol)))
                {
                    ((IDictionary<string,object>)this.trades).Remove((string)symbol);
                }
            }
        }
    }

    public async virtual Task<object> authenticate(object subscriptionHash, object parameters = null)
    {
        // we only need one listenKey since ccxt shares connections
        parameters ??= new Dictionary<string, object>();
        object listenKey = this.safeString(this.options, "listenKey");
        if (isTrue(!isEqual(listenKey, null)))
        {
            return listenKey;
        }
        object response = await this.spotPrivatePostUserDataStream(parameters);
        //
        //    {
        //        "listenKey": "pqia91ma19a5s61cv6a81va65sdf19v8a65a1a5s61cv6a81va65sdf19v8a65a1"
        //    }
        //
        listenKey = this.safeString(response, "listenKey");
        ((IDictionary<string,object>)this.options)["listenKey"] = listenKey;
        object listenKeyRefreshRate = this.safeInteger(this.options, "listenKeyRefreshRate", 1200000);
        this.delay(listenKeyRefreshRate,  this.keepAliveListenKey, new object[] { listenKey, parameters});
        return listenKey;
    }

    public async virtual Task keepAliveListenKey(object listenKey, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(listenKey, null)))
        {
            return;
        }
        object request = new Dictionary<string, object>() {
            { "listenKey", listenKey },
        };
        try
        {
            await this.spotPrivatePutUserDataStream(this.extend(request, parameters));
            object listenKeyRefreshRate = this.safeInteger(this.options, "listenKeyRefreshRate", 1200000);
            this.delay(listenKeyRefreshRate,  this.keepAliveListenKey, new object[] { listenKey, parameters});
        } catch(Exception error)
        {
            object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "spot"), "?listenKey="), listenKey);
            var client = this.client(url);
            ((IDictionary<string,object>)this.options)["listenKey"] = null;
            ((WebSocketClient)client).reject(error);
            ((IDictionary<string, ccxt.Exchange.WebSocketClient>)this.clients).Remove((string)url);
        }
    }

    public virtual object handlePong(WebSocketClient client, object message)
    {
        client.lastPong = this.milliseconds();
        return message;
    }

    public virtual void handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //    {
        //        "id": 0,
        //        "code": 0,
        //        "msg": "spot@public.increase.depth.v3.api@BTCUSDT"
        //    }
        // Set the default to an empty string if the message is empty during the test.
        object msg = this.safeString(message, "msg", "");
        if (isTrue(isEqual(msg, "PONG")))
        {
            this.handlePong(client as WebSocketClient, message);
        } else if (isTrue(isGreaterThan(getIndexOf(msg, "@"), -1)))
        {
            object parts = ((string)msg).Split(new [] {((string)"@")}, StringSplitOptions.None).ToList<object>();
            object channel = this.safeString(parts, 1);
            object methods = new Dictionary<string, object>() {
                { "public.increase.depth.v3.api", this.handleOrderBookSubscription },
                { "public.aggre.depth.v3.api.pb", this.handleOrderBookSubscription },
            };
            object method = this.safeValue(methods, channel);
            if (isTrue(!isEqual(method, null)))
            {
                DynamicInvoker.InvokeMethod(method, new object[] { client, message});
            }
        }
    }

    public virtual object handleProtobufMessage(WebSocketClient client, object message)
    {
        // protobuf message decoded
        //  {
        //    "channel":"spot@public.kline.v3.api.pb@BTCUSDT@Min1",
        //    "symbol":"BTCUSDT",
        //    "symbolId":"2fb942154ef44a4ab2ef98c8afb6a4a7",
        //    "createTime":"1754737941062",
        //    "publicSpotKline":{
        //       "interval":"Min1",
        //       "windowStart":"1754737920",
        //       "openingPrice":"117317.31",
        //       "closingPrice":"117325.26",
        //       "highestPrice":"117341",
        //       "lowestPrice":"117317.3",
        //       "volume":"3.12599854",
        //       "amount":"366804.43",
        //       "windowEnd":"1754737980"
        //    }
        // }
        object channel = this.safeString(message, "channel");
        object channelParts = ((string)channel).Split(new [] {((string)"@")}, StringSplitOptions.None).ToList<object>();
        object channelId = this.safeString(channelParts, 1);
        if (isTrue(isEqual(channelId, "public.kline.v3.api.pb")))
        {
            this.handleOHLCV(client as WebSocketClient, message);
        } else if (isTrue(isEqual(channelId, "public.aggre.deals.v3.api.pb")))
        {
            this.handleTrades(client as WebSocketClient, message);
        } else if (isTrue(isEqual(channelId, "public.aggre.bookTicker.v3.api.pb")))
        {
            this.handleTicker(client as WebSocketClient, message);
        } else if (isTrue(isEqual(channelId, "public.aggre.depth.v3.api.pb")))
        {
            this.handleOrderBook(client as WebSocketClient, message);
        } else if (isTrue(isEqual(channelId, "private.account.v3.api.pb")))
        {
            this.handleBalance(client as WebSocketClient, message);
        } else if (isTrue(isEqual(channelId, "private.deals.v3.api.pb")))
        {
            this.handleMyTrade(client as WebSocketClient, message);
        } else if (isTrue(isEqual(channelId, "private.orders.v3.api.pb")))
        {
            this.handleOrder(client as WebSocketClient, message);
        }
        return true;
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (isTrue((message is string)))
        {
            if (isTrue(isEqual(message, "Invalid listen key")))
            {
                var error = new AuthenticationError(add(this.id, " invalid listen key"));
                ((WebSocketClient)client).reject(error);
                return;
            }
        }
        if (isTrue(this.isBinaryMessage(message)))
        {
            message = this.decodeProtoMsg(message);
            this.handleProtobufMessage(client as WebSocketClient, message);
            return;
        }
        if (isTrue(inOp(message, "msg")))
        {
            this.handleSubscriptionStatus(client as WebSocketClient, message);
            return;
        }
        object c = this.safeString(message, "c");
        object channel = null;
        if (isTrue(isEqual(c, null)))
        {
            channel = this.safeString(message, "channel");
        } else
        {
            object parts = ((string)c).Split(new [] {((string)"@")}, StringSplitOptions.None).ToList<object>();
            channel = this.safeString(parts, 1);
        }
        object methods = new Dictionary<string, object>() {
            { "public.deals.v3.api", this.handleTrades },
            { "push.deal", this.handleTrades },
            { "public.kline.v3.api", this.handleOHLCV },
            { "push.kline", this.handleOHLCV },
            { "public.bookTicker.v3.api", this.handleTicker },
            { "public.miniTicker.v3.api", this.handleTicker },
            { "public.miniTickers.v3.api", this.handleTickers },
            { "push.ticker", this.handleTicker },
            { "push.tickers", this.handleTickers },
            { "public.increase.depth.v3.api", this.handleOrderBook },
            { "push.depth", this.handleOrderBook },
            { "private.orders.v3.api", this.handleOrder },
            { "push.personal.order", this.handleOrder },
            { "private.account.v3.api", this.handleBalance },
            { "push.personal.asset", this.handleBalance },
            { "private.deals.v3.api", this.handleMyTrade },
            { "push.personal.order.deal", this.handleMyTrade },
            { "pong", this.handlePong },
        };
        if (isTrue(inOp(methods, channel)))
        {
            object method = getValue(methods, channel);
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
    }

    public override object ping(WebSocketClient client)
    {
        return new Dictionary<string, object>() {
            { "method", "ping" },
        };
    }
}
