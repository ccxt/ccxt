namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class exmo { public exmo(object args = null) : base(args) { } }
public partial class exmo : ccxt.exmo
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchBalance", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchTrades", true },
                { "watchMyTrades", true },
                { "watchOrders", false },
                { "watchOrderBook", true },
                { "watchOHLCV", false },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://ws-api.exmo.com:443/v1/public" },
                        { "spot", "wss://ws-api.exmo.com:443/v1/private" },
                        { "margin", "wss://ws-api.exmo.com:443/v1/margin/private" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {} },
            { "streaming", new Dictionary<string, object>() {} },
            { "exceptions", new Dictionary<string, object>() {} },
        });
    }

    public virtual object requestId()
    {
        object requestId = this.sum(this.safeInteger(this.options, "requestId", 0), 1);
        ((IDictionary<string,object>)this.options)["requestId"] = requestId;
        return requestId;
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @name exmo#watchBalance
        * @description watch balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.authenticate(parameters);
        var typequeryVariable = this.handleMarketTypeAndParams("watchBalance", null, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        object messageHash = add("balance:", type);
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), type);
        object subscribe = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "topics", new List<object>() {add(type, "/wallet")} },
            { "id", this.requestId() },
        };
        object request = this.deepExtend(subscribe, query);
        return await this.watch(url, messageHash, request, messageHash, request);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        //  spot
        //     {
        //         "ts": 1654208766007,
        //         "event": "snapshot",
        //         "topic": "spot/wallet",
        //         "data": {
        //             "balances": {
        //                 "ADA": "0",
        //                 "ALGO": "0",
        //                 ...
        //             },
        //             "reserved": {
        //                 "ADA": "0",
        //                 "ALGO": "0",
        //                 ...
        //             }
        //         }
        //     }
        //
        //  margin
        //     {
        //         "ts": 1624370076651,
        //         "event": "snapshot",
        //         "topic": "margin/wallets",
        //         "data": {
        //             "RUB": {
        //                 "balance": "1000000",
        //                 "used": "0",
        //                 "free": "1000000"
        //             },
        //             "USD": {
        //                 "balance": "1000000",
        //                 "used": "1831.925",
        //                 "free": "998168.075"
        //             }
        //         }
        //     }
        //     {
        //         "ts": 1624370185720,
        //         "event": "update",
        //         "topic": "margin/wallets",
        //         "data": {
        //             "USD": {
        //                 "balance": "1000123",
        //                 "used": "1831.925",
        //                 "free": "998291.075"
        //             }
        //         }
        //     }
        //
        object topic = this.safeString(message, "topic");
        object parts = ((string)topic).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
        object type = this.safeString(parts, 0);
        if (isTrue(isEqual(type, "spot")))
        {
            this.parseSpotBalance(message);
        } else if (isTrue(isEqual(type, "margin")))
        {
            this.parseMarginBalance(message);
        }
        object messageHash = add("balance:", type);
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, messageHash});
    }

    public virtual void parseSpotBalance(object message)
    {
        //
        //     {
        //         "balances": {
        //             "BTC": "3",
        //             "USD": "1000",
        //             "RUB": "0"
        //         },
        //         "reserved": {
        //             "BTC": "0.5",
        //             "DASH": "0",
        //             "RUB": "0"
        //         }
        //     }
        //
        object eventVar = this.safeString(message, "event");
        object data = this.safeValue(message, "data");
        ((IDictionary<string,object>)this.balance)["info"] = data;
        if (isTrue(isEqual(eventVar, "snapshot")))
        {
            object balances = this.safeValue(data, "balances", new Dictionary<string, object>() {});
            object reserved = this.safeValue(data, "reserved", new Dictionary<string, object>() {});
            object currencies = new List<object>(((IDictionary<string,object>)balances).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
            {
                object currencyId = getValue(currencies, i);
                object code = this.safeCurrencyCode(currencyId);
                object account = this.account();
                ((IDictionary<string,object>)account)["free"] = this.safeString(balances, currencyId);
                ((IDictionary<string,object>)account)["used"] = this.safeString(reserved, currencyId);
                ((IDictionary<string,object>)this.balance)[(string)code] = account;
            }
        } else if (isTrue(isEqual(eventVar, "update")))
        {
            object currencyId = this.safeString(data, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(data, "balance");
            ((IDictionary<string,object>)account)["used"] = this.safeString(data, "reserved");
            ((IDictionary<string,object>)this.balance)[(string)code] = account;
        }
        this.balance = this.safeBalance(this.balance);
    }

    public virtual void parseMarginBalance(object message)
    {
        //
        //     {
        //         "RUB": {
        //             "balance": "1000000",
        //             "used": "0",
        //             "free": "1000000"
        //         },
        //         "USD": {
        //             "balance": "1000000",
        //             "used": "1831.925",
        //             "free": "998168.075"
        //         }
        //     }
        //
        object data = this.safeValue(message, "data");
        ((IDictionary<string,object>)this.balance)["info"] = data;
        object currencies = new List<object>(((IDictionary<string,object>)data).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencies, i);
            object code = this.safeCurrencyCode(currencyId);
            object wallet = this.safeValue(data, currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(wallet, "free");
            ((IDictionary<string,object>)account)["used"] = this.safeString(wallet, "used");
            ((IDictionary<string,object>)account)["total"] = this.safeString(wallet, "balance");
            ((IDictionary<string,object>)this.balance)[(string)code] = account;
            this.balance = this.safeBalance(this.balance);
        }
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name exmo#watchTicker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#fd8f47bc-8517-43c0-bb60-1d61a86d4471
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "public");
        object messageHash = add("ticker:", symbol);
        object message = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "topics", new List<object>() {add("spot/ticker:", getValue(market, "id"))} },
            { "id", this.requestId() },
        };
        object request = this.deepExtend(message, parameters);
        return await this.watch(url, messageHash, request, messageHash, request);
    }

    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#watchTickers
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#fd8f47bc-8517-43c0-bb60-1d61a86d4471
        * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object messageHashes = new List<object>() {};
        object args = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object market = this.market(getValue(symbols, i));
            ((IList<object>)messageHashes).Add(add("ticker:", getValue(market, "symbol")));
            ((IList<object>)args).Add(add("spot/ticker:", getValue(market, "id")));
        }
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "public");
        object message = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "topics", args },
            { "id", this.requestId() },
        };
        object request = this.deepExtend(message, parameters);
        await this.watchMultiple(url, messageHashes, request, messageHashes, request);
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        //  spot
        //      {
        //          "ts": 1654205085473,
        //          "event": "update",
        //          "topic": "spot/ticker:BTC_USDT",
        //          "data": {
        //              "buy_price": "30285.84",
        //              "sell_price": "30299.97",
        //              "last_trade": "30295.01",
        //              "high": "30386.7",
        //              "low": "29542.76",
        //              "avg": "29974.16178449",
        //              "vol": "118.79538518",
        //              "vol_curr": "3598907.38200826",
        //              "updated": 1654205084
        //          }
        //      }
        //
        object topic = this.safeString(message, "topic");
        object topicParts = ((string)topic).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(topicParts, 1);
        object symbol = this.safeSymbol(marketId);
        object ticker = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object market = this.safeMarket(marketId);
        object parsedTicker = this.parseTicker(ticker, market);
        object messageHash = add("ticker:", symbol);
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = parsedTicker;
        callDynamically(client as WebSocketClient, "resolve", new object[] {parsedTicker, messageHash});
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#watchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "public");
        object messageHash = add("trades:", symbol);
        object message = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "topics", new List<object>() {add("spot/trades:", getValue(market, "id"))} },
            { "id", this.requestId() },
        };
        object request = this.deepExtend(message, parameters);
        object trades = await this.watch(url, messageHash, request, messageHash, request);
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        //      {
        //          "ts": 1654206084001,
        //          "event": "update",
        //          "topic": "spot/trades:BTC_USDT",
        //          "data": [{
        //              "trade_id": 389704729,
        //              "type": "sell",
        //              "price": "30310.95",
        //              "quantity": "0.0197",
        //              "amount": "597.125715",
        //              "date": 1654206083
        //          }]
        //      }
        //
        object topic = this.safeString(message, "topic");
        object parts = ((string)topic).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(parts, 1);
        object symbol = this.safeSymbol(marketId);
        object market = this.safeMarket(marketId);
        object trades = this.safeValue(message, "data", new List<object>() {});
        object messageHash = add("trades:", symbol);
        object stored = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
        {
            object trade = getValue(trades, i);
            object parsed = this.parseTrade(trade, market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.trades, symbol), messageHash});
    }

    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#watchTrades
        * @description get the list of trades associated with the user
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate(parameters);
        var typequeryVariable = this.handleMarketTypeAndParams("watchMyTrades", null, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), type);
        object messageHash = null;
        if (isTrue(isEqual(symbol, null)))
        {
            messageHash = add("myTrades:", type);
        } else
        {
            object market = this.market(symbol);
            symbol = getValue(market, "symbol");
            messageHash = add("myTrades:", getValue(market, "symbol"));
        }
        object message = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "topics", new List<object>() {add(type, "/user_trades")} },
            { "id", this.requestId() },
        };
        object request = this.deepExtend(message, query);
        object trades = await this.watch(url, messageHash, request, messageHash, request);
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleMyTrades(WebSocketClient client, object message)
    {
        //
        //  spot
        //     {
        //         "ts": 1654210290219,
        //         "event": "update",
        //         "topic": "spot/user_trades",
        //         "data": {
        //             "trade_id": 389715807,
        //             "type": "buy",
        //             "price": "30527.77",
        //             "quantity": "0.0001",
        //             "amount": "3.052777",
        //             "date": 1654210290,
        //             "order_id": 27352777112,
        //             "client_id": 0,
        //             "pair": "BTC_USDT",
        //             "exec_type": "taker",
        //             "commission_amount": "0.0000001",
        //             "commission_currency": "BTC",
        //             "commission_percent": "0.1"
        //         }
        //     }
        //
        //  margin
        //     {
        //         "ts":1624369720168,
        //         "event":"snapshot",
        //         "topic":"margin/user_trades",
        //         "data":[
        //            {
        //               "trade_id":"692844278081167054",
        //               "trade_dt":"1624369773990729200",
        //               "type":"buy",
        //               "order_id":"692844278081167033",
        //               "pair":"BTC_USD",
        //               "quantity":"0.1",
        //               "price":"36638.5",
        //               "is_maker":false
        //            }
        //         ]
        //     }
        //     {
        //         "ts":1624370368612,
        //         "event":"update",
        //         "topic":"margin/user_trades",
        //         "data":{
        //            "trade_id":"692844278081167693",
        //            "trade_dt":"1624370368569092500",
        //            "type":"buy",
        //            "order_id":"692844278081167674",
        //            "pair":"BTC_USD",
        //            "quantity":"0.1",
        //            "price":"36638.5",
        //            "is_maker":false
        //         }
        //     }
        //
        object topic = this.safeString(message, "topic");
        object parts = ((string)topic).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
        object type = this.safeString(parts, 0);
        object messageHash = add("myTrades:", type);
        object eventVar = this.safeString(message, "event");
        object rawTrades = new List<object>() {};
        object myTrades = null;
        if (isTrue(isEqual(this.myTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            myTrades = new ArrayCacheBySymbolById(limit);
            this.myTrades = myTrades;
        } else
        {
            myTrades = this.myTrades;
        }
        if (isTrue(isEqual(eventVar, "snapshot")))
        {
            rawTrades = this.safeValue(message, "data", new List<object>() {});
        } else if (isTrue(isEqual(eventVar, "update")))
        {
            object rawTrade = this.safeValue(message, "data", new Dictionary<string, object>() {});
            rawTrades = new List<object>() {rawTrade};
        }
        object trades = this.parseTrades(rawTrades);
        object symbols = new Dictionary<string, object>() {};
        for (object j = 0; isLessThan(j, getArrayLength(trades)); postFixIncrement(ref j))
        {
            object trade = getValue(trades, j);
            callDynamically(myTrades, "append", new object[] {trade});
            ((IDictionary<string,object>)symbols)[(string)getValue(trade, "symbol")] = true;
        }
        object symbolKeys = new List<object>(((IDictionary<string,object>)symbols).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(symbolKeys)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbolKeys, i);
            object symbolSpecificMessageHash = add("myTrades:", symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {myTrades, symbolSpecificMessageHash});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {myTrades, messageHash});
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#watchOrderBook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "public");
        object messageHash = add("orderbook:", symbol);
        parameters = this.omit(parameters, "aggregation");
        object subscribe = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "id", this.requestId() },
            { "topics", new List<object>() {add("spot/order_book_updates:", getValue(market, "id"))} },
        };
        object request = this.deepExtend(subscribe, parameters);
        object orderbook = await this.watch(url, messageHash, request, messageHash);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //     {
        //         "ts": 1574427585174,
        //         "event": "snapshot",
        //         "topic": "spot/order_book_updates:BTC_USD",
        //         "data": {
        //             "ask": [
        //                 ["100", "3", "300"],
        //                 ["200", "4", "800"]
        //             ],
        //             "bid": [
        //                 ["99", "2", "198"],
        //                 ["98", "1", "98"]
        //             ]
        //         }
        //     }
        //
        //     {
        //         "ts": 1574427585174,
        //         "event": "update",
        //         "topic": "spot/order_book_updates:BTC_USD",
        //         "data": {
        //             "ask": [
        //                 ["100", "1", "100"],
        //                 ["200", "2", "400"]
        //             ],
        //             "bid": [
        //                 ["99", "1", "99"],
        //                 ["98", "0", "0"]
        //             ]
        //         }
        //     }
        //
        object topic = this.safeString(message, "topic");
        object parts = ((string)topic).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(parts, 1);
        object symbol = this.safeSymbol(marketId);
        object orderBook = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object messageHash = add("orderbook:", symbol);
        object timestamp = this.safeInteger(message, "ts");
        if (!isTrue((inOp(this.orderbooks, symbol))))
        {
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {});
        }
        object orderbook = getValue(this.orderbooks, symbol);
        object eventVar = this.safeString(message, "event");
        if (isTrue(isEqual(eventVar, "snapshot")))
        {
            object snapshot = this.parseOrderBook(orderBook, symbol, timestamp, "bid", "ask");
            (orderbook as IOrderBook).reset(snapshot);
        } else
        {
            object asks = this.safeList(orderBook, "ask", new List<object>() {});
            object bids = this.safeList(orderBook, "bid", new List<object>() {});
            this.handleDeltas(getValue(orderbook, "asks"), asks);
            this.handleDeltas(getValue(orderbook, "bids"), bids);
            ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public override void handleDelta(object bookside, object delta)
    {
        object bidAsk = this.parseBidAsk(delta, 0, 1);
        (bookside as IOrderBookSide).storeArray(bidAsk);
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        //
        // {
        //     "ts": 1654206362552,
        //     "event": "info",
        //     "code": 1,
        //     "message": "connection established",
        //     "session_id": "7548931b-c2a4-45dd-8d71-877881a7251a"
        // }
        //
        // {
        //     "ts": 1654206491399,
        //     "event": "subscribed",
        //     "id": 1,
        //     "topic": "spot/ticker:BTC_USDT"
        // }
        object eventVar = this.safeString(message, "event");
        object events = new Dictionary<string, object>() {
            { "logged_in", this.handleAuthenticationMessage },
            { "info", this.handleInfo },
            { "subscribed", this.handleSubscribed },
        };
        object eventHandler = this.safeValue(events, eventVar);
        if (isTrue(!isEqual(eventHandler, null)))
        {
            DynamicInvoker.InvokeMethod(eventHandler, new object[] { client, message});
            return;
        }
        if (isTrue(isTrue((isEqual(eventVar, "update"))) || isTrue((isEqual(eventVar, "snapshot")))))
        {
            object topic = this.safeString(message, "topic");
            if (isTrue(!isEqual(topic, null)))
            {
                object parts = ((string)topic).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
                object channel = this.safeString(parts, 0);
                object handlers = new Dictionary<string, object>() {
                    { "spot/ticker", this.handleTicker },
                    { "spot/wallet", this.handleBalance },
                    { "margin/wallet", this.handleBalance },
                    { "margin/wallets", this.handleBalance },
                    { "spot/trades", this.handleTrades },
                    { "margin/trades", this.handleTrades },
                    { "spot/order_book_updates", this.handleOrderBook },
                    { "spot/user_trades", this.handleMyTrades },
                    { "margin/user_trades", this.handleMyTrades },
                };
                object handler = this.safeValue(handlers, channel);
                if (isTrue(!isEqual(handler, null)))
                {
                    DynamicInvoker.InvokeMethod(handler, new object[] { client, message});
                    return;
                }
            }
        }
        throw new NotSupported ((string)add(add(this.id, " received an unsupported message: "), this.json(message))) ;
    }

    public virtual object handleSubscribed(WebSocketClient client, object message)
    {
        //
        // {
        //     "method": "subscribe",
        //     "id": 2,
        //     "topics": ["spot/orders"]
        // }
        //
        return message;
    }

    public virtual object handleInfo(WebSocketClient client, object message)
    {
        //
        // {
        //     "ts": 1654215731659,
        //     "event": "info",
        //     "code": 1,
        //     "message": "connection established",
        //     "session_id": "4c496262-e259-4c27-b805-f20b46209c17"
        // }
        //
        return message;
    }

    public virtual void handleAuthenticationMessage(WebSocketClient client, object message)
    {
        //
        //     {
        //         "method": "login",
        //         "id": 1,
        //         "api_key": "K-************************",
        //         "sign": "******************************************************************",
        //         "nonce": 1654215729887
        //     }
        //
        object messageHash = "authenticated";
        callDynamically(client as WebSocketClient, "resolve", new object[] {message, messageHash});
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object messageHash = "authenticated";
        var typequeryVariable = this.handleMarketTypeAndParams("authenticate", null, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), type);
        var client = this.client(url);
        var future = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(future, null)))
        {
            object time = this.milliseconds();
            this.checkRequiredCredentials();
            object requestId = this.requestId();
            object signData = add(this.apiKey, ((object)time).ToString());
            object sign = this.hmac(this.encode(signData), this.encode(this.secret), sha512, "base64");
            object request = new Dictionary<string, object>() {
                { "method", "login" },
                { "id", requestId },
                { "api_key", this.apiKey },
                { "sign", sign },
                { "nonce", time },
            };
            object message = this.extend(request, query);
            future = await this.watch(url, messageHash, message, messageHash);
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)messageHash] = future;
        }
        return future;
    }
}
