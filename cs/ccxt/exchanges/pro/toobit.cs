namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class toobit { public toobit(object args = null) : base(args) { } }
public partial class toobit : ccxt.toobit
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchBalance", true },
                { "watchMyTrades", true },
                { "watchOHLCV", true },
                { "watchOHLCVForSymbols", true },
                { "watchOrderBook", true },
                { "watchOrderBookForSymbols", true },
                { "watchOrders", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "common", "wss://stream.toobit.com" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "ws", new Dictionary<string, object>() {
                    { "timeframes", new Dictionary<string, object>() {
                        { "1m", "1m" },
                        { "3m", "3m" },
                        { "5m", "5m" },
                        { "15m", "15m" },
                        { "30m", "30m" },
                        { "1h", "1h" },
                        { "2h", "2h" },
                        { "4h", "4h" },
                        { "6h", "6h" },
                        { "8h", "8h" },
                        { "12h", "12h" },
                        { "1d", "1d" },
                        { "1w", "1w" },
                        { "1M", "1M" },
                    } },
                    { "watchOrderBook", new Dictionary<string, object>() {
                        { "channel", "depth" },
                    } },
                    { "listenKeyRefreshRate", 1200000 },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "keepAlive", multiply(multiply((subtract(60, 1)), 5), 1000) },
                { "ping", this.ping },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "ws", new Dictionary<string, object>() {
                    { "exact", new Dictionary<string, object>() {} },
                } },
            } },
        });
    }

    public override object ping(WebSocketClient client)
    {
        return new Dictionary<string, object>() {
            { "ping", this.milliseconds() },
        };
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        //
        // public
        //
        //     {
        //         topic: "trade",
        //         symbol: "DOGEUSDT",
        //         symbolName: "DOGEUSDT",
        //         params: {
        //             realtimeInterval: "24h",
        //             binary: "false",
        //         },
        //         data: [
        //             {
        //                 v: "4864732022868004630",
        //                 t: 1757243788405,
        //                 p: "0.21804",
        //                 q: "80",
        //                 m: true,
        //             },
        //         ],
        //         f: true,  // initial first snapshot or not
        //         sendTime: 1757244002117,
        //         shared: false,
        //     }
        //
        // private
        //
        //     [
        //       {
        //         e: 'outboundContractAccountInfo',
        //         E: '1758228398234',
        //         T: true,
        //         W: true,
        //         D: true,
        //         B: [ [Object] ]
        //       }
        //     ]
        //
        object topic = this.safeString(message, "topic");
        if (isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            return;
        }
        //
        // handle ping-pong: { ping: 1758540450000 }
        //
        object pongTimestamp = this.safeInteger(message, "pong");
        if (isTrue(!isEqual(pongTimestamp, null)))
        {
            this.handleIncomingPong(client as WebSocketClient, pongTimestamp);
            return;
        }
        object methods = new Dictionary<string, object>() {
            { "trade", this.handleTrades },
            { "kline", this.handleOHLCV },
            { "realtimes", this.handleTickers },
            { "depth", this.handleOrderBookPartialSnapshot },
            { "diffDepth", this.handleOrderBook },
            { "outboundAccountInfo", this.handleBalance },
            { "outboundContractAccountInfo", this.handleBalance },
            { "executionReport", this.handleOrder },
            { "contractExecutionReport", this.handleOrder },
            { "ticketInfo", this.handleMyTrade },
            { "outboundContractPositionInfo", this.handlePositions },
        };
        object method = this.safeValue(methods, topic);
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        } else
        {
            // check private streams
            for (object i = 0; isLessThan(i, getArrayLength(message)); postFixIncrement(ref i))
            {
                object item = getValue(message, i);
                object eventVar = this.safeString(item, "e");
                object method2 = this.safeValue(methods, eventVar);
                if (isTrue(!isEqual(method2, null)))
                {
                    DynamicInvoker.InvokeMethod(method2, new object[] { client, item});
                }
            }
        }
    }

    public virtual void handleIncomingPong(WebSocketClient client, object pongTimestamp)
    {
        client.lastPong = pongTimestamp;
    }

    /**
     * @method
     * @name toobit#watchTrades
     * @description watches information on multiple trades made in a market
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#trade-streams
     * @param {string} symbol unified market symbol of the market trades were made in
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trade structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    /**
     * @method
     * @name toobit#watchTradesForSymbols
     * @description get the list of most recent trades for a list of symbols
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#trade-streams
     * @param {string[]} symbols unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.name] the name of the method to call, 'trade' or 'aggTrade', default is 'trade'
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object messageHashes = new List<object>() {};
        object subParams = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = this.market(symbol);
            ((IList<object>)messageHashes).Add(add("trade::", symbol));
            object rawHash = getValue(market, "id");
            ((IList<object>)subParams).Add(rawHash);
        }
        object marketIds = this.marketIds(symbols);
        object url = add(getValue(getValue(getValue(this.urls, "api"), "ws"), "common"), "/quote/ws/v1");
        object request = new Dictionary<string, object>() {
            { "symbol", String.Join(",", ((IList<object>)marketIds).ToArray()) },
            { "topic", "trade" },
            { "event", "sub" },
        };
        object trades = await this.watchMultiple(url, messageHashes, this.extend(request, parameters), messageHashes);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeValue(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //         symbol: "DOGEUSDT",
        //         symbolName: "DOGEUSDT",
        //         topic: "trade",
        //         params: {
        //             realtimeInterval: "24h",
        //             binary: "false",
        //         },
        //         data: [
        //             {
        //                 v: "4864732022868004630",
        //                 t: 1757243788405,
        //                 p: "0.21804",
        //                 q: "80",
        //                 m: true,
        //             },
        //         ],
        //         f: true,  // initial first snapshot or not
        //         sendTime: 1757244002117,
        //         shared: false,
        //     }
        //
        object marketId = this.safeString(message, "symbol");
        object symbol = this.safeSymbol(marketId);
        if (!isTrue((inOp(this.trades, symbol))))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = new ArrayCache(limit);
        }
        object stored = getValue(this.trades, symbol);
        object data = this.safeList(message, "data", new List<object>() {});
        object parsed = this.parseWsTrades(data);
        for (object i = 0; isLessThan(i, getArrayLength(parsed)); postFixIncrement(ref i))
        {
            object trade = getValue(parsed, i);
            ((IDictionary<string,object>)trade)["symbol"] = symbol;
            callDynamically(stored, "append", new object[] {trade});
        }
        object messageHash = add("trade::", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        return this.parseTrade(trade, market);
    }

    /**
     * @method
     * @name toobit#watchOHLCV
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#kline-candlestick-streams
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["callerMethodName"] = "watchOHLCV";
        object result = await this.watchOHLCVForSymbols(new List<object>() {new List<object>() {symbol, timeframe}}, since, limit, parameters);
        return getValue(getValue(result, symbol), timeframe);
    }

    /**
     * @method
     * @name toobit#watchOHLCVForSymbols
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#kline-candlestick-streams
     * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCVForSymbols(object symbolsAndTimeframes, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object url = add(getValue(getValue(getValue(this.urls, "api"), "ws"), "common"), "/quote/ws/v1");
        object messageHashes = new List<object>() {};
        object timeframes = this.safeDict(getValue(this.options, "ws"), "timeframes", new Dictionary<string, object>() {});
        object marketIds = new List<object>() {};
        object selectedTimeframe = null;
        for (object i = 0; isLessThan(i, getArrayLength(symbolsAndTimeframes)); postFixIncrement(ref i))
        {
            object data = getValue(symbolsAndTimeframes, i);
            object symbolStr = this.safeString(data, 0);
            object market = this.market(symbolStr);
            object marketId = getValue(market, "id");
            object unfiedTimeframe = this.safeString(data, 1, "1m");
            object rawTimeframe = this.safeString(timeframes, unfiedTimeframe, unfiedTimeframe);
            if (isTrue(isTrue(!isEqual(selectedTimeframe, null)) && isTrue(!isEqual(selectedTimeframe, rawTimeframe))))
            {
                throw new NotSupported ((string)add(this.id, " watchOHLCVForSymbols() only supports a single timeframe for all symbols")) ;
            } else
            {
                selectedTimeframe = rawTimeframe;
            }
            ((IList<object>)marketIds).Add(marketId);
            ((IList<object>)messageHashes).Add(add(add(add("ohlcv::", symbolStr), "::"), unfiedTimeframe));
        }
        object request = new Dictionary<string, object>() {
            { "symbol", String.Join(",", ((IList<object>)marketIds).ToArray()) },
            { "topic", add("kline_", selectedTimeframe) },
            { "event", "sub" },
        };
        var symboltimeframestoredVariable = await this.watchMultiple(url, messageHashes, this.extend(request, parameters), messageHashes);
        var symbol = ((IList<object>) symboltimeframestoredVariable)[0];
        var timeframe = ((IList<object>) symboltimeframestoredVariable)[1];
        var stored = ((IList<object>) symboltimeframestoredVariable)[2];
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(stored, "getLimit", new object[] {symbol, limit});
        }
        object filtered = this.filterBySinceLimit(stored, since, limit, 0, true);
        return this.createOHLCVObject(symbol, timeframe, filtered);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         symbol: 'DOGEUSDT',
        //         symbolName: 'DOGEUSDT',
        //         klineType: '1m',
        //         topic: 'kline',
        //         params: { realtimeInterval: '24h', klineType: '1m', binary: 'false' },
        //         data: [
        //             {
        //                 t: 1757251200000,
        //                 s: 'DOGEUSDT',
        //                 sn: 'DOGEUSDT',
        //                 c: '0.21889',
        //                 h: '0.21898',
        //                 l: '0.21889',
        //                 o: '0.21897',
        //                 v: '5247',
        //                 st: 0
        //             }
        //         ],
        //         f: true,
        //         sendTime: 1757251217643,
        //         shared: false
        //     }
        //
        object marketId = this.safeString(message, "symbol");
        object market = this.market(marketId);
        object symbol = getValue(market, "symbol");
        object parameters = this.safeDict(message, "params", new Dictionary<string, object>() {});
        object timeframeId = this.safeString(parameters, "klineType");
        object timeframe = this.findTimeframe(timeframeId);
        if (!isTrue((inOp(this.ohlcvs, symbol))))
        {
            ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = new Dictionary<string, object>() {};
        }
        if (!isTrue((inOp(getValue(this.ohlcvs, symbol), timeframe))))
        {
            object limit = this.safeInteger(getValue(this.options, "ws"), "OHLCVLimit", 1000);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = new ArrayCacheByTimestamp(limit);
        }
        object stored = getValue(getValue(this.ohlcvs, symbol), timeframe);
        object data = this.safeList(message, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object parsed = this.parseWsOHLCV(getValue(data, i), market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        object messageHash = add(add(add("ohlcv::", symbol), "::"), timeframe);
        object resolveData = new List<object>() {symbol, timeframe, stored};
        callDynamically(client as WebSocketClient, "resolve", new object[] {resolveData, messageHash});
    }

    public override object parseWsOHLCV(object ohlcv, object market = null)
    {
        //
        //             {
        //                 t: 1757251200000,
        //                 o: '0.21897',
        //                 h: '0.21898',
        //                 l: '0.21889',
        //                 c: '0.21889',
        //                 v: '5247',
        //                 s: 'DOGEUSDT',
        //                 sn: 'DOGEUSDT',
        //                 st: 0
        //             }
        //
        object parsed = this.parseOHLCV(ohlcv, market);
        return parsed;
    }

    /**
     * @method
     * @name toobit#watchTicker
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#individual-symbol-ticker-streams
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbol = this.symbol(symbol);
        object tickers = await this.watchTickers(new List<object>() {symbol}, parameters);
        return getValue(tickers, symbol);
    }

    /**
     * @method
     * @name toobit#watchTickers
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#individual-symbol-ticker-streams
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object messageHashes = new List<object>() {};
        object subParams = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = this.market(symbol);
            ((IList<object>)messageHashes).Add(add("ticker::", symbol));
            object rawHash = getValue(market, "id");
            ((IList<object>)subParams).Add(rawHash);
        }
        object marketIds = this.marketIds(symbols);
        object url = add(getValue(getValue(getValue(this.urls, "api"), "ws"), "common"), "/quote/ws/v1");
        object request = new Dictionary<string, object>() {
            { "symbol", String.Join(",", ((IList<object>)marketIds).ToArray()) },
            { "topic", "realtimes" },
            { "event", "sub" },
        };
        object ticker = await this.watchMultiple(url, messageHashes, this.extend(request, parameters), messageHashes);
        if (isTrue(this.newUpdates))
        {
            object result = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)result)[(string)getValue(ticker, "symbol")] = ticker;
            return result;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    public virtual void handleTickers(WebSocketClient client, object message)
    {
        //
        //    {
        //        "symbol": "DOGEUSDT",
        //        "symbolName": "DOGEUSDT",
        //        "topic": "realtimes",
        //        "params": {
        //            "realtimeInterval": "24h"
        //        },
        //        "data": [
        //            {
        //                "t": 1757257643683,
        //                "s": "DOGEUSDT",
        //                "o": "0.21462",
        //                "h": "0.22518",
        //                "l": "0.21229",
        //                "c": "0.2232",
        //                "v": "283337017",
        //                "qv": "62063771.42702",
        //                "sn": "DOGEUSDT",
        //                "m": "0.04",
        //                "e": 301,
        //                "c24h": "0.2232",
        //                "h24h": "0.22518",
        //                "l24h": "0.21229",
        //                "o24h": "0.21462",
        //                "v24h": "283337017",
        //                "qv24h": "62063771.42702",
        //                "m24h": "0.04"
        //            }
        //        ],
        //        "f": false,
        //        "sendTime": 1757257643751,
        //        "shared": false
        //    }
        //
        object data = this.safeList(message, "data");
        object newTickers = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object ticker = getValue(data, i);
            object parsed = this.parseWsTicker(ticker);
            object symbol = getValue(parsed, "symbol");
            ((IDictionary<string,object>)this.tickers)[(string)symbol] = parsed;
            ((IDictionary<string,object>)newTickers)[(string)symbol] = parsed;
            object messageHash = add("ticker::", symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {parsed, messageHash});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newTickers, "tickers"});
    }

    public virtual object parseWsTicker(object ticker, object market = null)
    {
        return this.parseTicker(ticker, market);
    }

    /**
     * @method
     * @name toobit#watchOrderBook
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#partial-book-depth-streams
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return.
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.watchOrderBookForSymbols(new List<object>() {symbol}, limit, parameters);
    }

    /**
     * @method
     * @name toobit#watchOrderBookForSymbols
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#partial-book-depth-streams
     * @param {string[]} symbols unified array of symbols
     * @param {int} [limit] the maximum amount of order book entries to return.
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object channel = null;
        var channelparametersVariable = this.handleOptionAndParams(parameters, "watchOrderBook", "channel", "depth");
        channel = ((IList<object>)channelparametersVariable)[0];
        parameters = ((IList<object>)channelparametersVariable)[1];
        object messageHashes = new List<object>() {};
        object subParams = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = this.market(symbol);
            ((IList<object>)messageHashes).Add(add(add(add("orderBook::", symbol), "::"), channel));
            object rawHash = getValue(market, "id");
            ((IList<object>)subParams).Add(rawHash);
        }
        object marketIds = this.marketIds(symbols);
        object url = add(getValue(getValue(getValue(this.urls, "api"), "ws"), "common"), "/quote/ws/v1");
        object request = new Dictionary<string, object>() {
            { "symbol", String.Join(",", ((IList<object>)marketIds).ToArray()) },
            { "topic", channel },
            { "event", "sub" },
        };
        object orderbook = await this.watchMultiple(url, messageHashes, this.extend(request, parameters), messageHashes);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //     {
        //         symbol: 'DOGEUSDT',
        //         symbolName: 'DOGEUSDT',
        //         topic: 'depth',
        //         params: { realtimeInterval: '24h' },
        //         data: [
        //             {
        //             e: 301,
        //             t: 1757304842860,
        //             v: '9814355_1E-18',
        //             b: [Array],
        //             a: [Array],
        //             o: 0
        //             }
        //         ],
        //         f: false,
        //         sendTime: 1757304843047,
        //         shared: false
        //     }
        //
        object isSnapshot = this.safeBool(message, "f", false);
        if (isTrue(isSnapshot))
        {
            this.setOrderBookSnapshot(client as WebSocketClient, message, "diffDepth");
            return;
        }
        object marketId = this.safeString(message, "symbol");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object data = this.safeList(message, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object messageHash = add(add(add("orderBook::", symbol), "::"), "diffDepth");
            if (!isTrue((inOp(this.orderbooks, symbol))))
            {
                object limit = this.safeInteger(getValue(this.options, "ws"), "orderBookLimit", 1000);
                ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
            }
            object orderBook = getValue(this.orderbooks, symbol);
            object timestamp = this.safeInteger(entry, "t");
            object bids = this.safeList(entry, "b", new List<object>() {});
            object asks = this.safeList(entry, "a", new List<object>() {});
            this.handleDeltas(getValue(orderBook, "asks"), asks);
            this.handleDeltas(getValue(orderBook, "bids"), bids);
            ((IDictionary<string,object>)orderBook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderBook;
            callDynamically(client as WebSocketClient, "resolve", new object[] {orderBook, messageHash});
        }
    }

    public override void handleDelta(object bookside, object delta)
    {
        object bidAsk = this.parseBidAsk(delta);
        (bookside as IOrderBookSide).storeArray(bidAsk);
    }

    public virtual void handleOrderBookPartialSnapshot(WebSocketClient client, object message)
    {
        //
        //     {
        //         symbol: 'DOGEUSDT',
        //         symbolName: 'DOGEUSDT',
        //         topic: 'depth',
        //         params: { realtimeInterval: '24h' },
        //         data: [
        //             {
        //             e: 301,
        //             s: 'DOGEUSDT',
        //             t: 1757304842860,
        //             v: '9814355_1E-18',
        //             b: [Array],
        //             a: [Array],
        //             o: 0
        //             }
        //         ],
        //         f: false,
        //         sendTime: 1757304843047,
        //         shared: false
        //     }
        //
        this.setOrderBookSnapshot(client as WebSocketClient, message, "depth");
    }

    public virtual void setOrderBookSnapshot(WebSocketClient client, object message, object channel)
    {
        object data = this.safeList(message, "data", new List<object>() {});
        object length = getArrayLength(data);
        if (isTrue(isEqual(length, 0)))
        {
            return;
        }
        for (object i = 0; isLessThan(i, length); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object marketId = this.safeString(entry, "s");
            object symbol = this.safeSymbol(marketId);
            object messageHash = add(add(add("orderBook::", symbol), "::"), channel);
            if (!isTrue((inOp(this.orderbooks, symbol))))
            {
                object limit = this.safeInteger(getValue(this.options, "ws"), "orderBookLimit", 1000);
                ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
            }
            object orderbook = getValue(this.orderbooks, symbol);
            object timestamp = this.safeInteger(entry, "t");
            object snapshot = this.parseOrderBook(entry, symbol, timestamp, "b", "a");
            (orderbook as IOrderBook).reset(snapshot);
            callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
        }
    }

    /**
     * @method
     * @name toobit#watchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#payload-account-update
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("watchBalance", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object isSpot = (isEqual(marketType, "spot"));
        object type = ((bool) isTrue(isSpot)) ? "spot" : "contract";
        object spotSubHash = "spot:balance";
        object swapSubHash = "contract:private";
        object spotMessageHash = "spot:balance";
        object swapMessageHash = "contract:balance";
        object messageHash = ((bool) isTrue(isSpot)) ? spotMessageHash : swapMessageHash;
        object subscriptionHash = ((bool) isTrue(isSpot)) ? spotSubHash : swapSubHash;
        object url = this.getUserStreamUrl();
        var client = this.client(url);
        this.setBalanceCache(client as WebSocketClient, marketType, subscriptionHash, parameters);
        client.future(add(type, ":fetchBalanceSnapshot"));
        return await this.watch(url, messageHash, parameters, subscriptionHash);
    }

    public virtual void setBalanceCache(WebSocketClient client, object marketType, object subscriptionHash = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(inOp(((WebSocketClient)client).subscriptions, subscriptionHash)))
        {
            return;
        }
        object type = ((bool) isTrue((isEqual(marketType, "spot")))) ? "spot" : "contract";
        object messageHash = add(type, ":fetchBalanceSnapshot");
        if (!isTrue((inOp(client.futures, messageHash))))
        {
            client.future(messageHash);
            this.spawn(this.loadBalanceSnapshot, new object[] { client, messageHash, marketType});
        }
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        // spot
        //
        // [
        //     {
        //         e: 'outboundAccountInfo',
        //         E: '1758226989725',
        //         T: true,
        //         W: true,
        //         D: true,
        //         B: [
        //             {
        //               a: "USDT",
        //               f: "6.37242839",
        //               l: "0",
        //             },
        //         ]
        //     }
        // ]
        //
        // contract
        //
        // [
        //     {
        //         e: 'outboundContractAccountInfo',
        //         E: '1758226989742',
        //         T: true,
        //         W: true,
        //         D: true,
        //         B: [ [Object] ]
        //     }
        // ]
        //
        object channel = this.safeString(message, "e");
        object data = this.safeList(message, "B", new List<object>() {});
        object timestamp = this.safeInteger(message, "E");
        object type = ((bool) isTrue((isEqual(channel, "outboundContractAccountInfo")))) ? "contract" : "spot";
        if (!isTrue((inOp(this.balance, type))))
        {
            ((IDictionary<string,object>)this.balance)[(string)type] = new Dictionary<string, object>() {};
        }
        ((IDictionary<string,object>)getValue(this.balance, type))["info"] = data;
        ((IDictionary<string,object>)getValue(this.balance, type))["timestamp"] = timestamp;
        ((IDictionary<string,object>)getValue(this.balance, type))["datetime"] = this.iso8601(timestamp);
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object balance = getValue(data, i);
            object currencyId = this.safeString(balance, "a");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["info"] = balance;
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "l");
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "f");
            ((IDictionary<string,object>)getValue(this.balance, type))[(string)code] = account;
        }
        ((IDictionary<string,object>)this.balance)[(string)type] = this.safeBalance(getValue(this.balance, type));
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, type), add(type, ":balance")});
    }

    public async virtual Task loadBalanceSnapshot(WebSocketClient client, object messageHash, object marketType)
    {
        object response = await this.fetchBalance(new Dictionary<string, object>() {
            { "type", marketType },
        });
        object type = ((bool) isTrue((isEqual(marketType, "spot")))) ? "spot" : "contract";
        ((IDictionary<string,object>)this.balance)[(string)type] = this.extend(response, this.safeDict(this.balance, type, new Dictionary<string, object>() {}));
        // don't remove the future from the .futures cache
        var future = getValue(client.futures, messageHash);
        (future as Future).resolve();
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, type), add(type, ":fetchBalanceSnapshot")});
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, type), add(type, ":balance")}); // we should also resolve right away after snapshot, so user doesn't double-fetch balance
    }

    /**
     * @method
     * @name toobit#watchOrders
     * @description watches information on multiple orders made by the user
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#payload-order-update
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object market = this.marketOrNull(symbol);
        symbol = this.safeString(market, "symbol", symbol);
        object messageHash = "orders";
        if (isTrue(!isEqual(symbol, null)))
        {
            messageHash = add(add(messageHash, ":"), symbol);
        }
        object url = this.getUserStreamUrl();
        object orders = await this.watch(url, messageHash, parameters, messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        //
        //    {
        //        "e": "executionReport",
        //        "E": "1758311011844",
        //        "s": "DOGEUSDT",
        //        "c": "1758311011948",
        //        "S": "BUY",
        //        "o": "LIMIT",
        //        "f": "GTC",
        //        "q": "22",
        //        "p": "0.23",
        //        "pt": "INPUT",
        //        "X": "NEW",
        //        "i": "2043255292855185152",
        //        "l": "0", // Last executed quantity
        //        "z": "0", // Cumulative filled quantity
        //        "L": "0", // Last executed price
        //        "n": "0",
        //        "N": "",
        //        "u": true,
        //        "w": true,
        //        "m": false,
        //        "O": "1758311011833",
        //        "U": "1758311011841",
        //        "Z": "0",
        //        "C": false,
        //        "v": "0",
        //        "rp": "0",
        //        "td": "0"
        //    }
        //
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object orders = this.orders;
        object order = this.parseWsOrder(message);
        callDynamically(orders, "append", new object[] {order});
        object messageHash = "orders";
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
        messageHash = add("orders:", this.safeString(order, "symbol"));
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
    }

    public override object parseWsOrder(object order, object market = null)
    {
        object timestamp = this.safeInteger(order, "O");
        object marketId = this.safeString(order, "s");
        object symbol = this.safeSymbol(marketId, market);
        object priceType = this.safeStringLower(order, "pt");
        object rawOrderType = this.safeStringLower(order, "o");
        object orderType = null;
        if (isTrue(isEqual(priceType, "market")))
        {
            orderType = "market";
        } else
        {
            orderType = rawOrderType;
        }
        object feeCost = this.safeNumber(order, "n");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", null },
            };
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString(order, "i") },
            { "clientOrderId", this.safeString(order, "c") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", this.safeInteger2(order, "U", "E") },
            { "symbol", symbol },
            { "type", orderType },
            { "timeInForce", this.safeStringUpper(order, "f") },
            { "postOnly", null },
            { "side", this.safeStringLower(order, "S") },
            { "price", this.safeString(order, "L") },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "amount", this.safeString(order, "q") },
            { "cost", null },
            { "average", this.safeString(order, "p") },
            { "filled", this.safeString(order, "z") },
            { "remaining", null },
            { "status", this.parseOrderStatus(this.safeString(order, "X")) },
            { "fee", fee },
            { "trades", null },
        }, market);
    }

    /**
     * @method
     * @name toobit#watchMyTrades
     * @description watches information on multiple trades made by the user
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#payload-ticket-push
     * @param {string} symbol unified market symbol of the market trades were made in
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trade structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.unifiedMargin] use unified margin account
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object market = this.marketOrNull(symbol);
        symbol = this.safeString(market, "symbol", symbol);
        object messageHash = "myTrades";
        if (isTrue(!isEqual(symbol, null)))
        {
            messageHash = add(add(messageHash, ":"), symbol);
        }
        object url = this.getUserStreamUrl();
        object trades = await this.watch(url, messageHash, parameters, messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleMyTrade(WebSocketClient client, object message)
    {
        //
        //    {
        //        "e": "ticketInfo",
        //        "E": "1758314657847",
        //        "s": "DOGEUSDT",
        //        "q": "22.0",
        //        "t": "1758314657842",
        //        "p": "0.26667",
        //        "T": "4864732022877055421",
        //        "o": "2043285877770284800",
        //        "c": "1758314657002",
        //        "a": "1783404067076253952",
        //        "m": false,
        //        "S": "BUY"
        //    }
        //
        object myTrades = this.myTrades;
        if (isTrue(isEqual(myTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            myTrades = new ArrayCacheBySymbolById(limit);
        }
        object trade = this.parseMyTrade(message);
        callDynamically(myTrades, "append", new object[] {trade});
        object messageHash = add("myTrades:", getValue(trade, "symbol"));
        callDynamically(client as WebSocketClient, "resolve", new object[] {myTrades, messageHash});
        messageHash = "myTrades";
        callDynamically(client as WebSocketClient, "resolve", new object[] {myTrades, messageHash});
    }

    public virtual object parseMyTrade(object trade, object market = null)
    {
        object marketId = this.safeString(trade, "s");
        object ts = this.safeString(trade, "t");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString(trade, "T") },
            { "timestamp", ts },
            { "datetime", this.iso8601(ts) },
            { "symbol", this.safeSymbol(marketId, market) },
            { "order", this.safeString(trade, "o") },
            { "type", null },
            { "side", this.safeStringLower(trade, "S") },
            { "takerOrMaker", ((bool) isTrue(this.safeBool(trade, "m"))) ? "maker" : "taker" },
            { "price", this.safeString(trade, "p") },
            { "amount", this.safeString(trade, "q") },
            { "cost", null },
            { "fee", null },
        }, market);
    }

    /**
     * @method
     * @name toobit#watchPositions
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#event-position-update
     * @description watch all open positions
     * @param {string[]} [symbols] list of unified market symbols
     * @param {int} [since] the earliest time in ms to fetch positions for
     * @param {int} [limit] the maximum number of positions to retrieve
     * @param {object} params extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
     */
    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object messageHash = "";
        if (!isTrue(this.isEmpty(symbols)))
        {
            symbols = this.marketSymbols(symbols);
            messageHash = add("::", String.Join(",", ((IList<object>)symbols).ToArray()));
        }
        object url = this.getUserStreamUrl();
        var client = this.client(url);
        await this.authenticate(url);
        this.setPositionsCache(client as WebSocketClient, symbols);
        object cache = this.positions;
        if (isTrue(isEqual(cache, null)))
        {
            object snapshot = await client.future("fetchPositionsSnapshot");
            return this.filterBySymbolsSinceLimit(snapshot, symbols, since, limit, true);
        }
        object newPositions = await this.watch(url, messageHash, null, messageHash);
        if (isTrue(this.newUpdates))
        {
            return newPositions;
        }
        return this.filterBySymbolsSinceLimit(cache, symbols, since, limit, true);
    }

    public virtual void setPositionsCache(WebSocketClient client, object type, object symbols = null, object isPortfolioMargin = null)
    {
        isPortfolioMargin ??= false;
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new Dictionary<string, object>() {};
        }
        if (isTrue(inOp(this.positions, type)))
        {
            return;
        }
        object fetchPositionsSnapshot = this.handleOption("watchPositions", "fetchPositionsSnapshot", false);
        if (isTrue(fetchPositionsSnapshot))
        {
            object messageHash = add(type, ":fetchPositionsSnapshot");
            if (!isTrue((inOp(client.futures, messageHash))))
            {
                client.future(messageHash);
                this.spawn(this.loadPositionsSnapshot, new object[] { client, messageHash, type, isPortfolioMargin});
            }
        } else
        {
            ((IDictionary<string,object>)this.positions)[(string)type] = new ArrayCacheBySymbolBySide();
        }
    }

    public async virtual Task loadPositionsSnapshot(WebSocketClient client, object messageHash, object type)
    {
        object parameters = new Dictionary<string, object>() {
            { "type", type },
        };
        object positions = await this.fetchPositions(null, parameters);
        ((IDictionary<string,object>)this.positions)[(string)type] = new ArrayCacheBySymbolBySide();
        object cache = getValue(this.positions, type);
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object position = getValue(positions, i);
            callDynamically(cache, "append", new object[] {position});
        }
        // don't remove the future from the .futures cache
        var future = getValue(client.futures, messageHash);
        (future as Future).resolve(cache);
        callDynamically(client as WebSocketClient, "resolve", new object[] {cache, add(type, ":positions")});
    }

    public virtual void handlePositions(WebSocketClient client, object message)
    {
        //
        // [
        //     {
        //         e: 'outboundContractPositionInfo',
        //         E: '1758316454554',
        //         A: '1783404067076253954',
        //         s: 'DOGE-SWAP-USDT',
        //         S: 'LONG',
        //         p: '0',
        //         P: '0',
        //         a: '0',
        //         f: '0.1228',
        //         m: '0',
        //         r: '0',
        //         up: '0',
        //         pr: '0',
        //         pv: '0',
        //         v: '3.0',
        //         mt: 'CROSS',
        //         mm: '0',
        //         mp: '0.265410000000000000'
        //     }
        // ]
        //
        object subscriptions = new List<object>(((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Keys);
        object accountType = getValue(subscriptions, 0);
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new Dictionary<string, object>() {};
        }
        if (!isTrue((inOp(this.positions, accountType))))
        {
            ((IDictionary<string,object>)this.positions)[(string)accountType] = new ArrayCacheBySymbolBySide();
        }
        object cache = getValue(this.positions, accountType);
        object newPositions = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(message)); postFixIncrement(ref i))
        {
            object rawPosition = getValue(message, i);
            object position = this.parseWsPosition(rawPosition);
            object timestamp = this.safeInteger(rawPosition, "E");
            ((IDictionary<string,object>)position)["timestamp"] = timestamp;
            ((IDictionary<string,object>)position)["datetime"] = this.iso8601(timestamp);
            ((IList<object>)newPositions).Add(position);
            callDynamically(cache, "append", new object[] {position});
        }
        object messageHashes = this.findMessageHashes(client as WebSocketClient, add(accountType, ":positions::"));
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object positions = this.filterByArray(newPositions, "symbol", symbols, false);
            if (!isTrue(this.isEmpty(positions)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {positions, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newPositions, add(accountType, ":positions")});
    }

    public virtual object parseWsPosition(object position, object market = null)
    {
        object marketId = this.safeString(position, "s");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", this.safeSymbol(marketId, null) },
            { "notional", this.omitZero(this.safeString(position, "pv")) },
            { "marginMode", this.safeStringLower(position, "mt") },
            { "liquidationPrice", this.safeString(position, "f") },
            { "entryPrice", this.safeString(position, "p") },
            { "unrealizedPnl", this.safeString(position, "up") },
            { "realizedPnl", this.safeNumber(position, "r") },
            { "percentage", null },
            { "contracts", null },
            { "contractSize", null },
            { "markPrice", this.safeString(position, "mp") },
            { "side", this.safeStringLower(position, "S") },
            { "hedged", null },
            { "timestamp", null },
            { "datetime", null },
            { "maintenanceMargin", this.safeString(position, "mm") },
            { "maintenanceMarginPercentage", null },
            { "collateral", null },
            { "initialMargin", this.omitZero(this.safeString(position, "m")) },
            { "initialMarginPercentage", null },
            { "leverage", this.safeString(position, "v") },
            { "marginRatio", null },
        });
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var client = this.client(this.getUserStreamUrl());
        object messageHash = "authenticated";
        var future = client.reusableFuture(messageHash);
        object authenticated = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(authenticated, null)))
        {
            this.checkRequiredCredentials();
            object time = this.milliseconds();
            object lastAuthenticatedTime = this.safeInteger(getValue(this.options, "ws"), "lastAuthenticatedTime", 0);
            object listenKeyRefreshRate = this.safeInteger(getValue(this.options, "ws"), "listenKeyRefreshRate", 1200000);
            object delay = this.sum(listenKeyRefreshRate, 10000);
            if (isTrue(isGreaterThan(subtract(time, lastAuthenticatedTime), delay)))
            {
                try
                {
                    ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)messageHash] = true;
                    object response = await this.privatePostApiV1UserDataStream(parameters);
                    ((IDictionary<string,object>)getValue(this.options, "ws"))["listenKey"] = this.safeString(response, "listenKey");
                    ((IDictionary<string,object>)getValue(this.options, "ws"))["lastAuthenticatedTime"] = time;
                    (future as Future).resolve(true);
                    this.delay(listenKeyRefreshRate,  this.keepAliveListenKey, new object[] { parameters});
                } catch(Exception e)
                {
                    var err = new AuthenticationError(add(add(this.id, " "), this.json(e)));
                    ((WebSocketClient)client).reject(err, messageHash);
                    if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
                    {
                        ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
                    }
                }
            }
        }
        return await (future as Exchange.Future);
    }

    public async virtual Task keepAliveListenKey(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object options = this.safeValue(this.options, "ws", new Dictionary<string, object>() {});
        object listenKey = this.safeString(options, "listenKey");
        if (isTrue(isEqual(listenKey, null)))
        {
            // A network error happened: we can't renew a listen key that does not exist.
            return;
        }
        try
        {
            object response = await this.privatePostApiV1UserDataStream(parameters);
            ((IDictionary<string,object>)getValue(this.options, "ws"))["listenKey"] = this.safeString(response, "listenKey");
            ((IDictionary<string,object>)getValue(this.options, "ws"))["lastAuthenticatedTime"] = this.milliseconds();
        } catch(Exception error)
        {
            object url = this.getUserStreamUrl();
            var client = this.client(url);
            object messageHashes = new List<object>(((IDictionary<string, ccxt.Exchange.Future>)client.futures).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
            {
                object messageHash = getValue(messageHashes, i);
                ((WebSocketClient)client).reject(error, messageHash);
            }
            ((IDictionary<string,object>)getValue(this.options, "ws"))["listenKey"] = null;
            ((IDictionary<string,object>)getValue(this.options, "ws"))["lastAuthenticatedTime"] = 0;
            return;
        }
        // whether or not to schedule another listenKey keepAlive request
        object listenKeyRefreshRate = this.safeInteger(this.options, "listenKeyRefreshRate", 1200000);
        this.delay(listenKeyRefreshRate,  this.keepAliveListenKey, new object[] { parameters});
    }

    public virtual object getUserStreamUrl()
    {
        return add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "common"), "/api/v1/ws/"), getValue(getValue(this.options, "ws"), "listenKey"));
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //    {
        //        "code": '-100010',
        //        "desc": "Invalid Symbols!"
        //    }
        //
        object code = this.safeString(message, "code");
        if (isTrue(!isEqual(code, null)))
        {
            object desc = this.safeString(message, "desc");
            object msg = add(add(add(add(this.id, " code: "), code), " message: "), desc);
            var exception = new ExchangeError(            ((string)msg)); // c# fix
            ((WebSocketClient)client).reject(exception);
            return true;
        }
        return false;
    }
}
