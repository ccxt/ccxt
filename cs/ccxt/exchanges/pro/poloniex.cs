namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class poloniex { public poloniex(object args = null) : base(args) { } }
public partial class poloniex : ccxt.poloniex
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchOHLCV", true },
                { "watchOrderBook", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
                { "watchBalance", true },
                { "watchStatus", false },
                { "watchOrders", true },
                { "watchMyTrades", true },
                { "createOrderWs", true },
                { "editOrderWs", false },
                { "fetchOpenOrdersWs", false },
                { "fetchOrderWs", false },
                { "cancelOrderWs", true },
                { "cancelOrdersWs", true },
                { "cancelAllOrdersWs", true },
                { "fetchTradesWs", false },
                { "fetchBalanceWs", false },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://ws.poloniex.com/ws/public" },
                        { "private", "wss://ws.poloniex.com/ws/private" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "createMarketBuyOrderRequiresPrice", true },
                { "tradesLimit", 1000 },
                { "ordersLimit", 1000 },
                { "OHLCVLimit", 1000 },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "name", "book_lv2" },
                } },
                { "connectionsLimit", 2000 },
                { "requestsLimit", 500 },
                { "timeframes", new Dictionary<string, object>() {
                    { "1m", "candles_minute_1" },
                    { "5m", "candles_minute_5" },
                    { "10m", "candles_minute_10" },
                    { "15m", "candles_minute_15" },
                    { "30m", "candles_minute_30" },
                    { "1h", "candles_hour_1" },
                    { "2h", "candles_hour_2" },
                    { "4h", "candles_hour_4" },
                    { "6h", "candles_hour_6" },
                    { "12h", "candles_hour_12" },
                    { "1d", "candles_day_1" },
                    { "3d", "candles_day_3" },
                    { "1w", "candles_week_1" },
                    { "1M", "candles_month_1" },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "keepAlive", 15000 },
                { "ping", this.ping },
            } },
        });
    }

    /**
     * @ignore
     * @method
     * @description authenticates the user to access private web socket channels
     * @see https://api-docs.poloniex.com/spot/websocket/authentication
     * @returns {object} response from exchange
     */
    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object timestamp = this.numberToString(this.milliseconds());
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        object messageHash = "authenticated";
        var client = this.client(url);
        var future = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(future, null)))
        {
            object accessPath = "/ws";
            object requestString = add(add(add("GET\n", accessPath), "\nsignTimestamp="), timestamp);
            object signature = this.hmac(this.encode(requestString), this.encode(this.secret), sha256, "base64");
            object request = new Dictionary<string, object>() {
                { "event", "subscribe" },
                { "channel", new List<object>() {"auth"} },
                { "params", new Dictionary<string, object>() {
                    { "key", this.apiKey },
                    { "signTimestamp", timestamp },
                    { "signature", signature },
                    { "signatureMethod", "HmacSHA256" },
                    { "signatureVersion", "2" },
                } },
            };
            object message = this.extend(request, parameters);
            future = await this.watch(url, messageHash, message, messageHash);
            //
            //    {
            //        "data": {
            //            "success": true,
            //            "ts": 1645597033915
            //        },
            //        "channel": "auth"
            //    }
            //
            //    # Failure to return results
            //
            //    {
            //        "data": {
            //            "success": false,
            //            "message": "Authentication failed!",
            //            "ts": 1646276295075
            //        },
            //        "channel": "auth"
            //    }
            //
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)messageHash] = future;
        }
        return future;
    }

    /**
     * @ignore
     * @method
     * @description Connects to a websocket channel
     * @param {string} name name of the channel
     * @param {string} messageHash unique identifier for the message
     * @param {boolean} isPrivate true for the authenticated url, false for the public url
     * @param {string[]} [symbols] CCXT market symbols
     * @param {object} [params] extra parameters specific to the poloniex api
     * @returns {object} data from the websocket stream
     */
    public async virtual Task<object> subscribe(object name, object messageHash, object isPrivate, object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object publicOrPrivate = ((bool) isTrue(isPrivate)) ? "private" : "public";
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), publicOrPrivate);
        object subscribe = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "channel", new List<object>() {name} },
        };
        object marketIds = new List<object>() {};
        if (isTrue(this.isEmpty(symbols)))
        {
            ((IList<object>)marketIds).Add("all");
        } else
        {
            messageHash = add(add(messageHash, "::"), String.Join(",", ((IList<object>)symbols).ToArray()));
            marketIds = this.marketIds(symbols);
        }
        if (isTrue(!isEqual(name, "balances")))
        {
            ((IDictionary<string,object>)subscribe)["symbols"] = marketIds;
        }
        object request = this.extend(subscribe, parameters);
        return await this.watch(url, messageHash, request, messageHash);
    }

    /**
     * @ignore
     * @method
     * @description Connects to a websocket channel
     * @param {string} name name of the channel
     * @param {object} [params] extra parameters specific to the poloniex api
     * @returns {object} data from the websocket stream
     */
    public async virtual Task<object> tradeRequest(object name, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        object messageHash = ((object)this.nonce()).ToString();
        object subscribe = new Dictionary<string, object>() {
            { "id", messageHash },
            { "event", name },
            { "params", parameters },
        };
        return await this.watch(url, messageHash, subscribe, messageHash);
    }

    /**
     * @method
     * @name poloniex#createOrderWs
     * @see https://api-docs.poloniex.com/spot/websocket/trade-request#create-order
     * @description create a trade order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the poloniex api endpoint
     * @param {string} [params.timeInForce] GTC (default), IOC, FOK
     * @param {string} [params.clientOrderId] Maximum 64-character length.*
     * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
     *
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {string} [params.amount] quote units for the order
     * @param {boolean} [params.allowBorrow] allow order to be placed by borrowing funds (Default: false)
     * @param {string} [params.stpMode] self-trade prevention, defaults to expire_taker, none: enable self-trade; expire_taker: taker order will be canceled when self-trade happens
     * @param {string} [params.slippageTolerance] used to control the maximum slippage ratio, the value range is greater than 0 and less than 1
     * @returns {object} an [order structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
     */
    public async override Task<object> createOrderWs(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object market = this.market(symbol);
        object uppercaseType = ((string)type).ToUpper();
        object uppercaseSide = ((string)side).ToUpper();
        object isPostOnly = this.isPostOnly(isEqual(uppercaseType, "MARKET"), isEqual(uppercaseType, "LIMIT_MAKER"), parameters);
        if (isTrue(isPostOnly))
        {
            uppercaseType = "LIMIT_MAKER";
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", ((string)side).ToUpper() },
            { "type", ((string)type).ToUpper() },
        };
        if (isTrue(isTrue((isEqual(uppercaseType, "MARKET"))) && isTrue((isEqual(uppercaseSide, "BUY")))))
        {
            object quoteAmount = null;
            object createMarketBuyOrderRequiresPrice = true;
            var createMarketBuyOrderRequiresPriceparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "createMarketBuyOrderRequiresPrice", true);
            createMarketBuyOrderRequiresPrice = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[0];
            parameters = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[1];
            object cost = this.safeNumber(parameters, "cost");
            parameters = this.omit(parameters, "cost");
            if (isTrue(!isEqual(cost, null)))
            {
                quoteAmount = this.costToPrecision(symbol, cost);
            } else if (isTrue(createMarketBuyOrderRequiresPrice))
            {
                if (isTrue(isEqual(price, null)))
                {
                    throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument")) ;
                } else
                {
                    object amountString = this.numberToString(amount);
                    object priceString = this.numberToString(price);
                    object costRequest = Precise.stringMul(amountString, priceString);
                    quoteAmount = this.costToPrecision(symbol, costRequest);
                }
            } else
            {
                quoteAmount = this.costToPrecision(symbol, amount);
            }
            ((IDictionary<string,object>)request)["amount"] = quoteAmount;
        } else
        {
            ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(getValue(market, "symbol"), amount);
            if (isTrue(!isEqual(price, null)))
            {
                ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            }
        }
        object orders = await this.tradeRequest("createOrder", this.extend(request, parameters));
        object order = this.safeDict(orders, 0);
        return order;
    }

    /**
     * @method
     * @name poloniex#cancelOrderWs
     * @see https://api-docs.poloniex.com/spot/websocket/trade-request#cancel-multiple-orders
     * @description cancel multiple orders
     * @param {string} id order id
     * @param {string} [symbol] unified market symbol
     * @param {object} [params] extra parameters specific to the poloniex api endpoint
     * @param {string} [params.clientOrderId] client order id
     * @returns {object} an list of [order structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
     */
    public async override Task<object> cancelOrderWs(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            object clientOrderIds = this.safeValue(parameters, "clientOrderId", new List<object>() {});
            ((IDictionary<string,object>)parameters)["clientOrderIds"] = this.arrayConcat(clientOrderIds, new List<object>() {clientOrderId});
        }
        object orders = await this.cancelOrdersWs(new List<object>() {id}, symbol, parameters);
        object order = this.safeDict(orders, 0);
        return order;
    }

    /**
     * @method
     * @name poloniex#cancelOrdersWs
     * @see https://api-docs.poloniex.com/spot/websocket/trade-request#cancel-multiple-orders
     * @description cancel multiple orders
     * @param {string[]} ids order ids
     * @param {string} symbol unified market symbol, default is undefined
     * @param {object} [params] extra parameters specific to the poloniex api endpoint
     * @param {string[]} [params.clientOrderIds] client order ids
     * @returns {object} an list of [order structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
     */
    public async override Task<object> cancelOrdersWs(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object request = new Dictionary<string, object>() {
            { "orderIds", ids },
        };
        return await this.tradeRequest("cancelOrders", this.extend(request, parameters));
    }

    /**
     * @method
     * @name poloniex#cancelAllOrdersWs
     * @see https://api-docs.poloniex.com/spot/websocket/trade-request#cancel-all-orders
     * @description cancel all open orders of a type. Only applicable to Option in Portfolio Margin mode, and MMP privilege is required.
     * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
     * @param {object} [params] extra parameters specific to the poloniex api endpoint
     * @returns {object[]} a list of [order structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
     */
    public async override Task<object> cancelAllOrdersWs(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        return await this.tradeRequest("cancelAllOrders", parameters);
    }

    public virtual void handleOrderRequest(WebSocketClient client, object message)
    {
        //
        //    {
        //        "id": "1234567",
        //        "data": [{
        //           "orderId": 205343650954092544,
        //           "clientOrderId": "",
        //           "message": "",
        //           "code": 200
        //        }]
        //    }
        //
        object messageHash = this.safeString(message, "id");
        object data = this.safeValue(message, "data", new List<object>() {});
        object orders = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object order = getValue(data, i);
            object parsedOrder = this.parseWsOrder(order);
            ((IList<object>)orders).Add(parsedOrder);
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
    }

    /**
     * @method
     * @name poloniex#watchOHLCV
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://api-docs.poloniex.com/spot/websocket/market-data#candlesticks
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object timeframes = this.safeValue(this.options, "timeframes", new Dictionary<string, object>() {});
        object channel = this.safeString(timeframes, timeframe, timeframe);
        if (isTrue(isEqual(channel, null)))
        {
            throw new BadRequest ((string)add(add(this.id, " watchOHLCV cannot take a timeframe of "), timeframe)) ;
        }
        object ohlcv = await this.subscribe(channel, channel, false, new List<object>() {symbol}, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    /**
     * @method
     * @name poloniex#watchTicker
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://api-docs.poloniex.com/spot/websocket/market-data#ticker
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbol = this.symbol(symbol);
        object tickers = await this.watchTickers(new List<object>() {symbol}, parameters);
        return this.safeValue(tickers, symbol);
    }

    /**
     * @method
     * @name poloniex#watchTickers
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://api-docs.poloniex.com/spot/websocket/market-data#ticker
     * @param {string[]} symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "ticker";
        symbols = this.marketSymbols(symbols);
        object newTickers = await this.subscribe(name, name, false, symbols, parameters);
        if (isTrue(this.newUpdates))
        {
            return newTickers;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    /**
     * @method
     * @name poloniex#watchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://api-docs.poloniex.com/spot/websocket/market-data#trades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    /**
     * @method
     * @name poloniex#watchTradesForSymbols
     * @description get the list of most recent trades for a list of symbols
     * @see https://api-docs.poloniex.com/spot/websocket/market-data#trades
     * @param {string[]} symbols unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false, true, true);
        object name = "trades";
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "public");
        object marketIds = this.marketIds(symbols);
        object subscribe = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "channel", new List<object>() {name} },
            { "symbols", marketIds },
        };
        object request = this.extend(subscribe, parameters);
        object messageHashes = new List<object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                ((IList<object>)messageHashes).Add(add(add(name, "::"), getValue(symbols, i)));
            }
        }
        object trades = await this.watchMultiple(url, messageHashes, request, messageHashes);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeValue(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    /**
     * @method
     * @name poloniex#watchOrderBook
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://api-docs.poloniex.com/spot/websocket/market-data#book-level-2
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] not used by poloniex watchOrderBook
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object watchOrderBookOptions = this.safeValue(this.options, "watchOrderBook");
        object name = this.safeString(watchOrderBookOptions, "name", "book_lv2");
        var nameparametersVariable = this.handleOptionAndParams(parameters, "method", "name", name);
        name = ((IList<object>)nameparametersVariable)[0];
        parameters = ((IList<object>)nameparametersVariable)[1];
        object orderbook = await this.subscribe(name, name, false, new List<object>() {symbol}, parameters);
        return (orderbook as IOrderBook).limit();
    }

    /**
     * @method
     * @name poloniex#watchOrders
     * @description watches information on multiple orders made by the user
     * @see https://api-docs.poloniex.com/spot/websocket/order
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] not used by poloniex watchOrders
     * @param {int} [limit] not used by poloniex watchOrders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "orders";
        await this.authenticate();
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
        }
        object symbols = ((bool) isTrue((isEqual(symbol, null)))) ? null : new List<object>() {symbol};
        object orders = await this.subscribe(name, name, true, symbols, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(orders, since, limit, "timestamp", true);
    }

    /**
     * @method
     * @name poloniex#watchMyTrades
     * @description watches information on multiple trades made by the user using orders stream
     * @see https://api-docs.poloniex.com/spot/websocket/order
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] not used by poloniex watchMyTrades
     * @param {int} [limit] not used by poloniex watchMyTrades
     * @param {object} [params] extra parameters specific to the poloniex strean
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "orders";
        object messageHash = "myTrades";
        await this.authenticate();
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
        }
        object symbols = ((bool) isTrue((isEqual(symbol, null)))) ? null : new List<object>() {symbol};
        object trades = await this.subscribe(name, messageHash, true, symbols, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    /**
     * @method
     * @name poloniex#watchBalance
     * @description watch balance and get the amount of funds available for trading or funds locked in orders
     * @see https://api-docs.poloniex.com/spot/websocket/balance
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "balances";
        await this.authenticate();
        return await this.subscribe(name, name, true, null, parameters);
    }

    public override object parseWsOHLCV(object ohlcv, object market = null)
    {
        //
        //    {
        //        "symbol": "BTC_USDT",
        //        "amount": "840.7240416",
        //        "high": "24832.35",
        //        "quantity": "0.033856",
        //        "tradeCount": 1,
        //        "low": "24832.35",
        //        "closeTime": 1676942519999,
        //        "startTime": 1676942460000,
        //        "close": "24832.35",
        //        "open": "24832.35",
        //        "ts": 1676942492072
        //    }
        //
        return new List<object> {this.safeInteger(ohlcv, "startTime"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "quantity")};
    }

    public virtual object handleOHLCV(WebSocketClient client, object message)
    {
        //
        //    {
        //        "channel": "candles_minute_1",
        //        "data": [
        //            {
        //                "symbol": "BTC_USDT",
        //                "amount": "840.7240416",
        //                "high": "24832.35",
        //                "quantity": "0.033856",
        //                "tradeCount": 1,
        //                "low": "24832.35",
        //                "closeTime": 1676942519999,
        //                "startTime": 1676942460000,
        //                "close": "24832.35",
        //                "open": "24832.35",
        //                "ts": 1676942492072
        //            }
        //        ]
        //    }
        //
        object data = this.safeValue(message, "data");
        data = this.safeValue(data, 0);
        object channel = this.safeString(message, "channel");
        object marketId = this.safeString(data, "symbol");
        object symbol = this.safeSymbol(marketId);
        object market = this.safeMarket(symbol);
        object timeframes = this.safeValue(this.options, "timeframes", new Dictionary<string, object>() {});
        object timeframe = this.findTimeframe(channel, timeframes);
        object messageHash = add(add(channel, "::"), symbol);
        object parsed = this.parseWsOHLCV(data, market);
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
        if (isTrue(!isEqual(symbol, null)))
        {
            if (isTrue(isEqual(stored, null)))
            {
                object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
                stored = new ArrayCacheByTimestamp(limit);
                ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
            }
            callDynamically(stored, "append", new object[] {parsed});
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        }
        return message;
    }

    public virtual object handleTrade(WebSocketClient client, object message)
    {
        //
        //    {
        //        "channel": "trades",
        //        "data": [
        //            {
        //                "symbol": "BTC_USDT",
        //                "amount": "13.41634893",
        //                "quantity": "0.000537",
        //                "takerSide": "buy",
        //                "createTime": 1676950548834,
        //                "price": "24983.89",
        //                "id": "62486976",
        //                "ts": 1676950548839
        //            }
        //        ]
        //    }
        //
        object data = this.safeValue(message, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object item = getValue(data, i);
            object marketId = this.safeString(item, "symbol");
            if (isTrue(!isEqual(marketId, null)))
            {
                object trade = this.parseWsTrade(item);
                object symbol = getValue(trade, "symbol");
                object type = "trades";
                object messageHash = add(add(type, "::"), symbol);
                object tradesArray = this.safeValue(this.trades, symbol);
                if (isTrue(isEqual(tradesArray, null)))
                {
                    object tradesLimit = this.safeInteger(this.options, "tradesLimit", 1000);
                    tradesArray = new ArrayCache(tradesLimit);
                    ((IDictionary<string,object>)this.trades)[(string)symbol] = tradesArray;
                }
                callDynamically(tradesArray, "append", new object[] {trade});
                callDynamically(client as WebSocketClient, "resolve", new object[] {tradesArray, messageHash});
            }
        }
        return message;
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        // handleTrade
        //
        //    {
        //        "symbol": "BTC_USDT",
        //        "amount": "13.41634893",
        //        "quantity": "0.000537",
        //        "takerSide": "buy",
        //        "createTime": 1676950548834,
        //        "price": "24983.89",
        //        "id": "62486976",
        //        "ts": 1676950548839
        //    }
        //
        // private trade
        //    {
        //        "orderId":"186250258089635840",
        //        "tradeId":"62036513",
        //        "clientOrderId":"",
        //        "accountType":"SPOT",
        //        "eventType":"trade",
        //        "symbol":"ADA_USDT",
        //        "side":"SELL",
        //        "type":"MARKET",
        //        "price":"0",
        //        "quantity":"3",
        //        "state":"FILLED",
        //        "createTime":1685371921891,
        //        "tradeTime":1685371921908,
        //        "tradePrice":"0.37694",
        //        "tradeQty":"3",
        //        "feeCurrency":"USDT",
        //        "tradeFee":"0.00226164",
        //        "tradeAmount":"1.13082",
        //        "filledQuantity":"3",
        //        "filledAmount":"1.13082",
        //        "ts":1685371921945,
        //        "source":"WEB",
        //        "orderAmount":"0",
        //        "matchRole":"TAKER"
        //     }
        //
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(trade, "createTime");
        object takerMaker = this.safeStringLower2(trade, "matchRole", "taker");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString2(trade, "id", "tradeId") },
            { "symbol", this.safeString(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "order", this.safeString(trade, "orderId") },
            { "type", this.safeStringLower(trade, "type") },
            { "side", this.safeStringLower2(trade, "takerSide", "side") },
            { "takerOrMaker", takerMaker },
            { "price", this.omitZero(this.safeString2(trade, "tradePrice", "price")) },
            { "amount", this.omitZero(this.safeString2(trade, "filledQuantity", "quantity")) },
            { "cost", this.safeString2(trade, "amount", "filledAmount") },
            { "fee", new Dictionary<string, object>() {
                { "rate", null },
                { "cost", this.safeString(trade, "tradeFee") },
                { "currency", this.safeString(trade, "feeCurrency") },
            } },
        }, market);
    }

    public virtual object parseStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "open" },
            { "PARTIALLY_FILLED", "open" },
            { "FILLED", "closed" },
            { "PENDING_CANCEL", "open" },
            { "PARTIALLY_CANCELED", "open" },
            { "CANCELED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseWsOrderTrade(object trade, object market = null)
    {
        //
        //    {
        //        "symbol": "BTC_USDT",
        //        "type": "LIMIT",
        //        "quantity": "1",
        //        "orderId": "32471407854219264",
        //        "tradeFee": "0",
        //        "clientOrderId": "",
        //        "accountType": "SPOT",
        //        "feeCurrency": "",
        //        "eventType": "place",
        //        "source": "API",
        //        "side": "BUY",
        //        "filledQuantity": "0",
        //        "filledAmount": "0",
        //        "matchRole": "MAKER",
        //        "state": "NEW",
        //        "tradeTime": 0,
        //        "tradeAmount": "0",
        //        "orderAmount": "0",
        //        "createTime": 1648708186922,
        //        "price": "47112.1",
        //        "tradeQty": "0",
        //        "tradePrice": "0",
        //        "tradeId": "0",
        //        "ts": 1648708187469
        //    }
        //
        object timestamp = this.safeInteger(trade, "tradeTime");
        object marketId = this.safeString(trade, "symbol");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString(trade, "tradeId") },
            { "symbol", this.safeSymbol(marketId, market) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "order", this.safeString(trade, "orderId") },
            { "type", this.safeStringLower(trade, "type") },
            { "side", this.safeString(trade, "side") },
            { "takerOrMaker", this.safeStringLower(trade, "matchRole") },
            { "price", this.safeString(trade, "price") },
            { "amount", this.safeString(trade, "tradeAmount") },
            { "cost", null },
            { "fee", new Dictionary<string, object>() {
                { "rate", null },
                { "cost", this.safeString(trade, "tradeFee") },
                { "currency", this.safeString(trade, "feeCurrency") },
            } },
        }, market);
    }

    public virtual object handleOrder(WebSocketClient client, object message)
    {
        //
        // Order is created
        //
        //    {
        //        "channel": "orders",
        //        "data": [
        //            {
        //                "symbol": "BTC_USDT",
        //                "type": "LIMIT",
        //                "quantity": "1",
        //                "orderId": "32471407854219264",
        //                "tradeFee": "0",
        //                "clientOrderId": "",
        //                "accountType": "SPOT",
        //                "feeCurrency": "",
        //                "eventType": "place",
        //                "source": "API",
        //                "side": "BUY",
        //                "filledQuantity": "0",
        //                "filledAmount": "0",
        //                "matchRole": "MAKER",
        //                "state": "NEW",
        //                "tradeTime": 0,
        //                "tradeAmount": "0",
        //                "orderAmount": "0",
        //                "createTime": 1648708186922,
        //                "price": "47112.1",
        //                "tradeQty": "0",
        //                "tradePrice": "0",
        //                "tradeId": "0",
        //                "ts": 1648708187469
        //            }
        //        ]
        //    }
        //
        object data = this.safeValue(message, "data", new List<object>() {});
        object orders = this.orders;
        if (isTrue(isEqual(orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit");
            orders = new ArrayCacheBySymbolById(limit);
            this.orders = orders;
        }
        object marketIds = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object order = this.safeValue(data, i);
            object marketId = this.safeString(order, "symbol");
            object eventType = this.safeString(order, "eventType");
            if (isTrue(!isEqual(marketId, null)))
            {
                object symbol = this.safeSymbol(marketId);
                object orderId = this.safeString(order, "orderId");
                object clientOrderId = this.safeString(order, "clientOrderId");
                if (isTrue(isTrue(isEqual(eventType, "place")) || isTrue(isEqual(eventType, "canceled"))))
                {
                    object parsed = this.parseWsOrder(order);
                    callDynamically(orders, "append", new object[] {parsed});
                } else
                {
                    object previousOrders = this.safeValue((orders as ArrayCacheBySymbolById).hashmap, symbol, new Dictionary<string, object>() {});
                    object previousOrder = this.safeValue2(previousOrders, orderId, clientOrderId);
                    object trade = this.parseWsTrade(order);
                    this.handleMyTrades(client as WebSocketClient, trade);
                    if (isTrue(isEqual(getValue(previousOrder, "trades"), null)))
                    {
                        ((IDictionary<string,object>)previousOrder)["trades"] = new List<object>() {};
                    }
                    ((IList<object>)getValue(previousOrder, "trades")).Add(trade);
                    ((IDictionary<string,object>)previousOrder)["lastTradeTimestamp"] = getValue(trade, "timestamp");
                    object totalCost = "0";
                    object totalAmount = "0";
                    object previousOrderTrades = getValue(previousOrder, "trades");
                    for (object j = 0; isLessThan(j, getArrayLength(previousOrderTrades)); postFixIncrement(ref j))
                    {
                        object previousOrderTrade = getValue(previousOrderTrades, j);
                        object cost = this.numberToString(getValue(previousOrderTrade, "cost"));
                        object amount = this.numberToString(getValue(previousOrderTrade, "amount"));
                        totalCost = Precise.stringAdd(totalCost, cost);
                        totalAmount = Precise.stringAdd(totalAmount, amount);
                    }
                    if (isTrue(Precise.stringGt(totalAmount, "0")))
                    {
                        ((IDictionary<string,object>)previousOrder)["average"] = this.parseNumber(Precise.stringDiv(totalCost, totalAmount));
                    }
                    ((IDictionary<string,object>)previousOrder)["cost"] = this.parseNumber(totalCost);
                    if (isTrue(!isEqual(getValue(previousOrder, "filled"), null)))
                    {
                        object tradeAmount = this.numberToString(getValue(trade, "amount"));
                        object previousOrderFilled = this.numberToString(getValue(previousOrder, "filled"));
                        previousOrderFilled = Precise.stringAdd(previousOrderFilled, tradeAmount);
                        ((IDictionary<string,object>)previousOrder)["filled"] = previousOrderFilled;
                        if (isTrue(!isEqual(getValue(previousOrder, "amount"), null)))
                        {
                            object previousOrderAmount = this.numberToString(getValue(previousOrder, "amount"));
                            ((IDictionary<string,object>)previousOrder)["remaining"] = this.parseNumber(Precise.stringSub(previousOrderAmount, previousOrderFilled));
                        }
                    }
                    if (isTrue(isEqual(getValue(previousOrder, "fee"), null)))
                    {
                        ((IDictionary<string,object>)previousOrder)["fee"] = new Dictionary<string, object>() {
                            { "rate", null },
                            { "cost", 0 },
                            { "currency", getValue(getValue(trade, "fee"), "currency") },
                        };
                    }
                    if (isTrue(isTrue((!isEqual(getValue(getValue(previousOrder, "fee"), "cost"), null))) && isTrue((!isEqual(getValue(getValue(trade, "fee"), "cost"), null)))))
                    {
                        object stringOrderCost = this.numberToString(getValue(getValue(previousOrder, "fee"), "cost"));
                        object stringTradeCost = this.numberToString(getValue(getValue(trade, "fee"), "cost"));
                        ((IDictionary<string,object>)getValue(previousOrder, "fee"))["cost"] = Precise.stringAdd(stringOrderCost, stringTradeCost);
                    }
                    object rawState = this.safeString(order, "state");
                    object state = this.parseStatus(rawState);
                    ((IDictionary<string,object>)previousOrder)["status"] = state;
                    // update the newUpdates count
                    callDynamically(orders, "append", new object[] {previousOrder});
                }
                ((IList<object>)marketIds).Add(marketId);
            }
        }
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = getValue(marketIds, i);
            object market = this.market(marketId);
            object symbol = getValue(market, "symbol");
            object messageHash = add("orders::", symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, "orders"});
        return message;
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        //    {
        //        "symbol": "BTC_USDT",
        //        "type": "LIMIT",
        //        "quantity": "1",
        //        "orderId": "32471407854219264",
        //        "tradeFee": "0",
        //        "clientOrderId": "",
        //        "accountType": "SPOT",
        //        "feeCurrency": "",
        //        "eventType": "place",
        //        "source": "API",
        //        "side": "BUY",
        //        "filledQuantity": "0",
        //        "filledAmount": "0",
        //        "matchRole": "MAKER",
        //        "state": "NEW",
        //        "tradeTime": 0,
        //        "tradeAmount": "0",
        //        "orderAmount": "0",
        //        "createTime": 1648708186922,
        //        "price": "47112.1",
        //        "tradeQty": "0",
        //        "tradePrice": "0",
        //        "tradeId": "0",
        //        "ts": 1648708187469
        //    }
        //
        object id = this.safeString(order, "orderId");
        object clientOrderId = this.safeString(order, "clientOrderId");
        object marketId = this.safeString(order, "symbol");
        object timestamp = this.safeString(order, "ts");
        object filledAmount = this.safeString(order, "filledAmount");
        object status = this.safeString(order, "state");
        object trades = null;
        if (!isTrue(Precise.stringEq(filledAmount, "0")))
        {
            trades = new List<object>() {};
            object trade = this.parseWsOrderTrade(order);
            ((IList<object>)trades).Add(trade);
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "symbol", this.safeSymbol(marketId, market) },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "type", this.safeString(order, "type") },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", this.safeString(order, "side") },
            { "price", this.safeString(order, "price") },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "amount", this.safeString(order, "quantity") },
            { "cost", null },
            { "average", null },
            { "filled", filledAmount },
            { "remaining", this.safeString(order, "remaining_size") },
            { "status", this.parseStatus(status) },
            { "fee", new Dictionary<string, object>() {
                { "rate", null },
                { "cost", this.safeString(order, "tradeFee") },
                { "currency", this.safeString(order, "feeCurrency") },
            } },
            { "trades", trades },
        });
    }

    public virtual object handleTicker(WebSocketClient client, object message)
    {
        //
        //    {
        //        "channel": "ticker",
        //        "data": [
        //            {
        //                "symbol": "BTC_USDT",
        //                "startTime": 1677280800000,
        //                "open": "23154.32",
        //                "high": "23212.21",
        //                "low": "22761.01",
        //                "close": "23148.86",
        //                "quantity": "105.179566",
        //                "amount": "2423161.17436702",
        //                "tradeCount": 17582,
        //                "dailyChange": "-0.0002",
        //                "markPrice": "23151.09",
        //                "closeTime": 1677367197924,
        //                "ts": 1677367251090
        //            }
        //        ]
        //    }
        //
        object data = this.safeValue(message, "data", new List<object>() {});
        object newTickers = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object item = getValue(data, i);
            object marketId = this.safeString(item, "symbol");
            if (isTrue(!isEqual(marketId, null)))
            {
                object ticker = this.parseTicker(item);
                object symbol = getValue(ticker, "symbol");
                ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
                ((IDictionary<string,object>)newTickers)[(string)symbol] = ticker;
            }
        }
        object messageHashes = this.findMessageHashes(client as WebSocketClient, "ticker::");
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object tickers = this.filterByArray(newTickers, "symbol", symbols);
            if (!isTrue(this.isEmpty(tickers)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {tickers, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newTickers, "ticker"});
        return message;
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        // snapshot
        //
        //    {
        //        "channel": "book_lv2",
        //        "data": [
        //            {
        //                "symbol": "BTC_USDT",
        //                "createTime": 1677368876253,
        //                "asks": [
        //                    ["5.65", "0.02"],
        //                    ...
        //                ],
        //                "bids": [
        //                    ["6.16", "0.6"],
        //                    ...
        //                ],
        //                "lastId": 164148724,
        //                "id": 164148725,
        //                "ts": 1677368876316
        //            }
        //        ],
        //        "action": "snapshot"
        //    }
        //
        // update
        //
        //    {
        //        "channel": "book_lv2",
        //        "data": [
        //            {
        //                "symbol": "BTC_USDT",
        //                "createTime": 1677368876882,
        //                "asks": [
        //                    ["6.35", "3"]
        //                ],
        //                "bids": [
        //                    ["5.65", "0.02"]
        //                ],
        //                "lastId": 164148725,
        //                "id": 164148726,
        //                "ts": 1677368876890
        //            }
        //        ],
        //        "action": "update"
        //    }
        //
        object data = this.safeValue(message, "data", new List<object>() {});
        object type = this.safeString(message, "action");
        object snapshot = isEqual(type, "snapshot");
        object update = isEqual(type, "update");
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object item = getValue(data, i);
            object marketId = this.safeString(item, "symbol");
            object market = this.safeMarket(marketId);
            object symbol = getValue(market, "symbol");
            object name = "book_lv2";
            object messageHash = add(add(name, "::"), symbol);
            object subscription = this.safeValue(((WebSocketClient)client).subscriptions, messageHash, new Dictionary<string, object>() {});
            object limit = this.safeInteger(subscription, "limit");
            object timestamp = this.safeInteger(item, "ts");
            object asks = this.safeValue(item, "asks");
            object bids = this.safeValue(item, "bids");
            if (isTrue(isTrue(snapshot) || isTrue(update)))
            {
                if (isTrue(snapshot))
                {
                    ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
                }
                object orderbook = getValue(this.orderbooks, symbol);
                if (isTrue(!isEqual(bids, null)))
                {
                    for (object j = 0; isLessThan(j, getArrayLength(bids)); postFixIncrement(ref j))
                    {
                        object bid = this.safeValue(bids, j);
                        object price = this.safeNumber(bid, 0);
                        object amount = this.safeNumber(bid, 1);
                        object bidsSide = getValue(orderbook, "bids");
                        (bidsSide as IOrderBookSide).store(price, amount);
                    }
                }
                if (isTrue(!isEqual(asks, null)))
                {
                    for (object j = 0; isLessThan(j, getArrayLength(asks)); postFixIncrement(ref j))
                    {
                        object ask = this.safeValue(asks, j);
                        object price = this.safeNumber(ask, 0);
                        object amount = this.safeNumber(ask, 1);
                        object asksSide = getValue(orderbook, "asks");
                        (asksSide as IOrderBookSide).store(price, amount);
                    }
                }
                ((IDictionary<string,object>)orderbook)["symbol"] = symbol;
                ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
                ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
                callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
            }
        }
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        //    {
        //       "channel": "balances",
        //       "data": [
        //            {
        //                "changeTime": 1657312008411,
        //                "accountId": "1234",
        //                "accountType": "SPOT",
        //                "eventType": "place_order",
        //                "available": "9999999983.668",
        //                "currency": "BTC",
        //                "id": 60018450912695040,
        //                "userId": 12345,
        //                "hold": "16.332",
        //                "ts": 1657312008443
        //            }
        //        ]
        //    }
        //
        object data = this.safeValue(message, "data", new List<object>() {});
        object messageHash = "balances";
        this.balance = this.parseWsBalance(data);
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, messageHash});
    }

    public virtual object parseWsBalance(object response)
    {
        //
        //    [
        //        {
        //            "changeTime": 1657312008411,
        //            "accountId": "1234",
        //            "accountType": "SPOT",
        //            "eventType": "place_order",
        //            "available": "9999999983.668",
        //            "currency": "BTC",
        //            "id": 60018450912695040,
        //            "userId": 12345,
        //            "hold": "16.332",
        //            "ts": 1657312008443
        //        }
        //    ]
        //
        object firstBalance = this.safeValue(response, 0, new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(firstBalance, "ts");
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object balance = this.safeValue(response, i);
            object currencyId = this.safeString(balance, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object newAccount = this.account();
            ((IDictionary<string,object>)newAccount)["free"] = this.safeString(balance, "available");
            ((IDictionary<string,object>)newAccount)["used"] = this.safeString(balance, "hold");
            ((IDictionary<string,object>)result)[(string)code] = newAccount;
        }
        return this.safeBalance(result);
    }

    public virtual void handleMyTrades(WebSocketClient client, object parsedTrade)
    {
        // emulated using the orders' stream
        object messageHash = "myTrades";
        object symbol = getValue(parsedTrade, "symbol");
        if (isTrue(isEqual(this.myTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            this.myTrades = new ArrayCacheBySymbolById(limit);
        }
        object trades = this.myTrades;
        callDynamically(trades, "append", new object[] {parsedTrade});
        callDynamically(client as WebSocketClient, "resolve", new object[] {trades, messageHash});
        object symbolMessageHash = add(add(messageHash, ":"), symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {trades, symbolMessageHash});
    }

    public virtual void handlePong(WebSocketClient client)
    {
        client.lastPong = this.milliseconds();
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            return;
        }
        object type = this.safeString(message, "channel");
        object eventVar = this.safeString(message, "event");
        if (isTrue(isEqual(eventVar, "pong")))
        {
            client.lastPong = this.milliseconds();
        }
        object methods = new Dictionary<string, object>() {
            { "candles_minute_1", this.handleOHLCV },
            { "candles_minute_5", this.handleOHLCV },
            { "candles_minute_10", this.handleOHLCV },
            { "candles_minute_15", this.handleOHLCV },
            { "candles_minute_30", this.handleOHLCV },
            { "candles_hour_1", this.handleOHLCV },
            { "candles_hour_2", this.handleOHLCV },
            { "candles_hour_4", this.handleOHLCV },
            { "candles_hour_6", this.handleOHLCV },
            { "candles_hour_12", this.handleOHLCV },
            { "candles_day_1", this.handleOHLCV },
            { "candles_day_3", this.handleOHLCV },
            { "candles_week_1", this.handleOHLCV },
            { "candles_month_1", this.handleOHLCV },
            { "book", this.handleOrderBook },
            { "book_lv2", this.handleOrderBook },
            { "ticker", this.handleTicker },
            { "trades", this.handleTrade },
            { "orders", this.handleOrder },
            { "balances", this.handleBalance },
            { "createOrder", this.handleOrderRequest },
            { "cancelOrder", this.handleOrderRequest },
            { "cancelAllOrders", this.handleOrderRequest },
            { "auth", this.handleAuthenticate },
        };
        object method = this.safeValue(methods, type);
        if (isTrue(isEqual(type, "auth")))
        {
            this.handleAuthenticate(client as WebSocketClient, message);
        } else if (isTrue(isEqual(type, null)))
        {
            this.handleOrderRequest(client as WebSocketClient, message);
        } else
        {
            object data = this.safeValue(message, "data", new List<object>() {});
            object dataLength = getArrayLength(data);
            if (isTrue(isGreaterThan(dataLength, 0)))
            {
                DynamicInvoker.InvokeMethod(method, new object[] { client, message});
            }
        }
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //    {
        //        message: 'Invalid channel value ["ordersss"]',
        //        event: 'error'
        //    }
        //
        //    {
        //        "orderId": 0,
        //        "clientOrderId": null,
        //        "message": "Currency trade disabled",
        //        "code": 21352
        //    }
        //
        //    {
        //       "event": "error",
        //       "message": "Platform in maintenance mode"
        //    }
        //    {
        //       "id":"1722386782048",
        //       "data":[
        //          {
        //             "orderId":0,
        //             "clientOrderId":null,
        //             "message":"available insufficient",
        //             "code":21721
        //          }
        //       ]
        //    }
        //
        object id = this.safeString(message, "id");
        object eventVar = this.safeString(message, "event");
        object data = this.safeList(message, "data");
        object first = this.safeDict(data, 0);
        object orderId = this.safeString(first, "orderId");
        if (isTrue(isTrue((isEqual(eventVar, "error"))) || isTrue((isEqual(orderId, "0")))))
        {
            try
            {
                object error = this.safeString(first, "message");
                object code = this.safeString(first, "code");
                object feedback = add(add(this.id, " "), this.json(message));
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
                this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), error, feedback);
                throw new ExchangeError ((string)feedback) ;
            } catch(Exception e)
            {
                if (isTrue(e is AuthenticationError))
                {
                    object messageHash = "authenticated";
                    ((WebSocketClient)client).reject(e, messageHash);
                    if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
                    {
                        ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
                    }
                } else
                {
                    ((WebSocketClient)client).reject(e, id);
                }
                return true;
            }
        }
        return false;
    }

    public virtual object handleAuthenticate(WebSocketClient client, object message)
    {
        //
        //    {
        //        "success": true,
        //        "ret_msg": '',
        //        "op": "auth",
        //        "conn_id": "ce3dpomvha7dha97tvp0-2xh"
        //    }
        //
        object data = this.safeValue(message, "data");
        object success = this.safeValue(data, "success");
        object messageHash = "authenticated";
        if (isTrue(success))
        {
            callDynamically(client as WebSocketClient, "resolve", new object[] {message, messageHash});
        } else
        {
            var error = new AuthenticationError(add(add(this.id, " "), this.json(message)));
            ((WebSocketClient)client).reject(error, messageHash);
            if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
            {
                ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
            }
        }
        return message;
    }

    public override object ping(WebSocketClient client)
    {
        return new Dictionary<string, object>() {
            { "event", "ping" },
        };
    }
}
