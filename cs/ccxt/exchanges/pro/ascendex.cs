namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class ascendex { public ascendex(object args = null) : base(args) { } }
public partial class ascendex : ccxt.ascendex
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchBalance", true },
                { "watchOHLCV", true },
                { "watchOrderBook", true },
                { "watchOrders", true },
                { "watchTicker", false },
                { "watchTrades", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://ascendex.com:443/api/pro/v2/stream" },
                        { "private", "wss://ascendex.com:443/{accountGroup}/api/pro/v2/stream" },
                    } },
                } },
                { "test", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://api-test.ascendex-sandbox.com:443/api/pro/v2/stream" },
                        { "private", "wss://api-test.ascendex-sandbox.com:443/{accountGroup}/api/pro/v2/stream" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "tradesLimit", 1000 },
                { "ordersLimit", 1000 },
                { "OHLCVLimit", 1000 },
                { "categoriesAccount", new Dictionary<string, object>() {
                    { "cash", "spot" },
                    { "futures", "swap" },
                    { "margin", "margin" },
                } },
            } },
        });
    }

    public async virtual Task<object> watchPublic(object messageHash, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "public");
        object id = this.nonce();
        object request = new Dictionary<string, object>() {
            { "id", ((object)id).ToString() },
            { "op", "sub" },
        };
        object message = this.extend(request, parameters);
        return await this.watch(url, messageHash, message, messageHash);
    }

    public async virtual Task<object> watchPrivate(object channel, object messageHash, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadAccounts();
        object accountGroup = this.safeString(this.options, "account-group");
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        url = this.implodeParams(url, new Dictionary<string, object>() {
            { "accountGroup", accountGroup },
        });
        object id = this.nonce();
        object request = new Dictionary<string, object>() {
            { "id", ((object)id).ToString() },
            { "op", "sub" },
            { "ch", channel },
        };
        object message = this.extend(request, parameters);
        await this.authenticate(url, parameters);
        return await this.watch(url, messageHash, message, channel);
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#watchOHLCV
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        if (isTrue(isTrue((isEqual(limit, null))) || isTrue((isGreaterThan(limit, 1440)))))
        {
            limit = 100;
        }
        object interval = this.safeString(this.timeframes, timeframe, timeframe);
        object channel = add(add(add(add("bar", ":"), interval), ":"), getValue(market, "id"));
        parameters = new Dictionary<string, object>() {
            { "ch", channel },
        };
        object ohlcv = await this.watchPublic(channel, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual object handleOHLCV(WebSocketClient client, object message)
    {
        //
        // {
        //     "m": "bar",
        //     "s": "ASD/USDT",
        //     "data": {
        //         "i":  "1",
        //         "ts": 1575398940000,
        //         "o":  "0.04993",
        //         "c":  "0.04970",
        //         "h":  "0.04993",
        //         "l":  "0.04970",
        //         "v":  "8052"
        //     }
        // }
        //
        object marketId = this.safeString(message, "s");
        object symbol = this.safeSymbol(marketId);
        object channel = this.safeString(message, "m");
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object interval = this.safeString(data, "i");
        object messageHash = add(add(add(add(channel, ":"), interval), ":"), marketId);
        object timeframe = this.findTimeframe(interval);
        object market = this.market(symbol);
        object parsed = this.parseOHLCV(message, market);
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
        }
        callDynamically(stored, "append", new object[] {parsed});
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        return message;
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#watchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object channel = add(add("trades", ":"), getValue(market, "id"));
        parameters = this.extend(parameters, new Dictionary<string, object>() {
            { "ch", channel },
        });
        object trades = await this.watchPublic(channel, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        // {
        //     "m": "trades",
        //     "symbol": "BTC/USDT",
        //     "data": [
        //       {
        //         "p": "40744.28",
        //         "q": "0.00150",
        //         "ts": 1647514330758,
        //         "bm": true,
        //         "seqnum": 72057633465800320
        //       }
        //     ]
        // }
        //
        object marketId = this.safeString(message, "symbol");
        object symbol = this.safeSymbol(marketId);
        object channel = this.safeString(message, "m");
        object messageHash = add(add(channel, ":"), marketId);
        object market = this.market(symbol);
        object rawData = this.safeValue(message, "data");
        if (isTrue(isEqual(rawData, null)))
        {
            rawData = new List<object>() {};
        }
        object trades = this.parseTrades(rawData, market);
        object tradesArray = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(tradesArray, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            tradesArray = new ArrayCache(limit);
        }
        for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
        {
            callDynamically(tradesArray, "append", new object[] {getValue(trades, i)});
        }
        ((IDictionary<string,object>)this.trades)[(string)symbol] = tradesArray;
        callDynamically(client as WebSocketClient, "resolve", new object[] {tradesArray, messageHash});
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#watchOrderBook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object channel = add(add("depth", ":"), getValue(market, "id"));
        parameters = this.extend(parameters, new Dictionary<string, object>() {
            { "ch", channel },
        });
        object orderbook = await this.watchPublic(channel, parameters);
        return (orderbook as IOrderBook).limit();
    }

    public async virtual Task<object> watchOrderBookSnapshot(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object action = "depth-snapshot";
        object channel = add(add(action, ":"), getValue(market, "id"));
        parameters = this.extend(parameters, new Dictionary<string, object>() {
            { "action", action },
            { "args", new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
            } },
            { "op", "req" },
        });
        object orderbook = await this.watchPublic(channel, parameters);
        return (orderbook as IOrderBook).limit();
    }

    public async virtual Task<object> fetchOrderBookSnapshot(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object restOrderBook = await this.fetchRestOrderBookSafe(symbol, limit, parameters);
        if (!isTrue((inOp(this.orderbooks, symbol))))
        {
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook();
        }
        object orderbook = getValue(this.orderbooks, symbol);
        (orderbook as IOrderBook).reset(restOrderBook);
        return orderbook;
    }

    public virtual void handleOrderBookSnapshot(WebSocketClient client, object message)
    {
        //
        // {
        //     "m": "depth",
        //     "symbol": "BTC/USDT",
        //     "data": {
        //       "ts": 1647520500149,
        //       "seqnum": 28590487626,
        //       "asks": [
        //         [Array], [Array], [Array],
        //         [Array], [Array], [Array],
        //       ],
        //       "bids": [
        //         [Array], [Array], [Array],
        //         [Array], [Array], [Array],
        //       ]
        //     }
        //   }
        //
        object marketId = this.safeString(message, "symbol");
        object symbol = this.safeSymbol(marketId);
        object channel = this.safeString(message, "m");
        object messageHash = add(add(channel, ":"), symbol);
        object orderbook = getValue(this.orderbooks, symbol);
        object data = this.safeValue(message, "data");
        object snapshot = this.parseOrderBook(data, symbol);
        ((IDictionary<string,object>)snapshot)["nonce"] = this.safeInteger(data, "seqnum");
        (orderbook as IOrderBook).reset(snapshot);
        // unroll the accumulated deltas
        object messages = (orderbook as ccxt.pro.OrderBook).cache;
        for (object i = 0; isLessThan(i, getArrayLength(messages)); postFixIncrement(ref i))
        {
            object messageItem = getValue(messages, i);
            this.handleOrderBookMessage(client as WebSocketClient, messageItem, orderbook);
        }
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //   {
        //       "m": "depth",
        //       "symbol": "BTC/USDT",
        //       "data": {
        //         "ts": 1647515136144,
        //         "seqnum": 28590470736,
        //         "asks": [ [Array], [Array] ],
        //         "bids": [ [Array], [Array], [Array], [Array], [Array], [Array] ]
        //       }
        //   }
        //
        object channel = this.safeString(message, "m");
        object marketId = this.safeString(message, "symbol");
        object symbol = this.safeSymbol(marketId);
        object messageHash = add(add(channel, ":"), marketId);
        if (!isTrue((inOp(this.orderbooks, symbol))))
        {
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {});
        }
        object orderbook = getValue(this.orderbooks, symbol);
        if (isTrue(isEqual(getValue(orderbook, "nonce"), null)))
        {
            ((IList<object>)(orderbook as ccxt.pro.OrderBook).cache).Add(message);
        } else
        {
            this.handleOrderBookMessage(client as WebSocketClient, message, orderbook);
            callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
        }
    }

    public override void handleDelta(object bookside, object delta)
    {
        //
        // ["40990.47","0.01619"],
        //
        object price = this.safeFloat(delta, 0);
        object amount = this.safeFloat(delta, 1);
        (bookside as IOrderBookSide).store(price, amount);
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    public virtual object handleOrderBookMessage(WebSocketClient client, object message, object orderbook)
    {
        //
        // {
        //     "m":"depth",
        //     "symbol":"BTC/USDT",
        //     "data":{
        //        "ts":1647527417715,
        //        "seqnum":28590257013,
        //        "asks":[
        //           ["40990.47","0.01619"],
        //           ["41021.21","0"],
        //           ["41031.59","0.06096"]
        //        ],
        //        "bids":[
        //           ["40990.46","0.76114"],
        //           ["40985.18","0"]
        //        ]
        //     }
        //  }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object seqNum = this.safeInteger(data, "seqnum");
        if (isTrue(isGreaterThan(seqNum, getValue(orderbook, "nonce"))))
        {
            object asks = this.safeValue(data, "asks", new List<object>() {});
            object bids = this.safeValue(data, "bids", new List<object>() {});
            this.handleDeltas(getValue(orderbook, "asks"), asks);
            this.handleDeltas(getValue(orderbook, "bids"), bids);
            ((IDictionary<string,object>)orderbook)["nonce"] = seqNum;
            object timestamp = this.safeInteger(data, "ts");
            ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        }
        return orderbook;
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @name ascendex#watchBalance
        * @description watch balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        var typequeryVariable = this.handleMarketTypeAndParams("watchBalance", null, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        object channel = null;
        object messageHash = null;
        if (isTrue(isTrue((isEqual(type, "spot"))) || isTrue((isEqual(type, "margin")))))
        {
            object accountCategories = this.safeValue(this.options, "accountCategories", new Dictionary<string, object>() {});
            object accountCategory = this.safeString(accountCategories, type, "cash"); // cash, margin,
            accountCategory = ((string)accountCategory).ToUpper();
            channel = add("order:", accountCategory); // order and balance share the same channel
            messageHash = add("balance:", type);
        } else
        {
            channel = "futures-account-update";
            messageHash = "balance:swap";
        }
        return await this.watchPrivate(channel, messageHash, query);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        // cash account
        //
        // {
        //     "m": "balance",
        //     "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
        //     "ac": "CASH",
        //     "data": {
        //         "a" : "USDT",
        //         "sn": 8159798,
        //         "tb": "600",
        //         "ab": "600"
        //     }
        // }
        //
        // margin account
        //
        // {
        //     "m": "balance",
        //     "accountId": "marOxpKJV83dxTRx0Eyxpa0gxc4Txt0P",
        //     "ac": "MARGIN",
        //     "data": {
        //         "a"  : "USDT",
        //         "sn" : 8159802,
        //         "tb" : "400", // total Balance
        //         "ab" : "400", // available balance
        //         "brw": "0", // borrowws
        //         "int": "0" // interest
        //     }
        // }
        //
        // futures
        // {
        //     "m"     : "futures-account-update",            // message
        //     "e"     : "ExecutionReport",                   // event type
        //     "t"     : 1612508562129,                       // time
        //     "acc"   : "futures-account-id",         // account ID
        //     "at"    : "FUTURES",                           // account type
        //     "sn"    : 23128,                               // sequence number,
        //     "id"    : "r177710001cbU3813942147C5kbFGOan",
        //     "col": [
        //       {
        //         "a": "USDT",               // asset code
        //         "b": "1000000",            // balance
        //         "f": "1"                   // discount factor
        //       }
        //     ],
        //     (...)
        //
        object channel = this.safeString(message, "m");
        object result = null;
        object type = null;
        if (isTrue(isTrue((isEqual(channel, "order"))) || isTrue((isEqual(channel, "futures-order")))))
        {
            object data = this.safeValue(message, "data");
            object marketId = this.safeString(data, "s");
            object market = this.safeMarket(marketId);
            object baseAccount = this.account();
            ((IDictionary<string,object>)baseAccount)["free"] = this.safeString(data, "bab");
            ((IDictionary<string,object>)baseAccount)["total"] = this.safeString(data, "btb");
            object quoteAccount = this.account();
            ((IDictionary<string,object>)quoteAccount)["free"] = this.safeString(data, "qab");
            ((IDictionary<string,object>)quoteAccount)["total"] = this.safeString(data, "qtb");
            if (isTrue(getValue(market, "contract")))
            {
                type = "swap";
                result = this.safeValue(this.balance, type, new Dictionary<string, object>() {});
            } else
            {
                type = getValue(market, "type");
                result = this.safeValue(this.balance, type, new Dictionary<string, object>() {});
            }
            ((IDictionary<string,object>)result)[(string)getValue(market, "base")] = baseAccount;
            ((IDictionary<string,object>)result)[(string)getValue(market, "quote")] = quoteAccount;
        } else
        {
            object accountType = this.safeStringLower2(message, "ac", "at");
            object categoriesAccounts = this.safeValue(this.options, "categoriesAccount");
            type = this.safeString(categoriesAccounts, accountType, "spot");
            result = this.safeValue(this.balance, type, new Dictionary<string, object>() {});
            object data = this.safeValue(message, "data");
            object balances = null;
            if (isTrue(isEqual(data, null)))
            {
                balances = this.safeValue(message, "col");
            } else
            {
                balances = new List<object>() {data};
            }
            for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
            {
                object balance = getValue(balances, i);
                object code = this.safeCurrencyCode(this.safeString(balance, "a"));
                object account = this.account();
                ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "ab");
                ((IDictionary<string,object>)account)["total"] = this.safeString2(balance, "tb", "b");
                ((IDictionary<string,object>)result)[(string)code] = account;
            }
        }
        object messageHash = add(add("balance", ":"), type);
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.safeBalance(result), messageHash});
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#watchOrders
        * @see https://ascendex.github.io/ascendex-pro-api/#channel-order-and-balance
        * @description watches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        var typequeryVariable = this.handleMarketTypeAndParams("watchOrders", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        object messageHash = null;
        object channel = null;
        if (isTrue(isTrue(!isEqual(type, "spot")) && isTrue(!isEqual(type, "margin"))))
        {
            channel = "futures-order";
            messageHash = "order:FUTURES";
        } else
        {
            object accountCategories = this.safeValue(this.options, "accountCategories", new Dictionary<string, object>() {});
            object accountCategory = this.safeString(accountCategories, type, "cash"); // cash, margin
            accountCategory = ((string)accountCategory).ToUpper();
            messageHash = add(add("order", ":"), accountCategory);
            channel = messageHash;
        }
        if (isTrue(!isEqual(symbol, null)))
        {
            messageHash = add(add(messageHash, ":"), symbol);
        }
        object orders = await this.watchPrivate(channel, messageHash, query);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        //
        // spot order
        // {
        //   "m": "order",
        //   "accountId": "cshF5SlR9ukAXoDOuXbND4dVpBMw9gzH",
        //   "ac": "CASH",
        //   "data": {
        //     "sn": 19399016185,
        //     "orderId": "r17f9d7983faU7223046196CMlrj3bfC",
        //     "s": "LTC/USDT",
        //     "ot": "Limit",
        //     "t": 1647614461160,
        //     "p": "50",
        //     "q": "0.1",
        //     "sd": "Buy",
        //     "st": "New",
        //     "ap": "0",
        //     "cfq": "0",
        //     "sp": '',
        //     "err": '',
        //     "btb": "0",
        //     "bab": "0",
        //     "qtb": "8",
        //     "qab": "2.995",
        //     "cf": "0",
        //     "fa": "USDT",
        //     "ei": "NULL_VAL"
        //   }
        // }
        //
        //  futures order
        // {
        //     "m": "futures-order",
        //     "sn": 19399927636,
        //     "e": "ExecutionReport",
        //     "a": "futF5SlR9ukAXoDOuXbND4dVpBMw9gzH", // account id
        //     "ac": "FUTURES",
        //     "t": 1647622515434, // last execution time
        //      (...)
        // }
        //
        object accountType = this.safeString(message, "ac");
        object messageHash = add("order:", accountType);
        object data = this.safeValue(message, "data", message);
        object order = this.parseWsOrder(data);
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object orders = this.orders;
        callDynamically(orders, "append", new object[] {order});
        object symbolMessageHash = add(add(messageHash, ":"), getValue(order, "symbol"));
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, symbolMessageHash});
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        // spot order
        //    {
        //          "sn": 19399016185, //sequence number
        //          "orderId": "r17f9d7983faU7223046196CMlrj3bfC",
        //          "s": "LTC/USDT",
        //          "ot": "Limit", // order type
        //          "t": 1647614461160, // last execution timestamp
        //          "p": "50", // price
        //          "q": "0.1", // quantity
        //          "sd": "Buy", // side
        //          "st": "New", // status
        //          "ap": "0", // average fill price
        //          "cfq": "0", // cumulated fill quantity
        //          "sp": '', // stop price
        //          "err": '',
        //          "btb": "0", // base asset total balance
        //          "bab": "0", // base asset available balance
        //          "qtb": "8", // quote asset total balance
        //          "qab": "2.995", // quote asset available balance
        //          "cf": "0", // cumulated commission
        //          "fa": "USDT", // fee asset
        //          "ei": "NULL_VAL"
        //        }
        //
        //  futures order
        // {
        //     "m": "futures-order",
        //     "sn": 19399927636,
        //     "e": "ExecutionReport",
        //     "a": "futF5SlR9ukAXoDOuXbND4dVpBMw9gzH", // account id
        //     "ac": "FUTURES",
        //     "t": 1647622515434, // last execution time
        //     "ct": 1647622515413, // order creation time
        //     "orderId": "r17f9df469b1U7223046196Okf5Kbmd",
        //     "sd": "Buy", // side
        //     "ot": "Limit", // order type
        //     "ei": "NULL_VAL",
        //     "q": "1", // quantity
        //     "p": "50", //price
        //     "sp": "0", // stopPrice
        //     "spb": '',  // stopTrigger
        //     "s": "LTC-PERP", // symbol
        //     "st": "New", // state
        //     "err": '',
        //     "lp": "0", // last filled price
        //     "lq": "0", // last filled quantity (base asset)
        //     "ap": "0",  // average filled price
        //     "cfq": "0", // cummulative filled quantity (base asset)
        //     "f": "0", // commission fee of the current execution
        //     "cf": "0", // cumulative commission fee
        //     "fa": "USDT", // fee asset
        //     "psl": "0",
        //     "pslt": "market",
        //     "ptp": "0",
        //     "ptpt": "market"
        //   }
        //
        object status = this.parseOrderStatus(this.safeString(order, "st"));
        object marketId = this.safeString(order, "s");
        object timestamp = this.safeInteger(order, "t");
        object symbol = this.safeSymbol(marketId, market, "/");
        object lastTradeTimestamp = this.safeInteger(order, "t");
        object price = this.safeString(order, "p");
        object amount = this.safeString(order, "q");
        object average = this.safeString(order, "ap");
        object filled = this.safeString(order, "cfq");
        object id = this.safeString(order, "orderId");
        object type = this.safeStringLower(order, "ot");
        object side = this.safeStringLower(order, "sd");
        object feeCost = this.safeNumber(order, "cf");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrencyId = this.safeString(order, "fa");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrencyCode },
            };
        }
        object stopPrice = this.parseNumber(this.omitZero(this.safeString(order, "sp")));
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "amount", amount },
            { "cost", null },
            { "average", average },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", fee },
            { "trades", null },
        }, market);
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        //
        // {
        //     "m": "disconnected",
        //     "code": 100005,
        //     "reason": "INVALID_WS_REQUEST_DATA",
        //     "info": "Session is disconnected due to missing pong message from the client"
        //   }
        //
        object errorCode = this.safeInteger(message, "code");
        try
        {
            if (isTrue(!isEqual(errorCode, null)))
            {
                object feedback = add(add(this.id, " "), this.json(message));
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
                object messageString = this.safeValue(message, "message");
                if (isTrue(!isEqual(messageString, null)))
                {
                    this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), messageString, feedback);
                }
            }
            return false;
        } catch(Exception e)
        {
            if (isTrue(e is AuthenticationError))
            {
                object messageHash = "authenticated";
                ((WebSocketClient)client).reject(e, messageHash);
                if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
                {

                }
            } else
            {
                ((WebSocketClient)client).reject(e);
            }
            return true;
        }
    }

    public virtual void handleAuthenticate(WebSocketClient client, object message)
    {
        //
        //     { m: "auth", id: "1647605234", code: 0 }
        //
        object messageHash = "authenticated";
        callDynamically(client as WebSocketClient, "resolve", new object[] {message, messageHash});
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            return;
        }
        //
        //     { m: "ping", hp: 3 }
        //
        //     { m: "sub", ch: "bar:BTC/USDT", code: 0 }
        //
        //     { m: 'sub', id: "1647515701", ch: "depth:BTC/USDT", code: 0 }
        //
        //     { m: "connected", type: "unauth" }
        //
        //     { m: "auth", id: "1647605234", code: 0 }
        //
        // order or balance sub
        // {
        //     "m": "sub",
        //     "id": "1647605952",
        //     "ch": "order:cshF5SlR9ukAXoDOuXbND4dVpBMw9gzH", or futures-order
        //     "code": 0
        //   }
        //
        // ohlcv
        //  {
        //     "m": "bar",
        //     "s": "BTC/USDT",
        //     "data": {
        //       "i": "1",
        //       "ts": 1647510060000,
        //       "o": "40813.93",
        //       "c": "40804.57",
        //       "h": "40814.21",
        //       "l": "40804.56",
        //       "v": "0.01537"
        //     }
        //   }
        //
        // trades
        //
        //    {
        //        "m": "trades",
        //        "symbol": "BTC/USDT",
        //        "data": [
        //          {
        //            "p": "40762.26",
        //            "q": "0.01500",
        //            "ts": 1647514306759,
        //            "bm": true,
        //            "seqnum": 72057633465795180
        //          }
        //        ]
        //    }
        //
        // orderbook deltas
        //
        // {
        //     "m":"depth",
        //     "symbol":"BTC/USDT",
        //     "data":{
        //        "ts":1647527417715,
        //        "seqnum":28590257013,
        //        "asks":[
        //           ["40990.47","0.01619"],
        //           ["41021.21","0"],
        //           ["41031.59","0.06096"]
        //        ],
        //        "bids":[
        //           ["40990.46","0.76114"],
        //           ["40985.18","0"]
        //        ]
        //     }
        //  }
        //
        // orderbook snapshot
        //  {
        //     "m": "depth-snapshot",
        //     "symbol": "BTC/USDT",
        //     "data": {
        //       "ts": 1647525938513,
        //       "seqnum": 28590504772,
        //       "asks": [
        //         [Array], [Array], [Array], [Array], [Array], [Array], [Array],
        //         [Array], [Array], [Array], [Array], [Array], [Array], [Array],
        //         [Array], [Array], [Array], [Array], [Array], [Array], [Array],
        //          (...)
        //       ]
        //  }
        //
        // spot order update
        //  {
        //      "m": "order",
        //      "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
        //      "ac": "CASH",
        //      "data": {
        //          "s":       "BTC/USDT",
        //          "sn":       8159711,
        //          "sd":      "Buy",
        //          "ap":      "0",
        //          "bab":     "2006.5974027",
        //          "btb":     "2006.5974027",
        //          "cf":      "0",
        //          "cfq":     "0",
        //          (...)
        //      }
        //  }
        // future order update
        // {
        //     "m": "futures-order",
        //     "sn": 19404258063,
        //     "e": "ExecutionReport",
        //     "a": "futF5SlR9ukAXoDOuXbND4dVpBMw9gzH",
        //     "ac": "FUTURES",
        //     "t": 1647681792543,
        //     "ct": 1647622515413,
        //     "orderId": "r17f9df469b1U7223046196Okf5KbmdL",
        //         (...)
        //     "ptpt": "None"
        //   }
        //
        // balance update cash
        // {
        //     "m": "balance",
        //     "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
        //     "ac": "CASH",
        //     "data": {
        //         "a" : "USDT",
        //         "sn": 8159798,
        //         "tb": "600",
        //         "ab": "600"
        //     }
        // }
        //
        // balance update margin
        // {
        //     "m": "balance",
        //     "accountId": "marOxpKJV83dxTRx0Eyxpa0gxc4Txt0P",
        //     "ac": "MARGIN",
        //     "data": {
        //         "a"  : "USDT",
        //         "sn" : 8159802,
        //         "tb" : "400",
        //         "ab" : "400",
        //         "brw": "0",
        //         "int": "0"
        //     }
        // }
        //
        object subject = this.safeString(message, "m");
        object methods = new Dictionary<string, object>() {
            { "ping", this.handlePing },
            { "auth", this.handleAuthenticate },
            { "sub", this.handleSubscriptionStatus },
            { "depth", this.handleOrderBook },
            { "depth-snapshot", this.handleOrderBookSnapshot },
            { "trades", this.handleTrades },
            { "bar", this.handleOHLCV },
            { "balance", this.handleBalance },
            { "futures-account-update", this.handleBalance },
        };
        object method = this.safeValue(methods, subject);
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
        if (isTrue(isTrue((isEqual(subject, "order"))) || isTrue((isEqual(subject, "futures-order")))))
        {
            // this.handleOrder (client as WebSocketClient, message);
            // balance updates may be in the order structure
            // they may also be standalone balance updates related to account transfers
            this.handleOrder(client as WebSocketClient, message);
            if (isTrue(isEqual(subject, "order")))
            {
                this.handleBalance(client as WebSocketClient, message);
            }
        }
    }

    public virtual object handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //     { m: "sub", ch: "bar:BTC/USDT", code: 0 }
        //
        //     { m: 'sub', id: "1647515701", ch: "depth:BTC/USDT", code: 0 }
        //
        object channel = this.safeString(message, "ch", "");
        if (isTrue(isTrue(isGreaterThan(getIndexOf(channel, "depth"), -1)) && !isTrue((isGreaterThan(getIndexOf(channel, "depth-snapshot"), -1)))))
        {
            this.handleOrderBookSubscription(client as WebSocketClient, message);
        }
        return message;
    }

    public virtual void handleOrderBookSubscription(WebSocketClient client, object message)
    {
        object channel = this.safeString(message, "ch");
        object parts = ((string)channel).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
        object marketId = getValue(parts, 1);
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        if (isTrue(inOp(this.orderbooks, symbol)))
        {

        }
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {});
        if (isTrue(isTrue(isEqual(getValue(this.options, "defaultType"), "swap")) || isTrue(getValue(market, "contract"))))
        {
            this.spawn(this.fetchOrderBookSnapshot, new object[] { symbol});
        } else
        {
            this.spawn(this.watchOrderBookSnapshot, new object[] { symbol});
        }
    }

    public async virtual Task pong(WebSocketClient client, object message)
    {
        try
        {
            await client.send(new Dictionary<string, object>() {
                { "op", "pong" },
                { "hp", this.safeInteger(message, "hp") },
            });
        } catch(Exception e)
        {
            var error = new NetworkError(add(add(this.id, " handlePing failed with error "), this.json(e)));
            ((WebSocketClient)client).reset(error);
        }
    }

    public virtual void handlePing(WebSocketClient client, object message)
    {
        this.spawn(this.pong, new object[] { client, message});
    }

    public async virtual Task<object> authenticate(object url, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object messageHash = "authenticated";
        var client = this.client(url);
        var future = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(future, null)))
        {
            object timestamp = ((object)this.milliseconds()).ToString();
            object urlParts = ((string)url).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
            object partsLength = getArrayLength(urlParts);
            object path = this.safeString(urlParts, subtract(partsLength, 1));
            object version = this.safeString(urlParts, subtract(partsLength, 2));
            object auth = add(add(add(add(timestamp, "+"), version), "/"), path);
            object secret = this.base64ToBinary(this.secret);
            object signature = this.hmac(this.encode(auth), secret, sha256, "base64");
            object request = new Dictionary<string, object>() {
                { "op", "auth" },
                { "id", ((object)this.nonce()).ToString() },
                { "t", timestamp },
                { "key", this.apiKey },
                { "sig", signature },
            };
            future = await this.watch(url, messageHash, this.extend(request, parameters), messageHash);
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)messageHash] = future;
        }
        return future;
    }
}
