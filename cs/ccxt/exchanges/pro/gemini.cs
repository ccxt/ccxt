namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class gemini { public gemini(object args = null) : base(args) { } }
public partial class gemini : ccxt.gemini
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchBalance", false },
                { "watchTicker", false },
                { "watchTickers", false },
                { "watchBidsAsks", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
                { "watchMyTrades", false },
                { "watchOrders", true },
                { "watchOrderBook", true },
                { "watchOrderBookForSymbols", true },
                { "watchOHLCV", true },
            } },
            { "hostname", "api.gemini.com" },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", "wss://api.gemini.com" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "ws", "wss://api.sandbox.gemini.com" },
                } },
            } },
        });
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gemini#watchTrades
        * @description watch the list of most recent trades for a particular symbol
        * @see https://docs.gemini.com/websocket-api/#market-data-version-2
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object messageHash = add("trades:", getValue(market, "symbol"));
        object marketId = getValue(market, "id");
        object request = new Dictionary<string, object>() {
            { "type", "subscribe" },
            { "subscriptions", new List<object>() {new Dictionary<string, object>() {
    { "name", "l2" },
    { "symbols", new List<object> {((string)marketId).ToUpper()} },
}} },
        };
        object subscribeHash = add("l2:", getValue(market, "symbol"));
        object url = add(getValue(getValue(this.urls, "api"), "ws"), "/v2/marketdata");
        object trades = await this.watch(url, messageHash, request, subscribeHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {getValue(market, "symbol"), limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gemini#watchTradesForSymbols
        * @see https://docs.gemini.com/websocket-api/#multi-market-data
        * @description get the list of most recent trades for a list of symbols
        * @param {string[]} symbols unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        object trades = await this.helperForWatchMultipleConstruct("trades", symbols, parameters);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeList(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        // regular v2 trade
        //
        //     {
        //         "type": "trade",
        //         "symbol": "BTCUSD",
        //         "event_id": 122258166738,
        //         "timestamp": 1655330221424,
        //         "price": "22269.14",
        //         "quantity": "0.00004473",
        //         "side": "buy"
        //     }
        //
        // multi data trade
        //
        //    {
        //        "type": "trade",
        //        "symbol": "ETHUSD",
        //        "tid": "1683002242170204", // this is not TS, but somewhat ID
        //        "price": "2299.24",
        //        "amount": "0.002662",
        //        "makerSide": "bid"
        //    }
        //
        object timestamp = this.safeInteger(trade, "timestamp");
        object id = this.safeString2(trade, "event_id", "tid");
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString2(trade, "quantity", "amount");
        object side = this.safeStringLower(trade, "side");
        if (isTrue(isEqual(side, null)))
        {
            object marketSide = this.safeStringLower(trade, "makerSide");
            if (isTrue(isEqual(marketSide, "bid")))
            {
                side = "sell";
            } else if (isTrue(isEqual(marketSide, "ask")))
            {
                side = "buy";
            }
        }
        object marketId = this.safeStringLower(trade, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "order", null },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", null },
            { "side", side },
            { "takerOrMaker", null },
            { "price", priceString },
            { "cost", null },
            { "amount", amountString },
            { "fee", null },
        }, market);
    }

    public virtual void handleTrade(WebSocketClient client, object message)
    {
        //
        //     {
        //         "type": "trade",
        //         "symbol": "BTCUSD",
        //         "event_id": 122278173770,
        //         "timestamp": 1655335880981,
        //         "price": "22530.80",
        //         "quantity": "0.04",
        //         "side": "buy"
        //     }
        //
        object trade = this.parseWsTrade(message);
        object symbol = getValue(trade, "symbol");
        object tradesLimit = this.safeInteger(this.options, "tradesLimit", 1000);
        object stored = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(stored, null)))
        {
            stored = new ArrayCache(tradesLimit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        callDynamically(stored, "append", new object[] {trade});
        object messageHash = add("trades:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //         "type": "l2_updates",
        //         "symbol": "BTCUSD",
        //         "changes": [
        //             [ "buy", '22252.37', "0.02" ],
        //             [ "buy", '22251.61', "0.04" ],
        //             [ "buy", '22251.60', "0.04" ],
        //             // some asks as well
        //         ],
        //         "trades": [
        //             { type: 'trade', symbol: 'BTCUSD', event_id: 122258166738, timestamp: 1655330221424, price: '22269.14', quantity: "0.00004473", side: "buy" },
        //             { type: 'trade', symbol: 'BTCUSD', event_id: 122258141090, timestamp: 1655330213216, price: '22250.00', quantity: "0.00704098", side: "buy" },
        //             { type: 'trade', symbol: 'BTCUSD', event_id: 122258118291, timestamp: 1655330206753, price: '22250.00', quantity: "0.03", side: "buy" },
        //         ],
        //         "auction_events": [
        //             {
        //                 "type": "auction_result",
        //                 "symbol": "BTCUSD",
        //                 "time_ms": 1655323200000,
        //                 "result": "failure",
        //                 "highest_bid_price": "21590.88",
        //                 "lowest_ask_price": "21602.30",
        //                 "collar_price": "21634.73"
        //             },
        //             {
        //                 "type": "auction_indicative",
        //                 "symbol": "BTCUSD",
        //                 "time_ms": 1655323185000,
        //                 "result": "failure",
        //                 "highest_bid_price": "21661.90",
        //                 "lowest_ask_price": "21663.78",
        //                 "collar_price": "21662.845"
        //             },
        //         ]
        //     }
        //
        object marketId = this.safeStringLower(message, "symbol");
        object market = this.safeMarket(marketId);
        object trades = this.safeValue(message, "trades");
        if (isTrue(!isEqual(trades, null)))
        {
            object symbol = getValue(market, "symbol");
            object tradesLimit = this.safeInteger(this.options, "tradesLimit", 1000);
            object stored = this.safeValue(this.trades, symbol);
            if (isTrue(isEqual(stored, null)))
            {
                stored = new ArrayCache(tradesLimit);
                ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
            }
            for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
            {
                object trade = this.parseWsTrade(getValue(trades, i), market);
                callDynamically(stored, "append", new object[] {trade});
            }
            object messageHash = add("trades:", symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        }
    }

    public virtual void handleTradesForMultidata(WebSocketClient client, object trades, object timestamp)
    {
        if (isTrue(!isEqual(trades, null)))
        {
            object tradesLimit = this.safeInteger(this.options, "tradesLimit", 1000);
            object storesForSymbols = new Dictionary<string, object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
            {
                object marketId = getValue(getValue(trades, i), "symbol");
                object market = this.safeMarket(((string)marketId).ToLower());
                object symbol = getValue(market, "symbol");
                object trade = this.parseWsTrade(getValue(trades, i), market);
                ((IDictionary<string,object>)trade)["timestamp"] = timestamp;
                ((IDictionary<string,object>)trade)["datetime"] = this.iso8601(timestamp);
                object stored = this.safeValue(this.trades, symbol);
                if (isTrue(isEqual(stored, null)))
                {
                    stored = new ArrayCache(tradesLimit);
                    ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
                }
                callDynamically(stored, "append", new object[] {trade});
                ((IDictionary<string,object>)storesForSymbols)[(string)symbol] = stored;
            }
            object symbols = new List<object>(((IDictionary<string,object>)storesForSymbols).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                object stored = getValue(storesForSymbols, symbol);
                object messageHash = add("trades:", symbol);
                callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
            }
        }
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gemini#fetchOHLCV
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://docs.gemini.com/websocket-api/#candles-data-feed
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object timeframeId = this.safeString(this.timeframes, timeframe, timeframe);
        object request = new Dictionary<string, object>() {
            { "type", "subscribe" },
            { "subscriptions", new List<object>() {new Dictionary<string, object>() {
    { "name", add("candles_", timeframeId) },
    { "symbols", new List<object> {((string)getValue(market, "id")).ToUpper()} },
}} },
        };
        object messageHash = add(add(add("ohlcv:", getValue(market, "symbol")), ":"), timeframeId);
        object url = add(getValue(getValue(this.urls, "api"), "ws"), "/v2/marketdata");
        object ohlcv = await this.watch(url, messageHash, request, messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual object handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "type": "candles_15m_updates",
        //         "symbol": "BTCUSD",
        //         "changes": [
        //             [
        //                 1561054500000,
        //                 9350.18,
        //                 9358.35,
        //                 9350.18,
        //                 9355.51,
        //                 2.07
        //             ],
        //             [
        //                 1561053600000,
        //                 9357.33,
        //                 9357.33,
        //                 9350.18,
        //                 9350.18,
        //                 1.5900161
        //             ]
        //             ...
        //         ]
        //     }
        //
        object type = this.safeString(message, "type", "");
        object timeframeId = slice(type, 8, null);
        object timeframeEndIndex = getIndexOf(timeframeId, "_");
        timeframeId = slice(timeframeId, 0, timeframeEndIndex);
        object marketId = ((string)this.safeString(message, "symbol", "")).ToLower();
        object market = this.safeMarket(marketId);
        object symbol = this.safeSymbol(marketId, market);
        object changes = this.safeValue(message, "changes", new List<object>() {});
        object timeframe = this.findTimeframe(timeframeId);
        object ohlcvsBySymbol = this.safeValue(this.ohlcvs, symbol);
        if (isTrue(isEqual(ohlcvsBySymbol, null)))
        {
            ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = new Dictionary<string, object>() {};
        }
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
        }
        object changesLength = getArrayLength(changes);
        // reverse order of array to store candles in ascending order
        for (object i = 0; isLessThan(i, changesLength); postFixIncrement(ref i))
        {
            object index = subtract(subtract(changesLength, i), 1);
            object parsed = this.parseOHLCV(getValue(changes, index), market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        object messageHash = add(add(add("ohlcv:", symbol), ":"), timeframeId);
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        return message;
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gemini#watchOrderBook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://docs.gemini.com/websocket-api/#market-data-version-2
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object messageHash = add("orderbook:", getValue(market, "symbol"));
        object marketId = getValue(market, "id");
        object request = new Dictionary<string, object>() {
            { "type", "subscribe" },
            { "subscriptions", new List<object>() {new Dictionary<string, object>() {
    { "name", "l2" },
    { "symbols", new List<object> {((string)marketId).ToUpper()} },
}} },
        };
        object subscribeHash = add("l2:", getValue(market, "symbol"));
        object url = add(getValue(getValue(this.urls, "api"), "ws"), "/v2/marketdata");
        object orderbook = await this.watch(url, messageHash, request, subscribeHash);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        object changes = this.safeValue(message, "changes", new List<object>() {});
        object marketId = this.safeStringLower(message, "symbol");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object messageHash = add("orderbook:", symbol);
        // let orderbook = this.safeValue (this.orderbooks, symbol);
        if (!isTrue((inOp(this.orderbooks, symbol))))
        {
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook();
        }
        object orderbook = getValue(this.orderbooks, symbol);
        for (object i = 0; isLessThan(i, getArrayLength(changes)); postFixIncrement(ref i))
        {
            object delta = getValue(changes, i);
            object price = this.safeNumber(delta, 1);
            object size = this.safeNumber(delta, 2);
            object side = ((bool) isTrue((isEqual(getValue(delta, 0), "buy")))) ? "bids" : "asks";
            object bookside = getValue(orderbook, side);
            (bookside as IOrderBookSide).store(price, size);
            ((IDictionary<string,object>)orderbook)[(string)side] = bookside;
        }
        ((IDictionary<string,object>)orderbook)["symbol"] = symbol;
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gemini#watchOrderBookForSymbols
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://docs.gemini.com/websocket-api/#multi-market-data
        * @param {string[]} symbols unified array of symbols
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        object orderbook = await this.helperForWatchMultipleConstruct("orderbook", symbols, parameters);
        return (orderbook as IOrderBook).limit();
    }

    public async override Task<object> watchBidsAsks(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name gemini#watchBidsAsks
        * @description watches best bid & ask for symbols
        * @see https://docs.gemini.com/websocket-api/#multi-market-data
        * @param {string[]} symbols unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.helperForWatchMultipleConstruct("bidsasks", symbols, parameters);
    }

    public virtual void handleBidsAsksForMultidata(WebSocketClient client, object rawBidAskChanges, object timestamp, object nonce)
    {
        //
        // {
        //     eventId: '1683002916916153',
        //     events: [
        //       {
        //         price: '50945.37',
        //         reason: 'top-of-book',
        //         remaining: '0.0',
        //         side: 'bid',
        //         symbol: 'BTCUSDT',
        //         type: 'change'
        //       },
        //       {
        //         price: '50947.75',
        //         reason: 'top-of-book',
        //         remaining: '0.11725',
        //         side: 'bid',
        //         symbol: 'BTCUSDT',
        //         type: 'change'
        //       }
        //     ],
        //     socket_sequence: 322,
        //     timestamp: 1708674495,
        //     timestampms: 1708674495174,
        //     type: 'update'
        // }
        //
        object marketId = getValue(getValue(rawBidAskChanges, 0), "symbol");
        object market = this.safeMarket(((string)marketId).ToLower());
        object symbol = getValue(market, "symbol");
        if (!isTrue((inOp(this.bidsasks, symbol))))
        {
            ((IDictionary<string,object>)this.bidsasks)[(string)symbol] = this.parseTicker(new Dictionary<string, object>() {});
            ((IDictionary<string,object>)getValue(this.bidsasks, symbol))["symbol"] = symbol;
        }
        object currentBidAsk = getValue(this.bidsasks, symbol);
        object messageHash = add("bidsasks:", symbol);
        // last update always overwrites the previous state and is the latest state
        for (object i = 0; isLessThan(i, getArrayLength(rawBidAskChanges)); postFixIncrement(ref i))
        {
            object entry = getValue(rawBidAskChanges, i);
            object rawSide = this.safeString(entry, "side");
            object price = this.safeNumber(entry, "price");
            object size = this.safeNumber(entry, "remaining");
            if (isTrue(isEqual(size, 0)))
            {
                continue;
            }
            if (isTrue(isEqual(rawSide, "bid")))
            {
                ((IDictionary<string,object>)currentBidAsk)["bid"] = price;
                ((IDictionary<string,object>)currentBidAsk)["bidVolume"] = size;
            } else
            {
                ((IDictionary<string,object>)currentBidAsk)["ask"] = price;
                ((IDictionary<string,object>)currentBidAsk)["askVolume"] = size;
            }
        }
        ((IDictionary<string,object>)currentBidAsk)["timestamp"] = timestamp;
        ((IDictionary<string,object>)currentBidAsk)["datetime"] = this.iso8601(timestamp);
        ((IDictionary<string,object>)currentBidAsk)["info"] = rawBidAskChanges;
        ((IDictionary<string,object>)this.bidsasks)[(string)symbol] = currentBidAsk;
        callDynamically(client as WebSocketClient, "resolve", new object[] {currentBidAsk, messageHash});
    }

    public async virtual Task<object> helperForWatchMultipleConstruct(object itemHashName, object symbols, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false, true, true);
        object firstMarket = this.market(getValue(symbols, 0));
        if (isTrue(!isTrue(getValue(firstMarket, "spot")) && !isTrue(getValue(firstMarket, "linear"))))
        {
            throw new NotSupported ((string)add(this.id, " watchMultiple supports only spot or linear-swap symbols")) ;
        }
        object messageHashes = new List<object>() {};
        object marketIds = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object messageHash = add(add(itemHashName, ":"), symbol);
            ((IList<object>)messageHashes).Add(messageHash);
            object market = this.market(symbol);
            ((IList<object>)marketIds).Add(getValue(market, "id"));
        }
        object queryStr = String.Join(",", ((IList<object>)marketIds).ToArray());
        object url = add(add(add(getValue(getValue(this.urls, "api"), "ws"), "/v1/multimarketdata?symbols="), queryStr), "&heartbeat=true&");
        if (isTrue(isEqual(itemHashName, "orderbook")))
        {
            url = add(url, "trades=false&bids=true&offers=true");
        } else if (isTrue(isEqual(itemHashName, "bidsasks")))
        {
            url = add(url, "trades=false&bids=true&offers=true&top_of_book=true");
        } else if (isTrue(isEqual(itemHashName, "trades")))
        {
            url = add(url, "trades=true&bids=false&offers=false");
        }
        return await this.watchMultiple(url, messageHashes, null);
    }

    public virtual void handleOrderBookForMultidata(WebSocketClient client, object rawOrderBookChanges, object timestamp, object nonce)
    {
        //
        // rawOrderBookChanges
        //
        // [
        //   {
        //     delta: "4105123935484.817624",
        //     price: "0.000000001",
        //     reason: "initial", // initial|cancel|place
        //     remaining: "4105123935484.817624",
        //     side: "bid", // bid|ask
        //     symbol: "SHIBUSD",
        //     type: "change", // seems always change
        //   },
        //   ...
        //
        object marketId = getValue(getValue(rawOrderBookChanges, 0), "symbol");
        object market = this.safeMarket(((string)marketId).ToLower());
        object symbol = getValue(market, "symbol");
        object messageHash = add("orderbook:", symbol);
        if (!isTrue((inOp(this.orderbooks, symbol))))
        {
            object ob = this.orderBook();
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = ob;
        }
        object orderbook = getValue(this.orderbooks, symbol);
        object bids = getValue(orderbook, "bids");
        object asks = getValue(orderbook, "asks");
        for (object i = 0; isLessThan(i, getArrayLength(rawOrderBookChanges)); postFixIncrement(ref i))
        {
            object entry = getValue(rawOrderBookChanges, i);
            object price = this.safeNumber(entry, "price");
            object size = this.safeNumber(entry, "remaining");
            object rawSide = this.safeString(entry, "side");
            if (isTrue(isEqual(rawSide, "bid")))
            {
                (bids as IOrderBookSide).store(price, size);
            } else
            {
                (asks as IOrderBookSide).store(price, size);
            }
        }
        ((IDictionary<string,object>)orderbook)["bids"] = bids;
        ((IDictionary<string,object>)orderbook)["asks"] = asks;
        ((IDictionary<string,object>)orderbook)["symbol"] = symbol;
        ((IDictionary<string,object>)orderbook)["nonce"] = nonce;
        ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
        ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public virtual void handleL2Updates(WebSocketClient client, object message)
    {
        //
        //     {
        //         "type": "l2_updates",
        //         "symbol": "BTCUSD",
        //         "changes": [
        //             [ "buy", '22252.37', "0.02" ],
        //             [ "buy", '22251.61', "0.04" ],
        //             [ "buy", '22251.60', "0.04" ],
        //             // some asks as well
        //         ],
        //         "trades": [
        //             { type: 'trade', symbol: 'BTCUSD', event_id: 122258166738, timestamp: 1655330221424, price: '22269.14', quantity: "0.00004473", side: "buy" },
        //             { type: 'trade', symbol: 'BTCUSD', event_id: 122258141090, timestamp: 1655330213216, price: '22250.00', quantity: "0.00704098", side: "buy" },
        //             { type: 'trade', symbol: 'BTCUSD', event_id: 122258118291, timestamp: 1655330206753, price: '22250.00', quantity: "0.03", side: "buy" },
        //         ],
        //         "auction_events": [
        //             {
        //                 "type": "auction_result",
        //                 "symbol": "BTCUSD",
        //                 "time_ms": 1655323200000,
        //                 "result": "failure",
        //                 "highest_bid_price": "21590.88",
        //                 "lowest_ask_price": "21602.30",
        //                 "collar_price": "21634.73"
        //             },
        //             {
        //                 "type": "auction_indicative",
        //                 "symbol": "BTCUSD",
        //                 "time_ms": 1655323185000,
        //                 "result": "failure",
        //                 "highest_bid_price": "21661.90",
        //                 "lowest_ask_price": "21663.79",
        //                 "collar_price": "21662.845"
        //             },
        //         ]
        //     }
        //
        this.handleOrderBook(client as WebSocketClient, message);
        this.handleTrades(client as WebSocketClient, message);
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gemini#fetchOrders
        * @description watches information on multiple orders made by the user
        * @see https://docs.gemini.com/websocket-api/#order-events
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object url = add(getValue(getValue(this.urls, "api"), "ws"), "/v1/order/events?eventTypeFilter=initial&eventTypeFilter=accepted&eventTypeFilter=rejected&eventTypeFilter=fill&eventTypeFilter=cancelled&eventTypeFilter=booked");
        await this.loadMarkets();
        object authParams = new Dictionary<string, object>() {
            { "url", url },
        };
        await this.authenticate(authParams);
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        object messageHash = "orders";
        object orders = await this.watch(url, messageHash, null, messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual object handleHeartbeat(WebSocketClient client, object message)
    {
        //
        //     {
        //         "type": "heartbeat",
        //         "timestampms": 1659740268958,
        //         "sequence": 7,
        //         "trace_id": "25b3d92476dd3a9a5c03c9bd9e0a0dba",
        //         "socket_sequence": 7
        //     }
        //
        client.lastPong = this.milliseconds();
        return message;
    }

    public virtual object handleSubscription(WebSocketClient client, object message)
    {
        //
        //     {
        //         "type": "subscription_ack",
        //         "accountId": 19433282,
        //         "subscriptionId": "orderevents-websocket-25b3d92476dd3a9a5c03c9bd9e0a0dba",
        //         "symbolFilter": [],
        //         "apiSessionFilter": [],
        //         "eventTypeFilter": []
        //     }
        //
        return message;
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        //
        //     [
        //         {
        //             "type": "accepted",
        //             "order_id": "134150423884",
        //             "event_id": "134150423886",
        //             "account_name": "primary",
        //             "client_order_id": "1659739406916",
        //             "api_session": "account-pnBFSS0XKGvDamX4uEIt",
        //             "symbol": "batbtc",
        //             "side": "sell",
        //             "order_type": "exchange limit",
        //             "timestamp": "1659739407",
        //             "timestampms": 1659739407576,
        //             "is_live": true,
        //             "is_cancelled": false,
        //             "is_hidden": false,
        //             "original_amount": "1",
        //             "price": "1",
        //             "socket_sequence": 139
        //         }
        //     ]
        //
        object messageHash = "orders";
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object orders = this.orders;
        for (object i = 0; isLessThan(i, getArrayLength(message)); postFixIncrement(ref i))
        {
            object order = this.parseWsOrder(getValue(message, i));
            callDynamically(orders, "append", new object[] {order});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageHash});
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        //     {
        //         "type": "accepted",
        //         "order_id": "134150423884",
        //         "event_id": "134150423886",
        //         "account_name": "primary",
        //         "client_order_id": "1659739406916",
        //         "api_session": "account-pnBFSS0XKGvDamX4uEIt",
        //         "symbol": "batbtc",
        //         "side": "sell",
        //         "order_type": "exchange limit",
        //         "timestamp": "1659739407",
        //         "timestampms": 1659739407576,
        //         "is_live": true,
        //         "is_cancelled": false,
        //         "is_hidden": false,
        //         "original_amount": "1",
        //         "price": "1",
        //         "socket_sequence": 139
        //     }
        //
        object timestamp = this.safeInteger(order, "timestampms");
        object status = this.safeString(order, "type");
        object marketId = this.safeString(order, "symbol");
        object typeId = this.safeString(order, "order_type");
        object behavior = this.safeString(order, "behavior");
        object timeInForce = "GTC";
        object postOnly = false;
        if (isTrue(isEqual(behavior, "immediate-or-cancel")))
        {
            timeInForce = "IOC";
        } else if (isTrue(isEqual(behavior, "fill-or-kill")))
        {
            timeInForce = "FOK";
        } else if (isTrue(isEqual(behavior, "maker-or-cancel")))
        {
            timeInForce = "PO";
            postOnly = true;
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(order, "order_id") },
            { "clientOrderId", this.safeString(order, "client_order_id") },
            { "info", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "status", this.parseWsOrderStatus(status) },
            { "symbol", this.safeSymbol(marketId, market) },
            { "type", this.parseWsOrderType(typeId) },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "side", this.safeString(order, "side") },
            { "price", this.safeNumber(order, "price") },
            { "stopPrice", null },
            { "average", this.safeNumber(order, "avg_execution_price") },
            { "cost", null },
            { "amount", this.safeNumber(order, "original_amount") },
            { "filled", this.safeNumber(order, "executed_amount") },
            { "remaining", this.safeNumber(order, "remaining_amount") },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public virtual object parseWsOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "accepted", "open" },
            { "booked", "open" },
            { "fill", "closed" },
            { "cancelled", "canceled" },
            { "cancel_rejected", "rejected" },
            { "rejected", "rejected" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseWsOrderType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "exchange limit", "limit" },
            { "market buy", "market" },
            { "market sell", "market" },
        };
        return this.safeString(types, type, type);
    }

    public virtual void handleError(WebSocketClient client, object message)
    {
        throw new ExchangeError ((string)this.json(message)) ;
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        //
        //  public
        //     {
        //         "type": "trade",
        //         "symbol": "BTCUSD",
        //         "event_id": 122278173770,
        //         "timestamp": 1655335880981,
        //         "price": "22530.80",
        //         "quantity": "0.04",
        //         "side": "buy"
        //     }
        //
        //  private
        //     [
        //         {
        //             "type": "accepted",
        //             "order_id": "134150423884",
        //             "event_id": "134150423886",
        //             "account_name": "primary",
        //             "client_order_id": "1659739406916",
        //             "api_session": "account-pnBFSS0XKGvDamX4uEIt",
        //             "symbol": "batbtc",
        //             "side": "sell",
        //             "order_type": "exchange limit",
        //             "timestamp": "1659739407",
        //             "timestampms": 1659739407576,
        //             "is_live": true,
        //             "is_cancelled": false,
        //             "is_hidden": false,
        //             "original_amount": "1",
        //             "price": "1",
        //             "socket_sequence": 139
        //         }
        //     ]
        //
        object isArray = ((message is IList<object>) || (message.GetType().IsGenericType && message.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))));
        if (isTrue(isArray))
        {
            this.handleOrder(client as WebSocketClient, message);
            return;
        }
        object reason = this.safeString(message, "reason");
        if (isTrue(isEqual(reason, "error")))
        {
            this.handleError(client as WebSocketClient, message);
        }
        object methods = new Dictionary<string, object>() {
            { "l2_updates", this.handleL2Updates },
            { "trade", this.handleTrade },
            { "subscription_ack", this.handleSubscription },
            { "heartbeat", this.handleHeartbeat },
        };
        object type = this.safeString(message, "type", "");
        if (isTrue(isGreaterThanOrEqual(getIndexOf(type, "candles"), 0)))
        {
            this.handleOHLCV(client as WebSocketClient, message);
            return;
        }
        object method = this.safeValue(methods, type);
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
        // handle multimarketdata
        if (isTrue(isEqual(type, "update")))
        {
            object ts = this.safeInteger(message, "timestampms", this.milliseconds());
            object eventId = this.safeInteger(message, "eventId");
            object events = this.safeList(message, "events");
            object orderBookItems = new List<object>() {};
            object bidaskItems = new List<object>() {};
            object collectedEventsOfTrades = new List<object>() {};
            object eventsLength = getArrayLength(events);
            for (object i = 0; isLessThan(i, getArrayLength(events)); postFixIncrement(ref i))
            {
                object eventVar = getValue(events, i);
                object eventType = this.safeString(eventVar, "type");
                object isOrderBook = isTrue(isTrue((isEqual(eventType, "change"))) && isTrue((inOp(eventVar, "side")))) && isTrue(this.inArray(getValue(eventVar, "side"), new List<object>() {"ask", "bid"}));
                object eventReason = this.safeString(eventVar, "reason");
                object isBidAsk = isTrue((isEqual(eventReason, "top-of-book"))) || isTrue((isTrue(isTrue(isOrderBook) && isTrue((isEqual(eventReason, "initial")))) && isTrue(isEqual(eventsLength, 2))));
                if (isTrue(isBidAsk))
                {
                    ((IList<object>)bidaskItems).Add(eventVar);
                } else if (isTrue(isOrderBook))
                {
                    ((IList<object>)orderBookItems).Add(eventVar);
                } else if (isTrue(isEqual(eventType, "trade")))
                {
                    ((IList<object>)collectedEventsOfTrades).Add(getValue(events, i));
                }
            }
            object lengthBa = getArrayLength(bidaskItems);
            if (isTrue(isGreaterThan(lengthBa, 0)))
            {
                this.handleBidsAsksForMultidata(client as WebSocketClient, bidaskItems, ts, eventId);
            }
            object lengthOb = getArrayLength(orderBookItems);
            if (isTrue(isGreaterThan(lengthOb, 0)))
            {
                this.handleOrderBookForMultidata(client as WebSocketClient, orderBookItems, ts, eventId);
            }
            object lengthTrades = getArrayLength(collectedEventsOfTrades);
            if (isTrue(isGreaterThan(lengthTrades, 0)))
            {
                this.handleTradesForMultidata(client as WebSocketClient, collectedEventsOfTrades, ts);
            }
        }
    }

    public async virtual Task authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object url = this.safeString(parameters, "url");
        if (isTrue(isTrue((!isEqual(this.clients, null))) && isTrue((inOp(this.clients, url)))))
        {
            return;
        }
        this.checkRequiredCredentials();
        object startIndex = getArrayLength(getValue(getValue(this.urls, "api"), "ws"));
        object urlParamsIndex = getIndexOf(url, "?");
        object urlLength = ((string)url).Length;
        object endIndex = ((bool) isTrue((isGreaterThanOrEqual(urlParamsIndex, 0)))) ? urlParamsIndex : urlLength;
        object request = slice(url, startIndex, endIndex);
        object payload = new Dictionary<string, object>() {
            { "request", request },
            { "nonce", this.nonce() },
        };
        object b64 = this.stringToBase64(this.json(payload));
        object signature = this.hmac(this.encode(b64), this.encode(this.secret), sha384, "hex");
        object defaultOptions = new Dictionary<string, object>() {
            { "ws", new Dictionary<string, object>() {
                { "options", new Dictionary<string, object>() {
                    { "headers", new Dictionary<string, object>() {} },
                } },
            } },
        };
        // this.options = this.extend (defaultOptions, this.options);
        this.extendExchangeOptions(defaultOptions);
        object originalHeaders = getValue(getValue(getValue(this.options, "ws"), "options"), "headers");
        object headers = new Dictionary<string, object>() {
            { "X-GEMINI-APIKEY", this.apiKey },
            { "X-GEMINI-PAYLOAD", b64 },
            { "X-GEMINI-SIGNATURE", signature },
        };
        ((IDictionary<string,object>)getValue(getValue(this.options, "ws"), "options"))["headers"] = headers;
        this.client(url);
        ((IDictionary<string,object>)getValue(getValue(this.options, "ws"), "options"))["headers"] = originalHeaders;
    }
}
