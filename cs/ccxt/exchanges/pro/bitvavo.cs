namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class bitvavo { public bitvavo(object args = null) : base(args) { } }
public partial class bitvavo : ccxt.bitvavo
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "cancelOrdersWs", false },
                { "fetchTradesWs", false },
                { "watchOrderBook", true },
                { "watchTrades", true },
                { "watchTicker", true },
                { "watchOHLCV", true },
                { "watchOrders", true },
                { "watchMyTrades", true },
                { "cancelAllOrdersWs", true },
                { "cancelOrderWs", true },
                { "createOrderWs", true },
                { "createStopLimitOrderWs", true },
                { "createStopMarketOrderWs", true },
                { "createStopOrderWs", true },
                { "editOrderWs", true },
                { "fetchBalanceWs", true },
                { "fetchCurrenciesWS", true },
                { "fetchDepositAddressWs", true },
                { "fetchDepositsWs", true },
                { "fetchDepositWithdrawFeesWs", true },
                { "fetchMyTradesWs", true },
                { "fetchOHLCVWs", true },
                { "fetchOpenOrdersWs", true },
                { "fetchOrderWs", true },
                { "fetchOrderBookWs", true },
                { "fetchOrdersWs", true },
                { "fetchTickerWs", true },
                { "fetchTickersWs", true },
                { "fetchTimeWs", true },
                { "fetchTradingFeesWs", true },
                { "fetchWithdrawalsWs", true },
                { "withdrawWs", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", "wss://ws.bitvavo.com/v2" },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "supressMultipleWsRequestsError", false },
                { "tradesLimit", 1000 },
                { "ordersLimit", 1000 },
                { "OHLCVLimit", 1000 },
            } },
        });
    }

    public async virtual Task<object> watchPublic(object name, object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object messageHash = add(add(name, "@"), getValue(market, "id"));
        object url = getValue(getValue(this.urls, "api"), "ws");
        object request = new Dictionary<string, object>() {
            { "action", "subscribe" },
            { "channels", new List<object>() {new Dictionary<string, object>() {
    { "name", name },
    { "markets", new List<object>() {getValue(market, "id")} },
}} },
        };
        object message = this.extend(request, parameters);
        return await this.watch(url, messageHash, message, messageHash);
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#watchTicker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchPublic("ticker24h", symbol, parameters);
    }

    public virtual object handleTicker(WebSocketClient client, object message)
    {
        //
        //     {
        //         "event": "ticker24h",
        //         "data": [
        //             {
        //                 "market": "ETH-EUR",
        //                 "open": "193.5",
        //                 "high": "202.72",
        //                 "low": "192.46",
        //                 "last": "199.01",
        //                 "volume": "3587.05020246",
        //                 "volumeQuote": "708030.17",
        //                 "bid": "199.56",
        //                 "bidSize": "4.14730802",
        //                 "ask": "199.57",
        //                 "askSize": "6.13642074",
        //                 "timestamp": 1590770885217
        //             }
        //         ]
        //     }
        //
        object eventVar = this.safeString(message, "event");
        object tickers = this.safeValue(message, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(tickers)); postFixIncrement(ref i))
        {
            object data = getValue(tickers, i);
            object marketId = this.safeString(data, "market");
            object market = this.safeMarket(marketId, null, "-");
            object messageHash = add(add(eventVar, "@"), marketId);
            object ticker = this.parseTicker(data, market);
            object symbol = getValue(ticker, "symbol");
            ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
            callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
        }
        return message;
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#watchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbol = this.symbol(symbol);
        object trades = await this.watchPublic("trades", symbol, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrade(WebSocketClient client, object message)
    {
        //
        //     {
        //         "event": "trade",
        //         "timestamp": 1590779594547,
        //         "market": "ETH-EUR",
        //         "id": "450c3298-f082-4461-9e2c-a0262cc7cc2e",
        //         "amount": "0.05026233",
        //         "price": "198.46",
        //         "side": "buy"
        //     }
        //
        object marketId = this.safeString(message, "market");
        object market = this.safeMarket(marketId, null, "-");
        object symbol = getValue(market, "symbol");
        object name = "trades";
        object messageHash = add(add(name, "@"), marketId);
        object trade = this.parseTrade(message, market);
        object tradesArray = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(tradesArray, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            tradesArray = new ArrayCache(limit);
        }
        callDynamically(tradesArray, "append", new object[] {trade});
        ((IDictionary<string,object>)this.trades)[(string)symbol] = tradesArray;
        callDynamically(client as WebSocketClient, "resolve", new object[] {tradesArray, messageHash});
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#watchOHLCV
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object name = "candles";
        object marketId = getValue(market, "id");
        object interval = this.safeString(this.timeframes, timeframe, timeframe);
        object messageHash = add(add(add(add(name, "@"), marketId), "_"), interval);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object request = new Dictionary<string, object>() {
            { "action", "subscribe" },
            { "channels", new List<object>() {new Dictionary<string, object>() {
    { "name", "candles" },
    { "interval", new List<object>() {interval} },
    { "markets", new List<object>() {marketId} },
}} },
        };
        object message = this.extend(request, parameters);
        object ohlcv = await this.watch(url, messageHash, message, messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual void handleFetchOHLCV(WebSocketClient client, object message)
    {
        //
        //    {
        //        action: 'getCandles',
        //        response: [
        //            [1690325820000, '26453', '26453', '26436', '26447', '0.01626246'],
        //            [1690325760000, '26454', '26454', '26453', '26453', '0.00037707']
        //        ]
        //    }
        //
        object action = this.safeString(message, "action");
        object response = this.safeValue(message, "response");
        object ohlcv = this.parseOHLCVs(response, null, null, null);
        object messageHash = this.buildMessageHash(action);
        callDynamically(client as WebSocketClient, "resolve", new object[] {ohlcv, messageHash});
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "event": "candle",
        //         "market": "BTC-EUR",
        //         "interval": "1m",
        //         "candle": [
        //             [
        //                 1590797160000,
        //                 "8480.9",
        //                 "8480.9",
        //                 "8480.9",
        //                 "8480.9",
        //                 "0.01038628"
        //             ]
        //         ]
        //     }
        //
        object name = "candles";
        object marketId = this.safeString(message, "market");
        object market = this.safeMarket(marketId, null, "-");
        object symbol = getValue(market, "symbol");
        object interval = this.safeString(message, "interval");
        // use a reverse lookup in a static map instead
        object timeframe = this.findTimeframe(interval);
        object messageHash = add(add(add(add(name, "@"), marketId), "_"), interval);
        object candles = this.safeValue(message, "candle");
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
        }
        for (object i = 0; isLessThan(i, getArrayLength(candles)); postFixIncrement(ref i))
        {
            object candle = getValue(candles, i);
            object parsed = this.parseOHLCV(candle, market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#watchOrderBook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object name = "book";
        object messageHash = add(add(name, "@"), getValue(market, "id"));
        object url = getValue(getValue(this.urls, "api"), "ws");
        object request = new Dictionary<string, object>() {
            { "action", "subscribe" },
            { "channels", new List<object>() {new Dictionary<string, object>() {
    { "name", name },
    { "markets", new List<object>() {getValue(market, "id")} },
}} },
        };
        object subscription = new Dictionary<string, object>() {
            { "messageHash", messageHash },
            { "name", name },
            { "symbol", symbol },
            { "marketId", getValue(market, "id") },
            { "method", this.handleOrderBookSubscription },
            { "limit", limit },
            { "params", parameters },
        };
        object message = this.extend(request, parameters);
        object orderbook = await this.watch(url, messageHash, message, messageHash, subscription);
        return (orderbook as IOrderBook).limit();
    }

    public override void handleDelta(object bookside, object delta)
    {
        object price = this.safeFloat(delta, 0);
        object amount = this.safeFloat(delta, 1);
        (bookside as IOrderBookSide).store(price, amount);
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    public virtual object handleOrderBookMessage(WebSocketClient client, object message, object orderbook)
    {
        //
        //     {
        //         "event": "book",
        //         "market": "BTC-EUR",
        //         "nonce": 36947383,
        //         "bids": [
        //             [ "8477.8", "0" ]
        //         ],
        //         "asks": [
        //             [ "8550.9", "0" ]
        //         ]
        //     }
        //
        object nonce = this.safeInteger(message, "nonce");
        if (isTrue(isGreaterThan(nonce, getValue(orderbook, "nonce"))))
        {
            this.handleDeltas(getValue(orderbook, "asks"), this.safeValue(message, "asks", new List<object>() {}));
            this.handleDeltas(getValue(orderbook, "bids"), this.safeValue(message, "bids", new List<object>() {}));
            ((IDictionary<string,object>)orderbook)["nonce"] = nonce;
        }
        return orderbook;
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //     {
        //         "event": "book",
        //         "market": "BTC-EUR",
        //         "nonce": 36729561,
        //         "bids": [
        //             [ "8513.3", "0" ],
        //             [ '8518.8', "0.64236203" ],
        //             [ '8513.6', "0.32435481" ],
        //         ],
        //         "asks": []
        //     }
        //
        object eventVar = this.safeString(message, "event");
        object marketId = this.safeString(message, "market");
        object market = this.safeMarket(marketId, null, "-");
        object symbol = getValue(market, "symbol");
        object messageHash = add(add(eventVar, "@"), getValue(market, "id"));
        object orderbook = this.safeValue(this.orderbooks, symbol);
        if (isTrue(isEqual(orderbook, null)))
        {
            return;
        }
        if (isTrue(isEqual(getValue(orderbook, "nonce"), null)))
        {
            object subscription = this.safeValue(((WebSocketClient)client).subscriptions, messageHash, new Dictionary<string, object>() {});
            object watchingOrderBookSnapshot = this.safeValue(subscription, "watchingOrderBookSnapshot");
            if (isTrue(isEqual(watchingOrderBookSnapshot, null)))
            {
                ((IDictionary<string,object>)subscription)["watchingOrderBookSnapshot"] = true;
                ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)messageHash] = subscription;
                object options = this.safeValue(this.options, "watchOrderBookSnapshot", new Dictionary<string, object>() {});
                object delay = this.safeInteger(options, "delay", this.rateLimit);
                // fetch the snapshot in a separate async call after a warmup delay
                this.delay(delay,  this.watchOrderBookSnapshot, new object[] { client, message, subscription});
            }
            ((IList<object>)(orderbook as ccxt.pro.OrderBook).cache).Add(message);
        } else
        {
            this.handleOrderBookMessage(client as WebSocketClient, message, orderbook);
            callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
        }
    }

    public async virtual Task<object> watchOrderBookSnapshot(WebSocketClient client, object message, object subscription)
    {
        object parameters = this.safeValue(subscription, "params");
        object marketId = this.safeString(subscription, "marketId");
        object name = "getBook";
        object messageHash = add(add(name, "@"), marketId);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object request = new Dictionary<string, object>() {
            { "action", name },
            { "market", marketId },
        };
        object orderbook = await this.watch(url, messageHash, this.extend(request, parameters), messageHash, subscription);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBookSnapshot(WebSocketClient client, object message)
    {
        //
        //     {
        //         "action": "getBook",
        //         "response": {
        //             "market": "BTC-EUR",
        //             "nonce": 36946120,
        //             "bids": [
        //                 [ '8494.9', "0.24399521" ],
        //                 [ '8494.8', "0.34884085" ],
        //                 [ '8493.9', "0.14535128" ],
        //             ],
        //             "asks": [
        //                 [ "8495", "0.46982463" ],
        //                 [ '8495.1', "0.12178267" ],
        //                 [ '8496.2', "0.21924143" ],
        //             ]
        //         }
        //     }
        //
        object response = this.safeValue(message, "response");
        if (isTrue(isEqual(response, null)))
        {
            return;
        }
        object marketId = this.safeString(response, "market");
        object symbol = this.safeSymbol(marketId, null, "-");
        object name = "book";
        object messageHash = add(add(name, "@"), marketId);
        object orderbook = getValue(this.orderbooks, symbol);
        object snapshot = this.parseOrderBook(response, symbol);
        ((IDictionary<string,object>)snapshot)["nonce"] = this.safeInteger(response, "nonce");
        (orderbook as IOrderBook).reset(snapshot);
        // unroll the accumulated deltas
        object messages = (orderbook as ccxt.pro.OrderBook).cache;
        for (object i = 0; isLessThan(i, getArrayLength(messages)); postFixIncrement(ref i))
        {
            object messageItem = getValue(messages, i);
            this.handleOrderBookMessage(client as WebSocketClient, messageItem, orderbook);
        }
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public virtual void handleOrderBookSubscription(WebSocketClient client, object message, object subscription)
    {
        object symbol = this.safeString(subscription, "symbol");
        object limit = this.safeInteger(subscription, "limit");
        if (isTrue(inOp(this.orderbooks, symbol)))
        {

        }
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
    }

    public virtual void handleOrderBookSubscriptions(WebSocketClient client, object message, object marketIds)
    {
        object name = "book";
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = this.safeString(marketIds, i);
            object symbol = this.safeSymbol(marketId, null, "-");
            object messageHash = add(add(name, "@"), marketId);
            if (!isTrue((inOp(this.orderbooks, symbol))))
            {
                object subscription = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
                object method = this.safeValue(subscription, "method");
                if (isTrue(!isEqual(method, null)))
                {
                    DynamicInvoker.InvokeMethod(method, new object[] { client, message, subscription});
                }
            }
        }
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#watchOrders
        * @description watches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        await this.authenticate();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object marketId = getValue(market, "id");
        object url = getValue(getValue(this.urls, "api"), "ws");
        object name = "account";
        object messageHash = add("order:", symbol);
        object request = new Dictionary<string, object>() {
            { "action", "subscribe" },
            { "channels", new List<object>() {new Dictionary<string, object>() {
    { "name", name },
    { "markets", new List<object>() {marketId} },
}} },
        };
        object orders = await this.watch(url, messageHash, request, messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#watchMyTrades
        * @description watches information on multiple trades made by the user
        * @param {string} symbol unified market symbol of the market trades were made in
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trade structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=ortradeder-structure
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        await this.authenticate();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object marketId = getValue(market, "id");
        object url = getValue(getValue(this.urls, "api"), "ws");
        object name = "account";
        object messageHash = add("myTrades:", symbol);
        object request = new Dictionary<string, object>() {
            { "action", "subscribe" },
            { "channels", new List<object>() {new Dictionary<string, object>() {
    { "name", name },
    { "markets", new List<object>() {marketId} },
}} },
        };
        object trades = await this.watch(url, messageHash, request, messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public async override Task<object> createOrderWs(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#createOrderWs
        * @description create a trade order
        * @see https://docs.bitvavo.com/#tag/Orders/paths/~1order/post
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the bitvavo api endpoint
        * @param {string} [params.timeInForce] "GTC", "IOC", or "PO"
        * @param {float} [params.stopPrice] The price at which a trigger order is triggered at
        * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
        * @param {bool} [params.postOnly] If true, the order will only be posted to the order book and not executed immediately
        * @param {float} [params.stopLossPrice] The price at which a stop loss order is triggered at
        * @param {float} [params.takeProfitPrice] The price at which a take profit order is triggered at
        * @param {string} [params.triggerType] "price"
        * @param {string} [params.triggerReference] "lastTrade", "bestBid", "bestAsk", "midPrice" Only for stop orders: Use this to determine which parameter will trigger the order
        * @param {string} [params.selfTradePrevention] "decrementAndCancel", "cancelOldest", "cancelNewest", "cancelBoth"
        * @param {bool} [params.disableMarketProtection] don't cancel if the next fill price is 10% worse than the best fill price
        * @param {bool} [params.responseRequired] Set this to 'false' when only an acknowledgement of success or failure is required, this is faster.
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        return await this.watchRequest("privateCreateOrder", request);
    }

    public async override Task<object> editOrderWs(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#editOrderWs
        * @description edit a trade order
        * @see https://docs.bitvavo.com/#tag/Orders/paths/~1order/put
        * @param {string} id cancel order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} [amount] how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the base currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the bitvavo api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object request = this.editOrderRequest(id, symbol, type, side, amount, price, parameters);
        return await this.watchRequest("privateUpdateOrder", request);
    }

    public async override Task<object> cancelOrderWs(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#cancelOrderWs
        * @see https://docs.bitvavo.com/#tag/Orders/paths/~1order/delete
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the bitvavo api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object request = this.cancelOrderRequest(id, symbol, parameters);
        return await this.watchRequest("privateCancelOrder", request);
    }

    public async override Task<object> cancelAllOrdersWs(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#cancelAllOrdersWs
        * @see https://docs.bitvavo.com/#tag/Orders/paths/~1orders/delete
        * @description cancel all open orders
        * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} [params] extra parameters specific to the bitvavo api endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
        }
        return await this.watchRequest("privateCancelOrders", this.extend(request, parameters));
    }

    public virtual void handleMultipleOrders(WebSocketClient client, object message)
    {
        //
        //    {
        //        action: 'privateCancelOrders',
        //        response: [{
        //            orderId: 'd71df826-1130-478a-8741-d219128675b0'
        //        }]
        //    }
        //
        object action = this.safeString(message, "action");
        object response = this.safeValue(message, "response");
        object firstRawOrder = this.safeValue(response, 0, new Dictionary<string, object>() {});
        object marketId = this.safeString(firstRawOrder, "market");
        object orders = this.parseOrders(response);
        object messageHash = this.buildMessageHash(action, new Dictionary<string, object>() {
            { "market", marketId },
        });
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
        messageHash = this.buildMessageHash(action, message);
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
    }

    public async override Task<object> fetchOrderWs(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#fetchOrderWs
        * @see https://docs.bitvavo.com/#tag/General/paths/~1assets/get
        * @description fetches information on an order made by the user
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the bitvavo api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        await this.authenticate();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "orderId", id },
            { "market", getValue(market, "id") },
        };
        return await this.watchRequest("privateGetOrder", this.extend(request, parameters));
    }

    public async override Task<object> fetchOrdersWs(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#fetchOrdersWs
        * @see https://docs.bitvavo.com/#tag/Orders/paths/~1orders/get
        * @description fetches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of  orde structures to retrieve
        * @param {object} [params] extra parameters specific to the bitvavo api endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrdersWs() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        await this.authenticate();
        object request = this.fetchOrdersRequest(symbol, since, limit, parameters);
        object orders = await this.watchRequest("privateGetOrders", request);
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit);
    }

    public async virtual Task<object> watchRequest(object action, object request)
    {
        ((IDictionary<string,object>)request)["action"] = action;
        object messageHash = this.buildMessageHash(action, request);
        this.checkMessageHashDoesNotExist(messageHash);
        object url = getValue(getValue(this.urls, "api"), "ws");
        return await this.watch(url, messageHash, request, messageHash);
    }

    public async override Task<object> fetchOpenOrdersWs(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#fetchOpenOrdersWs
        * @description fetch all unfilled currently open orders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the bitvavo api endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
        }
        object orders = await this.watchRequest("privateGetOrdersOpen", this.extend(request, parameters));
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit);
    }

    public async override Task<object> fetchMyTradesWs(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#fetchMyTradesWs
        * @see https://docs.bitvavo.com/#tag/Trades
        * @description fetch all trades made by the user
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the bitvavo api endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTradesWs() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        await this.authenticate();
        object request = this.fetchMyTradesRequest(symbol, since, limit, parameters);
        object myTrades = await this.watchRequest("privateGetTrades", request);
        return this.filterBySymbolSinceLimit(myTrades, symbol, since, limit);
    }

    public virtual void handleMyTrades(WebSocketClient client, object message)
    {
        //
        //    {
        //        action: 'privateGetTrades',
        //        response: [
        //            {
        //                "id": "108c3633-0276-4480-a902-17a01829deae",
        //                "orderId": "1d671998-3d44-4df4-965f-0d48bd129a1b",
        //                "timestamp": 1542967486256,
        //                "market": "BTC-EUR",
        //                "side": "buy",
        //                "amount": "0.005",
        //                "price": "5000.1",
        //                "taker": true,
        //                "fee": "0.03",
        //                "feeCurrency": "EUR",
        //                "settled": true
        //            }
        //        ]
        //    }
        //
        //
        object action = this.safeString(message, "action");
        object response = this.safeValue(message, "response");
        object firstRawTrade = this.safeValue(response, 0, new Dictionary<string, object>() {});
        object marketId = this.safeString(firstRawTrade, "market");
        object trades = this.parseTrades(response, null, null, null);
        object messageHash = this.buildMessageHash(action, new Dictionary<string, object>() {
            { "market", marketId },
        });
        callDynamically(client as WebSocketClient, "resolve", new object[] {trades, messageHash});
    }

    public async virtual Task<object> withdrawWs(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#withdrawWs
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the bitvavo api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        await this.authenticate();
        object request = this.withdrawRequest(code, amount, address, tag, parameters);
        return await this.watchRequest("privateWithdrawAssets", request);
    }

    public virtual void handleWithdraw(WebSocketClient client, object message)
    {
        //
        //    {
        //        action: 'privateWithdrawAssets',
        //        response: {
        //         "success": true,
        //         "symbol": "BTC",
        //         "amount": "1.5"
        //        }
        //    }
        //
        object action = this.safeString(message, "action");
        object messageHash = this.buildMessageHash(action, message);
        object response = this.safeValue(message, "response");
        object withdraw = this.parseTransaction(response);
        callDynamically(client as WebSocketClient, "resolve", new object[] {withdraw, messageHash});
    }

    public async override Task<object> fetchWithdrawalsWs(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#fetchWithdrawalsWs
        * @see https://docs.bitvavo.com/#tag/Account/paths/~1withdrawalHistory/get
        * @description fetch all withdrawals made from an account
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the bitvavo api endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object request = this.fetchWithdrawalsRequest(code, since, limit, parameters);
        object withdraws = await this.watchRequest("privateGetWithdrawalHistory", request);
        return this.filterByCurrencySinceLimit(withdraws, code, since, limit);
    }

    public virtual void handleWithdraws(WebSocketClient client, object message)
    {
        //
        //    {
        //        action: 'privateGetWithdrawalHistory',
        //        response: [{
        //                timestamp: 1689792085000,
        //                symbol: 'BTC',
        //                amount: '0.0009',
        //                fee: '0',
        //                status: 'completed',
        //                txId: '7dbadc658d7d59c129de1332c55ee8e08d0ab74432faae03b417b9809c819d1f'
        //            },
        //            ...
        //        ]
        //    }
        //
        object action = this.safeString(message, "action");
        object messageHash = this.buildMessageHash(action, message);
        object response = this.safeValue(message, "response");
        object withdrawals = this.parseTransactions(response, null, null, null, new Dictionary<string, object>() {
            { "type", "withdrawal" },
        });
        callDynamically(client as WebSocketClient, "resolve", new object[] {withdrawals, messageHash});
    }

    public async override Task<object> fetchOHLCVWs(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#fetchOHLCVWs
        * @see https://docs.bitvavo.com/#tag/Market-Data/paths/~1{market}~1candles/get
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the bitvavo api endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = this.fetchOHLCVRequest(symbol, timeframe, since, limit, parameters);
        object action = "getCandles";
        object ohlcv = await this.watchRequest(action, request);
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public async override Task<object> fetchDepositsWs(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#fetchDepositsWs
        * @see https://docs.bitvavo.com/#tag/Account/paths/~1depositHistory/get
        * @description fetch all deposits made to an account
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the bitvavo api endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object request = this.fetchDepositsRequest(code, since, limit, parameters);
        object deposits = await this.watchRequest("privateGetDepositHistory", request);
        return this.filterByCurrencySinceLimit(deposits, code, since, limit);
    }

    public virtual void handleDeposits(WebSocketClient client, object message)
    {
        //
        //    {
        //        action: 'privateGetDepositHistory',
        //        response: [{
        //                timestamp: 1689792085000,
        //                symbol: 'BTC',
        //                amount: '0.0009',
        //                fee: '0',
        //                status: 'completed',
        //                txId: '7dbadc658d7d59c129de1332c55ee8e08d0ab74432faae03b417b9809c819d1f'
        //            },
        //            ...
        //        ]
        //    }
        //
        object action = this.safeString(message, "action");
        object messageHash = this.buildMessageHash(action, message);
        object response = this.safeValue(message, "response");
        object deposits = this.parseTransactions(response, null, null, null, new Dictionary<string, object>() {
            { "type", "deposit" },
        });
        callDynamically(client as WebSocketClient, "resolve", new object[] {deposits, messageHash});
    }

    public async override Task<object> fetchTradingFeesWs(object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#fetchTradingFeesWs
        * @see https://docs.bitvavo.com/#tag/Account/paths/~1account/get
        * @description fetch the trading fees for multiple markets
        * @param {object} [params] extra parameters specific to the bitvavo api endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        return await this.watchRequest("privateGetAccount", parameters);
    }

    public async override Task<object> fetchMarketsWs(object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#fetchMarketsWs
        * @see https://docs.bitvavo.com/#tag/General/paths/~1markets/get
        * @description retrieves data on all markets for bitvavo
        * @param {object} [params] extra parameters specific to the exchange api endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchRequest("getMarkets", parameters);
    }

    public async override Task<object> fetchCurrenciesWs(object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#fetchCurrenciesWs
        * @see https://docs.bitvavo.com/#tag/General/paths/~1assets/get
        * @description fetches all available currencies on an exchange
        * @param {object} [params] extra parameters specific to the bitvavo api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        return await this.watchRequest("getAssets", parameters);
    }

    public virtual void handleFetchCurrencies(WebSocketClient client, object message)
    {
        //
        //    {
        //        action: 'getAssets',
        //        response: [{
        //                symbol: '1INCH',
        //                name: '1inch',
        //                decimals: 8,
        //                depositFee: '0',
        //                depositConfirmations: 64,
        //                depositStatus: 'OK',
        //                withdrawalFee: '13',
        //                withdrawalMinAmount: '13',
        //                withdrawalStatus: 'OK',
        //                networks: [Array],
        //                message: ''
        //            },
        //            ...
        //        ]
        //    }
        //
        object action = this.safeString(message, "action");
        object messageHash = this.buildMessageHash(action, message);
        object response = this.safeValue(message, "response");
        object currencies = this.parseCurrencies(response);
        callDynamically(client as WebSocketClient, "resolve", new object[] {currencies, messageHash});
    }

    public virtual void handleTradingFees(WebSocketClient client, object message)
    {
        //
        //    {
        //        action: 'privateGetAccount',
        //        response: {
        //            fees: {
        //                taker: '0.0025',
        //                maker: '0.0015',
        //                volume: '1693.74'
        //            }
        //        }
        //    }
        //
        object action = this.safeString(message, "action");
        object messageHash = this.buildMessageHash(action, message);
        object response = this.safeValue(message, "response");
        object fees = this.parseTradingFees(response);
        callDynamically(client as WebSocketClient, "resolve", new object[] {fees, messageHash});
    }

    public async override Task<object> fetchBalanceWs(object parameters = null)
    {
        /**
        * @method
        * @name bitvavo#fetchBalanceWs
        * @see https://docs.bitvavo.com/#tag/Account/paths/~1balance/get
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} [params] extra parameters specific to the bitvavo api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        return await this.watchRequest("privateGetBalance", parameters);
    }

    public virtual void handleFetchBalance(WebSocketClient client, object message)
    {
        //
        //    {
        //        action: 'privateGetBalance',
        //        response: [{
        //                symbol: 'ADA',
        //                available: '0',
        //                inOrder: '0'
        //            },
        //            ...
        //        ]
        //    }
        //
        object action = this.safeString(message, "action", "privateGetBalance");
        object messageHash = this.buildMessageHash(action, message);
        object response = this.safeValue(message, "response", new List<object>() {});
        object balance = this.parseBalance(response);
        callDynamically(client as WebSocketClient, "resolve", new object[] {balance, messageHash});
    }

    public virtual void handleSingleOrder(WebSocketClient client, object message)
    {
        //
        //    {
        //        action: 'privateCreateOrder',
        //        response: {
        //            orderId: 'd71df826-1130-478a-8741-d219128675b0',
        //            market: 'BTC-EUR',
        //            created: 1689792749748,
        //            updated: 1689792749748,
        //            status: 'new',
        //            side: 'sell',
        //            orderType: 'limit',
        //            amount: '0.0002',
        //            amountRemaining: '0.0002',
        //            price: '37000',
        //            onHold: '0.0002',
        //            onHoldCurrency: 'BTC',
        //            filledAmount: '0',
        //            filledAmountQuote: '0',
        //            feePaid: '0',
        //            feeCurrency: 'EUR',
        //            fills: [],
        //            selfTradePrevention: 'decrementAndCancel',
        //            visible: true,
        //            timeInForce: 'GTC',
        //            postOnly: false
        //        }
        //    }
        //
        object action = this.safeString(message, "action");
        object response = this.safeValue(message, "response", new Dictionary<string, object>() {});
        object order = this.parseOrder(response);
        object messageHash = this.buildMessageHash(action, response);
        callDynamically(client as WebSocketClient, "resolve", new object[] {order, messageHash});
    }

    public virtual void handleMarkets(WebSocketClient client, object message)
    {
        //
        //    {
        //        action: 'getMarkets',
        //        response: [{
        //                market: '1INCH-EUR',
        //                status: 'trading',
        //                base: '1INCH',
        //                quote: 'EUR',
        //                pricePrecision: 5,
        //                minOrderInBaseAsset: '2',
        //                minOrderInQuoteAsset: '5',
        //                maxOrderInBaseAsset: '1000000000',
        //                maxOrderInQuoteAsset: '1000000000',
        //                orderTypes: [Array]
        //            },
        //            ...
        //        ]
        //    }
        //
        object action = this.safeString(message, "action");
        object response = this.safeValue(message, "response", new Dictionary<string, object>() {});
        object markets = this.parseMarkets(response);
        object messageHash = this.buildMessageHash(action, response);
        callDynamically(client as WebSocketClient, "resolve", new object[] {markets, messageHash});
    }

    public virtual object buildMessageHash(object action, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methods = new Dictionary<string, object>() {
            { "privateCreateOrder", this.actionAndMarketMessageHash },
            { "privateUpdateOrder", this.actionAndOrderIdMessageHash },
            { "privateCancelOrder", this.actionAndOrderIdMessageHash },
            { "privateGetOrder", this.actionAndOrderIdMessageHash },
            { "privateGetTrades", this.actionAndMarketMessageHash },
        };
        object method = this.safeValue(methods, action);
        object messageHash = action;
        if (isTrue(!isEqual(method, null)))
        {
            messageHash = DynamicInvoker.InvokeMethod(method, new object[] { action, parameters});
        }
        return messageHash;
    }

    public virtual void checkMessageHashDoesNotExist(object messageHash)
    {
        object supressMultipleWsRequestsError = this.safeBool(this.options, "supressMultipleWsRequestsError", false);
        if (!isTrue(supressMultipleWsRequestsError))
        {
            var client = this.safeValue(this.clients, getValue(getValue(this.urls, "api"), "ws"));
            if (isTrue(!isEqual(client as WebSocketClient, null)))
            {
                var future = this.safeValue((client as WebSocketClient).futures, messageHash);
                if (isTrue(!isEqual(future, null)))
                {
                    throw new ExchangeError ((string)add(add(add(this.id, " a similar request with messageHash "), messageHash), " is already pending, you must wait for a response, or turn off this error by setting supressMultipleWsRequestsError in the options to true")) ;
                }
            }
        }
    }

    public virtual object actionAndMarketMessageHash(object action, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object symbol = this.safeString(parameters, "market", "");
        return add(action, symbol);
    }

    public virtual object actionAndOrderIdMessageHash(object action, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object orderId = this.safeString(parameters, "orderId");
        if (isTrue(isEqual(orderId, null)))
        {
            throw new ExchangeError ((string)add(this.id, " privateUpdateOrderMessageHash requires a orderId parameter")) ;
        }
        return add(action, orderId);
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        //
        //     {
        //         "event": "order",
        //         "orderId": "f0e5180f-9497-4d05-9dc2-7056e8a2de9b",
        //         "market": "ETH-EUR",
        //         "created": 1590948500319,
        //         "updated": 1590948500319,
        //         "status": "new",
        //         "side": "sell",
        //         "orderType": "limit",
        //         "amount": "0.1",
        //         "amountRemaining": "0.1",
        //         "price": "300",
        //         "onHold": "0.1",
        //         "onHoldCurrency": "ETH",
        //         "selfTradePrevention": "decrementAndCancel",
        //         "visible": true,
        //         "timeInForce": "GTC",
        //         "postOnly": false
        //     }
        //
        object marketId = this.safeString(message, "market");
        object market = this.safeMarket(marketId, null, "-");
        object symbol = getValue(market, "symbol");
        object messageHash = add("order:", symbol);
        object order = this.parseOrder(message, market);
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object orders = this.orders;
        callDynamically(orders, "append", new object[] {order});
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageHash});
    }

    public virtual void handleMyTrade(WebSocketClient client, object message)
    {
        //
        //     {
        //         "event": "fill",
        //         "timestamp": 1590964470132,
        //         "market": "ETH-EUR",
        //         "orderId": "85d082e1-eda4-4209-9580-248281a29a9a",
        //         "fillId": "861d2da5-aa93-475c-8d9a-dce431bd4211",
        //         "side": "sell",
        //         "amount": "0.1",
        //         "price": "211.46",
        //         "taker": true,
        //         "fee": "0.056",
        //         "feeCurrency": "EUR"
        //     }
        //
        object marketId = this.safeString(message, "market");
        object market = this.safeMarket(marketId, null, "-");
        object symbol = getValue(market, "symbol");
        object messageHash = add("myTrades:", symbol);
        object trade = this.parseTrade(message, market);
        if (isTrue(isEqual(this.myTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            this.myTrades = new ArrayCache(limit);
        }
        object tradesArray = this.myTrades;
        callDynamically(tradesArray, "append", new object[] {trade});
        callDynamically(client as WebSocketClient, "resolve", new object[] {tradesArray, messageHash});
    }

    public virtual object handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //     {
        //         "event": "subscribed",
        //         "subscriptions": {
        //             "book": [ "BTC-EUR" ]
        //         }
        //     }
        //
        object subscriptions = this.safeValue(message, "subscriptions", new Dictionary<string, object>() {});
        object methods = new Dictionary<string, object>() {
            { "book", this.handleOrderBookSubscriptions },
        };
        object names = new List<object>(((IDictionary<string,object>)subscriptions).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(names)); postFixIncrement(ref i))
        {
            object name = getValue(names, i);
            object method = this.safeValue(methods, name);
            if (isTrue(!isEqual(method, null)))
            {
                object subscription = this.safeValue(subscriptions, name);
                DynamicInvoker.InvokeMethod(method, new object[] { client, message, subscription});
            }
        }
        return message;
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object url = getValue(getValue(this.urls, "api"), "ws");
        var client = this.client(url);
        object messageHash = "authenticated";
        var future = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(future, null)))
        {
            object timestamp = this.milliseconds();
            object stringTimestamp = ((object)timestamp).ToString();
            object auth = add(add(add(stringTimestamp, "GET/"), this.version), "/websocket");
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
            object action = "authenticate";
            object request = new Dictionary<string, object>() {
                { "action", action },
                { "key", this.apiKey },
                { "signature", signature },
                { "timestamp", timestamp },
            };
            object message = this.extend(request, parameters);
            future = await this.watch(url, messageHash, message, messageHash);
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)messageHash] = future;
        }
        return future;
    }

    public virtual void handleAuthenticationMessage(WebSocketClient client, object message)
    {
        //
        //     {
        //         "event": "authenticate",
        //         "authenticated": true
        //     }
        //
        object messageHash = "authenticated";
        object authenticated = this.safeBool(message, "authenticated", false);
        if (isTrue(authenticated))
        {
            // we resolve the future here permanently so authentication only happens once
            callDynamically(client as WebSocketClient, "resolve", new object[] {message, messageHash});
        } else
        {
            var error = new AuthenticationError(this.json(message));
            ((WebSocketClient)client).reject(error, messageHash);
            // allows further authentication attempts
            if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
            {

            }
        }
    }

    public virtual void handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //    {
        //        action: 'privateCreateOrder',
        //        market: 'BTC-EUR',
        //        errorCode: 217,
        //        error: 'Minimum order size in quote currency is 5 EUR or 0.001 BTC.'
        //    }
        //
        object error = this.safeString(message, "error");
        object code = this.safeInteger(error, "errorCode");
        object action = this.safeString(message, "action");
        object messageHash = this.buildMessageHash(action, message);
        object rejected = false;
        try
        {
            this.handleErrors(code, error, client.url, null, null, error, message, null, null);
        } catch(Exception e)
        {
            rejected = true;
            ((WebSocketClient)client).reject(e, messageHash);
        }
        if (!isTrue(rejected))
        {
            ((WebSocketClient)client).reject(message, messageHash);
        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        //
        //     {
        //         "event": "subscribed",
        //         "subscriptions": {
        //             "book": [ "BTC-EUR" ]
        //         }
        //     }
        //
        //     {
        //         "event": "book",
        //         "market": "BTC-EUR",
        //         "nonce": 36729561,
        //         "bids": [
        //             [ "8513.3", "0" ],
        //             [ '8518.8', "0.64236203" ],
        //             [ '8513.6', "0.32435481" ],
        //         ],
        //         "asks": []
        //     }
        //
        //     {
        //         "action": "getBook",
        //         "response": {
        //             "market": "BTC-EUR",
        //             "nonce": 36946120,
        //             "bids": [
        //                 [ '8494.9', "0.24399521" ],
        //                 [ '8494.8', "0.34884085" ],
        //                 [ '8493.9', "0.14535128" ],
        //             ],
        //             "asks": [
        //                 [ "8495", "0.46982463" ],
        //                 [ '8495.1', "0.12178267" ],
        //                 [ '8496.2', "0.21924143" ],
        //             ]
        //         }
        //     }
        //
        //     {
        //         "event": "authenticate",
        //         "authenticated": true
        //     }
        //
        object error = this.safeString(message, "error");
        if (isTrue(!isEqual(error, null)))
        {
            this.handleErrorMessage(client as WebSocketClient, message);
        }
        object methods = new Dictionary<string, object>() {
            { "subscribed", this.handleSubscriptionStatus },
            { "book", this.handleOrderBook },
            { "getBook", this.handleOrderBookSnapshot },
            { "trade", this.handleTrade },
            { "candle", this.handleOHLCV },
            { "ticker24h", this.handleTicker },
            { "authenticate", this.handleAuthenticationMessage },
            { "order", this.handleOrder },
            { "fill", this.handleMyTrade },
            { "privateCreateOrder", this.handleSingleOrder },
            { "privateUpdateOrder", this.handleSingleOrder },
            { "privateGetBalance", this.handleFetchBalance },
            { "privateCancelOrders", this.handleMultipleOrders },
            { "privateGetOrders", this.handleMultipleOrders },
            { "privateGetOrder", this.handleSingleOrder },
            { "privateCancelOrder", this.handleSingleOrder },
            { "privateGetOrdersOpen", this.handleMultipleOrders },
            { "privateGetAccount", this.handleTradingFees },
            { "privateGetDepositHistory", this.handleDeposits },
            { "privateGetWithdrawalHistory", this.handleWithdraws },
            { "privateWithdrawAssets", this.handleWithdraw },
            { "privateGetTrades", this.handleMyTrades },
            { "getAssets", this.handleFetchCurrencies },
            { "getCandles", this.handleFetchOHLCV },
            { "getMarkets", this.handleMarkets },
        };
        object eventVar = this.safeString(message, "event");
        object method = this.safeValue(methods, eventVar);
        if (isTrue(isEqual(method, null)))
        {
            object action = this.safeString(message, "action");
            method = this.safeValue(methods, action);
            if (isTrue(!isEqual(method, null)))
            {
                DynamicInvoker.InvokeMethod(method, new object[] { client, message});
            }
        } else
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
    }
}
