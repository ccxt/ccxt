namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class blofin { public blofin(object args = null) : base(args) { } }
public partial class blofin : ccxt.blofin
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
                { "watchOrderBook", true },
                { "watchOrderBookForSymbols", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchBidsAsks", true },
                { "watchOHLCV", true },
                { "watchOHLCVForSymbols", true },
                { "watchOrders", true },
                { "watchOrdersForSymbols", true },
                { "watchPositions", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "swap", new Dictionary<string, object>() {
                            { "public", "wss://openapi.blofin.com/ws/public" },
                            { "private", "wss://openapi.blofin.com/ws/private" },
                        } },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "defaultType", "swap" },
                { "tradesLimit", 1000 },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "channel", "books" },
                } },
                { "watchOrderBookForSymbols", new Dictionary<string, object>() {
                    { "channel", "books" },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "ping", this.ping },
                { "keepAlive", 25000 },
            } },
        });
    }

    public override object ping(WebSocketClient client)
    {
        return "ping";
    }

    public virtual void handlePong(WebSocketClient client, object message)
    {
        //
        //   'pong'
        //
        client.lastPong = this.milliseconds();
    }

    /**
     * @method
     * @name blofin#watchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://docs.blofin.com/index.html#ws-trades-channel
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["callerMethodName"] = "watchTrades";
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    /**
     * @method
     * @name blofin#watchTradesForSymbols
     * @description get the list of most recent trades for a list of symbols
     * @see https://docs.blofin.com/index.html#ws-trades-channel
     * @param {string[]} symbols unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object trades = await this.watchMultipleWrapper(true, "trades", "watchTradesForSymbols", symbols, parameters);
        if (isTrue(this.newUpdates))
        {
            object firstMarket = this.safeDict(trades, 0);
            object firstSymbol = this.safeString(firstMarket, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {firstSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //       arg: {
        //         channel: "trades",
        //         instId: "DOGE-USDT",
        //       },
        //       data : [
        //         <same object as shown in REST example>,
        //         ...
        //       ]
        //     }
        //
        object arg = this.safeDict(message, "arg");
        object channelName = this.safeString(arg, "channel");
        object data = this.safeList(message, "data");
        if (isTrue(isEqual(data, null)))
        {
            return;
        }
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object rawTrade = getValue(data, i);
            object trade = this.parseWsTrade(rawTrade);
            object symbol = getValue(trade, "symbol");
            object stored = this.safeValue(this.trades, symbol);
            if (isTrue(isEqual(stored, null)))
            {
                object limit = this.safeInteger(this.options, "tradesLimit", 1000);
                stored = new ArrayCache(limit);
                ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
            }
            callDynamically(stored, "append", new object[] {trade});
            object messageHash = add(add(channelName, ":"), symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        }
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        return this.parseTrade(trade, market);
    }

    /**
     * @method
     * @name blofin#watchOrderBook
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://docs.blofin.com/index.html#ws-order-book-channel
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["callerMethodName"] = "watchOrderBook";
        return await this.watchOrderBookForSymbols(new List<object>() {symbol}, limit, parameters);
    }

    /**
     * @method
     * @name blofin#watchOrderBookForSymbols
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://docs.blofin.com/index.html#ws-order-book-channel
     * @param {string[]} symbols unified array of symbols
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.depth] the type of order book to subscribe to, default is 'depth/increase100', also accepts 'depth5' or 'depth20' or depth50
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object callerMethodName = null;
        var callerMethodNameparametersVariable = this.handleParamString(parameters, "callerMethodName", "watchOrderBookForSymbols");
        callerMethodName = ((IList<object>)callerMethodNameparametersVariable)[0];
        parameters = ((IList<object>)callerMethodNameparametersVariable)[1];
        object channelName = null;
        var channelNameparametersVariable = this.handleOptionAndParams(parameters, callerMethodName, "channel", "books");
        channelName = ((IList<object>)channelNameparametersVariable)[0];
        parameters = ((IList<object>)channelNameparametersVariable)[1];
        // due to some problem, temporarily disable other channels
        if (isTrue(!isEqual(channelName, "books")))
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), callerMethodName), "() at this moment "), channelName), " is not supported, coming soon")) ;
        }
        object orderbook = await this.watchMultipleWrapper(true, channelName, callerMethodName, symbols, parameters);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //   {
        //     arg: {
        //         channel: "books",
        //         instId: "DOGE-USDT",
        //     },
        //     action: "snapshot", // can be 'snapshot' or 'update'
        //     data: {
        //         asks: [   [ 0.08096, 1 ], [ 0.08097, 123 ], ...   ],
        //         bids: [   [ 0.08095, 4 ], [ 0.08094, 237 ], ...   ],
        //         ts: "1707491587909",
        //         prevSeqId: "0", // in case of 'update' there will be some value, less then seqId
        //         seqId: "3374250786",
        //     },
        // }
        //
        object arg = this.safeDict(message, "arg");
        object channelName = this.safeString(arg, "channel");
        object data = this.safeDict(message, "data");
        object marketId = this.safeString(arg, "instId");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object messageHash = add(add(channelName, ":"), symbol);
        if (!isTrue((inOp(this.orderbooks, symbol))))
        {
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook();
        }
        object orderbook = getValue(this.orderbooks, symbol);
        object timestamp = this.safeInteger(data, "ts");
        object action = this.safeString(message, "action");
        if (isTrue(isEqual(action, "snapshot")))
        {
            object orderBookSnapshot = this.parseOrderBook(data, symbol, timestamp);
            ((IDictionary<string,object>)orderBookSnapshot)["nonce"] = this.safeInteger(data, "seqId");
            (orderbook as IOrderBook).reset(orderBookSnapshot);
        } else
        {
            object asks = this.safeList(data, "asks", new List<object>() {});
            object bids = this.safeList(data, "bids", new List<object>() {});
            this.handleDeltasWithKeys(getValue(orderbook, "asks"), asks);
            this.handleDeltasWithKeys(getValue(orderbook, "bids"), bids);
            ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        }
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    /**
     * @method
     * @name blofin#watchTicker
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://docs.blofin.com/index.html#ws-tickers-channel
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["callerMethodName"] = "watchTicker";
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object result = await this.watchTickers(new List<object>() {symbol}, parameters);
        return getValue(result, symbol);
    }

    /**
     * @method
     * @name blofin#watchTickers
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
     * @see https://docs.blofin.com/index.html#ws-tickers-channel
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbols, null)))
        {
            throw new NotSupported ((string)add(this.id, " watchTickers() requires a list of symbols")) ;
        }
        object ticker = await this.watchMultipleWrapper(true, "tickers", "watchTickers", symbols, parameters);
        if (isTrue(this.newUpdates))
        {
            object tickers = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)tickers)[(string)getValue(ticker, "symbol")] = ticker;
            return tickers;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        // message
        //
        //     {
        //         arg: {
        //             channel: "tickers",
        //             instId: "DOGE-USDT",
        //         },
        //         data: [
        //             <same object as shown in REST example>
        //         ],
        //     }
        //
        this.handleBidAsk(client as WebSocketClient, message);
        object arg = this.safeDict(message, "arg");
        object channelName = this.safeString(arg, "channel");
        object data = this.safeList(message, "data");
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object ticker = this.parseWsTicker(getValue(data, i));
            object symbol = getValue(ticker, "symbol");
            object messageHash = add(add(channelName, ":"), symbol);
            ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
            callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.tickers, symbol), messageHash});
        }
    }

    public virtual object parseWsTicker(object ticker, object market = null)
    {
        return this.parseTicker(ticker, market);
    }

    /**
     * @method
     * @name blofin#watchBidsAsks
     * @description watches best bid & ask for symbols
     * @see https://docs.blofin.com/index.html#ws-tickers-channel
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchBidsAsks(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object firstMarket = this.market(getValue(symbols, 0));
        object channel = "tickers";
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("watchBidsAsks", firstMarket, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object url = this.implodeHostname(getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), marketType), "public"));
        object messageHashes = new List<object>() {};
        object args = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object market = this.market(getValue(symbols, i));
            ((IList<object>)messageHashes).Add(add("bidask:", getValue(market, "symbol")));
            ((IList<object>)args).Add(new Dictionary<string, object>() {
                { "channel", channel },
                { "instId", getValue(market, "id") },
            });
        }
        object request = this.getSubscriptionRequest(args);
        object ticker = await this.watchMultiple(url, messageHashes, this.deepExtend(request, parameters), messageHashes);
        if (isTrue(this.newUpdates))
        {
            object tickers = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)tickers)[(string)getValue(ticker, "symbol")] = ticker;
            return tickers;
        }
        return this.filterByArray(this.bidsasks, "symbol", symbols);
    }

    public virtual void handleBidAsk(WebSocketClient client, object message)
    {
        object data = this.safeList(message, "data");
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object ticker = this.parseWsBidAsk(getValue(data, i));
            object symbol = getValue(ticker, "symbol");
            object messageHash = add("bidask:", symbol);
            ((IDictionary<string,object>)this.bidsasks)[(string)symbol] = ticker;
            callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
        }
    }

    public virtual object parseWsBidAsk(object ticker, object market = null)
    {
        object marketId = this.safeString(ticker, "instId");
        market = this.safeMarket(marketId, market, "-");
        object symbol = this.safeString(market, "symbol");
        object timestamp = this.safeInteger(ticker, "ts");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "ask", this.safeString(ticker, "askPrice") },
            { "askVolume", this.safeString(ticker, "askSize") },
            { "bid", this.safeString(ticker, "bidPrice") },
            { "bidVolume", this.safeString(ticker, "bidSize") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name blofin#watchOHLCV
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["callerMethodName"] = "watchOHLCV";
        object result = await this.watchOHLCVForSymbols(new List<object>() {new List<object>() {symbol, timeframe}}, since, limit, parameters);
        return getValue(getValue(result, symbol), timeframe);
    }

    /**
     * @method
     * @name blofin#watchOHLCVForSymbols
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://docs.blofin.com/index.html#ws-candlesticks-channel
     * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCVForSymbols(object symbolsAndTimeframes, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object symbolsLength = getArrayLength(symbolsAndTimeframes);
        if (isTrue(isTrue(isEqual(symbolsLength, 0)) || !isTrue(((getValue(symbolsAndTimeframes, 0) is IList<object>) || (getValue(symbolsAndTimeframes, 0).GetType().IsGenericType && getValue(symbolsAndTimeframes, 0).GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]")) ;
        }
        await this.loadMarkets();
        var symboltimeframecandlesVariable = await this.watchMultipleWrapper(true, "candle", "watchOHLCVForSymbols", symbolsAndTimeframes, parameters);
        var symbol = ((IList<object>) symboltimeframecandlesVariable)[0];
        var timeframe = ((IList<object>) symboltimeframecandlesVariable)[1];
        var candles = ((IList<object>) symboltimeframecandlesVariable)[2];
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(candles, "getLimit", new object[] {symbol, limit});
        }
        object filtered = this.filterBySinceLimit(candles, since, limit, 0, true);
        return this.createOHLCVObject(symbol, timeframe, filtered);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        // message
        //
        //     {
        //         arg: {
        //             channel: "candle1m",
        //             instId: "DOGE-USDT",
        //         },
        //         data: [
        //             [ same object as shown in REST example ]
        //         ],
        //     }
        //
        object arg = this.safeDict(message, "arg");
        object channelName = this.safeString(arg, "channel");
        object data = this.safeList(message, "data");
        object marketId = this.safeString(arg, "instId");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object interval = ((string)channelName).Replace((string)"candle", (string)"");
        object unifiedTimeframe = this.findTimeframe(interval);
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeDict(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), unifiedTimeframe);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)unifiedTimeframe] = stored;
        }
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object candle = getValue(data, i);
            object parsed = this.parseOHLCV(candle, market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        object resolveData = new List<object>() {symbol, unifiedTimeframe, stored};
        object messageHash = add(add(add("candle", interval), ":"), symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {resolveData, messageHash});
    }

    /**
     * @method
     * @name blofin#watchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://docs.blofin.com/index.html#ws-account-channel
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("watchBalance", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " watchBalance() is not supported for spot markets yet")) ;
        }
        object messageHash = add(marketType, ":balance");
        object sub = new Dictionary<string, object>() {
            { "channel", "account" },
        };
        object request = this.getSubscriptionRequest(new List<object>() {sub});
        object url = this.implodeHostname(getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), marketType), "private"));
        return await this.watch(url, messageHash, this.deepExtend(request, parameters), messageHash);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        //     {
        //         arg: {
        //           channel: "account",
        //         },
        //         data: <same object as shown in REST example>,
        //     }
        //
        object marketType = "swap"; // for now
        if (!isTrue((inOp(this.balance, marketType))))
        {
            ((IDictionary<string,object>)this.balance)[(string)marketType] = new Dictionary<string, object>() {};
        }
        ((IDictionary<string,object>)this.balance)[(string)marketType] = this.parseWsBalance(message);
        object messageHash = add(marketType, ":balance");
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, marketType), messageHash});
    }

    public virtual object parseWsBalance(object message)
    {
        return this.parseBalance(message);
    }

    /**
     * @method
     * @name alpaca#watchOrders
     * @description watches information on multiple orders made by the user
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["callerMethodName"] = "watchOrders";
        object symbolsArray = ((bool) isTrue((!isEqual(symbol, null)))) ? new List<object>() {symbol} : new List<object>() {};
        return await this.watchOrdersForSymbols(symbolsArray, since, limit, parameters);
    }

    /**
     * @method
     * @name blofin#watchOrdersForSymbols
     * @description watches information on multiple orders made by the user across multiple symbols
     * @see https://docs.blofin.com/index.html#ws-order-channel
     * @param {string[]} symbols
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
     */
    public async override Task<object> watchOrdersForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticate();
        await this.loadMarkets();
        object orders = await this.watchMultipleWrapper(false, "orders", "watchOrdersForSymbols", symbols, parameters);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeValue(orders, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(orders, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(orders, since, limit, "timestamp", true);
    }

    public virtual void handleOrders(WebSocketClient client, object message)
    {
        //
        //     {
        //         action: 'update',
        //         arg: { channel: 'orders' },
        //         data: [
        //           <same object as shown in REST example>
        //         ]
        //     }
        //
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object orders = this.orders;
        object arg = this.safeDict(message, "arg");
        object channelName = this.safeString(arg, "channel");
        object data = this.safeList(message, "data");
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object order = this.parseWsOrder(getValue(data, i));
            object symbol = getValue(order, "symbol");
            object messageHash = add(add(channelName, ":"), symbol);
            callDynamically(orders, "append", new object[] {order});
            callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
            callDynamically(client as WebSocketClient, "resolve", new object[] {orders, channelName});
        }
    }

    public override object parseWsOrder(object order, object market = null)
    {
        return this.parseOrder(order, market);
    }

    /**
     * @method
     * @name blofin#watchPositions
     * @see https://docs.blofin.com/index.html#ws-positions-channel
     * @description watch all open positions
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param since
     * @param limit
     * @param {object} params extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
     */
    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticate();
        await this.loadMarkets();
        object newPositions = await this.watchMultipleWrapper(false, "positions", "watchPositions", symbols, parameters);
        if (isTrue(this.newUpdates))
        {
            return newPositions;
        }
        return this.filterBySymbolsSinceLimit(this.positions, symbols, since, limit);
    }

    public virtual void handlePositions(WebSocketClient client, object message)
    {
        //
        //     {
        //         arg: { channel: 'positions' },
        //         data: [
        //           <same object as shown in REST example>
        //         ]
        //     }
        //
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new ArrayCacheBySymbolBySide();
        }
        object cache = this.positions;
        object arg = this.safeDict(message, "arg");
        object channelName = this.safeString(arg, "channel");
        object data = this.safeList(message, "data");
        object newPositions = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object position = this.parseWsPosition(getValue(data, i));
            ((IList<object>)newPositions).Add(position);
            callDynamically(cache, "append", new object[] {position});
            object messageHash = add(add(channelName, ":"), getValue(position, "symbol"));
            callDynamically(client as WebSocketClient, "resolve", new object[] {position, messageHash});
        }
    }

    public virtual object parseWsPosition(object position, object market = null)
    {
        return this.parsePosition(position, market);
    }

    public async virtual Task<object> watchMultipleWrapper(object isPublic, object channelName, object callerMethodName, object symbolsArray = null, object parameters = null)
    {
        // underlier method for all watch-multiple symbols
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        var callerMethodNameparametersVariable = this.handleParamString(parameters, "callerMethodName", callerMethodName);
        callerMethodName = ((IList<object>)callerMethodNameparametersVariable)[0];
        parameters = ((IList<object>)callerMethodNameparametersVariable)[1];
        // if OHLCV method are being called, then symbols would be symbolsAndTimeframes (multi-dimensional) array
        object isOHLCV = (isEqual(channelName, "candle"));
        object symbols = ((bool) isTrue(isOHLCV)) ? this.getListFromObjectValues(symbolsArray, 0) : symbolsArray;
        symbols = this.marketSymbols(symbols, null, true, true);
        object firstMarket = null;
        object firstSymbol = this.safeString(symbols, 0);
        if (isTrue(!isEqual(firstSymbol, null)))
        {
            firstMarket = this.market(firstSymbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams(callerMethodName, firstMarket, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(!isEqual(marketType, "swap")))
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), callerMethodName), "() does not support "), marketType), " markets yet")) ;
        }
        object rawSubscriptions = new List<object>() {};
        object messageHashes = new List<object>() {};
        if (isTrue(isEqual(symbols, null)))
        {
            symbols = new List<object>() {};
        }
        object symbolsLength = getArrayLength(symbols);
        if (isTrue(isGreaterThan(symbolsLength, 0)))
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object current = getValue(symbols, i);
                object market = null;
                object channel = channelName;
                if (isTrue(isOHLCV))
                {
                    market = this.market(current);
                    object tfArray = getValue(symbolsArray, i);
                    object tf = getValue(tfArray, 1);
                    object interval = this.safeString(this.timeframes, tf, tf);
                    channel = add(channel, interval);
                } else
                {
                    market = this.market(current);
                }
                object topic = new Dictionary<string, object>() {
                    { "channel", channel },
                    { "instId", getValue(market, "id") },
                };
                ((IList<object>)rawSubscriptions).Add(topic);
                ((IList<object>)messageHashes).Add(add(add(channel, ":"), getValue(market, "symbol")));
            }
        } else
        {
            ((IList<object>)rawSubscriptions).Add(new Dictionary<string, object>() {
                { "channel", channelName },
            });
            ((IList<object>)messageHashes).Add(channelName);
        }
        // private channel are difference, they only need plural channel name for multiple symbols
        if (isTrue(this.inArray(channelName, new List<object>() {"orders", "positions"})))
        {
            rawSubscriptions = new List<object>() {new Dictionary<string, object>() {
    { "channel", channelName },
}};
        }
        object request = this.getSubscriptionRequest(rawSubscriptions);
        object privateOrPublic = ((bool) isTrue(isPublic)) ? "public" : "private";
        object url = this.implodeHostname(getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), marketType), privateOrPublic));
        return await this.watchMultiple(url, messageHashes, this.deepExtend(request, parameters), messageHashes);
    }

    public virtual object getSubscriptionRequest(object args)
    {
        return new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", args },
        };
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        //
        // message examples
        //
        // {
        //   arg: {
        //     channel: "trades",
        //     instId: "DOGE-USDT",
        //   },
        //   event: "subscribe"
        // }
        //
        // incoming data updates' examples can be seen under each handler method
        //
        object methods = new Dictionary<string, object>() {
            { "pong", this.handlePong },
            { "trades", this.handleTrades },
            { "books", this.handleOrderBook },
            { "tickers", this.handleTicker },
            { "candle", this.handleOHLCV },
            { "account", this.handleBalance },
            { "orders", this.handleOrders },
            { "positions", this.handlePositions },
        };
        object method = null;
        if (isTrue(isEqual(message, "pong")))
        {
            method = this.safeValue(methods, "pong");
        } else
        {
            object eventVar = this.safeString(message, "event");
            if (isTrue(isEqual(eventVar, "subscribe")))
            {
                return;
            } else if (isTrue(isEqual(eventVar, "login")))
            {
                var future = this.safeValue((client as WebSocketClient).futures, "authenticate_hash");
                (future as Future).resolve(true);
                return;
            } else if (isTrue(isEqual(eventVar, "error")))
            {
                throw new ExchangeError ((string)add(add(this.id, " error: "), this.json(message))) ;
            }
            object arg = this.safeDict(message, "arg");
            object channelName = this.safeString(arg, "channel");
            method = this.safeValue(methods, channelName);
            if (isTrue(!isTrue(method) && isTrue(isGreaterThanOrEqual(getIndexOf(channelName, "candle"), 0))))
            {
                method = getValue(methods, "candle");
            }
        }
        if (isTrue(method))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
    }

    public async virtual Task authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object milliseconds = this.milliseconds();
        object messageHash = "authenticate_hash";
        object timestamp = ((object)milliseconds).ToString();
        object nonce = add("n_", timestamp);
        object auth = add(add(add(add("/users/self/verify", "GET"), timestamp), ""), nonce);
        object signature = this.stringToBase64(this.hmac(this.encode(auth), this.encode(this.secret), sha256));
        object request = new Dictionary<string, object>() {
            { "op", "login" },
            { "args", new List<object>() {new Dictionary<string, object>() {
    { "apiKey", this.apiKey },
    { "passphrase", this.password },
    { "timestamp", timestamp },
    { "nonce", nonce },
    { "sign", signature },
}} },
        };
        object marketType = "swap"; // for now
        object url = this.implodeHostname(getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), marketType), "private"));
        await this.watch(url, messageHash, this.deepExtend(request, parameters), messageHash);
    }
}
