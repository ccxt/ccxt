namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class bingx { public bingx(object args = null) : base(args) { } }
public partial class bingx : ccxt.bingx
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchTrades", true },
                { "watchOrderBook", true },
                { "watchOHLCV", true },
                { "watchOrders", true },
                { "watchMyTrades", true },
                { "watchTicker", true },
                { "watchTickers", false },
                { "watchBalance", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "spot", "wss://open-api-ws.bingx.com/market" },
                        { "swap", "wss://open-api-swap.bingx.com/swap-market" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "listenKeyRefreshRate", 3540000 },
                { "ws", new Dictionary<string, object>() {
                    { "gunzip", true },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "timeframes", new Dictionary<string, object>() {
                        { "1m", "1m" },
                        { "3m", "3m" },
                        { "5m", "5m" },
                        { "15m", "15m" },
                        { "30m", "30m" },
                        { "1h", "1h" },
                        { "2h", "2h" },
                        { "4h", "4h" },
                        { "6h", "6h" },
                        { "12h", "12h" },
                        { "1d", "1d" },
                        { "3d", "3d" },
                        { "1w", "1w" },
                        { "1M", "1M" },
                    } },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "timeframes", new Dictionary<string, object>() {
                        { "1m", "1min" },
                        { "5m", "5min" },
                        { "15m", "15min" },
                        { "30m", "30min" },
                        { "1h", "60min" },
                        { "1d", "1day" },
                    } },
                } },
                { "watchBalance", new Dictionary<string, object>() {
                    { "fetchBalanceSnapshot", true },
                    { "awaitBalanceSnapshot", false },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "keepAlive", 1800000 },
            } },
        });
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bingx#watchTicker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/market.html#Subscribe%20to%2024-hour%20price%20changes
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var marketTypequeryVariable = this.handleMarketTypeAndParams("watchTrades", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        object url = this.safeValue(getValue(getValue(this.urls, "api"), "ws"), marketType);
        if (isTrue(isEqual(url, null)))
        {
            throw new BadRequest ((string)add(add(add(this.id, " watchTrades is not supported for "), marketType), " markets.")) ;
        }
        object messageHash = add(getValue(market, "id"), "@ticker");
        object uuid = this.uuid();
        object request = new Dictionary<string, object>() {
            { "id", uuid },
            { "dataType", messageHash },
        };
        if (isTrue(isEqual(marketType, "swap")))
        {
            ((IDictionary<string,object>)request)["reqType"] = "sub";
        }
        return await this.watch(url, messageHash, this.extend(request, query), messageHash);
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "dataType": "BTC-USDT@ticker",
        //         "data": {
        //             "e": "24hTicker",
        //             "E": 1706498923556,
        //             "s": "BTC-USDT",
        //             "p": "346.4",
        //             "P": "0.82",
        //             "c": "42432.5",
        //             "L": "0.0529",
        //             "h": "42855.4",
        //             "l": "41578.3",
        //             "v": "64310.9754",
        //             "q": "2728360284.15",
        //             "o": "42086.1",
        //             "O": 1706498922655,
        //             "C": 1706498883023,
        //             "A": "42437.8",
        //             "a": "1.4160",
        //             "B": "42437.1",
        //             "b": "2.5747"
        //         }
        //     }
        //
        // spot
        //
        //     {
        //         "code": 0,
        //         "timestamp": 1706506795473,
        //         "data": {
        //             "e": "24hTicker",
        //             "E": 1706506795472,
        //             "s": "BTC-USDT",
        //             "p": -372.12,
        //             "P": "-0.87%",
        //             "o": 42548.95,
        //             "h": 42696.1,
        //             "l": 41621.29,
        //             "c": 42176.83,
        //             "v": 4943.33,
        //             "q": 208842236.5,
        //             "O": 1706420395472,
        //             "C": 1706506795472,
        //             "A": 42177.23,
        //             "a": 5.14484,
        //             "B": 42176.38,
        //             "b": 5.36117
        //         }
        //     }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "s");
        // const marketId = messageHash.split('@')[0];
        object isSwap = isGreaterThanOrEqual(getIndexOf(client.url, "swap"), 0);
        object marketType = ((bool) isTrue(isSwap)) ? "swap" : "spot";
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        object ticker = this.parseWsTicker(data, market);
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
        object messageHash = add(getValue(market, "id"), "@ticker");
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
    }

    public virtual object parseWsTicker(object message, object market = null)
    {
        //
        //     {
        //         "e": "24hTicker",
        //         "E": 1706498923556,
        //         "s": "BTC-USDT",
        //         "p": "346.4",
        //         "P": "0.82",
        //         "c": "42432.5",
        //         "L": "0.0529",
        //         "h": "42855.4",
        //         "l": "41578.3",
        //         "v": "64310.9754",
        //         "q": "2728360284.15",
        //         "o": "42086.1",
        //         "O": 1706498922655,
        //         "C": 1706498883023,
        //         "A": "42437.8",
        //         "a": "1.4160",
        //         "B": "42437.1",
        //         "b": "2.5747"
        //     }
        //
        object timestamp = this.safeInteger(message, "ts");
        object marketId = this.safeString(message, "s");
        market = this.safeMarket(marketId, market);
        object close = this.safeString(message, "c");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(message, "h") },
            { "low", this.safeString(message, "l") },
            { "bid", this.safeString(message, "B") },
            { "bidVolume", this.safeString(message, "b") },
            { "ask", this.safeString(message, "A") },
            { "askVolume", this.safeString(message, "a") },
            { "vwap", null },
            { "open", this.safeString(message, "o") },
            { "close", close },
            { "last", close },
            { "previousClose", null },
            { "change", this.safeString(message, "p") },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(message, "v") },
            { "quoteVolume", this.safeString(message, "q") },
            { "info", message },
        }, market);
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#watchTrades
        * @description watches information on multiple trades made in a market
        * @see https://bingx-api.github.io/docs/#/spot/socket/market.html#Subscribe%20to%20tick-by-tick
        * @see https://bingx-api.github.io/docs/#/swapV2/socket/market.html#Subscribe%20the%20Latest%20Trade%20Detail
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var marketTypequeryVariable = this.handleMarketTypeAndParams("watchTrades", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        object url = this.safeValue(getValue(getValue(this.urls, "api"), "ws"), marketType);
        if (isTrue(isEqual(url, null)))
        {
            throw new BadRequest ((string)add(add(add(this.id, " watchTrades is not supported for "), marketType), " markets.")) ;
        }
        object messageHash = add(getValue(market, "id"), "@trade");
        object uuid = this.uuid();
        object request = new Dictionary<string, object>() {
            { "id", uuid },
            { "dataType", messageHash },
        };
        if (isTrue(isEqual(marketType, "swap")))
        {
            ((IDictionary<string,object>)request)["reqType"] = "sub";
        }
        object trades = await this.watch(url, messageHash, this.extend(request, query), messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        // spot
        // first snapshot
        //
        //    {
        //      "id": "d83b78ce-98be-4dc2-b847-12fe471b5bc5",
        //      "code": 0,
        //      "msg": "SUCCESS",
        //      "timestamp": 1690214699854
        //    }
        //
        // subsequent updates
        //
        //     {
        //         "code": 0,
        //         "data": {
        //           "E": 1690214529432,
        //           "T": 1690214529386,
        //           "e": "trade",
        //           "m": true,
        //           "p": "29110.19",
        //           "q": "0.1868",
        //           "s": "BTC-USDT",
        //           "t": "57903921"
        //         },
        //         "dataType": "BTC-USDT@trade",
        //         "success": true
        //     }
        //
        //
        // swap
        // first snapshot
        //
        //    {
        //        "id": "2aed93b1-6e1e-4038-aeba-f5eeaec2ca48",
        //        "code": 0,
        //        "msg": '',
        //        "dataType": '',
        //        "data": null
        //    }
        //
        // subsequent updates
        //
        //
        //    {
        //        "code": 0,
        //        "dataType": "BTC-USDT@trade",
        //        "data": [
        //            {
        //                "q": "0.0421",
        //                "p": "29023.5",
        //                "T": 1690221401344,
        //                "m": false,
        //                "s": "BTC-USDT"
        //            },
        //            ...
        //        ]
        //    }
        //
        object data = this.safeValue(message, "data", new List<object>() {});
        object messageHash = this.safeString(message, "dataType");
        object marketId = getValue(((string)messageHash).Split(new [] {((string)"@")}, StringSplitOptions.None).ToList<object>(), 0);
        object isSwap = isGreaterThanOrEqual(getIndexOf(client.url, "swap"), 0);
        object marketType = ((bool) isTrue(isSwap)) ? "swap" : "spot";
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        object trades = null;
        if (isTrue(((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            trades = this.parseTrades(data, market);
        } else
        {
            trades = new List<object> {this.parseTrade(data, market)};
        }
        object stored = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        for (object j = 0; isLessThan(j, getArrayLength(trades)); postFixIncrement(ref j))
        {
            callDynamically(stored, "append", new object[] {getValue(trades, j)});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#watchOrderBook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://bingx-api.github.io/docs/#/spot/socket/market.html#Subscribe%20Market%20Depth%20Data
        * @see https://bingx-api.github.io/docs/#/swapV2/socket/market.html#Subscribe%20Market%20Depth%20Data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var marketTypequeryVariable = this.handleMarketTypeAndParams("watchOrderBook", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100;
        } else
        {
            if (isTrue(isEqual(marketType, "swap")))
            {
                if (isTrue(isTrue(isTrue(isTrue(isTrue((!isEqual(limit, 5))) && isTrue((!isEqual(limit, 10)))) && isTrue((!isEqual(limit, 20)))) && isTrue((!isEqual(limit, 50)))) && isTrue((!isEqual(limit, 100)))))
                {
                    throw new BadRequest ((string)add(this.id, " watchOrderBook() (swap) only supports limit 5, 10, 20, 50, and 100")) ;
                }
            } else if (isTrue(isEqual(marketType, "spot")))
            {
                if (isTrue(isTrue((!isEqual(limit, 20))) && isTrue((!isEqual(limit, 100)))))
                {
                    throw new BadRequest ((string)add(this.id, " watchOrderBook() (spot) only supports limit 20, and 100")) ;
                }
            }
        }
        object url = this.safeValue(getValue(getValue(this.urls, "api"), "ws"), marketType);
        if (isTrue(isEqual(url, null)))
        {
            throw new BadRequest ((string)add(add(add(this.id, " watchOrderBook is not supported for "), marketType), " markets.")) ;
        }
        object messageHash = add(add(getValue(market, "id"), "@depth"), ((object)limit).ToString());
        object uuid = this.uuid();
        object request = new Dictionary<string, object>() {
            { "id", uuid },
            { "dataType", messageHash },
        };
        if (isTrue(isEqual(marketType, "swap")))
        {
            ((IDictionary<string,object>)request)["reqType"] = "sub";
        }
        object orderbook = await this.watch(url, messageHash, this.deepExtend(request, query), messageHash);
        return (orderbook as IOrderBook).limit();
    }

    public override void handleDelta(object bookside, object delta)
    {
        object price = this.safeFloat(delta, 0);
        object amount = this.safeFloat(delta, 1);
        (bookside as IOrderBookSide).store(price, amount);
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //
        //    {
        //        "code": 0,
        //        "dataType": "BTC-USDT@depth20",
        //        "data": {
        //          "bids": [
        //            [ '28852.9', "34.2621" ],
        //            ...
        //          ],
        //          "asks": [
        //            [ '28864.9', "23.4079" ],
        //            ...
        //          ]
        //        },
        //        "dataType": "BTC-USDT@depth20",
        //        "success": true
        //    }
        //
        // swap
        //
        //
        //    {
        //        "code": 0,
        //        "dataType": "BTC-USDT@depth20",
        //        "data": {
        //          "bids": [
        //            [ '28852.9', "34.2621" ],
        //            ...
        //          ],
        //          "asks": [
        //            [ '28864.9', "23.4079" ],
        //            ...
        //          ]
        //        }
        //    }
        //
        object data = this.safeValue(message, "data", new List<object>() {});
        object messageHash = this.safeString(message, "dataType");
        object marketId = getValue(((string)messageHash).Split(new [] {((string)"@")}, StringSplitOptions.None).ToList<object>(), 0);
        object isSwap = isGreaterThanOrEqual(getIndexOf(client.url, "swap"), 0);
        object marketType = ((bool) isTrue(isSwap)) ? "swap" : "spot";
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        object orderbook = this.safeValue(this.orderbooks, symbol);
        if (isTrue(isEqual(orderbook, null)))
        {
            orderbook = this.orderBook();
        }
        object snapshot = this.parseOrderBook(data, symbol, null, "bids", "asks", 0, 1);
        (orderbook as IOrderBook).reset(snapshot);
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public override object parseWsOHLCV(object ohlcv, object market = null)
    {
        //
        //    {
        //        "c": "28909.0",
        //        "o": "28915.4",
        //        "h": "28915.4",
        //        "l": "28896.1",
        //        "v": "27.6919",
        //        "T": 1696687499999,
        //        "t": 1696687440000
        //    }
        //
        // for spot, opening-time (t) is used instead of closing-time (T), to be compatible with fetchOHLCV
        // for swap, (T) is the opening time
        object timestamp = ((bool) isTrue((getValue(market, "spot")))) ? "t" : "T";
        return new List<object> {this.safeInteger(ohlcv, timestamp), this.safeNumber(ohlcv, "o"), this.safeNumber(ohlcv, "h"), this.safeNumber(ohlcv, "l"), this.safeNumber(ohlcv, "c"), this.safeNumber(ohlcv, "v")};
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //   {
        //       "code": 0,
        //       "data": {
        //         "E": 1696687498608,
        //         "K": {
        //           "T": 1696687499999,
        //           "c": "27917.829",
        //           "h": "27918.427",
        //           "i": "1min",
        //           "l": "27917.7",
        //           "n": 262,
        //           "o": "27917.91",
        //           "q": "25715.359197",
        //           "s": "BTC-USDT",
        //           "t": 1696687440000,
        //           "v": "0.921100"
        //         },
        //         "e": "kline",
        //         "s": "BTC-USDT"
        //       },
        //       "dataType": "BTC-USDT@kline_1min",
        //       "success": true
        //   }
        //
        // swap
        //    {
        //        "code": 0,
        //        "dataType": "BTC-USDT@kline_1m",
        //        "s": "BTC-USDT",
        //        "data": [
        //            {
        //            "c": "28909.0",
        //            "o": "28915.4",
        //            "h": "28915.4",
        //            "l": "28896.1",
        //            "v": "27.6919",
        //            "T": 1690907580000
        //            }
        //        ]
        //    }
        //
        object data = this.safeValue(message, "data", new List<object>() {});
        object candles = null;
        if (isTrue(((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            candles = data;
        } else
        {
            candles = new List<object> {this.safeValue(data, "K", new List<object>() {})};
        }
        object messageHash = this.safeString(message, "dataType");
        object timeframeId = getValue(((string)messageHash).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>(), 1);
        object marketId = getValue(((string)messageHash).Split(new [] {((string)"@")}, StringSplitOptions.None).ToList<object>(), 0);
        object isSwap = isGreaterThanOrEqual(getIndexOf(client.url, "swap"), 0);
        object marketType = ((bool) isTrue(isSwap)) ? "swap" : "spot";
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframeId);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframeId] = stored;
        }
        for (object i = 0; isLessThan(i, getArrayLength(candles)); postFixIncrement(ref i))
        {
            object candle = getValue(candles, i);
            object parsed = this.parseWsOHLCV(candle, market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#watchOHLCV
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://bingx-api.github.io/docs/#/spot/socket/market.html#K%E7%BA%BF%20Streams
        * @see https://bingx-api.github.io/docs/#/swapV2/socket/market.html#Subscribe%20K-Line%20Data
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var marketTypequeryVariable = this.handleMarketTypeAndParams("watchOHLCV", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        object url = this.safeValue(getValue(getValue(this.urls, "api"), "ws"), marketType);
        if (isTrue(isEqual(url, null)))
        {
            throw new BadRequest ((string)add(add(add(this.id, " watchOHLCV is not supported for "), marketType), " markets.")) ;
        }
        object options = this.safeValue(this.options, marketType, new Dictionary<string, object>() {});
        object timeframes = this.safeValue(options, "timeframes", new Dictionary<string, object>() {});
        object interval = this.safeString(timeframes, timeframe, timeframe);
        object messageHash = add(add(getValue(market, "id"), "@kline_"), interval);
        object uuid = this.uuid();
        object request = new Dictionary<string, object>() {
            { "id", uuid },
            { "dataType", messageHash },
        };
        if (isTrue(isEqual(marketType, "swap")))
        {
            ((IDictionary<string,object>)request)["reqType"] = "sub";
        }
        object ohlcv = await this.watch(url, messageHash, this.extend(request, query), messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#watchOrders
        * @see https://bingx-api.github.io/docs/#/spot/socket/account.html#Subscription%20order%20update%20data
        * @see https://bingx-api.github.io/docs/#/swapV2/socket/account.html#Account%20balance%20and%20position%20update%20push
        * @description watches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object type = null;
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        var typeparametersVariable = this.handleMarketTypeAndParams("watchOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object isSpot = (isEqual(type, "spot"));
        object spotHash = "spot:private";
        object swapHash = "swap:private";
        object subscriptionHash = ((bool) isTrue(isSpot)) ? spotHash : swapHash;
        object spotMessageHash = "spot:order";
        object swapMessageHash = "swap:order";
        object messageHash = ((bool) isTrue(isSpot)) ? spotMessageHash : swapMessageHash;
        if (isTrue(!isEqual(market, null)))
        {
            messageHash = add(messageHash, add(":", symbol));
        }
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "?listenKey="), getValue(this.options, "listenKey"));
        object request = null;
        object uuid = this.uuid();
        if (isTrue(isSpot))
        {
            request = new Dictionary<string, object>() {
                { "id", uuid },
                { "dataType", "spot.executionReport" },
            };
        }
        object orders = await this.watch(url, messageHash, request, subscriptionHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#watchMyTrades
        * @see https://bingx-api.github.io/docs/#/spot/socket/account.html#Subscription%20order%20update%20data
        * @see https://bingx-api.github.io/docs/#/swapV2/socket/account.html#Account%20balance%20and%20position%20update%20push
        * @description watches information on multiple trades made by the user
        * @param {string} symbol unified market symbol of the market trades were made in
        * @param {int} [since] the earliest time in ms to trades orders for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object type = null;
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        var typeparametersVariable = this.handleMarketTypeAndParams("watchOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object isSpot = (isEqual(type, "spot"));
        object spotSubHash = "spot:private";
        object swapSubHash = "swap:private";
        object subscriptionHash = ((bool) isTrue(isSpot)) ? spotSubHash : swapSubHash;
        object spotMessageHash = "spot:mytrades";
        object swapMessageHash = "swap:mytrades";
        object messageHash = ((bool) isTrue(isSpot)) ? spotMessageHash : swapMessageHash;
        if (isTrue(!isEqual(market, null)))
        {
            messageHash = add(messageHash, add(":", symbol));
        }
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "?listenKey="), getValue(this.options, "listenKey"));
        object request = null;
        object uuid = this.uuid();
        if (isTrue(isSpot))
        {
            request = new Dictionary<string, object>() {
                { "id", uuid },
                { "dataType", "spot.executionReport" },
            };
        }
        object trades = await this.watch(url, messageHash, request, subscriptionHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bingx#watchBalance
        * @see https://bingx-api.github.io/docs/#/spot/socket/account.html#Subscription%20order%20update%20data
        * @see https://bingx-api.github.io/docs/#/swapV2/socket/account.html#Account%20balance%20and%20position%20update%20push
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object isSpot = (isEqual(type, "spot"));
        object spotSubHash = "spot:balance";
        object swapSubHash = "swap:private";
        object spotMessageHash = "spot:balance";
        object swapMessageHash = "swap:balance";
        object messageHash = ((bool) isTrue(isSpot)) ? spotMessageHash : swapMessageHash;
        object subscriptionHash = ((bool) isTrue(isSpot)) ? spotSubHash : swapSubHash;
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "?listenKey="), getValue(this.options, "listenKey"));
        object request = null;
        object uuid = this.uuid();
        if (isTrue(isEqual(type, "spot")))
        {
            request = new Dictionary<string, object>() {
                { "id", uuid },
                { "dataType", "ACCOUNT_UPDATE" },
            };
        }
        var client = this.client(url);
        this.setBalanceCache(client as WebSocketClient, type, subscriptionHash, parameters);
        object fetchBalanceSnapshot = null;
        object awaitBalanceSnapshot = null;
        var fetchBalanceSnapshotparametersVariable = this.handleOptionAndParams(parameters, "watchBalance", "fetchBalanceSnapshot", true);
        fetchBalanceSnapshot = ((IList<object>)fetchBalanceSnapshotparametersVariable)[0];
        parameters = ((IList<object>)fetchBalanceSnapshotparametersVariable)[1];
        var awaitBalanceSnapshotparametersVariable = this.handleOptionAndParams(parameters, "watchBalance", "awaitBalanceSnapshot", false);
        awaitBalanceSnapshot = ((IList<object>)awaitBalanceSnapshotparametersVariable)[0];
        parameters = ((IList<object>)awaitBalanceSnapshotparametersVariable)[1];
        if (isTrue(isTrue(fetchBalanceSnapshot) && isTrue(awaitBalanceSnapshot)))
        {
            await client.future(add(type, ":fetchBalanceSnapshot"));
        }
        return await this.watch(url, messageHash, request, subscriptionHash);
    }

    public virtual void setBalanceCache(WebSocketClient client, object type, object subscriptionHash, object parameters)
    {
        if (isTrue(inOp(((WebSocketClient)client).subscriptions, subscriptionHash)))
        {
            return;
        }
        object fetchBalanceSnapshot = this.handleOptionAndParams(parameters, "watchBalance", "fetchBalanceSnapshot", true);
        if (isTrue(fetchBalanceSnapshot))
        {
            object messageHash = add(type, ":fetchBalanceSnapshot");
            if (!isTrue((inOp(client.futures, messageHash))))
            {
                client.future(messageHash);
                this.spawn(this.loadBalanceSnapshot, new object[] { client, messageHash, type});
            }
        } else
        {
            ((IDictionary<string,object>)this.balance)[(string)type] = new Dictionary<string, object>() {};
        }
    }

    public async virtual Task loadBalanceSnapshot(WebSocketClient client, object messageHash, object type)
    {
        object response = await this.fetchBalance(new Dictionary<string, object>() {
            { "type", type },
        });
        ((IDictionary<string,object>)this.balance)[(string)type] = this.extend(response, this.safeValue(this.balance, type, new Dictionary<string, object>() {}));
        // don't remove the future from the .futures cache
        var future = getValue(client.futures, messageHash);
        (future as Future).resolve();
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, type), add(type, ":balance")});
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        //
        // { code: 100400, msg: '', timestamp: 1696245808833 }
        //
        // {
        //     "code": 100500,
        //     "id": "9cd37d32-da98-440b-bd04-37e7dbcf51ad",
        //     "msg": '',
        //     "timestamp": 1696245842307
        // }
        object code = this.safeString(message, "code");
        try
        {
            if (isTrue(!isEqual(code, null)))
            {
                object feedback = add(add(this.id, " "), this.json(message));
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            }
        } catch(Exception e)
        {
            ((WebSocketClient)client).reject(e);
        }
        return true;
    }

    public async virtual Task authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object time = this.milliseconds();
        object listenKey = this.safeString(this.options, "listenKey");
        if (isTrue(isEqual(listenKey, null)))
        {
            object response = await this.userAuthPrivatePostUserDataStream();
            ((IDictionary<string,object>)this.options)["listenKey"] = this.safeString(response, "listenKey");
            ((IDictionary<string,object>)this.options)["lastAuthenticatedTime"] = time;
            return;
        }
        object lastAuthenticatedTime = this.safeInteger(this.options, "lastAuthenticatedTime", 0);
        object listenKeyRefreshRate = this.safeInteger(this.options, "listenKeyRefreshRate", 3600000); // 1 hour
        if (isTrue(isGreaterThan(subtract(time, lastAuthenticatedTime), listenKeyRefreshRate)))
        {
            object response = await this.userAuthPrivatePutUserDataStream(new Dictionary<string, object>() {
                { "listenKey", listenKey },
            }); // extend the expiry
            ((IDictionary<string,object>)this.options)["listenKey"] = this.safeString(response, "listenKey");
            ((IDictionary<string,object>)this.options)["lastAuthenticatedTime"] = time;
        }
    }

    public async virtual Task pong(WebSocketClient client, object message)
    {
        try
        {
            if (isTrue(isEqual(message, "Ping")))
            {
                await client.send("Pong");
            } else
            {
                object ping = this.safeString(message, "ping");
                object time = this.safeString(message, "time");
                await client.send(new Dictionary<string, object>() {
                    { "pong", ping },
                    { "time", time },
                });
            }
        } catch(Exception e)
        {
            var error = new NetworkError(add(add(this.id, " pong failed with error "), this.json(e)));
            ((WebSocketClient)client).reset(error);
        }
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        //
        //     {
        //         "code": 0,
        //         "dataType": "spot.executionReport",
        //         "data": {
        //            "e": "executionReport",
        //            "E": 1694680212947,
        //            "s": "LTC-USDT",
        //            "S": "BUY",
        //            "o": "LIMIT",
        //            "q": 0.1,
        //            "p": 50,
        //            "x": "NEW",
        //            "X": "PENDING",
        //            "i": 1702238305204043800,
        //            "l": 0,
        //            "z": 0,
        //            "L": 0,
        //            "n": 0,
        //            "N": "",
        //            "T": 0,
        //            "t": 0,
        //            "O": 1694680212676,
        //            "Z": 0,
        //            "Y": 0,
        //            "Q": 0,
        //            "m": false
        //         }
        //      }
        //
        //      {
        //         "code": 0,
        //         "dataType": "spot.executionReport",
        //         "data": {
        //           "e": "executionReport",
        //           "E": 1694681809302,
        //           "s": "LTC-USDT",
        //           "S": "BUY",
        //           "o": "MARKET",
        //           "q": 0,
        //           "p": 62.29,
        //           "x": "TRADE",
        //           "X": "FILLED",
        //           "i": "1702245001712369664",
        //           "l": 0.0802,
        //           "z": 0.0802,
        //           "L": 62.308,
        //           "n": -0.0000802,
        //           "N": "LTC",
        //           "T": 1694681809256,
        //           "t": 38259147,
        //           "O": 1694681809248,
        //           "Z": 4.9971016,
        //           "Y": 4.9971016,
        //           "Q": 5,
        //           "m": false
        //         }
        //       }
        // swap
        //    {
        //        "e": "ORDER_TRADE_UPDATE",
        //        "E": 1696843635475,
        //        "o": {
        //           "s": "LTC-USDT",
        //           "c": "",
        //           "i": "1711312357852147712",
        //           "S": "BUY",
        //           "o": "MARKET",
        //           "q": "0.10000000",
        //           "p": "64.35010000",
        //           "ap": "64.36000000",
        //           "x": "TRADE",
        //           "X": "FILLED",
        //           "N": "USDT",
        //           "n": "-0.00321800",
        //           "T": 0,
        //           "wt": "MARK_PRICE",
        //           "ps": "LONG",
        //           "rp": "0.00000000",
        //           "z": "0.10000000"
        //        }
        //    }
        //
        object isSpot = (inOp(message, "dataType"));
        object data = this.safeValue2(message, "data", "o", new Dictionary<string, object>() {});
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object stored = this.orders;
        object parsedOrder = this.parseOrder(data);
        callDynamically(stored, "append", new object[] {parsedOrder});
        object symbol = getValue(parsedOrder, "symbol");
        object spotHash = "spot:order";
        object swapHash = "swap:order";
        object messageHash = ((bool) isTrue((isSpot))) ? spotHash : swapHash;
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, add(add(messageHash, ":"), symbol)});
    }

    public virtual void handleMyTrades(WebSocketClient client, object message)
    {
        //
        //
        //      {
        //         "code": 0,
        //         "dataType": "spot.executionReport",
        //         "data": {
        //           "e": "executionReport",
        //           "E": 1694681809302,
        //           "s": "LTC-USDT",
        //           "S": "BUY",
        //           "o": "MARKET",
        //           "q": 0,
        //           "p": 62.29,
        //           "x": "TRADE",
        //           "X": "FILLED",
        //           "i": "1702245001712369664",
        //           "l": 0.0802,
        //           "z": 0.0802,
        //           "L": 62.308,
        //           "n": -0.0000802,
        //           "N": "LTC",
        //           "T": 1694681809256,
        //           "t": 38259147,
        //           "O": 1694681809248,
        //           "Z": 4.9971016,
        //           "Y": 4.9971016,
        //           "Q": 5,
        //           "m": false
        //         }
        //       }
        //
        //  swap
        //    {
        //        "e": "ORDER_TRADE_UPDATE",
        //        "E": 1696843635475,
        //        "o": {
        //           "s": "LTC-USDT",
        //           "c": "",
        //           "i": "1711312357852147712",
        //           "S": "BUY",
        //           "o": "MARKET",
        //           "q": "0.10000000",
        //           "p": "64.35010000",
        //           "ap": "64.36000000",
        //           "x": "TRADE",
        //           "X": "FILLED",
        //           "N": "USDT",
        //           "n": "-0.00321800",
        //           "T": 0,
        //           "wt": "MARK_PRICE",
        //           "ps": "LONG",
        //           "rp": "0.00000000",
        //           "z": "0.10000000"
        //        }
        //    }
        //
        object isSpot = (inOp(message, "dataType"));
        object result = this.safeValue2(message, "data", "o", new Dictionary<string, object>() {});
        object cachedTrades = this.myTrades;
        if (isTrue(isEqual(cachedTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            cachedTrades = new ArrayCacheBySymbolById(limit);
            this.myTrades = cachedTrades;
        }
        object parsed = this.parseTrade(result);
        object symbol = getValue(parsed, "symbol");
        object spotHash = "spot:mytrades";
        object swapHash = "swap:mytrades";
        object messageHash = ((bool) isTrue(isSpot)) ? spotHash : swapHash;
        callDynamically(cachedTrades, "append", new object[] {parsed});
        callDynamically(client as WebSocketClient, "resolve", new object[] {cachedTrades, messageHash});
        callDynamically(client as WebSocketClient, "resolve", new object[] {cachedTrades, add(add(messageHash, ":"), symbol)});
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        // spot
        //     {
        //         "e":"ACCOUNT_UPDATE",
        //         "E":1696242817000,
        //         "T":1696242817142,
        //         "a":{
        //            "B":[
        //               {
        //                  "a":"USDT",
        //                  "bc":"-1.00000000000000000000",
        //                  "cw":"86.59497382000000050000",
        //                  "wb":"86.59497382000000050000"
        //               }
        //            ],
        //            "m":"ASSET_TRANSFER"
        //         }
        //     }
        // swap
        //     {
        //         "e":"ACCOUNT_UPDATE",
        //         "E":1696244249320,
        //         "a":{
        //            "m":"WITHDRAW",
        //            "B":[
        //               {
        //                  "a":"USDT",
        //                  "wb":"49.81083984",
        //                  "cw":"49.81083984",
        //                  "bc":"-1.00000000"
        //               }
        //            ],
        //            "P":[
        //            ]
        //         }
        //     }
        //
        object a = this.safeValue(message, "a", new Dictionary<string, object>() {});
        object data = this.safeValue(a, "B", new List<object>() {});
        object timestamp = this.safeInteger2(message, "T", "E");
        object type = ((bool) isTrue((inOp(a, "P")))) ? "swap" : "spot";
        ((IDictionary<string,object>)getValue(this.balance, type))["info"] = data;
        ((IDictionary<string,object>)getValue(this.balance, type))["timestamp"] = timestamp;
        ((IDictionary<string,object>)getValue(this.balance, type))["datetime"] = this.iso8601(timestamp);
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object balance = getValue(data, i);
            object currencyId = this.safeString(balance, "a");
            object code = this.safeCurrencyCode(currencyId);
            object account = ((bool) isTrue((inOp(getValue(this.balance, type), code)))) ? getValue(getValue(this.balance, type), code) : this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "wb");
            object balanceChange = this.safeString(balance, "bc");
            if (isTrue(!isEqual(getValue(account, "used"), null)))
            {
                ((IDictionary<string,object>)account)["used"] = Precise.stringSub(this.safeString(account, "used"), balanceChange);
            }
            ((IDictionary<string,object>)getValue(this.balance, type))[(string)code] = account;
        }
        ((IDictionary<string,object>)this.balance)[(string)type] = this.safeBalance(getValue(this.balance, type));
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, type), add(type, ":balance")});
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (!isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            return;
        }
        // public subscriptions
        if (isTrue(isTrue((isEqual(message, "Ping"))) || isTrue((inOp(message, "ping")))))
        {
            this.spawn(this.pong, new object[] { client, message});
            return;
        }
        object dataType = this.safeString(message, "dataType", "");
        if (isTrue(isGreaterThanOrEqual(getIndexOf(dataType, "@depth"), 0)))
        {
            this.handleOrderBook(client as WebSocketClient, message);
            return;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(dataType, "@ticker"), 0)))
        {
            this.handleTicker(client as WebSocketClient, message);
            return;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(dataType, "@trade"), 0)))
        {
            this.handleTrades(client as WebSocketClient, message);
            return;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(dataType, "@kline"), 0)))
        {
            this.handleOHLCV(client as WebSocketClient, message);
            return;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(dataType, "executionReport"), 0)))
        {
            object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
            object type = this.safeString(data, "x");
            if (isTrue(isEqual(type, "TRADE")))
            {
                this.handleMyTrades(client as WebSocketClient, message);
            }
            this.handleOrder(client as WebSocketClient, message);
            return;
        }
        object e = this.safeString(message, "e");
        if (isTrue(isEqual(e, "ACCOUNT_UPDATE")))
        {
            this.handleBalance(client as WebSocketClient, message);
        }
        if (isTrue(isEqual(e, "ORDER_TRADE_UPDATE")))
        {
            this.handleOrder(client as WebSocketClient, message);
            object data = this.safeValue(message, "o", new Dictionary<string, object>() {});
            object type = this.safeString(data, "x");
            object status = this.safeString(data, "X");
            if (isTrue(isTrue((isEqual(type, "TRADE"))) && isTrue((isEqual(status, "FILLED")))))
            {
                this.handleMyTrades(client as WebSocketClient, message);
            }
        }
        object msgData = this.safeValue(message, "data");
        object msgEvent = this.safeString(msgData, "e");
        if (isTrue(isEqual(msgEvent, "24hTicker")))
        {
            this.handleTicker(client as WebSocketClient, message);
        }
    }
}
