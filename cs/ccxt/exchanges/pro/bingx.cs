namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class bingx { public bingx(object args = null) : base(args) { } }
public partial class bingx : ccxt.bingx
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", false },
                { "watchOrderBook", true },
                { "watchOrderBookForSymbols", true },
                { "watchOHLCV", true },
                { "watchOHLCVForSymbols", true },
                { "watchOrders", true },
                { "watchMyTrades", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchBalance", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "spot", "wss://open-api-ws.bingx.com/market" },
                        { "linear", "wss://open-api-swap.bingx.com/swap-market" },
                        { "inverse", "wss://open-api-cswap-ws.bingx.com/market" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "listenKeyRefreshRate", 3540000 },
                { "ws", new Dictionary<string, object>() {
                    { "gunzip", true },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "timeframes", new Dictionary<string, object>() {
                        { "1m", "1m" },
                        { "3m", "3m" },
                        { "5m", "5m" },
                        { "15m", "15m" },
                        { "30m", "30m" },
                        { "1h", "1h" },
                        { "2h", "2h" },
                        { "4h", "4h" },
                        { "6h", "6h" },
                        { "12h", "12h" },
                        { "1d", "1d" },
                        { "3d", "3d" },
                        { "1w", "1w" },
                        { "1M", "1M" },
                    } },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "timeframes", new Dictionary<string, object>() {
                        { "1m", "1min" },
                        { "5m", "5min" },
                        { "15m", "15min" },
                        { "30m", "30min" },
                        { "1h", "60min" },
                        { "1d", "1day" },
                    } },
                } },
                { "watchBalance", new Dictionary<string, object>() {
                    { "fetchBalanceSnapshot", true },
                    { "awaitBalanceSnapshot", false },
                } },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "depth", 100 },
                    { "interval", 500 },
                } },
                { "watchOrderBookForSymbols", new Dictionary<string, object>() {
                    { "depth", 100 },
                    { "interval", 500 },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "keepAlive", 1800000 },
            } },
        });
    }

    /**
     * @method
     * @name bingx#watchTicker
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://bingx-api.github.io/docs/#/en-us/spot/socket/market.html#Subscribe%20to%2024-hour%20Price%20Change
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/market.html#Subscribe%20to%2024-hour%20price%20changes
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/socket/market.html#Subscribe%20to%2024-Hour%20Price%20Change
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketType = null;
        object subType = null;
        object url = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("watchTicker", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchTicker", market, parameters, "linear");
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "swap")))
        {
            url = this.safeString(getValue(getValue(this.urls, "api"), "ws"), subType);
        } else
        {
            url = this.safeString(getValue(getValue(this.urls, "api"), "ws"), marketType);
        }
        object subscriptionHash = add(getValue(market, "id"), "@ticker");
        object messageHash = this.getMessageHash("ticker", getValue(market, "symbol"));
        object uuid = this.uuid();
        object request = new Dictionary<string, object>() {
            { "id", uuid },
            { "dataType", subscriptionHash },
        };
        if (isTrue(isEqual(marketType, "swap")))
        {
            ((IDictionary<string,object>)request)["reqType"] = "sub";
        }
        return await this.watch(url, messageHash, this.extend(request, parameters), subscriptionHash);
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "dataType": "BTC-USDT@ticker",
        //         "data": {
        //             "e": "24hTicker",
        //             "E": 1706498923556,
        //             "s": "BTC-USDT",
        //             "p": "346.4",
        //             "P": "0.82",
        //             "c": "42432.5",
        //             "L": "0.0529",
        //             "h": "42855.4",
        //             "l": "41578.3",
        //             "v": "64310.9754",
        //             "q": "2728360284.15",
        //             "o": "42086.1",
        //             "O": 1706498922655,
        //             "C": 1706498883023,
        //             "A": "42437.8",
        //             "a": "1.4160",
        //             "B": "42437.1",
        //             "b": "2.5747"
        //         }
        //     }
        //
        // spot
        //
        //     {
        //         "code": 0,
        //         "timestamp": 1706506795473,
        //         "data": {
        //             "e": "24hTicker",
        //             "E": 1706506795472,
        //             "s": "BTC-USDT",
        //             "p": -372.12,
        //             "P": "-0.87%",
        //             "o": 42548.95,
        //             "h": 42696.1,
        //             "l": 41621.29,
        //             "c": 42176.83,
        //             "v": 4943.33,
        //             "q": 208842236.5,
        //             "O": 1706420395472,
        //             "C": 1706506795472,
        //             "A": 42177.23,
        //             "a": 5.14484,
        //             "B": 42176.38,
        //             "b": 5.36117
        //         }
        //     }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "s");
        // const marketId = messageHash.split('@')[0];
        object isSwap = isGreaterThanOrEqual(getIndexOf(client.url, "swap"), 0);
        object marketType = ((bool) isTrue(isSwap)) ? "swap" : "spot";
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        object ticker = this.parseWsTicker(data, market);
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, this.getMessageHash("ticker", symbol)});
        if (isTrue(isEqual(this.safeString(message, "dataType"), "all@ticker")))
        {
            callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, this.getMessageHash("ticker")});
        }
    }

    public virtual object parseWsTicker(object message, object market = null)
    {
        //
        //     {
        //         "e": "24hTicker",
        //         "E": 1706498923556,
        //         "s": "BTC-USDT",
        //         "p": "346.4",
        //         "P": "0.82",
        //         "c": "42432.5",
        //         "L": "0.0529",
        //         "h": "42855.4",
        //         "l": "41578.3",
        //         "v": "64310.9754",
        //         "q": "2728360284.15",
        //         "o": "42086.1",
        //         "O": 1706498922655,
        //         "C": 1706498883023,
        //         "A": "42437.8",
        //         "a": "1.4160",
        //         "B": "42437.1",
        //         "b": "2.5747"
        //     }
        //
        object timestamp = this.safeInteger(message, "C");
        object marketId = this.safeString(message, "s");
        market = this.safeMarket(marketId, market);
        object close = this.safeString(message, "c");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(message, "h") },
            { "low", this.safeString(message, "l") },
            { "bid", this.safeString(message, "B") },
            { "bidVolume", this.safeString(message, "b") },
            { "ask", this.safeString(message, "A") },
            { "askVolume", this.safeString(message, "a") },
            { "vwap", null },
            { "open", this.safeString(message, "o") },
            { "close", close },
            { "last", close },
            { "previousClose", null },
            { "change", this.safeString(message, "p") },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(message, "v") },
            { "quoteVolume", this.safeString(message, "q") },
            { "info", message },
        }, market);
    }

    /**
     * @method
     * @name bingx#watchTickers
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/market.html#Subscribe%20to%2024-hour%20price%20changes%20of%20all%20trading%20pairs
     * @param {string[]} symbols unified symbol of the market to watch the tickers for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, true, true, false);
        object firstMarket = null;
        object marketType = null;
        object subType = null;
        object symbolsDefined = (!isEqual(symbols, null));
        if (isTrue(symbolsDefined))
        {
            firstMarket = this.market(getValue(symbols, 0));
        }
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("watchTickers", firstMarket, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchTickers", firstMarket, parameters, "linear");
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " watchTickers is not supported for spot markets yet")) ;
        }
        if (isTrue(isEqual(subType, "inverse")))
        {
            throw new NotSupported ((string)add(this.id, " watchTickers is not supported for inverse markets yet")) ;
        }
        object messageHashes = new List<object>() {};
        object subscriptionHashes = new List<object>() {"all@ticker"};
        if (isTrue(symbolsDefined))
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                object market = this.market(symbol);
                ((IList<object>)messageHashes).Add(this.getMessageHash("ticker", getValue(market, "symbol")));
            }
        } else
        {
            ((IList<object>)messageHashes).Add(this.getMessageHash("ticker"));
        }
        object url = this.safeString(getValue(getValue(this.urls, "api"), "ws"), subType);
        object uuid = this.uuid();
        object request = new Dictionary<string, object>() {
            { "id", uuid },
            { "dataType", "all@ticker" },
        };
        if (isTrue(isEqual(marketType, "swap")))
        {
            ((IDictionary<string,object>)request)["reqType"] = "sub";
        }
        object result = await this.watchMultiple(url, messageHashes, this.deepExtend(request, parameters), subscriptionHashes);
        if (isTrue(this.newUpdates))
        {
            object newDict = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)newDict)[(string)getValue(result, "symbol")] = result;
            return newDict;
        }
        return this.tickers;
    }

    /**
     * @method
     * @name bingx#watchOrderBookForSymbols
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/market.html#Subscribe%20Market%20Depth%20Data%20of%20all%20trading%20pairs
     * @param {string[]} symbols unified array of symbols
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        symbols = this.marketSymbols(symbols, null, true, true, false);
        object firstMarket = null;
        object marketType = null;
        object subType = null;
        object symbolsDefined = (!isEqual(symbols, null));
        if (isTrue(symbolsDefined))
        {
            firstMarket = this.market(getValue(symbols, 0));
        }
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("watchOrderBookForSymbols", firstMarket, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchOrderBookForSymbols", firstMarket, parameters, "linear");
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " watchOrderBookForSymbols is not supported for spot markets yet")) ;
        }
        if (isTrue(isEqual(subType, "inverse")))
        {
            throw new NotSupported ((string)add(this.id, " watchOrderBookForSymbols is not supported for inverse markets yet")) ;
        }
        limit = this.getOrderBookLimitByMarketType(marketType, limit);
        object interval = null;
        var intervalparametersVariable = this.handleOptionAndParams(parameters, "watchOrderBookForSymbols", "interval", 500);
        interval = ((IList<object>)intervalparametersVariable)[0];
        parameters = ((IList<object>)intervalparametersVariable)[1];
        this.checkRequiredArgument("watchOrderBookForSymbols", interval, "interval", new List<object>() {100, 200, 500, 1000});
        object channelName = add(add(add(add("depth", ((object)limit).ToString()), "@"), ((object)interval).ToString()), "ms");
        object subscriptionHash = add("all@", channelName);
        object messageHashes = new List<object>() {};
        if (isTrue(symbolsDefined))
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                object market = this.market(symbol);
                ((IList<object>)messageHashes).Add(this.getMessageHash("orderbook", getValue(market, "symbol")));
            }
        } else
        {
            ((IList<object>)messageHashes).Add(this.getMessageHash("orderbook"));
        }
        object url = this.safeString(getValue(getValue(this.urls, "api"), "ws"), subType);
        object uuid = this.uuid();
        object request = new Dictionary<string, object>() {
            { "id", uuid },
            { "dataType", subscriptionHash },
        };
        if (isTrue(isEqual(marketType, "swap")))
        {
            ((IDictionary<string,object>)request)["reqType"] = "sub";
        }
        object subscriptionArgs = new Dictionary<string, object>() {
            { "symbols", symbols },
            { "limit", limit },
            { "interval", interval },
            { "params", parameters },
        };
        object orderbook = await this.watchMultiple(url, messageHashes, this.deepExtend(request, parameters), new List<object>() {subscriptionHash}, subscriptionArgs);
        return (orderbook as IOrderBook).limit();
    }

    /**
     * @method
     * @name bingx#watchOHLCVForSymbols
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/market.html#Subscribe%20K-Line%20Data%20of%20all%20trading%20pairs
     * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCVForSymbols(object symbolsAndTimeframes, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object symbolsLength = getArrayLength(symbolsAndTimeframes);
        if (isTrue(isTrue(!isEqual(symbolsLength, 0)) && !isTrue(((getValue(symbolsAndTimeframes, 0) is IList<object>) || (getValue(symbolsAndTimeframes, 0).GetType().IsGenericType && getValue(symbolsAndTimeframes, 0).GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchOHLCVForSymbols() requires a an array like  [['BTC/USDT:USDT', '1m'], ['LTC/USDT:USDT', '5m']]")) ;
        }
        await this.loadMarkets();
        object messageHashes = new List<object>() {};
        object marketType = null;
        object subType = null;
        object chosenTimeframe = null;
        object firstMarket = null;
        if (isTrue(!isEqual(symbolsLength, 0)))
        {
            object symbols = this.getListFromObjectValues(symbolsAndTimeframes, 0);
            symbols = this.marketSymbols(symbols, null, true, true, false);
            firstMarket = this.market(getValue(symbols, 0));
        }
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("watchOHLCVForSymbols", firstMarket, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchOHLCVForSymbols", firstMarket, parameters, "linear");
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " watchOHLCVForSymbols is not supported for spot markets yet")) ;
        }
        if (isTrue(isEqual(subType, "inverse")))
        {
            throw new NotSupported ((string)add(this.id, " watchOHLCVForSymbols is not supported for inverse markets yet")) ;
        }
        object marketOptions = this.safeDict(this.options, marketType);
        object timeframes = this.safeDict(marketOptions, "timeframes", new Dictionary<string, object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(symbolsAndTimeframes)); postFixIncrement(ref i))
        {
            object symbolAndTimeframe = getValue(symbolsAndTimeframes, i);
            object sym = getValue(symbolAndTimeframe, 0);
            object tf = getValue(symbolAndTimeframe, 1);
            object market = this.market(sym);
            object rawTimeframe = this.safeString(timeframes, tf, tf);
            if (isTrue(isEqual(chosenTimeframe, null)))
            {
                chosenTimeframe = rawTimeframe;
            } else if (isTrue(!isEqual(chosenTimeframe, rawTimeframe)))
            {
                throw new BadRequest ((string)add(this.id, " watchOHLCVForSymbols requires all timeframes to be the same")) ;
            }
            ((IList<object>)messageHashes).Add(this.getMessageHash("ohlcv", getValue(market, "symbol"), chosenTimeframe));
        }
        object subscriptionHash = add("all@kline_", chosenTimeframe);
        object url = this.safeString(getValue(getValue(this.urls, "api"), "ws"), subType);
        object uuid = this.uuid();
        object request = new Dictionary<string, object>() {
            { "id", uuid },
            { "dataType", subscriptionHash },
        };
        if (isTrue(isEqual(marketType, "swap")))
        {
            ((IDictionary<string,object>)request)["reqType"] = "sub";
        }
        object subscriptionArgs = new Dictionary<string, object>() {
            { "limit", limit },
            { "params", parameters },
        };
        var symboltimeframecandlesVariable = await this.watchMultiple(url, messageHashes, request, new List<object>() {subscriptionHash}, subscriptionArgs);
        var symbol = ((IList<object>) symboltimeframecandlesVariable)[0];
        var timeframe = ((IList<object>) symboltimeframecandlesVariable)[1];
        var candles = ((IList<object>) symboltimeframecandlesVariable)[2];
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(candles, "getLimit", new object[] {symbol, limit});
        }
        object filtered = this.filterBySinceLimit(candles, since, limit, 0, true);
        return this.createOHLCVObject(symbol, timeframe, filtered);
    }

    public virtual object getOrderBookLimitByMarketType(object marketType, object limit = null)
    {
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100;
        } else
        {
            if (isTrue(isTrue(isEqual(marketType, "swap")) || isTrue(isEqual(marketType, "future"))))
            {
                limit = this.findNearestCeiling(new List<object>() {5, 10, 20, 50, 100}, limit);
            } else if (isTrue(isEqual(marketType, "spot")))
            {
                limit = this.findNearestCeiling(new List<object>() {20, 100}, limit);
            }
        }
        return limit;
    }

    public virtual object getMessageHash(object unifiedChannel, object symbol = null, object extra = null)
    {
        object hash = unifiedChannel;
        if (isTrue(!isEqual(symbol, null)))
        {
            hash = add(hash, add("::", symbol));
        } else
        {
            hash = add(hash, "s"); // tickers, orderbooks, ohlcvs ...
        }
        if (isTrue(!isEqual(extra, null)))
        {
            hash = add(hash, add("::", extra));
        }
        return hash;
    }

    /**
     * @method
     * @name bingx#watchTrades
     * @description watches information on multiple trades made in a market
     * @see https://bingx-api.github.io/docs/#/spot/socket/market.html#Subscribe%20to%20tick-by-tick
     * @see https://bingx-api.github.io/docs/#/swapV2/socket/market.html#Subscribe%20the%20Latest%20Trade%20Detail
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/socket/market.html#Subscription%20transaction%20by%20transaction
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object marketType = null;
        object subType = null;
        object url = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("watchTrades", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchTrades", market, parameters, "linear");
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "swap")))
        {
            url = this.safeString(getValue(getValue(this.urls, "api"), "ws"), subType);
        } else
        {
            url = this.safeString(getValue(getValue(this.urls, "api"), "ws"), marketType);
        }
        object rawHash = add(getValue(market, "id"), "@trade");
        object messageHash = add("trade::", symbol);
        object uuid = this.uuid();
        object request = new Dictionary<string, object>() {
            { "id", uuid },
            { "dataType", rawHash },
        };
        if (isTrue(isEqual(marketType, "swap")))
        {
            ((IDictionary<string,object>)request)["reqType"] = "sub";
        }
        object trades = await this.watch(url, messageHash, this.extend(request, parameters), messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        // spot: first snapshot
        //
        //    {
        //      "id": "d83b78ce-98be-4dc2-b847-12fe471b5bc5",
        //      "code": 0,
        //      "msg": "SUCCESS",
        //      "timestamp": 1690214699854
        //    }
        //
        // spot: subsequent updates
        //
        //     {
        //         "code": 0,
        //         "data": {
        //           "E": 1690214529432,
        //           "T": 1690214529386,
        //           "e": "trade",
        //           "m": true,
        //           "p": "29110.19",
        //           "q": "0.1868",
        //           "s": "BTC-USDT",
        //           "t": "57903921"
        //         },
        //         "dataType": "BTC-USDT@trade",
        //         "success": true
        //     }
        //
        // linear swap: first snapshot
        //
        //    {
        //        "id": "2aed93b1-6e1e-4038-aeba-f5eeaec2ca48",
        //        "code": 0,
        //        "msg": '',
        //        "dataType": '',
        //        "data": null
        //    }
        //
        // linear swap: subsequent updates
        //
        //    {
        //        "code": 0,
        //        "dataType": "BTC-USDT@trade",
        //        "data": [
        //            {
        //                "q": "0.0421",
        //                "p": "29023.5",
        //                "T": 1690221401344,
        //                "m": false,
        //                "s": "BTC-USDT"
        //            },
        //            ...
        //        ]
        //    }
        //
        // inverse swap: first snapshot
        //
        //     {
        //         "code": 0,
        //         "id": "a2e482ca-f71b-42f8-a83a-8ff85a713e64",
        //         "msg": "SUCCESS",
        //         "timestamp": 1722920589426
        //     }
        //
        // inverse swap: subsequent updates
        //
        //     {
        //         "code": 0,
        //         "dataType": "BTC-USD@trade",
        //         "data": {
        //             "e": "trade",
        //             "E": 1722920589665,
        //             "s": "BTC-USD",
        //             "t": "39125001",
        //             "p": "55360.0",
        //             "q": "1",
        //             "T": 1722920589582,
        //             "m": false
        //         }
        //     }
        //
        object data = this.safeValue(message, "data", new List<object>() {});
        object rawHash = this.safeString(message, "dataType");
        object marketId = getValue(((string)rawHash).Split(new [] {((string)"@")}, StringSplitOptions.None).ToList<object>(), 0);
        object isSwap = isGreaterThanOrEqual(getIndexOf(client.url, "swap"), 0);
        object marketType = ((bool) isTrue(isSwap)) ? "swap" : "spot";
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        object messageHash = add("trade::", symbol);
        object trades = null;
        if (isTrue(((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            trades = this.parseTrades(data, market);
        } else
        {
            trades = new List<object> {this.parseTrade(data, market)};
        }
        object stored = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        for (object j = 0; isLessThan(j, getArrayLength(trades)); postFixIncrement(ref j))
        {
            callDynamically(stored, "append", new object[] {getValue(trades, j)});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    /**
     * @method
     * @name bingx#watchOrderBook
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://bingx-api.github.io/docs/#/en-us/spot/socket/market.html#Subscribe%20Market%20Depth%20Data
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/market.html#Subscribe%20Market%20Depth%20Data
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/socket/market.html#Subscribe%20to%20Limited%20Depth
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketType = null;
        object subType = null;
        object url = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("watchOrderBook", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchOrderBook", market, parameters, "linear");
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "swap")))
        {
            url = this.safeString(getValue(getValue(this.urls, "api"), "ws"), subType);
        } else
        {
            url = this.safeString(getValue(getValue(this.urls, "api"), "ws"), marketType);
        }
        limit = this.getOrderBookLimitByMarketType(marketType, limit);
        object channelName = add("depth", ((object)limit).ToString());
        object interval = null;
        if (isTrue(!isEqual(marketType, "spot")))
        {
            if (!isTrue(getValue(market, "inverse")))
            {
                var intervalparametersVariable = this.handleOptionAndParams(parameters, "watchOrderBook", "interval", 500);
                interval = ((IList<object>)intervalparametersVariable)[0];
                parameters = ((IList<object>)intervalparametersVariable)[1];
                this.checkRequiredArgument("watchOrderBook", interval, "interval", new List<object>() {100, 200, 500, 1000});
                channelName = add(add(add(channelName, "@"), ((object)interval).ToString()), "ms");
            }
        }
        object subscriptionHash = add(add(getValue(market, "id"), "@"), channelName);
        object messageHash = this.getMessageHash("orderbook", getValue(market, "symbol"));
        object uuid = this.uuid();
        object request = new Dictionary<string, object>() {
            { "id", uuid },
            { "dataType", subscriptionHash },
        };
        if (isTrue(isEqual(marketType, "swap")))
        {
            ((IDictionary<string,object>)request)["reqType"] = "sub";
        }
        object subscriptionArgs = new Dictionary<string, object>() {};
        if (isTrue(getValue(market, "inverse")))
        {
            subscriptionArgs = new Dictionary<string, object>() {
                { "count", limit },
                { "params", parameters },
            };
        } else
        {
            subscriptionArgs = new Dictionary<string, object>() {
                { "level", limit },
                { "interval", interval },
                { "params", parameters },
            };
        }
        object orderbook = await this.watch(url, messageHash, this.deepExtend(request, parameters), subscriptionHash, subscriptionArgs);
        return (orderbook as IOrderBook).limit();
    }

    public override void handleDelta(object bookside, object delta)
    {
        object price = this.safeFloat2(delta, 0, "p");
        object amount = this.safeFloat2(delta, 1, "a");
        (bookside as IOrderBookSide).store(price, amount);
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //    {
        //        "code": 0,
        //        "dataType": "BTC-USDT@depth20",
        //        "data": {
        //          "bids": [
        //            [ '28852.9', "34.2621" ],
        //            ...
        //          ],
        //          "asks": [
        //            [ '28864.9', "23.4079" ],
        //            ...
        //          ]
        //        },
        //        "dataType": "BTC-USDT@depth20",
        //        "success": true
        //    }
        //
        // linear swap
        //
        //    {
        //        "code": 0,
        //        "dataType": "BTC-USDT@depth20@100ms", //or "all@depth20@100ms"
        //        "data": {
        //          "bids": [
        //            [ '28852.9', "34.2621" ],
        //            ...
        //          ],
        //          "asks": [
        //            [ '28864.9', "23.4079" ],
        //            ...
        //          ],
        //          "symbol": "BTC-USDT", // this key exists only in "all" subscription
        //        }
        //    }
        //
        // inverse swap
        //
        //     {
        //         "code": 0,
        //         "dataType": "BTC-USD@depth100",
        //         "data": {
        //             {
        //                 "symbol": "BTC-USD",
        //                 "bids": [
        //                     { "p": "58074.2", "a": "1.422318", "v": "826.0" },
        //                     ...
        //                 ],
        //                 "asks": [
        //                     { "p": "62878.0", "a": "0.001590", "v": "1.0" },
        //                     ...
        //                 ],
        //                 "aggPrecision": "0.1",
        //                 "timestamp": 1723705093529
        //             }
        //         }
        //     }
        //
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object dataType = this.safeString(message, "dataType");
        object parts = ((string)dataType).Split(new [] {((string)"@")}, StringSplitOptions.None).ToList<object>();
        object firstPart = getValue(parts, 0);
        object isAllEndpoint = (isEqual(firstPart, "all"));
        object marketId = this.safeString(data, "symbol", firstPart);
        object isSwap = isGreaterThanOrEqual(getIndexOf(client.url, "swap"), 0);
        object marketType = ((bool) isTrue(isSwap)) ? "swap" : "spot";
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        if (isTrue(isEqual(this.safeValue(this.orderbooks, symbol), null)))
        {
            // const limit = [ 5, 10, 20, 50, 100 ]
            object subscriptionHash = dataType;
            object subscription = getValue(((WebSocketClient)client).subscriptions, subscriptionHash);
            object limit = this.safeInteger(subscription, "limit");
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
        }
        object orderbook = getValue(this.orderbooks, symbol);
        object snapshot = null;
        if (isTrue(getValue(market, "inverse")))
        {
            snapshot = this.parseOrderBook(data, symbol, null, "bids", "asks", "p", "a");
        } else
        {
            snapshot = this.parseOrderBook(data, symbol, null, "bids", "asks", 0, 1);
        }
        (orderbook as IOrderBook).reset(snapshot);
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
        object messageHash = this.getMessageHash("orderbook", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
        // resolve for "all"
        if (isTrue(isAllEndpoint))
        {
            object messageHashForAll = this.getMessageHash("orderbook");
            callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHashForAll});
        }
    }

    public override object parseWsOHLCV(object ohlcv, object market = null)
    {
        //
        //    {
        //        "c": "28909.0",
        //        "o": "28915.4",
        //        "h": "28915.4",
        //        "l": "28896.1",
        //        "v": "27.6919",
        //        "T": 1696687499999,
        //        "t": 1696687440000
        //    }
        //
        // for spot, opening-time (t) is used instead of closing-time (T), to be compatible with fetchOHLCV
        // for linear swap, (T) is the opening time
        object timestamp = ((bool) isTrue((getValue(market, "spot")))) ? "t" : "T";
        if (isTrue(getValue(market, "swap")))
        {
            timestamp = ((bool) isTrue((getValue(market, "inverse")))) ? "t" : "T";
        }
        return new List<object> {this.safeInteger(ohlcv, timestamp), this.safeNumber(ohlcv, "o"), this.safeNumber(ohlcv, "h"), this.safeNumber(ohlcv, "l"), this.safeNumber(ohlcv, "c"), this.safeNumber(ohlcv, "v")};
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        // spot:
        //
        //   {
        //       "code": 0,
        //       "data": {
        //         "E": 1696687498608,
        //         "K": {
        //           "T": 1696687499999,
        //           "c": "27917.829",
        //           "h": "27918.427",
        //           "i": "1min",
        //           "l": "27917.7",
        //           "n": 262,
        //           "o": "27917.91",
        //           "q": "25715.359197",
        //           "s": "BTC-USDT",
        //           "t": 1696687440000,
        //           "v": "0.921100"
        //         },
        //         "e": "kline",
        //         "s": "BTC-USDT"
        //       },
        //       "dataType": "BTC-USDT@kline_1min",
        //       "success": true
        //   }
        //
        // linear swap:
        //
        //    {
        //        "code": 0,
        //        "dataType": "BTC-USDT@kline_1m",
        //        "s": "BTC-USDT",
        //        "data": [
        //            {
        //            "c": "28909.0",
        //            "o": "28915.4",
        //            "h": "28915.4",
        //            "l": "28896.1",
        //            "v": "27.6919",
        //            "T": 1690907580000
        //            }
        //        ]
        //    }
        //
        // inverse swap:
        //
        //     {
        //         "code": 0,
        //         "timestamp": 1723769354547,
        //         "dataType": "BTC-USD@kline_1m",
        //         "data": {
        //             "t": 1723769340000,
        //             "o": 57485.1,
        //             "c": 57468,
        //             "l": 57464.9,
        //             "h": 57485.1,
        //             "a": 0.189663,
        //             "v": 109,
        //             "u": 92,
        //             "s": "BTC-USD"
        //         }
        //     }
        //
        object isSwap = isGreaterThanOrEqual(getIndexOf(client.url, "swap"), 0);
        object dataType = this.safeString(message, "dataType");
        object parts = ((string)dataType).Split(new [] {((string)"@")}, StringSplitOptions.None).ToList<object>();
        object firstPart = getValue(parts, 0);
        object isAllEndpoint = (isEqual(firstPart, "all"));
        object marketId = this.safeString(message, "s", firstPart);
        object marketType = ((bool) isTrue(isSwap)) ? "swap" : "spot";
        object market = this.safeMarket(marketId, null, null, marketType);
        object candles = null;
        if (isTrue(isSwap))
        {
            if (isTrue(getValue(market, "inverse")))
            {
                candles = new List<object> {this.safeDict(message, "data", new Dictionary<string, object>() {})};
            } else
            {
                candles = this.safeList(message, "data", new List<object>() {});
            }
        } else
        {
            object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
            candles = new List<object> {this.safeDict(data, "K", new Dictionary<string, object>() {})};
        }
        object symbol = getValue(market, "symbol");
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        object rawTimeframe = getValue(((string)dataType).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>(), 1);
        object marketOptions = this.safeDict(this.options, marketType);
        object timeframes = this.safeDict(marketOptions, "timeframes", new Dictionary<string, object>() {});
        object unifiedTimeframe = this.findTimeframe(rawTimeframe, timeframes);
        if (isTrue(isEqual(this.safeValue(getValue(this.ohlcvs, symbol), rawTimeframe), null)))
        {
            object subscriptionHash = dataType;
            object subscription = getValue(((WebSocketClient)client).subscriptions, subscriptionHash);
            object limit = this.safeInteger(subscription, "limit");
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)unifiedTimeframe] = new ArrayCacheByTimestamp(limit);
        }
        object stored = getValue(getValue(this.ohlcvs, symbol), unifiedTimeframe);
        for (object i = 0; isLessThan(i, getArrayLength(candles)); postFixIncrement(ref i))
        {
            object candle = getValue(candles, i);
            object parsed = this.parseWsOHLCV(candle, market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        object resolveData = new List<object>() {symbol, unifiedTimeframe, stored};
        object messageHash = this.getMessageHash("ohlcv", symbol, unifiedTimeframe);
        callDynamically(client as WebSocketClient, "resolve", new object[] {resolveData, messageHash});
        // resolve for "all"
        if (isTrue(isAllEndpoint))
        {
            object messageHashForAll = this.getMessageHash("ohlcv", null, unifiedTimeframe);
            callDynamically(client as WebSocketClient, "resolve", new object[] {resolveData, messageHashForAll});
        }
    }

    /**
     * @method
     * @name bingx#watchOHLCV
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://bingx-api.github.io/docs/#/en-us/spot/socket/market.html#K-line%20Streams
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/market.html#Subscribe%20K-Line%20Data
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/socket/market.html#Subscribe%20to%20Latest%20Trading%20Pair%20K-Line
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketType = null;
        object subType = null;
        object url = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("watchOHLCV", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchOHLCV", market, parameters, "linear");
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "swap")))
        {
            url = this.safeString(getValue(getValue(this.urls, "api"), "ws"), subType);
        } else
        {
            url = this.safeString(getValue(getValue(this.urls, "api"), "ws"), marketType);
        }
        if (isTrue(isEqual(url, null)))
        {
            throw new BadRequest ((string)add(add(add(this.id, " watchOHLCV is not supported for "), marketType), " markets.")) ;
        }
        object options = this.safeValue(this.options, marketType, new Dictionary<string, object>() {});
        object timeframes = this.safeValue(options, "timeframes", new Dictionary<string, object>() {});
        object rawTimeframe = this.safeString(timeframes, timeframe, timeframe);
        object messageHash = this.getMessageHash("ohlcv", getValue(market, "symbol"), timeframe);
        object subscriptionHash = add(add(getValue(market, "id"), "@kline_"), rawTimeframe);
        object uuid = this.uuid();
        object request = new Dictionary<string, object>() {
            { "id", uuid },
            { "dataType", subscriptionHash },
        };
        if (isTrue(isEqual(marketType, "swap")))
        {
            ((IDictionary<string,object>)request)["reqType"] = "sub";
        }
        object subscriptionArgs = new Dictionary<string, object>() {
            { "interval", rawTimeframe },
            { "params", parameters },
        };
        object result = await this.watch(url, messageHash, this.extend(request, parameters), subscriptionHash, subscriptionArgs);
        object ohlcv = getValue(result, 2);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    /**
     * @method
     * @name bingx#watchOrders
     * @description watches information on multiple orders made by the user
     * @see https://bingx-api.github.io/docs/#/en-us/spot/socket/account.html#Subscription%20order%20update%20data
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/account.html#Order%20update%20push
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/socket/account.html#Order%20update%20push
     * @param {string} [symbol] unified market symbol of the market orders are made in
     * @param {int} [since] the earliest time in ms to watch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object type = null;
        object subType = null;
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        var typeparametersVariable = this.handleMarketTypeAndParams("watchOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchOrders", market, parameters, "linear");
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object isSpot = (isEqual(type, "spot"));
        object spotHash = "spot:private";
        object swapHash = "swap:private";
        object subscriptionHash = ((bool) isTrue(isSpot)) ? spotHash : swapHash;
        object spotMessageHash = "spot:order";
        object swapMessageHash = "swap:order";
        object messageHash = ((bool) isTrue(isSpot)) ? spotMessageHash : swapMessageHash;
        if (isTrue(!isEqual(market, null)))
        {
            messageHash = add(messageHash, add(":", symbol));
        }
        object uuid = this.uuid();
        object baseUrl = null;
        object request = null;
        if (isTrue(isEqual(type, "swap")))
        {
            if (isTrue(isEqual(subType, "inverse")))
            {
                throw new NotSupported ((string)add(this.id, " watchOrders is not supported for inverse swap markets yet")) ;
            }
            baseUrl = this.safeString(getValue(getValue(this.urls, "api"), "ws"), subType);
        } else
        {
            baseUrl = this.safeString(getValue(getValue(this.urls, "api"), "ws"), type);
            request = new Dictionary<string, object>() {
                { "id", uuid },
                { "reqType", "sub" },
                { "dataType", "spot.executionReport" },
            };
        }
        object url = add(add(baseUrl, "?listenKey="), getValue(this.options, "listenKey"));
        object orders = await this.watch(url, messageHash, request, subscriptionHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    /**
     * @method
     * @name bingx#watchMyTrades
     * @description watches information on multiple trades made by the user
     * @see https://bingx-api.github.io/docs/#/en-us/spot/socket/account.html#Subscription%20order%20update%20data
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/account.html#Order%20update%20push
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/socket/account.html#Order%20update%20push
     * @param {string} [symbol] unified market symbol of the market the trades are made in
     * @param {int} [since] the earliest time in ms to watch trades for
     * @param {int} [limit] the maximum number of trade structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object type = null;
        object subType = null;
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        var typeparametersVariable = this.handleMarketTypeAndParams("watchMyTrades", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchMyTrades", market, parameters, "linear");
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object isSpot = (isEqual(type, "spot"));
        object spotHash = "spot:private";
        object swapHash = "swap:private";
        object subscriptionHash = ((bool) isTrue(isSpot)) ? spotHash : swapHash;
        object spotMessageHash = "spot:mytrades";
        object swapMessageHash = "swap:mytrades";
        object messageHash = ((bool) isTrue(isSpot)) ? spotMessageHash : swapMessageHash;
        if (isTrue(!isEqual(market, null)))
        {
            messageHash = add(messageHash, add(":", symbol));
        }
        object uuid = this.uuid();
        object baseUrl = null;
        object request = null;
        if (isTrue(isEqual(type, "swap")))
        {
            if (isTrue(isEqual(subType, "inverse")))
            {
                throw new NotSupported ((string)add(this.id, " watchMyTrades is not supported for inverse swap markets yet")) ;
            }
            baseUrl = this.safeString(getValue(getValue(this.urls, "api"), "ws"), subType);
        } else
        {
            baseUrl = this.safeString(getValue(getValue(this.urls, "api"), "ws"), type);
            request = new Dictionary<string, object>() {
                { "id", uuid },
                { "reqType", "sub" },
                { "dataType", "spot.executionReport" },
            };
        }
        object url = add(add(baseUrl, "?listenKey="), getValue(this.options, "listenKey"));
        object trades = await this.watch(url, messageHash, request, subscriptionHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    /**
     * @method
     * @name bingx#watchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://bingx-api.github.io/docs/#/en-us/spot/socket/account.html#Subscription%20account%20balance%20push
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/account.html#Account%20balance%20and%20position%20update%20push
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/socket/account.html#Account%20balance%20and%20position%20update%20push
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object type = null;
        object subType = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchBalance", null, parameters, "linear");
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object isSpot = (isEqual(type, "spot"));
        object spotSubHash = "spot:balance";
        object swapSubHash = "swap:private";
        object spotMessageHash = "spot:balance";
        object swapMessageHash = "swap:balance";
        object messageHash = ((bool) isTrue(isSpot)) ? spotMessageHash : swapMessageHash;
        object subscriptionHash = ((bool) isTrue(isSpot)) ? spotSubHash : swapSubHash;
        object request = null;
        object baseUrl = null;
        object uuid = this.uuid();
        if (isTrue(isEqual(type, "swap")))
        {
            if (isTrue(isEqual(subType, "inverse")))
            {
                throw new NotSupported ((string)add(this.id, " watchBalance is not supported for inverse swap markets yet")) ;
            }
            baseUrl = this.safeString(getValue(getValue(this.urls, "api"), "ws"), subType);
        } else
        {
            baseUrl = this.safeString(getValue(getValue(this.urls, "api"), "ws"), type);
            request = new Dictionary<string, object>() {
                { "id", uuid },
                { "dataType", "ACCOUNT_UPDATE" },
            };
        }
        object url = add(add(baseUrl, "?listenKey="), getValue(this.options, "listenKey"));
        var client = this.client(url);
        this.setBalanceCache(client as WebSocketClient, type, subType, subscriptionHash, parameters);
        object fetchBalanceSnapshot = null;
        object awaitBalanceSnapshot = null;
        var fetchBalanceSnapshotparametersVariable = this.handleOptionAndParams(parameters, "watchBalance", "fetchBalanceSnapshot", true);
        fetchBalanceSnapshot = ((IList<object>)fetchBalanceSnapshotparametersVariable)[0];
        parameters = ((IList<object>)fetchBalanceSnapshotparametersVariable)[1];
        var awaitBalanceSnapshotparametersVariable = this.handleOptionAndParams(parameters, "watchBalance", "awaitBalanceSnapshot", false);
        awaitBalanceSnapshot = ((IList<object>)awaitBalanceSnapshotparametersVariable)[0];
        parameters = ((IList<object>)awaitBalanceSnapshotparametersVariable)[1];
        if (isTrue(isTrue(fetchBalanceSnapshot) && isTrue(awaitBalanceSnapshot)))
        {
            await client.future(add(type, ":fetchBalanceSnapshot"));
        }
        return await this.watch(url, messageHash, request, subscriptionHash);
    }

    public virtual void setBalanceCache(WebSocketClient client, object type, object subType, object subscriptionHash, object parameters)
    {
        if (isTrue(inOp(((WebSocketClient)client).subscriptions, subscriptionHash)))
        {
            return;
        }
        object fetchBalanceSnapshot = this.handleOptionAndParams(parameters, "watchBalance", "fetchBalanceSnapshot", true);
        if (isTrue(fetchBalanceSnapshot))
        {
            object messageHash = add(type, ":fetchBalanceSnapshot");
            if (!isTrue((inOp(client.futures, messageHash))))
            {
                client.future(messageHash);
                this.spawn(this.loadBalanceSnapshot, new object[] { client, messageHash, type, subType});
            }
        } else
        {
            ((IDictionary<string,object>)this.balance)[(string)type] = new Dictionary<string, object>() {};
        }
    }

    public async virtual Task loadBalanceSnapshot(WebSocketClient client, object messageHash, object type, object subType)
    {
        object response = await this.fetchBalance(new Dictionary<string, object>() {
            { "type", type },
            { "subType", subType },
        });
        ((IDictionary<string,object>)this.balance)[(string)type] = this.extend(response, this.safeValue(this.balance, type, new Dictionary<string, object>() {}));
        // don't remove the future from the .futures cache
        var future = getValue(client.futures, messageHash);
        (future as Future).resolve();
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, type), add(type, ":balance")});
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        //
        // { code: 100400, msg: '', timestamp: 1696245808833 }
        //
        // {
        //     "code": 100500,
        //     "id": "9cd37d32-da98-440b-bd04-37e7dbcf51ad",
        //     "msg": '',
        //     "timestamp": 1696245842307
        // }
        object code = this.safeString(message, "code");
        try
        {
            if (isTrue(!isEqual(code, null)))
            {
                object feedback = add(add(this.id, " "), this.json(message));
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            }
        } catch(Exception e)
        {
            ((WebSocketClient)client).reject(e);
        }
        return true;
    }

    public async virtual Task keepAliveListenKey(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object listenKey = this.safeString(this.options, "listenKey");
        if (isTrue(isEqual(listenKey, null)))
        {
            // A network error happened: we can't renew a listen key that does not exist.
            return;
        }
        try
        {
            await this.userAuthPrivatePutUserDataStream(new Dictionary<string, object>() {
                { "listenKey", listenKey },
            }); // extend the expiry
        } catch(Exception error)
        {
            object types = new List<object>() {"spot", "linear", "inverse"};
            for (object i = 0; isLessThan(i, getArrayLength(types)); postFixIncrement(ref i))
            {
                object type = getValue(types, i);
                object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "?listenKey="), listenKey);
                var client = this.client(url);
                object messageHashes = new List<object>(((IDictionary<string, ccxt.Exchange.Future>)client.futures).Keys);
                for (object j = 0; isLessThan(j, getArrayLength(messageHashes)); postFixIncrement(ref j))
                {
                    object messageHash = getValue(messageHashes, j);
                    ((WebSocketClient)client).reject(error, messageHash);
                }
            }
            ((IDictionary<string,object>)this.options)["listenKey"] = null;
            ((IDictionary<string,object>)this.options)["lastAuthenticatedTime"] = 0;
            return;
        }
        // whether or not to schedule another listenKey keepAlive request
        object listenKeyRefreshRate = this.safeInteger(this.options, "listenKeyRefreshRate", 3600000);
        this.delay(listenKeyRefreshRate,  this.keepAliveListenKey, new object[] { parameters});
    }

    public async virtual Task authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object time = this.milliseconds();
        object lastAuthenticatedTime = this.safeInteger(this.options, "lastAuthenticatedTime", 0);
        object listenKeyRefreshRate = this.safeInteger(this.options, "listenKeyRefreshRate", 3600000); // 1 hour
        if (isTrue(isGreaterThan(subtract(time, lastAuthenticatedTime), listenKeyRefreshRate)))
        {
            object response = await this.userAuthPrivatePostUserDataStream();
            ((IDictionary<string,object>)this.options)["listenKey"] = this.safeString(response, "listenKey");
            ((IDictionary<string,object>)this.options)["lastAuthenticatedTime"] = time;
            this.delay(listenKeyRefreshRate,  this.keepAliveListenKey, new object[] { parameters});
        }
    }

    public async virtual Task pong(WebSocketClient client, object message)
    {
        try
        {
            if (isTrue(isEqual(message, "Ping")))
            {
                await client.send("Pong");
            } else
            {
                object ping = this.safeString(message, "ping");
                object time = this.safeString(message, "time");
                await client.send(new Dictionary<string, object>() {
                    { "pong", ping },
                    { "time", time },
                });
            }
        } catch(Exception e)
        {
            var error = new NetworkError(add(add(this.id, " pong failed with error "), this.json(e)));
            ((WebSocketClient)client).reset(error);
        }
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        //
        //     {
        //         "code": 0,
        //         "dataType": "spot.executionReport",
        //         "data": {
        //            "e": "executionReport",
        //            "E": 1694680212947,
        //            "s": "LTC-USDT",
        //            "S": "BUY",
        //            "o": "LIMIT",
        //            "q": 0.1,
        //            "p": 50,
        //            "x": "NEW",
        //            "X": "PENDING",
        //            "i": 1702238305204043800,
        //            "l": 0,
        //            "z": 0,
        //            "L": 0,
        //            "n": 0,
        //            "N": "",
        //            "T": 0,
        //            "t": 0,
        //            "O": 1694680212676,
        //            "Z": 0,
        //            "Y": 0,
        //            "Q": 0,
        //            "m": false
        //         }
        //      }
        //
        //      {
        //         "code": 0,
        //         "dataType": "spot.executionReport",
        //         "data": {
        //           "e": "executionReport",
        //           "E": 1694681809302,
        //           "s": "LTC-USDT",
        //           "S": "BUY",
        //           "o": "MARKET",
        //           "q": 0,
        //           "p": 62.29,
        //           "x": "TRADE",
        //           "X": "FILLED",
        //           "i": "1702245001712369664",
        //           "l": 0.0802,
        //           "z": 0.0802,
        //           "L": 62.308,
        //           "n": -0.0000802,
        //           "N": "LTC",
        //           "T": 1694681809256,
        //           "t": 38259147,
        //           "O": 1694681809248,
        //           "Z": 4.9971016,
        //           "Y": 4.9971016,
        //           "Q": 5,
        //           "m": false
        //         }
        //       }
        // swap
        //    {
        //        "e": "ORDER_TRADE_UPDATE",
        //        "E": 1696843635475,
        //        "o": {
        //           "s": "LTC-USDT",
        //           "c": "",
        //           "i": "1711312357852147712",
        //           "S": "BUY",
        //           "o": "MARKET",
        //           "q": "0.10000000",
        //           "p": "64.35010000",
        //           "ap": "64.36000000",
        //           "x": "TRADE",
        //           "X": "FILLED",
        //           "N": "USDT",
        //           "n": "-0.00321800",
        //           "T": 0,
        //           "wt": "MARK_PRICE",
        //           "ps": "LONG",
        //           "rp": "0.00000000",
        //           "z": "0.10000000"
        //        }
        //    }
        //
        object isSpot = (inOp(message, "dataType"));
        object data = this.safeValue2(message, "data", "o", new Dictionary<string, object>() {});
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object stored = this.orders;
        object parsedOrder = this.parseOrder(data);
        callDynamically(stored, "append", new object[] {parsedOrder});
        object symbol = getValue(parsedOrder, "symbol");
        object spotHash = "spot:order";
        object swapHash = "swap:order";
        object messageHash = ((bool) isTrue((isSpot))) ? spotHash : swapHash;
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, add(add(messageHash, ":"), symbol)});
    }

    public virtual void handleMyTrades(WebSocketClient client, object message)
    {
        //
        //
        //      {
        //         "code": 0,
        //         "dataType": "spot.executionReport",
        //         "data": {
        //           "e": "executionReport",
        //           "E": 1694681809302,
        //           "s": "LTC-USDT",
        //           "S": "BUY",
        //           "o": "MARKET",
        //           "q": 0,
        //           "p": 62.29,
        //           "x": "TRADE",
        //           "X": "FILLED",
        //           "i": "1702245001712369664",
        //           "l": 0.0802,
        //           "z": 0.0802,
        //           "L": 62.308,
        //           "n": -0.0000802,
        //           "N": "LTC",
        //           "T": 1694681809256,
        //           "t": 38259147,
        //           "O": 1694681809248,
        //           "Z": 4.9971016,
        //           "Y": 4.9971016,
        //           "Q": 5,
        //           "m": false
        //         }
        //       }
        //
        //  swap
        //    {
        //        "e": "ORDER_TRADE_UPDATE",
        //        "E": 1696843635475,
        //        "o": {
        //           "s": "LTC-USDT",
        //           "c": "",
        //           "i": "1711312357852147712",
        //           "S": "BUY",
        //           "o": "MARKET",
        //           "q": "0.10000000",
        //           "p": "64.35010000",
        //           "ap": "64.36000000",
        //           "x": "TRADE",
        //           "X": "FILLED",
        //           "N": "USDT",
        //           "n": "-0.00321800",
        //           "T": 0,
        //           "wt": "MARK_PRICE",
        //           "ps": "LONG",
        //           "rp": "0.00000000",
        //           "z": "0.10000000"
        //        }
        //    }
        //
        object isSpot = (inOp(message, "dataType"));
        object result = this.safeDict2(message, "data", "o", new Dictionary<string, object>() {});
        object cachedTrades = this.myTrades;
        if (isTrue(isEqual(cachedTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            cachedTrades = new ArrayCacheBySymbolById(limit);
            this.myTrades = cachedTrades;
        }
        object type = ((bool) isTrue(isSpot)) ? "spot" : "swap";
        object marketId = this.safeString(result, "s");
        object market = this.safeMarket(marketId, null, "-", type);
        object parsed = this.parseTrade(result, market);
        object symbol = getValue(parsed, "symbol");
        object spotHash = "spot:mytrades";
        object swapHash = "swap:mytrades";
        object messageHash = ((bool) isTrue(isSpot)) ? spotHash : swapHash;
        callDynamically(cachedTrades, "append", new object[] {parsed});
        callDynamically(client as WebSocketClient, "resolve", new object[] {cachedTrades, messageHash});
        callDynamically(client as WebSocketClient, "resolve", new object[] {cachedTrades, add(add(messageHash, ":"), symbol)});
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        // spot
        //     {
        //         "e":"ACCOUNT_UPDATE",
        //         "E":1696242817000,
        //         "T":1696242817142,
        //         "a":{
        //            "B":[
        //               {
        //                  "a":"USDT",
        //                  "bc":"-1.00000000000000000000",
        //                  "cw":"86.59497382000000050000",
        //                  "wb":"86.59497382000000050000"
        //               }
        //            ],
        //            "m":"ASSET_TRANSFER"
        //         }
        //     }
        // swap
        //     {
        //         "e":"ACCOUNT_UPDATE",
        //         "E":1696244249320,
        //         "a":{
        //            "m":"WITHDRAW",
        //            "B":[
        //               {
        //                  "a":"USDT",
        //                  "wb":"49.81083984",
        //                  "cw":"49.81083984",
        //                  "bc":"-1.00000000"
        //               }
        //            ],
        //            "P":[
        //            ]
        //         }
        //     }
        //
        object a = this.safeDict(message, "a", new Dictionary<string, object>() {});
        object data = this.safeList(a, "B", new List<object>() {});
        object timestamp = this.safeInteger2(message, "T", "E");
        object type = ((bool) isTrue((inOp(a, "P")))) ? "swap" : "spot";
        if (!isTrue((inOp(this.balance, type))))
        {
            ((IDictionary<string,object>)this.balance)[(string)type] = new Dictionary<string, object>() {};
        }
        ((IDictionary<string,object>)getValue(this.balance, type))["info"] = data;
        ((IDictionary<string,object>)getValue(this.balance, type))["timestamp"] = timestamp;
        ((IDictionary<string,object>)getValue(this.balance, type))["datetime"] = this.iso8601(timestamp);
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object balance = getValue(data, i);
            object currencyId = this.safeString(balance, "a");
            object code = this.safeCurrencyCode(currencyId);
            object account = ((bool) isTrue((inOp(getValue(this.balance, type), code)))) ? getValue(getValue(this.balance, type), code) : this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "wb");
            object balanceChange = this.safeString(balance, "bc");
            if (isTrue(!isEqual(getValue(account, "used"), null)))
            {
                ((IDictionary<string,object>)account)["used"] = Precise.stringSub(this.safeString(account, "used"), balanceChange);
            }
            ((IDictionary<string,object>)getValue(this.balance, type))[(string)code] = account;
        }
        ((IDictionary<string,object>)this.balance)[(string)type] = this.safeBalance(getValue(this.balance, type));
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, type), add(type, ":balance")});
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (!isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            return;
        }
        // public subscriptions
        if (isTrue(isTrue((isEqual(message, "Ping"))) || isTrue((inOp(message, "ping")))))
        {
            this.spawn(this.pong, new object[] { client, message});
            return;
        }
        object dataType = this.safeString(message, "dataType", "");
        if (isTrue(isGreaterThanOrEqual(getIndexOf(dataType, "@depth"), 0)))
        {
            this.handleOrderBook(client as WebSocketClient, message);
            return;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(dataType, "@ticker"), 0)))
        {
            this.handleTicker(client as WebSocketClient, message);
            return;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(dataType, "@trade"), 0)))
        {
            this.handleTrades(client as WebSocketClient, message);
            return;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(dataType, "@kline"), 0)))
        {
            this.handleOHLCV(client as WebSocketClient, message);
            return;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(dataType, "executionReport"), 0)))
        {
            object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
            object type = this.safeString(data, "x");
            if (isTrue(isEqual(type, "TRADE")))
            {
                this.handleMyTrades(client as WebSocketClient, message);
            }
            this.handleOrder(client as WebSocketClient, message);
            return;
        }
        object e = this.safeString(message, "e");
        if (isTrue(isEqual(e, "ACCOUNT_UPDATE")))
        {
            this.handleBalance(client as WebSocketClient, message);
        }
        if (isTrue(isEqual(e, "ORDER_TRADE_UPDATE")))
        {
            this.handleOrder(client as WebSocketClient, message);
            object data = this.safeValue(message, "o", new Dictionary<string, object>() {});
            object type = this.safeString(data, "x");
            object status = this.safeString(data, "X");
            if (isTrue(isTrue((isEqual(type, "TRADE"))) && isTrue((isEqual(status, "FILLED")))))
            {
                this.handleMyTrades(client as WebSocketClient, message);
            }
        }
        object msgData = this.safeValue(message, "data");
        object msgEvent = this.safeString(msgData, "e");
        if (isTrue(isEqual(msgEvent, "24hTicker")))
        {
            this.handleTicker(client as WebSocketClient, message);
        }
    }
}
