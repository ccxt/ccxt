namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class upbit { public upbit(object args = null) : base(args) { } }
public partial class upbit : ccxt.upbit
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchOrderBook", true },
                { "watchTicker", true },
                { "watchTrades", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", "wss://api.upbit.com/websocket/v1" },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "tradesLimit", 1000 },
            } },
        });
    }

    public async virtual Task<object> watchPublic(object symbol, object channel, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object marketId = getValue(market, "id");
        object url = getValue(getValue(this.urls, "api"), "ws");
        ((IDictionary<string,object>)this.options)[(string)channel] = this.safeValue(this.options, channel, new Dictionary<string, object>() {});
        ((IDictionary<string,object>)getValue(this.options, channel))[(string)symbol] = true;
        object symbols = new List<object>(((IDictionary<string,object>)getValue(this.options, channel)).Keys);
        object marketIds = this.marketIds(symbols);
        object request = new List<object>() {new Dictionary<string, object>() {
    { "ticket", this.uuid() },
}, new Dictionary<string, object>() {
    { "type", channel },
    { "codes", marketIds },
}};
        object messageHash = add(add(channel, ":"), marketId);
        return await this.watch(url, messageHash, request, messageHash);
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name upbit#watchTicker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchPublic(symbol, "ticker");
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name upbit#watchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbol = this.symbol(symbol);
        object trades = await this.watchPublic(symbol, "trade");
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name upbit#watchOrderBook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        object orderbook = await this.watchPublic(symbol, "orderbook");
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        // 2020-03-17T23:07:36.511Z "onMessage" <Buffer 7b 22 74 79 70 65 22 3a 22 74 69 63 6b 65 72 22 2c 22 63 6f 64 65 22 3a 22 42 54 43 2d 45 54 48 22 2c 22 6f 70 65 6e 69 6e 67 5f 70 72 69 63 65 22 3a ... >
        // { type: "ticker",
        //   "code": "BTC-ETH",
        //   "opening_price": 0.02295092,
        //   "high_price": 0.02295092,
        //   "low_price": 0.02161249,
        //   "trade_price": 0.02161249,
        //   "prev_closing_price": 0.02185802,
        //   "acc_trade_price": 2.32732482,
        //   "change": "FALL",
        //   "change_price": 0.00024553,
        //   "signed_change_price": -0.00024553,
        //   "change_rate": 0.0112329479,
        //   "signed_change_rate": -0.0112329479,
        //   "ask_bid": "ASK",
        //   "trade_volume": 2.12,
        //   "acc_trade_volume": 106.11798418,
        //   "trade_date": "20200317",
        //   "trade_time": "215843",
        //   "trade_timestamp": 1584482323000,
        //   "acc_ask_volume": 90.16935908,
        //   "acc_bid_volume": 15.9486251,
        //   "highest_52_week_price": 0.03537414,
        //   "highest_52_week_date": "2019-04-08",
        //   "lowest_52_week_price": 0.01614901,
        //   "lowest_52_week_date": "2019-09-06",
        //   "trade_status": null,
        //   "market_state": "ACTIVE",
        //   "market_state_for_ios": null,
        //   "is_trading_suspended": false,
        //   "delisting_date": null,
        //   "market_warning": "NONE",
        //   "timestamp": 1584482323378,
        //   "acc_trade_price_24h": 2.5955306323568927,
        //   "acc_trade_volume_24h": 118.38798416,
        //   "stream_type": "SNAPSHOT" }
        object marketId = this.safeString(message, "code");
        object messageHash = add("ticker:", marketId);
        object ticker = this.parseTicker(message);
        object symbol = getValue(ticker, "symbol");
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        // { type: "orderbook",
        //   "code": "BTC-ETH",
        //   "timestamp": 1584486737444,
        //   "total_ask_size": 16.76384456,
        //   "total_bid_size": 168.9020623,
        //   "orderbook_units":
        //    [ { ask_price: 0.02295077,
        //        "bid_price": 0.02161249,
        //        "ask_size": 3.57100696,
        //        "bid_size": 22.5303265 },
        //      { ask_price: 0.02295078,
        //        "bid_price": 0.02152658,
        //        "ask_size": 0.52451651,
        //        "bid_size": 2.30355128 },
        //      { ask_price: 0.02295086,
        //        "bid_price": 0.02150802,
        //        "ask_size": 1.585,
        //        "bid_size": 5 }, ... ],
        //   "stream_type": "SNAPSHOT" }
        object marketId = this.safeString(message, "code");
        object symbol = this.safeSymbol(marketId, null, "-");
        object type = this.safeString(message, "stream_type");
        object options = this.safeValue(this.options, "watchOrderBook", new Dictionary<string, object>() {});
        object limit = this.safeInteger(options, "limit", 15);
        if (isTrue(isEqual(type, "SNAPSHOT")))
        {
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
        }
        object orderbook = getValue(this.orderbooks, symbol);
        // upbit always returns a snapshot of 15 topmost entries
        // the "REALTIME" deltas are not incremental
        // therefore we reset the orderbook on each update
        // and reinitialize it again with new bidasks
        (orderbook as IOrderBook).reset(new Dictionary<string, object>() {});
        ((IDictionary<string,object>)orderbook)["symbol"] = symbol;
        object bids = getValue(orderbook, "bids");
        object asks = getValue(orderbook, "asks");
        object data = this.safeValue(message, "orderbook_units", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object ask_price = this.safeFloat(entry, "ask_price");
            object ask_size = this.safeFloat(entry, "ask_size");
            object bid_price = this.safeFloat(entry, "bid_price");
            object bid_size = this.safeFloat(entry, "bid_size");
            (asks as IOrderBookSide).store(ask_price, ask_size);
            (bids as IOrderBookSide).store(bid_price, bid_size);
        }
        object timestamp = this.safeInteger(message, "timestamp");
        object datetime = this.iso8601(timestamp);
        ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
        ((IDictionary<string,object>)orderbook)["datetime"] = datetime;
        object messageHash = add("orderbook:", marketId);
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        // { type: "trade",
        //   "code": "KRW-BTC",
        //   "timestamp": 1584508285812,
        //   "trade_date": "2020-03-18",
        //   "trade_time": "05:11:25",
        //   "trade_timestamp": 1584508285000,
        //   "trade_price": 6747000,
        //   "trade_volume": 0.06499468,
        //   "ask_bid": "ASK",
        //   "prev_closing_price": 6774000,
        //   "change": "FALL",
        //   "change_price": 27000,
        //   "sequential_id": 1584508285000002,
        //   "stream_type": "REALTIME" }
        object trade = this.parseTrade(message);
        object symbol = getValue(trade, "symbol");
        object stored = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        callDynamically(stored, "append", new object[] {trade});
        object marketId = this.safeString(message, "code");
        object messageHash = add("trade:", marketId);
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        object methods = new Dictionary<string, object>() {
            { "ticker", this.handleTicker },
            { "orderbook", this.handleOrderBook },
            { "trade", this.handleTrades },
        };
        object methodName = this.safeString(message, "type");
        object method = this.safeValue(methods, methodName);
        if (isTrue(method))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
    }
}
