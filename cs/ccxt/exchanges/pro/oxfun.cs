namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class oxfun { public oxfun(object args = null) : base(args) { } }
public partial class oxfun : ccxt.oxfun
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
                { "watchOrderBook", true },
                { "watchOrderBookForSymbols", true },
                { "watchOHLCV", true },
                { "watchOHLCVForSymbols", true },
                { "watchOrders", true },
                { "watchMyTrades", false },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchBalance", true },
                { "createOrderWs", true },
                { "editOrderWs", true },
                { "cancelOrderWs", true },
                { "cancelOrdersWs", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", "wss://api.ox.fun/v2/websocket" },
                    { "test", "wss://stgapi.ox.fun/v2/websocket" },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "timeframes", new Dictionary<string, object>() {
                    { "1m", "60s" },
                    { "3m", "180s" },
                    { "5m", "300s" },
                    { "15m", "900s" },
                    { "30m", "1800s" },
                    { "1h", "3600s" },
                    { "2h", "7200s" },
                    { "4h", "14400s" },
                    { "6h", "21600s" },
                    { "12h", "43200s" },
                    { "1d", "86400s" },
                } },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "channel", "depth" },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "ping", this.ping },
                { "keepAlive", 50000 },
            } },
        });
    }

    public async virtual Task<object> subscribeMultiple(object messageHashes, object argsArray, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object url = getValue(getValue(this.urls, "api"), "ws");
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", argsArray },
        };
        return await this.watchMultiple(url, messageHashes, this.extend(request, parameters), messageHashes);
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name oxfun#watchTrades
        * @description watches information on multiple trades made in a market
        * @see https://docs.ox.fun/?json#trade
        * @param {string} symbol unified market symbol of the market trades were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of trade structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name oxfun#watchTradesForSymbols
        * @description get the list of most recent trades for a particular symbol
        * @see https://docs.ox.fun/?json#trade
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object args = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object messageHash = add(add("trades", ":"), symbol);
            ((IList<object>)messageHashes).Add(messageHash);
            object marketId = this.marketId(symbol);
            object arg = add("trade:", marketId);
            ((IList<object>)args).Add(arg);
        }
        object trades = await this.subscribeMultiple(messageHashes, args, parameters);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeDict(trades, 0, new Dictionary<string, object>() {});
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //         table: 'trade',
        //         data: [
        //             {
        //                 side: 'SELL',
        //                 quantity: '0.074',
        //                 matchType: 'TAKER',
        //                 price: '3079.5',
        //                 marketCode: 'ETH-USD-SWAP-LIN',
        //                 tradeId: '400017157974517783',
        //                 timestamp: '1716124156643'
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(message, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object trade = this.safeDict(data, i, new Dictionary<string, object>() {});
            object parsedTrade = this.parseWsTrade(trade);
            object symbol = this.safeString(parsedTrade, "symbol");
            object messageHash = add("trades:", symbol);
            if (!isTrue((inOp(this.trades, symbol))))
            {
                object tradesLimit = this.safeInteger(this.options, "tradesLimit", 1000);
                ((IDictionary<string,object>)this.trades)[(string)symbol] = new ArrayCache(tradesLimit);
            }
            object stored = getValue(this.trades, symbol);
            callDynamically(stored, "append", new object[] {parsedTrade});
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        }
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        //     {
        //         side: 'SELL',
        //         quantity: '0.074',
        //         matchType: 'TAKER',
        //         price: '3079.5',
        //         marketCode: 'ETH-USD-SWAP-LIN',
        //         tradeId: '400017157974517783',
        //         timestamp: '1716124156643'
        //     }
        //
        object marketId = this.safeString(trade, "marketCode");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(trade, "timestamp");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "id", this.safeString(trade, "tradeId") },
            { "order", null },
            { "type", null },
            { "takerOrMaker", this.safeStringLower(trade, "matchType") },
            { "side", this.safeStringLower(trade, "side") },
            { "price", this.safeNumber(trade, "price") },
            { "amount", this.safeNumber(trade, "quantity") },
            { "cost", null },
            { "fee", null },
        });
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name oxfun#watchOHLCV
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://docs.ox.fun/?json#candles
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object timeframes = this.safeDict(this.options, "timeframes", new Dictionary<string, object>() {});
        object interval = this.safeString(timeframes, timeframe, timeframe);
        object args = add(add(add("candles", interval), ":"), getValue(market, "id"));
        object messageHash = add(add(add("ohlcv:", symbol), ":"), timeframe);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", new List<object>() {args} },
        };
        object ohlcvs = await this.watch(url, messageHash, this.extend(request, parameters), messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcvs, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcvs, since, limit, 0, true);
    }

    public async override Task<object> watchOHLCVForSymbols(object symbolsAndTimeframes, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name oxfun#watchOHLCVForSymbols
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://docs.ox.fun/?json#candles
        * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        parameters ??= new Dictionary<string, object>();
        object symbolsLength = getArrayLength(symbolsAndTimeframes);
        if (isTrue(isTrue(isEqual(symbolsLength, 0)) || !isTrue(((getValue(symbolsAndTimeframes, 0) is IList<object>) || (getValue(symbolsAndTimeframes, 0).GetType().IsGenericType && getValue(symbolsAndTimeframes, 0).GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [[\'BTC/USDT:OX\', \'1m\'], [\'OX/USDT\', \'5m\']]")) ;
        }
        await this.loadMarkets();
        object args = new List<object>() {};
        object messageHashes = new List<object>() {};
        object timeframes = this.safeDict(this.options, "timeframes", new Dictionary<string, object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(symbolsAndTimeframes)); postFixIncrement(ref i))
        {
            object symbolAndTimeframe = getValue(symbolsAndTimeframes, i);
            object sym = getValue(symbolAndTimeframe, 0);
            object tf = getValue(symbolAndTimeframe, 1);
            object marketId = this.marketId(sym);
            object interval = this.safeString(timeframes, tf, tf);
            object arg = add(add(add("candles", interval), ":"), marketId);
            ((IList<object>)args).Add(arg);
            object messageHash = add(add(add("multi:ohlcv:", sym), ":"), tf);
            ((IList<object>)messageHashes).Add(messageHash);
        }
        var symboltimeframecandlesVariable = await this.subscribeMultiple(messageHashes, args, parameters);
        var symbol = ((IList<object>) symboltimeframecandlesVariable)[0];
        var timeframe = ((IList<object>) symboltimeframecandlesVariable)[1];
        var candles = ((IList<object>) symboltimeframecandlesVariable)[2];
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(candles, "getLimit", new object[] {symbol, limit});
        }
        object filtered = this.filterBySinceLimit(candles, since, limit, 0, true);
        return this.createOHLCVObject(symbol, timeframe, filtered);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "table": "candles60s",
        //         "data": [
        //             {
        //                 "marketCode": "BTC-USD-SWAP-LIN",
        //                 "candle": [
        //                     "1594313762698", //timestamp
        //                     "9633.1",        //open
        //                     "9693.9",        //high
        //                     "9238.1",        //low
        //                     "9630.2",        //close
        //                     "45247",         //volume in OX
        //                     "5.3"            //volume in Contracts
        //                 ]
        //             }
        //         ]
        //     }
        //
        object table = this.safeString(message, "table");
        object parts = ((string)table).Split(new [] {((string)"candles")}, StringSplitOptions.None).ToList<object>();
        object timeframeId = this.safeString(parts, 1, "");
        object timeframe = this.findTimeframe(timeframeId);
        object messageData = this.safeList(message, "data", new List<object>() {});
        object data = this.safeDict(messageData, 0, new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "marketCode");
        object market = this.safeMarket(marketId);
        object symbol = this.safeSymbol(marketId, market);
        if (!isTrue((inOp(this.ohlcvs, symbol))))
        {
            ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = new Dictionary<string, object>() {};
        }
        if (!isTrue((inOp(getValue(this.ohlcvs, symbol), timeframe))))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = new ArrayCacheByTimestamp(limit);
        }
        object candle = this.safeList(data, "candle", new List<object>() {});
        object parsed = this.parseWsOHLCV(candle, market);
        object stored = getValue(getValue(this.ohlcvs, symbol), timeframe);
        callDynamically(stored, "append", new object[] {parsed});
        object messageHash = add(add(add("ohlcv:", symbol), ":"), timeframe);
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        // for multiOHLCV we need special object, as opposed to other "multi"
        // methods, because OHLCV response item does not contain symbol
        // or timeframe, thus otherwise it would be unrecognizable
        object messageHashForMulti = add("multi:", messageHash);
        callDynamically(client as WebSocketClient, "resolve", new object[] {new List<object>() {symbol, timeframe, stored}, messageHashForMulti});
    }

    public override object parseWsOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         "1594313762698", //timestamp
        //         "9633.1",        //open
        //         "9693.9",        //high
        //         "9238.1",        //low
        //         "9630.2",        //close
        //         "45247",         //volume in OX
        //         "5.3"            //volume in Contracts
        //     ]
        //
        return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 6)};
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name oxfun#watchOrderBook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://docs.ox.fun/?json#fixed-size-order-book
        * @see https://docs.ox.fun/?json#full-order-book
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchOrderBookForSymbols(new List<object>() {symbol}, limit, parameters);
    }

    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name oxfun#watchOrderBookForSymbols
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://docs.ox.fun/?json#fixed-size-order-book
        * @see https://docs.ox.fun/?json#full-order-book
        * @param {string[]} symbols unified array of symbols
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object channel = "depth";
        object options = this.safeDict(this.options, "watchOrderBook", new Dictionary<string, object>() {});
        object defaultChannel = this.safeString(options, "channel");
        if (isTrue(!isEqual(defaultChannel, null)))
        {
            channel = defaultChannel;
        } else if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(isLessThanOrEqual(limit, 5)))
            {
                channel = "depthL5";
            } else if (isTrue(isLessThanOrEqual(limit, 10)))
            {
                channel = "depthL10";
            } else if (isTrue(isLessThanOrEqual(limit, 25)))
            {
                channel = "depthL25";
            }
        }
        object args = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object messageHash = add("orderbook:", symbol);
            ((IList<object>)messageHashes).Add(messageHash);
            object marketId = this.marketId(symbol);
            object arg = add(add(channel, ":"), marketId);
            ((IList<object>)args).Add(arg);
        }
        object orderbook = await this.subscribeMultiple(messageHashes, args, parameters);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //     {
        //         "table": "depth",
        //         "data": {
        //             "seqNum": "100170478917895032",
        //             "asks": [
        //                 [ 0.01, 100500 ],
        //                 ...
        //             ],
        //             "bids": [
        //                 [ 69.69696, 69 ],
        //                 ...
        //             ],
        //             "checksum": 261021645,
        //             "marketCode": "OX-USDT",
        //             "timestamp": 1716204786184
        //         },
        //         "action": "partial"
        //     }
        //
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "marketCode");
        object symbol = this.safeSymbol(marketId);
        object timestamp = this.safeInteger(data, "timestamp");
        object messageHash = add("orderbook:", symbol);
        if (!isTrue((inOp(this.orderbooks, symbol))))
        {
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {});
        }
        object orderbook = getValue(this.orderbooks, symbol);
        object snapshot = this.parseOrderBook(data, symbol, timestamp, "asks", "bids");
        (orderbook as IOrderBook).reset(snapshot);
        ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger(data, "seqNum");
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name oxfun#watchTicker
        * @see https://docs.ox.fun/?json#ticker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object ticker = await this.watchTickers(new List<object>() {symbol}, parameters);
        return this.safeValue(ticker, symbol);
    }

    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name oxfun#watchTickers
        * @see https://docs.ox.fun/?json#ticker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
        * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object allSymbols = (isEqual(symbols, null));
        object sym = symbols;
        object args = new List<object>() {};
        if (isTrue(allSymbols))
        {
            sym = this.symbols;
            ((IList<object>)args).Add("ticker:all");
        }
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(sym)); postFixIncrement(ref i))
        {
            object symbol = getValue(sym, i);
            object messageHash = add(add("tickers", ":"), symbol);
            ((IList<object>)messageHashes).Add(messageHash);
            object marketId = this.marketId(symbol);
            if (!isTrue(allSymbols))
            {
                ((IList<object>)args).Add(add("ticker:", marketId));
            }
        }
        object newTicker = await this.subscribeMultiple(messageHashes, args, parameters);
        if (isTrue(this.newUpdates))
        {
            object result = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)result)[(string)getValue(newTicker, "symbol")] = newTicker;
            return result;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        //     {
        //         "table": "ticker",
        //         "data": [
        //             {
        //                 "last": "3088.6",
        //                 "open24h": "3087.2",
        //                 "high24h": "3142.0",
        //                 "low24h": "3053.9",
        //                 "volume24h": "450512672.1800",
        //                 "currencyVolume24h": "1458.579",
        //                 "openInterest": "3786.801",
        //                 "marketCode": "ETH-USD-SWAP-LIN",
        //                 "timestamp": "1716212747050",
        //                 "lastQty": "0.813",
        //                 "markPrice": "3088.6",
        //                 "lastMarkPrice": "3088.6",
        //                 "indexPrice": "3086.5"
        //             },
        //             ...
        //         ]
        //     }
        //
        object data = this.safeList(message, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object rawTicker = this.safeDict(data, i, new Dictionary<string, object>() {});
            object ticker = this.parseTicker(rawTicker);
            object symbol = getValue(ticker, "symbol");
            object messageHash = add("tickers:", symbol);
            ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
            callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
        }
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @name oxfun#watchBalance
        * @see https://docs.ox.fun/?json#balance-channel
        * @description watch balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.authenticate();
        object args = "balance:all";
        object messageHash = "balance";
        object url = getValue(getValue(this.urls, "api"), "ws");
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", new List<object>() {args} },
        };
        return await this.watch(url, messageHash, this.extend(request, parameters), messageHash);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        //     {
        //         "table": "balance",
        //         "accountId": "106464",
        //         "timestamp": "1716549132780",
        //         "tradeType": "PORTFOLIO",
        //         "data": [
        //             {
        //                 "instrumentId": "xOX",
        //                 "total": "23.375591220",
        //                 "available": "23.375591220",
        //                 "reserved": "0",
        //                 "quantityLastUpdated": "1716509744262",
        //                 "locked": "0"
        //             },
        //             ...
        //         ]
        //     }
        //
        object balances = this.safeList(message, "data");
        object timestamp = this.safeInteger(message, "timestamp");
        ((IDictionary<string,object>)this.balance)["info"] = message;
        ((IDictionary<string,object>)this.balance)["timestamp"] = timestamp;
        ((IDictionary<string,object>)this.balance)["datetime"] = this.iso8601(timestamp);
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = this.safeDict(balances, i, new Dictionary<string, object>() {});
            object currencyId = this.safeString(balance, "instrumentId");
            object code = this.safeCurrencyCode(currencyId);
            if (!isTrue((inOp(this.balance, code))))
            {
                ((IDictionary<string,object>)this.balance)[(string)code] = this.account();
            }
            object account = getValue(this.balance, code);
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "total");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "reserved");
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "available");
            ((IDictionary<string,object>)this.balance)[(string)code] = account;
        }
        this.balance = this.safeBalance(this.balance);
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, "balance"});
    }

    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name oxfun#watchPositions
        * @see https://docs.ox.fun/?json#position-channel
        * @description watch all open positions
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the exchange API endpoint
        * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object allSymbols = (isEqual(symbols, null));
        object sym = symbols;
        object args = new List<object>() {};
        if (isTrue(allSymbols))
        {
            sym = this.symbols;
            ((IList<object>)args).Add("position:all");
        }
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(sym)); postFixIncrement(ref i))
        {
            object symbol = getValue(sym, i);
            object messageHash = add(add("positions", ":"), symbol);
            ((IList<object>)messageHashes).Add(messageHash);
            object marketId = this.marketId(symbol);
            if (!isTrue(allSymbols))
            {
                ((IList<object>)args).Add(add("position:", marketId));
            }
        }
        object newPositions = await this.subscribeMultiple(messageHashes, args, parameters);
        if (isTrue(this.newUpdates))
        {
            return newPositions;
        }
        return this.filterBySymbolsSinceLimit(this.positions, symbols, since, limit, true);
    }

    public virtual void handlePositions(WebSocketClient client, object message)
    {
        //
        //     {
        //         "table": "position",
        //         "accountId": "106464",
        //         "timestamp": "1716550771582",
        //         "data": [
        //             {
        //                 "instrumentId": "ETH-USD-SWAP-LIN",
        //                 "quantity": "0.01",
        //                 "lastUpdated": "1716550757299",
        //                 "contractValCurrency": "ETH",
        //                 "entryPrice": "3709.6",
        //                 "positionPnl": "-5.000",
        //                 "estLiquidationPrice": "743.4",
        //                 "margin": "0",
        //                 "leverage": "0"
        //             }
        //         ]
        //     }
        //
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new ArrayCacheBySymbolBySide();
        }
        object cache = this.positions;
        object data = this.safeList(message, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object rawPosition = this.safeDict(data, i, new Dictionary<string, object>() {});
            object position = this.parseWsPosition(rawPosition);
            object symbol = getValue(position, "symbol");
            object messageHash = add("positions:", symbol);
            callDynamically(cache, "append", new object[] {position});
            callDynamically(client as WebSocketClient, "resolve", new object[] {position, messageHash});
        }
    }

    public virtual object parseWsPosition(object position, object market = null)
    {
        //
        //     {
        //         "instrumentId": "ETH-USD-SWAP-LIN",
        //         "quantity": "0.01",
        //         "lastUpdated": "1716550757299",
        //         "contractValCurrency": "ETH",
        //         "entryPrice": "3709.6",
        //         "positionPnl": "-5.000",
        //         "estLiquidationPrice": "743.4",
        //         "margin": "0", // Currently always reports 0
        //         "leverage": "0" // Currently always reports 0
        //     }
        //
        object marketId = this.safeString(position, "instrumentId");
        market = this.safeMarket(marketId, market);
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", getValue(market, "symbol") },
            { "notional", null },
            { "marginMode", "cross" },
            { "liquidationPrice", this.safeNumber(position, "estLiquidationPrice") },
            { "entryPrice", this.safeNumber(position, "entryPrice") },
            { "unrealizedPnl", this.safeNumber(position, "positionPnl") },
            { "realizedPnl", null },
            { "percentage", null },
            { "contracts", this.safeNumber(position, "quantity") },
            { "contractSize", null },
            { "markPrice", null },
            { "lastPrice", null },
            { "side", null },
            { "hedged", null },
            { "timestamp", null },
            { "datetime", null },
            { "lastUpdateTimestamp", this.safeInteger(position, "lastUpdated") },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "collateral", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "leverage", null },
            { "marginRatio", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name oxfun#watchOrders
        * @description watches information on multiple orders made by the user
        * @see https://docs.ox.fun/?json#order-channel
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object messageHash = "orders";
        object args = "order:";
        object market = this.safeMarket(symbol);
        if (isTrue(isEqual(symbol, null)))
        {
            args = add(args, "all");
        } else
        {
            messageHash = add(messageHash, add(":", symbol));
            args = add(args, add(":", getValue(market, "id")));
        }
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", new List<object>() {args} },
        };
        object url = getValue(getValue(this.urls, "api"), "ws");
        object orders = await this.watch(url, messageHash, request, messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleOrders(WebSocketClient client, object message)
    {
        //
        //     {
        //         "table": "order",
        //         "data": [
        //             {
        //                 "accountId": "106464",
        //                 "clientOrderId": "1716713676233",
        //                 "orderId": "1000116921319",
        //                 "price": "1000.0",
        //                 "quantity": "0.01",
        //                 "amount": "0.0",
        //                 "side": "BUY",
        //                 "status": "OPEN",
        //                 "marketCode": "ETH-USD-SWAP-LIN",
        //                 "timeInForce": "MAKER_ONLY",
        //                 "timestamp": "1716713677834",
        //                 "remainQuantity": "0.01",
        //                 "limitPrice": "1000.0",
        //                 "notice": "OrderOpened",
        //                 "orderType": "LIMIT",
        //                 "isTriggered": "false",
        //                 "displayQuantity": "0.01"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(message, "data", new List<object>() {});
        object messageHash = "orders";
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object orders = this.orders;
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object order = this.safeDict(data, i, new Dictionary<string, object>() {});
            object parsedOrder = this.parseOrder(order);
            callDynamically(orders, "append", new object[] {parsedOrder});
            messageHash = add(messageHash, add(":", getValue(parsedOrder, "symbol")));
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageHash});
        }
    }

    public async override Task<object> createOrderWs(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name oxfun#createOrderWs
        * @see https://docs.ox.fun/?json#order-commands
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market', 'limit', 'STOP_LIMIT' or 'STOP_MARKET'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.clientOrderId] a unique id for the order
        * @param {int} [params.timestamp] in milliseconds. If an order reaches the matching engine and the current timestamp exceeds timestamp + recvWindow, then the order will be rejected.
        * @param {int} [params.recvWindow] in milliseconds. If an order reaches the matching engine and the current timestamp exceeds timestamp + recvWindow, then the order will be rejected. If timestamp is provided without recvWindow, then a default recvWindow of 1000ms is used.
        * @param {float} [params.cost] the quote quantity that can be used as an alternative for the amount for market buy orders
        * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
        * @param {float} [params.limitPrice] Limit price for the STOP_LIMIT order
        * @param {bool} [params.postOnly] if true, the order will only be posted if it will be a maker order
        * @param {string} [params.timeInForce] GTC (default), IOC, FOK, PO, MAKER_ONLY or MAKER_ONLY_REPRICE (reprices order to the best maker only price if the specified price were to lead to a taker trade)
        * @param {string} [params.selfTradePreventionMode] NONE, EXPIRE_MAKER, EXPIRE_TAKER or EXPIRE_BOTH for more info check here {@link https://docs.ox.fun/?json#self-trade-prevention-modes}
        * @param {string} [params.displayQuantity] for an iceberg order, pass both quantity and displayQuantity fields in the order request
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object messageHash = ((object)this.nonce()).ToString();
        object request = new Dictionary<string, object>() {
            { "op", "placeorder" },
            { "tag", messageHash },
        };
        parameters = this.omit(parameters, "tag");
        object orderRequest = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object timestamp = this.safeInteger(orderRequest, "timestamp");
        if (isTrue(isEqual(timestamp, null)))
        {
            ((IDictionary<string,object>)orderRequest)["timestamp"] = this.milliseconds();
        }
        ((IDictionary<string,object>)request)["data"] = orderRequest;
        object url = getValue(getValue(this.urls, "api"), "ws");
        return await this.watch(url, messageHash, request, messageHash);
    }

    public async override Task<object> editOrderWs(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name oxfun#editOrderWs
        * @description edit a trade order
        * @see https://docs.ox.fun/?json#modify-order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of the currency you want to trade in units of the base currency
        * @param {float|undefined} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {int} [params.timestamp] in milliseconds. If an order reaches the matching engine and the current timestamp exceeds timestamp + recvWindow, then the order will be rejected.
        * @param {int} [params.recvWindow] in milliseconds. If an order reaches the matching engine and the current timestamp exceeds timestamp + recvWindow, then the order will be rejected. If timestamp is provided without recvWindow, then a default recvWindow of 1000ms is used.
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object messageHash = ((object)this.nonce()).ToString();
        object request = new Dictionary<string, object>() {
            { "op", "modifyorder" },
            { "tag", messageHash },
        };
        parameters = this.omit(parameters, "tag");
        object orderRequest = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        orderRequest = this.extend(orderRequest, new Dictionary<string, object>() {
            { "orderId", id },
        });
        object timestamp = this.safeInteger(orderRequest, "timestamp");
        if (isTrue(isEqual(timestamp, null)))
        {
            ((IDictionary<string,object>)orderRequest)["timestamp"] = this.milliseconds();
        }
        ((IDictionary<string,object>)request)["data"] = orderRequest;
        object url = getValue(getValue(this.urls, "api"), "ws");
        return await this.watch(url, messageHash, request, messageHash);
    }

    public virtual void handlePlaceOrders(WebSocketClient client, object message)
    {
        //
        //     {
        //         "event": "placeorder",
        //         "submitted": true,
        //         "tag": "1716934577",
        //         "timestamp": "1716932973899",
        //         "data": {
        //             "marketCode": "ETH-USD-SWAP-LIN",
        //             "side": "BUY",
        //             "orderType": "LIMIT",
        //             "quantity": "0.010",
        //             "timeInForce": "GTC",
        //             "price": "400.0",
        //             "limitPrice": "400.0",
        //             "orderId": "1000117429736",
        //             "source": 13
        //         }
        //     }
        //
        //
        // Failure response format
        //     {
        //         "event": "placeorder",
        //         "submitted": false,
        //         "message": "JSON data format is invalid",
        //         "code": "20009",
        //         "timestamp": "1716932877381"
        //     }
        //
        object messageHash = this.safeString(message, "tag");
        object submitted = this.safeBool(message, "submitted");
        // filter out partial errors
        if (!isTrue(submitted))
        {
            object method = this.safeString(message, "event");
            object stringMsg = this.json(message);
            object code = this.safeInteger(message, "code");
            this.handleErrors(code, null, client.url, method, null, stringMsg, message, null, null);
        }
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object order = this.parseOrder(data);
        callDynamically(client as WebSocketClient, "resolve", new object[] {order, messageHash});
    }

    public async override Task<object> cancelOrderWs(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name oxfun#cancelOrderWs
        * @see https://docs.ox.fun/?json#cancel-order
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified market symbol, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrderWs() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        await this.authenticate();
        object messageHash = ((object)this.nonce()).ToString();
        object data = new Dictionary<string, object>() {
            { "marketCode", this.marketId(symbol) },
            { "orderId", id },
        };
        object request = new Dictionary<string, object>() {
            { "op", "cancelorder" },
            { "tag", messageHash },
            { "data", data },
        };
        object url = getValue(getValue(this.urls, "api"), "ws");
        return await this.watch(url, messageHash, request, messageHash);
    }

    public async override Task<object> cancelOrdersWs(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#cancelOrdersWs
        * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-ws-mass-cancel-order
        * @description cancel multiple orders
        * @param {string[]} ids order ids
        * @param {string} symbol unified market symbol, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object idsLength = getArrayLength(ids);
        if (isTrue(isGreaterThan(idsLength, 20)))
        {
            throw new BadRequest ((string)add(this.id, " cancelOrdersWs() accepts up to 20 ids at a time")) ;
        }
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrdersWs() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        await this.authenticate();
        object messageHash = ((object)this.nonce()).ToString();
        object marketId = this.marketId(symbol);
        object dataArray = new List<object>() {};
        for (object i = 0; isLessThan(i, idsLength); postFixIncrement(ref i))
        {
            object data = new Dictionary<string, object>() {
                { "instId", marketId },
                { "ordId", getValue(ids, i) },
            };
            ((IList<object>)dataArray).Add(data);
        }
        object request = new Dictionary<string, object>() {
            { "op", "cancelorders" },
            { "tag", messageHash },
            { "dataArray", dataArray },
        };
        object url = getValue(getValue(this.urls, "api"), "ws");
        return await this.watch(url, messageHash, this.deepExtend(request, parameters), messageHash);
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object url = getValue(getValue(this.urls, "api"), "ws");
        var client = this.client(url);
        object messageHash = "authenticated";
        var future = client.future(messageHash);
        object authenticated = this.safeDict(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(authenticated, null)))
        {
            this.checkRequiredCredentials();
            object timestamp = this.milliseconds();
            object payload = add(((object)timestamp).ToString(), "GET/auth/self/verify");
            object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha256, "base64");
            object request = new Dictionary<string, object>() {
                { "op", "login" },
                { "data", new Dictionary<string, object>() {
                    { "apiKey", this.apiKey },
                    { "timestamp", timestamp },
                    { "signature", signature },
                } },
            };
            object message = this.extend(request, parameters);
            this.watch(url, messageHash, message, messageHash);
        }
        return await (future as Exchange.Future);
    }

    public virtual void handleAuthenticationMessage(WebSocketClient client, object message)
    {
        object authenticated = this.safeBool(message, "success", false);
        object messageHash = "authenticated";
        if (isTrue(authenticated))
        {
            // we resolve the future here permanently so authentication only happens once
            var future = this.safeDict(client.futures, messageHash);
            (future as Future).resolve(true);
        } else
        {
            var error = new AuthenticationError(this.json(message));
            ((WebSocketClient)client).reject(error, messageHash);
            if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
            {

            }
        }
    }

    public override object ping(WebSocketClient client)
    {
        return "ping";
    }

    public virtual object handlePong(WebSocketClient client, object message)
    {
        client.lastPong = this.milliseconds();
        return message;
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (isTrue(isEqual(message, "pong")))
        {
            this.handlePong(client as WebSocketClient, message);
            return;
        }
        object table = this.safeString(message, "table");
        object data = this.safeList(message, "data", new List<object>() {});
        object eventVar = this.safeString(message, "event");
        if (isTrue(isTrue((!isEqual(table, null))) && isTrue((!isEqual(data, null)))))
        {
            if (isTrue(isEqual(table, "trade")))
            {
                this.handleTrades(client as WebSocketClient, message);
            }
            if (isTrue(isEqual(table, "ticker")))
            {
                this.handleTicker(client as WebSocketClient, message);
            }
            if (isTrue(isGreaterThan(getIndexOf(table, "candles"), -1)))
            {
                this.handleOHLCV(client as WebSocketClient, message);
            }
            if (isTrue(isGreaterThan(getIndexOf(table, "depth"), -1)))
            {
                this.handleOrderBook(client as WebSocketClient, message);
            }
            if (isTrue(isGreaterThan(getIndexOf(table, "balance"), -1)))
            {
                this.handleBalance(client as WebSocketClient, message);
            }
            if (isTrue(isGreaterThan(getIndexOf(table, "position"), -1)))
            {
                this.handlePositions(client as WebSocketClient, message);
            }
            if (isTrue(isGreaterThan(getIndexOf(table, "order"), -1)))
            {
                this.handleOrders(client as WebSocketClient, message);
            }
        } else
        {
            if (isTrue(isEqual(eventVar, "login")))
            {
                this.handleAuthenticationMessage(client as WebSocketClient, message);
            }
            if (isTrue(isTrue(isTrue((isEqual(eventVar, "placeorder"))) || isTrue((isEqual(eventVar, "modifyorder")))) || isTrue((isEqual(eventVar, "cancelorder")))))
            {
                this.handlePlaceOrders(client as WebSocketClient, message);
            }
        }
    }
}
