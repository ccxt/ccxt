namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class hashkey { public hashkey(object args = null) : base(args) { } }
public partial class hashkey : ccxt.hashkey
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchBalance", true },
                { "watchMyTrades", true },
                { "watchOHLCV", true },
                { "watchOrderBook", true },
                { "watchOrders", true },
                { "watchTicker", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", false },
                { "watchPositions", false },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://stream-glb.hashkey.com/quote/ws/v1" },
                        { "private", "wss://stream-glb.hashkey.com/api/v1/ws" },
                    } },
                    { "test", new Dictionary<string, object>() {
                        { "ws", new Dictionary<string, object>() {
                            { "public", "wss://stream-glb.sim.hashkeydev.com/quote/ws/v1" },
                            { "private", "wss://stream-glb.sim.hashkeydev.com/api/v1/ws" },
                        } },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "listenKeyRefreshRate", 3600000 },
                { "listenKey", null },
                { "watchBalance", new Dictionary<string, object>() {
                    { "fetchBalanceSnapshot", true },
                    { "awaitBalanceSnapshot", false },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "keepAlive", 10000 },
            } },
        });
    }

    public async virtual Task<object> wathPublic(object market, object topic, object messageHash, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "topic", topic },
            { "event", "sub" },
        };
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "public");
        return await this.watch(url, messageHash, this.deepExtend(request, parameters), messageHash);
    }

    public async virtual Task<object> watchPrivate(object messageHash)
    {
        object listenKey = await this.authenticate();
        object url = this.getPrivateUrl(listenKey);
        return await this.watch(url, messageHash, null, messageHash);
    }

    public virtual object getPrivateUrl(object listenKey)
    {
        return add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "private"), "/"), listenKey);
    }

    /**
     * @method
     * @name hashkey#watchOHLCV
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://hashkeyglobal-apidoc.readme.io/reference/websocket-api#public-stream
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.binary] true or false - default false
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object interval = this.safeString(this.timeframes, timeframe, timeframe);
        object topic = add("kline_", interval);
        object messageHash = add(add(add("ohlcv:", symbol), ":"), timeframe);
        object ohlcv = await this.wathPublic(market, topic, messageHash, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "symbol": "DOGEUSDT",
        //         "symbolName": "DOGEUSDT",
        //         "topic": "kline",
        //         "params": {
        //             "realtimeInterval": "24h",
        //             "klineType": "1m"
        //         },
        //         "data": [
        //             {
        //                 "t": 1722861660000,
        //                 "s": "DOGEUSDT",
        //                 "sn": "DOGEUSDT",
        //                 "c": "0.08389",
        //                 "h": "0.08389",
        //                 "l": "0.08389",
        //                 "o": "0.08389",
        //                 "v": "0"
        //             }
        //         ],
        //         "f": true,
        //         "sendTime": 1722861664258,
        //         "shared": false
        //     }
        //
        object marketId = this.safeString(message, "symbol");
        object market = this.safeMarket(marketId);
        object symbol = this.safeSymbol(marketId, market);
        if (!isTrue((inOp(this.ohlcvs, symbol))))
        {
            ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = new Dictionary<string, object>() {};
        }
        object parameters = this.safeDict(message, "params");
        object klineType = this.safeString(parameters, "klineType");
        object timeframe = this.findTimeframe(klineType);
        if (!isTrue((inOp(getValue(this.ohlcvs, symbol), timeframe))))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = new ArrayCacheByTimestamp(limit);
        }
        object data = this.safeList(message, "data", new List<object>() {});
        object stored = getValue(getValue(this.ohlcvs, symbol), timeframe);
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object candle = this.safeDict(data, i, new Dictionary<string, object>() {});
            object parsed = this.parseWsOHLCV(candle, market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        object messageHash = add(add(add("ohlcv:", symbol), ":"), timeframe);
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public override object parseWsOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "t": 1722861660000,
        //         "s": "DOGEUSDT",
        //         "sn": "DOGEUSDT",
        //         "c": "0.08389",
        //         "h": "0.08389",
        //         "l": "0.08389",
        //         "o": "0.08389",
        //         "v": "0"
        //     }
        //
        return new List<object> {this.safeInteger(ohlcv, "t"), this.safeNumber(ohlcv, "o"), this.safeNumber(ohlcv, "h"), this.safeNumber(ohlcv, "l"), this.safeNumber(ohlcv, "c"), this.safeNumber(ohlcv, "v")};
    }

    /**
     * @method
     * @name hahskey#watchTicker
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://hashkeyglobal-apidoc.readme.io/reference/websocket-api#public-stream
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.binary] true or false - default false
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object topic = "realtimes";
        object messageHash = add("ticker:", symbol);
        return await this.wathPublic(market, topic, messageHash, parameters);
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        //     {
        //         "symbol": "ETHUSDT",
        //         "symbolName": "ETHUSDT",
        //         "topic": "realtimes",
        //         "params": {
        //             "realtimeInterval": "24h"
        //         },
        //         "data": [
        //             {
        //                 "t": 1722864411064,
        //                 "s": "ETHUSDT",
        //                 "sn": "ETHUSDT",
        //                 "c": "2195",
        //                 "h": "2918.85",
        //                 "l": "2135.5",
        //                 "o": "2915.78",
        //                 "v": "666.5019",
        //                 "qv": "1586902.757079",
        //                 "m": "-0.2472",
        //                 "e": 301
        //             }
        //         ],
        //         "f": false,
        //         "sendTime": 1722864411086,
        //         "shared": false
        //     }
        //
        object data = this.safeList(message, "data", new List<object>() {});
        object ticker = this.parseTicker(this.safeDict(data, 0));
        object symbol = getValue(ticker, "symbol");
        object messageHash = add("ticker:", symbol);
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.tickers, symbol), messageHash});
    }

    /**
     * @method
     * @name hashkey#watchTrades
     * @description watches information on multiple trades made in a market
     * @see https://hashkeyglobal-apidoc.readme.io/reference/websocket-api#public-stream
     * @param {string} symbol unified market symbol of the market trades were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of trade structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.binary] true or false - default false
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object topic = "trade";
        object messageHash = add("trades:", symbol);
        object trades = await this.wathPublic(market, topic, messageHash, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //         "symbol": "ETHUSDT",
        //         "symbolName": "ETHUSDT",
        //         "topic": "trade",
        //         "params": {
        //             "realtimeInterval": "24h"
        //         },
        //         "data": [
        //             {
        //                 "v": "1745922896272048129",
        //                 "t": 1722866228075,
        //                 "p": "2340.41",
        //                 "q": "0.0132",
        //                 "m": true
        //             },
        //             ...
        //         ],
        //         "f": true,
        //         "sendTime": 1722869464248,
        //         "channelId": "668498fffeba4108-00000001-00113184-562e27d215e43f9c-c188b319",
        //         "shared": false
        //     }
        //
        object marketId = this.safeString(message, "symbol");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        if (!isTrue((inOp(this.trades, symbol))))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = new ArrayCache(limit);
        }
        object stored = getValue(this.trades, symbol);
        object data = this.safeList(message, "data");
        if (isTrue(!isEqual(data, null)))
        {
            data = this.sortBy(data, "t");
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object trade = this.safeDict(data, i);
                object parsed = this.parseWsTrade(trade, market);
                callDynamically(stored, "append", new object[] {parsed});
            }
        }
        object messageHash = add(add("trades", ":"), symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    /**
     * @method
     * @name alpaca#watchOrderBook
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://hashkeyglobal-apidoc.readme.io/reference/websocket-api#public-stream
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return.
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object topic = "depth";
        object messageHash = add("orderbook:", symbol);
        object orderbook = await this.wathPublic(market, topic, messageHash, parameters);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //     {
        //         "symbol": "ETHUSDT",
        //         "symbolName": "ETHUSDT",
        //         "topic": "depth",
        //         "params": { "realtimeInterval": "24h" },
        //         "data": [
        //             {
        //                 "e": 301,
        //                 "s": "ETHUSDT",
        //                 "t": 1722873144371,
        //                 "v": "84661262_18",
        //                 "b": [
        //                     [ "1650", "0.0864" ],
        //                     ...
        //                 ],
        //                 "a": [
        //                     ["4085", "0.0074" ],
        //                     ...
        //                 ],
        //                 "o": 0
        //             }
        //         ],
        //         "f": false,
        //         "sendTime": 1722873144589,
        //         "channelId": "2265aafffe68b588-00000001-0011510c-9e9ca710b1500854-551830bd",
        //         "shared": false
        //     }
        //
        object marketId = this.safeString(message, "symbol");
        object symbol = this.safeSymbol(marketId);
        object messageHash = add("orderbook:", symbol);
        if (!isTrue((inOp(this.orderbooks, symbol))))
        {
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {});
        }
        object orderbook = getValue(this.orderbooks, symbol);
        object data = this.safeList(message, "data", new List<object>() {});
        object dataEntry = this.safeDict(data, 0);
        object timestamp = this.safeInteger(dataEntry, "t");
        object snapshot = this.parseOrderBook(dataEntry, symbol, timestamp, "b", "a");
        (orderbook as IOrderBook).reset(snapshot);
        ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger(message, "id");
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    /**
     * @method
     * @name hashkey#watchOrders
     * @description watches information on multiple orders made by the user
     * @see https://hashkeyglobal-apidoc.readme.io/reference/websocket-api#private-stream
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object messageHash = "orders";
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
            messageHash = add(add(messageHash, ":"), symbol);
        }
        object orders = await this.watchPrivate(messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        //
        // swap
        //     {
        //         "e": "contractExecutionReport",
        //         "E": "1723037391181",
        //         "s": "ETHUSDT-PERPETUAL",
        //         "c": "1723037389677",
        //         "S": "BUY_OPEN",
        //         "o": "LIMIT",
        //         "f": "IOC",
        //         "q": "1",
        //         "p": "2561.75",
        //         "X": "FILLED",
        //         "i": "1747358716129257216",
        //         "l": "1",
        //         "z": "1",
        //         "L": "2463.36",
        //         "n": "0.001478016",
        //         "N": "USDT",
        //         "u": true,
        //         "w": true,
        //         "m": false,
        //         "O": "1723037391140",
        //         "Z": "2463.36",
        //         "C": false,
        //         "v": "5",
        //         "reqAmt": "0",
        //         "d": "1747358716255075840",
        //         "r": "0",
        //         "V": "2463.36",
        //         "P": "0",
        //         "lo": false,
        //         "lt": ""
        //     }
        //
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object parsed = this.parseWsOrder(message);
        object orders = this.orders;
        callDynamically(orders, "append", new object[] {parsed});
        object messageHash = "orders";
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
        object symbol = getValue(parsed, "symbol");
        object symbolSpecificMessageHash = add(add(messageHash, ":"), symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, symbolSpecificMessageHash});
    }

    public override object parseWsOrder(object order, object market = null)
    {
        object marketId = this.safeString(order, "s");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(order, "O");
        object side = this.safeStringLower(order, "S");
        object reduceOnly = null;
        var sidereduceOnlyVariable = this.parseOrderSideAndReduceOnly(side);
        side = ((IList<object>)sidereduceOnlyVariable)[0];
        reduceOnly = ((IList<object>)sidereduceOnlyVariable)[1];
        object type = this.parseOrderType(this.safeString(order, "o"));
        object timeInForce = this.safeString(order, "f");
        object postOnly = null;
        var typetimeInForcepostOnlyVariable = this.parseOrderTypeTimeInForceAndPostOnly(type, timeInForce);
        type = ((IList<object>)typetimeInForcepostOnlyVariable)[0];
        timeInForce = ((IList<object>)typetimeInForcepostOnlyVariable)[1];
        postOnly = ((IList<object>)typetimeInForcepostOnlyVariable)[2];
        if (isTrue(getValue(market, "contract")))
        {
            type = null;
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(order, "i") },
            { "clientOrderId", this.safeString(order, "c") },
            { "datetime", this.iso8601(timestamp) },
            { "timestamp", timestamp },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", null },
            { "status", this.parseOrderStatus(this.safeString(order, "X")) },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "timeInForce", timeInForce },
            { "side", side },
            { "price", this.safeString(order, "p") },
            { "average", this.safeString(order, "V") },
            { "amount", this.omitZero(this.safeString(order, "q")) },
            { "filled", this.safeString(order, "z") },
            { "remaining", this.safeString(order, "r") },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "takeProfitPrice", null },
            { "stopLossPrice", null },
            { "cost", this.omitZero(this.safeString(order, "Z")) },
            { "trades", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(this.safeString(order, "N")) },
                { "amount", this.omitZero(this.safeString(order, "n")) },
            } },
            { "reduceOnly", reduceOnly },
            { "postOnly", postOnly },
            { "info", order },
        }, market);
    }

    /**
     * @method
     * @name hashkey#watchMyTrades
     * @description watches information on multiple trades made by the user
     * @see https://hashkeyglobal-apidoc.readme.io/reference/websocket-api#private-stream
     * @param {string} symbol unified market symbol of the market trades were made in
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trade structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object messageHash = "myTrades";
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
            messageHash = add(messageHash, add(":", symbol));
        }
        object trades = await this.watchPrivate(messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleMyTrade(WebSocketClient client, object message, object subscription = null)
    {
        //
        //     {
        //         "e": "ticketInfo",
        //         "E": "1723037391156",
        //         "s": "ETHUSDT-PERPETUAL",
        //         "q": "1.00",
        //         "t": "1723037391147",
        //         "p": "2463.36",
        //         "T": "1747358716187197441",
        //         "o": "1747358716129257216",
        //         "c": "1723037389677",
        //         "a": "1735619524953226496",
        //         "m": false,
        //         "S": "BUY"
        //     }
        //
        subscription ??= new Dictionary<string, object>();
        if (isTrue(isEqual(this.myTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            this.myTrades = new ArrayCacheBySymbolById(limit);
        }
        object tradesArray = this.myTrades;
        object parsed = this.parseWsTrade(message);
        callDynamically(tradesArray, "append", new object[] {parsed});
        this.myTrades = tradesArray;
        object messageHash = "myTrades";
        callDynamically(client as WebSocketClient, "resolve", new object[] {tradesArray, messageHash});
        object symbol = getValue(parsed, "symbol");
        object symbolSpecificMessageHash = add(add(messageHash, ":"), symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {tradesArray, symbolSpecificMessageHash});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        // watchTrades
        //     {
        //         "v": "1745922896272048129",
        //         "t": 1722866228075,
        //         "p": "2340.41",
        //         "q": "0.0132",
        //         "m": true
        //     }
        //
        // watchMyTrades
        //     {
        //         "e": "ticketInfo",
        //         "E": "1723037391156",
        //         "s": "ETHUSDT-PERPETUAL",
        //         "q": "1.00",
        //         "t": "1723037391147",
        //         "p": "2463.36",
        //         "T": "1747358716187197441",
        //         "o": "1747358716129257216",
        //         "c": "1723037389677",
        //         "a": "1735619524953226496",
        //         "m": false,
        //         "S": "BUY"
        //     }
        //
        object marketId = this.safeString(trade, "s");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(trade, "t");
        object isMaker = this.safeBool(trade, "m");
        object takerOrMaker = null;
        if (isTrue(!isEqual(isMaker, null)))
        {
            if (isTrue(isMaker))
            {
                takerOrMaker = "maker";
            } else
            {
                takerOrMaker = "taker";
            }
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", this.safeString2(trade, "v", "T") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "side", this.safeStringLower(trade, "S") },
            { "price", this.safeString(trade, "p") },
            { "amount", this.safeString(trade, "q") },
            { "cost", null },
            { "takerOrMaker", takerOrMaker },
            { "type", null },
            { "order", this.safeString(trade, "o") },
            { "fee", null },
            { "info", trade },
        }, market);
    }

    /**
     * @method
     * @name hashkey#watchPositions
     * @see https://hashkeyglobal-apidoc.readme.io/reference/websocket-api#private-stream
     * @description watch all open positions
     * @param {string[]} [symbols] list of unified market symbols to watch positions for
     * @param {int} [since] the earliest time in ms to fetch positions for
     * @param {int} [limit] the maximum number of positions to retrieve
     * @param {object} params extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
     */
    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object listenKey = await this.authenticate();
        symbols = this.marketSymbols(symbols);
        object messageHash = "positions";
        object messageHashes = new List<object>() {};
        if (isTrue(isEqual(symbols, null)))
        {
            ((IList<object>)messageHashes).Add(messageHash);
        } else
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                ((IList<object>)messageHashes).Add(add(add(messageHash, ":"), symbol));
            }
        }
        object url = this.getPrivateUrl(listenKey);
        object positions = await this.watchMultiple(url, messageHashes, null, messageHashes);
        if (isTrue(this.newUpdates))
        {
            return positions;
        }
        return this.filterBySymbolsSinceLimit(this.positions, symbols, since, limit, true);
    }

    public virtual void handlePosition(WebSocketClient client, object message)
    {
        //
        //     {
        //         "e": "outboundContractPositionInfo",
        //         "E": "1723084699801",
        //         "A": "1735619524953226496",
        //         "s": "ETHUSDT-PERPETUAL",
        //         "S": "LONG",
        //         "p": "2429.6",
        //         "P": "2",
        //         "a": "2",
        //         "f": "10760.14",
        //         "m": "1.0085",
        //         "r": "-0.0029",
        //         "up": "0.0478",
        //         "pr": "0.0492",
        //         "pv": "4.8592",
        //         "v": "5.00",
        //         "mt": "CROSS",
        //         "mm": "0.0367"
        //     }
        //
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new ArrayCacheBySymbolBySide();
        }
        object positions = this.positions;
        object parsed = this.parseWsPosition(message);
        callDynamically(positions, "append", new object[] {parsed});
        object messageHash = "positions";
        callDynamically(client as WebSocketClient, "resolve", new object[] {parsed, messageHash});
        object symbol = getValue(parsed, "symbol");
        callDynamically(client as WebSocketClient, "resolve", new object[] {parsed, add(add(messageHash, ":"), symbol)});
    }

    public virtual object parseWsPosition(object position, object market = null)
    {
        object marketId = this.safeString(position, "s");
        market = this.safeMarket(marketId);
        object timestamp = this.safeInteger(position, "E");
        return this.safePosition(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "id", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "contracts", this.safeNumber(position, "P") },
            { "contractSize", null },
            { "side", this.safeStringLower(position, "S") },
            { "notional", this.safeNumber(position, "pv") },
            { "leverage", this.safeInteger(position, "v") },
            { "unrealizedPnl", this.safeNumber(position, "up") },
            { "realizedPnl", this.safeNumber(position, "r") },
            { "collateral", null },
            { "entryPrice", this.safeNumber(position, "p") },
            { "markPrice", null },
            { "liquidationPrice", this.safeNumber(position, "f") },
            { "marginMode", this.safeStringLower(position, "mt") },
            { "hedged", true },
            { "maintenanceMargin", this.safeNumber(position, "mm") },
            { "maintenanceMarginPercentage", null },
            { "initialMargin", this.safeNumber(position, "m") },
            { "initialMarginPercentage", null },
            { "marginRatio", null },
            { "lastUpdateTimestamp", null },
            { "lastPrice", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
            { "percentage", null },
            { "info", position },
        });
    }

    /**
     * @method
     * @name bitmart#watchBalance
     * @description watch balance and get the amount of funds available for trading or funds locked in orders
     * @see https://hashkeyglobal-apidoc.readme.io/reference/websocket-api#private-stream
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] 'spot' or 'swap' - the type of the market to watch balance for (default 'spot')
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object listenKey = await this.authenticate();
        await this.loadMarkets();
        object type = "spot";
        var typeparametersVariable = this.handleMarketTypeAndParams("watchBalance", null, parameters, type);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object messageHash = add("balance:", type);
        object url = this.getPrivateUrl(listenKey);
        var client = this.client(url);
        this.setBalanceCache(client as WebSocketClient, type, messageHash);
        object fetchBalanceSnapshot = null;
        object awaitBalanceSnapshot = null;
        var fetchBalanceSnapshotparametersVariable = this.handleOptionAndParams(this.options, "watchBalance", "fetchBalanceSnapshot", true);
        fetchBalanceSnapshot = ((IList<object>)fetchBalanceSnapshotparametersVariable)[0];
        parameters = ((IList<object>)fetchBalanceSnapshotparametersVariable)[1];
        var awaitBalanceSnapshotparametersVariable = this.handleOptionAndParams(this.options, "watchBalance", "awaitBalanceSnapshot", false);
        awaitBalanceSnapshot = ((IList<object>)awaitBalanceSnapshotparametersVariable)[0];
        parameters = ((IList<object>)awaitBalanceSnapshotparametersVariable)[1];
        if (isTrue(isTrue(fetchBalanceSnapshot) && isTrue(awaitBalanceSnapshot)))
        {
            await client.future(add(type, ":fetchBalanceSnapshot"));
        }
        return await this.watch(url, messageHash, null, messageHash);
    }

    public virtual void setBalanceCache(WebSocketClient client, object type, object subscribeHash)
    {
        if (isTrue(inOp(((WebSocketClient)client).subscriptions, subscribeHash)))
        {
            return;
        }
        object options = this.safeDict(this.options, "watchBalance");
        object snapshot = this.safeBool(options, "fetchBalanceSnapshot", true);
        if (isTrue(snapshot))
        {
            object messageHash = add(add(type, ":"), "fetchBalanceSnapshot");
            if (!isTrue((inOp(client.futures, messageHash))))
            {
                client.future(messageHash);
                this.spawn(this.loadBalanceSnapshot, new object[] { client, messageHash, type});
            }
        }
        ((IDictionary<string,object>)this.balance)[(string)type] = new Dictionary<string, object>() {};
    }

    public async virtual Task loadBalanceSnapshot(WebSocketClient client, object messageHash, object type)
    {
        object response = await this.fetchBalance(new Dictionary<string, object>() {
            { "type", type },
        });
        ((IDictionary<string,object>)this.balance)[(string)type] = this.extend(response, this.safeValue(this.balance, type, new Dictionary<string, object>() {}));
        // don't remove the future from the .futures cache
        var future = getValue(client.futures, messageHash);
        (future as Future).resolve();
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, type), add("balance:", type)});
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        //     {
        //         "e": "outboundContractAccountInfo",        // event type
        //                                                    // outboundContractAccountInfo
        //         "E": "1714717314118",                      // event time
        //         "T": true,                                 // can trade
        //         "W": true,                                 // can withdraw
        //         "D": true,                                 // can deposit
        //         "B": [                                     // balances changed
        //             {
        //                 "a": "USDT",                       // asset
        //                 "f": "474960.65",                  // free amount
        //                 "l": "24835.178056020383226869",   // locked amount
        //                 "r": ""                            // to be released
        //             }
        //         ]
        //     }
        //
        object eventVar = this.safeString(message, "e");
        object data = this.safeList(message, "B", new List<object>() {});
        object balanceUpdate = this.safeDict(data, 0);
        object isSpot = isEqual(eventVar, "outboundAccountInfo");
        object type = ((bool) isTrue(isSpot)) ? "spot" : "swap";
        if (!isTrue((inOp(this.balance, type))))
        {
            ((IDictionary<string,object>)this.balance)[(string)type] = new Dictionary<string, object>() {};
        }
        ((IDictionary<string,object>)getValue(this.balance, type))["info"] = message;
        object currencyId = this.safeString(balanceUpdate, "a");
        object code = this.safeCurrencyCode(currencyId);
        object account = this.account();
        ((IDictionary<string,object>)account)["free"] = this.safeString(balanceUpdate, "f");
        ((IDictionary<string,object>)account)["used"] = this.safeString(balanceUpdate, "l");
        ((IDictionary<string,object>)getValue(this.balance, type))[(string)code] = account;
        ((IDictionary<string,object>)this.balance)[(string)type] = this.safeBalance(getValue(this.balance, type));
        object messageHash = add("balance:", type);
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, type), messageHash});
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object listenKey = this.safeString(this.options, "listenKey");
        if (isTrue(!isEqual(listenKey, null)))
        {
            return listenKey;
        }
        object response = await this.privatePostApiV1UserDataStream(parameters);
        //
        //    {
        //        "listenKey": "atbNEcWnBqnmgkfmYQeTuxKTpTStlZzgoPLJsZhzAOZTbAlxbHqGNWiYaUQzMtDz"
        //    }
        //
        listenKey = this.safeString(response, "listenKey");
        ((IDictionary<string,object>)this.options)["listenKey"] = listenKey;
        object listenKeyRefreshRate = this.safeInteger(this.options, "listenKeyRefreshRate", 3600000);
        this.delay(listenKeyRefreshRate,  this.keepAliveListenKey, new object[] { listenKey, parameters});
        return listenKey;
    }

    public async virtual Task keepAliveListenKey(object listenKey, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(listenKey, null)))
        {
            return;
        }
        object request = new Dictionary<string, object>() {
            { "listenKey", listenKey },
        };
        try
        {
            await this.privatePutApiV1UserDataStream(this.extend(request, parameters));
            object listenKeyRefreshRate = this.safeInteger(this.options, "listenKeyRefreshRate", 1200000);
            this.delay(listenKeyRefreshRate,  this.keepAliveListenKey, new object[] { listenKey, parameters});
        } catch(Exception error)
        {
            object url = this.getPrivateUrl(listenKey);
            var client = this.client(url);
            ((IDictionary<string,object>)this.options)["listenKey"] = null;
            ((WebSocketClient)client).reject(error);
            ((IDictionary<string, ccxt.Exchange.WebSocketClient>)this.clients).Remove((string)url);
        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (isTrue(((message is IList<object>) || (message.GetType().IsGenericType && message.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            message = this.safeDict(message, 0, new Dictionary<string, object>() {});
        }
        object topic = this.safeString2(message, "topic", "e");
        if (isTrue(isEqual(topic, "kline")))
        {
            this.handleOHLCV(client as WebSocketClient, message);
        } else if (isTrue(isEqual(topic, "realtimes")))
        {
            this.handleTicker(client as WebSocketClient, message);
        } else if (isTrue(isEqual(topic, "trade")))
        {
            this.handleTrades(client as WebSocketClient, message);
        } else if (isTrue(isEqual(topic, "depth")))
        {
            this.handleOrderBook(client as WebSocketClient, message);
        } else if (isTrue(isTrue((isEqual(topic, "contractExecutionReport"))) || isTrue((isEqual(topic, "executionReport")))))
        {
            this.handleOrder(client as WebSocketClient, message);
        } else if (isTrue(isEqual(topic, "ticketInfo")))
        {
            this.handleMyTrade(client as WebSocketClient, message);
        } else if (isTrue(isEqual(topic, "outboundContractPositionInfo")))
        {
            this.handlePosition(client as WebSocketClient, message);
        } else if (isTrue(isTrue((isEqual(topic, "outboundAccountInfo"))) || isTrue((isEqual(topic, "outboundContractAccountInfo")))))
        {
            this.handleBalance(client as WebSocketClient, message);
        }
    }
}
