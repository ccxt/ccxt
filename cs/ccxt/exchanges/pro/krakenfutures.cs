namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class krakenfutures { public krakenfutures(object args = null) : base(args) { } }
public partial class krakenfutures : ccxt.krakenfutures
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "cancelAllOrdersWs", false },
                { "cancelOrdersWs", false },
                { "cancelOrderWs", false },
                { "createOrderWs", false },
                { "editOrderWs", false },
                { "fetchBalanceWs", false },
                { "fetchOpenOrdersWs", false },
                { "fetchOrderWs", false },
                { "fetchTradesWs", false },
                { "watchOHLCV", false },
                { "watchOrderBook", true },
                { "watchOrderBookForSymbols", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchBidsAsks", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
                { "watchBalance", true },
                { "watchOrders", true },
                { "watchMyTrades", true },
                { "watchPositions", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", "wss://futures.kraken.com/ws/v1" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "ws", "wss://demo-futures.kraken.com/ws/v1" },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "tradesLimit", 1000 },
                { "ordersLimit", 1000 },
                { "OHLCVLimit", 1000 },
                { "connectionLimit", 100 },
                { "requestLimit", 100 },
                { "fetchBalance", new Dictionary<string, object>() {
                    { "type", null },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "keepAlive", 30000 },
            } },
        });
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        /**
        * @ignore
        * @method
        * @description authenticates the user to access private web socket channels
        * @see https://docs.futures.kraken.com/#websocket-api-public-feeds-challenge
        * @returns {object} response from exchange
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        // Hash the challenge with the SHA-256 algorithm
        // Base64-decode your api_secret
        // Use the result of step 2 to hash the result of step 1 with the HMAC-SHA-512 algorithm
        // Base64-encode the result of step 3
        object url = getValue(getValue(this.urls, "api"), "ws");
        object messageHash = "challenge";
        var client = this.client(url);
        var future = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(future, null)))
        {
            object request = new Dictionary<string, object>() {
                { "event", "challenge" },
                { "api_key", this.apiKey },
            };
            object message = this.extend(request, parameters);
            future = await this.watch(url, messageHash, message, messageHash);
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)messageHash] = future;
        }
        return future;
    }

    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name krakenfutures#watchOrderBookForSymbols
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://docs.futures.kraken.com/#websocket-api-public-feeds-challenge
        * @param {string[]} symbols unified array of symbols
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        object orderbook = await this.watchMultiHelper("orderbook", "book", symbols, new Dictionary<string, object>() {
            { "limit", limit },
        }, parameters);
        return (orderbook as IOrderBook).limit();
    }

    public async virtual Task<object> subscribePublic(object name, object symbols, object parameters = null)
    {
        /**
        * @ignore
        * @method
        * @description Connects to a websocket channel
        * @param {string} name name of the channel
        * @param {string[]} symbols CCXT market symbols
        * @param {object} [params] extra parameters specific to the krakenfutures api
        * @returns {object} data from the websocket stream
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object url = getValue(getValue(this.urls, "api"), "ws");
        object subscribe = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "feed", name },
        };
        object marketIds = new List<object>() {};
        object messageHash = name;
        if (isTrue(isEqual(symbols, null)))
        {
            symbols = new List<object>() {};
        }
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            ((IList<object>)marketIds).Add(this.marketId(symbol));
        }
        object length = getArrayLength(symbols);
        if (isTrue(isEqual(length, 1)))
        {
            object market = this.market(getValue(marketIds, 0));
            messageHash = add(add(messageHash, ":"), getValue(market, "symbol"));
        }
        ((IDictionary<string,object>)subscribe)["product_ids"] = marketIds;
        object request = this.extend(subscribe, parameters);
        return await this.watch(url, messageHash, request, messageHash);
    }

    public async virtual Task<object> subscribePrivate(object name, object messageHash, object parameters = null)
    {
        /**
        * @ignore
        * @method
        * @description Connects to a websocket channel
        * @param {string} name name of the channel
        * @param {string[]} symbols CCXT market symbols
        * @param {object} [params] extra parameters specific to the krakenfutures api
        * @returns {object} data from the websocket stream
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate();
        object url = getValue(getValue(this.urls, "api"), "ws");
        object subscribe = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "feed", name },
            { "api_key", this.apiKey },
            { "original_challenge", getValue(this.options, "challenge") },
            { "signed_challenge", getValue(this.options, "signedChallenge") },
        };
        object request = this.extend(subscribe, parameters);
        return await this.watch(url, messageHash, request, messageHash);
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name krakenfutures#watchTicker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://docs.futures.kraken.com/#websocket-api-public-feeds-ticker
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbol = this.symbol(symbol);
        object tickers = await this.watchTickers(new List<object>() {symbol}, parameters);
        return getValue(tickers, symbol);
    }

    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name krakenfutures#watchTickers
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://docs.futures.kraken.com/#websocket-api-public-feeds-ticker
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object ticker = await this.watchMultiHelper("ticker", "ticker", symbols, null, parameters);
        if (isTrue(this.newUpdates))
        {
            object result = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)result)[(string)getValue(ticker, "symbol")] = ticker;
            return result;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    public async override Task<object> watchBidsAsks(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name krakenfutures#watchBidsAsks
        * @see https://docs.futures.kraken.com/#websocket-api-public-feeds-ticker-lite
        * @description watches best bid & ask for symbols
        * @param {string[]} symbols unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object ticker = await this.watchMultiHelper("bidask", "ticker_lite", symbols, null, parameters);
        if (isTrue(this.newUpdates))
        {
            object result = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)result)[(string)getValue(ticker, "symbol")] = ticker;
            return result;
        }
        return this.filterByArray(this.bidsasks, "symbol", symbols);
    }

    public async override Task<object> watchTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name krakenfutures#watchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://docs.futures.kraken.com/#websocket-api-public-feeds-trade
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name krakenfutures#watchTradesForSymbols
        * @see https://docs.futures.kraken.com/#websocket-api-public-feeds-trade
        * @description get the list of most recent trades for a list of symbols
        * @param {string[]} symbols unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        object trades = await this.watchMultiHelper("trade", "trade", symbols, null, parameters);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeList(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name krakenfutures#watchOrderBook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://docs.futures.kraken.com/#websocket-api-public-feeds-book
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] not used by krakenfutures watchOrderBook
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchOrderBookForSymbols(new List<object>() {symbol}, limit, parameters);
    }

    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name krakenfutures#watchPositions
        * @see https://docs.futures.kraken.com/#websocket-api-private-feeds-open-positions
        * @description watch all open positions
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object messageHash = "";
        symbols = this.marketSymbols(symbols);
        if (!isTrue(this.isEmpty(symbols)))
        {
            messageHash = add("::", String.Join(",", ((IList<object>)symbols).ToArray()));
        }
        messageHash = add("positions", messageHash);
        object newPositions = await this.subscribePrivate("open_positions", messageHash, parameters);
        if (isTrue(this.newUpdates))
        {
            return newPositions;
        }
        return this.filterBySymbolsSinceLimit(this.positions, symbols, since, limit, true);
    }

    public virtual void handlePositions(WebSocketClient client, object message)
    {
        //
        //    {
        //        feed: 'open_positions',
        //        account: '3b111acc-4fcc-45be-a622-57e611fe9f7f',
        //        positions: [
        //            {
        //                instrument: 'PF_LTCUSD',
        //                balance: 0.5,
        //                pnl: -0.8628305877699987,
        //                entry_price: 70.53,
        //                mark_price: 68.80433882446,
        //                index_price: 68.8091,
        //                liquidation_threshold: 0,
        //                effective_leverage: 0.007028866753648637,
        //                return_on_equity: -1.2233525985679834,
        //                unrealized_funding: 0.0000690610530935388,
        //                initial_margin: 0.7053,
        //                initial_margin_with_orders: 0.7053,
        //                maintenance_margin: 0.35265,
        //                pnl_currency: 'USD'
        //            }
        //        ],
        //        seq: 0,
        //        timestamp: 1698608414910
        //    }
        //
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new ArrayCacheBySymbolById();
        }
        object cache = this.positions;
        object rawPositions = this.safeValue(message, "positions", new List<object>() {});
        object newPositions = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rawPositions)); postFixIncrement(ref i))
        {
            object rawPosition = getValue(rawPositions, i);
            object position = this.parseWsPosition(rawPosition);
            object timestamp = this.safeInteger(message, "timestamp");
            ((IDictionary<string,object>)position)["timestamp"] = timestamp;
            ((IDictionary<string,object>)position)["datetime"] = this.iso8601(timestamp);
            ((IList<object>)newPositions).Add(position);
            callDynamically(cache, "append", new object[] {position});
        }
        object messageHashes = this.findMessageHashes(client as WebSocketClient, "positions::");
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object positions = this.filterByArray(newPositions, "symbol", symbols, false);
            if (!isTrue(this.isEmpty(positions)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {positions, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newPositions, "positions"});
    }

    public virtual object parseWsPosition(object position, object market = null)
    {
        //
        //        {
        //            instrument: 'PF_LTCUSD',
        //            balance: 0.5,
        //            pnl: -0.8628305877699987,
        //            entry_price: 70.53,
        //            mark_price: 68.80433882446,
        //            index_price: 68.8091,
        //            liquidation_threshold: 0,
        //            effective_leverage: 0.007028866753648637,
        //            return_on_equity: -1.2233525985679834,
        //            unrealized_funding: 0.0000690610530935388,
        //            initial_margin: 0.7053,
        //            initial_margin_with_orders: 0.7053,
        //            maintenance_margin: 0.35265,
        //            pnl_currency: 'USD'
        //        }
        //
        object marketId = this.safeString(position, "instrument");
        object hedged = "both";
        object balance = this.safeNumber(position, "balance");
        object side = ((bool) isTrue((isGreaterThan(balance, 0)))) ? "long" : "short";
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", this.safeSymbol(marketId) },
            { "notional", null },
            { "marginMode", null },
            { "liquidationPrice", this.safeNumber(position, "liquidation_threshold") },
            { "entryPrice", this.safeNumber(position, "entry_price") },
            { "unrealizedPnl", this.safeNumber(position, "pnl") },
            { "percentage", this.safeNumber(position, "return_on_equity") },
            { "contracts", this.parseNumber(Precise.stringAbs(this.numberToString(balance))) },
            { "contractSize", null },
            { "markPrice", this.safeNumber(position, "mark_price") },
            { "side", side },
            { "hedged", hedged },
            { "timestamp", null },
            { "datetime", null },
            { "maintenanceMargin", this.safeNumber(position, "maintenance_margin") },
            { "maintenanceMarginPercentage", null },
            { "collateral", null },
            { "initialMargin", this.safeNumber(position, "initial_margin") },
            { "initialMarginPercentage", null },
            { "leverage", null },
            { "marginRatio", null },
        });
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name krakenfutures#watchOrders
        * @description watches information on multiple orders made by the user
        * @see https://docs.futures.kraken.com/#websocket-api-private-feeds-open-orders
        * @see https://docs.futures.kraken.com/#websocket-api-private-feeds-open-orders-verbose
        * @param {string} symbol not used by krakenfutures watchOrders
        * @param {int} [since] not used by krakenfutures watchOrders
        * @param {int} [limit] not used by krakenfutures watchOrders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "open_orders";
        object messageHash = "orders";
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            messageHash = add(messageHash, add(":", getValue(market, "symbol")));
        }
        object orders = await this.subscribePrivate(name, messageHash, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(orders, since, limit, "timestamp", true);
    }

    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name krakenfutures#watchMyTrades
        * @description watches information on multiple trades made by the user
        * @see https://docs.futures.kraken.com/#websocket-api-private-feeds-fills
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "fills";
        object messageHash = "myTrades";
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            messageHash = add(messageHash, add(":", getValue(market, "symbol")));
        }
        object trades = await this.subscribePrivate(name, messageHash, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @name krakenfutures#watchOrders
        * @description watches information on multiple orders made by the user
        * @see https://docs.futures.kraken.com/#websocket-api-private-feeds-balances
        * @param {string} symbol not used by krakenfutures watchBalance
        * @param {int} [since] not used by krakenfutures watchBalance
        * @param {int} [limit] not used by krakenfutures watchBalance
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.account] can be either 'futures' or 'flex_futures'
        * @returns {object} a object of wallet types each with a balance structure {@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "balances";
        object messageHash = name;
        object account = null;
        var accountparametersVariable = this.handleOptionAndParams(parameters, "watchBalance", "account");
        account = ((IList<object>)accountparametersVariable)[0];
        parameters = ((IList<object>)accountparametersVariable)[1];
        if (isTrue(!isEqual(account, null)))
        {
            if (isTrue(isTrue(!isEqual(account, "futures")) && isTrue(!isEqual(account, "flex_futures"))))
            {
                throw new ArgumentsRequired ((string)add(this.id, " watchBalance account must be either \'futures\' or \'flex_futures\'")) ;
            }
            messageHash = add(messageHash, add(":", account));
        }
        return await this.subscribePrivate(name, messageHash, parameters);
    }

    public virtual void handleTrade(WebSocketClient client, object message)
    {
        //
        // snapshot
        //
        //    {
        //        "feed": "trade_snapshot",
        //        "product_id": "PI_XBTUSD",
        //        "trades": [
        //            {
        //                "feed": "trade",
        //                "product_id": "PI_XBTUSD",
        //                "uid": "caa9c653-420b-4c24-a9f1-462a054d86f1",
        //                "side": "sell",
        //                "type": "fill",
        //                "seq": 655508,
        //                "time": 1612269657781,
        //                "qty": 440,
        //                "price": 34893
        //            },
        //            ...
        //        ]
        //    }
        //
        // update
        //
        //    {
        //        "feed": "trade",
        //        "product_id": "PI_XBTUSD",
        //        "uid": "05af78ac-a774-478c-a50c-8b9c234e071e",
        //        "side": "sell",
        //        "type": "fill",
        //        "seq": 653355,
        //        "time": 1612266317519,
        //        "qty": 15000,
        //        "price": 34969.5
        //    }
        //
        object channel = this.safeString(message, "feed");
        object marketId = this.safeString(message, "product_id");
        if (isTrue(!isEqual(marketId, null)))
        {
            object market = this.market(marketId);
            object symbol = getValue(market, "symbol");
            object messageHash = this.getMessageHash("trade", null, symbol);
            if (isTrue(isEqual(this.safeList(this.trades, symbol), null)))
            {
                object tradesLimit = this.safeInteger(this.options, "tradesLimit", 1000);
                ((IDictionary<string,object>)this.trades)[(string)symbol] = new ArrayCache(tradesLimit);
            }
            object tradesArray = getValue(this.trades, symbol);
            if (isTrue(isEqual(channel, "trade_snapshot")))
            {
                object trades = this.safeList(message, "trades", new List<object>() {});
                object length = getArrayLength(trades);
                for (object i = 0; isLessThan(i, length); postFixIncrement(ref i))
                {
                    object index = subtract(subtract(length, 1), i); // need reverse to correct chronology
                    object item = getValue(trades, index);
                    object trade = this.parseWsTrade(item);
                    callDynamically(tradesArray, "append", new object[] {trade});
                }
            } else
            {
                object trade = this.parseWsTrade(message);
                callDynamically(tradesArray, "append", new object[] {trade});
            }
            callDynamically(client as WebSocketClient, "resolve", new object[] {tradesArray, messageHash});
        }
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        //    {
        //        "feed": "trade",
        //        "product_id": "PI_XBTUSD",
        //        "uid": "caa9c653-420b-4c24-a9f1-462a054d86f1",
        //        "side": "sell",
        //        "type": "fill",
        //        "seq": 655508,
        //        "time": 1612269657781,
        //        "qty": 440,
        //        "price": 34893
        //    }
        //
        object marketId = this.safeString(trade, "product_id");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(trade, "time");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString(trade, "uid") },
            { "symbol", this.safeString(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "order", null },
            { "type", this.safeString(trade, "type") },
            { "side", this.safeString(trade, "side") },
            { "takerOrMaker", "taker" },
            { "price", this.safeString(trade, "price") },
            { "amount", this.safeString(trade, "qty") },
            { "cost", null },
            { "fee", new Dictionary<string, object>() {
                { "rate", null },
                { "cost", null },
                { "currency", null },
            } },
        }, market);
    }

    public override object parseWsOrderTrade(object trade, object market = null)
    {
        //
        //    {
        //        "symbol": "BTC_USDT",
        //        "type": "LIMIT",
        //        "quantity": "1",
        //        "orderId": "32471407854219264",
        //        "tradeFee": "0",
        //        "clientOrderId": "",
        //        "accountType": "SPOT",
        //        "feeCurrency": "",
        //        "eventType": "place",
        //        "source": "API",
        //        "side": "BUY",
        //        "filledQuantity": "0",
        //        "filledAmount": "0",
        //        "matchRole": "MAKER",
        //        "state": "NEW",
        //        "tradeTime": 0,
        //        "tradeAmount": "0",
        //        "orderAmount": "0",
        //        "createTime": 1648708186922,
        //        "price": "47112.1",
        //        "tradeQty": "0",
        //        "tradePrice": "0",
        //        "tradeId": "0",
        //        "ts": 1648708187469
        //    }
        //
        object timestamp = this.safeInteger(trade, "tradeTime");
        object marketId = this.safeString(trade, "symbol");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString(trade, "tradeId") },
            { "symbol", this.safeSymbol(marketId, market) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "order", this.safeString(trade, "orderId") },
            { "type", this.safeStringLower(trade, "type") },
            { "side", this.safeString(trade, "side") },
            { "takerOrMaker", this.safeString(trade, "matchRole") },
            { "price", this.safeString(trade, "price") },
            { "amount", this.safeString(trade, "tradeAmount") },
            { "cost", null },
            { "fee", new Dictionary<string, object>() {
                { "rate", null },
                { "cost", this.safeString(trade, "tradeFee") },
                { "currency", this.safeString(trade, "feeCurrency") },
            } },
        }, market);
    }

    public virtual object handleOrder(WebSocketClient client, object message)
    {
        //
        //  update (verbose)
        //
        //    {
        //        "feed": "open_orders_verbose",
        //        "order": {
        //            "instrument": "PI_XBTUSD",
        //            "time": 1567597581495,
        //            "last_update_time": 1567597581495,
        //            "qty": 102.0,
        //            "filled": 0.0,
        //            "limit_price": 10601.0,
        //            "stop_price": 0.0,
        //            "type": "limit",
        //            "order_id": "fa9806c9-cba9-4661-9f31-8c5fd045a95d",
        //            "direction": 0,
        //            "reduce_only": false
        //        },
        //        "is_cancel": true,
        //        "reason": "post_order_failed_because_it_would_be_filled"
        //    }
        //
        // update
        //
        //    {
        //        "feed": "open_orders",
        //        "order": {
        //          "instrument": "PI_XBTUSD",
        //          "time": 1567702877410,
        //          "last_update_time": 1567702877410,
        //          "qty": 304.0,
        //          "filled": 0.0,
        //          "limit_price": 10640.0,
        //          "stop_price": 0.0,
        //          "type": "limit",
        //          "order_id": "59302619-41d2-4f0b-941f-7e7914760ad3",
        //          "direction": 1,
        //          "reduce_only": true
        //        },
        //        "is_cancel": false,
        //        "reason": "new_placed_order_by_user"
        //    }
        //    {
        //        "feed": "open_orders",
        //        "order_id": "ea8a7144-37db-449b-bb4a-b53c814a0f43",
        //        "is_cancel": true,
        //        "reason": "cancelled_by_user"
        //    }
        //
        //     {
        //         "feed": 'open_orders',
        //         "order": {
        //         "instrument": 'PF_XBTUSD',
        //         "time": 1698159920097,
        //         "last_update_time": 1699835622988,
        //         "qty": 1.1,
        //         "filled": 0,
        //         "limit_price": 20000,
        //         "stop_price": 0,
        //         "type": 'limit',
        //         "order_id": '0eaf02b0-855d-4451-a3b7-e2b3070c1fa4',
        //         "direction": 0,
        //         "reduce_only": false
        //         },
        //         "is_cancel": false,
        //         "reason": 'edited_by_user'
        //     }
        //
        object orders = this.orders;
        if (isTrue(isEqual(orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit");
            orders = new ArrayCacheBySymbolById(limit);
            this.orders = orders;
        }
        object order = this.safeValue(message, "order");
        if (isTrue(!isEqual(order, null)))
        {
            object marketId = this.safeString(order, "instrument");
            object messageHash = "orders";
            object symbol = this.safeSymbol(marketId);
            object orderId = this.safeString(order, "order_id");
            object previousOrders = this.safeValue((orders as ArrayCacheBySymbolById).hashmap, symbol, new Dictionary<string, object>() {});
            object previousOrder = this.safeValue(previousOrders, orderId);
            object reason = this.safeString(message, "reason");
            if (isTrue(isTrue((isEqual(previousOrder, null))) || isTrue((isEqual(reason, "edited_by_user")))))
            {
                object parsed = this.parseWsOrder(order);
                callDynamically(orders, "append", new object[] {parsed});
                callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
                callDynamically(client as WebSocketClient, "resolve", new object[] {orders, add(add(messageHash, ":"), symbol)});
            } else
            {
                object trade = this.parseWsTrade(order);
                if (isTrue(isEqual(getValue(previousOrder, "trades"), null)))
                {
                    ((IDictionary<string,object>)previousOrder)["trades"] = new List<object>() {};
                }
                ((IList<object>)getValue(previousOrder, "trades")).Add(trade);
                ((IDictionary<string,object>)previousOrder)["lastTradeTimestamp"] = getValue(trade, "timestamp");
                object totalCost = "0";
                object totalAmount = "0";
                object trades = getValue(previousOrder, "trades");
                for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
                {
                    object currentTrade = getValue(trades, i);
                    totalCost = Precise.stringAdd(totalCost, this.numberToString(getValue(currentTrade, "cost")));
                    totalAmount = Precise.stringAdd(totalAmount, this.numberToString(getValue(currentTrade, "amount")));
                }
                if (isTrue(Precise.stringGt(totalAmount, "0")))
                {
                    ((IDictionary<string,object>)previousOrder)["average"] = Precise.stringDiv(totalCost, totalAmount);
                }
                ((IDictionary<string,object>)previousOrder)["cost"] = totalCost;
                if (isTrue(!isEqual(getValue(previousOrder, "filled"), null)))
                {
                    object stringOrderFilled = this.numberToString(getValue(previousOrder, "filled"));
                    ((IDictionary<string,object>)previousOrder)["filled"] = Precise.stringAdd(stringOrderFilled, this.numberToString(getValue(trade, "amount")));
                    if (isTrue(!isEqual(getValue(previousOrder, "amount"), null)))
                    {
                        ((IDictionary<string,object>)previousOrder)["remaining"] = Precise.stringSub(this.numberToString(getValue(previousOrder, "amount")), stringOrderFilled);
                    }
                }
                if (isTrue(isEqual(getValue(previousOrder, "fee"), null)))
                {
                    ((IDictionary<string,object>)previousOrder)["fee"] = new Dictionary<string, object>() {
                        { "rate", null },
                        { "cost", "0" },
                        { "currency", this.numberToString(getValue(getValue(trade, "fee"), "currency")) },
                    };
                }
                if (isTrue(isTrue((!isEqual(getValue(getValue(previousOrder, "fee"), "cost"), null))) && isTrue((!isEqual(getValue(getValue(trade, "fee"), "cost"), null)))))
                {
                    object stringOrderCost = this.numberToString(getValue(getValue(previousOrder, "fee"), "cost"));
                    object stringTradeCost = this.numberToString(getValue(getValue(trade, "fee"), "cost"));
                    ((IDictionary<string,object>)getValue(previousOrder, "fee"))["cost"] = Precise.stringAdd(stringOrderCost, stringTradeCost);
                }
                // update the newUpdates count
                callDynamically(orders, "append", new object[] {this.safeOrder(previousOrder)});
                callDynamically(client as WebSocketClient, "resolve", new object[] {orders, add(add(messageHash, ":"), symbol)});
                callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
            }
        } else
        {
            object isCancel = this.safeValue(message, "is_cancel");
            if (isTrue(isCancel))
            {
                // get order without symbol
                for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
                {
                    object currentOrder = getValue(orders, i);
                    if (isTrue(isEqual(getValue(currentOrder, "id"), getValue(message, "order_id"))))
                    {
                        ((List<object>)orders)[Convert.ToInt32(i)] = this.extend(currentOrder, new Dictionary<string, object>() {
                            { "status", "canceled" },
                        });
                        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, "orders"});
                        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, add("orders:", getValue(currentOrder, "symbol"))});
                        break;
                    }
                }
            }
        }
        return message;
    }

    public virtual void handleOrderSnapshot(WebSocketClient client, object message)
    {
        //
        // verbose
        //
        //    {
        //        "feed": "open_orders_verbose_snapshot",
        //        "account": "0f9c23b8-63e2-40e4-9592-6d5aa57c12ba",
        //        "orders": [
        //            {
        //                "instrument": "PI_XBTUSD",
        //                "time": 1567428848005,
        //                "last_update_time": 1567428848005,
        //                "qty": 100.0,
        //                "filled": 0.0,
        //                "limit_price": 8500.0,
        //                "stop_price": 0.0,
        //                "type": "limit",
        //                "order_id": "566942c8-a3b5-4184-a451-622b09493129",
        //                "direction": 0,
        //                "reduce_only": false
        //            },
        //            ...
        //        ]
        //    }
        //
        // regular
        //
        //    {
        //        "feed": "open_orders_snapshot",
        //        "account": "e258dba9-4dd4-4da5-bfef-75beb91c098e",
        //        "orders": [
        //            {
        //                "instrument": "PI_XBTUSD",
        //                "time": 1612275024153,
        //                "last_update_time": 1612275024153,
        //                "qty": 1000,
        //                "filled": 0,
        //                "limit_price": 34900,
        //                "stop_price": 13789,
        //                "type": "stop",
        //                "order_id": "723ba95f-13b7-418b-8fcf-ab7ba6620555",
        //                "direction": 1,
        //                "reduce_only": false,
        //                "triggerSignal": "last"
        //            },
        //            ...
        //        ]
        //    }
        object orders = this.safeValue(message, "orders", new List<object>() {});
        object limit = this.safeInteger(this.options, "ordersLimit");
        this.orders = new ArrayCacheBySymbolById(limit);
        object symbols = new Dictionary<string, object>() {};
        object cachedOrders = this.orders;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object order = getValue(orders, i);
            object parsed = this.parseWsOrder(order);
            object symbol = getValue(parsed, "symbol");
            ((IDictionary<string,object>)symbols)[(string)symbol] = true;
            callDynamically(cachedOrders, "append", new object[] {parsed});
        }
        object length = getArrayLength(this.orders);
        if (isTrue(isGreaterThan(length, 0)))
        {
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, "orders"});
            object keys = new List<object>(((IDictionary<string,object>)symbols).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
            {
                object symbol = getValue(keys, i);
                object messageHash = add("orders:", symbol);
                callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageHash});
            }
        }
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        // update
        //
        //    {
        //        "feed": "open_orders_verbose",
        //        "order": {
        //            "instrument": "PI_XBTUSD",
        //            "time": 1567597581495,
        //            "last_update_time": 1567597581495,
        //            "qty": 102.0,
        //            "filled": 0.0,
        //            "limit_price": 10601.0,
        //            "stop_price": 0.0,
        //            "type": "limit",
        //            "order_id": "fa9806c9-cba9-4661-9f31-8c5fd045a95d",
        //            "direction": 0,
        //            "reduce_only": false
        //        },
        //        "is_cancel": true,
        //        "reason": "post_order_failed_because_it_would_be_filled"
        //    }
        //
        // snapshot
        //
        //    {
        //        "instrument": "PI_XBTUSD",
        //        "time": 1567597581495,
        //        "last_update_time": 1567597581495,
        //        "qty": 102.0,
        //        "filled": 0.0,
        //        "limit_price": 10601.0,
        //        "stop_price": 0.0,
        //        "type": "limit",
        //        "order_id": "fa9806c9-cba9-4661-9f31-8c5fd045a95d",
        //        "direction": 0,
        //        "reduce_only": false
        //    }
        //
        object isCancelled = this.safeValue(order, "is_cancel");
        object unparsedOrder = order;
        object status = null;
        if (isTrue(!isEqual(isCancelled, null)))
        {
            unparsedOrder = this.safeValue(order, "order");
            if (isTrue(isEqual(isCancelled, true)))
            {
                status = "cancelled";
            }
        }
        object marketId = this.safeString(unparsedOrder, "instrument");
        object timestamp = this.safeString(unparsedOrder, "time");
        object direction = this.safeInteger(unparsedOrder, "direction");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "symbol", this.safeSymbol(marketId, market) },
            { "id", this.safeString(unparsedOrder, "order_id") },
            { "clientOrderId", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "type", this.safeString(unparsedOrder, "type") },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", ((bool) isTrue((isEqual(direction, 0)))) ? "buy" : "sell" },
            { "price", this.safeString(unparsedOrder, "limit_price") },
            { "stopPrice", this.safeString(unparsedOrder, "stop_price") },
            { "triggerPrice", this.safeString(unparsedOrder, "stop_price") },
            { "amount", this.safeString(unparsedOrder, "qty") },
            { "cost", null },
            { "average", null },
            { "filled", this.safeString(unparsedOrder, "filled") },
            { "remaining", null },
            { "status", status },
            { "fee", new Dictionary<string, object>() {
                { "rate", null },
                { "cost", null },
                { "currency", null },
            } },
            { "trades", null },
        });
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        //    {
        //        "time": 1680811086487,
        //        "product_id": "PI_XBTUSD",
        //        "funding_rate": 7.792297e-12,
        //        "funding_rate_prediction": -4.2671095e-11,
        //        "relative_funding_rate": 2.18013888889e-7,
        //        "relative_funding_rate_prediction": -0.0000011974,
        //        "next_funding_rate_time": 1680811200000,
        //        "feed": "ticker",
        //        "bid": 28060,
        //        "ask": 28070,
        //        "bid_size": 2844,
        //        "ask_size": 1902,
        //        "volume": 19628180,
        //        "dtm": 0,
        //        "leverage": "50x",
        //        "index": 28062.14,
        //        "premium": 0,
        //        "last": 28053.5,
        //        "change": -0.7710945651981715,
        //        "suspended": false,
        //        "tag": "perpetual",
        //        "pair": "XBT:USD",
        //        "openInterest": 28875946,
        //        "markPrice": 28064.92082724592,
        //        "maturityTime": 0,
        //        "post_only": false,
        //        "volumeQuote": 19628180
        //    }
        //
        object marketId = this.safeString(message, "product_id");
        if (isTrue(!isEqual(marketId, null)))
        {
            object ticker = this.parseWsTicker(message);
            object symbol = getValue(ticker, "symbol");
            ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
            object messageHash = this.getMessageHash("ticker", null, symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
        }
    }

    public virtual void handleBidAsk(WebSocketClient client, object message)
    {
        //
        //    {
        //        "feed": "ticker_lite",
        //        "product_id": "FI_ETHUSD_210625",
        //        "bid": 1753.45,
        //        "ask": 1760.35,
        //        "change": 13.448175559936647,
        //        "premium": 9.1,
        //        "volume": 6899673.0,
        //        "tag": "semiannual",
        //        "pair": "ETH:USD",
        //        "dtm": 141,
        //        "maturityTime": 1624633200000,
        //        "volumeQuote": 6899673.0
        //    }
        //
        object marketId = this.safeString(message, "product_id");
        if (isTrue(!isEqual(marketId, null)))
        {
            object ticker = this.parseWsTicker(message);
            object symbol = getValue(ticker, "symbol");
            ((IDictionary<string,object>)this.bidsasks)[(string)symbol] = ticker;
            object messageHash = this.getMessageHash("bidask", null, symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
        }
    }

    public virtual object parseWsTicker(object ticker, object market = null)
    {
        //
        //    {
        //        "time": 1680811086487,
        //        "product_id": "PI_XBTUSD",
        //        "funding_rate": 7.792297e-12,
        //        "funding_rate_prediction": -4.2671095e-11,
        //        "relative_funding_rate": 2.18013888889e-7,
        //        "relative_funding_rate_prediction": -0.0000011974,
        //        "next_funding_rate_time": 1680811200000,
        //        "feed": "ticker",
        //        "bid": 28060,
        //        "ask": 28070,
        //        "bid_size": 2844,
        //        "ask_size": 1902,
        //        "volume": 19628180,
        //        "dtm": 0,
        //        "leverage": "50x",
        //        "index": 28062.14,
        //        "premium": 0,
        //        "last": 28053.5,
        //        "change": -0.7710945651981715,
        //        "suspended": false,
        //        "tag": "perpetual",
        //        "pair": "XBT:USD",
        //        "openInterest": 28875946,
        //        "markPrice": 28064.92082724592,
        //        "maturityTime": 0,
        //        "post_only": false,
        //        "volumeQuote": 19628180
        //    }
        //
        // ticker_lite
        //
        //    {
        //        "feed": "ticker_lite",
        //        "product_id": "FI_ETHUSD_210625",
        //        "bid": 1753.45,
        //        "ask": 1760.35,
        //        "change": 13.448175559936647,
        //        "premium": 9.1,
        //        "volume": 6899673.0,
        //        "tag": "semiannual",
        //        "pair": "ETH:USD",
        //        "dtm": 141,
        //        "maturityTime": 1624633200000,
        //        "volumeQuote": 6899673.0
        //    }
        //
        object marketId = this.safeString(ticker, "product_id");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object timestamp = this.parse8601(this.safeString(ticker, "lastTime"));
        object last = this.safeString(ticker, "last");
        return this.safeTicker(new Dictionary<string, object>() {
            { "info", ticker },
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", null },
            { "low", null },
            { "bid", this.safeString(ticker, "bid") },
            { "bidVolume", this.safeString(ticker, "bid_size") },
            { "ask", this.safeString(ticker, "ask") },
            { "askVolume", this.safeString(ticker, "ask_size") },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", this.safeString(ticker, "change") },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "volume") },
            { "quoteVolume", this.safeString(ticker, "volumeQuote") },
        });
    }

    public virtual void handleOrderBookSnapshot(WebSocketClient client, object message)
    {
        //
        //    {
        //        "feed": "book_snapshot",
        //        "product_id": "PI_XBTUSD",
        //        "timestamp": 1612269825817,
        //        "seq": 326072249,
        //        "tickSize": null,
        //        "bids": [
        //            {
        //                "price": 34892.5,
        //                "qty": 6385
        //            },
        //            {
        //                "price": 34892,
        //                "qty": 10924
        //            },
        //        ],
        //        "asks": [
        //            {
        //                "price": 34911.5,
        //                "qty": 20598
        //            },
        //            {
        //                "price": 34912,
        //                "qty": 2300
        //            },
        //        ]
        //    }
        //
        object marketId = this.safeString(message, "product_id");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object messageHash = this.getMessageHash("orderbook", null, symbol);
        object subscription = this.safeDict(((WebSocketClient)client).subscriptions, messageHash, new Dictionary<string, object>() {});
        object limit = this.safeInteger(subscription, "limit");
        object timestamp = this.safeInteger(message, "timestamp");
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
        object orderbook = getValue(this.orderbooks, symbol);
        object bids = this.safeList(message, "bids");
        object asks = this.safeList(message, "asks");
        for (object i = 0; isLessThan(i, getArrayLength(bids)); postFixIncrement(ref i))
        {
            object bid = getValue(bids, i);
            object price = this.safeNumber(bid, "price");
            object qty = this.safeNumber(bid, "qty");
            object bidsSide = getValue(orderbook, "bids");
            (bidsSide as IOrderBookSide).store(price, qty);
        }
        for (object i = 0; isLessThan(i, getArrayLength(asks)); postFixIncrement(ref i))
        {
            object ask = getValue(asks, i);
            object price = this.safeNumber(ask, "price");
            object qty = this.safeNumber(ask, "qty");
            object asksSide = getValue(orderbook, "asks");
            (asksSide as IOrderBookSide).store(price, qty);
        }
        ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
        ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        ((IDictionary<string,object>)orderbook)["symbol"] = symbol;
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //    {
        //        "feed": "book",
        //        "product_id": "PI_XBTUSD",
        //        "side": "sell",
        //        "seq": 326094134,
        //        "price": 34981,
        //        "qty": 0,
        //        "timestamp": 1612269953629
        //    }
        //
        object marketId = this.safeString(message, "product_id");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object messageHash = this.getMessageHash("orderbook", null, symbol);
        object orderbook = getValue(this.orderbooks, symbol);
        object side = this.safeString(message, "side");
        object price = this.safeNumber(message, "price");
        object qty = this.safeNumber(message, "qty");
        object timestamp = this.safeInteger(message, "timestamp");
        if (isTrue(isEqual(side, "sell")))
        {
            object asks = getValue(orderbook, "asks");
            (asks as IOrderBookSide).store(price, qty);
        } else
        {
            object bids = getValue(orderbook, "bids");
            (bids as IOrderBookSide).store(price, qty);
        }
        ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
        ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        // snapshot
        //
        //    {
        //        "feed": "balances_snapshot",
        //        "account": "4a012c31-df95-484a-9473-d51e4a0c4ae7",
        //        "holding": {
        //            "USDT": 4997.5012493753,
        //            "XBT": 0.1285407184,
        //            ...
        //        },
        //        "futures": {
        //            "F-ETH:EUR": {
        //                "name": "F-ETH:EUR",
        //                "pair": "ETH/EUR",
        //                "unit": "EUR",
        //                "portfolio_value": 0.0,
        //                "balance": 0.0,
        //                "maintenance_margin": 0.0,
        //                "initial_margin": 0.0,
        //                "available": 0.0,
        //                "unrealized_funding": 0.0,
        //                "pnl": 0.0
        //            },
        //            ...
        //        },
        //        "flex_futures": {
        //            "currencies": {
        //                "USDT": {
        //                    "quantity": 0.0,
        //                    "value": 0.0,
        //                    "collateral_value": 0.0,
        //                    "available": 0.0,
        //                    "haircut": 0.0,
        //                    "conversion_spread": 0.0
        //                },
        //                ...
        //            },
        //            "balance_value":0.0,
        //            "portfolio_value":0.0,
        //            "collateral_value":0.0,
        //            "initial_margin":0.0,
        //            "initial_margin_without_orders":0.0,
        //            "maintenance_margin":0.0,
        //            "pnl":0.0,
        //            "unrealized_funding":0.0,
        //            "total_unrealized":0.0,
        //            "total_unrealized_as_margin":0.0,
        //            "margin_equity":0.0,
        //            "available_margin":0.0
        //            "isolated":{
        //            },
        //            "cross":{
        //                "balance_value":9963.66,
        //                "portfolio_value":9963.66,
        //                "collateral_value":9963.66,
        //                "initial_margin":0.0,
        //                "initial_margin_without_orders":0.0,
        //                "maintenance_margin":0.0,
        //                "pnl":0.0,
        //                "unrealized_funding":0.0,
        //                "total_unrealized":0.0,
        //                "total_unrealized_as_margin":0.0,
        //                "margin_equity":9963.66,
        //                "available_margin":9963.66,
        //                "effective_leverage":0.0
        //            },
        //        },
        //        "timestamp":1640995200000,
        //        "seq":0
        //    }
        //
        // update
        //
        //    Holding Wallet
        //
        //    {
        //        "feed": "balances",
        //        "account": "7a641082-55c7-4411-a85f-930ec2e09617",
        //        "holding": {
        //            "USD": 5000.0
        //        },
        //        "futures": {},
        //        "timestamp": 1640995200000,
        //        "seq": 83
        //    }
        //
        //    Multi-Collateral
        //
        //    {
        //        "feed": "balances"
        //        "account": "7a641082-55c7-4411-a85f-930ec2e09617"
        //        "flex_futures": {
        //            "currencies": {
        //                "USDT": {
        //                    "quantity": 0.0,
        //                    "value": 0.0,
        //                    "collateral_value": 0.0,
        //                    "available": 0.0,
        //                    "haircut": 0.0,
        //                    "conversion_spread": 0.0
        //                },
        //                ...
        //            },
        //            "balance_value": 5000.0,
        //            "portfolio_value": 5000.0,
        //            "collateral_value": 5000.0,
        //            "initial_margin": 0.0,
        //            "initial_margin_without_orders": 0.0,
        //            "maintenance_margin": 0.0,
        //            "pnl": 0.0,
        //            "unrealized_funding": 0.0,
        //            "total_unrealized": 0.0,
        //            "total_unrealized_as_margin": 0.0,
        //            "margin_equity": 5000.0,
        //            "available_margin": 5000.0
        //        },
        //        "timestamp": 1640995200000,
        //        "seq": 1
        //    }
        //
        //    Sample Single-Collateral Balance Delta
        //
        //    {
        //        "feed": "balances",
        //        "account": "7a641082-55c7-4411-a85f-930ec2e09617",
        //        "holding": {},
        //        "futures": {
        //            "F-XBT:USD": {
        //                "name": "F-XBT:USD",
        //                "pair": "XBT/USD",
        //                "unit": "XBT",
        //                "portfolio_value": 0.1219368845,
        //                "balance": 0.1219368845,
        //                "maintenance_margin": 0.0,
        //                "initial_margin": 0.0,
        //                "available": 0.1219368845,
        //                "unrealized_funding": 0.0,
        //                "pnl": 0.0
        //            }
        //        },
        //        "timestamp": 1640995200000,
        //        "seq": 2
        //    }
        //
        object holding = this.safeValue(message, "holding");
        object futures = this.safeValue(message, "futures");
        object flexFutures = this.safeValue(message, "flex_futures");
        object messageHash = "balances";
        object timestamp = this.safeInteger(message, "timestamp");
        if (isTrue(!isEqual(holding, null)))
        {
            object holdingKeys = new List<object>(((IDictionary<string,object>)holding).Keys); // cashAccount
            object holdingResult = new Dictionary<string, object>() {
                { "info", message },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            };
            for (object i = 0; isLessThan(i, getArrayLength(holdingKeys)); postFixIncrement(ref i))
            {
                object key = getValue(holdingKeys, i);
                object code = this.safeCurrencyCode(key);
                object newAccount = this.account();
                ((IDictionary<string,object>)newAccount)["total"] = this.safeString(holding, key);
                ((IDictionary<string,object>)holdingResult)[(string)code] = newAccount;
            }
            ((IDictionary<string,object>)this.balance)["cash"] = holdingResult;
            ((IDictionary<string,object>)this.balance)["cash"] = this.safeBalance(getValue(this.balance, "cash"));
            callDynamically(client as WebSocketClient, "resolve", new object[] {holdingResult, messageHash});
        }
        if (isTrue(!isEqual(futures, null)))
        {
            object futuresKeys = new List<object>(((IDictionary<string,object>)futures).Keys); // marginAccount
            object futuresResult = new Dictionary<string, object>() {
                { "info", message },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            };
            for (object i = 0; isLessThan(i, getArrayLength(futuresKeys)); postFixIncrement(ref i))
            {
                object key = getValue(futuresKeys, i);
                object symbol = this.safeSymbol(key);
                object newAccount = this.account();
                var future = this.safeValue(futures, key);
                object currencyId = this.safeString(future, "unit");
                object code = this.safeCurrencyCode(currencyId);
                ((IDictionary<string,object>)newAccount)["free"] = this.safeString(future, "available");
                ((IDictionary<string,object>)newAccount)["used"] = this.safeString(future, "initial_margin");
                ((IDictionary<string,object>)newAccount)["total"] = this.safeString(future, "balance");
                ((IDictionary<string,object>)futuresResult)[(string)symbol] = new Dictionary<string, object>() {};
                ((IDictionary<string,object>)getValue(futuresResult, symbol))[(string)code] = newAccount;
            }
            ((IDictionary<string,object>)this.balance)["margin"] = futuresResult;
            ((IDictionary<string,object>)this.balance)["margin"] = this.safeBalance(getValue(this.balance, "margin"));
            callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, "margin"), add(messageHash, "futures")});
        }
        if (isTrue(!isEqual(flexFutures, null)))
        {
            object flexFutureCurrencies = this.safeValue(flexFutures, "currencies", new Dictionary<string, object>() {});
            object flexFuturesKeys = new List<object>(((IDictionary<string,object>)flexFutureCurrencies).Keys); // multi-collateral margin account
            object flexFuturesResult = new Dictionary<string, object>() {
                { "info", message },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            };
            for (object i = 0; isLessThan(i, getArrayLength(flexFuturesKeys)); postFixIncrement(ref i))
            {
                object key = getValue(flexFuturesKeys, i);
                object flexFuture = this.safeValue(flexFutureCurrencies, key);
                object code = this.safeCurrencyCode(key);
                object newAccount = this.account();
                ((IDictionary<string,object>)newAccount)["free"] = this.safeString(flexFuture, "available");
                ((IDictionary<string,object>)newAccount)["used"] = this.safeString(flexFuture, "collateral_value");
                ((IDictionary<string,object>)newAccount)["total"] = this.safeString(flexFuture, "quantity");
                ((IDictionary<string,object>)flexFuturesResult)[(string)code] = newAccount;
            }
            ((IDictionary<string,object>)this.balance)["flex"] = flexFuturesResult;
            ((IDictionary<string,object>)this.balance)["flex"] = this.safeBalance(getValue(this.balance, "flex"));
            callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, "flex"), add(messageHash, "flex_futures")});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, messageHash});
    }

    public virtual void handleMyTrades(WebSocketClient client, object message)
    {
        //
        //    {
        //        "feed": "fills_snapshot",
        //        "account": "DemoUser",
        //        "fills": [
        //            {
        //                "instrument": "FI_XBTUSD_200925",
        //                "time": 1600256910739,
        //                "price": 10937.5,
        //                "seq": 36,
        //                "buy": true,
        //                "qty": 5000.0,
        //                "order_id": "9e30258b-5a98-4002-968a-5b0e149bcfbf",
        //                "cli_ord_id": "8b58d9da-fcaf-4f60-91bc-9973a3eba48d", // only on update, not on snapshot
        //                "fill_id": "cad76f07-814e-4dc6-8478-7867407b6bff",
        //                "fill_type": "maker",
        //                "fee_paid": -0.00009142857,
        //                "fee_currency": "BTC",
        //                "taker_order_type": "ioc",
        //                "order_type": "limit"
        //            },
        //            ...
        //        ]
        //    }
        //
        object trades = this.safeValue(message, "fills", new List<object>() {});
        object stored = this.myTrades;
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCacheBySymbolById(limit);
            this.myTrades = stored;
        }
        object tradeSymbols = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
        {
            object trade = getValue(trades, i);
            object parsedTrade = this.parseWsMyTrade(trade);
            ((IDictionary<string,object>)tradeSymbols)[(string)getValue(parsedTrade, "symbol")] = true;
            callDynamically(stored, "append", new object[] {parsedTrade});
        }
        object tradeSymbolKeys = new List<object>(((IDictionary<string,object>)tradeSymbols).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(tradeSymbolKeys)); postFixIncrement(ref i))
        {
            object symbol = getValue(tradeSymbolKeys, i);
            object messageHash = add("myTrades:", symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, "myTrades"});
    }

    public virtual object parseWsMyTrade(object trade, object market = null)
    {
        //
        //    {
        //        "instrument": "FI_XBTUSD_200925",
        //        "time": 1600256910739,
        //        "price": 10937.5,
        //        "seq": 36,
        //        "buy": true,
        //        "qty": 5000.0,
        //        "order_id": "9e30258b-5a98-4002-968a-5b0e149bcfbf",
        //        "cli_ord_id": "8b58d9da-fcaf-4f60-91bc-9973a3eba48d", // only on update, not on snapshot
        //        "fill_id": "cad76f07-814e-4dc6-8478-7867407b6bff",
        //        "fill_type": "maker",
        //        "fee_paid": -0.00009142857,
        //        "fee_currency": "BTC",
        //        "taker_order_type": "ioc",
        //        "order_type": "limit"
        //    }
        //
        object timestamp = this.safeInteger(trade, "time");
        object marketId = this.safeString(trade, "instrument");
        market = this.safeMarket(marketId, market);
        object isBuy = this.safeValue(trade, "buy");
        object feeCurrencyId = this.safeString(trade, "fee_currency");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString(trade, "fill_id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", this.safeString(market, "symbol") },
            { "order", this.safeString(trade, "order_id") },
            { "type", this.safeString(trade, "type") },
            { "side", ((bool) isTrue(isBuy)) ? "buy" : "sell" },
            { "takerOrMaker", this.safeString(trade, "fill_type") },
            { "price", this.safeString(trade, "price") },
            { "amount", this.safeString(trade, "qty") },
            { "cost", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(feeCurrencyId) },
                { "cost", this.safeString(trade, "fee_paid") },
                { "rate", null },
            } },
        });
    }

    public async virtual Task<object> watchMultiHelper(object unifiedName, object channelName, object symbols = null, object subscriptionArgs = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        // symbols are required
        symbols = this.marketSymbols(symbols, null, false, true, false);
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            ((IList<object>)messageHashes).Add(this.getMessageHash(unifiedName, null, this.symbol(getValue(symbols, i))));
        }
        object marketIds = this.marketIds(symbols);
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "feed", channelName },
            { "product_ids", marketIds },
        };
        object url = getValue(getValue(this.urls, "api"), "ws");
        return await this.watchMultiple(url, messageHashes, this.extend(request, parameters), messageHashes, subscriptionArgs);
    }

    public virtual object getMessageHash(object unifiedElementName, object subChannelName = null, object symbol = null)
    {
        // unifiedElementName can be : orderbook, trade, ticker, bidask ...
        // subChannelName only applies to channel that needs specific variation (i.e. depth_50, depth_100..) to be selected
        object withSymbol = !isEqual(symbol, null);
        object messageHash = unifiedElementName;
        if (!isTrue(withSymbol))
        {
            messageHash = add(messageHash, "s");
        } else
        {
            messageHash = add(messageHash, add(":", symbol));
        }
        if (isTrue(!isEqual(subChannelName, null)))
        {
            messageHash = add(messageHash, add("#", subChannelName));
        }
        return messageHash;
    }

    public virtual void handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //    {
        //        event: 'alert',
        //        message: 'Failed to subscribe to authenticated feed'
        //    }
        //
        object errMsg = this.safeString(message, "message");
        try
        {
            throw new ExchangeError ((string)add(add(this.id, " "), errMsg)) ;
        } catch(Exception error)
        {
            ((WebSocketClient)client).reject(error);
        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        object eventVar = this.safeString(message, "event");
        if (isTrue(isEqual(eventVar, "challenge")))
        {
            this.handleAuthenticate(client as WebSocketClient, message);
        } else if (isTrue(isEqual(eventVar, "alert")))
        {
            this.handleErrorMessage(client as WebSocketClient, message);
        } else if (isTrue(isEqual(eventVar, "pong")))
        {
            client.lastPong = this.milliseconds();
        } else if (isTrue(isEqual(eventVar, null)))
        {
            object feed = this.safeString(message, "feed");
            object methods = new Dictionary<string, object>() {
                { "ticker", this.handleTicker },
                { "ticker_lite", this.handleBidAsk },
                { "trade", this.handleTrade },
                { "trade_snapshot", this.handleTrade },
                { "book", this.handleOrderBook },
                { "book_snapshot", this.handleOrderBookSnapshot },
                { "open_orders_verbose", this.handleOrder },
                { "open_orders_verbose_snapshot", this.handleOrderSnapshot },
                { "fills", this.handleMyTrades },
                { "fills_snapshot", this.handleMyTrades },
                { "open_orders", this.handleOrder },
                { "open_orders_snapshot", this.handleOrderSnapshot },
                { "balances", this.handleBalance },
                { "balances_snapshot", this.handleBalance },
                { "open_positions", this.handlePositions },
            };
            object method = this.safeValue(methods, feed);
            if (isTrue(!isEqual(method, null)))
            {
                DynamicInvoker.InvokeMethod(method, new object[] { client, message});
            }
        }
    }

    public virtual object handleAuthenticate(WebSocketClient client, object message)
    {
        /**
         * @ignore
         * @method
         * @see https://docs.futures.kraken.com/#websocket-api-websocket-api-introduction-sign-challenge-challenge
         */
        //
        //    {
        //        "event": "challenge",
        //        "message": "226aee50-88fc-4618-a42a-34f7709570b2"
        //    }
        //
        object eventVar = this.safeValue(message, "event");
        object messageHash = "challenge";
        if (isTrue(!isEqual(eventVar, "error")))
        {
            object challenge = this.safeValue(message, "message");
            object hashedChallenge = this.hash(this.encode(challenge), sha256, "binary");
            object base64Secret = this.base64ToBinary(this.secret);
            object signature = this.hmac(hashedChallenge, base64Secret, sha512, "base64");
            ((IDictionary<string,object>)this.options)["challenge"] = challenge;
            ((IDictionary<string,object>)this.options)["signedChallenge"] = signature;
            callDynamically(client as WebSocketClient, "resolve", new object[] {message, messageHash});
        } else
        {
            var error = new AuthenticationError(add(add(this.id, " "), this.json(message)));
            ((WebSocketClient)client).reject(error, messageHash);
            if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
            {

            }
        }
        return message;
    }
}
