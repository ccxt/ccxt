namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class kucoin { public kucoin(object args = null) : base(args) { } }
public partial class kucoin : ccxt.kucoin
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "createOrderWs", false },
                { "editOrderWs", false },
                { "fetchOpenOrdersWs", false },
                { "fetchOrderWs", false },
                { "cancelOrderWs", false },
                { "cancelOrdersWs", false },
                { "cancelAllOrdersWs", false },
                { "watchBidsAsks", true },
                { "watchOrderBook", true },
                { "watchOrders", true },
                { "watchMyTrades", true },
                { "watchTickers", true },
                { "watchTicker", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
                { "watchOrderBookForSymbols", true },
                { "watchBalance", true },
                { "watchOHLCV", true },
            } },
            { "options", new Dictionary<string, object>() {
                { "tradesLimit", 1000 },
                { "watchTicker", new Dictionary<string, object>() {
                    { "name", "market/snapshot" },
                } },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "snapshotDelay", 5 },
                    { "snapshotMaxRetries", 3 },
                    { "method", "/market/level2" },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "ping", this.ping },
            } },
        });
    }

    public async virtual Task<object> negotiate(object privateChannel, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object connectId = ((bool) isTrue(privateChannel)) ? "private" : "public";
        object urls = this.safeValue(this.options, "urls", new Dictionary<string, object>() {});
        object spawaned = this.safeValue(urls, connectId);
        if (isTrue(!isEqual(spawaned, null)))
        {
            return await (spawaned as Exchange.Future);
        }
        // we store an awaitable to the url
        // so that multiple calls don't asynchronously
        // fetch different urls and overwrite each other
        ((IDictionary<string,object>)urls)[(string)connectId] = this.spawn(this.negotiateHelper, new object[] { privateChannel, parameters});
        ((IDictionary<string,object>)this.options)["urls"] = urls;
        var future = getValue(urls, connectId);
        return await (future as Exchange.Future);
    }

    public async virtual Task<object> negotiateHelper(object privateChannel, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = null;
        object connectId = ((bool) isTrue(privateChannel)) ? "private" : "public";
        try
        {
            if (isTrue(privateChannel))
            {
                response = await this.privatePostBulletPrivate(parameters);
            } else
            {
                response = await this.publicPostBulletPublic(parameters);
            }
            object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
            object instanceServers = this.safeValue(data, "instanceServers", new List<object>() {});
            object firstInstanceServer = this.safeValue(instanceServers, 0);
            object pingInterval = this.safeInteger(firstInstanceServer, "pingInterval");
            object endpoint = this.safeString(firstInstanceServer, "endpoint");
            object token = this.safeString(data, "token");
            object result = add(add(endpoint, "?"), this.urlencode(new Dictionary<string, object>() {
    { "token", token },
    { "privateChannel", privateChannel },
    { "connectId", connectId },
}));
            var client = this.client(result);
            client.keepAlive = pingInterval;
            return result;
        } catch(Exception e)
        {
            var future = this.safeValue(getValue(this.options, "urls"), connectId);
            ((Future)future).reject(e);

        }
        return null;
    }

    public virtual object requestId()
    {
        object requestId = this.sum(this.safeInteger(this.options, "requestId", 0), 1);
        ((IDictionary<string,object>)this.options)["requestId"] = requestId;
        return requestId;
    }

    public async virtual Task<object> subscribe(object url, object messageHash, object subscriptionHash, object parameters = null, object subscription = null)
    {
        parameters ??= new Dictionary<string, object>();
        object requestId = ((object)this.requestId()).ToString();
        object request = new Dictionary<string, object>() {
            { "id", requestId },
            { "type", "subscribe" },
            { "topic", subscriptionHash },
            { "response", true },
        };
        object message = this.extend(request, parameters);
        var client = this.client(url);
        if (!isTrue((inOp(((WebSocketClient)client).subscriptions, subscriptionHash))))
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)requestId] = subscriptionHash;
        }
        return await this.watch(url, messageHash, message, subscriptionHash, subscription);
    }

    public async virtual Task<object> subscribeMultiple(object url, object messageHashes, object topic, object subscriptionHashes, object parameters = null, object subscription = null)
    {
        parameters ??= new Dictionary<string, object>();
        object requestId = ((object)this.requestId()).ToString();
        object request = new Dictionary<string, object>() {
            { "id", requestId },
            { "type", "subscribe" },
            { "topic", topic },
            { "response", true },
        };
        object message = this.extend(request, parameters);
        var client = this.client(url);
        for (object i = 0; isLessThan(i, getArrayLength(subscriptionHashes)); postFixIncrement(ref i))
        {
            object subscriptionHash = getValue(subscriptionHashes, i);
            if (!isTrue((inOp(((WebSocketClient)client).subscriptions, subscriptionHash))))
            {
                ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)requestId] = subscriptionHash;
            }
        }
        return await this.watchMultiple(url, messageHashes, message, subscriptionHashes, subscription);
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#watchTicker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object url = await this.negotiate(false);
        var methodqueryVariable = this.handleOptionAndParams(parameters, "watchTicker", "method", "/market/snapshot");
        var method = ((IList<object>) methodqueryVariable)[0];
        var query = ((IList<object>) methodqueryVariable)[1];
        object topic = add(add(method, ":"), getValue(market, "id"));
        object messageHash = add("ticker:", symbol);
        return await this.subscribe(url, messageHash, topic, query);
    }

    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#watchTickers
        * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/ticker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
        * @param {string[]} symbols unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.method] either '/market/snapshot' or '/market/ticker' default is '/market/ticker'
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object messageHash = "tickers";
        object method = null;
        var methodparametersVariable = this.handleOptionAndParams(parameters, "watchTickers", "method", "/market/ticker");
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        object messageHashes = new List<object>() {};
        object topics = new List<object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                ((IList<object>)messageHashes).Add(add("ticker:", symbol));
                object market = this.market(symbol);
                ((IList<object>)topics).Add(add(add(method, ":"), getValue(market, "id")));
            }
        }
        object url = await this.negotiate(false);
        object tickers = null;
        if (isTrue(isEqual(symbols, null)))
        {
            object allTopic = add(method, ":all");
            tickers = await this.subscribe(url, messageHash, allTopic, parameters);
            if (isTrue(this.newUpdates))
            {
                return tickers;
            }
        } else
        {
            object marketIds = this.marketIds(symbols);
            object symbolsTopic = add(add(method, ":"), String.Join(",", ((IList<object>)marketIds).ToArray()));
            tickers = await this.subscribeMultiple(url, messageHashes, symbolsTopic, topics, parameters);
            if (isTrue(this.newUpdates))
            {
                object newDict = new Dictionary<string, object>() {};
                ((IDictionary<string,object>)newDict)[(string)getValue(tickers, "symbol")] = tickers;
                return newDict;
            }
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        // market/snapshot
        //
        // updates come in every 2 sec unless there
        // were no changes since the previous update
        //
        //     {
        //         "data": {
        //             "sequence": "1545896669291",
        //             "data": {
        //                 "trading": true,
        //                 "symbol": "KCS-BTC",
        //                 "buy": 0.00011,
        //                 "sell": 0.00012,
        //                 "sort": 100,
        //                 "volValue": 3.13851792584, // total
        //                 "baseCurrency": "KCS",
        //                 "market": "BTC",
        //                 "quoteCurrency": "BTC",
        //                 "symbolCode": "KCS-BTC",
        //                 "datetime": 1548388122031,
        //                 "high": 0.00013,
        //                 "vol": 27514.34842,
        //                 "low": 0.0001,
        //                 "changePrice": -1.0e-5,
        //                 "changeRate": -0.0769,
        //                 "lastTradedPrice": 0.00012,
        //                 "board": 0,
        //                 "mark": 0
        //             }
        //         },
        //         "subject": "trade.snapshot",
        //         "topic": "/market/snapshot:KCS-BTC",
        //         "type": "message"
        //     }
        //
        // market/ticker
        //
        //     {
        //         "type": "message",
        //         "topic": "/market/ticker:BTC-USDT",
        //         "subject": "trade.ticker",
        //         "data": {
        //             "bestAsk": "62163",
        //             "bestAskSize": "0.99011388",
        //             "bestBid": "62162.9",
        //             "bestBidSize": "0.04794181",
        //             "price": "62162.9",
        //             "sequence": "1621383371852",
        //             "size": "0.00832274",
        //             "time": 1634641987564
        //         }
        //     }
        //
        object topic = this.safeString(message, "topic");
        object market = null;
        if (isTrue(!isEqual(topic, null)))
        {
            object parts = ((string)topic).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
            object first = this.safeString(parts, 1);
            object marketId = null;
            if (isTrue(isEqual(first, "all")))
            {
                marketId = this.safeString(message, "subject");
            } else
            {
                marketId = first;
            }
            market = this.safeMarket(marketId, market, "-");
        }
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object rawTicker = this.safeValue(data, "data", data);
        object ticker = this.parseTicker(rawTicker, market);
        object symbol = getValue(ticker, "symbol");
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
        object messageHash = add("ticker:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
        // watchTickers
        object allTickers = new Dictionary<string, object>() {};
        ((IDictionary<string,object>)allTickers)[(string)symbol] = ticker;
        callDynamically(client as WebSocketClient, "resolve", new object[] {allTickers, "tickers"});
    }

    public async override Task<object> watchBidsAsks(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#watchBidsAsks
        * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level1-bbo-market-data
        * @description watches best bid & ask for symbols
        * @param {string[]} symbols unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object ticker = await this.watchMultiHelper("watchBidsAsks", "/spotMarket/level1:", symbols, parameters);
        if (isTrue(this.newUpdates))
        {
            object tickers = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)tickers)[(string)getValue(ticker, "symbol")] = ticker;
            return tickers;
        }
        return this.filterByArray(this.bidsasks, "symbol", symbols);
    }

    public async virtual Task<object> watchMultiHelper(object methodName, object channelName, object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false, true, false);
        object length = getArrayLength(symbols);
        if (isTrue(isGreaterThan(length, 100)))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() accepts a maximum of 100 symbols")) ;
        }
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = this.market(symbol);
            ((IList<object>)messageHashes).Add(add("bidask@", getValue(market, "symbol")));
        }
        object url = await this.negotiate(false);
        object marketIds = this.marketIds(symbols);
        object joined = String.Join(",", ((IList<object>)marketIds).ToArray());
        object requestId = ((object)this.requestId()).ToString();
        object request = new Dictionary<string, object>() {
            { "id", requestId },
            { "type", "subscribe" },
            { "topic", add(channelName, joined) },
            { "response", true },
        };
        object message = this.extend(request, parameters);
        return await this.watchMultiple(url, messageHashes, message, messageHashes);
    }

    public virtual void handleBidAsk(WebSocketClient client, object message)
    {
        //
        // arrives one symbol dict
        //
        //     {
        //         topic: '/spotMarket/level1:ETH-USDT',
        //         type: 'message',
        //         data: {
        //             asks: [ '3347.42', '2.0778387' ],
        //             bids: [ '3347.41', '6.0411697' ],
        //             timestamp: 1712231142085
        //         },
        //         subject: 'level1'
        //     }
        //
        object parsedTicker = this.parseWsBidAsk(message);
        object symbol = getValue(parsedTicker, "symbol");
        ((IDictionary<string,object>)this.bidsasks)[(string)symbol] = parsedTicker;
        object messageHash = add("bidask@", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {parsedTicker, messageHash});
    }

    public virtual object parseWsBidAsk(object ticker, object market = null)
    {
        object topic = this.safeString(ticker, "topic");
        object parts = ((string)topic).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
        object marketId = getValue(parts, 1);
        market = this.safeMarket(marketId, market);
        object symbol = this.safeString(market, "symbol");
        object data = this.safeDict(ticker, "data", new Dictionary<string, object>() {});
        object ask = this.safeList(data, "asks", new List<object>() {});
        object bid = this.safeList(data, "bids", new List<object>() {});
        object timestamp = this.safeInteger(data, "timestamp");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "ask", this.safeNumber(ask, 0) },
            { "askVolume", this.safeNumber(ask, 1) },
            { "bid", this.safeNumber(bid, 0) },
            { "bidVolume", this.safeNumber(bid, 1) },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#watchOHLCV
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object url = await this.negotiate(false);
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object period = this.safeString(this.timeframes, timeframe, timeframe);
        object topic = add(add(add("/market/candles:", getValue(market, "id")), "_"), period);
        object messageHash = add(add(add("candles:", symbol), ":"), timeframe);
        object ohlcv = await this.subscribe(url, messageHash, topic, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "data": {
        //             "symbol": "BTC-USDT",
        //             "candles": [
        //                 "1624881240",
        //                 "34138.8",
        //                 "34121.6",
        //                 "34138.8",
        //                 "34097.9",
        //                 "3.06097133",
        //                 "104430.955068564"
        //             ],
        //             "time": 1624881284466023700
        //         },
        //         "subject": "trade.candles.update",
        //         "topic": "/market/candles:BTC-USDT_1min",
        //         "type": "message"
        //     }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "symbol");
        object candles = this.safeValue(data, "candles", new List<object>() {});
        object topic = this.safeString(message, "topic");
        object parts = ((string)topic).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
        object interval = this.safeString(parts, 1);
        // use a reverse lookup in a static map instead
        object timeframe = this.findTimeframe(interval);
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object messageHash = add(add(add("candles:", symbol), ":"), timeframe);
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
        }
        object ohlcv = this.parseOHLCV(candles, market);
        callDynamically(stored, "append", new object[] {ohlcv});
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#watchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#watchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        object symbolsLength = getArrayLength(symbols);
        if (isTrue(isEqual(symbolsLength, 0)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchTradesForSymbols() requires a non-empty array of symbols")) ;
        }
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object marketIds = this.marketIds(symbols);
        object url = await this.negotiate(false);
        object messageHashes = new List<object>() {};
        object subscriptionHashes = new List<object>() {};
        object topic = add("/market/match:", String.Join(",", ((IList<object>)marketIds).ToArray()));
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            ((IList<object>)messageHashes).Add(add("trades:", symbol));
            object marketId = getValue(marketIds, i);
            ((IList<object>)subscriptionHashes).Add(add("/market/match:", marketId));
        }
        object trades = await this.subscribeMultiple(url, messageHashes, topic, subscriptionHashes, parameters);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeValue(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrade(WebSocketClient client, object message)
    {
        //
        //     {
        //         "data": {
        //             "sequence": "1568787654360",
        //             "symbol": "BTC-USDT",
        //             "side": "buy",
        //             "size": "0.00536577",
        //             "price": "9345",
        //             "takerOrderId": "5e356c4a9f1a790008f8d921",
        //             "time": "1580559434436443257",
        //             "type": "match",
        //             "makerOrderId": "5e356bffedf0010008fa5d7f",
        //             "tradeId": "5e356c4aeefabd62c62a1ece"
        //         },
        //         "subject": "trade.l3match",
        //         "topic": "/market/match:BTC-USDT",
        //         "type": "message"
        //     }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object trade = this.parseTrade(data);
        object symbol = getValue(trade, "symbol");
        object messageHash = add("trades:", symbol);
        object trades = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(trades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            trades = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = trades;
        }
        callDynamically(trades, "append", new object[] {trade});
        callDynamically(client as WebSocketClient, "resolve", new object[] {trades, messageHash});
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#watchOrderBook
        * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level1-bbo-market-data
        * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level2-market-data
        * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level2-5-best-ask-bid-orders
        * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level2-50-best-ask-bid-orders
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.method] either '/market/level2' or '/spotMarket/level2Depth5' or '/spotMarket/level2Depth50' default is '/market/level2'
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        //
        // https://docs.kucoin.com/#level-2-market-data
        //
        // 1. After receiving the websocket Level 2 data flow, cache the data.
        // 2. Initiate a REST request to get the snapshot data of Level 2 order book.
        // 3. Playback the cached Level 2 data flow.
        // 4. Apply the new Level 2 data flow to the local snapshot to ensure that
        // the sequence of the new Level 2 update lines up with the sequence of
        // the previous Level 2 data. Discard all the message prior to that
        // sequence, and then playback the change to snapshot.
        // 5. Update the level2 full data based on sequence according to the
        // size. If the price is 0, ignore the messages and update the sequence.
        // If the size=0, update the sequence and remove the price of which the
        // size is 0 out of level 2. Fr other cases, please update the price.
        //
        parameters ??= new Dictionary<string, object>();
        return await this.watchOrderBookForSymbols(new List<object>() {symbol}, limit, parameters);
    }

    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#watchOrderBookForSymbols
        * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level1-bbo-market-data
        * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level2-market-data
        * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level2-5-best-ask-bid-orders
        * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level2-50-best-ask-bid-orders
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string[]} symbols unified array of symbols
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.method] either '/market/level2' or '/spotMarket/level2Depth5' or '/spotMarket/level2Depth50' default is '/market/level2'
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        object symbolsLength = getArrayLength(symbols);
        if (isTrue(isEqual(symbolsLength, 0)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchOrderBookForSymbols() requires a non-empty array of symbols")) ;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(isTrue(isTrue(isTrue((!isEqual(limit, 20))) && isTrue((!isEqual(limit, 100)))) && isTrue((!isEqual(limit, 50)))) && isTrue((!isEqual(limit, 5)))))
            {
                throw new ExchangeError ((string)add(this.id, " watchOrderBook \'limit\' argument must be undefined, 5, 20, 50 or 100")) ;
            }
        }
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object marketIds = this.marketIds(symbols);
        object url = await this.negotiate(false);
        object method = null;
        var methodparametersVariable = this.handleOptionAndParams(parameters, "watchOrderBook", "method", "/market/level2");
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        if (isTrue(isTrue((isEqual(limit, 5))) || isTrue((isEqual(limit, 50)))))
        {
            method = add("/spotMarket/level2Depth", ((object)limit).ToString());
        }
        object topic = add(add(method, ":"), String.Join(",", ((IList<object>)marketIds).ToArray()));
        object messageHashes = new List<object>() {};
        object subscriptionHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            ((IList<object>)messageHashes).Add(add("orderbook:", symbol));
            object marketId = getValue(marketIds, i);
            ((IList<object>)subscriptionHashes).Add(add(add(method, ":"), marketId));
        }
        object subscription = new Dictionary<string, object>() {};
        if (isTrue(isEqual(method, "/market/level2")))
        {
            subscription = new Dictionary<string, object>() {
                { "method", this.handleOrderBookSubscription },
                { "symbols", symbols },
                { "limit", limit },
            };
        }
        object orderbook = await this.subscribeMultiple(url, messageHashes, topic, subscriptionHashes, parameters, subscription);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        // initial snapshot is fetched with ccxt's fetchOrderBook
        // the feed does not include a snapshot, just the deltas
        //
        //     {
        //         "type":"message",
        //         "topic":"/market/level2:BTC-USDT",
        //         "subject":"trade.l2update",
        //         "data":{
        //             "sequenceStart":1545896669105,
        //             "sequenceEnd":1545896669106,
        //             "symbol":"BTC-USDT",
        //             "changes": {
        //                 "asks": [["6","1","1545896669105"]], // price, size, sequence
        //                 "bids": [["4","1","1545896669106"]]
        //             }
        //         }
        //     }
        //
        //     {
        //         "topic": "/spotMarket/level2Depth5:BTC-USDT",
        //         "type": "message",
        //         "data": {
        //             "asks": [
        //                 [
        //                     "42815.6",
        //                     "1.24016245"
        //                 ]
        //             ],
        //             "bids": [
        //                 [
        //                     "42815.5",
        //                     "0.08652716"
        //                 ]
        //             ],
        //             "timestamp": 1707204474018
        //         },
        //         "subject": "level2"
        //     }
        //
        object data = this.safeValue(message, "data");
        object subject = this.safeString(message, "subject");
        object topic = this.safeString(message, "topic");
        object topicParts = ((string)topic).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
        object topicSymbol = this.safeString(topicParts, 1);
        object topicChannel = this.safeString(topicParts, 0);
        object marketId = this.safeString(data, "symbol", topicSymbol);
        object symbol = this.safeSymbol(marketId, null, "-");
        object messageHash = add("orderbook:", symbol);
        // let orderbook = this.safeDict (this.orderbooks, symbol);
        if (isTrue(isEqual(subject, "level2")))
        {
            if (!isTrue((inOp(this.orderbooks, symbol))))
            {
                ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook();
            } else
            {
                object orderbook = getValue(this.orderbooks, symbol);
                (orderbook as IOrderBook).reset();
            }
            ((IDictionary<string,object>)getValue(this.orderbooks, symbol))["symbol"] = symbol;
        } else
        {
            if (!isTrue((inOp(this.orderbooks, symbol))))
            {
                ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook();
            }
            object orderbook = getValue(this.orderbooks, symbol);
            object nonce = this.safeInteger(orderbook, "nonce");
            object deltaEnd = this.safeInteger2(data, "sequenceEnd", "timestamp");
            if (isTrue(isEqual(nonce, null)))
            {
                object cacheLength = getArrayLength((orderbook as ccxt.pro.OrderBook).cache);
                object subscriptions = new List<object>(((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Keys);
                object subscription = null;
                for (object i = 0; isLessThan(i, getArrayLength(subscriptions)); postFixIncrement(ref i))
                {
                    object key = getValue(subscriptions, i);
                    if (isTrue(isTrue((isGreaterThanOrEqual(getIndexOf(key, topicSymbol), 0))) && isTrue((isGreaterThanOrEqual(getIndexOf(key, topicChannel), 0)))))
                    {
                        subscription = getValue(((WebSocketClient)client).subscriptions, key);
                        break;
                    }
                }
                object limit = this.safeInteger(subscription, "limit");
                object snapshotDelay = this.handleOption("watchOrderBook", "snapshotDelay", 5);
                if (isTrue(isEqual(cacheLength, snapshotDelay)))
                {
                    this.spawn(this.loadOrderBook, new object[] { client, messageHash, symbol, limit, new Dictionary<string, object>() {}});
                }
                ((IList<object>)(orderbook as ccxt.pro.OrderBook).cache).Add(data);
                return;
            } else if (isTrue(isGreaterThanOrEqual(nonce, deltaEnd)))
            {
                return;
            }
        }
        this.handleDelta(getValue(this.orderbooks, symbol), data);
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.orderbooks, symbol), messageHash});
    }

    public override object getCacheIndex(object orderbook, object cache)
    {
        object firstDelta = this.safeValue(cache, 0);
        object nonce = this.safeInteger(orderbook, "nonce");
        object firstDeltaStart = this.safeInteger(firstDelta, "sequenceStart");
        if (isTrue(isLessThan(nonce, subtract(firstDeltaStart, 1))))
        {
            return -1;
        }
        for (object i = 0; isLessThan(i, getArrayLength(cache)); postFixIncrement(ref i))
        {
            object delta = getValue(cache, i);
            object deltaStart = this.safeInteger(delta, "sequenceStart");
            object deltaEnd = this.safeInteger(delta, "sequenceEnd");
            if (isTrue(isTrue((isGreaterThanOrEqual(nonce, subtract(deltaStart, 1)))) && isTrue((isLessThan(nonce, deltaEnd)))))
            {
                return i;
            }
        }
        return getArrayLength(cache);
    }

    public override void handleDelta(object orderbook, object delta)
    {
        object timestamp = this.safeInteger2(delta, "time", "timestamp");
        ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger(delta, "sequenceEnd", timestamp);
        ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
        ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        object changes = this.safeValue(delta, "changes", delta);
        object bids = this.safeValue(changes, "bids", new List<object>() {});
        object asks = this.safeValue(changes, "asks", new List<object>() {});
        object storedBids = getValue(orderbook, "bids");
        object storedAsks = getValue(orderbook, "asks");
        this.handleBidAsks(storedBids, bids);
        this.handleBidAsks(storedAsks, asks);
    }

    public virtual void handleBidAsks(object bookSide, object bidAsks)
    {
        for (object i = 0; isLessThan(i, getArrayLength(bidAsks)); postFixIncrement(ref i))
        {
            object bidAsk = this.parseBidAsk(getValue(bidAsks, i));
            (bookSide as IOrderBookSide).storeArray(bidAsk);
        }
    }

    public virtual void handleOrderBookSubscription(WebSocketClient client, object message, object subscription)
    {
        object limit = this.safeInteger(subscription, "limit");
        object symbols = this.safeValue(subscription, "symbols");
        if (isTrue(isEqual(symbols, null)))
        {
            object symbol = this.safeString(subscription, "symbol");
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
        } else
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
            }
        }
    }

    public virtual void handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //     {
        //         "id": "1578090438322",
        //         "type": "ack"
        //     }
        //
        object id = this.safeString(message, "id");
        if (!isTrue((inOp(((WebSocketClient)client).subscriptions, id))))
        {
            return;
        }
        object subscriptionHash = this.safeString(((WebSocketClient)client).subscriptions, id);
        object subscription = this.safeValue(((WebSocketClient)client).subscriptions, subscriptionHash);

        object method = this.safeValue(subscription, "method");
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message, subscription});
        }
    }

    public virtual object handleSystemStatus(WebSocketClient client, object message)
    {
        //
        // todo: answer the question whether handleSystemStatus should be renamed
        // and unified as handleStatus for any usage pattern that
        // involves system status and maintenance updates
        //
        //     {
        //         "id": "1578090234088", // connectId
        //         "type": "welcome",
        //     }
        //
        return message;
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#watchOrders
        * @description watches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.stop] trigger orders are watched if true
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object stop = this.safeValue2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        object url = await this.negotiate(true);
        object topic = ((bool) isTrue(stop)) ? "/spotMarket/advancedOrders" : "/spotMarket/tradeOrders";
        object request = new Dictionary<string, object>() {
            { "privateChannel", true },
        };
        object messageHash = "orders";
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            symbol = getValue(market, "symbol");
            messageHash = add(add(messageHash, ":"), symbol);
        }
        object orders = await this.subscribe(url, messageHash, topic, this.extend(request, parameters));
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual object parseWsOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "open", "open" },
            { "filled", "closed" },
            { "match", "open" },
            { "update", "open" },
            { "canceled", "canceled" },
            { "cancel", "canceled" },
            { "TRIGGERED", "triggered" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        // /spotMarket/tradeOrders
        //
        //    {
        //        "symbol": "XCAD-USDT",
        //        "orderType": "limit",
        //        "side": "buy",
        //        "orderId": "6249167327218b000135e749",
        //        "type": "canceled",
        //        "orderTime": 1648957043065280224,
        //        "size": "100.452",
        //        "filledSize": "0",
        //        "price": "2.9635",
        //        "clientOid": "buy-XCAD-USDT-1648957043010159",
        //        "remainSize": "0",
        //        "status": "done",
        //        "ts": 1648957054031001037
        //    }
        //
        // /spotMarket/advancedOrders
        //
        //    {
        //        "createdAt": 1589789942337,
        //        "orderId": "5ec244f6a8a75e0009958237",
        //        "orderPrice": "0.00062",
        //        "orderType": "stop",
        //        "side": "sell",
        //        "size": "1",
        //        "stop": "entry",
        //        "stopPrice": "0.00062",
        //        "symbol": "KCS-BTC",
        //        "tradeType": "TRADE",
        //        "triggerSuccess": true,
        //        "ts": 1589790121382281286,
        //        "type": "triggered"
        //    }
        //
        object rawType = this.safeString(order, "type");
        object status = this.parseWsOrderStatus(rawType);
        object timestamp = this.safeInteger2(order, "orderTime", "createdAt");
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object triggerPrice = this.safeString(order, "stopPrice");
        object triggerSuccess = this.safeValue(order, "triggerSuccess");
        object triggerFail = isTrue((!isEqual(triggerSuccess, true))) && isTrue((!isEqual(triggerSuccess, null))); // TODO: updated to triggerSuccess === False once transpiler transpiles it correctly
        if (isTrue(isTrue((isEqual(status, "triggered"))) && isTrue(triggerFail)))
        {
            status = "canceled";
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "symbol", getValue(market, "symbol") },
            { "id", this.safeString(order, "orderId") },
            { "clientOrderId", this.safeString(order, "clientOid") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "type", this.safeStringLower(order, "orderType") },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", this.safeStringLower(order, "side") },
            { "price", this.safeString2(order, "price", "orderPrice") },
            { "stopPrice", triggerPrice },
            { "triggerPrice", triggerPrice },
            { "amount", this.safeString(order, "size") },
            { "cost", null },
            { "average", null },
            { "filled", this.safeString(order, "filledSize") },
            { "remaining", null },
            { "status", status },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        //
        // Trigger Orders
        //
        //    {
        //        "createdAt": 1692745706437,
        //        "error": "Balance insufficient!",       // not always there
        //        "orderId": "vs86kp757vlda6ni003qs70v",
        //        "orderPrice": "0.26",
        //        "orderType": "stop",
        //        "side": "sell",
        //        "size": "5",
        //        "stop": "loss",
        //        "stopPrice": "0.26",
        //        "symbol": "ADA-USDT",
        //        "tradeType": "TRADE",
        //        "triggerSuccess": false,                // not always there
        //        "ts": "1692745706442929298",
        //        "type": "open"
        //    }
        //
        object messageHash = "orders";
        object data = this.safeValue(message, "data");
        object parsed = this.parseWsOrder(data);
        object symbol = this.safeString(parsed, "symbol");
        object orderId = this.safeString(parsed, "id");
        object triggerPrice = this.safeValue(parsed, "triggerPrice");
        object isTriggerOrder = (!isEqual(triggerPrice, null));
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
            this.triggerOrders = new ArrayCacheBySymbolById(limit);
        }
        object cachedOrders = ((bool) isTrue(isTriggerOrder)) ? this.triggerOrders : this.orders;
        object orders = this.safeValue((cachedOrders as ArrayCacheBySymbolById).hashmap, symbol, new Dictionary<string, object>() {});
        object order = this.safeValue(orders, orderId);
        if (isTrue(!isEqual(order, null)))
        {
            // todo add others to calculate average etc
            if (isTrue(isEqual(getValue(order, "status"), "closed")))
            {
                ((IDictionary<string,object>)parsed)["status"] = "closed";
            }
        }
        callDynamically(cachedOrders, "append", new object[] {parsed});
        callDynamically(client as WebSocketClient, "resolve", new object[] {cachedOrders, messageHash});
        object symbolSpecificMessageHash = add(add(messageHash, ":"), symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {cachedOrders, symbolSpecificMessageHash});
    }

    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#watchMyTrades
        * @description watches information on multiple trades made by the user
        * @param {string} symbol unified market symbol of the market trades were made in
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trade structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object url = await this.negotiate(true);
        object topic = "/spot/tradeFills";
        object request = new Dictionary<string, object>() {
            { "privateChannel", true },
        };
        object messageHash = "myTrades";
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            symbol = getValue(market, "symbol");
            messageHash = add(add(messageHash, ":"), getValue(market, "symbol"));
        }
        object trades = await this.subscribe(url, messageHash, topic, this.extend(request, parameters));
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleMyTrade(WebSocketClient client, object message)
    {
        if (isTrue(isEqual(this.myTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            this.myTrades = new ArrayCacheBySymbolById(limit);
        }
        object data = this.safeDict(message, "data");
        object parsed = this.parseWsTrade(data);
        callDynamically(this.myTrades, "append", new object[] {parsed});
        object messageHash = "myTrades";
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.myTrades, messageHash});
        object symbolSpecificMessageHash = add(add(messageHash, ":"), getValue(parsed, "symbol"));
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.myTrades, symbolSpecificMessageHash});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        // {
        //     "fee": 0.00262148,
        //     "feeCurrency": "USDT",
        //     "feeRate": 0.001,
        //     "orderId": "62417436b29df8000183df2f",
        //     "orderType": "market",
        //     "price": 131.074,
        //     "side": "sell",
        //     "size": 0.02,
        //     "symbol": "LTC-USDT",
        //     "time": "1648456758734571745",
        //     "tradeId": "624174362e113d2f467b3043"
        //   }
        //
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market, "-");
        object symbol = getValue(market, "symbol");
        object type = this.safeString(trade, "orderType");
        object side = this.safeString(trade, "side");
        object tradeId = this.safeString(trade, "tradeId");
        object price = this.safeString(trade, "price");
        object amount = this.safeString(trade, "size");
        object order = this.safeString(trade, "orderId");
        object timestamp = this.safeIntegerProduct(trade, "time", 0.000001);
        object feeCurrency = getValue(market, "quote");
        object feeRate = this.safeString(trade, "feeRate");
        object feeCost = this.safeString(trade, "fee");
        object fee = new Dictionary<string, object>() {
            { "cost", feeCost },
            { "rate", feeRate },
            { "currency", feeCurrency },
        };
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", tradeId },
            { "order", order },
            { "type", type },
            { "takerOrMaker", null },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @name kucoin#watchBalance
        * @description watch balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object url = await this.negotiate(true);
        object topic = "/account/balance";
        object request = new Dictionary<string, object>() {
            { "privateChannel", true },
        };
        object messageHash = "balance";
        return await this.subscribe(url, messageHash, topic, this.extend(request, parameters));
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        // {
        //     "id":"6217a451294b030001e3a26a",
        //     "type":"message",
        //     "topic":"/account/balance",
        //     "userId":"6217707c52f97f00012a67db",
        //     "channelType":"private",
        //     "subject":"account.balance",
        //     "data":{
        //        "accountId":"62177fe67810720001db2f18",
        //        "available":"89",
        //        "availableChange":"-30",
        //        "currency":"USDT",
        //        "hold":"0",
        //        "holdChange":"0",
        //        "relationContext":{
        //        },
        //        "relationEvent":"main.transfer",
        //        "relationEventId":"6217a451294b030001e3a26a",
        //        "time":"1645716561816",
        //        "total":"89"
        //     }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object messageHash = "balance";
        object currencyId = this.safeString(data, "currency");
        object relationEvent = this.safeString(data, "relationEvent");
        object requestAccountType = null;
        if (isTrue(!isEqual(relationEvent, null)))
        {
            object relationEventParts = ((string)relationEvent).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
            requestAccountType = this.safeString(relationEventParts, 0);
        }
        object selectedType = this.safeString2(this.options, "watchBalance", "defaultType", "trade"); // trade, main, margin or other
        object accountsByType = this.safeValue(this.options, "accountsByType");
        object uniformType = this.safeString(accountsByType, requestAccountType, "trade");
        if (!isTrue((inOp(this.balance, uniformType))))
        {
            ((IDictionary<string,object>)this.balance)[(string)uniformType] = new Dictionary<string, object>() {};
        }
        ((IDictionary<string,object>)getValue(this.balance, uniformType))["info"] = data;
        object timestamp = this.safeInteger(data, "time");
        ((IDictionary<string,object>)getValue(this.balance, uniformType))["timestamp"] = timestamp;
        ((IDictionary<string,object>)getValue(this.balance, uniformType))["datetime"] = this.iso8601(timestamp);
        object code = this.safeCurrencyCode(currencyId);
        object account = this.account();
        ((IDictionary<string,object>)account)["free"] = this.safeString(data, "available");
        ((IDictionary<string,object>)account)["used"] = this.safeString(data, "hold");
        ((IDictionary<string,object>)account)["total"] = this.safeString(data, "total");
        ((IDictionary<string,object>)getValue(this.balance, uniformType))[(string)code] = account;
        ((IDictionary<string,object>)this.balance)[(string)uniformType] = this.safeBalance(getValue(this.balance, uniformType));
        if (isTrue(isEqual(uniformType, selectedType)))
        {
            callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, uniformType), messageHash});
        }
    }

    public virtual void handleSubject(WebSocketClient client, object message)
    {
        //
        //     {
        //         "type":"message",
        //         "topic":"/market/level2:BTC-USDT",
        //         "subject":"trade.l2update",
        //         "data":{
        //             "sequenceStart":1545896669105,
        //             "sequenceEnd":1545896669106,
        //             "symbol":"BTC-USDT",
        //             "changes": {
        //                 "asks": [["6","1","1545896669105"]], // price, size, sequence
        //                 "bids": [["4","1","1545896669106"]]
        //             }
        //         }
        //     }
        //
        object topic = this.safeString(message, "topic");
        if (isTrue(isEqual(topic, "/market/ticker:all")))
        {
            this.handleTicker(client as WebSocketClient, message);
            return;
        }
        object subject = this.safeString(message, "subject");
        object methods = new Dictionary<string, object>() {
            { "level1", this.handleBidAsk },
            { "level2", this.handleOrderBook },
            { "trade.l2update", this.handleOrderBook },
            { "trade.ticker", this.handleTicker },
            { "trade.snapshot", this.handleTicker },
            { "trade.l3match", this.handleTrade },
            { "trade.candles.update", this.handleOHLCV },
            { "account.balance", this.handleBalance },
            { "/spot/tradeFills", this.handleMyTrade },
            { "orderChange", this.handleOrder },
            { "stopOrder", this.handleOrder },
        };
        object method = this.safeValue(methods, subject);
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
    }

    public override object ping(WebSocketClient client)
    {
        // kucoin does not support built-in ws protocol-level ping-pong
        // instead it requires a custom json-based text ping-pong
        // https://docs.kucoin.com/#ping
        object id = ((object)this.requestId()).ToString();
        return new Dictionary<string, object>() {
            { "id", id },
            { "type", "ping" },
        };
    }

    public virtual void handlePong(WebSocketClient client, object message)
    {
        client.lastPong = this.milliseconds();
    }

    public virtual void handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //    {
        //        "id": "1",
        //        "type": "error",
        //        "code": 415,
        //        "data": "type is not supported"
        //    }
        //
        object data = this.safeString(message, "data", "");
        if (isTrue(isEqual(data, "token is expired")))
        {
            object type = "public";
            if (isTrue(isGreaterThanOrEqual(getIndexOf(client.url, "connectId=private"), 0)))
            {
                type = "private";
            }
            ((IDictionary<string,object>)getValue(this.options, "urls"))[(string)type] = null;
        }
        this.handleErrors(null, null, client.url, null, null, data, message, null, null);
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        object type = this.safeString(message, "type");
        object methods = new Dictionary<string, object>() {
            { "welcome", this.handleSystemStatus },
            { "ack", this.handleSubscriptionStatus },
            { "message", this.handleSubject },
            { "pong", this.handlePong },
            { "error", this.handleErrorMessage },
        };
        object method = this.safeValue(methods, type);
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
    }
}
