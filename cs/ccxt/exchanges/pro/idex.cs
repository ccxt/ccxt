namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class idex { public idex(object args = null) : base(args) { } }
public partial class idex : ccxt.idex
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchOrderBook", true },
                { "watchTrades", true },
                { "watchOHLCV", true },
                { "watchTicker", true },
                { "watchTickers", false },
                { "watchOrders", true },
                { "watchTransactions", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "test", new Dictionary<string, object>() {
                    { "ws", "wss://websocket-matic.idex.io/v1" },
                } },
                { "api", new Dictionary<string, object>() {} },
            } },
            { "options", new Dictionary<string, object>() {
                { "tradesLimit", 1000 },
                { "ordersLimit", 1000 },
                { "OHLCVLimit", 1000 },
                { "watchOrderBookLimit", 1000 },
                { "orderBookSubscriptions", new Dictionary<string, object>() {} },
                { "token", null },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "maxRetries", 3 },
                } },
                { "fetchOrderBookSnapshotMaxAttempts", 10 },
                { "fetchOrderBookSnapshotMaxDelay", 10000 },
            } },
        });
    }

    public async virtual Task<object> subscribe(object subscribeObject, object messageHash, object subscription = null)
    {
        subscription ??= true;
        object url = getValue(getValue(this.urls, "test"), "ws");
        object request = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "subscriptions", new List<object>() {subscribeObject} },
        };
        return await this.watch(url, messageHash, request, messageHash, subscription);
    }

    public async virtual Task<object> subscribePrivate(object subscribeObject, object messageHash)
    {
        object token = await this.authenticate();
        object url = getValue(getValue(this.urls, "test"), "ws");
        object request = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "token", token },
            { "subscriptions", new List<object>() {subscribeObject} },
        };
        return await this.watch(url, messageHash, request, messageHash);
    }

    /**
     * @method
     * @name idex#watchTicker
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object name = "tickers";
        object subscribeObject = new Dictionary<string, object>() {
            { "name", name },
            { "markets", new List<object>() {getValue(market, "id")} },
        };
        object messageHash = add(add(name, ":"), getValue(market, "id"));
        return await this.subscribe(this.extend(subscribeObject, parameters), messageHash);
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        // { type: "tickers",
        //   "data":
        //    { m: "DIL-ETH",
        //      "t": 1599213946045,
        //      "o": "0.09699020",
        //      "h": "0.10301548",
        //      "l": "0.09577222",
        //      "c": "0.09907311",
        //      "Q": "1.32723120",
        //      "v": "297.80667468",
        //      "q": "29.52142669",
        //      "P": "2.14",
        //      "n": 197,
        //      "a": "0.09912245",
        //      "b": "0.09686980",
        //      "u": 5870 } }
        object type = this.safeString(message, "type");
        object data = this.safeValue(message, "data");
        object marketId = this.safeString(data, "m");
        object symbol = this.safeSymbol(marketId);
        object messageHash = add(add(type, ":"), marketId);
        object timestamp = this.safeInteger(data, "t");
        object close = this.safeString(data, "c");
        object percentage = this.safeString(data, "P");
        object change = null;
        if (isTrue(isTrue((!isEqual(percentage, null))) && isTrue((!isEqual(close, null)))))
        {
            change = Precise.stringMul(close, percentage);
        }
        object ticker = this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(data, "h") },
            { "low", this.safeString(data, "l") },
            { "bid", this.safeString(data, "b") },
            { "bidVolume", null },
            { "ask", this.safeString(data, "a") },
            { "askVolume", null },
            { "vwap", null },
            { "open", this.safeString(data, "o") },
            { "close", close },
            { "last", close },
            { "previousClose", null },
            { "change", change },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", this.safeString(data, "v") },
            { "quoteVolume", this.safeString(data, "q") },
            { "info", message },
        });
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
    }

    /**
     * @method
     * @name idex#watchTrades
     * @description get the list of most recent trades for a particular symbol
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object name = "trades";
        object subscribeObject = new Dictionary<string, object>() {
            { "name", name },
            { "markets", new List<object>() {getValue(market, "id")} },
        };
        object messageHash = add(add(name, ":"), getValue(market, "id"));
        object trades = await this.subscribe(subscribeObject, messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrade(WebSocketClient client, object message)
    {
        object type = this.safeString(message, "type");
        object data = this.safeValue(message, "data");
        object marketId = this.safeString(data, "m");
        object messageHash = add(add(type, ":"), marketId);
        object trade = this.parseWsTrade(data);
        object keys = new List<object>(((IDictionary<string,object>)this.trades).Keys);
        object length = getArrayLength(keys);
        if (isTrue(isEqual(length, 0)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit");
            this.trades = ((object)new ArrayCacheBySymbolById(limit));
        }
        object trades = ((object)this.trades);
        callDynamically(trades, "append", new object[] {trade});
        callDynamically(client as WebSocketClient, "resolve", new object[] {trades, messageHash});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        // public trades
        // { m: "DIL-ETH",
        //   "i": "897ecae6-4b75-368a-ac00-be555e6ad65f",
        //   "p": "0.09696995",
        //   "q": "2.00000000",
        //   "Q": "0.19393990",
        //   "t": 1599504616247,
        //   "s": "buy",
        //   "u": 6620 }
        // private trades
        // { i: "ee253d78-88be-37ed-a61c-a36395c2ce48",
        //   "p": "0.09925382",
        //   "q": "0.15000000",
        //   "Q": "0.01488807",
        //   "t": 1599499129369,
        //   "s": "sell",
        //   "u": 6603,
        //   "f": "0.00030000",
        //   "a": "DIL",
        //   "g": "0.00856110",
        //   "l": "maker",
        //   "S": "pending" }
        object marketId = this.safeString(trade, "m");
        object symbol = this.safeSymbol(marketId);
        object id = this.safeString(trade, "i");
        object price = this.safeString(trade, "p");
        object amount = this.safeString(trade, "q");
        object cost = this.safeString(trade, "Q");
        object timestamp = this.safeInteger(trade, "t");
        object side = this.safeString(trade, "s");
        object fee = new Dictionary<string, object>() {
            { "currency", this.safeString(trade, "a") },
            { "cost", this.safeString(trade, "f") },
        };
        object takerOrMarker = this.safeString(trade, "l");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", id },
            { "order", null },
            { "type", null },
            { "takerOrMaker", takerOrMarker },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "fee", fee },
        });
    }

    /**
     * @method
     * @name idex#watchOHLCV
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object name = "candles";
        object interval = this.safeString(this.timeframes, timeframe, timeframe);
        object subscribeObject = new Dictionary<string, object>() {
            { "name", name },
            { "markets", new List<object>() {getValue(market, "id")} },
            { "interval", interval },
        };
        object messageHash = add(add(name, ":"), getValue(market, "id"));
        object ohlcv = await this.subscribe(subscribeObject, messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        // { type: "candles",
        //   "data":
        //    { m: "DIL-ETH",
        //      "t": 1599477340109,
        //      "i": "1m",
        //      "s": 1599477300000,
        //      "e": 1599477360000,
        //      "o": "0.09911040",
        //      "h": "0.09911040",
        //      "l": "0.09911040",
        //      "c": "0.09911040",
        //      "v": "0.15000000",
        //      "n": 1,
        //      "u": 6531 } }
        object type = this.safeString(message, "type");
        object data = this.safeValue(message, "data");
        object marketId = this.safeString(data, "m");
        object messageHash = add(add(type, ":"), marketId);
        object parsed = new List<object> {this.safeInteger(data, "s"), this.safeFloat(data, "o"), this.safeFloat(data, "h"), this.safeFloat(data, "l"), this.safeFloat(data, "c"), this.safeFloat(data, "v")};
        object symbol = this.safeSymbol(marketId);
        object interval = this.safeString(data, "i");
        object timeframe = this.findTimeframe(interval);
        // TODO: move to base class
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
        }
        callDynamically(stored, "append", new object[] {parsed});
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public virtual void handleSubscribeMessage(WebSocketClient client, object message)
    {
        // {
        //   "type": "subscriptions",
        //   "subscriptions": [
        //     {
        //       "name": "l2orderbook",
        //       "markets": [
        //         "DIL-ETH"
        //       ]
        //     }
        //   ]
        // }
        object subscriptions = this.safeValue(message, "subscriptions");
        for (object i = 0; isLessThan(i, getArrayLength(subscriptions)); postFixIncrement(ref i))
        {
            object subscription = getValue(subscriptions, i);
            object name = this.safeString(subscription, "name");
            if (isTrue(isEqual(name, "l2orderbook")))
            {
                object markets = this.safeValue(subscription, "markets");
                for (object j = 0; isLessThan(j, getArrayLength(markets)); postFixIncrement(ref j))
                {
                    object marketId = getValue(markets, j);
                    object orderBookSubscriptions = this.safeValue(this.options, "orderBookSubscriptions", new Dictionary<string, object>() {});
                    if (!isTrue((inOp(orderBookSubscriptions, marketId))))
                    {
                        object symbol = this.safeSymbol(marketId);
                        if (!isTrue((inOp(this.orderbooks, symbol))))
                        {
                            object orderbook = this.countedOrderBook(new Dictionary<string, object>() {});
                            // (orderbook as ccxt.pro.OrderBook).cache = []; // cache is never used?
                            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
                        }
                        this.spawn(this.fetchOrderBookSnapshot, new object[] { client, symbol});
                    }
                }
                break;
            }
        }
    }

    public async virtual Task fetchOrderBookSnapshot(WebSocketClient client, object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object orderbook = getValue(this.orderbooks, symbol);
        object market = this.market(symbol);
        object messageHash = add(add("l2orderbook", ":"), getValue(market, "id"));
        object subscription = getValue(((WebSocketClient)client).subscriptions, messageHash);
        if (!isTrue(getValue(subscription, "fetchingOrderBookSnapshot")))
        {
            ((IDictionary<string,object>)subscription)["startTime"] = this.milliseconds();
        }
        ((IDictionary<string,object>)subscription)["fetchingOrderBookSnapshot"] = true;
        object maxAttempts = this.safeInteger(this.options, "fetchOrderBookSnapshotMaxAttempts", 10);
        object maxDelay = this.safeInteger(this.options, "fetchOrderBookSnapshotMaxDelay", 10000);
        try
        {
            object limit = this.safeInteger(subscription, "limit", 0);
            // 3. Request a level-2 order book snapshot for the market from the REST API Order Books endpoint with limit set to 0.
            object snapshot = await this.fetchRestOrderBookSafe(symbol, limit);
            object firstBuffered = this.safeValue((orderbook as ccxt.pro.OrderBook).cache, 0);
            object firstData = this.safeValue(firstBuffered, "data");
            object firstNonce = this.safeInteger(firstData, "u");
            object length = getArrayLength((orderbook as ccxt.pro.OrderBook).cache);
            object lastBuffered = this.safeValue((orderbook as ccxt.pro.OrderBook).cache, subtract(length, 1));
            object lastData = this.safeValue(lastBuffered, "data");
            object lastNonce = this.safeInteger(lastData, "u");
            object bothExist = isTrue((!isEqual(firstNonce, null))) && isTrue((!isEqual(lastNonce, null)));
            // ensure the snapshot is inside the range of our cached messages
            // for example if the snapshot nonce is 100
            // the first nonce must be less than or equal to 101 and the last nonce must be greater than 101
            if (isTrue(isTrue(isTrue(bothExist) && isTrue((isLessThanOrEqual(firstNonce, add(getValue(snapshot, "nonce"), 1))))) && isTrue((isGreaterThan(lastNonce, getValue(snapshot, "nonce"))))))
            {
                (orderbook as IOrderBook).reset(snapshot);
                for (object i = 0; isLessThan(i, getArrayLength((orderbook as ccxt.pro.OrderBook).cache)); postFixIncrement(ref i))
                {
                    object message = getValue((orderbook as ccxt.pro.OrderBook).cache, i);
                    object data = this.safeValue(message, "data");
                    object u = this.safeInteger(data, "u");
                    if (isTrue(isGreaterThan(u, getValue(orderbook, "nonce"))))
                    {
                        // 5. Discard all order book update messages with sequence numbers less than or equal to the snapshot sequence number.
                        // 6. Apply the remaining buffered order book update messages and any incoming order book update messages to the order book snapshot.
                        this.handleOrderBookMessage(client as WebSocketClient, message, orderbook);
                    }
                }
                ((IDictionary<string,object>)subscription)["fetchingOrderBookSnapshot"] = false;
                callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
            } else
            {
                // 4. If the sequence in the order book snapshot is less than the sequence of the
                //    first buffered order book update message, discard the order book snapshot and retry step 3.
                // this will continue to recurse until we have a buffered message
                // since updates the order book endpoint depend on order events
                // so it will eventually throw if there are no orders on a pair
                ((IDictionary<string,object>)subscription)["numAttempts"] = add(getValue(subscription, "numAttempts"), 1);
                object timeElapsed = subtract(this.milliseconds(), getValue(subscription, "startTime"));
                object maxAttemptsValid = isLessThan(getValue(subscription, "numAttempts"), maxAttempts);
                object timeElapsedValid = isLessThan(timeElapsed, maxDelay);
                if (isTrue(isTrue(maxAttemptsValid) && isTrue(timeElapsedValid)))
                {
                    this.delay(this.rateLimit,  this.fetchOrderBookSnapshot, new object[] { client, symbol});
                } else
                {
                    object endpart = ((bool) isTrue((!isTrue(maxAttemptsValid)))) ? add(add(" in ", ((object)maxAttempts).ToString()), " attempts") : add(add(" after ", ((object)maxDelay).ToString()), " milliseconds");
                    throw new InvalidNonce ((string)add(add(add(this.id, " failed to synchronize WebSocket feed with the snapshot for symbol "), symbol), endpart)) ;
                }
            }
        } catch(Exception e)
        {
            ((IDictionary<string,object>)subscription)["fetchingOrderBookSnapshot"] = false;
            ((WebSocketClient)client).reject(e, messageHash);
        }
    }

    /**
     * @method
     * @name idex#watchOrderBook
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object name = "l2orderbook";
        object subscribeObject = new Dictionary<string, object>() {
            { "name", name },
            { "markets", new List<object>() {getValue(market, "id")} },
        };
        object messageHash = add(add(name, ":"), getValue(market, "id"));
        object subscription = new Dictionary<string, object>() {
            { "fetchingOrderBookSnapshot", false },
            { "numAttempts", 0 },
            { "startTime", null },
        };
        if (isTrue(isEqual(limit, null)))
        {
            ((IDictionary<string,object>)subscription)["limit"] = 1000;
        } else
        {
            ((IDictionary<string,object>)subscription)["limit"] = limit;
        }
        // 1. Connect to the WebSocket API endpoint and subscribe to the L2 Order Book for the target market.
        object orderbook = await this.subscribe(subscribeObject, messageHash, ((object)subscription));
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        object data = this.safeValue(message, "data");
        object marketId = this.safeString(data, "m");
        object symbol = this.safeSymbol(marketId);
        object orderbook = getValue(this.orderbooks, symbol);
        if (isTrue(isEqual(getValue(orderbook, "nonce"), null)))
        {
            // 2. Buffer the incoming order book update subscription messages.
            ((IList<object>)(orderbook as ccxt.pro.OrderBook).cache).Add(message);
        } else
        {
            this.handleOrderBookMessage(client as WebSocketClient, message, orderbook);
        }
    }

    public virtual void handleOrderBookMessage(WebSocketClient client, object message, object orderbook)
    {
        // {
        //   "type": "l2orderbook",
        //   "data": {
        //     "m": "DIL-ETH",
        //     "t": 1600197205037,
        //     "u": 94116643,
        //     "b": [
        //       [
        //         "0.09662187",
        //         "0.00000000",
        //         0
        //       ]
        //     ],
        //     "a": []
        //   }
        // }
        object type = this.safeString(message, "type");
        object data = this.safeValue(message, "data");
        object marketId = this.safeString(data, "m");
        object messageHash = add(add(type, ":"), marketId);
        object nonce = this.safeInteger(data, "u");
        object timestamp = this.safeInteger(data, "t");
        object bids = this.safeValue(data, "b");
        object asks = this.safeValue(data, "a");
        this.handleDeltas(getValue(orderbook, "bids"), bids);
        this.handleDeltas(getValue(orderbook, "asks"), asks);
        ((IDictionary<string,object>)orderbook)["nonce"] = nonce;
        ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
        ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public override void handleDelta(object bookside, object delta)
    {
        object price = this.safeFloat(delta, 0);
        object amount = this.safeFloat(delta, 1);
        object count = this.safeInteger(delta, 2);
        (bookside as IOrderBookSide).storeArray(new List<object>() {price, amount, count});
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object time = this.seconds();
        object lastAuthenticatedTime = this.safeInteger(this.options, "lastAuthenticatedTime", 0);
        if (isTrue(isGreaterThan(subtract(time, lastAuthenticatedTime), 900)))
        {
            object request = new Dictionary<string, object>() {
                { "wallet", this.walletAddress },
                { "nonce", this.uuidv1() },
            };
            object response = await this.privateGetWsToken(this.extend(request, parameters));
            ((IDictionary<string,object>)this.options)["lastAuthenticatedTime"] = time;
            ((IDictionary<string,object>)this.options)["token"] = this.safeString(response, "token");
        }
        return getValue(this.options, "token");
    }

    /**
     * @method
     * @name idex#watchOrders
     * @description watches information on multiple orders made by the user
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "orders";
        object subscribeObject = new Dictionary<string, object>() {
            { "name", name },
        };
        object messageHash = name;
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
            object marketId = this.marketId(symbol);
            ((IDictionary<string,object>)subscribeObject)["markets"] = new List<object>() {marketId};
            messageHash = add(add(name, ":"), marketId);
        }
        object orders = await this.subscribePrivate(subscribeObject, messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(orders, since, limit, "timestamp", true);
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        // {
        //   "type": "orders",
        //   "data": {
        //     "m": "DIL-ETH",
        //     "i": "8f75dd30-f12d-11ea-b63c-df3381b4b5b4",
        //     "w": "0x0AB991497116f7F5532a4c2f4f7B1784488628e1",
        //     "t": 1599498857138,
        //     "T": 1599498857092,
        //     "x": "fill",
        //     "X": "filled",
        //     "u": 67695627,
        //     "o": "limit",
        //     "S": "buy",
        //     "q": "0.15000000",
        //     "z": "0.15000000",
        //     "Z": "0.01486286",
        //     "v": "0.09908573",
        //     "p": "1.00000000",
        //     "f": "gtc",
        //     "V": "2",
        //     "F": [
        //       {
        //         "i": "5cdc6d14-bc35-3279-ab5e-40d654ca1523",
        //         "p": "0.09908577",
        //         "q": "0.15000000",
        //         "Q": "0.01486286",
        //         "t": 1599498857092,
        //         "s": "sell",
        //         "u": 6600,
        //         "f": "0.00030000",
        //         "a": "DIL",
        //         "g": "0.00856977",
        //         "l": "maker",
        //         "S": "pending"
        //       }
        //     ]
        //   }
        // }
        object type = this.safeString(message, "type");
        object order = this.safeValue(message, "data");
        object marketId = this.safeString(order, "m");
        object symbol = this.safeSymbol(marketId);
        object timestamp = this.safeInteger(order, "t");
        object fills = this.safeValue(order, "F", new List<object>() {});
        object trades = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(fills)); postFixIncrement(ref i))
        {
            ((IList<object>)trades).Add(this.parseWsTrade(getValue(fills, i)));
        }
        object id = this.safeString(order, "i");
        object side = this.safeString(order, "s");
        object orderType = this.safeString(order, "o");
        object amount = this.safeString(order, "q");
        object filled = this.safeString(order, "z");
        object average = this.safeString(order, "v");
        object price = this.safeString(order, "price", average); // for market orders
        object rawStatus = this.safeString(order, "X");
        object status = this.parseOrderStatus(rawStatus);
        object fee = new Dictionary<string, object>() {
            { "currency", null },
            { "cost", null },
        };
        object lastTrade = null;
        for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
        {
            lastTrade = getValue(trades, i);
            ((IDictionary<string,object>)fee)["currency"] = getValue(getValue(lastTrade, "fee"), "currency");
            object stringLastTradeFee = getValue(getValue(lastTrade, "fee"), "cost");
            ((IDictionary<string,object>)fee)["cost"] = Precise.stringAdd(getValue(fee, "cost"), stringLastTradeFee);
        }
        object lastTradeTimestamp = this.safeInteger(lastTrade, "timestamp");
        object parsedOrder = this.safeOrder(new Dictionary<string, object>() {
            { "info", message },
            { "id", id },
            { "clientOrderId", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "symbol", symbol },
            { "type", orderType },
            { "side", side },
            { "price", this.parseNumber(price) },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "amount", this.parseNumber(amount) },
            { "cost", null },
            { "average", this.parseNumber(average) },
            { "filled", this.parseNumber(filled) },
            { "remaining", null },
            { "status", status },
            { "fee", fee },
            { "trades", trades },
        });
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object orders = this.orders;
        callDynamically(orders, "append", new object[] {parsedOrder});
        object symbolSpecificMessageHash = add(add(type, ":"), marketId);
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, symbolSpecificMessageHash});
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, type});
    }

    public async virtual Task<object> watchTransactions(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "balances";
        object subscribeObject = new Dictionary<string, object>() {
            { "name", name },
        };
        object messageHash = name;
        if (isTrue(!isEqual(code, null)))
        {
            messageHash = add(add(name, ":"), code);
        }
        object transactions = await this.subscribePrivate(subscribeObject, messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(transactions, "getLimit", new object[] {code, limit});
        }
        return this.filterBySinceLimit(transactions, since, limit, "timestamp");
    }

    public virtual void handleTransaction(WebSocketClient client, object message)
    {
        // Update Speed: Real time, updates on any deposit or withdrawal of the wallet
        // { type: "balances",
        //   "data":
        //    { w: "0x0AB991497116f7F5532a4c2f4f7B1784488628e1",
        //      "a": "ETH",
        //      "q": "0.11198667",
        //      "f": "0.11198667",
        //      "l": "0.00000000",
        //      "d": "0.00" } }
        object type = this.safeString(message, "type");
        object data = this.safeValue(message, "data");
        object currencyId = this.safeString(data, "a");
        object messageHash = add(add(type, ":"), currencyId);
        object code = this.safeCurrencyCode(currencyId);
        object address = this.safeString(data, "w");
        object transaction = new Dictionary<string, object>() {
            { "info", message },
            { "id", null },
            { "currency", code },
            { "amount", null },
            { "address", address },
            { "addressTo", null },
            { "addressFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "status", "ok" },
            { "type", null },
            { "updated", null },
            { "txid", null },
            { "timestamp", null },
            { "datetime", null },
            { "fee", null },
        };
        if (!isTrue((inOp(this.transactions, code))))
        {
            object limit = this.safeInteger(this.options, "transactionsLimit", 1000);
            ((IDictionary<string,object>)this.transactions)[(string)code] = new ArrayCache(limit);
        }
        object transactions = getValue(this.transactions, code);
        callDynamically(transactions, "append", new object[] {transaction});
        callDynamically(client as WebSocketClient, "resolve", new object[] {transactions, messageHash});
        callDynamically(client as WebSocketClient, "resolve", new object[] {transactions, type});
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        object type = this.safeString(message, "type");
        object methods = new Dictionary<string, object>() {
            { "tickers", this.handleTicker },
            { "trades", this.handleTrade },
            { "subscriptions", this.handleSubscribeMessage },
            { "candles", this.handleOHLCV },
            { "l2orderbook", this.handleOrderBook },
            { "balances", this.handleTransaction },
            { "orders", this.handleOrder },
        };
        if (isTrue(inOp(methods, type)))
        {
            object method = getValue(methods, type);
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
    }
}
