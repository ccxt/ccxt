namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class apex { public apex(object args = null) : base(args) { } }
public partial class apex : ccxt.apex
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchOrderBook", true },
                { "watchOrders", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", false },
                { "watchPositions", true },
                { "watchMyTrades", true },
                { "watchBalance", false },
                { "watchOHLCV", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://omni.apex.exchange/assets/logo_content-CY9uyFbz.svg" },
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://quote.omni.apex.exchange/realtime_public?v=2" },
                        { "private", "wss://quote.omni.apex.exchange/realtime_private?v=2" },
                    } },
                } },
                { "test", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://qa-quote.omni.apex.exchange/realtime_public?v=2" },
                        { "private", "wss://qa-quote.omni.apex.exchange/realtime_private?v=2" },
                    } },
                } },
                { "www", "https://apex.exchange/" },
                { "doc", "https://api-docs.pro.apex.exchange" },
                { "fees", "https://apex-pro.gitbook.io/apex-pro/apex-omni-live-now/trading-perpetual-contracts/trading-fees" },
                { "referral", "https://omni.apex.exchange/trade" },
            } },
            { "options", new Dictionary<string, object>() {} },
            { "streaming", new Dictionary<string, object>() {
                { "ping", this.ping },
                { "keepAlive", 18000 },
            } },
        });
    }

    /**
     * @method
     * @name apex#watchTrades
     * @description watches information on multiple trades made in a market
     * @see https://api-docs.pro.apex.exchange/#websocket-v3-for-omni-websocket-endpoint
     * @param {string} symbol unified market symbol of the market trades were made in
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trade structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    /**
     * @method
     * @name apex#watchTradesForSymbols
     * @description get the list of most recent trades for a list of symbols
     * @see https://api-docs.pro.apex.exchange/#websocket-v3-for-omni-websocket-endpoint
     * @param {string[]} symbols unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object symbolsLength = getArrayLength(symbols);
        if (isTrue(isEqual(symbolsLength, 0)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchTradesForSymbols() requires a non-empty array of symbols")) ;
        }
        object timeStamp = ((object)this.milliseconds()).ToString();
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "public"), "&timestamp="), timeStamp);
        object topics = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = this.market(symbol);
            object topic = add("recentlyTrade.H.", getValue(market, "id2"));
            ((IList<object>)topics).Add(topic);
            object messageHash = add("trade:", symbol);
            ((IList<object>)messageHashes).Add(messageHash);
        }
        object trades = await this.watchTopics(url, messageHashes, topics, parameters);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeValue(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //         "topic": "recentlyTrade.H.BTCUSDT",
        //         "type": "snapshot",
        //         "ts": 1672304486868,
        //         "data": [
        //             {
        //                 "T": 1672304486865,
        //                 "s": "BTCUSDT",
        //                 "S": "Buy",
        //                 "v": "0.001",
        //                 "p": "16578.50",
        //                 "L": "PlusTick",
        //                 "i": "20f43950-d8dd-5b31-9112-a178eb6023af",
        //                 "BT": false
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object topic = this.safeString(message, "topic");
        object trades = data;
        object parts = ((string)topic).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(parts, 2);
        object market = this.safeMarket(marketId, null, null);
        object symbol = getValue(market, "symbol");
        object stored = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        for (object j = 0; isLessThan(j, getArrayLength(trades)); postFixIncrement(ref j))
        {
            object parsed = this.parseWsTrade(getValue(trades, j), market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        object messageHash = add(add("trade", ":"), symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        // public
        //    {
        //         "T": 1672304486865,
        //         "s": "BTCUSDT",
        //         "S": "Buy",
        //         "v": "0.001",
        //         "p": "16578.50",
        //         "L": "PlusTick",
        //         "i": "20f43950-d8dd-5b31-9112-a178eb6023af",
        //         "BT": false
        //     }
        //
        object id = this.safeStringN(trade, new List<object>() {"i", "id", "v"});
        object marketId = this.safeStringN(trade, new List<object>() {"s", "symbol"});
        market = this.safeMarket(marketId, market, null);
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeIntegerN(trade, new List<object>() {"t", "T", "createdAt"});
        object side = this.safeStringLowerN(trade, new List<object>() {"S", "side"});
        object price = this.safeStringN(trade, new List<object>() {"p", "price"});
        object amount = this.safeStringN(trade, new List<object>() {"q", "v", "size"});
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "order", null },
            { "type", null },
            { "side", side },
            { "takerOrMaker", null },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", null },
        }, market);
    }

    /**
     * @method
     * @name apex#watchOrderBook
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://api-docs.pro.apex.exchange/#websocket-v3-for-omni-websocket-endpoint
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return.
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.watchOrderBookForSymbols(new List<object>() {symbol}, limit, parameters);
    }

    /**
     * @method
     * @name apex#watchOrderBookForSymbols
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://api-docs.pro.apex.exchange/#websocket-v3-for-omni-websocket-endpoint
     * @param {string[]} symbols unified array of symbols
     * @param {int} [limit] the maximum amount of order book entries to return.
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object symbolsLength = getArrayLength(symbols);
        if (isTrue(isEqual(symbolsLength, 0)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchOrderBookForSymbols() requires a non-empty array of symbols")) ;
        }
        symbols = this.marketSymbols(symbols);
        object timeStamp = ((object)this.milliseconds()).ToString();
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "public"), "&timestamp="), timeStamp);
        object topics = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = this.market(symbol);
            if (isTrue(isEqual(limit, null)))
            {
                limit = 25;
            }
            object topic = add(add(add("orderBook", ((object)limit).ToString()), ".H."), getValue(market, "id2"));
            ((IList<object>)topics).Add(topic);
            object messageHash = add("orderbook:", symbol);
            ((IList<object>)messageHashes).Add(messageHash);
        }
        object orderbook = await this.watchTopics(url, messageHashes, topics, parameters);
        return (orderbook as IOrderBook).limit();
    }

    public async virtual Task<object> watchTopics(object url, object messageHashes, object topics, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", topics },
        };
        object message = this.extend(request, parameters);
        return await this.watchMultiple(url, messageHashes, message, messageHashes);
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //     {
        //         "topic": "orderbook25.H.BTCUSDT",
        //         "type": "snapshot",
        //         "ts": 1672304484978,
        //         "data": {
        //             "s": "BTCUSDT",
        //             "b": [
        //                 ...,
        //                 [
        //                     "16493.50",
        //                     "0.006"
        //                 ],
        //                 [
        //                     "16493.00",
        //                     "0.100"
        //                 ]
        //             ],
        //             "a": [
        //                 [
        //                     "16611.00",
        //                     "0.029"
        //                 ],
        //                 [
        //                     "16612.00",
        //                     "0.213"
        //                 ],
        //             ],
        //             "u": 18521288,
        //             "seq": 7961638724
        //         }
        //     }
        //
        object type = this.safeString(message, "type");
        object isSnapshot = (isEqual(type, "snapshot"));
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "s");
        object market = this.safeMarket(marketId, null, null);
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeIntegerProduct(message, "ts", 0.001);
        if (!isTrue((inOp(this.orderbooks, symbol))))
        {
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook();
        }
        object orderbook = getValue(this.orderbooks, symbol);
        if (isTrue(isSnapshot))
        {
            object snapshot = this.parseOrderBook(data, symbol, timestamp, "b", "a");
            (orderbook as IOrderBook).reset(snapshot);
        } else
        {
            object asks = this.safeList(data, "a", new List<object>() {});
            object bids = this.safeList(data, "b", new List<object>() {});
            this.handleDeltas(getValue(orderbook, "asks"), asks);
            this.handleDeltas(getValue(orderbook, "bids"), bids);
            ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        }
        object messageHash = add(add("orderbook", ":"), symbol);
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public override void handleDelta(object bookside, object delta)
    {
        object bidAsk = this.parseBidAsk(delta, 0, 1);
        (bookside as IOrderBookSide).storeArray(bidAsk);
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    /**
     * @method
     * @name apex#watchTicker
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://api-docs.pro.apex.exchange/#websocket-v3-for-omni-websocket-endpoint
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object timeStamp = ((object)this.milliseconds()).ToString();
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "public"), "&timestamp="), timeStamp);
        object messageHash = add("ticker:", symbol);
        object topic = add(add("instrumentInfo", ".H."), getValue(market, "id2"));
        object topics = new List<object>() {topic};
        return await this.watchTopics(url, new List<object>() {messageHash}, topics, parameters);
    }

    /**
     * @method
     * @name apex#watchTickers
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
     * @see https://api-docs.pro.apex.exchange/#websocket-v3-for-omni-websocket-endpoint
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object messageHashes = new List<object>() {};
        object timeStamp = ((object)this.milliseconds()).ToString();
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "public"), "&timestamp="), timeStamp);
        object topics = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = this.market(symbol);
            object topic = add(add("instrumentInfo", ".H."), getValue(market, "id2"));
            ((IList<object>)topics).Add(topic);
            object messageHash = add("ticker:", symbol);
            ((IList<object>)messageHashes).Add(messageHash);
        }
        object ticker = await this.watchTopics(url, messageHashes, topics, parameters);
        if (isTrue(this.newUpdates))
        {
            object result = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)result)[(string)getValue(ticker, "symbol")] = ticker;
            return result;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        // "topic":"instrumentInfo.H.BTCUSDT",
        //     "type":"snapshot",
        //     "data":{
        //     "symbol":"BTCUSDT",
        //         "lastPrice":"21572.5",
        //         "price24hPcnt":"-0.0194318181818182",
        //         "highPrice24h":"25306.5",
        //         "lowPrice24h":"17001.5",
        //         "turnover24h":"1334891.4545",
        //         "volume24h":"64.896",
        //         "nextFundingTime":"2022-08-26T08:00:00Z",
        //         "oraclePrice":"21412.060000000002752512",
        //         "indexPrice":"21409.82",
        //         "openInterest":"49.598",
        //         "tradeCount":"0",
        //         "fundingRate":"0.0000125",
        //         "predictedFundingRate":"0.0000125"
        // },
        //     "cs":44939063,
        //     "ts":1661500091955487
        // }
        object topic = this.safeString(message, "topic", "");
        object updateType = this.safeString(message, "type", "");
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object symbol = null;
        object parsed = null;
        if (isTrue((isEqual(updateType, "snapshot"))))
        {
            parsed = this.parseTicker(data);
            symbol = getValue(parsed, "symbol");
        } else if (isTrue(isEqual(updateType, "delta")))
        {
            object topicParts = ((string)topic).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
            object topicLength = getArrayLength(topicParts);
            object marketId = this.safeString(topicParts, subtract(topicLength, 1));
            object market = this.safeMarket(marketId, null, null);
            symbol = getValue(market, "symbol");
            object ticker = this.safeDict(this.tickers, symbol, new Dictionary<string, object>() {});
            object rawTicker = this.safeDict(ticker, "info", new Dictionary<string, object>() {});
            object merged = this.extend(rawTicker, data);
            parsed = this.parseTicker(merged);
        }
        object timestamp = this.safeIntegerProduct(message, "ts", 0.001);
        ((IDictionary<string,object>)parsed)["timestamp"] = timestamp;
        ((IDictionary<string,object>)parsed)["datetime"] = this.iso8601(timestamp);
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = parsed;
        object messageHash = add("ticker:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.tickers, symbol), messageHash});
    }

    /**
     * @method
     * @name apex#watchOHLCV
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://api-docs.pro.apex.exchange/#websocket-v3-for-omni-websocket-endpoint
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["callerMethodName"] = "watchOHLCV";
        object result = await this.watchOHLCVForSymbols(new List<object>() {new List<object>() {symbol, timeframe}}, since, limit, parameters);
        return getValue(getValue(result, symbol), timeframe);
    }

    /**
     * @method
     * @name apex#watchOHLCVForSymbols
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://api-docs.pro.apex.exchange/#websocket-v3-for-omni-websocket-endpoint
     * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCVForSymbols(object symbolsAndTimeframes, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object timeStamp = ((object)this.milliseconds()).ToString();
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "public"), "&timestamp="), timeStamp);
        object rawHashes = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbolsAndTimeframes)); postFixIncrement(ref i))
        {
            object data = getValue(symbolsAndTimeframes, i);
            object symbolString = this.safeString(data, 0);
            object market = this.market(symbolString);
            symbolString = getValue(market, "id2");
            object unfiedTimeframe = this.safeString(data, 1, "1");
            object timeframeId = this.safeString(this.timeframes, unfiedTimeframe, unfiedTimeframe);
            ((IList<object>)rawHashes).Add(add(add(add("candle.", timeframeId), "."), symbolString));
            ((IList<object>)messageHashes).Add(add(add(add("ohlcv::", symbolString), "::"), unfiedTimeframe));
        }
        var symboltimeframestoredVariable = await this.watchTopics(url, messageHashes, rawHashes, parameters);
        var symbol = ((IList<object>) symboltimeframestoredVariable)[0];
        var timeframe = ((IList<object>) symboltimeframestoredVariable)[1];
        var stored = ((IList<object>) symboltimeframestoredVariable)[2];
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(stored, "getLimit", new object[] {symbol, limit});
        }
        object filtered = this.filterBySinceLimit(stored, since, limit, 0, true);
        return this.createOHLCVObject(symbol, timeframe, filtered);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "topic": "candle.5.BTCUSDT",
        //         "data": [
        //             {
        //                 "start": 1672324800000,
        //                 "end": 1672325099999,
        //                 "interval": "5",
        //                 "open": "16649.5",
        //                 "close": "16677",
        //                 "high": "16677",
        //                 "low": "16608",
        //                 "volume": "2.081",
        //                 "turnover": "34666.4005",
        //                 "confirm": false,
        //                 "timestamp": 1672324988882
        //             }
        //         ],
        //         "ts": 1672324988882,
        //         "type": "snapshot"
        //     }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object topic = this.safeString(message, "topic");
        object topicParts = ((string)topic).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object topicLength = getArrayLength(topicParts);
        object timeframeId = this.safeString(topicParts, 1);
        object timeframe = this.findTimeframe(timeframeId);
        object marketId = this.safeString(topicParts, subtract(topicLength, 1));
        object isSpot = isGreaterThan(getIndexOf(client.url, "spot"), -1);
        object marketType = ((bool) isTrue(isSpot)) ? "spot" : "contract";
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        object ohlcvsByTimeframe = this.safeValue(this.ohlcvs, symbol);
        if (isTrue(isEqual(ohlcvsByTimeframe, null)))
        {
            ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = new Dictionary<string, object>() {};
        }
        if (isTrue(isEqual(this.safeValue(ohlcvsByTimeframe, timeframe), null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = new ArrayCacheByTimestamp(limit);
        }
        object stored = getValue(getValue(this.ohlcvs, symbol), timeframe);
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object parsed = this.parseWsOHLCV(getValue(data, i));
            callDynamically(stored, "append", new object[] {parsed});
        }
        object messageHash = add(add(add("ohlcv::", symbol), "::"), timeframe);
        object resolveData = new List<object>() {symbol, timeframe, stored};
        callDynamically(client as WebSocketClient, "resolve", new object[] {resolveData, messageHash});
    }

    public override object parseWsOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "start": 1670363160000,
        //         "end": 1670363219999,
        //         "interval": "1",
        //         "open": "16987.5",
        //         "close": "16987.5",
        //         "high": "16988",
        //         "low": "16987.5",
        //         "volume": "23.511",
        //         "turnover": "399396.344",
        //         "confirm": false,
        //         "timestamp": 1670363219614
        //     }
        //
        return new List<object> {this.safeInteger(ohlcv, "start"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber2(ohlcv, "volume", "turnover")};
    }

    /**
     * @method
     * @name apex#watchMyTrades
     * @description watches information on multiple trades made by the user
     * @see https://api-docs.pro.apex.exchange/#private-websocket
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.unifiedMargin] use unified margin account
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object messageHash = "myTrades";
        await this.loadMarkets();
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
            messageHash = add(messageHash, add(":", symbol));
        }
        object timeStamp = ((object)this.milliseconds()).ToString();
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "private"), "&timestamp="), timeStamp);
        await this.authenticate(url);
        object trades = await this.watchTopics(url, new List<object>() {messageHash}, new List<object>() {"myTrades"}, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    /**
     * @method
     * @name apex#watchPositions
     * @see https://api-docs.pro.apex.exchange/#private-websocket
     * @description watch all open positions
     * @param {string[]} [symbols] list of unified market symbols
     * @param {int} [since] the earliest time in ms to fetch positions for
     * @param {int} [limit] the maximum number of positions to retrieve
     * @param {object} params extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
     */
    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object messageHash = "";
        if (!isTrue(this.isEmpty(symbols)))
        {
            symbols = this.marketSymbols(symbols);
            messageHash = add("::", String.Join(",", ((IList<object>)symbols).ToArray()));
        }
        object timeStamp = ((object)this.milliseconds()).ToString();
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "private"), "&timestamp="), timeStamp);
        messageHash = add("positions", messageHash);
        var client = this.client(url);
        await this.authenticate(url);
        this.setPositionsCache(client as WebSocketClient, symbols);
        object cache = this.positions;
        if (isTrue(isEqual(cache, null)))
        {
            object snapshot = await client.future("fetchPositionsSnapshot");
            return this.filterBySymbolsSinceLimit(snapshot, symbols, since, limit, true);
        }
        object topics = new List<object>() {"positions"};
        object newPositions = await this.watchTopics(url, new List<object>() {messageHash}, topics, parameters);
        if (isTrue(this.newUpdates))
        {
            return newPositions;
        }
        return this.filterBySymbolsSinceLimit(cache, symbols, since, limit, true);
    }

    /**
     * @method
     * @name apex#watchOrders
     * @description watches information on multiple orders made by the user
     * @see https://api-docs.pro.apex.exchange/#private-websocket
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object messageHash = "orders";
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
            messageHash = add(messageHash, add(":", symbol));
        }
        object timeStamp = ((object)this.milliseconds()).ToString();
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "private"), "&timestamp="), timeStamp);
        await this.authenticate(url);
        object topics = new List<object>() {"orders"};
        object orders = await this.watchTopics(url, new List<object>() {messageHash}, topics, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleMyTrades(WebSocketClient client, object lists)
    {
        // [
        //     {
        //         "symbol":"ETH-USDT",
        //         "side":"BUY",
        //         "orderId":"2048046080",
        //         "fee":"0.625000",
        //         "liquidity":"TAKER",
        //         "accountId":"1024000",
        //         "createdAt":1652185521361,
        //         "isOpen":true,
        //         "size":"0.500",
        //         "price":"2500.0",
        //         "quoteAmount":"1250.0000",
        //         "id":"2048000182272",
        //         "updatedAt":1652185678345
        //     }
        // ]
        if (isTrue(isEqual(this.myTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            this.myTrades = new ArrayCacheBySymbolById(limit);
        }
        object trades = this.myTrades;
        object symbols = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(lists)); postFixIncrement(ref i))
        {
            object rawTrade = getValue(lists, i);
            object parsed = null;
            parsed = this.parseWsTrade(rawTrade);
            object symbol = getValue(parsed, "symbol");
            ((IDictionary<string,object>)symbols)[(string)symbol] = true;
            callDynamically(trades, "append", new object[] {parsed});
        }
        object keys = new List<object>(((IDictionary<string,object>)symbols).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object currentMessageHash = add("myTrades:", getValue(keys, i));
            callDynamically(client as WebSocketClient, "resolve", new object[] {trades, currentMessageHash});
        }
        // non-symbol specific
        object messageHash = "myTrades";
        callDynamically(client as WebSocketClient, "resolve", new object[] {trades, messageHash});
    }

    public virtual void handleOrder(WebSocketClient client, object lists)
    {
        // [
        //     {
        //         "symbol":"ETH-USDT",
        //         "cumSuccessFillFee":"0.625000",
        //         "trailingPercent":"0",
        //         "type":"LIMIT",
        //         "unfillableAt":1654779600000,
        //         "isDeleverage":false,
        //         "createdAt":1652185521339,
        //         "price":"2500.0",
        //         "cumSuccessFillValue":"0",
        //         "id":"2048046080",
        //         "cancelReason":"",
        //         "timeInForce":1,
        //         "updatedAt":1652185521392,
        //         "limitFee":"0.625000",
        //         "side":"BUY",
        //         "clientOrderId":"522843990",
        //         "triggerPrice":"",
        //         "expiresAt":1654779600000,
        //         "cumSuccessFillSize":"0",
        //         "accountId":"1024000",
        //         "size":"0.500",
        //         "reduceOnly":false,
        //         "isLiquidate":false,
        //         "remainingSize":"0.000",
        //         "status":"PENDING"
        //     }
        // ]
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object orders = this.orders;
        object symbols = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(lists)); postFixIncrement(ref i))
        {
            object parsed = null;
            parsed = this.parseOrder(getValue(lists, i));
            object symbol = getValue(parsed, "symbol");
            ((IDictionary<string,object>)symbols)[(string)symbol] = true;
            callDynamically(orders, "append", new object[] {parsed});
        }
        object symbolsArray = new List<object>(((IDictionary<string,object>)symbols).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(symbolsArray)); postFixIncrement(ref i))
        {
            object currentMessageHash = add("orders:", getValue(symbolsArray, i));
            callDynamically(client as WebSocketClient, "resolve", new object[] {orders, currentMessageHash});
        }
        object messageHash = "orders";
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
    }

    public virtual void setPositionsCache(WebSocketClient client, object symbols = null)
    {
        if (isTrue(!isEqual(this.positions, null)))
        {
            return;
        }
        object messageHash = "fetchPositionsSnapshot";
        if (!isTrue((inOp(client.futures, messageHash))))
        {
            client.future(messageHash);
            this.spawn(this.loadPositionsSnapshot, new object[] { client, messageHash});
        }
    }

    public async virtual Task loadPositionsSnapshot(WebSocketClient client, object messageHash)
    {
        // as only one ws channel gives positions for all types, for snapshot must load all positions
        object fetchFunctions = new List<object> {this.fetchPositions(null)};
        object promises = await promiseAll(fetchFunctions);
        this.positions = new ArrayCacheBySymbolBySide();
        object cache = this.positions;
        for (object i = 0; isLessThan(i, getArrayLength(promises)); postFixIncrement(ref i))
        {
            object positions = getValue(promises, i);
            for (object ii = 0; isLessThan(ii, getArrayLength(positions)); postFixIncrement(ref ii))
            {
                object position = getValue(positions, ii);
                callDynamically(cache, "append", new object[] {position});
            }
        }
        // don't remove the future from the .futures cache
        var future = getValue(client.futures, messageHash);
        (future as Future).resolve(cache);
        callDynamically(client as WebSocketClient, "resolve", new object[] {cache, "positions"});
    }

    public virtual void handlePositions(WebSocketClient client, object lists)
    {
        //
        // [
        //     {
        //         "symbol":"ETH-USDT",
        //         "exitPrice":"0",
        //         "side":"LONG",
        //         "maxSize":"2820.000",
        //         "sumOpen":"1.820",
        //         "sumClose":"0.000",
        //         "netFunding":"0.000000",
        //         "entryPrice":"2500.000000000000000000",
        //         "accountId":"1024000",
        //         "createdAt":1652179377769,
        //         "size":"1.820",
        //         "realizedPnl":"0",
        //         "closedAt":1652185521392,
        //         "updatedAt":1652185521392
        //     }
        // ]
        //
        // each account is connected to a different endpoint
        // and has exactly one subscriptionhash which is the account type
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new ArrayCacheBySymbolBySide();
        }
        object cache = this.positions;
        object newPositions = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(lists)); postFixIncrement(ref i))
        {
            object rawPosition = getValue(lists, i);
            object position = this.parsePosition(rawPosition);
            object side = this.safeString(position, "side");
            // hacky solution to handle closing positions
            // without crashing, we should handle this properly later
            ((IList<object>)newPositions).Add(position);
            if (isTrue(isTrue(isEqual(side, null)) || isTrue(isEqual(side, ""))))
            {
                // closing update, adding both sides to "reset" both sides
                // since we don't know which side is being closed
                ((IDictionary<string,object>)position)["side"] = "long";
                callDynamically(cache, "append", new object[] {position});
                ((IDictionary<string,object>)position)["side"] = "short";
                callDynamically(cache, "append", new object[] {position});
                ((IDictionary<string,object>)position)["side"] = null;
            } else
            {
                // regular update
                callDynamically(cache, "append", new object[] {position});
            }
        }
        object messageHashes = this.findMessageHashes(client as WebSocketClient, "positions::");
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object positions = this.filterByArray(newPositions, "symbol", symbols, false);
            if (!isTrue(this.isEmpty(positions)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {positions, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newPositions, "positions"});
    }

    public async virtual Task<object> authenticate(object url, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object timestamp = ((object)this.milliseconds()).ToString();
        object request_path = "/ws/accounts";
        object http_method = "GET";
        object messageString = (add(add(timestamp, http_method), request_path));
        object signature = this.hmac(this.encode(messageString), this.encode(this.stringToBase64(this.secret)), sha256, "base64");
        object messageHash = "authenticated";
        var client = this.client(url);
        var future = client.future(messageHash);
        object authenticated = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(authenticated, null)))
        {
            // auth sign
            object request = new Dictionary<string, object>() {
                { "type", "login" },
                { "topics", new List<object>() {"ws_zk_accounts_v3"} },
                { "httpMethod", http_method },
                { "requestPath", request_path },
                { "apiKey", this.apiKey },
                { "passphrase", this.password },
                { "timestamp", timestamp },
                { "signature", signature },
            };
            object message = new Dictionary<string, object>() {
                { "op", "login" },
                { "args", new List<object> {json(request)} },
            };
            this.watch(url, messageHash, message, messageHash);
        }
        return await (future as Exchange.Future);
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //   {
        //       "success": false,
        //       "ret_msg": "error:invalid op",
        //       "conn_id": "5e079fdd-9c7f-404d-9dbf-969d650838b5",
        //       "request": { op: '', args: null }
        //   }
        //
        // auth error
        //
        //   {
        //       "success": false,
        //       "ret_msg": "error:USVC1111",
        //       "conn_id": "e73770fb-a0dc-45bd-8028-140e20958090",
        //       "request": {
        //         "op": "auth",
        //         "args": [
        //           "9rFT6uR4uz9Imkw4Wx",
        //           "1653405853543",
        //           "542e71bd85597b4db0290f0ce2d13ed1fd4bb5df3188716c1e9cc69a879f7889"
        //         ]
        //   }
        //
        //   { code: '-10009', desc: "Invalid period!" }
        //
        //   {
        //       "reqId":"1",
        //       "retCode":170131,
        //       "retMsg":"Insufficient balance.",
        //       "op":"order.create",
        //       "data":{
        //
        //       },
        //       "header":{
        //           "X-Bapi-Limit":"20",
        //           "X-Bapi-Limit-Status":"19",
        //           "X-Bapi-Limit-Reset-Timestamp":"1714236608944",
        //           "Traceid":"3d7168a137bf32a947b7e5e6a575ac7f",
        //           "Timenow":"1714236608946"
        //       },
        //       "connId":"cojifin88smerbj9t560-406"
        //   }
        //
        object code = this.safeStringN(message, new List<object>() {"code", "ret_code", "retCode"});
        try
        {
            if (isTrue(isTrue(!isEqual(code, null)) && isTrue(!isEqual(code, "0"))))
            {
                object feedback = add(add(this.id, " "), this.json(message));
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
                object msg = this.safeString2(message, "retMsg", "ret_msg");
                this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), msg, feedback);
                throw new ExchangeError ((string)feedback) ;
            }
            object success = this.safeValue(message, "success");
            if (isTrue(isTrue(!isEqual(success, null)) && !isTrue(success)))
            {
                object ret_msg = this.safeString(message, "ret_msg");
                object request = this.safeValue(message, "request", new Dictionary<string, object>() {});
                object op = this.safeString(request, "op");
                if (isTrue(isEqual(op, "auth")))
                {
                    throw new AuthenticationError ((string)add("Authentication failed: ", ret_msg)) ;
                } else
                {
                    throw new ExchangeError ((string)add(add(this.id, " "), ret_msg)) ;
                }
            }
            return false;
        } catch(Exception error)
        {
            if (isTrue(error is AuthenticationError))
            {
                object messageHash = "authenticated";
                ((WebSocketClient)client).reject(error, messageHash);
                if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
                {
                    ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
                }
            } else
            {
                object messageHash = this.safeString(message, "reqId");
                ((WebSocketClient)client).reject(error, messageHash);
            }
            return true;
        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            return;
        }
        object topic = this.safeString2(message, "topic", "op", "");
        object methods = new Dictionary<string, object>() {
            { "ws_zk_accounts_v3", this.handleAccount },
            { "orderBook", this.handleOrderBook },
            { "depth", this.handleOrderBook },
            { "candle", this.handleOHLCV },
            { "kline", this.handleOHLCV },
            { "ticker", this.handleTicker },
            { "instrumentInfo", this.handleTicker },
            { "trade", this.handleTrades },
            { "recentlyTrade", this.handleTrades },
            { "pong", this.handlePong },
            { "auth", this.handleAuthenticate },
        };
        object exacMethod = this.safeValue(methods, topic);
        if (isTrue(!isEqual(exacMethod, null)))
        {
            DynamicInvoker.InvokeMethod(exacMethod, new object[] { client, message});
            return;
        }
        object keys = new List<object>(((IDictionary<string,object>)methods).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            if (isTrue(isGreaterThanOrEqual(getIndexOf(topic, getValue(keys, i)), 0)))
            {
                object method = getValue(methods, key);
                DynamicInvoker.InvokeMethod(method, new object[] { client, message});
                return;
            }
        }
        // unified auth acknowledgement
        object type = this.safeString(message, "type");
        if (isTrue(isEqual(type, "AUTH_RESP")))
        {
            this.handleAuthenticate(client as WebSocketClient, message);
        }
    }

    public override object ping(WebSocketClient client)
    {
        object timeStamp = ((object)this.milliseconds()).ToString();
        return new Dictionary<string, object>() {
            { "args", new List<object>() {timeStamp} },
            { "op", "ping" },
        };
    }

    public virtual object handlePong(WebSocketClient client, object message)
    {
        //
        //   {
        //       "success": true,
        //       "ret_msg": "pong",
        //       "conn_id": "db3158a0-8960-44b9-a9de-ac350ee13158",
        //       "request": { op: "ping", args: null }
        //   }
        //
        //   { pong: 1653296711335 }
        //
        client.lastPong = this.safeInteger(message, "pong");
        return message;
    }

    public virtual void handleAccount(WebSocketClient client, object message)
    {
        object contents = this.safeDict(message, "contents", new Dictionary<string, object>() {});
        object fills = this.safeList(contents, "fills", new List<object>() {});
        if (isTrue(!isEqual(fills, null)))
        {
            this.handleMyTrades(client as WebSocketClient, fills);
        }
        object positions = this.safeList(contents, "positions", new List<object>() {});
        if (isTrue(!isEqual(positions, null)))
        {
            this.handlePositions(client as WebSocketClient, positions);
        }
        object orders = this.safeList(contents, "orders", new List<object>() {});
        if (isTrue(!isEqual(orders, null)))
        {
            this.handleOrder(client as WebSocketClient, orders);
        }
    }

    public virtual object handleAuthenticate(WebSocketClient client, object message)
    {
        //
        //    {
        //        "success": true,
        //        "ret_msg": '',
        //        "op": "auth",
        //        "conn_id": "ce3dpomvha7dha97tvp0-2xh"
        //    }
        //
        object success = this.safeValue(message, "success");
        object code = this.safeInteger(message, "retCode");
        object messageHash = "authenticated";
        if (isTrue(isTrue(success) || isTrue(isEqual(code, 0))))
        {
            var future = this.safeValue((client as WebSocketClient).futures, messageHash);
            (future as Future).resolve(true);
        } else
        {
            var error = new AuthenticationError(add(add(this.id, " "), this.json(message)));
            ((WebSocketClient)client).reject(error, messageHash);
            if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
            {
                ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
            }
        }
        return message;
    }

    public virtual object handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //    {
        //        "topic": "kline",
        //        "event": "sub",
        //        "params": {
        //          "symbol": "LTCUSDT",
        //          "binary": "false",
        //          "klineType": "1m",
        //          "symbolName": "LTCUSDT"
        //        },
        //        "code": "0",
        //        "msg": "Success"
        //    }
        //
        return message;
    }
}
