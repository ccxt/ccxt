namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class woo { public woo(object args = null) : base(args) { } }
public partial class woo : ccxt.woo
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchBalance", true },
                { "watchMyTrades", true },
                { "watchOHLCV", true },
                { "watchOrderBook", true },
                { "watchOrders", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchTrades", true },
                { "watchPositions", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://wss.woo.org/ws/stream" },
                        { "private", "wss://wss.woo.network/v2/ws/private/stream" },
                    } },
                } },
                { "test", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://wss.staging.woo.org/ws/stream" },
                        { "private", "wss://wss.staging.woo.org/v2/ws/private/stream" },
                    } },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "uid", true },
            } },
            { "options", new Dictionary<string, object>() {
                { "tradesLimit", 1000 },
                { "ordersLimit", 1000 },
                { "requestId", new Dictionary<string, object>() {} },
                { "watchPositions", new Dictionary<string, object>() {
                    { "fetchPositionsSnapshot", true },
                    { "awaitPositionsSnapshot", true },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "ping", this.ping },
                { "keepAlive", 10000 },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "ws", new Dictionary<string, object>() {
                    { "exact", new Dictionary<string, object>() {
                        { "Auth is needed.", typeof(AuthenticationError) },
                    } },
                } },
            } },
        });
    }

    public virtual object requestId(object url)
    {
        object options = this.safeValue(this.options, "requestId", new Dictionary<string, object>() {});
        object previousValue = this.safeInteger(options, url, 0);
        object newValue = this.sum(previousValue, 1);
        ((IDictionary<string,object>)getValue(this.options, "requestId"))[(string)url] = newValue;
        return newValue;
    }

    public async virtual Task<object> watchPublic(object messageHash, object message)
    {
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "public"), "/"), this.uid);
        object requestId = this.requestId(url);
        object subscribe = new Dictionary<string, object>() {
            { "id", requestId },
        };
        object request = this.extend(subscribe, message);
        return await this.watch(url, messageHash, request, messageHash, subscribe);
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#watchOrderBook
        * @see https://docs.woo.org/#orderbook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return.
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "orderbook";
        object market = this.market(symbol);
        object topic = add(add(getValue(market, "id"), "@"), name);
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "topic", topic },
        };
        object message = this.extend(request, parameters);
        object orderbook = await this.watchPublic(topic, message);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //     {
        //         "topic": "PERP_BTC_USDT@orderbook",
        //         "ts": 1650121915308,
        //         "data": {
        //             "symbol": "PERP_BTC_USDT",
        //             "bids": [
        //                 [
        //                     0.30891,
        //                     2469.98
        //                 ]
        //             ],
        //             "asks": [
        //                 [
        //                     0.31075,
        //                     2379.63
        //                 ]
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(message, "data");
        object marketId = this.safeString(data, "symbol");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object topic = this.safeString(message, "topic");
        object orderbook = this.safeValue(this.orderbooks, symbol);
        if (isTrue(isEqual(orderbook, null)))
        {
            orderbook = this.orderBook(new Dictionary<string, object>() {});
        }
        object timestamp = this.safeInteger(message, "ts");
        object snapshot = this.parseOrderBook(data, symbol, timestamp, "bids", "asks");
        (orderbook as IOrderBook).reset(snapshot);
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, topic});
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name woo#watchTicker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "ticker";
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object topic = add(add(getValue(market, "id"), "@"), name);
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "topic", topic },
        };
        object message = this.extend(request, parameters);
        return await this.watchPublic(topic, message);
    }

    public virtual object parseWsTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "symbol": "PERP_BTC_USDT",
        //         "open": 19441.5,
        //         "close": 20147.07,
        //         "high": 20761.87,
        //         "low": 19320.54,
        //         "volume": 2481.103,
        //         "amount": 50037935.0286,
        //         "count": 3689
        //     }
        //
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(null, market) },
            { "timestamp", null },
            { "datetime", null },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", null },
            { "bidVolume", null },
            { "ask", null },
            { "askVolume", null },
            { "vwap", null },
            { "open", this.safeString(ticker, "open") },
            { "close", this.safeString(ticker, "close") },
            { "last", null },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "volume") },
            { "quoteVolume", this.safeString(ticker, "amount") },
            { "info", ticker },
        }, market);
    }

    public virtual object handleTicker(WebSocketClient client, object message)
    {
        //
        //     {
        //         "topic": "PERP_BTC_USDT@ticker",
        //         "ts": 1657120017000,
        //         "data": {
        //             "symbol": "PERP_BTC_USDT",
        //             "open": 19441.5,
        //             "close": 20147.07,
        //             "high": 20761.87,
        //             "low": 19320.54,
        //             "volume": 2481.103,
        //             "amount": 50037935.0286,
        //             "count": 3689
        //         }
        //     }
        //
        object data = this.safeValue(message, "data");
        object topic = this.safeValue(message, "topic");
        object marketId = this.safeString(data, "symbol");
        object market = this.safeMarket(marketId);
        object timestamp = this.safeInteger(message, "ts");
        ((IDictionary<string,object>)data)["date"] = timestamp;
        object ticker = this.parseWsTicker(data, market);
        ((IDictionary<string,object>)ticker)["symbol"] = getValue(market, "symbol");
        ((IDictionary<string,object>)this.tickers)[(string)getValue(market, "symbol")] = ticker;
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, topic});
        return message;
    }

    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#watchTickers
        * @see https://docs.woo.org/#24h-tickers
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
        * @param {string[]} symbols unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object name = "tickers";
        object topic = name;
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "topic", topic },
        };
        object message = this.extend(request, parameters);
        object tickers = await this.watchPublic(topic, message);
        return this.filterByArray(tickers, "symbol", symbols);
    }

    public virtual void handleTickers(WebSocketClient client, object message)
    {
        //
        //     {
        //         "topic":"tickers",
        //         "ts":1618820615000,
        //         "data":[
        //             {
        //                 "symbol":"SPOT_OKB_USDT",
        //                 "open":16.297,
        //                 "close":17.183,
        //                 "high":24.707,
        //                 "low":11.997,
        //                 "volume":0,
        //                 "amount":0,
        //                 "count":0
        //             },
        //             {
        //                 "symbol":"SPOT_XRP_USDT",
        //                 "open":1.3515,
        //                 "close":1.43794,
        //                 "high":1.96674,
        //                 "low":0.39264,
        //                 "volume":750127.1,
        //                 "amount":985440.5122,
        //                 "count":396
        //             },
        //         ...
        //         ]
        //     }
        //
        object topic = this.safeValue(message, "topic");
        object data = this.safeValue(message, "data");
        object timestamp = this.safeInteger(message, "ts");
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object marketId = this.safeString(getValue(data, i), "symbol");
            object market = this.safeMarket(marketId);
            object ticker = this.parseWsTicker(this.extend(getValue(data, i), new Dictionary<string, object>() {
                { "date", timestamp },
            }), market);
            ((IDictionary<string,object>)this.tickers)[(string)getValue(market, "symbol")] = ticker;
            ((IList<object>)result).Add(ticker);
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {result, topic});
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#watchOHLCV
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://docs.woo.org/#k-line
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isTrue(isTrue(isTrue(isTrue(isTrue(isTrue(isTrue((!isEqual(timeframe, "1m"))) && isTrue((!isEqual(timeframe, "5m")))) && isTrue((!isEqual(timeframe, "15m")))) && isTrue((!isEqual(timeframe, "30m")))) && isTrue((!isEqual(timeframe, "1h")))) && isTrue((!isEqual(timeframe, "1d")))) && isTrue((!isEqual(timeframe, "1w")))) && isTrue((!isEqual(timeframe, "1M")))))
        {
            throw new ExchangeError ((string)add(this.id, " watchOHLCV timeframe argument must be 1m, 5m, 15m, 30m, 1h, 1d, 1w, 1M")) ;
        }
        object market = this.market(symbol);
        object interval = this.safeString(this.timeframes, timeframe, timeframe);
        object name = "kline";
        object topic = add(add(add(add(getValue(market, "id"), "@"), name), "_"), interval);
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "topic", topic },
        };
        object message = this.extend(request, parameters);
        object ohlcv = await this.watchPublic(topic, message);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {getValue(market, "symbol"), limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "topic":"SPOT_BTC_USDT@kline_1m",
        //         "ts":1618822432146,
        //         "data":{
        //             "symbol":"SPOT_BTC_USDT",
        //             "type":"1m",
        //             "open":56948.97,
        //             "close":56891.76,
        //             "high":56948.97,
        //             "low":56889.06,
        //             "volume":44.00947568,
        //             "amount":2504584.9,
        //             "startTime":1618822380000,
        //             "endTime":1618822440000
        //         }
        //     }
        //
        object data = this.safeValue(message, "data");
        object topic = this.safeValue(message, "topic");
        object marketId = this.safeString(data, "symbol");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object interval = this.safeString(data, "type");
        object timeframe = this.findTimeframe(interval);
        object parsed = new List<object> {this.safeInteger(data, "startTime"), this.safeFloat(data, "open"), this.safeFloat(data, "high"), this.safeFloat(data, "low"), this.safeFloat(data, "close"), this.safeFloat(data, "volume")};
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
        }
        callDynamically(stored, "append", new object[] {parsed});
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, topic});
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#watchTrades
        * @description watches information on multiple trades made in a market
        * @see https://docs.woo.org/#trade
        * @param {string} symbol unified market symbol of the market trades were made in
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trade structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object topic = add(getValue(market, "id"), "@trade");
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "topic", topic },
        };
        object message = this.extend(request, parameters);
        object trades = await this.watchPublic(topic, message);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {getValue(market, "symbol"), limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleTrade(WebSocketClient client, object message)
    {
        //
        // {
        //     "topic":"SPOT_ADA_USDT@trade",
        //     "ts":1618820361552,
        //     "data":{
        //         "symbol":"SPOT_ADA_USDT",
        //         "price":1.27988,
        //         "size":300,
        //         "side":"BUY",
        //         "source":0
        //     }
        // }
        //
        object topic = this.safeString(message, "topic");
        object timestamp = this.safeInteger(message, "ts");
        object data = this.safeValue(message, "data");
        object marketId = this.safeString(data, "symbol");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object trade = this.parseWsTrade(this.extend(data, new Dictionary<string, object>() {
            { "timestamp", timestamp },
        }), market);
        object tradesArray = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(tradesArray, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            tradesArray = new ArrayCache(limit);
        }
        callDynamically(tradesArray, "append", new object[] {trade});
        ((IDictionary<string,object>)this.trades)[(string)symbol] = tradesArray;
        callDynamically(client as WebSocketClient, "resolve", new object[] {tradesArray, topic});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        //     {
        //         "symbol":"SPOT_ADA_USDT",
        //         "timestamp":1618820361552,
        //         "price":1.27988,
        //         "size":300,
        //         "side":"BUY",
        //         "source":0
        //     }
        // private trade
        //    {
        //     "msgType": 0,  // execution report
        //     "symbol": "SPOT_BTC_USDT",
        //     "clientOrderId": 0,
        //     "orderId": 54774393,
        //     "type": "MARKET",
        //     "side": "BUY",
        //     "quantity": 0.0,
        //     "price": 0.0,
        //     "tradeId": 56201985,
        //     "executedPrice": 23534.06,
        //     "executedQuantity": 0.00040791,
        //     "fee": 2.1E-7,
        //     "feeAsset": "BTC",
        //     "totalExecutedQuantity": 0.00040791,
        //     "avgPrice": 23534.06,
        //     "status": "FILLED",
        //     "reason": "",
        //     "orderTag": "default",
        //     "totalFee": 2.1E-7,
        //     "feeCurrency": "BTC",
        //     "totalRebate": 0,
        //     "rebateCurrency": "USDT",
        //     "visible": 0.0,
        //     "timestamp": 1675406261689,
        //     "reduceOnly": false,
        //     "maker": false
        //   }
        //
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object price = this.safeString(trade, "executedPrice", "price");
        object amount = this.safeString2(trade, "executedQuantity", "size");
        object cost = Precise.stringMul(price, amount);
        object side = this.safeStringLower(trade, "side");
        object timestamp = this.safeInteger(trade, "timestamp");
        object maker = this.safeBool(trade, "marker");
        object takerOrMaker = null;
        if (isTrue(!isEqual(maker, null)))
        {
            takerOrMaker = ((bool) isTrue(maker)) ? "maker" : "taker";
        }
        object type = this.safeStringLower(trade, "type");
        object fee = null;
        object feeCost = this.safeNumber(trade, "fee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", this.safeCurrencyCode(this.safeString(trade, "feeCurrency")) },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", this.safeString(trade, "tradeId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "order", this.safeString(trade, "orderId") },
            { "takerOrMaker", takerOrMaker },
            { "type", type },
            { "fee", fee },
            { "info", trade },
        }, market);
    }

    public virtual object checkRequiredUid(object error = null)
    {
        error ??= true;
        if (!isTrue(this.uid))
        {
            if (isTrue(error))
            {
                throw new AuthenticationError ((string)add(this.id, " requires `uid` credential")) ;
            } else
            {
                return false;
            }
        }
        return true;
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "private"), "/"), this.uid);
        var client = this.client(url);
        object messageHash = "authenticated";
        object eventVar = "auth";
        var future = client.future(messageHash);
        object authenticated = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(authenticated, null)))
        {
            object ts = ((object)this.nonce()).ToString();
            object auth = add("|", ts);
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
            object request = new Dictionary<string, object>() {
                { "event", eventVar },
                { "params", new Dictionary<string, object>() {
                    { "apikey", this.apiKey },
                    { "sign", signature },
                    { "timestamp", ts },
                } },
            };
            object message = this.extend(request, parameters);
            this.watch(url, messageHash, message, messageHash);
        }
        return await (future as Exchange.Future);
    }

    public async virtual Task<object> watchPrivate(object messageHash, object message, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticate(parameters);
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "private"), "/"), this.uid);
        object requestId = this.requestId(url);
        object subscribe = new Dictionary<string, object>() {
            { "id", requestId },
        };
        object request = this.extend(subscribe, message);
        return await this.watch(url, messageHash, request, messageHash, subscribe);
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#watchOrders
        * @see https://docs.woo.org/#executionreport
        * @see https://docs.woo.org/#algoexecutionreportv2
        * @description watches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object topic = "executionreport";
        object messageHash = topic;
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            symbol = getValue(market, "symbol");
            messageHash = add(messageHash, add(":", symbol));
        }
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "topic", topic },
        };
        object message = this.extend(request, parameters);
        object orders = await this.watchPrivate(messageHash, message);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#watchOrders
        * @see https://docs.woo.org/#executionreport
        * @description watches information on multiple trades made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object topic = "executionreport";
        object messageHash = "myTrades";
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            symbol = getValue(market, "symbol");
            messageHash = add(messageHash, add(":", symbol));
        }
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "topic", topic },
        };
        object message = this.extend(request, parameters);
        object trades = await this.watchPrivate(messageHash, message);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        //     {
        //         "symbol": "PERP_BTC_USDT",
        //         "clientOrderId": 0,
        //         "orderId": 52952826,
        //         "type": "LIMIT",
        //         "side": "SELL",
        //         "quantity": 0.01,
        //         "price": 22000,
        //         "tradeId": 0,
        //         "executedPrice": 0,
        //         "executedQuantity": 0,
        //         "fee": 0,
        //         "feeAsset": "USDT",
        //         "totalExecutedQuantity": 0,
        //         "status": "NEW",
        //         "reason": '',
        //         "orderTag": "default",
        //         "totalFee": 0,
        //         "visible": 0.01,
        //         "timestamp": 1657515556799,
        //         "reduceOnly": false,
        //         "maker": false
        //     }
        //
        object orderId = this.safeString(order, "orderId");
        object marketId = this.safeString(order, "symbol");
        market = this.market(marketId);
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger(order, "timestamp");
        object fee = new Dictionary<string, object>() {
            { "cost", this.safeString(order, "totalFee") },
            { "currency", this.safeString(order, "feeAsset") },
        };
        object price = this.safeNumber(order, "price");
        object avgPrice = this.safeNumber(order, "avgPrice");
        if (isTrue(isTrue((isEqual(price, 0))) && isTrue((!isEqual(avgPrice, null)))))
        {
            price = avgPrice;
        }
        object amount = this.safeFloat(order, "quantity");
        object side = this.safeStringLower(order, "side");
        object type = this.safeStringLower(order, "type");
        object filled = this.safeNumber(order, "totalExecutedQuantity");
        object totalExecQuantity = this.safeFloat(order, "totalExecutedQuantity");
        object remaining = amount;
        if (isTrue(isGreaterThanOrEqual(amount, totalExecQuantity)))
        {
            remaining = subtract(remaining, totalExecQuantity);
        }
        object rawStatus = this.safeString(order, "status");
        object status = this.parseOrderStatus(rawStatus);
        object trades = null;
        object clientOrderId = this.safeString(order, "clientOrderId");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "symbol", symbol },
            { "id", orderId },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", timestamp },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "amount", amount },
            { "cost", null },
            { "average", null },
            { "filled", filled },
            { "remaining", remaining },
            { "status", status },
            { "fee", fee },
            { "trades", trades },
        });
    }

    public virtual void handleOrderUpdate(WebSocketClient client, object message)
    {
        //
        //     {
        //         "topic": "executionreport",
        //         "ts": 1657515556799,
        //         "data": {
        //             "symbol": "PERP_BTC_USDT",
        //             "clientOrderId": 0,
        //             "orderId": 52952826,
        //             "type": "LIMIT",
        //             "side": "SELL",
        //             "quantity": 0.01,
        //             "price": 22000,
        //             "tradeId": 0,
        //             "executedPrice": 0,
        //             "executedQuantity": 0,
        //             "fee": 0,
        //             "feeAsset": "USDT",
        //             "totalExecutedQuantity": 0,
        //             "status": "NEW",
        //             "reason": '',
        //             "orderTag": "default",
        //             "totalFee": 0,
        //             "visible": 0.01,
        //             "timestamp": 1657515556799,
        //             "reduceOnly": false,
        //             "maker": false
        //         }
        //     }
        //
        object order = this.safeDict(message, "data");
        object tradeId = this.safeString(order, "tradeId");
        if (isTrue(isTrue((!isEqual(tradeId, null))) && isTrue((!isEqual(tradeId, "0")))))
        {
            this.handleMyTrade(client as WebSocketClient, order);
        }
        this.handleOrder(client as WebSocketClient, order);
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        object topic = "executionreport";
        object parsed = this.parseWsOrder(message);
        object symbol = this.safeString(parsed, "symbol");
        object orderId = this.safeString(parsed, "id");
        if (isTrue(!isEqual(symbol, null)))
        {
            if (isTrue(isEqual(this.orders, null)))
            {
                object limit = this.safeInteger(this.options, "ordersLimit", 1000);
                this.orders = new ArrayCacheBySymbolById(limit);
            }
            object cachedOrders = this.orders;
            object orders = this.safeValue((cachedOrders as ArrayCacheBySymbolById).hashmap, symbol, new Dictionary<string, object>() {});
            object order = this.safeValue(orders, orderId);
            if (isTrue(!isEqual(order, null)))
            {
                object fee = this.safeValue(order, "fee");
                if (isTrue(!isEqual(fee, null)))
                {
                    ((IDictionary<string,object>)parsed)["fee"] = fee;
                }
                object fees = this.safeValue(order, "fees");
                if (isTrue(!isEqual(fees, null)))
                {
                    ((IDictionary<string,object>)parsed)["fees"] = fees;
                }
                ((IDictionary<string,object>)parsed)["trades"] = this.safeValue(order, "trades");
                ((IDictionary<string,object>)parsed)["timestamp"] = this.safeInteger(order, "timestamp");
                ((IDictionary<string,object>)parsed)["datetime"] = this.safeString(order, "datetime");
            }
            callDynamically(cachedOrders, "append", new object[] {parsed});
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, topic});
            object messageHashSymbol = add(add(topic, ":"), symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageHashSymbol});
        }
    }

    public virtual void handleMyTrade(WebSocketClient client, object message)
    {
        //
        //    {
        //     "msgType": 0,  // execution report
        //     "symbol": "SPOT_BTC_USDT",
        //     "clientOrderId": 0,
        //     "orderId": 54774393,
        //     "type": "MARKET",
        //     "side": "BUY",
        //     "quantity": 0.0,
        //     "price": 0.0,
        //     "tradeId": 56201985,
        //     "executedPrice": 23534.06,
        //     "executedQuantity": 0.00040791,
        //     "fee": 2.1E-7,
        //     "feeAsset": "BTC",
        //     "totalExecutedQuantity": 0.00040791,
        //     "avgPrice": 23534.06,
        //     "status": "FILLED",
        //     "reason": "",
        //     "orderTag": "default",
        //     "totalFee": 2.1E-7,
        //     "feeCurrency": "BTC",
        //     "totalRebate": 0,
        //     "rebateCurrency": "USDT",
        //     "visible": 0.0,
        //     "timestamp": 1675406261689,
        //     "reduceOnly": false,
        //     "maker": false
        //   }
        //
        object myTrades = this.myTrades;
        if (isTrue(isEqual(myTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            myTrades = new ArrayCacheBySymbolById(limit);
        }
        object trade = this.parseWsTrade(message);
        callDynamically(myTrades, "append", new object[] {trade});
        object messageHash = add("myTrades:", getValue(trade, "symbol"));
        callDynamically(client as WebSocketClient, "resolve", new object[] {myTrades, messageHash});
        messageHash = "myTrades";
        callDynamically(client as WebSocketClient, "resolve", new object[] {myTrades, messageHash});
    }

    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#watchPositions
        * @see https://docs.woo.org/#position-push
        * @description watch all open positions
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object messageHash = "";
        symbols = this.marketSymbols(symbols);
        if (!isTrue(this.isEmpty(symbols)))
        {
            messageHash = add("::", String.Join(",", ((IList<object>)symbols).ToArray()));
        }
        messageHash = add("positions", messageHash);
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "private"), "/"), this.uid);
        var client = this.client(url);
        this.setPositionsCache(client as WebSocketClient, symbols);
        object fetchPositionsSnapshot = this.handleOption("watchPositions", "fetchPositionsSnapshot", true);
        object awaitPositionsSnapshot = this.safeBool("watchPositions", "awaitPositionsSnapshot", true);
        if (isTrue(isTrue(isTrue(fetchPositionsSnapshot) && isTrue(awaitPositionsSnapshot)) && isTrue(isEqual(this.positions, null))))
        {
            object snapshot = await client.future("fetchPositionsSnapshot");
            return this.filterBySymbolsSinceLimit(snapshot, symbols, since, limit, true);
        }
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "topic", "position" },
        };
        object newPositions = await this.watchPrivate(messageHash, request, parameters);
        if (isTrue(this.newUpdates))
        {
            return newPositions;
        }
        return this.filterBySymbolsSinceLimit(this.positions, symbols, since, limit, true);
    }

    public virtual void setPositionsCache(WebSocketClient client, object type, object symbols = null)
    {
        object fetchPositionsSnapshot = this.handleOption("watchPositions", "fetchPositionsSnapshot", false);
        if (isTrue(fetchPositionsSnapshot))
        {
            object messageHash = "fetchPositionsSnapshot";
            if (!isTrue((inOp(client.futures, messageHash))))
            {
                client.future(messageHash);
                this.spawn(this.loadPositionsSnapshot, new object[] { client, messageHash});
            }
        } else
        {
            this.positions = new ArrayCacheBySymbolBySide();
        }
    }

    public async virtual Task loadPositionsSnapshot(WebSocketClient client, object messageHash)
    {
        object positions = await this.fetchPositions();
        this.positions = new ArrayCacheBySymbolBySide();
        object cache = this.positions;
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object position = getValue(positions, i);
            object contracts = this.safeNumber(position, "contracts", 0);
            if (isTrue(isGreaterThan(contracts, 0)))
            {
                callDynamically(cache, "append", new object[] {position});
            }
        }
        // don't remove the future from the .futures cache
        var future = getValue(client.futures, messageHash);
        (future as Future).resolve(cache);
        callDynamically(client as WebSocketClient, "resolve", new object[] {cache, "positions"});
    }

    public virtual void handlePositions(WebSocketClient client, object message)
    {
        //
        //    {
        //        "topic":"position",
        //        "ts":1705292345255,
        //        "data":{
        //           "positions":{
        //              "PERP_LTC_USDT":{
        //                 "holding":1,
        //                 "pendingLongQty":0,
        //                 "pendingShortQty":0,
        //                 "averageOpenPrice":71.53,
        //                 "pnl24H":0,
        //                 "fee24H":0.07153,
        //                 "settlePrice":71.53,
        //                 "markPrice":71.32098452065145,
        //                 "version":7886,
        //                 "openingTime":1705292304267,
        //                 "pnl24HPercentage":0,
        //                 "adlQuantile":1,
        //                 "positionSide":"BOTH"
        //              }
        //           }
        //        }
        //    }
        //
        object data = this.safeValue(message, "data", new Dictionary<string, object>() {});
        object rawPositions = this.safeValue(data, "positions", new Dictionary<string, object>() {});
        object postitionsIds = new List<object>(((IDictionary<string,object>)rawPositions).Keys);
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new ArrayCacheBySymbolBySide();
        }
        object cache = this.positions;
        object newPositions = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(postitionsIds)); postFixIncrement(ref i))
        {
            object marketId = getValue(postitionsIds, i);
            object market = this.safeMarket(marketId);
            object rawPosition = getValue(rawPositions, marketId);
            object position = this.parsePosition(rawPosition, market);
            ((IList<object>)newPositions).Add(position);
            callDynamically(cache, "append", new object[] {position});
        }
        object messageHashes = this.findMessageHashes(client as WebSocketClient, "positions::");
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object positions = this.filterByArray(newPositions, "symbol", symbols, false);
            if (!isTrue(this.isEmpty(positions)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {positions, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newPositions, "positions"});
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @see https://docs.woo.org/#balance
        * @name woo#watchBalance
        * @description watch balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object topic = "balance";
        object messageHash = topic;
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "topic", topic },
        };
        object message = this.extend(request, parameters);
        return await this.watchPrivate(messageHash, message);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        //   {
        //       "topic": "balance",
        //       "ts": 1695716888789,
        //       "data": {
        //          "balances": {
        //             "USDT": {
        //                "holding": 266.56059176,
        //                "frozen": 0,
        //                "interest": 0,
        //                "pendingShortQty": 0,
        //                "pendingExposure": 0,
        //                "pendingLongQty": 0,
        //                "pendingLongExposure": 0,
        //                "version": 37,
        //                "staked": 0,
        //                "unbonding": 0,
        //                "vault": 0,
        //                "averageOpenPrice": 0,
        //                "pnl24H": 0,
        //                "fee24H": 0,
        //                "markPrice": 1,
        //                "pnl24HPercentage": 0
        //             }
        //          }
        //
        //    }
        //
        object data = this.safeValue(message, "data");
        object balances = this.safeValue(data, "balances");
        object keys = new List<object>(((IDictionary<string,object>)balances).Keys);
        object ts = this.safeInteger(message, "ts");
        ((IDictionary<string,object>)this.balance)["info"] = data;
        ((IDictionary<string,object>)this.balance)["timestamp"] = ts;
        ((IDictionary<string,object>)this.balance)["datetime"] = this.iso8601(ts);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object value = getValue(balances, key);
            object code = this.safeCurrencyCode(key);
            object account = ((bool) isTrue((inOp(this.balance, code)))) ? getValue(this.balance, code) : this.account();
            object total = this.safeString(value, "holding");
            object used = this.safeString(value, "frozen");
            ((IDictionary<string,object>)account)["total"] = total;
            ((IDictionary<string,object>)account)["used"] = used;
            ((IDictionary<string,object>)account)["free"] = Precise.stringSub(total, used);
            ((IDictionary<string,object>)this.balance)[(string)code] = account;
        }
        this.balance = this.safeBalance(this.balance);
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, "balance"});
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        //
        // {"id":"1","event":"subscribe","success":false,"ts":1710780997216,"errorMsg":"Auth is needed."}
        //
        if (!isTrue((inOp(message, "success"))))
        {
            return false;
        }
        object success = this.safeBool(message, "success");
        if (isTrue(success))
        {
            return false;
        }
        object errorMessage = this.safeString(message, "errorMsg");
        try
        {
            if (isTrue(!isEqual(errorMessage, null)))
            {
                object feedback = add(add(this.id, " "), this.json(message));
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorMessage, feedback);
            }
            return false;
        } catch(Exception error)
        {
            if (isTrue(error is AuthenticationError))
            {
                object messageHash = "authenticated";
                ((WebSocketClient)client).reject(error, messageHash);
                if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
                {

                }
            } else
            {
                ((WebSocketClient)client).reject(error);
            }
            return true;
        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            return;
        }
        object methods = new Dictionary<string, object>() {
            { "ping", this.handlePing },
            { "pong", this.handlePong },
            { "subscribe", this.handleSubscribe },
            { "orderbook", this.handleOrderBook },
            { "ticker", this.handleTicker },
            { "tickers", this.handleTickers },
            { "kline", this.handleOHLCV },
            { "auth", this.handleAuth },
            { "executionreport", this.handleOrderUpdate },
            { "trade", this.handleTrade },
            { "balance", this.handleBalance },
            { "position", this.handlePositions },
        };
        object eventVar = this.safeString(message, "event");
        object method = this.safeValue(methods, eventVar);
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
            return;
        }
        object topic = this.safeString(message, "topic");
        if (isTrue(!isEqual(topic, null)))
        {
            method = this.safeValue(methods, topic);
            if (isTrue(!isEqual(method, null)))
            {
                DynamicInvoker.InvokeMethod(method, new object[] { client, message});
                return;
            }
            object splitTopic = ((string)topic).Split(new [] {((string)"@")}, StringSplitOptions.None).ToList<object>();
            object splitLength = getArrayLength(splitTopic);
            if (isTrue(isEqual(splitLength, 2)))
            {
                object name = this.safeString(splitTopic, 1);
                method = this.safeValue(methods, name);
                if (isTrue(!isEqual(method, null)))
                {
                    DynamicInvoker.InvokeMethod(method, new object[] { client, message});
                    return;
                }
                object splitName = ((string)name).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
                object splitNameLength = getArrayLength(splitTopic);
                if (isTrue(isEqual(splitNameLength, 2)))
                {
                    method = this.safeValue(methods, this.safeString(splitName, 0));
                    if (isTrue(!isEqual(method, null)))
                    {
                        DynamicInvoker.InvokeMethod(method, new object[] { client, message});
                    }
                }
            }
        }
    }

    public override object ping(WebSocketClient client)
    {
        return new Dictionary<string, object>() {
            { "event", "ping" },
        };
    }

    public virtual object handlePing(WebSocketClient client, object message)
    {
        return new Dictionary<string, object>() {
            { "event", "pong" },
        };
    }

    public virtual object handlePong(WebSocketClient client, object message)
    {
        //
        // { event: "pong", ts: 1657117026090 }
        //
        client.lastPong = this.milliseconds();
        return message;
    }

    public virtual object handleSubscribe(WebSocketClient client, object message)
    {
        //
        //     {
        //         "id": "666888",
        //         "event": "subscribe",
        //         "success": true,
        //         "ts": 1657117712212
        //     }
        //
        return message;
    }

    public virtual void handleAuth(WebSocketClient client, object message)
    {
        //
        //     {
        //         "event": "auth",
        //         "success": true,
        //         "ts": 1657463158812
        //     }
        //
        object messageHash = "authenticated";
        object success = this.safeValue(message, "success");
        if (isTrue(success))
        {
            // client.resolve (message, messageHash);
            var future = this.safeValue((client as WebSocketClient).futures, "authenticated");
            (future as Future).resolve(true);
        } else
        {
            var error = new AuthenticationError(this.json(message));
            ((WebSocketClient)client).reject(error, messageHash);
            // allows further authentication attempts
            if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
            {

            }
        }
    }
}
