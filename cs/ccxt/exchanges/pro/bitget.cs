namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class bitget { public bitget(object args = null) : base(args) { } }
public partial class bitget : ccxt.bitget
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "createOrderWs", false },
                { "editOrderWs", false },
                { "fetchOpenOrdersWs", false },
                { "fetchOrderWs", false },
                { "cancelOrderWs", false },
                { "cancelOrdersWs", false },
                { "cancelAllOrdersWs", false },
                { "watchBalance", true },
                { "watchMyTrades", true },
                { "watchOHLCV", true },
                { "watchOHLCVForSymbols", false },
                { "watchOrderBook", true },
                { "watchOrderBookForSymbols", true },
                { "watchOrders", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
                { "watchPositions", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://ws.bitget.com/v2/ws/public" },
                        { "private", "wss://ws.bitget.com/v2/ws/private" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "tradesLimit", 1000 },
                { "OHLCVLimit", 1000 },
                { "timeframes", new Dictionary<string, object>() {
                    { "1m", "1m" },
                    { "5m", "5m" },
                    { "15m", "15m" },
                    { "30m", "30m" },
                    { "1h", "1H" },
                    { "4h", "4H" },
                    { "6h", "6H" },
                    { "12h", "12H" },
                    { "1d", "1D" },
                    { "1w", "1W" },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "ping", this.ping },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "ws", new Dictionary<string, object>() {
                    { "exact", new Dictionary<string, object>() {
                        { "30001", typeof(BadRequest) },
                        { "30002", typeof(AuthenticationError) },
                        { "30003", typeof(BadRequest) },
                        { "30004", typeof(AuthenticationError) },
                        { "30005", typeof(AuthenticationError) },
                        { "30006", typeof(RateLimitExceeded) },
                        { "30007", typeof(RateLimitExceeded) },
                        { "30011", typeof(AuthenticationError) },
                        { "30012", typeof(AuthenticationError) },
                        { "30013", typeof(AuthenticationError) },
                        { "30014", typeof(BadRequest) },
                        { "30015", typeof(AuthenticationError) },
                        { "30016", typeof(BadRequest) },
                    } },
                    { "broad", new Dictionary<string, object>() {} },
                } },
            } },
        });
    }

    public virtual object getInstType(object market, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object instType = null;
        if (isTrue(isEqual(market, null)))
        {
            var instTypeparametersVariable = this.handleProductTypeAndParams(null, parameters);
            instType = ((IList<object>)instTypeparametersVariable)[0];
            parameters = ((IList<object>)instTypeparametersVariable)[1];
        } else if (isTrue(isTrue((getValue(market, "swap"))) || isTrue((getValue(market, "future")))))
        {
            var instTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            instType = ((IList<object>)instTypeparametersVariable)[0];
            parameters = ((IList<object>)instTypeparametersVariable)[1];
        } else
        {
            instType = "SPOT";
        }
        object instypeAux = null;
        var instypeAuxparametersVariable = this.handleOptionAndParams(parameters, "getInstType", "instType", instType);
        instypeAux = ((IList<object>)instypeAuxparametersVariable)[0];
        parameters = ((IList<object>)instypeAuxparametersVariable)[1];
        instType = instypeAux;
        return new List<object>() {instType, parameters};
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitget#watchTicker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://www.bitget.com/api-doc/spot/websocket/public/Tickers-Channel
        * @see https://www.bitget.com/api-doc/contract/websocket/public/Tickers-Channel
        * @param {string} symbol unified symbol of the market to watch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object messageHash = add("ticker:", symbol);
        object instType = null;
        var instTypeparametersVariable = this.getInstType(market, parameters);
        instType = ((IList<object>)instTypeparametersVariable)[0];
        parameters = ((IList<object>)instTypeparametersVariable)[1];
        object args = new Dictionary<string, object>() {
            { "instType", instType },
            { "channel", "ticker" },
            { "instId", getValue(market, "id") },
        };
        return await this.watchPublic(messageHash, args, parameters);
    }

    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#watchTickers
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
        * @see https://www.bitget.com/api-doc/spot/websocket/public/Tickers-Channel
        * @see https://www.bitget.com/api-doc/contract/websocket/public/Tickers-Channel
        * @param {string[]} symbols unified symbol of the market to watch the tickers for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object market = this.market(getValue(symbols, 0));
        object instType = null;
        var instTypeparametersVariable = this.getInstType(market, parameters);
        instType = ((IList<object>)instTypeparametersVariable)[0];
        parameters = ((IList<object>)instTypeparametersVariable)[1];
        object topics = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object marketInner = this.market(symbol);
            object args = new Dictionary<string, object>() {
                { "instType", instType },
                { "channel", "ticker" },
                { "instId", getValue(marketInner, "id") },
            };
            ((IList<object>)topics).Add(args);
            ((IList<object>)messageHashes).Add(add("ticker:", symbol));
        }
        object tickers = await this.watchPublicMultiple(messageHashes, topics, parameters);
        if (isTrue(this.newUpdates))
        {
            object result = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)result)[(string)getValue(tickers, "symbol")] = tickers;
            return result;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        //     {
        //         "action": "snapshot",
        //         "arg": {
        //             "instType": "SPOT",
        //             "channel": "ticker",
        //             "instId": "BTCUSDT"
        //         },
        //         "data": [
        //             {
        //                 "instId": "BTCUSDT",
        //                 "lastPr": "43528.19",
        //                 "open24h": "42267.78",
        //                 "high24h": "44490.00",
        //                 "low24h": "41401.53",
        //                 "change24h": "0.03879",
        //                 "bidPr": "43528",
        //                 "askPr": "43528.01",
        //                 "bidSz": "0.0334",
        //                 "askSz": "0.1917",
        //                 "baseVolume": "15002.4216",
        //                 "quoteVolume": "648006446.7164",
        //                 "openUtc": "44071.18",
        //                 "changeUtc24h": "-0.01232",
        //                 "ts": "1701842994338"
        //             }
        //         ],
        //         "ts": 1701842994341
        //     }
        //
        object ticker = this.parseWsTicker(message);
        object symbol = getValue(ticker, "symbol");
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
        object messageHash = add("ticker:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
    }

    public virtual object parseWsTicker(object message, object market = null)
    {
        //
        // spot
        //
        //     {
        //         "action": "snapshot",
        //         "arg": {
        //             "instType": "SPOT",
        //             "channel": "ticker",
        //             "instId": "BTCUSDT"
        //         },
        //         "data": [
        //             {
        //                 "instId": "BTCUSDT",
        //                 "lastPr": "43528.19",
        //                 "open24h": "42267.78",
        //                 "high24h": "44490.00",
        //                 "low24h": "41401.53",
        //                 "change24h": "0.03879",
        //                 "bidPr": "43528",
        //                 "askPr": "43528.01",
        //                 "bidSz": "0.0334",
        //                 "askSz": "0.1917",
        //                 "baseVolume": "15002.4216",
        //                 "quoteVolume": "648006446.7164",
        //                 "openUtc": "44071.18",
        //                 "changeUtc24h": "-0.01232",
        //                 "ts": "1701842994338"
        //             }
        //         ],
        //         "ts": 1701842994341
        //     }
        //
        // contract
        //
        //     {
        //         "action": "snapshot",
        //         "arg": {
        //             "instType": "USDT-FUTURES",
        //             "channel": "ticker",
        //             "instId": "BTCUSDT"
        //         },
        //         "data": [
        //             {
        //                 "instId": "BTCUSDT",
        //                 "lastPr": "43480.4",
        //                 "bidPr": "43476.3",
        //                 "askPr": "43476.8",
        //                 "bidSz": "0.1",
        //                 "askSz": "3.055",
        //                 "open24h": "42252.3",
        //                 "high24h": "44518.2",
        //                 "low24h": "41387.0",
        //                 "change24h": "0.03875",
        //                 "fundingRate": "0.000096",
        //                 "nextFundingTime": "1701849600000",
        //                 "markPrice": "43476.4",
        //                 "indexPrice": "43478.4",
        //                 "holdingAmount": "50670.787",
        //                 "baseVolume": "120187.104",
        //                 "quoteVolume": "5167385048.693",
        //                 "openUtc": "44071.4",
        //                 "symbolType": "1",
        //                 "symbol": "BTCUSDT",
        //                 "deliveryPrice": "0",
        //                 "ts": "1701843962811"
        //             }
        //         ],
        //         "ts": 1701843962812
        //     }
        //
        object arg = this.safeValue(message, "arg", new Dictionary<string, object>() {});
        object data = this.safeValue(message, "data", new List<object>() {});
        object ticker = this.safeValue(data, 0, new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(ticker, "ts");
        object instType = this.safeString(arg, "instType");
        object marketType = ((bool) isTrue((isEqual(instType, "SPOT")))) ? "spot" : "contract";
        object marketId = this.safeString(ticker, "instId");
        market = this.safeMarket(marketId, market, null, marketType);
        object close = this.safeString(ticker, "lastPr");
        object changeDecimal = this.safeString(ticker, "change24h");
        object change = Precise.stringMul(changeDecimal, "100");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high24h") },
            { "low", this.safeString(ticker, "low24h") },
            { "bid", this.safeString(ticker, "bidPr") },
            { "bidVolume", this.safeString(ticker, "bidSz") },
            { "ask", this.safeString(ticker, "askPr") },
            { "askVolume", this.safeString(ticker, "askSz") },
            { "vwap", null },
            { "open", this.safeString(ticker, "open24h") },
            { "close", close },
            { "last", close },
            { "previousClose", null },
            { "change", null },
            { "percentage", change },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "baseVolume") },
            { "quoteVolume", this.safeString(ticker, "quoteVolume") },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#watchOHLCV
        * @description watches historical candlestick data containing the open, high, low, close price, and the volume of a market
        * @see https://www.bitget.com/api-doc/spot/websocket/public/Candlesticks-Channel
        * @see https://www.bitget.com/api-doc/contract/websocket/public/Candlesticks-Channel
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object timeframes = this.safeValue(this.options, "timeframes");
        object interval = this.safeString(timeframes, timeframe);
        object messageHash = add(add(add("candles:", timeframe), ":"), symbol);
        object instType = null;
        var instTypeparametersVariable = this.getInstType(market, parameters);
        instType = ((IList<object>)instTypeparametersVariable)[0];
        parameters = ((IList<object>)instTypeparametersVariable)[1];
        object args = new Dictionary<string, object>() {
            { "instType", instType },
            { "channel", add("candle", interval) },
            { "instId", getValue(market, "id") },
        };
        object ohlcv = await this.watchPublic(messageHash, args, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "action": "snapshot",
        //         "arg": {
        //             "instType": "SPOT",
        //             "channel": "candle1m",
        //             "instId": "BTCUSDT"
        //         },
        //         "data": [
        //             [
        //                 "1701871620000",
        //                 "44080.23",
        //                 "44080.23",
        //                 "44028.5",
        //                 "44028.51",
        //                 "9.9287",
        //                 "437404.105512",
        //                 "437404.105512"
        //             ],
        //             [
        //                 "1701871680000",
        //                 "44028.51",
        //                 "44108.11",
        //                 "44028.5",
        //                 "44108.11",
        //                 "17.139",
        //                 "755436.870643",
        //                 "755436.870643"
        //             ],
        //         ],
        //         "ts": 1701901610417
        //     }
        //
        object arg = this.safeValue(message, "arg", new Dictionary<string, object>() {});
        object instType = this.safeString(arg, "instType");
        object marketType = ((bool) isTrue((isEqual(instType, "SPOT")))) ? "spot" : "contract";
        object marketId = this.safeString(arg, "instId");
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        object channel = this.safeString(arg, "channel");
        object interval = ((string)channel).Replace((string)"candle", (string)"");
        object timeframes = this.safeValue(this.options, "timeframes");
        object timeframe = this.findTimeframe(interval, timeframes);
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
        }
        object data = this.safeValue(message, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object parsed = this.parseWsOHLCV(getValue(data, i), market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        object messageHash = add(add(add("candles:", timeframe), ":"), symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public override object parseWsOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         "1701871620000",  // timestamp
        //         "44080.23", // open
        //         "44080.23", // high
        //         "44028.5", // low
        //         "44028.51", // close
        //         "9.9287", // base volume
        //         "437404.105512", // quote volume
        //         "437404.105512" // USDT volume
        //     ]
        //
        object volumeIndex = ((bool) isTrue((getValue(market, "inverse")))) ? 6 : 5;
        return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, volumeIndex)};
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#watchOrderBook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://www.bitget.com/api-doc/spot/websocket/public/Depth-Channel
        * @see https://www.bitget.com/api-doc/contract/websocket/public/Order-Book-Channel
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchOrderBookForSymbols(new List<object>() {symbol}, limit, parameters);
    }

    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#watchOrderBookForSymbols
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://www.bitget.com/api-doc/spot/websocket/public/Depth-Channel
        * @see https://www.bitget.com/api-doc/contract/websocket/public/Order-Book-Channel
        * @param {string[]} symbols unified array of symbols
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object channel = "books";
        object incrementalFeed = true;
        if (isTrue(isTrue(isTrue((isEqual(limit, 1))) || isTrue((isEqual(limit, 5)))) || isTrue((isEqual(limit, 15)))))
        {
            channel = add(channel, ((object)limit).ToString());
            incrementalFeed = false;
        }
        object topics = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = this.market(symbol);
            object instType = null;
            var instTypeparametersVariable = this.getInstType(market, parameters);
            instType = ((IList<object>)instTypeparametersVariable)[0];
            parameters = ((IList<object>)instTypeparametersVariable)[1];
            object args = new Dictionary<string, object>() {
                { "instType", instType },
                { "channel", channel },
                { "instId", getValue(market, "id") },
            };
            ((IList<object>)topics).Add(args);
            ((IList<object>)messageHashes).Add(add("orderbook:", symbol));
        }
        object orderbook = await this.watchPublicMultiple(messageHashes, topics, parameters);
        if (isTrue(incrementalFeed))
        {
            return (orderbook as IOrderBook).limit();
        } else
        {
            return orderbook;
        }
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //   {
        //       "action":"snapshot",
        //       "arg":{
        //          "instType":"SPOT",
        //          "channel":"books5",
        //          "instId":"BTCUSDT"
        //       },
        //       "data":[
        //          {
        //             "asks":[
        //                ["21041.11","0.0445"],
        //                ["21041.16","0.0411"],
        //                ["21041.21","0.0421"],
        //                ["21041.26","0.0811"],
        //                ["21041.65","1.9465"]
        //             ],
        //             "bids":[
        //                ["21040.76","0.0417"],
        //                ["21040.71","0.0434"],
        //                ["21040.66","0.1141"],
        //                ["21040.61","0.3004"],
        //                ["21040.60","1.3357"]
        //             ],
        //             "checksum": -1367582038,
        //             "ts":"1656413855484"
        //          }
        //       ]
        //   }
        //
        object arg = this.safeValue(message, "arg");
        object channel = this.safeString(arg, "channel");
        object instType = this.safeString(arg, "instType");
        object marketType = ((bool) isTrue((isEqual(instType, "SPOT")))) ? "spot" : "contract";
        object marketId = this.safeString(arg, "instId");
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        object messageHash = add("orderbook:", symbol);
        object data = this.safeValue(message, "data");
        object rawOrderBook = this.safeValue(data, 0);
        object timestamp = this.safeInteger(rawOrderBook, "ts");
        object incrementalBook = isEqual(channel, "books");
        if (isTrue(incrementalBook))
        {
            // storedOrderBook = this.safeValue (this.orderbooks, symbol);
            if (!isTrue((inOp(this.orderbooks, symbol))))
            {
                // const ob = this.orderBook ({});
                object ob = this.countedOrderBook(new Dictionary<string, object>() {});
                ((IDictionary<string,object>)ob)["symbol"] = symbol;
                ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = ob;
            }
            object storedOrderBook = getValue(this.orderbooks, symbol);
            object asks = this.safeValue(rawOrderBook, "asks", new List<object>() {});
            object bids = this.safeValue(rawOrderBook, "bids", new List<object>() {});
            this.handleDeltas(getValue(storedOrderBook, "asks"), asks);
            this.handleDeltas(getValue(storedOrderBook, "bids"), bids);
            ((IDictionary<string,object>)storedOrderBook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)storedOrderBook)["datetime"] = this.iso8601(timestamp);
            object checksum = this.safeBool(this.options, "checksum", true);
            object isSnapshot = isEqual(this.safeString(message, "action"), "snapshot"); // snapshot does not have a checksum
            if (isTrue(!isTrue(isSnapshot) && isTrue(checksum)))
            {
                object storedAsks = getValue(storedOrderBook, "asks");
                object storedBids = getValue(storedOrderBook, "bids");
                object asksLength = getArrayLength(storedAsks);
                object bidsLength = getArrayLength(storedBids);
                object payloadArray = new List<object>() {};
                for (object i = 0; isLessThan(i, 25); postFixIncrement(ref i))
                {
                    if (isTrue(isLessThan(i, bidsLength)))
                    {
                        ((IList<object>)payloadArray).Add(getValue(getValue(getValue(storedBids, i), 2), 0));
                        ((IList<object>)payloadArray).Add(getValue(getValue(getValue(storedBids, i), 2), 1));
                    }
                    if (isTrue(isLessThan(i, asksLength)))
                    {
                        ((IList<object>)payloadArray).Add(getValue(getValue(getValue(storedAsks, i), 2), 0));
                        ((IList<object>)payloadArray).Add(getValue(getValue(getValue(storedAsks, i), 2), 1));
                    }
                }
                object payload = String.Join(":", ((IList<object>)payloadArray).ToArray());
                object calculatedChecksum = this.crc32(payload, true);
                object responseChecksum = this.safeInteger(rawOrderBook, "checksum");
                if (isTrue(!isEqual(calculatedChecksum, responseChecksum)))
                {
                    var error = new InvalidNonce(add(this.id, " invalid checksum"));
                    ((WebSocketClient)client).reject(error, messageHash);
                }
            }
        } else
        {
            object orderbook = this.orderBook(new Dictionary<string, object>() {});
            object parsedOrderbook = this.parseOrderBook(rawOrderBook, symbol, timestamp);
            (orderbook as IOrderBook).reset(parsedOrderbook);
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.orderbooks, symbol), messageHash});
    }

    public override void handleDelta(object bookside, object delta)
    {
        object bidAsk = this.parseBidAsk(delta, 0, 1);
        // we store the string representations in the orderbook for checksum calculation
        // this simplifies the code for generating checksums as we do not need to do any complex number transformations
        ((IList<object>)bidAsk).Add(delta);
        (bookside as IOrderBookSide).storeArray(bidAsk);
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#watchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://www.bitget.com/api-doc/spot/websocket/public/Trades-Channel
        * @see https://www.bitget.com/api-doc/contract/websocket/public/New-Trades-Channel
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#watchTradesForSymbols
        * @description get the list of most recent trades for a particular symbol
        * @see https://www.bitget.com/api-doc/spot/websocket/public/Trades-Channel
        * @see https://www.bitget.com/api-doc/contract/websocket/public/New-Trades-Channel
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        object symbolsLength = getArrayLength(symbols);
        if (isTrue(isEqual(symbolsLength, 0)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchTradesForSymbols() requires a non-empty array of symbols")) ;
        }
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object topics = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = this.market(symbol);
            object instType = null;
            var instTypeparametersVariable = this.getInstType(market, parameters);
            instType = ((IList<object>)instTypeparametersVariable)[0];
            parameters = ((IList<object>)instTypeparametersVariable)[1];
            object args = new Dictionary<string, object>() {
                { "instType", instType },
                { "channel", "trade" },
                { "instId", getValue(market, "id") },
            };
            ((IList<object>)topics).Add(args);
            ((IList<object>)messageHashes).Add(add("trade:", symbol));
        }
        object trades = await this.watchPublicMultiple(messageHashes, topics, parameters);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeValue(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //         "action": "snapshot",
        //         "arg": { "instType": "SPOT", "channel": "trade", "instId": "BTCUSDT" },
        //         "data": [
        //             {
        //                 "ts": "1701910980366",
        //                 "price": "43854.01",
        //                 "size": "0.0535",
        //                 "side": "buy",
        //                 "tradeId": "1116461060594286593"
        //             },
        //         ],
        //         "ts": 1701910980730
        //     }
        //
        object arg = this.safeValue(message, "arg", new Dictionary<string, object>() {});
        object instType = this.safeString(arg, "instType");
        object marketType = ((bool) isTrue((isEqual(instType, "SPOT")))) ? "spot" : "contract";
        object marketId = this.safeString(arg, "instId");
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        object stored = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        object data = this.safeList(message, "data", new List<object>() {});
        object length = getArrayLength(data);
        // fix chronological order by reversing
        for (object i = 0; isLessThan(i, length); postFixIncrement(ref i))
        {
            object index = subtract(subtract(length, i), 1);
            object rawTrade = getValue(data, index);
            object parsed = this.parseWsTrade(rawTrade, market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        object messageHash = add("trade:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        //     {
        //         "ts": "1701910980366",
        //         "price": "43854.01",
        //         "size": "0.0535",
        //         "side": "buy",
        //         "tradeId": "1116461060594286593"
        //     }
        // swap private
        //
        //            {
        //               "orderId": "1169142761031114781",
        //               "tradeId": "1169142761312637004",
        //               "symbol": "LTCUSDT",
        //               "orderType": "market",
        //               "side": "buy",
        //               "price": "80.87",
        //               "baseVolume": "0.1",
        //               "quoteVolume": "8.087",
        //               "profit": "0",
        //               "tradeSide": "open",
        //               "posMode": "hedge_mode",
        //               "tradeScope": "taker",
        //               "feeDetail": [
        //                  {
        //                     "feeCoin": "USDT",
        //                     "deduction": "no",
        //                     "totalDeductionFee": "0",
        //                     "totalFee": "-0.0048522"
        //                  }
        //               ],
        //               "cTime": "1714471276596",
        //               "uTime": "1714471276596"
        //            }
        // spot private
        //        {
        //           "orderId": "1169142457356959747",
        //           "tradeId": "1169142457636958209",
        //           "symbol": "LTCUSDT",
        //           "orderType": "market",
        //           "side": "buy",
        //           "priceAvg": "81.069",
        //           "size": "0.074",
        //           "amount": "5.999106",
        //           "tradeScope": "taker",
        //           "feeDetail": [
        //              {
        //                 "feeCoin": "LTC",
        //                 "deduction": "no",
        //                 "totalDeductionFee": "0",
        //                 "totalFee": "0.000074"
        //              }
        //           ],
        //           "cTime": "1714471204194",
        //           "uTime": "1714471204194"
        //        }
        //
        object instId = this.safeString2(trade, "symbol", "instId");
        object posMode = this.safeString(trade, "posMode");
        object defaultType = ((bool) isTrue((!isEqual(posMode, null)))) ? "contract" : "spot";
        if (isTrue(isEqual(market, null)))
        {
            market = this.safeMarket(instId, null, null, defaultType);
        }
        object timestamp = this.safeIntegerN(trade, new List<object>() {"uTime", "cTime", "ts"});
        object feeDetail = this.safeList(trade, "feeDetail", new List<object>() {});
        object first = this.safeDict(feeDetail, 0);
        object fee = null;
        if (isTrue(!isEqual(first, null)))
        {
            object feeCurrencyId = this.safeString(first, "feeCoin");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", Precise.stringAbs(this.safeString(first, "totalFee")) },
                { "currency", feeCurrencyCode },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString(trade, "tradeId") },
            { "order", this.safeString(trade, "orderId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "type", this.safeString(trade, "orderType") },
            { "side", this.safeString(trade, "side") },
            { "takerOrMaker", this.safeString(trade, "tradeScope") },
            { "price", this.safeString2(trade, "priceAvg", "price") },
            { "amount", this.safeString2(trade, "size", "baseVolume") },
            { "cost", this.safeString2(trade, "amount", "quoteVolume") },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#watchPositions
        * @description watch all open positions
        * @see https://www.bitget.com/api-doc/contract/websocket/private/Positions-Channel
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the exchange API endpoint
        * @param {string} [params.instType] one of 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES', default is 'USDT-FUTURES'
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object messageHash = "";
        object subscriptionHash = "positions";
        object instType = "USDT-FUTURES";
        symbols = this.marketSymbols(symbols);
        if (!isTrue(this.isEmpty(symbols)))
        {
            market = this.getMarketFromSymbols(symbols);
            var instTypeparametersVariable = this.getInstType(market, parameters);
            instType = ((IList<object>)instTypeparametersVariable)[0];
            parameters = ((IList<object>)instTypeparametersVariable)[1];
        }
        messageHash = add(add(instType, ":positions"), messageHash);
        object args = new Dictionary<string, object>() {
            { "instType", instType },
            { "channel", "positions" },
            { "instId", "default" },
        };
        object newPositions = await this.watchPrivate(messageHash, subscriptionHash, args, parameters);
        if (isTrue(this.newUpdates))
        {
            return newPositions;
        }
        return this.filterBySymbolsSinceLimit(newPositions, symbols, since, limit, true);
    }

    public virtual void handlePositions(WebSocketClient client, object message)
    {
        //
        //     {
        //         "action": "snapshot",
        //         "arg": {
        //             "instType": "USDT-FUTURES",
        //             "channel": "positions",
        //             "instId": "default"
        //         },
        //         "data": [
        //             {
        //                 "posId": "926036334386778112",
        //                 "instId": "BTCUSDT",
        //                 "marginCoin": "USDT",
        //                 "marginSize": "2.19245",
        //                 "marginMode": "crossed",
        //                 "holdSide": "long",
        //                 "posMode": "hedge_mode",
        //                 "total": "0.001",
        //                 "available": "0.001",
        //                 "frozen": "0",
        //                 "openPriceAvg": "43849",
        //                 "leverage": 20,
        //                 "achievedProfits": "0",
        //                 "unrealizedPL": "-0.0032",
        //                 "unrealizedPLR": "-0.00145955438",
        //                 "liquidationPrice": "17629.684814834",
        //                 "keepMarginRate": "0.004",
        //                 "marginRate": "0.007634649185",
        //                 "cTime": "1652331666985",
        //                 "uTime": "1701913016923",
        //                 "autoMargin": "off"
        //             },
        //             ...
        //         ]
        //         "ts": 1701913043767
        //     }
        //
        object arg = this.safeValue(message, "arg", new Dictionary<string, object>() {});
        object instType = this.safeString(arg, "instType", "");
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new Dictionary<string, object>() {};
        }
        if (!isTrue((inOp(this.positions, instType))))
        {
            ((IDictionary<string,object>)this.positions)[(string)instType] = new ArrayCacheBySymbolBySide();
        }
        object cache = getValue(this.positions, instType);
        object rawPositions = this.safeValue(message, "data", new List<object>() {});
        object dataLength = getArrayLength(rawPositions);
        if (isTrue(isEqual(dataLength, 0)))
        {
            return;
        }
        object newPositions = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rawPositions)); postFixIncrement(ref i))
        {
            object rawPosition = getValue(rawPositions, i);
            object marketId = this.safeString(rawPosition, "instId");
            object market = this.safeMarket(marketId, null, null, "contract");
            object position = this.parseWsPosition(rawPosition, market);
            ((IList<object>)newPositions).Add(position);
            callDynamically(cache, "append", new object[] {position});
        }
        object messageHashes = this.findMessageHashes(client as WebSocketClient, add(instType, ":positions::"));
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object positions = this.filterByArray(newPositions, "symbol", symbols, false);
            if (!isTrue(this.isEmpty(positions)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {positions, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newPositions, add(instType, ":positions")});
    }

    public virtual object parseWsPosition(object position, object market = null)
    {
        //
        //     {
        //         "posId": "926036334386778112",
        //         "instId": "BTCUSDT",
        //         "marginCoin": "USDT",
        //         "marginSize": "2.19245",
        //         "marginMode": "crossed",
        //         "holdSide": "long",
        //         "posMode": "hedge_mode",
        //         "total": "0.001",
        //         "available": "0.001",
        //         "frozen": "0",
        //         "openPriceAvg": "43849",
        //         "leverage": 20,
        //         "achievedProfits": "0",
        //         "unrealizedPL": "-0.0032",
        //         "unrealizedPLR": "-0.00145955438",
        //         "liquidationPrice": "17629.684814834",
        //         "keepMarginRate": "0.004",
        //         "marginRate": "0.007634649185",
        //         "cTime": "1652331666985",
        //         "uTime": "1701913016923",
        //         "autoMargin": "off"
        //     }
        //
        object marketId = this.safeString(position, "instId");
        object marginModeId = this.safeString(position, "marginMode");
        object marginMode = this.getSupportedMapping(marginModeId, new Dictionary<string, object>() {
            { "crossed", "cross" },
            { "isolated", "isolated" },
        });
        object hedgedId = this.safeString(position, "posMode");
        object hedged = ((bool) isTrue((isEqual(hedgedId, "hedge_mode")))) ? true : false;
        object timestamp = this.safeInteger2(position, "uTime", "cTime");
        object percentageDecimal = this.safeString(position, "unrealizedPLR");
        object percentage = Precise.stringMul(percentageDecimal, "100");
        object contractSize = null;
        if (isTrue(!isEqual(market, null)))
        {
            contractSize = getValue(market, "contractSize");
        }
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", this.safeString(position, "posId") },
            { "symbol", this.safeSymbol(marketId, market, null, "contract") },
            { "notional", null },
            { "marginMode", marginMode },
            { "liquidationPrice", this.safeNumber(position, "liquidationPrice") },
            { "entryPrice", this.safeNumber(position, "openPriceAvg") },
            { "unrealizedPnl", this.safeNumber(position, "unrealizedPL") },
            { "percentage", this.parseNumber(percentage) },
            { "contracts", this.safeNumber(position, "total") },
            { "contractSize", contractSize },
            { "markPrice", null },
            { "side", this.safeString(position, "holdSide") },
            { "hedged", hedged },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", this.safeNumber(position, "keepMarginRate") },
            { "collateral", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "leverage", this.safeNumber(position, "leverage") },
            { "marginRatio", this.safeNumber(position, "marginRate") },
        });
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#watchOrders
        * @description watches information on multiple orders made by the user
        * @see https://www.bitget.com/api-doc/spot/websocket/private/Order-Channel
        * @see https://www.bitget.com/api-doc/contract/websocket/private/Order-Channel
        * @see https://www.bitget.com/api-doc/contract/websocket/private/Plan-Order-Channel
        * @see https://www.bitget.com/api-doc/margin/cross/websocket/private/Cross-Orders
        * @see https://www.bitget.com/api-doc/margin/isolated/websocket/private/Isolate-Orders
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.stop] *contract only* set to true for watching trigger orders
        * @param {string} [params.marginMode] 'isolated' or 'cross' for watching spot margin orders
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object marketId = null;
        object isStop = this.safeBool(parameters, "stop", false);
        parameters = this.omit(parameters, "stop");
        object messageHash = ((bool) isTrue((isStop))) ? "triggerOrder" : "order";
        object subscriptionHash = "order:trades";
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            marketId = getValue(market, "id");
            messageHash = add(add(messageHash, ":"), symbol);
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(isTrue((isEqual(type, "spot"))) && isTrue((isEqual(symbol, null)))))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " watchOrders requires a symbol argument for "), type), " markets.")) ;
        }
        if (isTrue(isTrue(isStop) && isTrue(isEqual(type, "spot"))))
        {
            throw new NotSupported ((string)add(add(add(this.id, " watchOrders does not support stop orders for "), type), " markets.")) ;
        }
        object instType = null;
        var instTypeparametersVariable = this.getInstType(market, parameters);
        instType = ((IList<object>)instTypeparametersVariable)[0];
        parameters = ((IList<object>)instTypeparametersVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            subscriptionHash = add(add(subscriptionHash, ":"), symbol);
        }
        if (isTrue(isStop))
        {
            subscriptionHash = add(subscriptionHash, ":stop"); // we don't want to re-use the same subscription hash for stop orders
        }
        object instId = ((bool) isTrue((isEqual(type, "spot")))) ? marketId : "default"; // different from other streams here the 'rest' id is required for spot markets, contract markets require default here
        object channel = ((bool) isTrue(isStop)) ? "orders-algo" : "orders";
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("watchOrders", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            instType = "MARGIN";
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                channel = "orders-isolated";
            } else
            {
                channel = "orders-crossed";
            }
        }
        object args = new Dictionary<string, object>() {
            { "instType", instType },
            { "channel", channel },
            { "instId", instId },
        };
        object orders = await this.watchPrivate(messageHash, subscriptionHash, args, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //     {
        //         "action": "snapshot",
        //         "arg": { "instType": "SPOT", "channel": "orders", "instId": "BTCUSDT" },
        //         "data": [
        //             {
        //                 "instId": "BTCUSDT",
        //                 "orderId": "1116512721422422017",
        //                 "clientOid": "798d1425-d31d-4ada-a51b-ec701e00a1d9",
        //                 "price": "35000.00",
        //                 "size": "7.0000",
        //                 "newSize": "500.0000",
        //                 "notional": "7.000000",
        //                 "orderType": "limit",
        //                 "force": "gtc",
        //                 "side": "buy",
        //                 "accBaseVolume": "0.0000",
        //                 "priceAvg": "0.00",
        //                 "status": "live",
        //                 "cTime": "1701923297267",
        //                 "uTime": "1701923297267",
        //                 "feeDetail": [],
        //                 "enterPointSource": "WEB"
        //             }
        //         ],
        //         "ts": 1701923297285
        //     }
        //
        // contract
        //
        //     {
        //         "action": "snapshot",
        //         "arg": { "instType": "USDT-FUTURES", "channel": "orders", "instId": "default" },
        //         "data": [
        //             {
        //                 "accBaseVolume": "0",
        //                 "cTime": "1701920553759",
        //                 "clientOid": "1116501214318198793",
        //                 "enterPointSource": "WEB",
        //                 "feeDetail": [{
        //                     "feeCoin": "USDT",
        //                     "fee": "-0.162003"
        //                 }],
        //                 "force": "gtc",
        //                 "instId": "BTCUSDT",
        //                 "leverage": "20",
        //                 "marginCoin": "USDT",
        //                 "marginMode": "isolated",
        //                 "notionalUsd": "105",
        //                 "orderId": "1116501214293032964",
        //                 "orderType": "limit",
        //                 "posMode": "hedge_mode",
        //                 "posSide": "long",
        //                 "price": "35000",
        //                 "reduceOnly": "no",
        //                 "side": "buy",
        //                 "size": "0.003",
        //                 "status": "canceled",
        //                 "tradeSide": "open",
        //                 "uTime": "1701920595866"
        //             }
        //         ],
        //         "ts": 1701920595879
        //     }
        //
        // trigger
        //
        //     {
        //         "action": "snapshot",
        //         "arg": {
        //             "instType": "USDT-FUTURES",
        //             "channel": "orders-algo",
        //             "instId": "default"
        //         },
        //         "data": [
        //             {
        //                 "instId": "BTCUSDT",
        //                 "orderId": "1116508960750899201",
        //                 "clientOid": "1116508960750899200",
        //                 "triggerPrice": "35000.000000000",
        //                 "triggerType": "mark_price",
        //                 "triggerTime": "1701922464373",
        //                 "planType": "pl",
        //                 "price": "35000.000000000",
        //                 "size": "0.001000000",
        //                 "actualSize": "0.000000000",
        //                 "orderType": "limit",
        //                 "side": "buy",
        //                 "tradeSide": "open",
        //                 "posSide": "long",
        //                 "marginCoin": "USDT",
        //                 "status": "cancelled",
        //                 "posMode": "hedge_mode",
        //                 "enterPointSource": "api",
        //                 "stopSurplusTriggerType": "fill_price",
        //                 "stopLossTriggerType": "fill_price",
        //                 "cTime": "1701922400653",
        //                 "uTime": "1701922464373"
        //             }
        //         ],
        //         "ts": 1701922464417
        //     }
        //
        // isolated and cross margin
        //
        //     {
        //         "action": "snapshot",
        //         "arg": { "instType": "MARGIN", "channel": "orders-crossed", "instId": "BTCUSDT" },
        //         "data": [
        //             {
        //                 "enterPointSource": "web",
        //                 "force": "gtc",
        //                 "orderType": "limit",
        //                 "price": "35000.000000000",
        //                 "quoteSize": "10.500000000",
        //                 "side": "buy",
        //                 "status": "live",
        //                 "baseSize": "0.000300000",
        //                 "cTime": "1701923982427",
        //                 "clientOid": "4902047879864dc980c4840e9906db4e",
        //                 "fillPrice": "0.000000000",
        //                 "baseVolume": "0.000000000",
        //                 "fillTotalAmount": "0.000000000",
        //                 "loanType": "auto-loan-and-repay",
        //                 "orderId": "1116515595178356737"
        //             }
        //         ],
        //         "ts": 1701923982497
        //     }
        //
        object arg = this.safeValue(message, "arg", new Dictionary<string, object>() {});
        object channel = this.safeString(arg, "channel");
        object instType = this.safeString(arg, "instType");
        object marketType = null;
        if (isTrue(isEqual(instType, "SPOT")))
        {
            marketType = "spot";
        } else if (isTrue(isEqual(instType, "MARGIN")))
        {
            marketType = "spot";
        } else
        {
            marketType = "contract";
        }
        object data = this.safeValue(message, "data", new List<object>() {});
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
            this.triggerOrders = new ArrayCacheBySymbolById(limit);
        }
        object stored = ((bool) isTrue((isEqual(channel, "ordersAlgo")))) ? this.triggerOrders : this.orders;
        object messageHash = ((bool) isTrue((isEqual(channel, "ordersAlgo")))) ? "triggerOrder" : "order";
        object marketSymbols = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object order = getValue(data, i);
            object marketId = this.safeString(order, "instId");
            object market = this.safeMarket(marketId, null, null, marketType);
            object parsed = this.parseWsOrder(order, market);
            callDynamically(stored, "append", new object[] {parsed});
            object symbol = getValue(parsed, "symbol");
            ((IDictionary<string,object>)marketSymbols)[(string)symbol] = true;
        }
        object keys = new List<object>(((IDictionary<string,object>)marketSymbols).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object symbol = getValue(keys, i);
            object innerMessageHash = add(add(messageHash, ":"), symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, innerMessageHash});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        // spot
        //
        //     {
        //         "instId": "BTCUSDT",
        //         "orderId": "1116512721422422017",
        //         "clientOid": "798d1425-d31d-4ada-a51b-ec701e00a1d9",
        //         "price": "35000.00",
        //         "size": "7.0000",
        //         "newSize": "500.0000",
        //         "notional": "7.000000",
        //         "orderType": "limit",
        //         "force": "gtc",
        //         "side": "buy",
        //         "accBaseVolume": "0.0000",
        //         "priceAvg": "0.00",
        //         "status": "live",
        //         "cTime": "1701923297267",
        //         "uTime": "1701923297267",
        //         "feeDetail": [],
        //         "enterPointSource": "WEB"
        //     }
        //
        // contract
        //
        //     {
        //         "accBaseVolume": "0",
        //         "cTime": "1701920553759",
        //         "clientOid": "1116501214318198793",
        //         "enterPointSource": "WEB",
        //         "feeDetail": [{
        //             "feeCoin": "USDT",
        //             "fee": "-0.162003"
        //         }],
        //         "force": "gtc",
        //         "instId": "BTCUSDT",
        //         "leverage": "20",
        //         "marginCoin": "USDT",
        //         "marginMode": "isolated",
        //         "notionalUsd": "105",
        //         "orderId": "1116501214293032964",
        //         "orderType": "limit",
        //         "posMode": "hedge_mode",
        //         "posSide": "long",
        //         "price": "35000",
        //         "reduceOnly": "no",
        //         "side": "buy",
        //         "size": "0.003",
        //         "status": "canceled",
        //         "tradeSide": "open",
        //         "uTime": "1701920595866"
        //     }
        //
        // trigger
        //
        //     {
        //         "instId": "BTCUSDT",
        //         "orderId": "1116508960750899201",
        //         "clientOid": "1116508960750899200",
        //         "triggerPrice": "35000.000000000",
        //         "triggerType": "mark_price",
        //         "triggerTime": "1701922464373",
        //         "planType": "pl",
        //         "price": "35000.000000000",
        //         "size": "0.001000000",
        //         "actualSize": "0.000000000",
        //         "orderType": "limit",
        //         "side": "buy",
        //         "tradeSide": "open",
        //         "posSide": "long",
        //         "marginCoin": "USDT",
        //         "status": "cancelled",
        //         "posMode": "hedge_mode",
        //         "enterPointSource": "api",
        //         "stopSurplusTriggerType": "fill_price",
        //         "stopLossTriggerType": "fill_price",
        //         "cTime": "1701922400653",
        //         "uTime": "1701922464373"
        //     }
        //
        // isolated and cross margin
        //
        //     {
        //         "enterPointSource": "web",
        //         "force": "gtc",
        //         "orderType": "limit",
        //         "price": "35000.000000000",
        //         "quoteSize": "10.500000000",
        //         "side": "buy",
        //         "status": "live",
        //         "baseSize": "0.000300000",
        //         "cTime": "1701923982427",
        //         "clientOid": "4902047879864dc980c4840e9906db4e",
        //         "fillPrice": "0.000000000",
        //         "baseVolume": "0.000000000",
        //         "fillTotalAmount": "0.000000000",
        //         "loanType": "auto-loan-and-repay",
        //         "orderId": "1116515595178356737"
        //     }
        //
        object marketId = this.safeString(order, "instId");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(order, "cTime");
        object symbol = getValue(market, "symbol");
        object rawStatus = this.safeString(order, "status");
        object orderFee = this.safeValue(order, "feeDetail", new List<object>() {});
        object fee = this.safeValue(orderFee, 0);
        object feeAmount = this.safeString(fee, "fee");
        object feeObject = null;
        if (isTrue(!isEqual(feeAmount, null)))
        {
            object feeCurrency = this.safeString(fee, "feeCoin");
            feeObject = new Dictionary<string, object>() {
                { "cost", this.parseNumber(Precise.stringAbs(feeAmount)) },
                { "currency", this.safeCurrencyCode(feeCurrency) },
            };
        }
        object triggerPrice = this.safeNumber(order, "triggerPrice");
        object price = this.safeString(order, "price");
        object avgPrice = this.omitZero(this.safeString2(order, "priceAvg", "fillPrice"));
        object cost = this.safeStringN(order, new List<object>() {"notional", "notionalUsd", "quoteSize"});
        object side = this.safeString(order, "side");
        object type = this.safeString(order, "orderType");
        if (isTrue(isTrue(isTrue(isEqual(side, "buy")) && isTrue(getValue(market, "spot"))) && isTrue((isEqual(type, "market")))))
        {
            cost = this.safeString(order, "newSize", cost);
        }
        object filled = this.safeString2(order, "accBaseVolume", "baseVolume");
        // if (market['spot'] && (rawStatus !== 'live')) {
        //     filled = Precise.stringDiv (cost, avgPrice);
        // }
        object amount = this.safeString(order, "baseVolume");
        if (isTrue(!isTrue(getValue(market, "spot")) || !isTrue((isTrue(isEqual(side, "buy")) && isTrue(isEqual(type, "market"))))))
        {
            amount = this.safeString(order, "newSize", amount);
        }
        if (isTrue(isTrue(getValue(market, "swap")) && isTrue((isEqual(amount, null)))))
        {
            amount = this.safeString(order, "size");
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "symbol", symbol },
            { "id", this.safeString(order, "orderId") },
            { "clientOrderId", this.safeString(order, "clientOid") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", this.safeInteger(order, "uTime") },
            { "type", type },
            { "timeInForce", this.safeStringUpper(order, "force") },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", triggerPrice },
            { "triggerPrice", triggerPrice },
            { "amount", amount },
            { "cost", cost },
            { "average", avgPrice },
            { "filled", filled },
            { "remaining", null },
            { "status", this.parseWsOrderStatus(rawStatus) },
            { "fee", feeObject },
            { "trades", null },
        }, market);
    }

    public virtual object parseWsOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "live", "open" },
            { "partially_filled", "open" },
            { "filled", "closed" },
            { "cancelled", "canceled" },
            { "not_trigger", "open" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#watchMyTrades
        * @description watches trades made by the user
        * @see https://www.bitget.com/api-doc/contract/websocket/private/Order-Channel
        * @param {str} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object messageHash = "myTrades";
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            messageHash = add(add(messageHash, ":"), symbol);
        }
        object instType = null;
        var instTypeparametersVariable = this.getInstType(market, parameters);
        instType = ((IList<object>)instTypeparametersVariable)[0];
        parameters = ((IList<object>)instTypeparametersVariable)[1];
        object subscriptionHash = add("fill:", instType);
        object args = new Dictionary<string, object>() {
            { "instType", instType },
            { "channel", "fill" },
            { "instId", "default" },
        };
        object trades = await this.watchPrivate(messageHash, subscriptionHash, args, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleMyTrades(WebSocketClient client, object message)
    {
        //
        // spot
        // {
        //     "action": "snapshot",
        //     "arg": {
        //        "instType": "SPOT",
        //        "channel": "fill",
        //        "instId": "default"
        //     },
        //     "data": [
        //        {
        //           "orderId": "1169142457356959747",
        //           "tradeId": "1169142457636958209",
        //           "symbol": "LTCUSDT",
        //           "orderType": "market",
        //           "side": "buy",
        //           "priceAvg": "81.069",
        //           "size": "0.074",
        //           "amount": "5.999106",
        //           "tradeScope": "taker",
        //           "feeDetail": [
        //              {
        //                 "feeCoin": "LTC",
        //                 "deduction": "no",
        //                 "totalDeductionFee": "0",
        //                 "totalFee": "0.000074"
        //              }
        //           ],
        //           "cTime": "1714471204194",
        //           "uTime": "1714471204194"
        //        }
        //     ],
        //     "ts": 1714471204270
        // }
        // swap
        //     {
        //         "action": "snapshot",
        //         "arg": {
        //            "instType": "USDT-FUTURES",
        //            "channel": "fill",
        //            "instId": "default"
        //         },
        //         "data": [
        //            {
        //               "orderId": "1169142761031114781",
        //               "tradeId": "1169142761312637004",
        //               "symbol": "LTCUSDT",
        //               "orderType": "market",
        //               "side": "buy",
        //               "price": "80.87",
        //               "baseVolume": "0.1",
        //               "quoteVolume": "8.087",
        //               "profit": "0",
        //               "tradeSide": "open",
        //               "posMode": "hedge_mode",
        //               "tradeScope": "taker",
        //               "feeDetail": [
        //                  {
        //                     "feeCoin": "USDT",
        //                     "deduction": "no",
        //                     "totalDeductionFee": "0",
        //                     "totalFee": "-0.0048522"
        //                  }
        //               ],
        //               "cTime": "1714471276596",
        //               "uTime": "1714471276596"
        //            }
        //         ],
        //         "ts": 1714471276629
        //     }
        //
        if (isTrue(isEqual(this.myTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            this.myTrades = new ArrayCache(limit);
        }
        object stored = this.myTrades;
        object data = this.safeList(message, "data", new List<object>() {});
        object length = getArrayLength(data);
        object messageHash = "myTrades";
        for (object i = 0; isLessThan(i, length); postFixIncrement(ref i))
        {
            object trade = getValue(data, i);
            object parsed = this.parseWsTrade(trade);
            callDynamically(stored, "append", new object[] {parsed});
            object symbol = getValue(parsed, "symbol");
            object symbolSpecificMessageHash = add("myTrades:", symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, symbolSpecificMessageHash});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bitget#watchBalance
        * @description watch balance and get the amount of funds available for trading or funds locked in orders
        * @see https://www.bitget.com/api-doc/spot/websocket/private/Account-Channel
        * @see https://www.bitget.com/api-doc/contract/websocket/private/Account-Channel
        * @see https://www.bitget.com/api-doc/margin/cross/websocket/private/Margin-Cross-Account-Assets
        * @see https://www.bitget.com/api-doc/margin/isolated/websocket/private/Margin-isolated-account-assets
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {str} [params.type] spot or contract if not provided this.options['defaultType'] is used
        * @param {string} [params.instType] one of 'SPOT', 'MARGIN', 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
        * @param {string} [params.marginMode] 'isolated' or 'cross' for watching spot margin balances
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("watchBalance", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object instType = null;
        object channel = "account";
        if (isTrue(isTrue((isEqual(type, "swap"))) || isTrue((isEqual(type, "future")))))
        {
            instType = "USDT-FUTURES";
        } else if (isTrue(!isEqual(marginMode, null)))
        {
            instType = "MARGIN";
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                channel = "account-isolated";
            } else
            {
                channel = "account-crossed";
            }
        } else
        {
            instType = "SPOT";
        }
        var instTypeparametersVariable = this.handleOptionAndParams(parameters, "watchBalance", "instType", instType);
        instType = ((IList<object>)instTypeparametersVariable)[0];
        parameters = ((IList<object>)instTypeparametersVariable)[1];
        object args = new Dictionary<string, object>() {
            { "instType", instType },
            { "channel", channel },
            { "coin", "default" },
        };
        object messageHash = add("balance:", ((string)instType).ToLower());
        return await this.watchPrivate(messageHash, messageHash, args, parameters);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //     {
        //         "action": "snapshot",
        //         "arg": { "instType": "SPOT", "channel": "account", "coin": "default" },
        //         "data": [
        //             {
        //                 "coin": "USDT",
        //                 "available": "19.1430952856087",
        //                 "frozen": "7",
        //                 "locked": "0",
        //                 "limitAvailable": "0",
        //                 "uTime": "1701931970487"
        //             },
        //         ],
        //         "ts": 1701931970487
        //     }
        //
        // swap
        //
        //     {
        //         "action": "snapshot",
        //         "arg": { "instType": "USDT-FUTURES", "channel": "account", "coin": "default" },
        //         "data": [
        //             {
        //                 "marginCoin": "USDT",
        //                 "frozen": "5.36581500",
        //                 "available": "26.14309528",
        //                 "maxOpenPosAvailable": "20.77728028",
        //                 "maxTransferOut": "20.77728028",
        //                 "equity": "26.14309528",
        //                 "usdtEquity": "26.143095285166"
        //             }
        //         ],
        //         "ts": 1701932570822
        //     }
        //
        // margin
        //
        //     {
        //         "action": "snapshot",
        //         "arg": { "instType": "MARGIN", "channel": "account-crossed", "coin": "default" },
        //         "data": [
        //             {
        //                 "uTime": "1701933110544",
        //                 "id": "1096916799926710272",
        //                 "coin": "USDT",
        //                 "available": "16.24309528",
        //                 "borrow": "0.00000000",
        //                 "frozen": "9.90000000",
        //                 "interest": "0.00000000",
        //                 "coupon": "0.00000000"
        //             }
        //         ],
        //         "ts": 1701933110544
        //     }
        //
        object data = this.safeValue(message, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object rawBalance = getValue(data, i);
            object currencyId = this.safeString2(rawBalance, "coin", "marginCoin");
            object code = this.safeCurrencyCode(currencyId);
            object account = ((bool) isTrue((inOp(this.balance, code)))) ? getValue(this.balance, code) : this.account();
            object borrow = this.safeString(rawBalance, "borrow");
            if (isTrue(!isEqual(borrow, null)))
            {
                object interest = this.safeString(rawBalance, "interest");
                ((IDictionary<string,object>)account)["debt"] = Precise.stringAdd(borrow, interest);
            }
            object freeQuery = ((bool) isTrue((inOp(rawBalance, "maxTransferOut")))) ? "maxTransferOut" : "available";
            ((IDictionary<string,object>)account)["free"] = this.safeString(rawBalance, freeQuery);
            ((IDictionary<string,object>)account)["total"] = this.safeString(rawBalance, "equity");
            ((IDictionary<string,object>)account)["used"] = this.safeString(rawBalance, "frozen");
            ((IDictionary<string,object>)this.balance)[(string)code] = account;
        }
        this.balance = this.safeBalance(this.balance);
        object arg = this.safeValue(message, "arg");
        object instType = this.safeStringLower(arg, "instType");
        object messageHash = add("balance:", instType);
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, messageHash});
    }

    public async virtual Task<object> watchPublic(object messageHash, object args, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "public");
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", new List<object>() {args} },
        };
        object message = this.extend(request, parameters);
        return await this.watch(url, messageHash, message, messageHash);
    }

    public async virtual Task<object> watchPublicMultiple(object messageHashes, object argsArray, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "public");
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", argsArray },
        };
        object message = this.extend(request, parameters);
        return await this.watchMultiple(url, messageHashes, message, messageHashes);
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        var client = this.client(url);
        object messageHash = "authenticated";
        var future = client.future(messageHash);
        object authenticated = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(authenticated, null)))
        {
            object timestamp = ((object)this.seconds()).ToString();
            object auth = add(add(timestamp, "GET"), "/user/verify");
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256, "base64");
            object operation = "login";
            object request = new Dictionary<string, object>() {
                { "op", operation },
                { "args", new List<object>() {new Dictionary<string, object>() {
    { "apiKey", this.apiKey },
    { "passphrase", this.password },
    { "timestamp", timestamp },
    { "sign", signature },
}} },
            };
            object message = this.extend(request, parameters);
            this.watch(url, messageHash, message, messageHash);
        }
        return await (future as Exchange.Future);
    }

    public async virtual Task<object> watchPrivate(object messageHash, object subscriptionHash, object args, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticate();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", new List<object>() {args} },
        };
        object message = this.extend(request, parameters);
        return await this.watch(url, messageHash, message, subscriptionHash);
    }

    public virtual void handleAuthenticate(WebSocketClient client, object message)
    {
        //
        //  { event: "login", code: 0 }
        //
        object messageHash = "authenticated";
        var future = this.safeValue((client as WebSocketClient).futures, messageHash);
        (future as Future).resolve(true);
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //    { event: "error", code: 30015, msg: "Invalid sign" }
        //
        object eventVar = this.safeString(message, "event");
        try
        {
            if (isTrue(isEqual(eventVar, "error")))
            {
                object code = this.safeString(message, "code");
                object feedback = add(add(this.id, " "), this.json(message));
                this.throwExactlyMatchedException(getValue(getValue(this.exceptions, "ws"), "exact"), code, feedback);
                object msg = this.safeString(message, "msg", "");
                this.throwBroadlyMatchedException(getValue(getValue(this.exceptions, "ws"), "broad"), msg, feedback);
                throw new ExchangeError ((string)feedback) ;
            }
            return false;
        } catch(Exception e)
        {
            if (isTrue(e is AuthenticationError))
            {
                object messageHash = "authenticated";
                ((WebSocketClient)client).reject(e, messageHash);
                if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
                {

                }
            } else
            {
                // Note: if error happens on a subscribe event, user will have to close exchange to resubscribe. Issue #19041
                ((WebSocketClient)client).reject(e);
            }
            return true;
        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        //
        //   {
        //       "action": "snapshot",
        //       "arg": { instType: 'SPOT', channel: "ticker", instId: "BTCUSDT" },
        //       "data": [
        //         {
        //           "instId": "BTCUSDT",
        //           "last": "21150.53",
        //           "open24h": "20759.65",
        //           "high24h": "21202.29",
        //           "low24h": "20518.82",
        //           "bestBid": "21150.500000",
        //           "bestAsk": "21150.600000",
        //           "baseVolume": "25402.1961",
        //           "quoteVolume": "530452554.2156",
        //           "ts": 1656408934044,
        //           "labeId": 0
        //         }
        //       ]
        //   }
        // pong message
        //    "pong"
        //
        // login
        //
        //     { event: "login", code: 0 }
        //
        // subscribe
        //
        //    {
        //        "event": "subscribe",
        //        "arg": { instType: 'SPOT', channel: "account", instId: "default" }
        //    }
        //
        if (isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            return;
        }
        object content = this.safeString(message, "message");
        if (isTrue(isEqual(content, "pong")))
        {
            this.handlePong(client as WebSocketClient, message);
            return;
        }
        if (isTrue(isEqual(message, "pong")))
        {
            this.handlePong(client as WebSocketClient, message);
            return;
        }
        object eventVar = this.safeString(message, "event");
        if (isTrue(isEqual(eventVar, "login")))
        {
            this.handleAuthenticate(client as WebSocketClient, message);
            return;
        }
        if (isTrue(isEqual(eventVar, "subscribe")))
        {
            this.handleSubscriptionStatus(client as WebSocketClient, message);
            return;
        }
        object methods = new Dictionary<string, object>() {
            { "ticker", this.handleTicker },
            { "trade", this.handleTrades },
            { "fill", this.handleMyTrades },
            { "orders", this.handleOrder },
            { "ordersAlgo", this.handleOrder },
            { "account", this.handleBalance },
            { "positions", this.handlePositions },
            { "account-isolated", this.handleBalance },
            { "account-crossed", this.handleBalance },
        };
        object arg = this.safeValue(message, "arg", new Dictionary<string, object>() {});
        object topic = this.safeValue(arg, "channel", "");
        object method = this.safeValue(methods, topic);
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(topic, "candle"), 0)))
        {
            this.handleOHLCV(client as WebSocketClient, message);
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(topic, "books"), 0)))
        {
            this.handleOrderBook(client as WebSocketClient, message);
        }
    }

    public override object ping(WebSocketClient client)
    {
        return "ping";
    }

    public virtual object handlePong(WebSocketClient client, object message)
    {
        client.lastPong = this.milliseconds();
        return message;
    }

    public virtual object handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //    {
        //        "event": "subscribe",
        //        "arg": { instType: 'SPOT', channel: "account", instId: "default" }
        //    }
        //
        return message;
    }
}
