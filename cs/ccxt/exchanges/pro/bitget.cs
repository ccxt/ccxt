namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class bitget { public bitget(object args = null) : base(args) { } }
public partial class bitget : ccxt.bitget
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "createOrderWs", false },
                { "editOrderWs", false },
                { "fetchOpenOrdersWs", false },
                { "fetchOrderWs", false },
                { "cancelOrderWs", false },
                { "cancelOrdersWs", false },
                { "cancelAllOrdersWs", false },
                { "watchBalance", true },
                { "watchMyTrades", true },
                { "watchOHLCV", true },
                { "watchOHLCVForSymbols", false },
                { "watchOrderBook", true },
                { "watchOrderBookForSymbols", true },
                { "watchOrders", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchBidsAsks", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
                { "watchPositions", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://ws.bitget.com/v2/ws/public" },
                        { "private", "wss://ws.bitget.com/v2/ws/private" },
                        { "utaPublic", "wss://ws.bitget.com/v3/ws/public" },
                        { "utaPrivate", "wss://ws.bitget.com/v3/ws/private" },
                    } },
                    { "demo", new Dictionary<string, object>() {
                        { "public", "wss://wspap.bitget.com/v2/ws/public" },
                        { "private", "wss://wspap.bitget.com/v2/ws/private" },
                        { "utaPublic", "wss://wspap.bitget.com/v3/ws/public" },
                        { "utaPrivate", "wss://wspap.bitget.com/v3/ws/private" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "tradesLimit", 1000 },
                { "OHLCVLimit", 1000 },
                { "timeframes", new Dictionary<string, object>() {
                    { "1m", "1m" },
                    { "3m", "3m" },
                    { "5m", "5m" },
                    { "15m", "15m" },
                    { "30m", "30m" },
                    { "1h", "1H" },
                    { "4h", "4H" },
                    { "6h", "6H" },
                    { "12h", "12H" },
                    { "1d", "1D" },
                    { "1w", "1W" },
                } },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "checksum", true },
                } },
                { "watchTrades", new Dictionary<string, object>() {
                    { "ignoreDuplicates", true },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "ping", this.ping },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "ws", new Dictionary<string, object>() {
                    { "exact", new Dictionary<string, object>() {
                        { "30001", typeof(BadRequest) },
                        { "30002", typeof(AuthenticationError) },
                        { "30003", typeof(BadRequest) },
                        { "30004", typeof(AuthenticationError) },
                        { "30005", typeof(AuthenticationError) },
                        { "30006", typeof(RateLimitExceeded) },
                        { "30007", typeof(RateLimitExceeded) },
                        { "30011", typeof(AuthenticationError) },
                        { "30012", typeof(AuthenticationError) },
                        { "30013", typeof(AuthenticationError) },
                        { "30014", typeof(BadRequest) },
                        { "30015", typeof(AuthenticationError) },
                        { "30016", typeof(BadRequest) },
                    } },
                    { "broad", new Dictionary<string, object>() {} },
                } },
            } },
        });
    }

    public virtual object getInstType(object market, object uta = null, object parameters = null)
    {
        uta ??= false;
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isTrue((isEqual(uta, null))) || !isTrue(uta)))
        {
            var utaparametersVariable = this.handleOptionAndParams(parameters, "getInstType", "uta", false);
            uta = ((IList<object>)utaparametersVariable)[0];
            parameters = ((IList<object>)utaparametersVariable)[1];
        }
        object instType = null;
        if (isTrue(isEqual(market, null)))
        {
            var instTypeparametersVariable = this.handleProductTypeAndParams(null, parameters);
            instType = ((IList<object>)instTypeparametersVariable)[0];
            parameters = ((IList<object>)instTypeparametersVariable)[1];
        } else if (isTrue(isTrue((getValue(market, "swap"))) || isTrue((getValue(market, "future")))))
        {
            var instTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            instType = ((IList<object>)instTypeparametersVariable)[0];
            parameters = ((IList<object>)instTypeparametersVariable)[1];
        } else
        {
            instType = "SPOT";
        }
        object instypeAux = null;
        var instypeAuxparametersVariable = this.handleOptionAndParams(parameters, "getInstType", "instType", instType);
        instypeAux = ((IList<object>)instypeAuxparametersVariable)[0];
        parameters = ((IList<object>)instypeAuxparametersVariable)[1];
        instType = instypeAux;
        if (isTrue(uta))
        {
            instType = ((string)instType).ToLower();
        }
        return new List<object>() {instType, parameters};
    }

    /**
     * @method
     * @name bitget#watchTicker
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://www.bitget.com/api-doc/spot/websocket/public/Tickers-Channel
     * @see https://www.bitget.com/api-doc/contract/websocket/public/Tickers-Channel
     * @see https://www.bitget.com/api-doc/uta/websocket/public/Tickers-Channel
     * @param {string} symbol unified symbol of the market to watch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object messageHash = add("ticker:", symbol);
        object instType = null;
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "watchTicker", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        var instTypeparametersVariable = this.getInstType(market, uta, parameters);
        instType = ((IList<object>)instTypeparametersVariable)[0];
        parameters = ((IList<object>)instTypeparametersVariable)[1];
        object args = new Dictionary<string, object>() {
            { "instType", instType },
        };
        object topicOrChannel = ((bool) isTrue(uta)) ? "topic" : "channel";
        object symbolOrInstId = ((bool) isTrue(uta)) ? "symbol" : "instId";
        ((IDictionary<string,object>)args)[(string)topicOrChannel] = "ticker";
        ((IDictionary<string,object>)args)[(string)symbolOrInstId] = getValue(market, "id");
        return await this.watchPublic(messageHash, args, parameters);
    }

    /**
     * @method
     * @name bitget#unWatchTicker
     * @description unsubscribe from the ticker channel
     * @see https://www.bitget.com/api-doc/spot/websocket/public/Tickers-Channel
     * @see https://www.bitget.com/api-doc/contract/websocket/public/Tickers-Channel
     * @param {string} symbol unified symbol of the market to unwatch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {any} status of the unwatch request
     */
    public async override Task<object> unWatchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        return await this.unWatchChannel(symbol, "ticker", "ticker", parameters);
    }

    /**
     * @method
     * @name bitget#watchTickers
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
     * @see https://www.bitget.com/api-doc/spot/websocket/public/Tickers-Channel
     * @see https://www.bitget.com/api-doc/contract/websocket/public/Tickers-Channel
     * @see https://www.bitget.com/api-doc/uta/websocket/public/Tickers-Channel
     * @param {string[]} symbols unified symbol of the market to watch the tickers for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object market = this.market(getValue(symbols, 0));
        object instType = null;
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "watchTickers", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        var instTypeparametersVariable = this.getInstType(market, uta, parameters);
        instType = ((IList<object>)instTypeparametersVariable)[0];
        parameters = ((IList<object>)instTypeparametersVariable)[1];
        object topics = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object marketInner = this.market(symbol);
            object args = new Dictionary<string, object>() {
                { "instType", instType },
            };
            object topicOrChannel = ((bool) isTrue(uta)) ? "topic" : "channel";
            object symbolOrInstId = ((bool) isTrue(uta)) ? "symbol" : "instId";
            ((IDictionary<string,object>)args)[(string)topicOrChannel] = "ticker";
            ((IDictionary<string,object>)args)[(string)symbolOrInstId] = getValue(marketInner, "id");
            ((IList<object>)topics).Add(args);
            ((IList<object>)messageHashes).Add(add("ticker:", symbol));
        }
        object tickers = await this.watchPublicMultiple(messageHashes, topics, parameters);
        if (isTrue(this.newUpdates))
        {
            object result = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)result)[(string)getValue(tickers, "symbol")] = tickers;
            return result;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        // default
        //
        //     {
        //         "action": "snapshot",
        //         "arg": {
        //             "instType": "SPOT",
        //             "channel": "ticker",
        //             "instId": "BTCUSDT"
        //         },
        //         "data": [
        //             {
        //                 "instId": "BTCUSDT",
        //                 "lastPr": "43528.19",
        //                 "open24h": "42267.78",
        //                 "high24h": "44490.00",
        //                 "low24h": "41401.53",
        //                 "change24h": "0.03879",
        //                 "bidPr": "43528",
        //                 "askPr": "43528.01",
        //                 "bidSz": "0.0334",
        //                 "askSz": "0.1917",
        //                 "baseVolume": "15002.4216",
        //                 "quoteVolume": "648006446.7164",
        //                 "openUtc": "44071.18",
        //                 "changeUtc24h": "-0.01232",
        //                 "ts": "1701842994338"
        //             }
        //         ],
        //         "ts": 1701842994341
        //     }
        //
        // uta
        //
        //     {
        //         "action": "snapshot",
        //         "arg": { "instType": "spot", topic: "ticker", symbol: "BTCUSDT" },
        //         "data": [
        //             {
        //                 "highPrice24h": "120255.61",
        //                 "lowPrice24h": "116145.88",
        //                 "openPrice24h": "118919.38",
        //                 "lastPrice": "119818.83",
        //                 "turnover24h": "215859996.272276",
        //                 "volume24h": "1819.756798",
        //                 "bid1Price": "119811.26",
        //                 "ask1Price": "119831.18",
        //                 "bid1Size": "0.008732",
        //                 "ask1Size": "0.004297",
        //                 "price24hPcnt": "0.02002"
        //             }
        //         ],
        //         "ts": 1753230479687
        //     }
        //
        this.handleBidAsk(client as WebSocketClient, message);
        object ticker = this.parseWsTicker(message);
        object symbol = getValue(ticker, "symbol");
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
        object messageHash = add("ticker:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
    }

    public virtual object parseWsTicker(object message, object market = null)
    {
        //
        // spot
        //
        //     {
        //         "action": "snapshot",
        //         "arg": {
        //             "instType": "SPOT",
        //             "channel": "ticker",
        //             "instId": "BTCUSDT"
        //         },
        //         "data": [
        //             {
        //                 "instId": "BTCUSDT",
        //                 "lastPr": "43528.19",
        //                 "open24h": "42267.78",
        //                 "high24h": "44490.00",
        //                 "low24h": "41401.53",
        //                 "change24h": "0.03879",
        //                 "bidPr": "43528",
        //                 "askPr": "43528.01",
        //                 "bidSz": "0.0334",
        //                 "askSz": "0.1917",
        //                 "baseVolume": "15002.4216",
        //                 "quoteVolume": "648006446.7164",
        //                 "openUtc": "44071.18",
        //                 "changeUtc24h": "-0.01232",
        //                 "ts": "1701842994338"
        //             }
        //         ],
        //         "ts": 1701842994341
        //     }
        //
        // contract
        //
        //     {
        //         "action": "snapshot",
        //         "arg": {
        //             "instType": "USDT-FUTURES",
        //             "channel": "ticker",
        //             "instId": "BTCUSDT"
        //         },
        //         "data": [
        //             {
        //                 "instId": "BTCUSDT",
        //                 "lastPr": "43480.4",
        //                 "bidPr": "43476.3",
        //                 "askPr": "43476.8",
        //                 "bidSz": "0.1",
        //                 "askSz": "3.055",
        //                 "open24h": "42252.3",
        //                 "high24h": "44518.2",
        //                 "low24h": "41387.0",
        //                 "change24h": "0.03875",
        //                 "fundingRate": "0.000096",
        //                 "nextFundingTime": "1701849600000",
        //                 "markPrice": "43476.4",
        //                 "indexPrice": "43478.4",
        //                 "holdingAmount": "50670.787",
        //                 "baseVolume": "120187.104",
        //                 "quoteVolume": "5167385048.693",
        //                 "openUtc": "44071.4",
        //                 "symbolType": "1",
        //                 "symbol": "BTCUSDT",
        //                 "deliveryPrice": "0",
        //                 "ts": "1701843962811"
        //             }
        //         ],
        //         "ts": 1701843962812
        //     }
        //
        // uta
        //
        //     {
        //         "action": "snapshot",
        //         "arg": { "instType": "spot", topic: "ticker", symbol: "BTCUSDT" },
        //         "data": [
        //             {
        //                 "highPrice24h": "120255.61",
        //                 "lowPrice24h": "116145.88",
        //                 "openPrice24h": "118919.38",
        //                 "lastPrice": "119818.83",
        //                 "turnover24h": "215859996.272276",
        //                 "volume24h": "1819.756798",
        //                 "bid1Price": "119811.26",
        //                 "ask1Price": "119831.18",
        //                 "bid1Size": "0.008732",
        //                 "ask1Size": "0.004297",
        //                 "price24hPcnt": "0.02002"
        //             }
        //         ],
        //         "ts": 1753230479687
        //     }
        //
        object arg = this.safeValue(message, "arg", new Dictionary<string, object>() {});
        object data = this.safeValue(message, "data", new List<object>() {});
        object ticker = this.safeValue(data, 0, new Dictionary<string, object>() {});
        object utaTimestamp = this.safeInteger(message, "ts");
        object timestamp = this.safeInteger(ticker, "ts", utaTimestamp);
        object instType = this.safeStringLower(arg, "instType");
        object marketType = ((bool) isTrue((isEqual(instType, "spot")))) ? "spot" : "contract";
        object utaMarketId = this.safeString(arg, "symbol");
        object marketId = this.safeString(ticker, "instId", utaMarketId);
        market = this.safeMarket(marketId, market, null, marketType);
        object close = this.safeString2(ticker, "lastPr", "lastPrice");
        object changeDecimal = this.safeString(ticker, "change24h", "");
        object change = this.safeString(ticker, "price24hPcnt", Precise.stringMul(changeDecimal, "100"));
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString2(ticker, "high24h", "highPrice24h") },
            { "low", this.safeString2(ticker, "low24h", "lowPrice24h") },
            { "bid", this.safeString2(ticker, "bidPr", "bid1Price") },
            { "bidVolume", this.safeString2(ticker, "bidSz", "bid1Size") },
            { "ask", this.safeString2(ticker, "askPr", "ask1Price") },
            { "askVolume", this.safeString2(ticker, "askSz", "ask1Size") },
            { "vwap", null },
            { "open", this.safeString2(ticker, "open24h", "openPrice24h") },
            { "close", close },
            { "last", close },
            { "previousClose", null },
            { "change", null },
            { "percentage", change },
            { "average", null },
            { "baseVolume", this.safeString2(ticker, "baseVolume", "volume24h") },
            { "quoteVolume", this.safeString2(ticker, "quoteVolume", "turnover24h") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name bitget#watchBidsAsks
     * @description watches best bid & ask for symbols
     * @see https://www.bitget.com/api-doc/spot/websocket/public/Tickers-Channel
     * @see https://www.bitget.com/api-doc/contract/websocket/public/Tickers-Channel
     * @see https://www.bitget.com/api-doc/uta/websocket/public/Tickers-Channel
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchBidsAsks(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object market = this.market(getValue(symbols, 0));
        object instType = null;
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "watchBidsAsks", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        var instTypeparametersVariable = this.getInstType(market, uta, parameters);
        instType = ((IList<object>)instTypeparametersVariable)[0];
        parameters = ((IList<object>)instTypeparametersVariable)[1];
        object topics = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object marketInner = this.market(symbol);
            object args = new Dictionary<string, object>() {
                { "instType", instType },
            };
            object topicOrChannel = ((bool) isTrue(uta)) ? "topic" : "channel";
            object symbolOrInstId = ((bool) isTrue(uta)) ? "symbol" : "instId";
            ((IDictionary<string,object>)args)[(string)topicOrChannel] = "ticker";
            ((IDictionary<string,object>)args)[(string)symbolOrInstId] = getValue(marketInner, "id");
            ((IList<object>)topics).Add(args);
            ((IList<object>)messageHashes).Add(add("bidask:", symbol));
        }
        object tickers = await this.watchPublicMultiple(messageHashes, topics, parameters);
        if (isTrue(this.newUpdates))
        {
            object result = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)result)[(string)getValue(tickers, "symbol")] = tickers;
            return result;
        }
        return this.filterByArray(this.bidsasks, "symbol", symbols);
    }

    public virtual void handleBidAsk(WebSocketClient client, object message)
    {
        object ticker = this.parseWsBidAsk(message);
        object symbol = getValue(ticker, "symbol");
        ((IDictionary<string,object>)this.bidsasks)[(string)symbol] = ticker;
        object messageHash = add("bidask:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
    }

    public virtual object parseWsBidAsk(object message, object market = null)
    {
        object arg = this.safeValue(message, "arg", new Dictionary<string, object>() {});
        object data = this.safeValue(message, "data", new List<object>() {});
        object ticker = this.safeValue(data, 0, new Dictionary<string, object>() {});
        object utaTimestamp = this.safeInteger(message, "ts");
        object timestamp = this.safeInteger(ticker, "ts", utaTimestamp);
        object instType = this.safeStringLower(arg, "instType");
        object marketType = ((bool) isTrue((isEqual(instType, "spot")))) ? "spot" : "contract";
        object utaMarketId = this.safeString(arg, "symbol");
        object marketId = this.safeString(ticker, "instId", utaMarketId);
        market = this.safeMarket(marketId, market, null, marketType);
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "ask", this.safeString2(ticker, "askPr", "ask1Price") },
            { "askVolume", this.safeString2(ticker, "askSz", "ask1Size") },
            { "bid", this.safeString2(ticker, "bidPr", "bid1Price") },
            { "bidVolume", this.safeString2(ticker, "bidSz", "bid1Size") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name bitget#watchOHLCV
     * @description watches historical candlestick data containing the open, high, low, close price, and the volume of a market
     * @see https://www.bitget.com/api-doc/spot/websocket/public/Candlesticks-Channel
     * @see https://www.bitget.com/api-doc/contract/websocket/public/Candlesticks-Channel
     * @see https://www.bitget.com/api-doc/uta/websocket/public/Candlesticks-Channel
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object timeframes = this.safeValue(this.options, "timeframes");
        object interval = this.safeString(timeframes, timeframe);
        object messageHash = null;
        object instType = null;
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "watchOHLCV", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        var instTypeparametersVariable = this.getInstType(market, uta, parameters);
        instType = ((IList<object>)instTypeparametersVariable)[0];
        parameters = ((IList<object>)instTypeparametersVariable)[1];
        object args = new Dictionary<string, object>() {
            { "instType", instType },
        };
        if (isTrue(uta))
        {
            ((IDictionary<string,object>)args)["topic"] = "kline";
            ((IDictionary<string,object>)args)["symbol"] = getValue(market, "id");
            ((IDictionary<string,object>)args)["interval"] = interval;
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "uta", true },
            });
            messageHash = add("kline:", symbol);
        } else
        {
            ((IDictionary<string,object>)args)["channel"] = add("candle", interval);
            ((IDictionary<string,object>)args)["instId"] = getValue(market, "id");
            messageHash = add(add(add("candles:", timeframe), ":"), symbol);
        }
        object ohlcv = await this.watchPublic(messageHash, args, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    /**
     * @method
     * @name bitget#unWatchOHLCV
     * @description unsubscribe from the ohlcv channel
     * @see https://www.bitget.com/api-doc/spot/websocket/public/Candlesticks-Channel
     * @see https://www.bitget.com/api-doc/contract/websocket/public/Candlesticks-Channel
     * @see https://www.bitget.com/api-doc/uta/websocket/public/Candlesticks-Channel
     * @param {string} symbol unified symbol of the market to unwatch the ohlcv for
     * @param {string} [timeframe] the period for the ratio, default is 1 minute
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async virtual Task<object> unWatchOHLCV(object symbol, object timeframe = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object timeframes = this.safeDict(this.options, "timeframes");
        object interval = this.safeString(timeframes, timeframe);
        object channel = null;
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object instType = null;
        object messageHash = null;
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "unWatchOHLCV", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        var instTypeparametersVariable = this.getInstType(market, uta, parameters);
        instType = ((IList<object>)instTypeparametersVariable)[0];
        parameters = ((IList<object>)instTypeparametersVariable)[1];
        object args = new Dictionary<string, object>() {
            { "instType", instType },
        };
        if (isTrue(uta))
        {
            channel = "kline";
            ((IDictionary<string,object>)args)["topic"] = channel;
            ((IDictionary<string,object>)args)["symbol"] = getValue(market, "id");
            ((IDictionary<string,object>)args)["interval"] = interval;
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "uta", true },
            });
            ((IDictionary<string,object>)parameters)["interval"] = interval;
            messageHash = add(channel, symbol);
        } else
        {
            channel = add("candle", interval);
            ((IDictionary<string,object>)args)["channel"] = channel;
            ((IDictionary<string,object>)args)["instId"] = getValue(market, "id");
            messageHash = add("candles:", interval);
        }
        return await this.unWatchChannel(symbol, channel, messageHash, parameters);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "action": "snapshot",
        //         "arg": {
        //             "instType": "SPOT",
        //             "channel": "candle1m",
        //             "instId": "BTCUSDT"
        //         },
        //         "data": [
        //             [
        //                 "1701871620000",
        //                 "44080.23",
        //                 "44080.23",
        //                 "44028.5",
        //                 "44028.51",
        //                 "9.9287",
        //                 "437404.105512",
        //                 "437404.105512"
        //             ],
        //             [
        //                 "1701871680000",
        //                 "44028.51",
        //                 "44108.11",
        //                 "44028.5",
        //                 "44108.11",
        //                 "17.139",
        //                 "755436.870643",
        //                 "755436.870643"
        //             ],
        //         ],
        //         "ts": 1701901610417
        //     }
        //
        // uta
        //
        //     {
        //         "action": "snapshot",
        //         "arg": {
        //             "instType": "usdt-futures",
        //             "topic": "kline",
        //             "symbol": "BTCUSDT",
        //             "interval": "1m"
        //         },
        //         "data": [
        //             {
        //                 "start": "1755564480000",
        //                 "open": "116286",
        //                 "close": "116256.2",
        //                 "high": "116310.2",
        //                 "low": "116232.8",
        //                 "volume": "39.7062",
        //                 "turnover": "4616746.46654"
        //             },
        //         ],
        //         "ts": 1755594421877
        //     }
        //
        object arg = this.safeValue(message, "arg", new Dictionary<string, object>() {});
        object instType = this.safeStringLower(arg, "instType");
        object marketType = ((bool) isTrue((isEqual(instType, "spot")))) ? "spot" : "contract";
        object marketId = this.safeString2(arg, "instId", "symbol");
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        object channel = this.safeString2(arg, "channel", "topic");
        object interval = this.safeString(arg, "interval");
        object isUta = null;
        if (isTrue(isEqual(interval, null)))
        {
            isUta = false;
            interval = ((string)channel).Replace((string)"candle", (string)"");
        } else
        {
            isUta = true;
        }
        object timeframes = this.safeValue(this.options, "timeframes");
        object timeframe = this.findTimeframe(interval, timeframes);
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
        }
        object data = this.safeValue(message, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object parsed = this.parseWsOHLCV(getValue(data, i), market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        object messageHash = null;
        if (isTrue(isUta))
        {
            messageHash = add("kline:", symbol);
        } else
        {
            messageHash = add(add(add("candles:", timeframe), ":"), symbol);
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public override object parseWsOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         "1701871620000",  // timestamp
        //         "44080.23", // open
        //         "44080.23", // high
        //         "44028.5", // low
        //         "44028.51", // close
        //         "9.9287", // base volume
        //         "437404.105512", // quote volume
        //         "437404.105512" // USDT volume
        //     ]
        //
        // uta
        //
        //     {
        //         "start": "1755564480000",
        //         "open": "116286",
        //         "close": "116256.2",
        //         "high": "116310.2",
        //         "low": "116232.8",
        //         "volume": "39.7062",
        //         "turnover": "4616746.46654"
        //     }
        //
        object volumeIndex = ((bool) isTrue((getValue(market, "inverse")))) ? 6 : 5;
        return new List<object> {this.safeInteger2(ohlcv, "start", 0), this.safeNumber2(ohlcv, "open", 1), this.safeNumber2(ohlcv, "high", 2), this.safeNumber2(ohlcv, "low", 3), this.safeNumber2(ohlcv, "close", 4), this.safeNumber2(ohlcv, "volume", volumeIndex)};
    }

    /**
     * @method
     * @name bitget#watchOrderBook
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://www.bitget.com/api-doc/spot/websocket/public/Depth-Channel
     * @see https://www.bitget.com/api-doc/contract/websocket/public/Order-Book-Channel
     * @see https://www.bitget.com/api-doc/uta/websocket/public/Order-Book-Channel
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.watchOrderBookForSymbols(new List<object>() {symbol}, limit, parameters);
    }

    /**
     * @method
     * @name bitget#unWatchOrderBook
     * @description unsubscribe from the orderbook channel
     * @see https://www.bitget.com/api-doc/spot/websocket/public/Depth-Channel
     * @see https://www.bitget.com/api-doc/contract/websocket/public/Order-Book-Channel
     * @see https://www.bitget.com/api-doc/uta/websocket/public/Order-Book-Channel
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.limit] orderbook limit, default is undefined
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> unWatchOrderBook(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object channel = "books";
        object limit = this.safeInteger(parameters, "limit");
        if (isTrue(isTrue(isTrue(isTrue((isEqual(limit, 1))) || isTrue((isEqual(limit, 5)))) || isTrue((isEqual(limit, 15)))) || isTrue((isEqual(limit, 50)))))
        {
            parameters = this.omit(parameters, "limit");
            channel = add(channel, ((object)limit).ToString());
        }
        return await this.unWatchChannel(symbol, channel, "orderbook", parameters);
    }

    public async virtual Task<object> unWatchChannel(object symbol, object channel, object messageHashTopic, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object messageHash = add(add(add("unsubscribe:", messageHashTopic), ":"), getValue(market, "symbol"));
        object instType = null;
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "unWatchChannel", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        var instTypeparametersVariable = this.getInstType(market, uta, parameters);
        instType = ((IList<object>)instTypeparametersVariable)[0];
        parameters = ((IList<object>)instTypeparametersVariable)[1];
        object args = new Dictionary<string, object>() {
            { "instType", instType },
        };
        if (isTrue(uta))
        {
            ((IDictionary<string,object>)args)["topic"] = channel;
            ((IDictionary<string,object>)args)["symbol"] = getValue(market, "id");
            ((IDictionary<string,object>)args)["interval"] = this.safeString(parameters, "interval", "1m");
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "uta", true },
            });
            parameters = this.omit(parameters, "interval");
        } else
        {
            ((IDictionary<string,object>)args)["channel"] = channel;
            ((IDictionary<string,object>)args)["instId"] = getValue(market, "id");
        }
        return await this.unWatchPublic(messageHash, args, parameters);
    }

    /**
     * @method
     * @name bitget#watchOrderBookForSymbols
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://www.bitget.com/api-doc/spot/websocket/public/Depth-Channel
     * @see https://www.bitget.com/api-doc/contract/websocket/public/Order-Book-Channel
     * @see https://www.bitget.com/api-doc/uta/websocket/public/Order-Book-Channel
     * @param {string[]} symbols unified array of symbols
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object channel = "books";
        object incrementalFeed = true;
        if (isTrue(isTrue(isTrue(isTrue((isEqual(limit, 1))) || isTrue((isEqual(limit, 5)))) || isTrue((isEqual(limit, 15)))) || isTrue((isEqual(limit, 50)))))
        {
            channel = add(channel, ((object)limit).ToString());
            incrementalFeed = false;
        }
        object topics = new List<object>() {};
        object messageHashes = new List<object>() {};
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "watchOrderBookForSymbols", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = this.market(symbol);
            object instType = null;
            var instTypeparametersVariable = this.getInstType(market, uta, parameters);
            instType = ((IList<object>)instTypeparametersVariable)[0];
            parameters = ((IList<object>)instTypeparametersVariable)[1];
            object args = new Dictionary<string, object>() {
                { "instType", instType },
            };
            object topicOrChannel = ((bool) isTrue(uta)) ? "topic" : "channel";
            object symbolOrInstId = ((bool) isTrue(uta)) ? "symbol" : "instId";
            ((IDictionary<string,object>)args)[(string)topicOrChannel] = channel;
            ((IDictionary<string,object>)args)[(string)symbolOrInstId] = getValue(market, "id");
            ((IList<object>)topics).Add(args);
            ((IList<object>)messageHashes).Add(add("orderbook:", symbol));
        }
        if (isTrue(uta))
        {
            ((IDictionary<string,object>)parameters)["uta"] = true;
        }
        object orderbook = await this.watchPublicMultiple(messageHashes, topics, parameters);
        if (isTrue(incrementalFeed))
        {
            return (orderbook as IOrderBook).limit();
        } else
        {
            return orderbook;
        }
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //   {
        //       "action":"snapshot",
        //       "arg":{
        //          "instType":"SPOT",
        //          "channel":"books5",
        //          "instId":"BTCUSDT"
        //       },
        //       "data":[
        //          {
        //             "asks":[
        //                ["21041.11","0.0445"],
        //                ["21041.16","0.0411"],
        //                ["21041.21","0.0421"],
        //                ["21041.26","0.0811"],
        //                ["21041.65","1.9465"]
        //             ],
        //             "bids":[
        //                ["21040.76","0.0417"],
        //                ["21040.71","0.0434"],
        //                ["21040.66","0.1141"],
        //                ["21040.61","0.3004"],
        //                ["21040.60","1.3357"]
        //             ],
        //             "checksum": -1367582038,
        //             "ts":"1656413855484"
        //          }
        //       ]
        //   }
        //
        // {
        //     "action": "snapshot",
        //     "arg": { "instType": "usdt-futures", "topic": "books", "symbol": "BTCUSDT" },
        //     "data": [
        //         {
        //             "a": [Array],
        //             "b": [Array],
        //             "checksum": 0,
        //             "pseq": 0,
        //             "seq": "1343064377779269632",
        //             "ts": "1755937421270"
        //         }
        //     ],
        //     "ts": 1755937421337
        // }
        //
        object arg = this.safeValue(message, "arg");
        object channel = this.safeString2(arg, "channel", "topic");
        object instType = this.safeStringLower(arg, "instType");
        object marketType = ((bool) isTrue((isEqual(instType, "spot")))) ? "spot" : "contract";
        object marketId = this.safeString2(arg, "instId", "symbol");
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        object messageHash = add("orderbook:", symbol);
        object data = this.safeValue(message, "data");
        object rawOrderBook = this.safeValue(data, 0);
        object timestamp = this.safeInteger(rawOrderBook, "ts");
        object incrementalBook = isEqual(channel, "books");
        if (isTrue(incrementalBook))
        {
            // storedOrderBook = this.safeValue (this.orderbooks, symbol);
            if (!isTrue((inOp(this.orderbooks, symbol))))
            {
                // const ob = this.orderBook ({});
                object ob = this.countedOrderBook(new Dictionary<string, object>() {});
                ((IDictionary<string,object>)ob)["symbol"] = symbol;
                ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = ob;
            }
            object storedOrderBook = getValue(this.orderbooks, symbol);
            object asks = this.safeList2(rawOrderBook, "asks", "a", new List<object>() {});
            object bids = this.safeList2(rawOrderBook, "bids", "b", new List<object>() {});
            this.handleDeltas(getValue(storedOrderBook, "asks"), asks);
            this.handleDeltas(getValue(storedOrderBook, "bids"), bids);
            ((IDictionary<string,object>)storedOrderBook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)storedOrderBook)["datetime"] = this.iso8601(timestamp);
            object checksum = this.handleOption("watchOrderBook", "checksum", true);
            object isSnapshot = isEqual(this.safeString(message, "action"), "snapshot"); // snapshot does not have a checksum
            if (isTrue(!isTrue(isSnapshot) && isTrue(checksum)))
            {
                object storedAsks = getValue(storedOrderBook, "asks");
                object storedBids = getValue(storedOrderBook, "bids");
                object asksLength = getArrayLength(storedAsks);
                object bidsLength = getArrayLength(storedBids);
                object payloadArray = new List<object>() {};
                for (object i = 0; isLessThan(i, 25); postFixIncrement(ref i))
                {
                    if (isTrue(isLessThan(i, bidsLength)))
                    {
                        ((IList<object>)payloadArray).Add(getValue(getValue(getValue(storedBids, i), 2), 0));
                        ((IList<object>)payloadArray).Add(getValue(getValue(getValue(storedBids, i), 2), 1));
                    }
                    if (isTrue(isLessThan(i, asksLength)))
                    {
                        ((IList<object>)payloadArray).Add(getValue(getValue(getValue(storedAsks, i), 2), 0));
                        ((IList<object>)payloadArray).Add(getValue(getValue(getValue(storedAsks, i), 2), 1));
                    }
                }
                object payload = String.Join(":", ((IList<object>)payloadArray).ToArray());
                object calculatedChecksum = this.crc32(payload, true);
                object responseChecksum = this.safeInteger(rawOrderBook, "checksum");
                if (isTrue(!isEqual(calculatedChecksum, responseChecksum)))
                {
                    // if (messageHash in ((WebSocketClient)client).subscriptions) {
                    //     // delete ((WebSocketClient)client).subscriptions[messageHash];
                    //     // delete this.orderbooks[symbol];
                    // }
                    this.spawn(this.handleCheckSumError, new object[] { client, symbol, messageHash});
                    return;
                }
            }
        } else
        {
            object orderbook = this.orderBook(new Dictionary<string, object>() {});
            object parsedOrderbook = this.parseOrderBook(rawOrderBook, symbol, timestamp);
            (orderbook as IOrderBook).reset(parsedOrderbook);
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.orderbooks, symbol), messageHash});
    }

    public async virtual Task handleCheckSumError(WebSocketClient client, object symbol, object messageHash)
    {
        await this.unWatchOrderBook(symbol);
        var error = new ChecksumError(add(add(this.id, " "), this.orderbookChecksumMessage(symbol)));
        ((WebSocketClient)client).reject(error, messageHash);
    }

    public override void handleDelta(object bookside, object delta)
    {
        object bidAsk = this.parseBidAsk(delta, 0, 1);
        // we store the string representations in the orderbook for checksum calculation
        // this simplifies the code for generating checksums as we do not need to do any complex number transformations
        ((IList<object>)bidAsk).Add(delta);
        (bookside as IOrderBookSide).storeArray(bidAsk);
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    /**
     * @method
     * @name bitget#watchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://www.bitget.com/api-doc/spot/websocket/public/Trades-Channel
     * @see https://www.bitget.com/api-doc/contract/websocket/public/New-Trades-Channel
     * @see https://www.bitget.com/api-doc/uta/websocket/public/New-Trades-Channel
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    /**
     * @method
     * @name bitget#watchTradesForSymbols
     * @description get the list of most recent trades for a particular symbol
     * @see https://www.bitget.com/api-doc/spot/websocket/public/Trades-Channel
     * @see https://www.bitget.com/api-doc/contract/websocket/public/New-Trades-Channel
     * @see https://www.bitget.com/api-doc/uta/websocket/public/New-Trades-Channel
     * @param {string[]} symbols unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object symbolsLength = getArrayLength(symbols);
        if (isTrue(isEqual(symbolsLength, 0)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchTradesForSymbols() requires a non-empty array of symbols")) ;
        }
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "watchTradesForSymbols", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        object topics = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = this.market(symbol);
            object instType = null;
            var instTypeparametersVariable = this.getInstType(market, uta, parameters);
            instType = ((IList<object>)instTypeparametersVariable)[0];
            parameters = ((IList<object>)instTypeparametersVariable)[1];
            object args = new Dictionary<string, object>() {
                { "instType", instType },
            };
            object topicOrChannel = ((bool) isTrue(uta)) ? "topic" : "channel";
            object symbolOrInstId = ((bool) isTrue(uta)) ? "symbol" : "instId";
            ((IDictionary<string,object>)args)[(string)topicOrChannel] = ((bool) isTrue(uta)) ? "publicTrade" : "trade";
            ((IDictionary<string,object>)args)[(string)symbolOrInstId] = getValue(market, "id");
            ((IList<object>)topics).Add(args);
            ((IList<object>)messageHashes).Add(add("trade:", symbol));
        }
        if (isTrue(uta))
        {
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "uta", true },
            });
        }
        object trades = await this.watchPublicMultiple(messageHashes, topics, parameters);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeValue(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        object result = this.filterBySinceLimit(trades, since, limit, "timestamp", true);
        if (isTrue(this.handleOption("watchTrades", "ignoreDuplicates", true)))
        {
            object filtered = this.removeRepeatedTradesFromArray(result);
            filtered = this.sortBy(filtered, "timestamp");
            return filtered;
        }
        return result;
    }

    /**
     * @method
     * @name bitget#unWatchTrades
     * @description unsubscribe from the trades channel
     * @see https://www.bitget.com/api-doc/spot/websocket/public/Trades-Channel
     * @see https://www.bitget.com/api-doc/contract/websocket/public/New-Trades-Channel
     * @see https://www.bitget.com/api-doc/uta/websocket/public/New-Trades-Channel
     * @param {string} symbol unified symbol of the market to unwatch the trades for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {any} status of the unwatch request
     */
    public async override Task<object> unWatchTrades(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "unWatchTrades", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        object channelTopic = ((bool) isTrue(uta)) ? "publicTrade" : "trade";
        return await this.unWatchChannel(symbol, channelTopic, "trade", parameters);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //         "action": "snapshot",
        //         "arg": { "instType": "SPOT", "channel": "trade", "instId": "BTCUSDT" },
        //         "data": [
        //             {
        //                 "ts": "1701910980366",
        //                 "price": "43854.01",
        //                 "size": "0.0535",
        //                 "side": "buy",
        //                 "tradeId": "1116461060594286593"
        //             },
        //         ],
        //         "ts": 1701910980730
        //     }
        //
        // uta
        //
        //     {
        //         "action": "snapshot",
        //         "arg": { "instType": "spot", "topic": "publicTrade", "symbol": "BTCUSDT" },
        //         "data": [
        //             {
        //                 "T": "1756287827920",
        //                 "P": "110878.5",
        //                 "v": "0.07",
        //                 "S": "buy",
        //                 "L": "1344534089797185550"
        //                 "i": "1344534089797185549"
        //             },
        //         ],
        //         "ts": 1701910980730
        //     }
        //
        object arg = this.safeValue(message, "arg", new Dictionary<string, object>() {});
        object instType = this.safeStringLower(arg, "instType");
        object marketType = ((bool) isTrue((isEqual(instType, "spot")))) ? "spot" : "contract";
        object marketId = this.safeString2(arg, "instId", "symbol");
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        object stored = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        object data = this.safeList(message, "data", new List<object>() {});
        object length = getArrayLength(data);
        // fix chronological order by reversing
        for (object i = 0; isLessThan(i, length); postFixIncrement(ref i))
        {
            object index = subtract(subtract(length, i), 1);
            object rawTrade = getValue(data, index);
            object parsed = this.parseWsTrade(rawTrade, market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        object messageHash = add("trade:", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        //     {
        //         "ts": "1701910980366",
        //         "price": "43854.01",
        //         "size": "0.0535",
        //         "side": "buy",
        //         "tradeId": "1116461060594286593"
        //     }
        // swap private
        //
        //            {
        //               "orderId": "1169142761031114781",
        //               "tradeId": "1169142761312637004",
        //               "symbol": "LTCUSDT",
        //               "orderType": "market",
        //               "side": "buy",
        //               "price": "80.87",
        //               "baseVolume": "0.1",
        //               "quoteVolume": "8.087",
        //               "profit": "0",
        //               "tradeSide": "open",
        //               "posMode": "hedge_mode",
        //               "tradeScope": "taker",
        //               "feeDetail": [
        //                  {
        //                     "feeCoin": "USDT",
        //                     "deduction": "no",
        //                     "totalDeductionFee": "0",
        //                     "totalFee": "-0.0048522"
        //                  }
        //               ],
        //               "cTime": "1714471276596",
        //               "uTime": "1714471276596"
        //            }
        // spot private
        //        {
        //           "orderId": "1169142457356959747",
        //           "tradeId": "1169142457636958209",
        //           "symbol": "LTCUSDT",
        //           "orderType": "market",
        //           "side": "buy",
        //           "priceAvg": "81.069",
        //           "size": "0.074",
        //           "amount": "5.999106",
        //           "tradeScope": "taker",
        //           "feeDetail": [
        //              {
        //                 "feeCoin": "LTC",
        //                 "deduction": "no",
        //                 "totalDeductionFee": "0",
        //                 "totalFee": "0.000074"
        //              }
        //           ],
        //           "cTime": "1714471204194",
        //           "uTime": "1714471204194"
        //        }
        //
        // uta private
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "orderType": "market",
        //         "updatedTime": "1736378720623",
        //         "side": "buy",
        //         "orderId": "1288888888888888888",
        //         "execPnl": "0",
        //         "feeDetail": [
        //             {
        //                 "feeCoin": "USDT",
        //                 "fee": "0.569958"
        //             }
        //         ],
        //         "execTime": "1736378720623",
        //         "tradeScope": "taker",
        //         "tradeSide": "open",
        //         "execId": "1288888888888888888",
        //         "execLinkId": "1288888888888888888",
        //         "execPrice": "94993",
        //         "holdSide": "long",
        //         "execValue": "949.93",
        //         "category": "USDT-FUTURES",
        //         "execQty": "0.01",
        //         "clientOid": "1288888888888888889"
        // uta
        //
        //     {
        //         "i": "1344534089797185549", // Fill execution ID
        //         "L": "1344534089797185550", // Execution correlation ID
        //         "p": "110878.5", // Fill price
        //         "v": "0.07", // Fill size
        //         "S": "buy", // Fill side
        //         "T": "1756287827920" // Fill timestamp
        //     }
        //
        object instId = this.safeString2(trade, "symbol", "instId");
        object posMode = this.safeString(trade, "posMode");
        object category = this.safeString(trade, "category");
        object defaultType = null;
        if (isTrue(!isEqual(category, null)))
        {
            defaultType = ((bool) isTrue((!isEqual(category, "SPOT")))) ? "contract" : "spot";
        } else
        {
            defaultType = ((bool) isTrue((!isEqual(posMode, null)))) ? "contract" : "spot";
        }
        if (isTrue(isEqual(market, null)))
        {
            market = this.safeMarket(instId, null, null, defaultType);
        }
        object timestamp = this.safeIntegerN(trade, new List<object>() {"uTime", "cTime", "ts", "T", "execTime"});
        object feeDetail = this.safeList(trade, "feeDetail", new List<object>() {});
        object first = this.safeDict(feeDetail, 0);
        object fee = null;
        if (isTrue(!isEqual(first, null)))
        {
            object feeCurrencyId = this.safeString(first, "feeCoin");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", Precise.stringAbs(this.safeString2(first, "totalFee", "fee")) },
                { "currency", feeCurrencyCode },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeStringN(trade, new List<object>() {"tradeId", "i", "execId"}) },
            { "order", this.safeString2(trade, "orderId", "L") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "type", this.safeString(trade, "orderType") },
            { "side", this.safeString2(trade, "side", "S") },
            { "takerOrMaker", this.safeString(trade, "tradeScope") },
            { "price", this.safeStringN(trade, new List<object>() {"priceAvg", "price", "execPrice", "P"}) },
            { "amount", this.safeStringN(trade, new List<object>() {"size", "baseVolume", "execQty", "v"}) },
            { "cost", this.safeStringN(trade, new List<object>() {"amount", "quoteVolume", "execValue"}) },
            { "fee", fee },
        }, market);
    }

    /**
     * @method
     * @name bitget#watchPositions
     * @description watch all open positions
     * @see https://www.bitget.com/api-doc/contract/websocket/private/Positions-Channel
     * @see https://www.bitget.com/api-doc/uta/websocket/private/Positions-Channel
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {int} [since] the earliest time in ms to fetch positions for
     * @param {int} [limit] the maximum number of positions to retrieve
     * @param {object} params extra parameters specific to the exchange API endpoint
     * @param {string} [params.instType] one of 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES', default is 'USDT-FUTURES'
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
     */
    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object messageHash = "";
        object subscriptionHash = "positions";
        object instType = "USDT-FUTURES";
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "watchPositions", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        symbols = this.marketSymbols(symbols);
        if (!isTrue(this.isEmpty(symbols)))
        {
            market = this.getMarketFromSymbols(symbols);
            var instTypeparametersVariable = this.getInstType(market, uta, parameters);
            instType = ((IList<object>)instTypeparametersVariable)[0];
            parameters = ((IList<object>)instTypeparametersVariable)[1];
        }
        if (isTrue(uta))
        {
            instType = "UTA";
        }
        messageHash = add(add(instType, ":positions"), messageHash);
        object args = new Dictionary<string, object>() {
            { "instType", instType },
        };
        object topicOrChannel = ((bool) isTrue(uta)) ? "topic" : "channel";
        object channel = ((bool) isTrue(uta)) ? "position" : "positions";
        ((IDictionary<string,object>)args)[(string)topicOrChannel] = channel;
        if (!isTrue(uta))
        {
            ((IDictionary<string,object>)args)["instId"] = "default";
        } else
        {
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "uta", true },
            });
        }
        object newPositions = await this.watchPrivate(messageHash, subscriptionHash, args, parameters);
        if (isTrue(this.newUpdates))
        {
            return newPositions;
        }
        return this.filterBySymbolsSinceLimit(newPositions, symbols, since, limit, true);
    }

    public virtual void handlePositions(WebSocketClient client, object message)
    {
        //
        //     {
        //         "action": "snapshot",
        //         "arg": {
        //             "instType": "USDT-FUTURES",
        //             "channel": "positions",
        //             "instId": "default"
        //         },
        //         "data": [
        //             {
        //                 "posId": "926036334386778112",
        //                 "instId": "BTCUSDT",
        //                 "marginCoin": "USDT",
        //                 "marginSize": "2.19245",
        //                 "marginMode": "crossed",
        //                 "holdSide": "long",
        //                 "posMode": "hedge_mode",
        //                 "total": "0.001",
        //                 "available": "0.001",
        //                 "frozen": "0",
        //                 "openPriceAvg": "43849",
        //                 "leverage": 20,
        //                 "achievedProfits": "0",
        //                 "unrealizedPL": "-0.0032",
        //                 "unrealizedPLR": "-0.00145955438",
        //                 "liquidationPrice": "17629.684814834",
        //                 "keepMarginRate": "0.004",
        //                 "marginRate": "0.007634649185",
        //                 "cTime": "1652331666985",
        //                 "uTime": "1701913016923",
        //                 "autoMargin": "off"
        //             },
        //             ...
        //         ]
        //         "ts": 1701913043767
        //     }
        //
        // uta
        //
        //     {
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "leverage": "20",
        //                 "openFeeTotal": "",
        //                 "mmr": "",
        //                 "breakEvenPrice": "",
        //                 "available": "0",
        //                 "liqPrice": "",
        //                 "marginMode": "crossed",
        //                 "unrealisedPnl": "0",
        //                 "markPrice": "94987.1",
        //                 "createdTime": "1736378720620",
        //                 "avgPrice": "0",
        //                 "totalFundingFee": "0",
        //                 "updatedTime": "1736378720620",
        //                 "marginCoin": "USDT",
        //                 "frozen": "0",
        //                 "profitRate": "",
        //                 "closeFeeTotal": "",
        //                 "marginSize": "0",
        //                 "curRealisedPnl": "0",
        //                 "size": "0",
        //                 "positionStatus": "ended",
        //                 "posSide": "long",
        //                 "holdMode": "hedge_mode"
        //             }
        //         ],
        //         "arg": {
        //             "instType": "UTA",
        //             "topic": "position"
        //         },
        //         "action": "snapshot",
        //         "ts": 1730711666652
        //     }
        //
        object arg = this.safeDict(message, "arg", new Dictionary<string, object>() {});
        object instType = this.safeString(arg, "instType", "");
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new Dictionary<string, object>() {};
        }
        object action = this.safeString(message, "action");
        if (isTrue(!isTrue((inOp(this.positions, instType))) || isTrue((isEqual(action, "snapshot")))))
        {
            ((IDictionary<string,object>)this.positions)[(string)instType] = new ArrayCacheBySymbolBySide();
        }
        object cache = getValue(this.positions, instType);
        object rawPositions = this.safeList(message, "data", new List<object>() {});
        object newPositions = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rawPositions)); postFixIncrement(ref i))
        {
            object rawPosition = getValue(rawPositions, i);
            object marketId = this.safeString2(rawPosition, "instId", "symbol");
            object market = this.safeMarket(marketId, null, null, "contract");
            object position = this.parseWsPosition(rawPosition, market);
            ((IList<object>)newPositions).Add(position);
            callDynamically(cache, "append", new object[] {position});
        }
        object messageHashes = this.findMessageHashes(client as WebSocketClient, add(instType, ":positions::"));
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object positions = this.filterByArray(newPositions, "symbol", symbols, false);
            if (!isTrue(this.isEmpty(positions)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {positions, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newPositions, add(instType, ":positions")});
    }

    public virtual object parseWsPosition(object position, object market = null)
    {
        //
        //     {
        //         "posId": "926036334386778112",
        //         "instId": "BTCUSDT",
        //         "marginCoin": "USDT",
        //         "marginSize": "2.19245",
        //         "marginMode": "crossed",
        //         "holdSide": "long",
        //         "posMode": "hedge_mode",
        //         "total": "0.001",
        //         "available": "0.001",
        //         "frozen": "0",
        //         "openPriceAvg": "43849",
        //         "leverage": 20,
        //         "achievedProfits": "0",
        //         "unrealizedPL": "-0.0032",
        //         "unrealizedPLR": "-0.00145955438",
        //         "liquidationPrice": "17629.684814834",
        //         "keepMarginRate": "0.004",
        //         "marginRate": "0.007634649185",
        //         "cTime": "1652331666985",
        //         "uTime": "1701913016923",
        //         "autoMargin": "off"
        //     }
        //
        // uta
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "leverage": "20",
        //         "openFeeTotal": "",
        //         "mmr": "",
        //         "breakEvenPrice": "",
        //         "available": "0",
        //         "liqPrice": "",
        //         "marginMode": "crossed",
        //         "unrealisedPnl": "0",
        //         "markPrice": "94987.1",
        //         "createdTime": "1736378720620",
        //         "avgPrice": "0",
        //         "totalFundingFee": "0",
        //         "updatedTime": "1736378720620",
        //         "marginCoin": "USDT",
        //         "frozen": "0",
        //         "profitRate": "",
        //         "closeFeeTotal": "",
        //         "marginSize": "0",
        //         "curRealisedPnl": "0",
        //         "size": "0",
        //         "positionStatus": "ended",
        //         "posSide": "long",
        //         "holdMode": "hedge_mode"
        //     }
        //
        object marketId = this.safeString2(position, "instId", "symbol");
        object marginModeId = this.safeString(position, "marginMode");
        object marginMode = this.getSupportedMapping(marginModeId, new Dictionary<string, object>() {
            { "crossed", "cross" },
            { "isolated", "isolated" },
        });
        object hedgedId = this.safeString2(position, "posMode", "holdMode");
        object hedged = ((bool) isTrue((isEqual(hedgedId, "hedge_mode")))) ? true : false;
        object timestamp = this.safeIntegerN(position, new List<object>() {"updatedTime", "uTime", "cTime", "createdTime"});
        object percentageDecimal = this.safeString2(position, "unrealizedPLR", "profitRate");
        object percentage = Precise.stringMul(percentageDecimal, "100");
        object contractSize = null;
        if (isTrue(!isEqual(market, null)))
        {
            contractSize = getValue(market, "contractSize");
        }
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", this.safeString(position, "posId") },
            { "symbol", this.safeSymbol(marketId, market, null, "contract") },
            { "notional", null },
            { "marginMode", marginMode },
            { "liquidationPrice", this.safeNumber2(position, "liquidationPrice", "liqPrice") },
            { "entryPrice", this.safeNumber2(position, "openPriceAvg", "avgPrice") },
            { "unrealizedPnl", this.safeNumber2(position, "unrealizedPL", "unrealisedPnl") },
            { "percentage", this.parseNumber(percentage) },
            { "contracts", this.safeNumber2(position, "total", "size") },
            { "contractSize", contractSize },
            { "markPrice", this.safeNumber(position, "markPrice") },
            { "side", this.safeString2(position, "holdSide", "posSide") },
            { "hedged", hedged },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", this.safeNumber2(position, "keepMarginRate", "mmr") },
            { "collateral", this.safeNumber(position, "available") },
            { "initialMargin", this.safeNumber(position, "marginSize") },
            { "initialMarginPercentage", null },
            { "leverage", this.safeNumber(position, "leverage") },
            { "marginRatio", this.safeNumber(position, "marginRate") },
        });
    }

    /**
     * @method
     * @name bitget#watchOrders
     * @description watches information on multiple orders made by the user
     * @see https://www.bitget.com/api-doc/spot/websocket/private/Order-Channel
     * @see https://www.bitget.com/api-doc/contract/websocket/private/Order-Channel
     * @see https://www.bitget.com/api-doc/contract/websocket/private/Plan-Order-Channel
     * @see https://www.bitget.com/api-doc/margin/cross/websocket/private/Cross-Orders
     * @see https://www.bitget.com/api-doc/margin/isolated/websocket/private/Isolate-Orders
     * @see https://www.bitget.com/api-doc/uta/websocket/private/Order-Channel
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.trigger] *contract only* set to true for watching trigger orders
     * @param {string} [params.marginMode] 'isolated' or 'cross' for watching spot margin orders]
     * @param {string} [params.type] 'spot', 'swap'
     * @param {string} [params.subType] 'linear', 'inverse'
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object marketId = null;
        object isTrigger = null;
        var isTriggerparametersVariable = this.isTriggerOrder(parameters);
        isTrigger = ((IList<object>)isTriggerparametersVariable)[0];
        parameters = ((IList<object>)isTriggerparametersVariable)[1];
        object messageHash = ((bool) isTrue((isTrigger))) ? "triggerOrder" : "order";
        object subscriptionHash = "order:trades";
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            marketId = getValue(market, "id");
            messageHash = add(add(messageHash, ":"), symbol);
        }
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "watchOrders", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        object productType = this.safeString(parameters, "productType");
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchOrders", market, parameters, "linear");
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(isTrue((isTrue(isEqual(type, "spot")) || isTrue(isEqual(type, "margin")))) && isTrue((isEqual(symbol, null)))))
        {
            marketId = "default";
        }
        if (isTrue(isTrue(isTrue((isEqual(productType, null))) && isTrue((!isEqual(type, "spot")))) && isTrue((isEqual(symbol, null)))))
        {
            messageHash = add(add(messageHash, ":"), subType);
        } else if (isTrue(isEqual(productType, "USDT-FUTURES")))
        {
            messageHash = add(messageHash, ":linear");
        } else if (isTrue(isEqual(productType, "COIN-FUTURES")))
        {
            messageHash = add(messageHash, ":inverse");
        } else if (isTrue(isEqual(productType, "USDC-FUTURES")))
        {
            messageHash = add(messageHash, ":usdcfutures"); // non unified channel
        }
        object instType = null;
        if (isTrue(isTrue(isEqual(market, null)) && isTrue(isEqual(type, "spot"))))
        {
            instType = "SPOT";
        } else
        {
            var instTypeparametersVariable = this.getInstType(market, uta, parameters);
            instType = ((IList<object>)instTypeparametersVariable)[0];
            parameters = ((IList<object>)instTypeparametersVariable)[1];
        }
        if (isTrue(isTrue(isEqual(type, "spot")) && isTrue((!isEqual(symbol, null)))))
        {
            subscriptionHash = add(add(subscriptionHash, ":"), symbol);
        }
        if (isTrue(isTrigger))
        {
            subscriptionHash = add(subscriptionHash, ":stop"); // we don't want to re-use the same subscription hash for stop orders
        }
        object instId = ((bool) isTrue((isTrue(isEqual(type, "spot")) || isTrue(isEqual(type, "margin"))))) ? marketId : "default"; // different from other streams here the 'rest' id is required for spot markets, contract markets require default here
        object channel = ((bool) isTrue(isTrigger)) ? "orders-algo" : "orders";
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("watchOrders", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            instType = "MARGIN";
            messageHash = add(add(messageHash, ":"), marginMode);
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                channel = "orders-isolated";
            } else
            {
                channel = "orders-crossed";
            }
        }
        if (isTrue(uta))
        {
            instType = "UTA";
            channel = "order";
        }
        subscriptionHash = add(add(subscriptionHash, ":"), instType);
        object args = new Dictionary<string, object>() {
            { "instType", instType },
        };
        object topicOrChannel = ((bool) isTrue(uta)) ? "topic" : "channel";
        ((IDictionary<string,object>)args)[(string)topicOrChannel] = channel;
        if (!isTrue(uta))
        {
            ((IDictionary<string,object>)args)["instId"] = instId;
        } else
        {
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "uta", true },
            });
        }
        object orders = await this.watchPrivate(messageHash, subscriptionHash, args, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //     {
        //         "action": "snapshot",
        //         "arg": { "instType": "SPOT", "channel": "orders", "instId": "BTCUSDT" },
        //         "data": [
        //             // see all examples in parseWsOrder
        //         ],
        //         "ts": 1701923297285
        //     }
        //
        // contract
        //
        //     {
        //         "action": "snapshot",
        //         "arg": { "instType": "USDT-FUTURES", "channel": "orders", "instId": "default" },
        //         "data": [
        //             // see all examples in parseWsOrder
        //         ],
        //         "ts": 1701920595879
        //     }
        //
        // isolated and cross margin
        //
        //     {
        //         "action": "snapshot",
        //         "arg": { "instType": "MARGIN", "channel": "orders-crossed", "instId": "BTCUSDT" },
        //         "data": [
        //             // see examples in parseWsOrder
        //         ],
        //         "ts": 1701923982497
        //     }
        //
        // uta
        //
        //     {
        //         "action": "snapshot",
        //         "arg": {
        //             "instType": "UTA",
        //             "topic": "order"
        //         },
        //         "data": [
        //             {
        //                 "category": "usdt-futures",
        //                 "symbol": "BTCUSDT",
        //                 "orderId": "xxx",
        //                 "clientOid": "xxx",
        //                 "price": "",
        //                 "qty": "0.001",
        //                 "amount": "1000",
        //                 "holdMode": "hedge_mode",
        //                 "holdSide": "long",
        //                 "tradeSide": "open",
        //                 "orderType": "market",
        //                 "timeInForce": "gtc",
        //                 "side": "buy",
        //                 "marginMode": "crossed",
        //                 "marginCoin": "USDT",
        //                 "reduceOnly": "no",
        //                 "cumExecQty": "0.001",
        //                 "cumExecValue": "83.1315",
        //                 "avgPrice": "83131.5",
        //                 "totalProfit": "0",
        //                 "orderStatus": "filled",
        //                 "cancelReason": "",
        //                 "leverage": "20",
        //                 "feeDetail": [
        //                     {
        //                         "feeCoin": "USDT",
        //                         "fee": "0.0332526"
        //                     }
        //                 ],
        //                 "createdTime": "1742367838101",
        //                 "updatedTime": "1742367838115",
        //                 "stpMode": "none"
        //             }
        //         ],
        //         "ts": 1742367838124
        //     }
        //
        object arg = this.safeDict(message, "arg", new Dictionary<string, object>() {});
        object channel = this.safeString2(arg, "channel", "topic");
        object instType = this.safeStringLower(arg, "instType");
        object argInstId = this.safeString(arg, "instId");
        object marketType = null;
        if (isTrue(isEqual(instType, "spot")))
        {
            marketType = "spot";
        } else if (isTrue(isEqual(instType, "margin")))
        {
            marketType = "spot";
        } else
        {
            marketType = "contract";
        }
        object data = this.safeList(message, "data", new List<object>() {});
        object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
        object category = this.safeStringLower(first, "category", instType);
        object isLinearSwap = (isEqual(category, "usdt-futures"));
        object isInverseSwap = (isEqual(category, "coin-futures"));
        object isUSDCFutures = (isEqual(category, "usdc-futures"));
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
            this.triggerOrders = new ArrayCacheBySymbolById(limit);
        }
        object isTrigger = isTrue((isEqual(channel, "orders-algo"))) || isTrue((isEqual(channel, "ordersAlgo")));
        object stored = ((bool) isTrue(isTrigger)) ? this.triggerOrders : this.orders;
        object messageHash = ((bool) isTrue(isTrigger)) ? "triggerOrder" : "order";
        object marketSymbols = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object order = getValue(data, i);
            object marketId = this.safeString2(order, "instId", "symbol", argInstId);
            object market = this.safeMarket(marketId, null, null, marketType);
            object parsed = this.parseWsOrder(order, market);
            callDynamically(stored, "append", new object[] {parsed});
            object symbol = getValue(parsed, "symbol");
            ((IDictionary<string,object>)marketSymbols)[(string)symbol] = true;
        }
        object keys = new List<object>(((IDictionary<string,object>)marketSymbols).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object symbol = getValue(keys, i);
            object innerMessageHash = add(add(messageHash, ":"), symbol);
            if (isTrue(isEqual(channel, "orders-crossed")))
            {
                innerMessageHash = add(innerMessageHash, ":cross");
            } else if (isTrue(isEqual(channel, "orders-isolated")))
            {
                innerMessageHash = add(innerMessageHash, ":isolated");
            }
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, innerMessageHash});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        if (isTrue(isLinearSwap))
        {
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, "order:linear"});
        }
        if (isTrue(isInverseSwap))
        {
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, "order:inverse"});
        }
        if (isTrue(isUSDCFutures))
        {
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, "order:usdcfutures"});
        }
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        // spot
        //
        //   {
        //         instId: 'EOSUSDT',
        //         orderId: '1171779081105780739',
        //         price: '0.81075', // limit price, field not present for market orders
        //         clientOid: 'a2330139-1d04-4d78-98be-07de3cfd1055',
        //         notional: '5.675250', // this is not cost! but notional
        //         newSize: '7.0000', // this is not cost! quanity (for limit order or market sell) or cost (for market buy order)
        //         size: '5.6752', // this is not cost, neither quanity, but notional! this field for "spot" can be ignored at all
        //         // Note: for limit order (even filled) we don't have cost value in response, only in market order
        //         orderType: 'limit', // limit, market
        //         force: 'gtc',
        //         side: 'buy',
        //         accBaseVolume: '0.0000', // in case of 'filled', this would be set (for limit orders, this is the only indicator of the amount filled)
        //         priceAvg: '0.00000', // in case of 'filled', this would be set
        //         status: 'live', // live, filled, partially_filled
        //         cTime: '1715099824215',
        //         uTime: '1715099824215',
        //         feeDetail: [],
        //         enterPointSource: 'API'
        //                   #### trigger order has these additional fields: ####
        //         "triggerPrice": "35100",
        //         "price": "35100", // this is same as trigger price
        //         "executePrice": "35123", // this is limit price
        //         "triggerType": "fill_price",
        //         "planType": "amount",
        //                   #### in case order had a partial fill: ####
        //         fillPrice: '35123',
        //         tradeId: '1171775539946528779',
        //         baseVolume: '7', // field present in market order
        //         fillTime: '1715098979937',
        //         fillFee: '-0.0069987',
        //         fillFeeCoin: 'BTC',
        //         tradeScope: 'T',
        //    }
        //
        // contract
        //
        //     {
        //         accBaseVolume: '0', // total amount filled during lifetime for order
        //         cTime: '1715065875539',
        //         clientOid: '1171636690041344003',
        //         enterPointSource: 'API',
        //         feeDetail: [ {
        //             "feeCoin": "USDT",
        //             "fee": "-0.162003"
        //         } ],
        //         force: 'gtc',
        //         instId: 'SEOSSUSDT',
        //         leverage: '10',
        //         marginCoin: 'USDT',
        //         marginMode: 'crossed',
        //         notionalUsd: '10.4468',
        //         orderId: '1171636690028761089',
        //         orderType: 'market',
        //         posMode: 'hedge_mode', // one_way_mode, hedge_mode
        //         posSide: 'short', // short, long, net
        //         price: '0', // zero for market order
        //         reduceOnly: 'no',
        //         side: 'sell',
        //         size: '13', // this is contracts amount
        //         status: 'live', // live, filled, cancelled
        //         tradeSide: 'open',
        //         uTime: '1715065875539'
        //                   #### when filled order is incoming, these additional fields are present too: ###
        //         baseVolume: '9', // amount filled for the incoming update/trade
        //         accBaseVolume: '13', // i.e. 9 has been filled from 13 amount (this value is same as 'size')
        //         fillFee: '-0.0062712',
        //         fillFeeCoin: 'SUSDT',
        //         fillNotionalUsd: '10.452',
        //         fillPrice: '0.804',
        //         fillTime: '1715065875605',
        //         pnl: '0',
        //         priceAvg: '0.804',
        //         tradeId: '1171636690314407937',
        //         tradeScope: 'T',
        //                   #### trigger order has these additional fields:
        //         "triggerPrice": "0.800000000",
        //         "price": "0.800000000",  // <-- this is same as trigger price, actual limit-price is not present in initial response
        //         "triggerType": "mark_price",
        //         "triggerTime": "1715082796679",
        //         "planType": "pl",
        //         "actualSize": "0.000000000",
        //         "stopSurplusTriggerType": "fill_price",
        //         "stopLossTriggerType": "fill_price",
        //     }
        //
        // isolated and cross margin
        //
        //     {
        //         enterPointSource: "web",
        //         feeDetail: [
        //           {
        //             feeCoin: "AAVE",
        //             deduction: "no",
        //             totalDeductionFee: "0",
        //             totalFee: "-0.00010740",
        //           },
        //         ],
        //         force: "gtc",
        //         orderType: "limit",
        //         price: "93.170000000",
        //         fillPrice: "93.170000000",
        //         baseSize: "0.110600000", // total amount of order
        //         quoteSize: "10.304602000", // total cost of order (independently if order is filled or pending)
        //         baseVolume: "0.107400000", // filled amount of order (during order's lifecycle, and not for this specific incoming update)
        //         fillTotalAmount: "10.006458000", // filled cost of order (during order's lifecycle, and not for this specific incoming update)
        //         side: "buy",
        //         status: "partially_filled",
        //         cTime: "1717875017306",
        //         clientOid: "b57afe789a06454e9c560a2aab7f7201",
        //         loanType: "auto-loan",
        //         orderId: "1183419084588060673",
        //       }
        //
        // uta
        //
        //     {
        //         "category": "usdt-futures",
        //         "symbol": "BTCUSDT",
        //         "orderId": "xxx",
        //         "clientOid": "xxx",
        //         "price": "",
        //         "qty": "0.001",
        //         "amount": "1000",
        //         "holdMode": "hedge_mode",
        //         "holdSide": "long",
        //         "tradeSide": "open",
        //         "orderType": "market",
        //         "timeInForce": "gtc",
        //         "side": "buy",
        //         "marginMode": "crossed",
        //         "marginCoin": "USDT",
        //         "reduceOnly": "no",
        //         "cumExecQty": "0.001",
        //         "cumExecValue": "83.1315",
        //         "avgPrice": "83131.5",
        //         "totalProfit": "0",
        //         "orderStatus": "filled",
        //         "cancelReason": "",
        //         "leverage": "20",
        //         "feeDetail": [
        //             {
        //                 "feeCoin": "USDT",
        //                 "fee": "0.0332526"
        //             }
        //         ],
        //         "createdTime": "1742367838101",
        //         "updatedTime": "1742367838115",
        //         "stpMode": "none"
        //     }
        //
        object isSpot = !isTrue((inOp(order, "posMode")));
        object isMargin = (inOp(order, "loanType"));
        object category = this.safeStringLower(order, "category");
        if (isTrue(isEqual(category, "spot")))
        {
            isSpot = true;
        }
        if (isTrue(isEqual(category, "margin")))
        {
            isMargin = true;
        }
        object marketId = this.safeString2(order, "instId", "symbol");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger2(order, "cTime", "createdTime");
        object symbol = getValue(market, "symbol");
        object rawStatus = this.safeString2(order, "status", "orderStatus");
        object orderFee = this.safeValue(order, "feeDetail", new List<object>() {});
        object fee = this.safeValue(orderFee, 0);
        object feeAmount = this.safeString(fee, "fee");
        object feeObject = null;
        if (isTrue(!isEqual(feeAmount, null)))
        {
            object feeCurrency = this.safeString(fee, "feeCoin");
            feeObject = new Dictionary<string, object>() {
                { "cost", this.parseNumber(Precise.stringAbs(feeAmount)) },
                { "currency", this.safeCurrencyCode(feeCurrency) },
            };
        }
        object triggerPrice = this.safeNumber(order, "triggerPrice");
        object isTriggerOrder = (!isEqual(triggerPrice, null));
        object price = null;
        if (!isTrue(isTriggerOrder))
        {
            price = this.safeNumber(order, "price");
        } else if (isTrue(isTrue(isSpot) && isTrue(isTriggerOrder)))
        {
            // for spot trigger order, limit price is this
            price = this.safeNumber(order, "executePrice");
        }
        object avgPrice = this.omitZero(this.safeStringLowerN(order, new List<object>() {"priceAvg", "fillPrice", "avgPrice"}));
        object side = this.safeString(order, "side");
        object type = this.safeString(order, "orderType");
        object accBaseVolume = this.omitZero(this.safeString2(order, "accBaseVolume", "cumExecQty"));
        object newSizeValue = this.omitZero(this.safeString2(order, "newSize", "cumExecValue"));
        object isMarketOrder = (isEqual(type, "market"));
        object isBuy = (isEqual(side, "buy"));
        object totalAmount = null;
        object filledAmount = null;
        object cost = null;
        object remaining = null;
        object totalFilled = this.safeString2(order, "accBaseVolume", "cumExecQty");
        if (isTrue(isSpot))
        {
            if (isTrue(isMargin))
            {
                totalAmount = this.safeString2(order, "baseSize", "qty");
                totalFilled = this.safeString2(order, "baseVolume", "cumExecQty");
                cost = this.safeString2(order, "fillTotalAmount", "cumExecValue");
            } else
            {
                object partialFillAmount = this.safeString(order, "baseVolume");
                if (isTrue(!isEqual(partialFillAmount, null)))
                {
                    filledAmount = partialFillAmount;
                } else
                {
                    filledAmount = totalFilled;
                }
                if (isTrue(isMarketOrder))
                {
                    if (isTrue(isBuy))
                    {
                        totalAmount = accBaseVolume;
                        cost = newSizeValue;
                    } else
                    {
                        totalAmount = newSizeValue;
                    }
                } else
                {
                    totalAmount = this.safeString2(order, "newSize", "qty");
                }
            }
        } else
        {
            // baseVolume should not be used for "amount" for contracts !
            filledAmount = this.safeString2(order, "baseVolume", "cumExecQty");
            totalAmount = this.safeString2(order, "size", "qty");
            cost = this.safeString2(order, "fillNotionalUsd", "cumExecValue");
        }
        remaining = Precise.stringSub(totalAmount, totalFilled);
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "symbol", symbol },
            { "id", this.safeString(order, "orderId") },
            { "clientOrderId", this.safeString(order, "clientOid") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", this.safeInteger2(order, "uTime", "updatedTime") },
            { "type", type },
            { "timeInForce", this.safeStringUpper2(order, "force", "timeInForce") },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "triggerPrice", triggerPrice },
            { "amount", totalAmount },
            { "cost", cost },
            { "average", avgPrice },
            { "filled", filledAmount },
            { "remaining", remaining },
            { "status", this.parseWsOrderStatus(rawStatus) },
            { "fee", feeObject },
            { "trades", null },
        }, market);
    }

    public virtual object parseWsOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "live", "open" },
            { "partially_filled", "open" },
            { "filled", "closed" },
            { "cancelled", "canceled" },
            { "not_trigger", "open" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name bitget#watchMyTrades
     * @description watches trades made by the user
     * @see https://www.bitget.com/api-doc/contract/websocket/private/Fill-Channel
     * @see https://www.bitget.com/api-doc/uta/websocket/private/Fill-Channel
     * @param {str} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object messageHash = "myTrades";
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            messageHash = add(add(messageHash, ":"), symbol);
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchMyTrades", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object instType = null;
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "watchMyTrades", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(isTrue(isEqual(market, null)) && isTrue(isEqual(type, "spot"))))
        {
            instType = "SPOT";
        } else
        {
            var instTypeparametersVariable = this.getInstType(market, uta, parameters);
            instType = ((IList<object>)instTypeparametersVariable)[0];
            parameters = ((IList<object>)instTypeparametersVariable)[1];
        }
        if (isTrue(uta))
        {
            instType = "UTA";
        }
        object subscriptionHash = add("fill:", instType);
        object args = new Dictionary<string, object>() {
            { "instType", instType },
        };
        object topicOrChannel = ((bool) isTrue(uta)) ? "topic" : "channel";
        ((IDictionary<string,object>)args)[(string)topicOrChannel] = "fill";
        if (!isTrue(uta))
        {
            ((IDictionary<string,object>)args)["instId"] = "default";
        } else
        {
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "uta", true },
            });
        }
        object trades = await this.watchPrivate(messageHash, subscriptionHash, args, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleMyTrades(WebSocketClient client, object message)
    {
        //
        // spot
        // {
        //     "action": "snapshot",
        //     "arg": {
        //        "instType": "SPOT",
        //        "channel": "fill",
        //        "instId": "default"
        //     },
        //     "data": [
        //        {
        //           "orderId": "1169142457356959747",
        //           "tradeId": "1169142457636958209",
        //           "symbol": "LTCUSDT",
        //           "orderType": "market",
        //           "side": "buy",
        //           "priceAvg": "81.069",
        //           "size": "0.074",
        //           "amount": "5.999106",
        //           "tradeScope": "taker",
        //           "feeDetail": [
        //              {
        //                 "feeCoin": "LTC",
        //                 "deduction": "no",
        //                 "totalDeductionFee": "0",
        //                 "totalFee": "0.000074"
        //              }
        //           ],
        //           "cTime": "1714471204194",
        //           "uTime": "1714471204194"
        //        }
        //     ],
        //     "ts": 1714471204270
        // }
        // swap
        //     {
        //         "action": "snapshot",
        //         "arg": {
        //            "instType": "USDT-FUTURES",
        //            "channel": "fill",
        //            "instId": "default"
        //         },
        //         "data": [
        //            {
        //               "orderId": "1169142761031114781",
        //               "tradeId": "1169142761312637004",
        //               "symbol": "LTCUSDT",
        //               "orderType": "market",
        //               "side": "buy",
        //               "price": "80.87",
        //               "baseVolume": "0.1",
        //               "quoteVolume": "8.087",
        //               "profit": "0",
        //               "tradeSide": "open",
        //               "posMode": "hedge_mode",
        //               "tradeScope": "taker",
        //               "feeDetail": [
        //                  {
        //                     "feeCoin": "USDT",
        //                     "deduction": "no",
        //                     "totalDeductionFee": "0",
        //                     "totalFee": "-0.0048522"
        //                  }
        //               ],
        //               "cTime": "1714471276596",
        //               "uTime": "1714471276596"
        //            }
        //         ],
        //         "ts": 1714471276629
        //     }
        //
        // uta
        //
        //     {
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "orderType": "market",
        //                 "updatedTime": "1736378720623",
        //                 "side": "buy",
        //                 "orderId": "1288888888888888888",
        //                 "execPnl": "0",
        //                 "feeDetail": [
        //                     {
        //                         "feeCoin": "USDT",
        //                         "fee": "0.569958"
        //                     }
        //                 ],
        //                 "execTime": "1736378720623",
        //                 "tradeScope": "taker",
        //                 "tradeSide": "open",
        //                 "execId": "1288888888888888888",
        //                 "execLinkId": "1288888888888888888",
        //                 "execPrice": "94993",
        //                 "holdSide": "long",
        //                 "execValue": "949.93",
        //                 "category": "USDT-FUTURES",
        //                 "execQty": "0.01",
        //                 "clientOid": "1288888888888888889"
        //             }
        //         ],
        //         "arg": {
        //             "instType": "UTA",
        //             "topic": "fill"
        //         },
        //         "action": "snapshot",
        //         "ts": 1733904123981
        //     }
        //
        if (isTrue(isEqual(this.myTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            this.myTrades = new ArrayCache(limit);
        }
        object stored = this.myTrades;
        object data = this.safeList(message, "data", new List<object>() {});
        object length = getArrayLength(data);
        object messageHash = "myTrades";
        for (object i = 0; isLessThan(i, length); postFixIncrement(ref i))
        {
            object trade = getValue(data, i);
            object parsed = this.parseWsTrade(trade);
            callDynamically(stored, "append", new object[] {parsed});
            object symbol = getValue(parsed, "symbol");
            object symbolSpecificMessageHash = add("myTrades:", symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, symbolSpecificMessageHash});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    /**
     * @method
     * @name bitget#watchBalance
     * @description watch balance and get the amount of funds available for trading or funds locked in orders
     * @see https://www.bitget.com/api-doc/spot/websocket/private/Account-Channel
     * @see https://www.bitget.com/api-doc/contract/websocket/private/Account-Channel
     * @see https://www.bitget.com/api-doc/margin/cross/websocket/private/Margin-Cross-Account-Assets
     * @see https://www.bitget.com/api-doc/margin/isolated/websocket/private/Margin-isolated-account-assets
     * @see https://www.bitget.com/api-doc/uta/websocket/private/Account-Channel
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {str} [params.type] spot or contract if not provided this.options['defaultType'] is used
     * @param {string} [params.instType] one of 'SPOT', 'MARGIN', 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
     * @param {string} [params.marginMode] 'isolated' or 'cross' for watching spot margin balances
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "watchBalance", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("watchBalance", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object instType = null;
        object channel = "account";
        if (isTrue(isTrue((isEqual(type, "swap"))) || isTrue((isEqual(type, "future")))))
        {
            instType = "USDT-FUTURES";
        } else if (isTrue(!isEqual(marginMode, null)))
        {
            instType = "MARGIN";
            if (!isTrue(uta))
            {
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    channel = "account-isolated";
                } else
                {
                    channel = "account-crossed";
                }
            }
        } else if (!isTrue(uta))
        {
            instType = "SPOT";
        }
        var instTypeparametersVariable = this.handleOptionAndParams(parameters, "watchBalance", "instType", instType);
        instType = ((IList<object>)instTypeparametersVariable)[0];
        parameters = ((IList<object>)instTypeparametersVariable)[1];
        if (isTrue(uta))
        {
            instType = "UTA";
        }
        object args = new Dictionary<string, object>() {
            { "instType", instType },
        };
        object topicOrChannel = ((bool) isTrue(uta)) ? "topic" : "channel";
        ((IDictionary<string,object>)args)[(string)topicOrChannel] = channel;
        if (!isTrue(uta))
        {
            ((IDictionary<string,object>)args)["coin"] = "default";
        } else
        {
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "uta", true },
            });
        }
        object messageHash = add("balance:", ((string)instType).ToLower());
        return await this.watchPrivate(messageHash, messageHash, args, parameters);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //     {
        //         "action": "snapshot",
        //         "arg": { "instType": "SPOT", "channel": "account", "coin": "default" },
        //         "data": [
        //             {
        //                 "coin": "USDT",
        //                 "available": "19.1430952856087",
        //                 "frozen": "7",
        //                 "locked": "0",
        //                 "limitAvailable": "0",
        //                 "uTime": "1701931970487"
        //             },
        //         ],
        //         "ts": 1701931970487
        //     }
        //
        // swap
        //
        //     {
        //         "action": "snapshot",
        //         "arg": { "instType": "USDT-FUTURES", "channel": "account", "coin": "default" },
        //         "data": [
        //             {
        //                 "marginCoin": "USDT",
        //                 "frozen": "5.36581500",
        //                 "available": "26.14309528",
        //                 "maxOpenPosAvailable": "20.77728028",
        //                 "maxTransferOut": "20.77728028",
        //                 "equity": "26.14309528",
        //                 "usdtEquity": "26.143095285166"
        //             }
        //         ],
        //         "ts": 1701932570822
        //     }
        //
        // margin
        //
        //     {
        //         "action": "snapshot",
        //         "arg": { "instType": "MARGIN", "channel": "account-crossed", "coin": "default" },
        //         "data": [
        //             {
        //                 "uTime": "1701933110544",
        //                 "id": "1096916799926710272",
        //                 "coin": "USDT",
        //                 "available": "16.24309528",
        //                 "borrow": "0.00000000",
        //                 "frozen": "9.90000000",
        //                 "interest": "0.00000000",
        //                 "coupon": "0.00000000"
        //             }
        //         ],
        //         "ts": 1701933110544
        //     }
        //
        // uta
        //
        //     {
        //         "data": [{
        //             "unrealisedPnL": "-10116.55",
        //             "totalEquity": "4976919.05",
        //             "positionMgnRatio": "0",
        //             "mmr": "408.08",
        //             "effEquity": "4847952.35",
        //             "imr": "17795.97",
        //             "mgnRatio": "0",
        //             "coin": [{
        //                 "debts": "0",
        //                 "balance": "0.9992",
        //                 "available": "0.9992",
        //                 "borrow": "0",
        //                 "locked": "0",
        //                 "equity": "0.9992",
        //                 "coin": "ETH",
        //                 "usdValue": "2488.667472"
        //             }]
        //         }],
        //         "arg": {
        //             "instType": "UTA",
        //             "topic": "account"
        //         },
        //         "action": "snapshot",
        //         "ts": 1740546523244
        //     }
        //
        object arg = this.safeDict(message, "arg", new Dictionary<string, object>() {});
        object instType = this.safeStringLower(arg, "instType");
        object data = this.safeValue(message, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object rawBalance = getValue(data, i);
            if (isTrue(isEqual(instType, "uta")))
            {
                object coins = this.safeList(rawBalance, "coin", new List<object>() {});
                for (object j = 0; isLessThan(j, getArrayLength(coins)); postFixIncrement(ref j))
                {
                    object entry = getValue(coins, j);
                    object currencyId = this.safeString(entry, "coin");
                    object code = this.safeCurrencyCode(currencyId);
                    object account = ((bool) isTrue((inOp(this.balance, code)))) ? getValue(this.balance, code) : this.account();
                    object borrow = this.safeString(entry, "borrow");
                    object debts = this.safeString(entry, "debts");
                    if (isTrue(isTrue((!isEqual(borrow, null))) || isTrue((!isEqual(debts, null)))))
                    {
                        ((IDictionary<string,object>)account)["debt"] = Precise.stringAdd(borrow, debts);
                    }
                    ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "available");
                    ((IDictionary<string,object>)account)["used"] = this.safeString(entry, "locked");
                    ((IDictionary<string,object>)account)["total"] = this.safeString(entry, "balance");
                    ((IDictionary<string,object>)this.balance)[(string)code] = account;
                }
            } else
            {
                object currencyId = this.safeString2(rawBalance, "coin", "marginCoin");
                object code = this.safeCurrencyCode(currencyId);
                object account = ((bool) isTrue((inOp(this.balance, code)))) ? getValue(this.balance, code) : this.account();
                object borrow = this.safeString(rawBalance, "borrow");
                if (isTrue(!isEqual(borrow, null)))
                {
                    object interest = this.safeString(rawBalance, "interest");
                    ((IDictionary<string,object>)account)["debt"] = Precise.stringAdd(borrow, interest);
                }
                object freeQuery = ((bool) isTrue((inOp(rawBalance, "maxTransferOut")))) ? "maxTransferOut" : "available";
                ((IDictionary<string,object>)account)["free"] = this.safeString(rawBalance, freeQuery);
                ((IDictionary<string,object>)account)["total"] = this.safeString(rawBalance, "equity");
                ((IDictionary<string,object>)account)["used"] = this.safeString(rawBalance, "frozen");
                ((IDictionary<string,object>)this.balance)[(string)code] = account;
            }
        }
        this.balance = this.safeBalance(this.balance);
        object messageHash = add("balance:", instType);
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, messageHash});
    }

    public async virtual Task<object> watchPublic(object messageHash, object args, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object uta = null;
        object url = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "watchPublic", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            url = getValue(getValue(getValue(this.urls, "api"), "ws"), "utaPublic");
        } else
        {
            url = getValue(getValue(getValue(this.urls, "api"), "ws"), "public");
        }
        object sandboxMode = this.safeBool2(this.options, "sandboxMode", "sandbox", false);
        if (isTrue(sandboxMode))
        {
            object instType = this.safeString(args, "instType");
            if (isTrue(isTrue(isTrue((!isEqual(instType, "SCOIN-FUTURES"))) && isTrue((!isEqual(instType, "SUSDT-FUTURES")))) && isTrue((!isEqual(instType, "SUSDC-FUTURES")))))
            {
                if (isTrue(uta))
                {
                    url = getValue(getValue(getValue(this.urls, "api"), "demo"), "utaPublic");
                } else
                {
                    url = getValue(getValue(getValue(this.urls, "api"), "demo"), "public");
                }
            }
        }
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", new List<object>() {args} },
        };
        object message = this.extend(request, parameters);
        return await this.watch(url, messageHash, message, messageHash);
    }

    public async virtual Task<object> unWatchPublic(object messageHash, object args, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object uta = null;
        object url = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "unWatchPublic", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            url = getValue(getValue(getValue(this.urls, "api"), "ws"), "utaPublic");
        } else
        {
            url = getValue(getValue(getValue(this.urls, "api"), "ws"), "public");
        }
        object sandboxMode = this.safeBool2(this.options, "sandboxMode", "sandbox", false);
        if (isTrue(sandboxMode))
        {
            object instType = this.safeString(args, "instType");
            if (isTrue(isTrue(isTrue((!isEqual(instType, "SCOIN-FUTURES"))) && isTrue((!isEqual(instType, "SUSDT-FUTURES")))) && isTrue((!isEqual(instType, "SUSDC-FUTURES")))))
            {
                if (isTrue(uta))
                {
                    url = getValue(getValue(getValue(this.urls, "api"), "demo"), "utaPublic");
                } else
                {
                    url = getValue(getValue(getValue(this.urls, "api"), "demo"), "public");
                }
            }
        }
        object request = new Dictionary<string, object>() {
            { "op", "unsubscribe" },
            { "args", new List<object>() {args} },
        };
        object message = this.extend(request, parameters);
        return await this.watch(url, messageHash, message, messageHash);
    }

    public async virtual Task<object> watchPublicMultiple(object messageHashes, object argsArray, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object uta = null;
        object url = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "watchPublicMultiple", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            url = getValue(getValue(getValue(this.urls, "api"), "ws"), "utaPublic");
        } else
        {
            url = getValue(getValue(getValue(this.urls, "api"), "ws"), "public");
        }
        object sandboxMode = this.safeBool2(this.options, "sandboxMode", "sandbox", false);
        if (isTrue(sandboxMode))
        {
            object argsArrayFirst = this.safeDict(argsArray, 0, new Dictionary<string, object>() {});
            object instType = this.safeString(argsArrayFirst, "instType");
            if (isTrue(isTrue(isTrue((!isEqual(instType, "SCOIN-FUTURES"))) && isTrue((!isEqual(instType, "SUSDT-FUTURES")))) && isTrue((!isEqual(instType, "SUSDC-FUTURES")))))
            {
                if (isTrue(uta))
                {
                    url = getValue(getValue(getValue(this.urls, "api"), "demo"), "utaPublic");
                } else
                {
                    url = getValue(getValue(getValue(this.urls, "api"), "demo"), "public");
                }
            }
        }
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", argsArray },
        };
        object message = this.extend(request, parameters);
        return await this.watchMultiple(url, messageHashes, message, messageHashes);
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object url = this.safeString(parameters, "url");
        var client = this.client(url);
        object messageHash = "authenticated";
        var future = client.future(messageHash);
        object authenticated = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(authenticated, null)))
        {
            object timestamp = ((object)this.seconds()).ToString();
            object auth = add(add(timestamp, "GET"), "/user/verify");
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256, "base64");
            object operation = "login";
            object request = new Dictionary<string, object>() {
                { "op", operation },
                { "args", new List<object>() {new Dictionary<string, object>() {
    { "apiKey", this.apiKey },
    { "passphrase", this.password },
    { "timestamp", timestamp },
    { "sign", signature },
}} },
            };
            object message = this.extend(request, parameters);
            this.watch(url, messageHash, message, messageHash);
        }
        return await (future as Exchange.Future);
    }

    public async virtual Task<object> watchPrivate(object messageHash, object subscriptionHash, object args, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object uta = null;
        object url = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "watchPrivate", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            url = getValue(getValue(getValue(this.urls, "api"), "ws"), "utaPrivate");
        } else
        {
            url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        }
        object sandboxMode = this.safeBool2(this.options, "sandboxMode", "sandbox", false);
        if (isTrue(sandboxMode))
        {
            object instType = this.safeString(args, "instType");
            if (isTrue(isTrue(isTrue((!isEqual(instType, "SCOIN-FUTURES"))) && isTrue((!isEqual(instType, "SUSDT-FUTURES")))) && isTrue((!isEqual(instType, "SUSDC-FUTURES")))))
            {
                if (isTrue(uta))
                {
                    url = getValue(getValue(getValue(this.urls, "api"), "demo"), "utaPrivate");
                } else
                {
                    url = getValue(getValue(getValue(this.urls, "api"), "demo"), "private");
                }
            }
        }
        await this.authenticate(new Dictionary<string, object>() {
            { "url", url },
        });
        object request = new Dictionary<string, object>() {
            { "op", "subscribe" },
            { "args", new List<object>() {args} },
        };
        object message = this.extend(request, parameters);
        return await this.watch(url, messageHash, message, subscriptionHash);
    }

    public virtual void handleAuthenticate(WebSocketClient client, object message)
    {
        //
        //  { event: "login", code: 0 }
        //
        object messageHash = "authenticated";
        var future = this.safeValue((client as WebSocketClient).futures, messageHash);
        (future as Future).resolve(true);
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //    { event: "error", code: 30015, msg: "Invalid sign" }
        //
        object eventVar = this.safeString(message, "event");
        try
        {
            if (isTrue(isEqual(eventVar, "error")))
            {
                object code = this.safeString(message, "code");
                object feedback = add(add(this.id, " "), this.json(message));
                this.throwExactlyMatchedException(getValue(getValue(this.exceptions, "ws"), "exact"), code, feedback);
                object msg = this.safeString(message, "msg", "");
                this.throwBroadlyMatchedException(getValue(getValue(this.exceptions, "ws"), "broad"), msg, feedback);
                throw new ExchangeError ((string)feedback) ;
            }
            return false;
        } catch(Exception e)
        {
            if (isTrue(e is AuthenticationError))
            {
                object messageHash = "authenticated";
                ((WebSocketClient)client).reject(e, messageHash);
                if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
                {
                    ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
                }
            } else
            {
                // Note: if error happens on a subscribe event, user will have to close exchange to resubscribe. Issue #19041
                ((WebSocketClient)client).reject(e);
            }
            return true;
        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        //
        //   {
        //       "action": "snapshot",
        //       "arg": { instType: 'SPOT', channel: "ticker", instId: "BTCUSDT" },
        //       "data": [
        //         {
        //           "instId": "BTCUSDT",
        //           "last": "21150.53",
        //           "open24h": "20759.65",
        //           "high24h": "21202.29",
        //           "low24h": "20518.82",
        //           "bestBid": "21150.500000",
        //           "bestAsk": "21150.600000",
        //           "baseVolume": "25402.1961",
        //           "quoteVolume": "530452554.2156",
        //           "ts": 1656408934044,
        //           "labeId": 0
        //         }
        //       ]
        //   }
        // pong message
        //    "pong"
        //
        // login
        //
        //     { event: "login", code: 0 }
        //
        // subscribe
        //
        //    {
        //        "event": "subscribe",
        //        "arg": { instType: 'SPOT', channel: "account", instId: "default" }
        //    }
        // unsubscribe
        //    {
        //        "op":"unsubscribe",
        //        "args":[
        //          {
        //            "instType":"USDT-FUTURES",
        //            "channel":"ticker",
        //            "instId":"BTCUSDT"
        //          }
        //        ]
        //    }
        //
        // uta
        //
        //     {
        //         "action": "snapshot",
        //         "arg": { "instType": "spot", topic: "ticker", symbol: "BTCUSDT" },
        //         "data": [
        //             {
        //                 "highPrice24h": "120255.61",
        //                 "lowPrice24h": "116145.88",
        //                 "openPrice24h": "118919.38",
        //                 "lastPrice": "119818.83",
        //                 "turnover24h": "215859996.272276",
        //                 "volume24h": "1819.756798",
        //                 "bid1Price": "119811.26",
        //                 "ask1Price": "119831.18",
        //                 "bid1Size": "0.008732",
        //                 "ask1Size": "0.004297",
        //                 "price24hPcnt": "0.02002"
        //             }
        //         ],
        //         "ts": 1753230479687
        //     }
        //
        // unsubscribe
        //
        //     {
        //         "event": "unsubscribe",
        //         "arg": {
        //             "instType": "spot",
        //             "topic": "kline",
        //             "symbol": "BTCUSDT",
        //             "interval": "1m"
        //         }
        //     }
        //
        if (isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            return;
        }
        object content = this.safeString(message, "message");
        if (isTrue(isEqual(content, "pong")))
        {
            this.handlePong(client as WebSocketClient, message);
            return;
        }
        if (isTrue(isEqual(message, "pong")))
        {
            this.handlePong(client as WebSocketClient, message);
            return;
        }
        object eventVar = this.safeString(message, "event");
        if (isTrue(isEqual(eventVar, "login")))
        {
            this.handleAuthenticate(client as WebSocketClient, message);
            return;
        }
        if (isTrue(isEqual(eventVar, "subscribe")))
        {
            this.handleSubscriptionStatus(client as WebSocketClient, message);
            return;
        }
        if (isTrue(isEqual(eventVar, "unsubscribe")))
        {
            this.handleUnSubscriptionStatus(client as WebSocketClient, message);
            return;
        }
        object methods = new Dictionary<string, object>() {
            { "ticker", this.handleTicker },
            { "trade", this.handleTrades },
            { "publicTrade", this.handleTrades },
            { "fill", this.handleMyTrades },
            { "order", this.handleOrder },
            { "orders", this.handleOrder },
            { "ordersAlgo", this.handleOrder },
            { "orders-algo", this.handleOrder },
            { "orders-crossed", this.handleOrder },
            { "orders-isolated", this.handleOrder },
            { "account", this.handleBalance },
            { "position", this.handlePositions },
            { "positions", this.handlePositions },
            { "account-isolated", this.handleBalance },
            { "account-crossed", this.handleBalance },
            { "kline", this.handleOHLCV },
        };
        object arg = this.safeValue(message, "arg", new Dictionary<string, object>() {});
        object topic = this.safeValue2(arg, "channel", "topic", "");
        object method = this.safeValue(methods, topic);
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(topic, "candle"), 0)))
        {
            this.handleOHLCV(client as WebSocketClient, message);
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(topic, "books"), 0)))
        {
            this.handleOrderBook(client as WebSocketClient, message);
        }
    }

    public override object ping(WebSocketClient client)
    {
        return "ping";
    }

    public virtual object handlePong(WebSocketClient client, object message)
    {
        client.lastPong = this.milliseconds();
        return message;
    }

    public virtual object handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //    {
        //        "event": "subscribe",
        //        "arg": { instType: 'SPOT', channel: "account", instId: "default" }
        //    }
        //
        return message;
    }

    public virtual void handleOrderBookUnSubscription(WebSocketClient client, object message)
    {
        //
        //    {"event":"unsubscribe","arg":{"instType":"SPOT","channel":"books","instId":"BTCUSDT"}}
        //
        object arg = this.safeDict(message, "arg", new Dictionary<string, object>() {});
        object instType = this.safeStringLower(arg, "instType");
        object type = ((bool) isTrue((isEqual(instType, "spot")))) ? "spot" : "contract";
        object instId = this.safeString(arg, "instId");
        object market = this.safeMarket(instId, null, null, type);
        object symbol = getValue(market, "symbol");
        object messageHash = add("unsubscribe:orderbook:", getValue(market, "symbol"));
        object subMessageHash = add("orderbook:", symbol);
        if (isTrue(inOp(this.orderbooks, symbol)))
        {
            ((IDictionary<string,object>)this.orderbooks).Remove((string)symbol);
        }
        if (isTrue(inOp(((WebSocketClient)client).subscriptions, subMessageHash)))
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)subMessageHash);
        }
        if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
        }
        var error = new UnsubscribeError(add(add(this.id, " orderbook "), symbol));
        ((WebSocketClient)client).reject(error, subMessageHash);
        callDynamically(client as WebSocketClient, "resolve", new object[] {true, messageHash});
    }

    public virtual void handleTradesUnSubscription(WebSocketClient client, object message)
    {
        //
        //    {"event":"unsubscribe","arg":{"instType":"SPOT","channel":"trade","instId":"BTCUSDT"}}
        //
        object arg = this.safeDict(message, "arg", new Dictionary<string, object>() {});
        object instType = this.safeStringLower(arg, "instType");
        object type = ((bool) isTrue((isEqual(instType, "spot")))) ? "spot" : "contract";
        object instId = this.safeString2(arg, "instId", "symbol");
        object market = this.safeMarket(instId, null, null, type);
        object symbol = getValue(market, "symbol");
        object messageHash = add("unsubscribe:trade:", getValue(market, "symbol"));
        object subMessageHash = add("trade:", symbol);
        if (isTrue(inOp(this.trades, symbol)))
        {
            ((IDictionary<string,object>)this.trades).Remove((string)symbol);
        }
        if (isTrue(inOp(((WebSocketClient)client).subscriptions, subMessageHash)))
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)subMessageHash);
        }
        if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
        }
        var error = new UnsubscribeError(add(add(this.id, " trades "), symbol));
        ((WebSocketClient)client).reject(error, subMessageHash);
        callDynamically(client as WebSocketClient, "resolve", new object[] {true, messageHash});
    }

    public virtual void handleTickerUnSubscription(WebSocketClient client, object message)
    {
        //
        //    {"event":"unsubscribe","arg":{"instType":"SPOT","channel":"trade","instId":"BTCUSDT"}}
        //
        object arg = this.safeDict(message, "arg", new Dictionary<string, object>() {});
        object instType = this.safeStringLower(arg, "instType");
        object type = ((bool) isTrue((isEqual(instType, "spot")))) ? "spot" : "contract";
        object instId = this.safeString2(arg, "instId", "symbol");
        object market = this.safeMarket(instId, null, null, type);
        object symbol = getValue(market, "symbol");
        object messageHash = add("unsubscribe:ticker:", getValue(market, "symbol"));
        object subMessageHash = add("ticker:", symbol);
        if (isTrue(inOp(this.tickers, symbol)))
        {
            ((IDictionary<string,object>)this.tickers).Remove((string)symbol);
        }
        if (isTrue(inOp(((WebSocketClient)client).subscriptions, subMessageHash)))
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)subMessageHash);
        }
        if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
        }
        var error = new UnsubscribeError(add(add(this.id, " ticker "), symbol));
        ((WebSocketClient)client).reject(error, subMessageHash);
        callDynamically(client as WebSocketClient, "resolve", new object[] {true, messageHash});
    }

    public virtual void handleOHLCVUnSubscription(WebSocketClient client, object message)
    {
        //
        //    {"event":"unsubscribe","arg":{"instType":"SPOT","channel":"candle1m","instId":"BTCUSDT"}}
        //
        // UTA
        //
        //    {"event":"unsubscribe","arg":{"instType":"spot","topic":"kline","symbol":"BTCUSDT","interval":"1m"}}
        //
        object arg = this.safeDict(message, "arg", new Dictionary<string, object>() {});
        object instType = this.safeStringLower(arg, "instType");
        object type = ((bool) isTrue((isEqual(instType, "spot")))) ? "spot" : "contract";
        object instId = this.safeString2(arg, "instId", "symbol");
        object channel = this.safeString2(arg, "channel", "topic");
        object interval = this.safeString(arg, "interval");
        object isUta = null;
        if (isTrue(isEqual(interval, null)))
        {
            isUta = false;
            interval = ((string)channel).Replace((string)"candle", (string)"");
        } else
        {
            isUta = true;
        }
        object timeframes = this.safeValue(this.options, "timeframes");
        object timeframe = this.findTimeframe(interval, timeframes);
        object market = this.safeMarket(instId, null, null, type);
        object symbol = getValue(market, "symbol");
        object messageHash = null;
        object subMessageHash = null;
        if (isTrue(isUta))
        {
            messageHash = add("unsubscribe:kline:", symbol);
            subMessageHash = add("kline:", symbol);
        } else
        {
            messageHash = add(add(add("unsubscribe:candles:", timeframe), ":"), symbol);
            subMessageHash = add(add(add("candles:", timeframe), ":"), symbol);
        }
        if (isTrue(inOp(this.ohlcvs, symbol)))
        {
            if (isTrue(inOp(getValue(this.ohlcvs, symbol), timeframe)))
            {
                ((IDictionary<string,object>)getValue(this.ohlcvs, symbol)).Remove((string)timeframe);
            }
        }
        this.cleanUnsubscription(client as WebSocketClient, subMessageHash, messageHash);
    }

    public virtual object handleUnSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //  {
        //      "op":"unsubscribe",
        //      "args":[
        //        {
        //          "instType":"USDT-FUTURES",
        //          "channel":"ticker",
        //          "instId":"BTCUSDT"
        //        },
        //        {
        //          "instType":"USDT-FUTURES",
        //          "channel":"candle1m",
        //          "instId":"BTCUSDT"
        //        }
        //      ]
        //  }
        //  or
        // {"event":"unsubscribe","arg":{"instType":"SPOT","channel":"books","instId":"BTCUSDT"}}
        //
        object argsList = this.safeList(message, "args");
        if (isTrue(isEqual(argsList, null)))
        {
            argsList = new List<object> {this.safeDict(message, "arg", new Dictionary<string, object>() {})};
        }
        for (object i = 0; isLessThan(i, getArrayLength(argsList)); postFixIncrement(ref i))
        {
            object arg = getValue(argsList, i);
            object channel = this.safeString2(arg, "channel", "topic");
            if (isTrue(isEqual(channel, "books")))
            {
                // for now only unWatchOrderBook is supporteod
                this.handleOrderBookUnSubscription(client as WebSocketClient, message);
            } else if (isTrue(isTrue((isEqual(channel, "trade"))) || isTrue((isEqual(channel, "publicTrade")))))
            {
                this.handleTradesUnSubscription(client as WebSocketClient, message);
            } else if (isTrue(isEqual(channel, "ticker")))
            {
                this.handleTickerUnSubscription(client as WebSocketClient, message);
            } else if (isTrue(((string)channel).StartsWith(((string)"candle"))))
            {
                this.handleOHLCVUnSubscription(client as WebSocketClient, message);
            } else if (isTrue(((string)channel).StartsWith(((string)"kline"))))
            {
                this.handleOHLCVUnSubscription(client as WebSocketClient, message);
            }
        }
        return message;
    }
}
