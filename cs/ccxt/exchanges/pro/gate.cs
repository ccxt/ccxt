namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class gate { public gate(object args = null) : base(args) { } }
public partial class gate : ccxt.gate
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchOrderBook", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
                { "watchMyTrades", true },
                { "watchOHLCV", true },
                { "watchBalance", true },
                { "watchOrders", true },
                { "watchPositions", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", "wss://ws.gate.io/v4" },
                    { "spot", "wss://api.gateio.ws/ws/v4/" },
                    { "swap", new Dictionary<string, object>() {
                        { "usdt", "wss://fx-ws.gateio.ws/v4/ws/usdt" },
                        { "btc", "wss://fx-ws.gateio.ws/v4/ws/btc" },
                    } },
                    { "future", new Dictionary<string, object>() {
                        { "usdt", "wss://fx-ws.gateio.ws/v4/ws/delivery/usdt" },
                        { "btc", "wss://fx-ws.gateio.ws/v4/ws/delivery/btc" },
                    } },
                    { "option", new Dictionary<string, object>() {
                        { "usdt", "wss://op-ws.gateio.live/v4/ws/usdt" },
                        { "btc", "wss://op-ws.gateio.live/v4/ws/btc" },
                    } },
                } },
                { "test", new Dictionary<string, object>() {
                    { "swap", new Dictionary<string, object>() {
                        { "usdt", "wss://fx-ws-testnet.gateio.ws/v4/ws/usdt" },
                        { "btc", "wss://fx-ws-testnet.gateio.ws/v4/ws/btc" },
                    } },
                    { "future", new Dictionary<string, object>() {
                        { "usdt", "wss://fx-ws-testnet.gateio.ws/v4/ws/usdt" },
                        { "btc", "wss://fx-ws-testnet.gateio.ws/v4/ws/btc" },
                    } },
                    { "option", new Dictionary<string, object>() {
                        { "usdt", "wss://op-ws-testnet.gateio.live/v4/ws/usdt" },
                        { "btc", "wss://op-ws-testnet.gateio.live/v4/ws/btc" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "tradesLimit", 1000 },
                { "OHLCVLimit", 1000 },
                { "watchTradesSubscriptions", new Dictionary<string, object>() {} },
                { "watchTickerSubscriptions", new Dictionary<string, object>() {} },
                { "watchOrderBookSubscriptions", new Dictionary<string, object>() {} },
                { "watchTicker", new Dictionary<string, object>() {
                    { "name", "tickers" },
                } },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "interval", "100ms" },
                    { "snapshotDelay", 10 },
                    { "snapshotMaxRetries", 3 },
                } },
                { "watchBalance", new Dictionary<string, object>() {
                    { "settle", "usdt" },
                    { "spot", "spot.balances" },
                } },
                { "watchPositions", new Dictionary<string, object>() {
                    { "fetchPositionsSnapshot", true },
                    { "awaitPositionsSnapshot", true },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "ws", new Dictionary<string, object>() {
                    { "exact", new Dictionary<string, object>() {
                        { "2", typeof(BadRequest) },
                        { "4", typeof(AuthenticationError) },
                        { "6", typeof(AuthenticationError) },
                        { "11", typeof(AuthenticationError) },
                    } },
                } },
            } },
        });
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#watchOrderBook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object marketId = getValue(market, "id");
        var intervalqueryVariable = this.handleOptionAndParams(parameters, "watchOrderBook", "interval", "100ms");
        var interval = ((IList<object>) intervalqueryVariable)[0];
        var query = ((IList<object>) intervalqueryVariable)[1];
        object messageType = this.getTypeByMarket(market);
        object channel = add(messageType, ".order_book_update");
        object messageHash = add(add("orderbook", ":"), symbol);
        object url = this.getUrlByMarket(market);
        object payload = new List<object>() {marketId, interval};
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100;
        }
        if (isTrue(getValue(market, "contract")))
        {
            object stringLimit = ((object)limit).ToString();
            ((IList<object>)payload).Add(stringLimit);
        }
        object subscription = new Dictionary<string, object>() {
            { "symbol", symbol },
            { "limit", limit },
        };
        object orderbook = await this.subscribePublic(url, messageHash, payload, channel, query, subscription);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBookSubscription(WebSocketClient client, object message, object subscription)
    {
        object symbol = this.safeString(subscription, "symbol");
        object limit = this.safeInteger(subscription, "limit");
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //     {
        //         "time": 1650189272,
        //         "channel": "spot.order_book_update",
        //         "event": "update",
        //         "result": {
        //             "t": 1650189272515,
        //             "e": "depthUpdate",
        //             "E": 1650189272,
        //             "s": "GMT_USDT",
        //             "U": 140595902,
        //             "u": 140595902,
        //             "b": [
        //                 [ '2.51518', "228.119" ],
        //                 [ '2.50587', "1510.11" ],
        //                 [ '2.49944', "67.6" ],
        //             ],
        //             "a": [
        //                 [ '2.5182', "4.199" ],
        //                 [ "2.51926", "1874" ],
        //                 [ '2.53528', "96.529" ],
        //             ]
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         "id": null,
        //         "time": 1650188898,
        //         "channel": "futures.order_book_update",
        //         "event": "update",
        //         "error": null,
        //         "result": {
        //             "t": 1650188898938,
        //             "s": "GMT_USDT",
        //             "U": 1577718307,
        //             "u": 1577719254,
        //             "b": [
        //                 { p: "2.5178", s: 0 },
        //                 { p: "2.5179", s: 0 },
        //                 { p: "2.518", s: 0 },
        //             ],
        //             "a": [
        //                 { p: "2.52", s: 0 },
        //                 { p: "2.5201", s: 0 },
        //                 { p: "2.5203", s: 0 },
        //             ]
        //         }
        //     }
        //
        object channel = this.safeString(message, "channel");
        object channelParts = ((string)channel).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object rawMarketType = this.safeString(channelParts, 0);
        object isSpot = isEqual(rawMarketType, "spot");
        object marketType = ((bool) isTrue(isSpot)) ? "spot" : "contract";
        object delta = this.safeValue(message, "result");
        object deltaStart = this.safeInteger(delta, "U");
        object deltaEnd = this.safeInteger(delta, "u");
        object marketId = this.safeString(delta, "s");
        object symbol = this.safeSymbol(marketId, null, "_", marketType);
        object messageHash = add("orderbook:", symbol);
        object storedOrderBook = this.safeValue(this.orderbooks, symbol, this.orderBook(new Dictionary<string, object>() {}));
        object nonce = this.safeInteger(storedOrderBook, "nonce");
        if (isTrue(isEqual(nonce, null)))
        {
            object cacheLength = 0;
            if (isTrue(!isEqual(storedOrderBook, null)))
            {
                cacheLength = getArrayLength((storedOrderBook as ccxt.pro.OrderBook).cache);
            }
            object snapshotDelay = this.handleOption("watchOrderBook", "snapshotDelay", 10);
            object waitAmount = ((bool) isTrue(isSpot)) ? snapshotDelay : 0;
            if (isTrue(isEqual(cacheLength, waitAmount)))
            {
                // max limit is 100
                object subscription = getValue(((WebSocketClient)client).subscriptions, messageHash);
                object limit = this.safeInteger(subscription, "limit");
                this.spawn(this.loadOrderBook, new object[] { client, messageHash, symbol, limit, new Dictionary<string, object>() {}}); // needed for c#, number of args needs to match
            }
            ((IList<object>)(storedOrderBook as ccxt.pro.OrderBook).cache).Add(delta);
            return;
        } else if (isTrue(isGreaterThanOrEqual(nonce, deltaEnd)))
        {
            return;
        } else if (isTrue(isGreaterThanOrEqual(nonce, subtract(deltaStart, 1))))
        {
            this.handleDelta(storedOrderBook, delta);
        } else
        {
            var error = new InvalidNonce(add(this.id, " orderbook update has a nonce bigger than u"));


            ((WebSocketClient)client).reject(error, messageHash);
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {storedOrderBook, messageHash});
    }

    public override object getCacheIndex(object orderBook, object cache)
    {
        object nonce = this.safeInteger(orderBook, "nonce");
        object firstDelta = getValue(cache, 0);
        object firstDeltaStart = this.safeInteger(firstDelta, "U");
        if (isTrue(isLessThan(nonce, firstDeltaStart)))
        {
            return -1;
        }
        for (object i = 0; isLessThan(i, getArrayLength(cache)); postFixIncrement(ref i))
        {
            object delta = getValue(cache, i);
            object deltaStart = this.safeInteger(delta, "U");
            object deltaEnd = this.safeInteger(delta, "u");
            if (isTrue(isTrue((isGreaterThanOrEqual(nonce, subtract(deltaStart, 1)))) && isTrue((isLessThan(nonce, deltaEnd)))))
            {
                return i;
            }
        }
        return getArrayLength(cache);
    }

    public virtual void handleBidAsks(object bookSide, object bidAsks)
    {
        for (object i = 0; isLessThan(i, getArrayLength(bidAsks)); postFixIncrement(ref i))
        {
            object bidAsk = getValue(bidAsks, i);
            if (isTrue(((bidAsk is IList<object>) || (bidAsk.GetType().IsGenericType && bidAsk.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                (bookSide as IOrderBookSide).storeArray(this.parseBidAsk(bidAsk));
            } else
            {
                object price = this.safeFloat(bidAsk, "p");
                object amount = this.safeFloat(bidAsk, "s");
                (bookSide as IOrderBookSide).store(price, amount);
            }
        }
    }

    public override void handleDelta(object orderbook, object delta)
    {
        object timestamp = this.safeInteger(delta, "t");
        ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
        ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger(delta, "u");
        object bids = this.safeValue(delta, "b", new List<object>() {});
        object asks = this.safeValue(delta, "a", new List<object>() {});
        object storedBids = getValue(orderbook, "bids");
        object storedAsks = getValue(orderbook, "asks");
        this.handleBidAsks(storedBids, bids);
        this.handleBidAsks(storedAsks, asks);
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name gate#watchTicker
        * @see https://www.gate.io/docs/developers/apiv4/ws/en/#tickers-channel
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        ((IDictionary<string,object>)parameters)["callerMethodName"] = "watchTicker";
        object result = await this.watchTickers(new List<object>() {symbol}, parameters);
        return this.safeValue(result, symbol);
    }

    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#watchTickers
        * @see https://www.gate.io/docs/developers/apiv4/ws/en/#tickers-channel
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
        * @param {string[]} symbols unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.subscribeWatchTickersAndBidsAsks(symbols, "watchTickers", this.extend(new Dictionary<string, object>() {
            { "method", "tickers" },
        }, parameters));
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        //    {
        //        "time": 1649326221,
        //        "channel": "spot.tickers",
        //        "event": "update",
        //        "result": {
        //          "currency_pair": "BTC_USDT",
        //          "last": "43444.82",
        //          "lowest_ask": "43444.82",
        //          "highest_bid": "43444.81",
        //          "change_percentage": "-4.0036",
        //          "base_volume": "5182.5412425462",
        //          "quote_volume": "227267634.93123952",
        //          "high_24h": "47698",
        //          "low_24h": "42721.03"
        //        }
        //    }
        //
        this.handleTickerAndBidAsk("ticker", client, message);
    }

    public async override Task<object> watchBidsAsks(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#watchBidsAsks
        * @see https://www.gate.io/docs/developers/apiv4/ws/en/#best-bid-or-ask-price
        * @see https://www.gate.io/docs/developers/apiv4/ws/en/#order-book-channel
        * @description watches best bid & ask for symbols
        * @param {string[]} symbols unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.subscribeWatchTickersAndBidsAsks(symbols, "watchBidsAsks", this.extend(new Dictionary<string, object>() {
            { "method", "book_ticker" },
        }, parameters));
    }

    public virtual void handleBidAsk(WebSocketClient client, object message)
    {
        //
        //    {
        //        "time": 1671363004,
        //        "time_ms": 1671363004235,
        //        "channel": "spot.book_ticker",
        //        "event": "update",
        //        "result": {
        //          "t": 1671363004228,
        //          "u": 9793320464,
        //          "s": "BTC_USDT",
        //          "b": "16716.8",
        //          "B": "0.0134",
        //          "a": "16716.9",
        //          "A": "0.0353"
        //        }
        //    }
        //
        this.handleTickerAndBidAsk("bidask", client, message);
    }

    public async virtual Task<object> subscribeWatchTickersAndBidsAsks(object symbols = null, object callerMethodName = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        var callerMethodNameparametersVariable = this.handleParamString(parameters, "callerMethodName", callerMethodName);
        callerMethodName = ((IList<object>)callerMethodNameparametersVariable)[0];
        parameters = ((IList<object>)callerMethodNameparametersVariable)[1];
        symbols = this.marketSymbols(symbols, null, false);
        object market = this.market(getValue(symbols, 0));
        object messageType = this.getTypeByMarket(market);
        object marketIds = this.marketIds(symbols);
        object channelName = null;
        var channelNameparametersVariable = this.handleOptionAndParams(parameters, callerMethodName, "method");
        channelName = ((IList<object>)channelNameparametersVariable)[0];
        parameters = ((IList<object>)channelNameparametersVariable)[1];
        object url = this.getUrlByMarket(market);
        object channel = add(add(messageType, "."), channelName);
        object isWatchTickers = isGreaterThanOrEqual(getIndexOf(callerMethodName, "watchTicker"), 0);
        object prefix = ((bool) isTrue(isWatchTickers)) ? "ticker" : "bidask";
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            ((IList<object>)messageHashes).Add(add(add(prefix, ":"), symbol));
        }
        object tickerOrBidAsk = await this.subscribePublicMultiple(url, messageHashes, marketIds, channel, parameters);
        if (isTrue(this.newUpdates))
        {
            object items = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)items)[(string)getValue(tickerOrBidAsk, "symbol")] = tickerOrBidAsk;
            return items;
        }
        object result = ((bool) isTrue(isWatchTickers)) ? this.tickers : this.bidsasks;
        return this.filterByArray(result, "symbol", symbols, true);
    }

    public virtual void handleTickerAndBidAsk(object objectName, object client, object message)
    {
        object channel = this.safeString(message, "channel");
        object parts = ((string)channel).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object rawMarketType = this.safeString(parts, 0);
        object marketType = ((bool) isTrue((isEqual(rawMarketType, "futures")))) ? "contract" : "spot";
        object result = this.safeValue(message, "result");
        object results = new List<object>() {};
        if (isTrue(((result is IList<object>) || (result.GetType().IsGenericType && result.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            results = this.safeList(message, "result", new List<object>() {});
        } else
        {
            object rawTicker = this.safeDict(message, "result", new Dictionary<string, object>() {});
            results = new List<object>() {rawTicker};
        }
        object isTicker = (isEqual(objectName, "ticker")); // whether ticker or bid-ask
        for (object i = 0; isLessThan(i, getArrayLength(results)); postFixIncrement(ref i))
        {
            object rawTicker = getValue(results, i);
            object marketId = this.safeString(rawTicker, "s");
            object market = this.safeMarket(marketId, null, "_", marketType);
            object parsedItem = this.parseTicker(rawTicker, market);
            object symbol = getValue(parsedItem, "symbol");
            if (isTrue(isTicker))
            {
                ((IDictionary<string,object>)this.tickers)[(string)symbol] = parsedItem;
            } else
            {
                ((IDictionary<string,object>)this.bidsasks)[(string)symbol] = parsedItem;
            }
            object messageHash = add(add(objectName, ":"), symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {parsedItem, messageHash});
        }
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#watchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#watchTradesForSymbols
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object marketIds = this.marketIds(symbols);
        object market = this.market(getValue(symbols, 0));
        object messageType = this.getTypeByMarket(market);
        object channel = add(messageType, ".trades");
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            ((IList<object>)messageHashes).Add(add("trades:", symbol));
        }
        object url = this.getUrlByMarket(market);
        object trades = await this.subscribePublicMultiple(url, messageHashes, marketIds, channel, parameters);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeValue(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        // {
        //     "time": 1648725035,
        //     "channel": "spot.trades",
        //     "event": "update",
        //     "result": [{
        //       "id": 3130257995,
        //       "create_time": 1648725035,
        //       "create_time_ms": "1648725035923.0",
        //       "side": "sell",
        //       "currency_pair": "LTC_USDT",
        //       "amount": "0.0116",
        //       "price": "130.11"
        //     }]
        // }
        //
        object result = this.safeValue(message, "result");
        if (!isTrue(((result is IList<object>) || (result.GetType().IsGenericType && result.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            result = new List<object>() {result};
        }
        object parsedTrades = this.parseTrades(result);
        for (object i = 0; isLessThan(i, getArrayLength(parsedTrades)); postFixIncrement(ref i))
        {
            object trade = getValue(parsedTrades, i);
            object symbol = getValue(trade, "symbol");
            object cachedTrades = this.safeValue(this.trades, symbol);
            if (isTrue(isEqual(cachedTrades, null)))
            {
                object limit = this.safeInteger(this.options, "tradesLimit", 1000);
                cachedTrades = new ArrayCache(limit);
                ((IDictionary<string,object>)this.trades)[(string)symbol] = cachedTrades;
            }
            callDynamically(cachedTrades, "append", new object[] {trade});
            object hash = add("trades:", symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {cachedTrades, hash});
        }
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#watchOHLCV
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object marketId = getValue(market, "id");
        object interval = this.safeString(this.timeframes, timeframe, timeframe);
        object messageType = this.getTypeByMarket(market);
        object channel = add(messageType, ".candlesticks");
        object messageHash = add(add(add("candles:", interval), ":"), getValue(market, "symbol"));
        object url = this.getUrlByMarket(market);
        object payload = new List<object>() {interval, marketId};
        object ohlcv = await this.subscribePublic(url, messageHash, payload, channel, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        // {
        //     "time": 1606292600,
        //     "channel": "spot.candlesticks",
        //     "event": "update",
        //     "result": {
        //       "t": "1606292580", // total volume
        //       "v": "2362.32035", // volume
        //       "c": "19128.1", // close
        //       "h": "19128.1", // high
        //       "l": "19128.1", // low
        //       "o": "19128.1", // open
        //       "n": "1m_BTC_USDT" // sub
        //     }
        //   }
        //
        object channel = this.safeString(message, "channel");
        object channelParts = ((string)channel).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object rawMarketType = this.safeString(channelParts, 0);
        object marketType = ((bool) isTrue((isEqual(rawMarketType, "spot")))) ? "spot" : "contract";
        object result = this.safeValue(message, "result");
        if (!isTrue(((result is IList<object>) || (result.GetType().IsGenericType && result.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            result = new List<object>() {result};
        }
        object marketIds = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
        {
            object ohlcv = getValue(result, i);
            object subscription = this.safeString(ohlcv, "n", "");
            object parts = ((string)subscription).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
            object timeframe = this.safeString(parts, 0);
            object timeframeId = this.findTimeframe(timeframe);
            object prefix = add(timeframe, "_");
            object marketId = ((string)subscription).Replace((string)prefix, (string)"");
            object symbol = this.safeSymbol(marketId, null, "_", marketType);
            object parsed = this.parseOHLCV(ohlcv);
            ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
            object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
            if (isTrue(isEqual(stored, null)))
            {
                object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
                stored = new ArrayCacheByTimestamp(limit);
                ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframeId] = stored;
            }
            callDynamically(stored, "append", new object[] {parsed});
            ((IDictionary<string,object>)marketIds)[(string)symbol] = timeframe;
        }
        object keys = new List<object>(((IDictionary<string,object>)marketIds).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object symbol = getValue(keys, i);
            object timeframe = getValue(marketIds, symbol);
            object interval = this.findTimeframe(timeframe);
            object hash = add(add(add(add("candles", ":"), interval), ":"), symbol);
            object stored = this.safeValue(getValue(this.ohlcvs, symbol), interval);
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, hash});
        }
    }

    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#watchMyTrades
        * @description watches information on multiple trades made by the user
        * @param {string} symbol unified market symbol of the market trades were made in
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trade structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object subType = null;
        object type = null;
        object marketId = add("!", "all");
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            marketId = getValue(market, "id");
        }
        var typeparametersVariable = this.handleMarketTypeAndParams("watchMyTrades", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchMyTrades", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object messageType = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "spot", "spot" },
            { "margin", "spot" },
            { "future", "futures" },
            { "swap", "futures" },
            { "option", "options" },
        });
        object channel = add(messageType, ".usertrades");
        object messageHash = "myTrades";
        if (isTrue(!isEqual(symbol, null)))
        {
            messageHash = add(messageHash, add(":", symbol));
        }
        object isInverse = (isEqual(subType, "inverse"));
        object url = this.getUrlByMarketType(type, isInverse);
        object payload = new List<object>() {marketId};
        // uid required for non spot markets
        object requiresUid = (!isEqual(type, "spot"));
        object trades = await this.subscribePrivate(url, messageHash, payload, channel, parameters, requiresUid);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleMyTrades(WebSocketClient client, object message)
    {
        //
        // {
        //     "time": 1543205083,
        //     "channel": "futures.usertrades",
        //     "event": "update",
        //     "error": null,
        //     "result": [
        //       {
        //         "id": "3335259",
        //         "create_time": 1628736848,
        //         "create_time_ms": 1628736848321,
        //         "contract": "BTC_USD",
        //         "order_id": "4872460",
        //         "size": 1,
        //         "price": "40000.4",
        //         "role": "maker"
        //       }
        //     ]
        // }
        //
        object result = this.safeValue(message, "result", new List<object>() {});
        object tradesLength = getArrayLength(result);
        if (isTrue(isEqual(tradesLength, 0)))
        {
            return;
        }
        object cachedTrades = this.myTrades;
        if (isTrue(isEqual(cachedTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            cachedTrades = new ArrayCacheBySymbolById(limit);
            this.myTrades = cachedTrades;
        }
        object parsed = this.parseTrades(result);
        object marketIds = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(parsed)); postFixIncrement(ref i))
        {
            object trade = getValue(parsed, i);
            callDynamically(cachedTrades, "append", new object[] {trade});
            object symbol = getValue(trade, "symbol");
            ((IDictionary<string,object>)marketIds)[(string)symbol] = true;
        }
        object keys = new List<object>(((IDictionary<string,object>)marketIds).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object market = getValue(keys, i);
            object hash = add("myTrades:", market);
            callDynamically(client as WebSocketClient, "resolve", new object[] {cachedTrades, hash});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {cachedTrades, "myTrades"});
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @name gate#watchBalance
        * @description watch balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
        object subType = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchBalance", null, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object isInverse = (isEqual(subType, "inverse"));
        object url = this.getUrlByMarketType(type, isInverse);
        object requiresUid = (!isEqual(type, "spot"));
        object channelType = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "spot", "spot" },
            { "margin", "spot" },
            { "future", "futures" },
            { "swap", "futures" },
            { "option", "options" },
        });
        object channel = add(channelType, ".balances");
        object messageHash = add(type, ".balance");
        return await this.subscribePrivate(url, messageHash, null, channel, parameters, requiresUid);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        // spot order fill
        //   {
        //       "time": 1653664351,
        //       "channel": "spot.balances",
        //       "event": "update",
        //       "result": [
        //         {
        //           "timestamp": "1653664351",
        //           "timestamp_ms": "1653664351017",
        //           "user": "10406147",
        //           "currency": "LTC",
        //           "change": "-0.0002000000000000",
        //           "total": "0.09986000000000000000",
        //           "available": "0.09986000000000000000"
        //         }
        //       ]
        //   }
        //
        // account transfer
        //
        //    {
        //        "id": null,
        //        "time": 1653665088,
        //        "channel": "futures.balances",
        //        "event": "update",
        //        "error": null,
        //        "result": [
        //          {
        //            "balance": 25.035008537,
        //            "change": 25,
        //            "text": "-",
        //            "time": 1653665088,
        //            "time_ms": 1653665088286,
        //            "type": "dnw",
        //            "user": "10406147"
        //          }
        //        ]
        //   }
        //
        // swap order fill
        //   {
        //       "id": null,
        //       "time": 1653665311,
        //       "channel": "futures.balances",
        //       "event": "update",
        //       "error": null,
        //       "result": [
        //         {
        //           "balance": 20.031873037,
        //           "change": -0.0031355,
        //           "text": "LTC_USDT:165551103273",
        //           "time": 1653665311,
        //           "time_ms": 1653665311437,
        //           "type": "fee",
        //           "user": "10406147"
        //         }
        //       ]
        //   }
        //
        object result = this.safeValue(message, "result", new List<object>() {});
        object timestamp = this.safeInteger(message, "time_ms");
        ((IDictionary<string,object>)this.balance)["info"] = result;
        ((IDictionary<string,object>)this.balance)["timestamp"] = timestamp;
        ((IDictionary<string,object>)this.balance)["datetime"] = this.iso8601(timestamp);
        for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
        {
            object rawBalance = getValue(result, i);
            object account = this.account();
            object currencyId = this.safeString(rawBalance, "currency", "USDT"); // when not present it is USDT
            object code = this.safeCurrencyCode(currencyId);
            ((IDictionary<string,object>)account)["free"] = this.safeString(rawBalance, "available");
            ((IDictionary<string,object>)account)["total"] = this.safeString2(rawBalance, "total", "balance");
            ((IDictionary<string,object>)this.balance)[(string)code] = account;
        }
        object channel = this.safeString(message, "channel");
        object parts = ((string)channel).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object rawType = this.safeString(parts, 0);
        object channelType = this.getSupportedMapping(rawType, new Dictionary<string, object>() {
            { "spot", "spot" },
            { "futures", "swap" },
            { "options", "option" },
        });
        object messageHash = add(channelType, ".balance");
        this.balance = this.safeBalance(this.balance);
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, messageHash});
    }

    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#watchPositions
        * @see https://www.gate.io/docs/developers/futures/ws/en/#positions-subscription
        * @see https://www.gate.io/docs/developers/delivery/ws/en/#positions-subscription
        * @see https://www.gate.io/docs/developers/options/ws/en/#positions-channel
        * @description watch all open positions
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        symbols = this.marketSymbols(symbols);
        object payload = new List<object>() {add("!", "all")};
        if (!isTrue(this.isEmpty(symbols)))
        {
            market = this.getMarketFromSymbols(symbols);
        }
        object type = null;
        object query = null;
        var typequeryVariable = this.handleMarketTypeAndParams("watchPositions", market, parameters);
        type = ((IList<object>)typequeryVariable)[0];
        query = ((IList<object>)typequeryVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            type = "swap";
        }
        object typeId = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "future", "futures" },
            { "swap", "futures" },
            { "option", "options" },
        });
        object messageHash = add(type, ":positions");
        if (!isTrue(this.isEmpty(symbols)))
        {
            messageHash = add(messageHash, add("::", String.Join(",", ((IList<object>)symbols).ToArray())));
        }
        object channel = add(typeId, ".positions");
        object subType = null;
        var subTypequeryVariable = this.handleSubTypeAndParams("watchPositions", market, query);
        subType = ((IList<object>)subTypequeryVariable)[0];
        query = ((IList<object>)subTypequeryVariable)[1];
        object isInverse = (isEqual(subType, "inverse"));
        object url = this.getUrlByMarketType(type, isInverse);
        var client = this.client(url);
        this.setPositionsCache(client as WebSocketClient, type, symbols);
        object fetchPositionsSnapshot = this.handleOption("watchPositions", "fetchPositionsSnapshot", true);
        object awaitPositionsSnapshot = this.safeBool("watchPositions", "awaitPositionsSnapshot", true);
        object cache = this.safeValue(this.positions, type);
        if (isTrue(isTrue(isTrue(fetchPositionsSnapshot) && isTrue(awaitPositionsSnapshot)) && isTrue(isEqual(cache, null))))
        {
            return await client.future(add(type, ":fetchPositionsSnapshot"));
        }
        object positions = await this.subscribePrivate(url, messageHash, payload, channel, query, true);
        if (isTrue(this.newUpdates))
        {
            return positions;
        }
        return this.filterBySymbolsSinceLimit(getValue(this.positions, type), symbols, since, limit, true);
    }

    public virtual void setPositionsCache(WebSocketClient client, object type, object symbols = null)
    {
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new Dictionary<string, object>() {};
        }
        if (isTrue(inOp(this.positions, type)))
        {
            return;
        }
        object fetchPositionsSnapshot = this.handleOption("watchPositions", "fetchPositionsSnapshot", false);
        if (isTrue(fetchPositionsSnapshot))
        {
            object messageHash = add(type, ":fetchPositionsSnapshot");
            if (!isTrue((inOp(client.futures, messageHash))))
            {
                client.future(messageHash);
                this.spawn(this.loadPositionsSnapshot, new object[] { client, messageHash, type});
            }
        } else
        {
            ((IDictionary<string,object>)this.positions)[(string)type] = new ArrayCacheBySymbolBySide();
        }
    }

    public async virtual Task loadPositionsSnapshot(WebSocketClient client, object messageHash, object type)
    {
        object positions = await this.fetchPositions(null, new Dictionary<string, object>() {
            { "type", type },
        });
        ((IDictionary<string,object>)this.positions)[(string)type] = new ArrayCacheBySymbolBySide();
        object cache = getValue(this.positions, type);
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object position = getValue(positions, i);
            callDynamically(cache, "append", new object[] {position});
        }
        // don't remove the future from the .futures cache
        var future = getValue(client.futures, messageHash);
        (future as Future).resolve(cache);
        callDynamically(client as WebSocketClient, "resolve", new object[] {cache, add(type, ":position")});
    }

    public virtual void handlePositions(WebSocketClient client, object message)
    {
        //
        //    {
        //        time: 1693158497,
        //        time_ms: 1693158497204,
        //        channel: 'futures.positions',
        //        event: 'update',
        //        result: [{
        //            contract: 'XRP_USDT',
        //            cross_leverage_limit: 0,
        //            entry_price: 0.5253,
        //            history_pnl: 0,
        //            history_point: 0,
        //            last_close_pnl: 0,
        //            leverage: 0,
        //            leverage_max: 50,
        //            liq_price: 0.0361,
        //            maintenance_rate: 0.01,
        //            margin: 4.89609962852,
        //            mode: 'single',
        //            realised_pnl: -0.0026265,
        //            realised_point: 0,
        //            risk_limit: 500000,
        //            size: 1,
        //            time: 1693158497,
        //            time_ms: 1693158497195,
        //            update_id: 1,
        //            user: '10444586'
        //        }]
        //    }
        //
        object type = this.getMarketTypeByUrl(client.url);
        object data = this.safeValue(message, "result", new List<object>() {});
        object cache = getValue(this.positions, type);
        object newPositions = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object rawPosition = getValue(data, i);
            object position = this.parsePosition(rawPosition);
            ((IList<object>)newPositions).Add(position);
            callDynamically(cache, "append", new object[] {position});
        }
        object messageHashes = this.findMessageHashes(client as WebSocketClient, add(type, ":positions::"));
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object positions = this.filterByArray(newPositions, "symbol", symbols, false);
            if (!isTrue(this.isEmpty(positions)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {positions, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newPositions, add(type, ":positions")});
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#watchOrders
        * @description watches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.type] spot, margin, swap, future, or option. Required if listening to all symbols.
        * @param {boolean} [params.isInverse] if future, listen to inverse or linear contracts
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        object type = null;
        object query = null;
        var typequeryVariable = this.handleMarketTypeAndParams("watchOrders", market, parameters);
        type = ((IList<object>)typequeryVariable)[0];
        query = ((IList<object>)typequeryVariable)[1];
        object typeId = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "spot", "spot" },
            { "margin", "spot" },
            { "future", "futures" },
            { "swap", "futures" },
            { "option", "options" },
        });
        object channel = add(typeId, ".orders");
        object messageHash = "orders";
        object payload = new List<object>() {add("!", "all")};
        if (isTrue(!isEqual(symbol, null)))
        {
            messageHash = add(messageHash, add(":", getValue(market, "id")));
            payload = new List<object>() {getValue(market, "id")};
        }
        object subType = null;
        var subTypequeryVariable = this.handleSubTypeAndParams("watchOrders", market, query);
        subType = ((IList<object>)subTypequeryVariable)[0];
        query = ((IList<object>)subTypequeryVariable)[1];
        object isInverse = (isEqual(subType, "inverse"));
        object url = this.getUrlByMarketType(type, isInverse);
        // uid required for non spot markets
        object requiresUid = (!isEqual(type, "spot"));
        object orders = await this.subscribePrivate(url, messageHash, payload, channel, query, requiresUid);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(orders, since, limit, "timestamp", true);
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        //
        // {
        //     "time": 1605175506,
        //     "channel": "spot.orders",
        //     "event": "update",
        //     "result": [
        //       {
        //         "id": "30784435",
        //         "user": 123456,
        //         "text": "t-abc",
        //         "create_time": "1605175506",
        //         "create_time_ms": "1605175506123",
        //         "update_time": "1605175506",
        //         "update_time_ms": "1605175506123",
        //         "event": "put",
        //         "currency_pair": "BTC_USDT",
        //         "type": "limit",
        //         "account": "spot",
        //         "side": "sell",
        //         "amount": "1",
        //         "price": "10001",
        //         "time_in_force": "gtc",
        //         "left": "1",
        //         "filled_total": "0",
        //         "fee": "0",
        //         "fee_currency": "USDT",
        //         "point_fee": "0",
        //         "gt_fee": "0",
        //         "gt_discount": true,
        //         "rebated_fee": "0",
        //         "rebated_fee_currency": "USDT"
        //       }
        //     ]
        // }
        //
        object orders = this.safeValue(message, "result", new List<object>() {});
        object limit = this.safeInteger(this.options, "ordersLimit", 1000);
        if (isTrue(isEqual(this.orders, null)))
        {
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object stored = this.orders;
        object marketIds = new Dictionary<string, object>() {};
        object parsedOrders = this.parseOrders(orders);
        for (object i = 0; isLessThan(i, getArrayLength(parsedOrders)); postFixIncrement(ref i))
        {
            object parsed = getValue(parsedOrders, i);
            // inject order status
            object info = this.safeValue(parsed, "info");
            object eventVar = this.safeString(info, "event");
            if (isTrue(isTrue(isEqual(eventVar, "put")) || isTrue(isEqual(eventVar, "update"))))
            {
                ((IDictionary<string,object>)parsed)["status"] = "open";
            } else if (isTrue(isEqual(eventVar, "finish")))
            {
                object status = this.safeString(parsed, "status");
                if (isTrue(isEqual(status, null)))
                {
                    object left = this.safeNumber(info, "left");
                    ((IDictionary<string,object>)parsed)["status"] = ((bool) isTrue((isEqual(left, 0)))) ? "closed" : "canceled";
                }
            }
            callDynamically(stored, "append", new object[] {parsed});
            object symbol = getValue(parsed, "symbol");
            object market = this.market(symbol);
            ((IDictionary<string,object>)marketIds)[(string)getValue(market, "id")] = true;
        }
        object keys = new List<object>(((IDictionary<string,object>)marketIds).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object messageHash = add("orders:", getValue(keys, i));
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageHash});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, "orders"});
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        // {
        //     "time": 1647274664,
        //     "channel": "futures.orders",
        //     "event": "subscribe",
        //     "error": { code: 2, message: "unknown contract BTC_USDT_20220318" },
        // }
        // {
        //     "time": 1647276473,
        //     "channel": "futures.orders",
        //     "event": "subscribe",
        //     "error": {
        //       "code": 4,
        //       "message": "{"label":"INVALID_KEY","message":"Invalid key provided"}\n"
        //     },
        //     "result": null
        //   }
        object error = this.safeValue(message, "error");
        object code = this.safeInteger(error, "code");
        object id = this.safeString(message, "id");
        if (isTrue(isEqual(id, null)))
        {
            return false;
        }
        if (isTrue(!isEqual(code, null)))
        {
            object messageHash = this.safeString(((WebSocketClient)client).subscriptions, id);
            if (isTrue(!isEqual(messageHash, null)))
            {
                try
                {
                    this.throwExactlyMatchedException(getValue(getValue(this.exceptions, "ws"), "exact"), code, this.json(message));
                } catch(Exception e)
                {
                    ((WebSocketClient)client).reject(e, messageHash);
                    if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
                    {

                    }
                }
            }

            return true;
        }
        return false;
    }

    public virtual void handleBalanceSubscription(WebSocketClient client, object message, object subscription = null)
    {
        this.balance = new Dictionary<string, object>() {};
    }

    public virtual void handleSubscriptionStatus(WebSocketClient client, object message)
    {
        object channel = this.safeString(message, "channel");
        object methods = new Dictionary<string, object>() {
            { "balance", this.handleBalanceSubscription },
            { "spot.order_book_update", this.handleOrderBookSubscription },
            { "futures.order_book_update", this.handleOrderBookSubscription },
        };
        object id = this.safeString(message, "id");
        if (isTrue(inOp(methods, channel)))
        {
            object subscriptionHash = this.safeString(((WebSocketClient)client).subscriptions, id);
            object subscription = this.safeValue(((WebSocketClient)client).subscriptions, subscriptionHash);
            object method = getValue(methods, channel);
            DynamicInvoker.InvokeMethod(method, new object[] { client, message, subscription});
        }
        if (isTrue(inOp(((WebSocketClient)client).subscriptions, id)))
        {

        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        //
        // subscribe
        //    {
        //        "time": 1649062304,
        //        "id": 1649062303,
        //        "channel": "spot.candlesticks",
        //        "event": "subscribe",
        //        "result": { status: "success" }
        //    }
        //
        // candlestick
        //    {
        //        "time": 1649063328,
        //        "channel": "spot.candlesticks",
        //        "event": "update",
        //        "result": {
        //          "t": "1649063280",
        //          "v": "58932.23174896",
        //          "c": "45966.47",
        //          "h": "45997.24",
        //          "l": "45966.47",
        //          "o": "45975.18",
        //          "n": "1m_BTC_USDT",
        //          "a": "1.281699"
        //        }
        //     }
        //
        //  orders
        //   {
        //       "time": 1630654851,
        //       "channel": "options.orders", or futures.orders or spot.orders
        //       "event": "update",
        //       "result": [
        //          {
        //             "contract": "BTC_USDT-20211130-65000-C",
        //             "create_time": 1637897000,
        //               (...)
        //       ]
        //   }
        // orderbook
        //   {
        //       "time": 1649770525,
        //       "channel": "spot.order_book_update",
        //       "event": "update",
        //       "result": {
        //         "t": 1649770525653,
        //         "e": "depthUpdate",
        //         "E": 1649770525,
        //         "s": "LTC_USDT",
        //         "U": 2622525645,
        //         "u": 2622525665,
        //         "b": [
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array]
        //         ],
        //         "a": [
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array]
        //         ]
        //       }
        //     }
        //
        // balance update
        //
        //    {
        //        "time": 1653664351,
        //        "channel": "spot.balances",
        //        "event": "update",
        //        "result": [
        //          {
        //            "timestamp": "1653664351",
        //            "timestamp_ms": "1653664351017",
        //            "user": "10406147",
        //            "currency": "LTC",
        //            "change": "-0.0002000000000000",
        //            "total": "0.09986000000000000000",
        //            "available": "0.09986000000000000000"
        //          }
        //        ]
        //    }
        //
        if (isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            return;
        }
        object eventVar = this.safeString(message, "event");
        if (isTrue(isEqual(eventVar, "subscribe")))
        {
            this.handleSubscriptionStatus(client as WebSocketClient, message);
            return;
        }
        object channel = this.safeString(message, "channel", "");
        object channelParts = ((string)channel).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object channelType = this.safeValue(channelParts, 1);
        object v4Methods = new Dictionary<string, object>() {
            { "usertrades", this.handleMyTrades },
            { "candlesticks", this.handleOHLCV },
            { "orders", this.handleOrder },
            { "positions", this.handlePositions },
            { "tickers", this.handleTicker },
            { "book_ticker", this.handleBidAsk },
            { "trades", this.handleTrades },
            { "order_book_update", this.handleOrderBook },
            { "balances", this.handleBalance },
        };
        object method = this.safeValue(v4Methods, channelType);
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
    }

    public virtual object getUrlByMarket(object market)
    {
        object baseUrl = getValue(getValue(this.urls, "api"), getValue(market, "type"));
        if (isTrue(getValue(market, "contract")))
        {
            return ((bool) isTrue(getValue(market, "linear"))) ? getValue(baseUrl, "usdt") : getValue(baseUrl, "btc");
        } else
        {
            return baseUrl;
        }
    }

    public virtual object getTypeByMarket(object market)
    {
        if (isTrue(getValue(market, "spot")))
        {
            return "spot";
        } else if (isTrue(getValue(market, "option")))
        {
            return "options";
        } else
        {
            return "futures";
        }
    }

    public virtual object getUrlByMarketType(object type, object isInverse = null)
    {
        isInverse ??= false;
        object api = getValue(this.urls, "api");
        object url = getValue(api, type);
        if (isTrue(isTrue((isEqual(type, "swap"))) || isTrue((isEqual(type, "future")))))
        {
            return ((bool) isTrue(isInverse)) ? getValue(url, "btc") : getValue(url, "usdt");
        } else
        {
            return url;
        }
    }

    public virtual object getMarketTypeByUrl(object url)
    {
        object findBy = new Dictionary<string, object>() {
            { "op-", "option" },
            { "delivery", "future" },
            { "fx", "swap" },
        };
        object keys = new List<object>(((IDictionary<string,object>)findBy).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object value = getValue(findBy, key);
            if (isTrue(isGreaterThanOrEqual(getIndexOf(url, key), 0)))
            {
                return value;
            }
        }
        return "spot";
    }

    public virtual object requestId()
    {
        // their support said that reqid must be an int32, not documented
        object reqid = this.sum(this.safeInteger(this.options, "reqid", 0), 1);
        ((IDictionary<string,object>)this.options)["reqid"] = reqid;
        return reqid;
    }

    public async virtual Task<object> subscribePublic(object url, object messageHash, object payload, object channel, object parameters = null, object subscription = null)
    {
        parameters ??= new Dictionary<string, object>();
        object requestId = this.requestId();
        object time = this.seconds();
        object request = new Dictionary<string, object>() {
            { "id", requestId },
            { "time", time },
            { "channel", channel },
            { "event", "subscribe" },
            { "payload", payload },
        };
        if (isTrue(!isEqual(subscription, null)))
        {
            var client = this.client(url);
            if (!isTrue((inOp(((WebSocketClient)client).subscriptions, messageHash))))
            {
                object tempSubscriptionHash = ((object)requestId).ToString();
                ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)tempSubscriptionHash] = messageHash;
            }
        }
        object message = this.extend(request, parameters);
        return await this.watch(url, messageHash, message, messageHash, subscription);
    }

    public async virtual Task<object> subscribePublicMultiple(object url, object messageHashes, object payload, object channel, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object requestId = this.requestId();
        object time = this.seconds();
        object request = new Dictionary<string, object>() {
            { "id", requestId },
            { "time", time },
            { "channel", channel },
            { "event", "subscribe" },
            { "payload", payload },
        };
        object message = this.extend(request, parameters);
        return await this.watchMultiple(url, messageHashes, message, messageHashes);
    }

    public async virtual Task<object> subscribePrivate(object url, object messageHash, object payload, object channel, object parameters, object requiresUid = null)
    {
        requiresUid ??= false;
        this.checkRequiredCredentials();
        // uid is required for some subscriptions only so it's not a part of required credentials
        if (isTrue(requiresUid))
        {
            if (isTrue(isTrue(isEqual(this.uid, null)) || isTrue(isEqual(((string)this.uid).Length, 0))))
            {
                throw new ArgumentsRequired ((string)add(this.id, " requires uid to subscribe")) ;
            }
            object idArray = new List<object>() {this.uid};
            if (isTrue(isEqual(payload, null)))
            {
                payload = idArray;
            } else
            {
                payload = this.arrayConcat(idArray, payload);
            }
        }
        object time = this.seconds();
        object eventVar = "subscribe";
        object signaturePayload = add(add(add(add(add(add(add("channel=", channel), "&"), "event="), eventVar), "&"), "time="), ((object)time).ToString());
        object signature = this.hmac(this.encode(signaturePayload), this.encode(this.secret), sha512, "hex");
        object auth = new Dictionary<string, object>() {
            { "method", "api_key" },
            { "KEY", this.apiKey },
            { "SIGN", signature },
        };
        object requestId = this.requestId();
        object request = new Dictionary<string, object>() {
            { "id", requestId },
            { "time", time },
            { "channel", channel },
            { "event", "subscribe" },
            { "auth", auth },
        };
        if (isTrue(!isEqual(payload, null)))
        {
            ((IDictionary<string,object>)request)["payload"] = payload;
        }
        var client = this.client(url);
        if (!isTrue((inOp(((WebSocketClient)client).subscriptions, messageHash))))
        {
            object tempSubscriptionHash = ((object)requestId).ToString();
            // in case of authenticationError we will throw
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)tempSubscriptionHash] = messageHash;
        }
        object message = this.extend(request, parameters);
        return await this.watch(url, messageHash, message, messageHash);
    }
}
