namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class gate { public gate(object args = null) : base(args) { } }
public partial class gate : ccxt.gate
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "cancelAllOrdersWs", true },
                { "cancelOrderWs", true },
                { "createMarketBuyOrderWithCostWs", true },
                { "createMarketOrderWs", true },
                { "createMarketOrderWithCostWs", false },
                { "createMarketSellOrderWithCostWs", false },
                { "createOrderWs", true },
                { "createOrdersWs", true },
                { "createPostOnlyOrderWs", true },
                { "createReduceOnlyOrderWs", true },
                { "createStopLimitOrderWs", true },
                { "createStopLossOrderWs", true },
                { "createStopMarketOrderWs", false },
                { "createStopOrderWs", true },
                { "createTakeProfitOrderWs", true },
                { "createTriggerOrderWs", true },
                { "editOrderWs", true },
                { "fetchOrderWs", true },
                { "fetchOrdersWs", false },
                { "fetchOpenOrdersWs", true },
                { "fetchClosedOrdersWs", true },
                { "watchOrderBook", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
                { "watchMyTrades", true },
                { "watchOHLCV", true },
                { "watchBalance", true },
                { "watchOrders", true },
                { "watchLiquidations", false },
                { "watchLiquidationsForSymbols", false },
                { "watchMyLiquidations", true },
                { "watchMyLiquidationsForSymbols", true },
                { "watchPositions", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", "wss://ws.gate.io/v4" },
                    { "spot", "wss://api.gateio.ws/ws/v4/" },
                    { "swap", new Dictionary<string, object>() {
                        { "usdt", "wss://fx-ws.gateio.ws/v4/ws/usdt" },
                        { "btc", "wss://fx-ws.gateio.ws/v4/ws/btc" },
                    } },
                    { "future", new Dictionary<string, object>() {
                        { "usdt", "wss://fx-ws.gateio.ws/v4/ws/delivery/usdt" },
                        { "btc", "wss://fx-ws.gateio.ws/v4/ws/delivery/btc" },
                    } },
                    { "option", new Dictionary<string, object>() {
                        { "usdt", "wss://op-ws.gateio.live/v4/ws/usdt" },
                        { "btc", "wss://op-ws.gateio.live/v4/ws/btc" },
                    } },
                } },
                { "test", new Dictionary<string, object>() {
                    { "swap", new Dictionary<string, object>() {
                        { "usdt", "wss://fx-ws-testnet.gateio.ws/v4/ws/usdt" },
                        { "btc", "wss://fx-ws-testnet.gateio.ws/v4/ws/btc" },
                    } },
                    { "future", new Dictionary<string, object>() {
                        { "usdt", "wss://fx-ws-testnet.gateio.ws/v4/ws/usdt" },
                        { "btc", "wss://fx-ws-testnet.gateio.ws/v4/ws/btc" },
                    } },
                    { "option", new Dictionary<string, object>() {
                        { "usdt", "wss://op-ws-testnet.gateio.live/v4/ws/usdt" },
                        { "btc", "wss://op-ws-testnet.gateio.live/v4/ws/btc" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "tradesLimit", 1000 },
                { "OHLCVLimit", 1000 },
                { "watchTradesSubscriptions", new Dictionary<string, object>() {} },
                { "watchTickerSubscriptions", new Dictionary<string, object>() {} },
                { "watchOrderBookSubscriptions", new Dictionary<string, object>() {} },
                { "watchTicker", new Dictionary<string, object>() {
                    { "name", "tickers" },
                } },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "interval", "100ms" },
                    { "snapshotDelay", 10 },
                    { "snapshotMaxRetries", 3 },
                    { "checksum", true },
                } },
                { "watchBalance", new Dictionary<string, object>() {
                    { "settle", "usdt" },
                    { "spot", "spot.balances" },
                } },
                { "watchPositions", new Dictionary<string, object>() {
                    { "fetchPositionsSnapshot", true },
                    { "awaitPositionsSnapshot", true },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "ws", new Dictionary<string, object>() {
                    { "exact", new Dictionary<string, object>() {
                        { "1", typeof(BadRequest) },
                        { "2", typeof(BadRequest) },
                        { "4", typeof(AuthenticationError) },
                        { "6", typeof(AuthenticationError) },
                        { "11", typeof(AuthenticationError) },
                    } },
                    { "broad", new Dictionary<string, object>() {} },
                } },
            } },
        });
    }

    /**
     * @method
     * @name gate#createOrderWs
     * @see https://www.gate.io/docs/developers/apiv4/ws/en/#order-place
     * @see https://www.gate.io/docs/developers/futures/ws/en/#order-place
     * @description Create an order on the exchange
     * @param {string} symbol Unified CCXT market symbol
     * @param {string} type 'limit' or 'market' *"market" is contract only*
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount the amount of currency to trade
     * @param {float} [price] *ignored in "market" orders* the price at which the order is to be fulfilled at in units of the quote currency
     * @param {object} [params]  extra parameters specific to the exchange API endpoint
     * @param {float} [params.stopPrice] The price at which a trigger order is triggered at
     * @param {string} [params.timeInForce] "GTC", "IOC", or "PO"
     * @param {float} [params.stopLossPrice] The price at which a stop loss order is triggered at
     * @param {float} [params.takeProfitPrice] The price at which a take profit order is triggered at
     * @param {string} [params.marginMode] 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
     * @param {int} [params.iceberg] Amount to display for the iceberg order, Null or 0 for normal orders, Set to -1 to hide the order completely
     * @param {string} [params.text] User defined information
     * @param {string} [params.account] *spot and margin only* "spot", "margin" or "cross_margin"
     * @param {bool} [params.auto_borrow] *margin only* Used in margin or cross margin trading to allow automatic loan of insufficient amount if balance is not enough
     * @param {string} [params.settle] *contract only* Unified Currency Code for settle currency
     * @param {bool} [params.reduceOnly] *contract only* Indicates if this order is to reduce the size of a position
     * @param {bool} [params.close] *contract only* Set as true to close the position, with size set to 0
     * @param {bool} [params.auto_size] *contract only* Set side to close dual-mode position, close_long closes the long side, while close_short the short one, size also needs to be set to 0
     * @param {int} [params.price_type] *contract only* 0 latest deal price, 1 mark price, 2 index price
     * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
     * @returns {object|undefined} [An order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrderWs(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object messageType = this.getTypeByMarket(market);
        object channel = add(messageType, ".order_place");
        object url = this.getUrlByMarket(market);
        ((IDictionary<string,object>)parameters)["textIsRequired"] = true;
        object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        await this.authenticate(url, messageType);
        object rawOrder = await this.requestPrivate(url, request, channel);
        object order = this.parseOrder(rawOrder, market);
        return order;
    }

    /**
     * @method
     * @name gate#createOrdersWs
     * @description create a list of trade orders
     * @see https://www.gate.io/docs/developers/futures/ws/en/#order-batch-place
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> createOrdersWs(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = this.createOrdersRequest(orders, parameters);
        object firstOrder = getValue(orders, 0);
        object market = this.market(getValue(firstOrder, "symbol"));
        if (isTrue(!isEqual(getValue(market, "swap"), true)))
        {
            throw new NotSupported ((string)add(this.id, " createOrdersWs is not supported for swap markets")) ;
        }
        object messageType = this.getTypeByMarket(market);
        object channel = add(messageType, ".order_batch_place");
        object url = this.getUrlByMarket(market);
        await this.authenticate(url, messageType);
        object rawOrders = await this.requestPrivate(url, request, channel);
        return this.parseOrders(rawOrders, market);
    }

    /**
     * @method
     * @name gate#cancelAllOrdersWs
     * @description cancel all open orders
     * @see https://www.gate.io/docs/developers/futures/ws/en/#cancel-all-open-orders-matched
     * @see https://www.gate.io/docs/developers/apiv4/ws/en/#order-cancel-all-with-specified-currency-pair
     * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.channel] the channel to use, defaults to spot.order_cancel_cp or futures.order_cancel_cp
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrdersWs(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = ((bool) isTrue((isEqual(symbol, null)))) ? null : this.market(symbol);
        object stop = this.safeBool2(parameters, "stop", "trigger");
        object messageType = this.getTypeByMarket(market);
        object channel = add(messageType, ".order_cancel_cp");
        var channelparametersVariable = this.handleOptionAndParams(parameters, "cancelAllOrdersWs", "channel", channel);
        channel = ((IList<object>)channelparametersVariable)[0];
        parameters = ((IList<object>)channelparametersVariable)[1];
        object url = this.getUrlByMarket(market);
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        var typequeryVariable = this.handleMarketTypeAndParams("cancelAllOrders", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        var requestrequestParamsVariable = ((bool) isTrue((isEqual(type, "spot")))) ? this.multiOrderSpotPrepareRequest(market, stop, query) : this.prepareRequest(market, type, query);
        var request = ((IList<object>) requestrequestParamsVariable)[0];
        var requestParams = ((IList<object>) requestrequestParamsVariable)[1];
        await this.authenticate(url, messageType);
        object rawOrders = await this.requestPrivate(url, this.extend(request, requestParams), channel);
        return this.parseOrders(rawOrders, market);
    }

    /**
     * @method
     * @name gate#cancelOrderWs
     * @description Cancels an open order
     * @see https://www.gate.io/docs/developers/apiv4/ws/en/#order-cancel
     * @see https://www.gate.io/docs/developers/futures/ws/en/#order-cancel
     * @param {string} id Order id
     * @param {string} symbol Unified market symbol
     * @param {object} [params] Parameters specified by the exchange api
     * @param {bool} [params.stop] True if the order to be cancelled is a trigger order
     * @returns An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrderWs(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = ((bool) isTrue((isEqual(symbol, null)))) ? null : this.market(symbol);
        object stop = this.safeValueN(parameters, new List<object>() {"is_stop_order", "stop", "trigger"}, false);
        parameters = this.omit(parameters, new List<object>() {"is_stop_order", "stop", "trigger"});
        var typequeryVariable = this.handleMarketTypeAndParams("cancelOrder", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        var requestrequestParamsVariable = ((bool) isTrue((isTrue(isEqual(type, "spot")) || isTrue(isEqual(type, "margin"))))) ? this.spotOrderPrepareRequest(market, stop, query) : this.prepareRequest(market, type, query);
        var request = ((IList<object>) requestrequestParamsVariable)[0];
        var requestParams = ((IList<object>) requestrequestParamsVariable)[1];
        object messageType = this.getTypeByMarket(market);
        object channel = add(messageType, ".order_cancel");
        object url = this.getUrlByMarket(market);
        await this.authenticate(url, messageType);
        ((IDictionary<string,object>)request)["order_id"] = ((object)id).ToString();
        object res = await this.requestPrivate(url, this.extend(request, requestParams), channel);
        return this.parseOrder(res, market);
    }

    /**
     * @method
     * @name gate#editOrderWs
     * @description edit a trade order, gate currently only supports the modification of the price or amount fields
     * @see https://www.gate.io/docs/developers/apiv4/ws/en/#order-amend
     * @see https://www.gate.io/docs/developers/futures/ws/en/#order-amend
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of the currency you want to trade in units of the base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> editOrderWs(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object extendedRequest = this.editOrderRequest(id, symbol, type, side, amount, price, parameters);
        object messageType = this.getTypeByMarket(market);
        object channel = add(messageType, ".order_amend");
        object url = this.getUrlByMarket(market);
        await this.authenticate(url, messageType);
        object rawOrder = await this.requestPrivate(url, extendedRequest, channel);
        return this.parseOrder(rawOrder, market);
    }

    /**
     * @method
     * @name gate#fetchOrderWs
     * @description Retrieves information on an order
     * @see https://www.gate.io/docs/developers/apiv4/ws/en/#order-status
     * @see https://www.gate.io/docs/developers/futures/ws/en/#order-status
     * @param {string} id Order id
     * @param {string} symbol Unified market symbol, *required for spot and margin*
     * @param {object} [params] Parameters specified by the exchange api
     * @param {bool} [params.stop] True if the order being fetched is a trigger order
     * @param {string} [params.marginMode] 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
     * @param {string} [params.type] 'spot', 'swap', or 'future', if not provided this.options['defaultMarginMode'] is used
     * @param {string} [params.settle] 'btc' or 'usdt' - settle currency for perpetual swap and future - market settle currency is used if symbol !== undefined, default="usdt" for swap and "btc" for future
     * @returns An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrderWs(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = ((bool) isTrue((isEqual(symbol, null)))) ? null : this.market(symbol);
        var requestrequestParamsVariable = this.fetchOrderRequest(id, symbol, parameters);
        var request = ((IList<object>) requestrequestParamsVariable)[0];
        var requestParams = ((IList<object>) requestrequestParamsVariable)[1];
        object messageType = this.getTypeByMarket(market);
        object channel = add(messageType, ".order_status");
        object url = this.getUrlByMarket(market);
        await this.authenticate(url, messageType);
        object rawOrder = await this.requestPrivate(url, this.extend(request, requestParams), channel);
        return this.parseOrder(rawOrder, market);
    }

    /**
     * @method
     * @name gate#fetchOpenOrdersWs
     * @description fetch all unfilled currently open orders
     * @see https://www.gate.io/docs/developers/futures/ws/en/#order-list
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of  open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrdersWs(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatusWs("open", symbol, since, limit, parameters);
    }

    /**
     * @method
     * @name gate#fetchClosedOrdersWs
     * @description fetches information on multiple closed orders made by the user
     * @see https://www.gate.io/docs/developers/futures/ws/en/#order-list
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrdersWs(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatusWs("finished", symbol, since, limit, parameters);
    }

    /**
     * @method
     * @name gate#fetchOrdersWs
     * @see https://www.gate.io/docs/developers/futures/ws/en/#order-list
     * @description fetches information on multiple orders made by the user by status
     * @param {string} status requested order status
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int|undefined} [since] the earliest time in ms to fetch orders for
     * @param {int|undefined} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.orderId] order id to begin at
     * @param {int} [params.limit] the maximum number of order structures to retrieve
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchOrdersByStatusWs(object status, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            if (isTrue(!isEqual(getValue(market, "swap"), true)))
            {
                throw new NotSupported ((string)add(this.id, " fetchOrdersByStatusWs is only supported by swap markets. Use rest API for other markets")) ;
            }
        }
        var requestrequestParamsVariable = this.prepareOrdersByStatusRequest(status, symbol, since, limit, parameters);
        var request = ((IList<object>) requestrequestParamsVariable)[0];
        var requestParams = ((IList<object>) requestrequestParamsVariable)[1];
        object newRequest = this.omit(request, new List<object>() {"settle"});
        object messageType = this.getTypeByMarket(market);
        object channel = add(messageType, ".order_list");
        object url = this.getUrlByMarket(market);
        await this.authenticate(url, messageType);
        object rawOrders = await this.requestPrivate(url, this.extend(newRequest, requestParams), channel);
        object orders = this.parseOrders(rawOrders, market);
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit);
    }

    /**
     * @method
     * @name gate#watchOrderBook
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object marketId = getValue(market, "id");
        var intervalqueryVariable = this.handleOptionAndParams(parameters, "watchOrderBook", "interval", "100ms");
        var interval = ((IList<object>) intervalqueryVariable)[0];
        var query = ((IList<object>) intervalqueryVariable)[1];
        object messageType = this.getTypeByMarket(market);
        object channel = add(messageType, ".order_book_update");
        object messageHash = add(add("orderbook", ":"), symbol);
        object url = this.getUrlByMarket(market);
        object payload = new List<object>() {marketId, interval};
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100;
        }
        if (isTrue(getValue(market, "contract")))
        {
            object stringLimit = ((object)limit).ToString();
            ((IList<object>)payload).Add(stringLimit);
        }
        object subscription = new Dictionary<string, object>() {
            { "symbol", symbol },
            { "limit", limit },
        };
        object orderbook = await this.subscribePublic(url, messageHash, payload, channel, query, subscription);
        return (orderbook as IOrderBook).limit();
    }

    /**
     * @method
     * @name gate#unWatchOrderBook
     * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> unWatchOrderBook(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object marketId = getValue(market, "id");
        object interval = "100ms";
        var intervalparametersVariable = this.handleOptionAndParams(parameters, "watchOrderBook", "interval", interval);
        interval = ((IList<object>)intervalparametersVariable)[0];
        parameters = ((IList<object>)intervalparametersVariable)[1];
        object messageType = this.getTypeByMarket(market);
        object channel = add(messageType, ".order_book_update");
        object subMessageHash = add(add("orderbook", ":"), symbol);
        object messageHash = add(add("unsubscribe:orderbook", ":"), symbol);
        object url = this.getUrlByMarket(market);
        object payload = new List<object>() {marketId, interval};
        object limit = this.safeInteger(parameters, "limit", 100);
        if (isTrue(getValue(market, "contract")))
        {
            object stringLimit = ((object)limit).ToString();
            ((IList<object>)payload).Add(stringLimit);
        }
        return await this.unSubscribePublicMultiple(url, "orderbook", new List<object>() {symbol}, new List<object>() {messageHash}, new List<object>() {subMessageHash}, payload, channel, parameters);
    }

    public virtual void handleOrderBookSubscription(WebSocketClient client, object message, object subscription)
    {
        object symbol = this.safeString(subscription, "symbol");
        object limit = this.safeInteger(subscription, "limit");
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //     {
        //         "time": 1650189272,
        //         "channel": "spot.order_book_update",
        //         "event": "update",
        //         "result": {
        //             "t": 1650189272515,
        //             "e": "depthUpdate",
        //             "E": 1650189272,
        //             "s": "GMT_USDT",
        //             "U": 140595902,
        //             "u": 140595902,
        //             "b": [
        //                 [ '2.51518', "228.119" ],
        //                 [ '2.50587', "1510.11" ],
        //                 [ '2.49944', "67.6" ],
        //             ],
        //             "a": [
        //                 [ '2.5182', "4.199" ],
        //                 [ "2.51926", "1874" ],
        //                 [ '2.53528', "96.529" ],
        //             ]
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         "id": null,
        //         "time": 1650188898,
        //         "channel": "futures.order_book_update",
        //         "event": "update",
        //         "error": null,
        //         "result": {
        //             "t": 1650188898938,
        //             "s": "GMT_USDT",
        //             "U": 1577718307,
        //             "u": 1577719254,
        //             "b": [
        //                 { p: "2.5178", s: 0 },
        //                 { p: "2.5179", s: 0 },
        //                 { p: "2.518", s: 0 },
        //             ],
        //             "a": [
        //                 { p: "2.52", s: 0 },
        //                 { p: "2.5201", s: 0 },
        //                 { p: "2.5203", s: 0 },
        //             ]
        //         }
        //     }
        //
        object channel = this.safeString(message, "channel");
        object channelParts = ((string)channel).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object rawMarketType = this.safeString(channelParts, 0);
        object isSpot = isEqual(rawMarketType, "spot");
        object marketType = ((bool) isTrue(isSpot)) ? "spot" : "contract";
        object delta = this.safeValue(message, "result");
        object deltaStart = this.safeInteger(delta, "U");
        object deltaEnd = this.safeInteger(delta, "u");
        object marketId = this.safeString(delta, "s");
        object symbol = this.safeSymbol(marketId, null, "_", marketType);
        object messageHash = add("orderbook:", symbol);
        object storedOrderBook = this.safeValue(this.orderbooks, symbol, this.orderBook(new Dictionary<string, object>() {}));
        object nonce = this.safeInteger(storedOrderBook, "nonce");
        if (isTrue(isEqual(nonce, null)))
        {
            object cacheLength = 0;
            if (isTrue(!isEqual(storedOrderBook, null)))
            {
                cacheLength = getArrayLength((storedOrderBook as ccxt.pro.OrderBook).cache);
            }
            object snapshotDelay = this.handleOption("watchOrderBook", "snapshotDelay", 10);
            object waitAmount = ((bool) isTrue(isSpot)) ? snapshotDelay : 0;
            if (isTrue(isEqual(cacheLength, waitAmount)))
            {
                // max limit is 100
                object subscription = getValue(((WebSocketClient)client).subscriptions, messageHash);
                object limit = this.safeInteger(subscription, "limit");
                this.spawn(this.loadOrderBook, new object[] { client, messageHash, symbol, limit, new Dictionary<string, object>() {}}); // needed for c#, number of args needs to match
            }
            ((IList<object>)(storedOrderBook as ccxt.pro.OrderBook).cache).Add(delta);
            return;
        } else if (isTrue(isGreaterThanOrEqual(nonce, deltaEnd)))
        {
            return;
        } else if (isTrue(isGreaterThanOrEqual(nonce, subtract(deltaStart, 1))))
        {
            this.handleDelta(storedOrderBook, delta);
        } else
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
            ((IDictionary<string,object>)this.orderbooks).Remove((string)symbol);
            object checksum = this.handleOption("watchOrderBook", "checksum", true);
            if (isTrue(checksum))
            {
                var error = new ChecksumError(add(add(this.id, " "), this.orderbookChecksumMessage(symbol)));
                ((WebSocketClient)client).reject(error, messageHash);
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {storedOrderBook, messageHash});
    }

    public override object getCacheIndex(object orderBook, object cache)
    {
        object nonce = this.safeInteger(orderBook, "nonce");
        object firstDelta = getValue(cache, 0);
        object firstDeltaStart = this.safeInteger(firstDelta, "U");
        if (isTrue(isLessThan(nonce, firstDeltaStart)))
        {
            return -1;
        }
        for (object i = 0; isLessThan(i, getArrayLength(cache)); postFixIncrement(ref i))
        {
            object delta = getValue(cache, i);
            object deltaStart = this.safeInteger(delta, "U");
            object deltaEnd = this.safeInteger(delta, "u");
            if (isTrue(isTrue((isGreaterThanOrEqual(nonce, subtract(deltaStart, 1)))) && isTrue((isLessThan(nonce, deltaEnd)))))
            {
                return i;
            }
        }
        return getArrayLength(cache);
    }

    public virtual void handleBidAsks(object bookSide, object bidAsks)
    {
        for (object i = 0; isLessThan(i, getArrayLength(bidAsks)); postFixIncrement(ref i))
        {
            object bidAsk = getValue(bidAsks, i);
            if (isTrue(((bidAsk is IList<object>) || (bidAsk.GetType().IsGenericType && bidAsk.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                (bookSide as IOrderBookSide).storeArray(this.parseBidAsk(bidAsk));
            } else
            {
                object price = this.safeFloat(bidAsk, "p");
                object amount = this.safeFloat(bidAsk, "s");
                (bookSide as IOrderBookSide).store(price, amount);
            }
        }
    }

    public override void handleDelta(object orderbook, object delta)
    {
        object timestamp = this.safeInteger(delta, "t");
        ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
        ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger(delta, "u");
        object bids = this.safeValue(delta, "b", new List<object>() {});
        object asks = this.safeValue(delta, "a", new List<object>() {});
        object storedBids = getValue(orderbook, "bids");
        object storedAsks = getValue(orderbook, "asks");
        this.handleBidAsks(storedBids, bids);
        this.handleBidAsks(storedAsks, asks);
    }

    /**
     * @method
     * @name gate#watchTicker
     * @see https://www.gate.io/docs/developers/apiv4/ws/en/#tickers-channel
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        ((IDictionary<string,object>)parameters)["callerMethodName"] = "watchTicker";
        object result = await this.watchTickers(new List<object>() {symbol}, parameters);
        return this.safeValue(result, symbol);
    }

    /**
     * @method
     * @name gate#watchTickers
     * @see https://www.gate.io/docs/developers/apiv4/ws/en/#tickers-channel
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.subscribeWatchTickersAndBidsAsks(symbols, "watchTickers", this.extend(new Dictionary<string, object>() {
            { "method", "tickers" },
        }, parameters));
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        //    {
        //        "time": 1649326221,
        //        "channel": "spot.tickers",
        //        "event": "update",
        //        "result": {
        //          "currency_pair": "BTC_USDT",
        //          "last": "43444.82",
        //          "lowest_ask": "43444.82",
        //          "highest_bid": "43444.81",
        //          "change_percentage": "-4.0036",
        //          "base_volume": "5182.5412425462",
        //          "quote_volume": "227267634.93123952",
        //          "high_24h": "47698",
        //          "low_24h": "42721.03"
        //        }
        //    }
        //
        this.handleTickerAndBidAsk("ticker", client, message);
    }

    /**
     * @method
     * @name gate#watchBidsAsks
     * @see https://www.gate.io/docs/developers/apiv4/ws/en/#best-bid-or-ask-price
     * @see https://www.gate.io/docs/developers/apiv4/ws/en/#order-book-channel
     * @description watches best bid & ask for symbols
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchBidsAsks(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.subscribeWatchTickersAndBidsAsks(symbols, "watchBidsAsks", this.extend(new Dictionary<string, object>() {
            { "method", "book_ticker" },
        }, parameters));
    }

    public virtual void handleBidAsk(WebSocketClient client, object message)
    {
        //
        //    {
        //        "time": 1671363004,
        //        "time_ms": 1671363004235,
        //        "channel": "spot.book_ticker",
        //        "event": "update",
        //        "result": {
        //          "t": 1671363004228,
        //          "u": 9793320464,
        //          "s": "BTC_USDT",
        //          "b": "16716.8",
        //          "B": "0.0134",
        //          "a": "16716.9",
        //          "A": "0.0353"
        //        }
        //    }
        //
        this.handleTickerAndBidAsk("bidask", client, message);
    }

    public async virtual Task<object> subscribeWatchTickersAndBidsAsks(object symbols = null, object callerMethodName = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        var callerMethodNameparametersVariable = this.handleParamString(parameters, "callerMethodName", callerMethodName);
        callerMethodName = ((IList<object>)callerMethodNameparametersVariable)[0];
        parameters = ((IList<object>)callerMethodNameparametersVariable)[1];
        symbols = this.marketSymbols(symbols, null, false);
        object market = this.market(getValue(symbols, 0));
        object messageType = this.getTypeByMarket(market);
        object marketIds = this.marketIds(symbols);
        object channelName = null;
        var channelNameparametersVariable = this.handleOptionAndParams(parameters, callerMethodName, "method");
        channelName = ((IList<object>)channelNameparametersVariable)[0];
        parameters = ((IList<object>)channelNameparametersVariable)[1];
        object url = this.getUrlByMarket(market);
        object channel = add(add(messageType, "."), channelName);
        object isWatchTickers = isGreaterThanOrEqual(getIndexOf(callerMethodName, "watchTicker"), 0);
        object prefix = ((bool) isTrue(isWatchTickers)) ? "ticker" : "bidask";
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            ((IList<object>)messageHashes).Add(add(add(prefix, ":"), symbol));
        }
        object tickerOrBidAsk = await this.subscribePublicMultiple(url, messageHashes, marketIds, channel, parameters);
        if (isTrue(this.newUpdates))
        {
            object items = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)items)[(string)getValue(tickerOrBidAsk, "symbol")] = tickerOrBidAsk;
            return items;
        }
        object result = ((bool) isTrue(isWatchTickers)) ? this.tickers : this.bidsasks;
        return this.filterByArray(result, "symbol", symbols, true);
    }

    public virtual void handleTickerAndBidAsk(object objectName, object client, object message)
    {
        object channel = this.safeString(message, "channel");
        object parts = ((string)channel).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object rawMarketType = this.safeString(parts, 0);
        object marketType = ((bool) isTrue((isEqual(rawMarketType, "futures")))) ? "contract" : "spot";
        object result = this.safeValue(message, "result");
        object results = new List<object>() {};
        if (isTrue(((result is IList<object>) || (result.GetType().IsGenericType && result.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            results = this.safeList(message, "result", new List<object>() {});
        } else
        {
            object rawTicker = this.safeDict(message, "result", new Dictionary<string, object>() {});
            results = new List<object>() {rawTicker};
        }
        object isTicker = (isEqual(objectName, "ticker")); // whether ticker or bid-ask
        for (object i = 0; isLessThan(i, getArrayLength(results)); postFixIncrement(ref i))
        {
            object rawTicker = getValue(results, i);
            object marketId = this.safeString(rawTicker, "s");
            object market = this.safeMarket(marketId, null, "_", marketType);
            object parsedItem = this.parseTicker(rawTicker, market);
            object symbol = getValue(parsedItem, "symbol");
            if (isTrue(isTicker))
            {
                ((IDictionary<string,object>)this.tickers)[(string)symbol] = parsedItem;
            } else
            {
                ((IDictionary<string,object>)this.bidsasks)[(string)symbol] = parsedItem;
            }
            object messageHash = add(add(objectName, ":"), symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {parsedItem, messageHash});
        }
    }

    /**
     * @method
     * @name gate#watchTrades
     * @description get the list of most recent trades for a particular symbol
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    /**
     * @method
     * @name gate#watchTradesForSymbols
     * @description get the list of most recent trades for a particular symbol
     * @param {string[]} symbols unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object marketIds = this.marketIds(symbols);
        object market = this.market(getValue(symbols, 0));
        object messageType = this.getTypeByMarket(market);
        object channel = add(messageType, ".trades");
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            ((IList<object>)messageHashes).Add(add("trades:", symbol));
        }
        object url = this.getUrlByMarket(market);
        object trades = await this.subscribePublicMultiple(url, messageHashes, marketIds, channel, parameters);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeValue(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    /**
     * @method
     * @name gate#unWatchTradesForSymbols
     * @description get the list of most recent trades for a particular symbol
     * @param {string[]} symbols unified symbol of the market to fetch trades for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> unWatchTradesForSymbols(object symbols, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object marketIds = this.marketIds(symbols);
        object market = this.market(getValue(symbols, 0));
        object messageType = this.getTypeByMarket(market);
        object channel = add(messageType, ".trades");
        object subMessageHashes = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            ((IList<object>)subMessageHashes).Add(add("trades:", symbol));
            ((IList<object>)messageHashes).Add(add("unsubscribe:trades:", symbol));
        }
        object url = this.getUrlByMarket(market);
        return await this.unSubscribePublicMultiple(url, "trades", symbols, messageHashes, subMessageHashes, marketIds, channel, parameters);
    }

    /**
     * @method
     * @name gate#unWatchTrades
     * @description get the list of most recent trades for a particular symbol
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> unWatchTrades(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.unWatchTradesForSymbols(new List<object>() {symbol}, parameters);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        // {
        //     "time": 1648725035,
        //     "channel": "spot.trades",
        //     "event": "update",
        //     "result": [{
        //       "id": 3130257995,
        //       "create_time": 1648725035,
        //       "create_time_ms": "1648725035923.0",
        //       "side": "sell",
        //       "currency_pair": "LTC_USDT",
        //       "amount": "0.0116",
        //       "price": "130.11"
        //     }]
        // }
        //
        object result = this.safeValue(message, "result");
        if (!isTrue(((result is IList<object>) || (result.GetType().IsGenericType && result.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            result = new List<object>() {result};
        }
        object parsedTrades = this.parseTrades(result);
        for (object i = 0; isLessThan(i, getArrayLength(parsedTrades)); postFixIncrement(ref i))
        {
            object trade = getValue(parsedTrades, i);
            object symbol = getValue(trade, "symbol");
            object cachedTrades = this.safeValue(this.trades, symbol);
            if (isTrue(isEqual(cachedTrades, null)))
            {
                object limit = this.safeInteger(this.options, "tradesLimit", 1000);
                cachedTrades = new ArrayCache(limit);
                ((IDictionary<string,object>)this.trades)[(string)symbol] = cachedTrades;
            }
            callDynamically(cachedTrades, "append", new object[] {trade});
            object hash = add("trades:", symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {cachedTrades, hash});
        }
    }

    /**
     * @method
     * @name gate#watchOHLCV
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object marketId = getValue(market, "id");
        object interval = this.safeString(this.timeframes, timeframe, timeframe);
        object messageType = this.getTypeByMarket(market);
        object channel = add(messageType, ".candlesticks");
        object messageHash = add(add(add("candles:", interval), ":"), getValue(market, "symbol"));
        object url = this.getUrlByMarket(market);
        object payload = new List<object>() {interval, marketId};
        object ohlcv = await this.subscribePublic(url, messageHash, payload, channel, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        // {
        //     "time": 1606292600,
        //     "channel": "spot.candlesticks",
        //     "event": "update",
        //     "result": {
        //       "t": "1606292580", // total volume
        //       "v": "2362.32035", // volume
        //       "c": "19128.1", // close
        //       "h": "19128.1", // high
        //       "l": "19128.1", // low
        //       "o": "19128.1", // open
        //       "n": "1m_BTC_USDT" // sub
        //     }
        //   }
        //
        object channel = this.safeString(message, "channel");
        object channelParts = ((string)channel).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object rawMarketType = this.safeString(channelParts, 0);
        object marketType = ((bool) isTrue((isEqual(rawMarketType, "spot")))) ? "spot" : "contract";
        object result = this.safeValue(message, "result");
        if (!isTrue(((result is IList<object>) || (result.GetType().IsGenericType && result.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            result = new List<object>() {result};
        }
        object marketIds = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
        {
            object ohlcv = getValue(result, i);
            object subscription = this.safeString(ohlcv, "n", "");
            object parts = ((string)subscription).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
            object timeframe = this.safeString(parts, 0);
            object timeframeId = this.findTimeframe(timeframe);
            object prefix = add(timeframe, "_");
            object marketId = ((string)subscription).Replace((string)prefix, (string)"");
            object symbol = this.safeSymbol(marketId, null, "_", marketType);
            object parsed = this.parseOHLCV(ohlcv);
            ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
            object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
            if (isTrue(isEqual(stored, null)))
            {
                object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
                stored = new ArrayCacheByTimestamp(limit);
                ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframeId] = stored;
            }
            callDynamically(stored, "append", new object[] {parsed});
            ((IDictionary<string,object>)marketIds)[(string)symbol] = timeframe;
        }
        object keys = new List<object>(((IDictionary<string,object>)marketIds).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object symbol = getValue(keys, i);
            object timeframe = getValue(marketIds, symbol);
            object interval = this.findTimeframe(timeframe);
            object hash = add(add(add(add("candles", ":"), interval), ":"), symbol);
            object stored = this.safeValue(getValue(this.ohlcvs, symbol), interval);
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, hash});
        }
    }

    /**
     * @method
     * @name gate#watchMyTrades
     * @description watches information on multiple trades made by the user
     * @param {string} symbol unified market symbol of the market trades were made in
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trade structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object subType = null;
        object type = null;
        object marketId = add("!", "all");
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            marketId = getValue(market, "id");
        }
        var typeparametersVariable = this.handleMarketTypeAndParams("watchMyTrades", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchMyTrades", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object messageType = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "spot", "spot" },
            { "margin", "spot" },
            { "future", "futures" },
            { "swap", "futures" },
            { "option", "options" },
        });
        object channel = add(messageType, ".usertrades");
        object messageHash = "myTrades";
        if (isTrue(!isEqual(symbol, null)))
        {
            messageHash = add(messageHash, add(":", symbol));
        }
        object isInverse = (isEqual(subType, "inverse"));
        object url = this.getUrlByMarketType(type, isInverse);
        object payload = new List<object>() {marketId};
        // uid required for non spot markets
        object requiresUid = (!isEqual(type, "spot"));
        object trades = await this.subscribePrivate(url, messageHash, payload, channel, parameters, requiresUid);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleMyTrades(WebSocketClient client, object message)
    {
        //
        // {
        //     "time": 1543205083,
        //     "channel": "futures.usertrades",
        //     "event": "update",
        //     "error": null,
        //     "result": [
        //       {
        //         "id": "3335259",
        //         "create_time": 1628736848,
        //         "create_time_ms": 1628736848321,
        //         "contract": "BTC_USD",
        //         "order_id": "4872460",
        //         "size": 1,
        //         "price": "40000.4",
        //         "role": "maker"
        //       }
        //     ]
        // }
        //
        object result = this.safeValue(message, "result", new List<object>() {});
        object tradesLength = getArrayLength(result);
        if (isTrue(isEqual(tradesLength, 0)))
        {
            return;
        }
        object cachedTrades = this.myTrades;
        if (isTrue(isEqual(cachedTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            cachedTrades = new ArrayCacheBySymbolById(limit);
            this.myTrades = cachedTrades;
        }
        object parsed = this.parseTrades(result);
        object marketIds = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(parsed)); postFixIncrement(ref i))
        {
            object trade = getValue(parsed, i);
            callDynamically(cachedTrades, "append", new object[] {trade});
            object symbol = getValue(trade, "symbol");
            ((IDictionary<string,object>)marketIds)[(string)symbol] = true;
        }
        object keys = new List<object>(((IDictionary<string,object>)marketIds).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object market = getValue(keys, i);
            object hash = add("myTrades:", market);
            callDynamically(client as WebSocketClient, "resolve", new object[] {cachedTrades, hash});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {cachedTrades, "myTrades"});
    }

    /**
     * @method
     * @name gate#watchBalance
     * @description watch balance and get the amount of funds available for trading or funds locked in orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
        object subType = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchBalance", null, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object isInverse = (isEqual(subType, "inverse"));
        object url = this.getUrlByMarketType(type, isInverse);
        object requiresUid = (!isEqual(type, "spot"));
        object channelType = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "spot", "spot" },
            { "margin", "spot" },
            { "future", "futures" },
            { "swap", "futures" },
            { "option", "options" },
        });
        object channel = add(channelType, ".balances");
        object messageHash = add(type, ".balance");
        return await this.subscribePrivate(url, messageHash, null, channel, parameters, requiresUid);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        // spot order fill
        //   {
        //       "time": 1653664351,
        //       "channel": "spot.balances",
        //       "event": "update",
        //       "result": [
        //         {
        //           "timestamp": "1653664351",
        //           "timestamp_ms": "1653664351017",
        //           "user": "10406147",
        //           "currency": "LTC",
        //           "change": "-0.0002000000000000",
        //           "total": "0.09986000000000000000",
        //           "available": "0.09986000000000000000"
        //         }
        //       ]
        //   }
        //
        // account transfer
        //
        //    {
        //        "id": null,
        //        "time": 1653665088,
        //        "channel": "futures.balances",
        //        "event": "update",
        //        "error": null,
        //        "result": [
        //          {
        //            "balance": 25.035008537,
        //            "change": 25,
        //            "text": "-",
        //            "time": 1653665088,
        //            "time_ms": 1653665088286,
        //            "type": "dnw",
        //            "user": "10406147"
        //          }
        //        ]
        //   }
        //
        // swap order fill
        //   {
        //       "id": null,
        //       "time": 1653665311,
        //       "channel": "futures.balances",
        //       "event": "update",
        //       "error": null,
        //       "result": [
        //         {
        //           "balance": 20.031873037,
        //           "change": -0.0031355,
        //           "text": "LTC_USDT:165551103273",
        //           "time": 1653665311,
        //           "time_ms": 1653665311437,
        //           "type": "fee",
        //           "user": "10406147"
        //         }
        //       ]
        //   }
        //
        object result = this.safeValue(message, "result", new List<object>() {});
        object timestamp = this.safeInteger(message, "time_ms");
        ((IDictionary<string,object>)this.balance)["info"] = result;
        ((IDictionary<string,object>)this.balance)["timestamp"] = timestamp;
        ((IDictionary<string,object>)this.balance)["datetime"] = this.iso8601(timestamp);
        for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
        {
            object rawBalance = getValue(result, i);
            object account = this.account();
            object currencyId = this.safeString(rawBalance, "currency", "USDT"); // when not present it is USDT
            object code = this.safeCurrencyCode(currencyId);
            ((IDictionary<string,object>)account)["free"] = this.safeString(rawBalance, "available");
            ((IDictionary<string,object>)account)["total"] = this.safeString2(rawBalance, "total", "balance");
            ((IDictionary<string,object>)this.balance)[(string)code] = account;
        }
        object channel = this.safeString(message, "channel");
        object parts = ((string)channel).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object rawType = this.safeString(parts, 0);
        object channelType = this.getSupportedMapping(rawType, new Dictionary<string, object>() {
            { "spot", "spot" },
            { "futures", "swap" },
            { "options", "option" },
        });
        object messageHash = add(channelType, ".balance");
        this.balance = this.safeBalance(this.balance);
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, messageHash});
    }

    /**
     * @method
     * @name gate#watchPositions
     * @see https://www.gate.io/docs/developers/futures/ws/en/#positions-subscription
     * @see https://www.gate.io/docs/developers/delivery/ws/en/#positions-subscription
     * @see https://www.gate.io/docs/developers/options/ws/en/#positions-channel
     * @description watch all open positions
     * @param {string[]} [symbols] list of unified market symbols to watch positions for
     * @param {int} [since] the earliest time in ms to fetch positions for
     * @param {int} [limit] the maximum number of positions to retrieve
     * @param {object} params extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
     */
    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        symbols = this.marketSymbols(symbols);
        object payload = new List<object>() {add("!", "all")};
        if (!isTrue(this.isEmpty(symbols)))
        {
            market = this.getMarketFromSymbols(symbols);
        }
        object type = null;
        object query = null;
        var typequeryVariable = this.handleMarketTypeAndParams("watchPositions", market, parameters);
        type = ((IList<object>)typequeryVariable)[0];
        query = ((IList<object>)typequeryVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            type = "swap";
        }
        object typeId = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "future", "futures" },
            { "swap", "futures" },
            { "option", "options" },
        });
        object messageHash = add(type, ":positions");
        if (!isTrue(this.isEmpty(symbols)))
        {
            messageHash = add(messageHash, add("::", String.Join(",", ((IList<object>)symbols).ToArray())));
        }
        object channel = add(typeId, ".positions");
        object subType = null;
        var subTypequeryVariable = this.handleSubTypeAndParams("watchPositions", market, query);
        subType = ((IList<object>)subTypequeryVariable)[0];
        query = ((IList<object>)subTypequeryVariable)[1];
        object isInverse = (isEqual(subType, "inverse"));
        object url = this.getUrlByMarketType(type, isInverse);
        var client = this.client(url);
        this.setPositionsCache(client as WebSocketClient, type, symbols);
        object fetchPositionsSnapshot = this.handleOption("watchPositions", "fetchPositionsSnapshot", true);
        object awaitPositionsSnapshot = this.handleOption("watchPositions", "awaitPositionsSnapshot", true);
        object cache = this.safeValue(this.positions, type);
        if (isTrue(isTrue(isTrue(fetchPositionsSnapshot) && isTrue(awaitPositionsSnapshot)) && isTrue(isEqual(cache, null))))
        {
            return await client.future(add(type, ":fetchPositionsSnapshot"));
        }
        object positions = await this.subscribePrivate(url, messageHash, payload, channel, query, true);
        if (isTrue(this.newUpdates))
        {
            return positions;
        }
        return this.filterBySymbolsSinceLimit(getValue(this.positions, type), symbols, since, limit, true);
    }

    public virtual void setPositionsCache(WebSocketClient client, object type, object symbols = null)
    {
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new Dictionary<string, object>() {};
        }
        if (isTrue(inOp(this.positions, type)))
        {
            return;
        }
        object fetchPositionsSnapshot = this.handleOption("watchPositions", "fetchPositionsSnapshot", false);
        if (isTrue(fetchPositionsSnapshot))
        {
            object messageHash = add(type, ":fetchPositionsSnapshot");
            if (!isTrue((inOp(client.futures, messageHash))))
            {
                client.future(messageHash);
                this.spawn(this.loadPositionsSnapshot, new object[] { client, messageHash, type});
            }
        } else
        {
            ((IDictionary<string,object>)this.positions)[(string)type] = new ArrayCacheBySymbolBySide();
        }
    }

    public async virtual Task loadPositionsSnapshot(WebSocketClient client, object messageHash, object type)
    {
        object positions = await this.fetchPositions(null, new Dictionary<string, object>() {
            { "type", type },
        });
        ((IDictionary<string,object>)this.positions)[(string)type] = new ArrayCacheBySymbolBySide();
        object cache = getValue(this.positions, type);
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object position = getValue(positions, i);
            callDynamically(cache, "append", new object[] {position});
        }
        // don't remove the future from the .futures cache
        var future = getValue(client.futures, messageHash);
        (future as Future).resolve(cache);
        callDynamically(client as WebSocketClient, "resolve", new object[] {cache, add(type, ":position")});
    }

    public virtual void handlePositions(WebSocketClient client, object message)
    {
        //
        //    {
        //        time: 1693158497,
        //        time_ms: 1693158497204,
        //        channel: 'futures.positions',
        //        event: 'update',
        //        result: [{
        //            contract: 'XRP_USDT',
        //            cross_leverage_limit: 0,
        //            entry_price: 0.5253,
        //            history_pnl: 0,
        //            history_point: 0,
        //            last_close_pnl: 0,
        //            leverage: 0,
        //            leverage_max: 50,
        //            liq_price: 0.0361,
        //            maintenance_rate: 0.01,
        //            margin: 4.89609962852,
        //            mode: 'single',
        //            realised_pnl: -0.0026265,
        //            realised_point: 0,
        //            risk_limit: 500000,
        //            size: 1,
        //            time: 1693158497,
        //            time_ms: 1693158497195,
        //            update_id: 1,
        //            user: '10444586'
        //        }]
        //    }
        //
        object type = this.getMarketTypeByUrl(client.url);
        object data = this.safeValue(message, "result", new List<object>() {});
        object cache = getValue(this.positions, type);
        object newPositions = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object rawPosition = getValue(data, i);
            object position = this.parsePosition(rawPosition);
            ((IList<object>)newPositions).Add(position);
            callDynamically(cache, "append", new object[] {position});
        }
        object messageHashes = this.findMessageHashes(client as WebSocketClient, add(type, ":positions::"));
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object positions = this.filterByArray(newPositions, "symbol", symbols, false);
            if (!isTrue(this.isEmpty(positions)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {positions, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newPositions, add(type, ":positions")});
    }

    /**
     * @method
     * @name gate#watchOrders
     * @description watches information on multiple orders made by the user
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] spot, margin, swap, future, or option. Required if listening to all symbols.
     * @param {boolean} [params.isInverse] if future, listen to inverse or linear contracts
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        object type = null;
        object query = null;
        var typequeryVariable = this.handleMarketTypeAndParams("watchOrders", market, parameters);
        type = ((IList<object>)typequeryVariable)[0];
        query = ((IList<object>)typequeryVariable)[1];
        object typeId = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "spot", "spot" },
            { "margin", "spot" },
            { "future", "futures" },
            { "swap", "futures" },
            { "option", "options" },
        });
        object channel = add(typeId, ".orders");
        object messageHash = "orders";
        object payload = new List<object>() {add("!", "all")};
        if (isTrue(!isEqual(symbol, null)))
        {
            messageHash = add(messageHash, add(":", getValue(market, "id")));
            payload = new List<object>() {getValue(market, "id")};
        }
        object subType = null;
        var subTypequeryVariable = this.handleSubTypeAndParams("watchOrders", market, query);
        subType = ((IList<object>)subTypequeryVariable)[0];
        query = ((IList<object>)subTypequeryVariable)[1];
        object isInverse = (isEqual(subType, "inverse"));
        object url = this.getUrlByMarketType(type, isInverse);
        // uid required for non spot markets
        object requiresUid = (!isEqual(type, "spot"));
        object orders = await this.subscribePrivate(url, messageHash, payload, channel, query, requiresUid);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(orders, since, limit, "timestamp", true);
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        //
        // {
        //     "time": 1605175506,
        //     "channel": "spot.orders",
        //     "event": "update",
        //     "result": [
        //       {
        //         "id": "30784435",
        //         "user": 123456,
        //         "text": "t-abc",
        //         "create_time": "1605175506",
        //         "create_time_ms": "1605175506123",
        //         "update_time": "1605175506",
        //         "update_time_ms": "1605175506123",
        //         "event": "put",
        //         "currency_pair": "BTC_USDT",
        //         "type": "limit",
        //         "account": "spot",
        //         "side": "sell",
        //         "amount": "1",
        //         "price": "10001",
        //         "time_in_force": "gtc",
        //         "left": "1",
        //         "filled_total": "0",
        //         "fee": "0",
        //         "fee_currency": "USDT",
        //         "point_fee": "0",
        //         "gt_fee": "0",
        //         "gt_discount": true,
        //         "rebated_fee": "0",
        //         "rebated_fee_currency": "USDT"
        //       }
        //     ]
        // }
        //
        object orders = this.safeValue(message, "result", new List<object>() {});
        object limit = this.safeInteger(this.options, "ordersLimit", 1000);
        if (isTrue(isEqual(this.orders, null)))
        {
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object stored = this.orders;
        object marketIds = new Dictionary<string, object>() {};
        object parsedOrders = this.parseOrders(orders);
        for (object i = 0; isLessThan(i, getArrayLength(parsedOrders)); postFixIncrement(ref i))
        {
            object parsed = getValue(parsedOrders, i);
            // inject order status
            object info = this.safeValue(parsed, "info");
            object eventVar = this.safeString(info, "event");
            if (isTrue(isTrue(isEqual(eventVar, "put")) || isTrue(isEqual(eventVar, "update"))))
            {
                ((IDictionary<string,object>)parsed)["status"] = "open";
            } else if (isTrue(isEqual(eventVar, "finish")))
            {
                object status = this.safeString(parsed, "status");
                if (isTrue(isEqual(status, null)))
                {
                    object left = this.safeInteger(info, "left");
                    ((IDictionary<string,object>)parsed)["status"] = ((bool) isTrue((isEqual(left, 0)))) ? "closed" : "canceled";
                }
            }
            callDynamically(stored, "append", new object[] {parsed});
            object symbol = getValue(parsed, "symbol");
            object market = this.market(symbol);
            ((IDictionary<string,object>)marketIds)[(string)getValue(market, "id")] = true;
        }
        object keys = new List<object>(((IDictionary<string,object>)marketIds).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object messageHash = add("orders:", getValue(keys, i));
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageHash});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, "orders"});
    }

    /**
     * @method
     * @name gate#watchMyLiquidations
     * @description watch the public liquidations of a trading pair
     * @see https://www.gate.io/docs/developers/futures/ws/en/#liquidates-api
     * @see https://www.gate.io/docs/developers/delivery/ws/en/#liquidates-api
     * @see https://www.gate.io/docs/developers/options/ws/en/#liquidates-channel
     * @param {string} symbol unified CCXT market symbol
     * @param {int} [since] the earliest time in ms to fetch liquidations for
     * @param {int} [limit] the maximum number of liquidation structures to retrieve
     * @param {object} [params] exchange specific parameters for the bitmex api endpoint
     * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
     */
    public async override Task<object> watchMyLiquidations(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return this.watchMyLiquidationsForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    /**
     * @method
     * @name gate#watchMyLiquidationsForSymbols
     * @description watch the private liquidations of a trading pair
     * @see https://www.gate.io/docs/developers/futures/ws/en/#liquidates-api
     * @see https://www.gate.io/docs/developers/delivery/ws/en/#liquidates-api
     * @see https://www.gate.io/docs/developers/options/ws/en/#liquidates-channel
     * @param {string[]} symbols unified CCXT market symbols
     * @param {int} [since] the earliest time in ms to fetch liquidations for
     * @param {int} [limit] the maximum number of liquidation structures to retrieve
     * @param {object} [params] exchange specific parameters for the gate api endpoint
     * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
     */
    public async override Task<object> watchMyLiquidationsForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, true, true);
        object market = this.getMarketFromSymbols(symbols);
        object type = null;
        object query = null;
        var typequeryVariable = this.handleMarketTypeAndParams("watchMyLiquidationsForSymbols", market, parameters);
        type = ((IList<object>)typequeryVariable)[0];
        query = ((IList<object>)typequeryVariable)[1];
        object typeId = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "future", "futures" },
            { "swap", "futures" },
            { "option", "options" },
        });
        object subType = null;
        var subTypequeryVariable = this.handleSubTypeAndParams("watchMyLiquidationsForSymbols", market, query);
        subType = ((IList<object>)subTypequeryVariable)[0];
        query = ((IList<object>)subTypequeryVariable)[1];
        object isInverse = (isEqual(subType, "inverse"));
        object url = this.getUrlByMarketType(type, isInverse);
        object payload = new List<object>() {};
        object messageHash = "";
        if (isTrue(this.isEmpty(symbols)))
        {
            if (isTrue(isTrue(!isEqual(typeId, "futures")) && !isTrue(isInverse)))
            {
                throw new BadRequest ((string)add(this.id, " watchMyLiquidationsForSymbols() does not support listening to all symbols, you must call watchMyLiquidations() instead for each symbol you wish to watch.")) ;
            }
            messageHash = "myLiquidations";
            ((IList<object>)payload).Add("!all");
        } else
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(!isEqual(symbolsLength, 1)))
            {
                throw new BadRequest ((string)add(this.id, " watchMyLiquidationsForSymbols() only allows one symbol at a time. To listen to several symbols call watchMyLiquidationsForSymbols() several times.")) ;
            }
            messageHash = add("myLiquidations::", getValue(symbols, 0));
            ((IList<object>)payload).Add(getValue(market, "id"));
        }
        object channel = add(typeId, ".liquidates");
        object newLiquidations = await this.subscribePrivate(url, messageHash, payload, channel, query, true);
        if (isTrue(this.newUpdates))
        {
            return newLiquidations;
        }
        return this.filterBySymbolsSinceLimit(this.liquidations, symbols, since, limit, true);
    }

    public virtual void handleLiquidation(WebSocketClient client, object message)
    {
        //
        // future / delivery
        //     {
        //         "channel":"futures.liquidates",
        //         "event":"update",
        //         "time":1541505434,
        //         "time_ms":1541505434123,
        //         "result":[
        //            {
        //               "entry_price":209,
        //               "fill_price":215.1,
        //               "left":0,
        //               "leverage":0.0,
        //               "liq_price":213,
        //               "margin":0.007816722941,
        //               "mark_price":213,
        //               "order_id":4093362,
        //               "order_price":215.1,
        //               "size":-124,
        //               "time":1541486601,
        //               "time_ms":1541486601123,
        //               "contract":"BTC_USD",
        //               "user":"1040xxxx"
        //            }
        //         ]
        //     }
        // option
        //    {
        //        "channel":"options.liquidates",
        //        "event":"update",
        //        "time":1630654851,
        //        "result":[
        //           {
        //              "user":"1xxxx",
        //              "init_margin":1190,
        //              "maint_margin":1042.5,
        //              "order_margin":0,
        //              "time":1639051907,
        //              "time_ms":1639051907000
        //           }
        //        ]
        //    }
        //
        object rawLiquidations = this.safeList(message, "result", new List<object>() {});
        object newLiquidations = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rawLiquidations)); postFixIncrement(ref i))
        {
            object rawLiquidation = getValue(rawLiquidations, i);
            object liquidation = this.parseWsLiquidation(rawLiquidation);
            object symbol = this.safeString(liquidation, "symbol");
            object liquidations = this.safeValue(this.liquidations, symbol);
            if (isTrue(isEqual(liquidations, null)))
            {
                object limit = this.safeInteger(this.options, "liquidationsLimit", 1000);
                liquidations = new ArrayCache(limit);
            }
            callDynamically(liquidations, "append", new object[] {liquidation});
            ((IDictionary<string,object>)this.liquidations)[(string)symbol] = liquidations;
            callDynamically(client as WebSocketClient, "resolve", new object[] {liquidations, add("myLiquidations::", symbol)});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newLiquidations, "myLiquidations"});
    }

    public virtual object parseWsLiquidation(object liquidation, object market = null)
    {
        //
        // future / delivery
        //    {
        //        "entry_price": 209,
        //        "fill_price": 215.1,
        //        "left": 0,
        //        "leverage": 0.0,
        //        "liq_price": 213,
        //        "margin": 0.007816722941,
        //        "mark_price": 213,
        //        "order_id": 4093362,
        //        "order_price": 215.1,
        //        "size": -124,
        //        "time": 1541486601,
        //        "time_ms": 1541486601123,
        //        "contract": "BTC_USD",
        //        "user": "1040xxxx"
        //    }
        // option
        //    {
        //        "user": "1xxxx",
        //        "init_margin": 1190,
        //        "maint_margin": 1042.5,
        //        "order_margin": 0,
        //        "time": 1639051907,
        //        "time_ms": 1639051907000
        //    }
        //
        object marketId = this.safeString(liquidation, "contract");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(liquidation, "time_ms");
        object originalSize = this.safeString(liquidation, "size");
        object left = this.safeString(liquidation, "left");
        object amount = Precise.stringAbs(Precise.stringSub(originalSize, left));
        return this.safeLiquidation(new Dictionary<string, object>() {
            { "info", liquidation },
            { "symbol", this.safeSymbol(marketId, market) },
            { "contracts", this.parseNumber(amount) },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "price", this.safeNumber(liquidation, "fill_price") },
            { "baseValue", null },
            { "quoteValue", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        });
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //    {
        //        "time": 1647274664,
        //        "channel": "futures.orders",
        //        "event": "subscribe",
        //        "error": { code: 2, message: "unknown contract BTC_USDT_20220318" },
        //    }
        //    {
        //      "time": 1647276473,
        //      "channel": "futures.orders",
        //      "event": "subscribe",
        //      "error": {
        //        "code": 4,
        //        "message": "{"label":"INVALID_KEY","message":"Invalid key provided"}\n"
        //      },
        //      "result": null
        //    }
        //    {
        //       header: {
        //         response_time: '1718551891329',
        //         status: '400',
        //         channel: 'spot.order_place',
        //         event: 'api',
        //         client_id: '81.34.68.6-0xc16375e2c0',
        //         conn_id: '9539116e0e09678f'
        //       },
        //       data: { errs: { label: 'AUTHENTICATION_FAILED', message: 'Not login' } },
        //       request_id: '10406147'
        //     }
        //
        object data = this.safeDict(message, "data");
        object errs = this.safeDict(data, "errs");
        object error = this.safeDict(message, "error", errs);
        object code = this.safeString2(error, "code", "label");
        object id = this.safeStringN(message, new List<object>() {"id", "requestId", "request_id"});
        if (isTrue(!isEqual(error, null)))
        {
            object messageHash = this.safeString(((WebSocketClient)client).subscriptions, id);
            try
            {
                this.throwExactlyMatchedException(getValue(getValue(this.exceptions, "ws"), "exact"), code, this.json(message));
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, this.json(errs));
                object errorMessage = this.safeString(error, "message", this.safeString(errs, "message"));
                this.throwBroadlyMatchedException(getValue(getValue(this.exceptions, "ws"), "broad"), errorMessage, this.json(message));
                throw new ExchangeError ((string)this.json(message)) ;
            } catch(Exception e)
            {
                ((WebSocketClient)client).reject(e, messageHash);
                if (isTrue(isTrue((!isEqual(messageHash, null))) && isTrue((inOp(((WebSocketClient)client).subscriptions, messageHash)))))
                {
                    ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
                }
            }
            if (isTrue(isTrue((!isEqual(id, null))) && isTrue((inOp(((WebSocketClient)client).subscriptions, id)))))
            {
                ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)id);
            }
            return true;
        }
        return false;
    }

    public virtual void handleBalanceSubscription(WebSocketClient client, object message, object subscription = null)
    {
        this.balance = new Dictionary<string, object>() {};
    }

    public virtual void handleSubscriptionStatus(WebSocketClient client, object message)
    {
        object channel = this.safeString(message, "channel");
        object methods = new Dictionary<string, object>() {
            { "balance", this.handleBalanceSubscription },
            { "spot.order_book_update", this.handleOrderBookSubscription },
            { "futures.order_book_update", this.handleOrderBookSubscription },
        };
        object id = this.safeString(message, "id");
        if (isTrue(inOp(methods, channel)))
        {
            object subscriptionHash = this.safeString(((WebSocketClient)client).subscriptions, id);
            object subscription = this.safeValue(((WebSocketClient)client).subscriptions, subscriptionHash);
            object method = getValue(methods, channel);
            DynamicInvoker.InvokeMethod(method, new object[] { client, message, subscription});
        }
        if (isTrue(inOp(((WebSocketClient)client).subscriptions, id)))
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)id);
        }
    }

    public virtual void handleUnSubscribe(WebSocketClient client, object message)
    {
        //
        // {
        //     "time":1725534679,
        //     "time_ms":1725534679786,
        //     "id":2,
        //     "conn_id":"fac539b443fd7002",
        //     "trace_id":"efe1d282b630b4aa266b84bee177791a",
        //     "channel":"spot.trades",
        //     "event":"unsubscribe",
        //     "payload":[
        //        "LTC_USDT"
        //     ],
        //     "result":{
        //        "status":"success"
        //     },
        //     "requestId":"efe1d282b630b4aa266b84bee177791a"
        // }
        //
        object id = this.safeString(message, "id");
        object keys = new List<object>(((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object messageHash = getValue(keys, i);
            if (!isTrue((inOp(((WebSocketClient)client).subscriptions, messageHash))))
            {
                continue;
            }
            if (isTrue(((string)messageHash).StartsWith(((string)"unsubscribe"))))
            {
                object subscription = getValue(((WebSocketClient)client).subscriptions, messageHash);
                object subId = this.safeString(subscription, "id");
                if (isTrue(!isEqual(id, subId)))
                {
                    continue;
                }
                object messageHashes = this.safeList(subscription, "messageHashes", new List<object>() {});
                object subMessageHashes = this.safeList(subscription, "subMessageHashes", new List<object>() {});
                for (object j = 0; isLessThan(j, getArrayLength(messageHashes)); postFixIncrement(ref j))
                {
                    object unsubHash = getValue(messageHashes, j);
                    object subHash = getValue(subMessageHashes, j);
                    this.cleanUnsubscription(client as WebSocketClient, subHash, unsubHash);
                }
                this.cleanCache(subscription);
            }
        }
    }

    public override void cleanCache(object subscription)
    {
        object topic = this.safeString(subscription, "topic", "");
        object symbols = this.safeList(subscription, "symbols", new List<object>() {});
        object symbolsLength = getArrayLength(symbols);
        if (isTrue(isEqual(topic, "ohlcv")))
        {
            object symbolsAndTimeFrames = this.safeList(subscription, "symbolsAndTimeframes", new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(symbolsAndTimeFrames)); postFixIncrement(ref i))
            {
                object symbolAndTimeFrame = getValue(symbolsAndTimeFrames, i);
                object symbol = this.safeString(symbolAndTimeFrame, 0);
                object timeframe = this.safeString(symbolAndTimeFrame, 1);
                ((IDictionary<string,object>)getValue(this.ohlcvs, symbol)).Remove((string)timeframe);
            }
        } else if (isTrue(isGreaterThan(symbolsLength, 0)))
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                if (isTrue(((string)topic).EndsWith(((string)"trades"))))
                {
                    ((IDictionary<string,object>)this.trades).Remove((string)symbol);
                } else if (isTrue(isEqual(topic, "orderbook")))
                {
                    ((IDictionary<string,object>)this.orderbooks).Remove((string)symbol);
                } else if (isTrue(isEqual(topic, "ticker")))
                {
                    ((IDictionary<string,object>)this.tickers).Remove((string)symbol);
                }
            }
        } else
        {
            if (isTrue(((string)topic).EndsWith(((string)"trades"))))
            {
                // don't reset this.myTrades directly here
                // because in c# we need to use a different object
                object keys = new List<object>(((IDictionary<string,object>)this.trades).Keys);
                for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
                {
                    ((IDictionary<string,object>)this.trades).Remove((string)getValue(keys, i));
                }
            }
        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        //
        // subscribe
        //    {
        //        "time": 1649062304,
        //        "id": 1649062303,
        //        "channel": "spot.candlesticks",
        //        "event": "subscribe",
        //        "result": { status: "success" }
        //    }
        //
        // candlestick
        //    {
        //        "time": 1649063328,
        //        "channel": "spot.candlesticks",
        //        "event": "update",
        //        "result": {
        //          "t": "1649063280",
        //          "v": "58932.23174896",
        //          "c": "45966.47",
        //          "h": "45997.24",
        //          "l": "45966.47",
        //          "o": "45975.18",
        //          "n": "1m_BTC_USDT",
        //          "a": "1.281699"
        //        }
        //     }
        //
        //  orders
        //   {
        //       "time": 1630654851,
        //       "channel": "options.orders", or futures.orders or spot.orders
        //       "event": "update",
        //       "result": [
        //          {
        //             "contract": "BTC_USDT-20211130-65000-C",
        //             "create_time": 1637897000,
        //               (...)
        //       ]
        //   }
        // orderbook
        //   {
        //       "time": 1649770525,
        //       "channel": "spot.order_book_update",
        //       "event": "update",
        //       "result": {
        //         "t": 1649770525653,
        //         "e": "depthUpdate",
        //         "E": 1649770525,
        //         "s": "LTC_USDT",
        //         "U": 2622525645,
        //         "u": 2622525665,
        //         "b": [
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array]
        //         ],
        //         "a": [
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array]
        //         ]
        //       }
        //     }
        //
        // balance update
        //
        //    {
        //        "time": 1653664351,
        //        "channel": "spot.balances",
        //        "event": "update",
        //        "result": [
        //          {
        //            "timestamp": "1653664351",
        //            "timestamp_ms": "1653664351017",
        //            "user": "10406147",
        //            "currency": "LTC",
        //            "change": "-0.0002000000000000",
        //            "total": "0.09986000000000000000",
        //            "available": "0.09986000000000000000"
        //          }
        //        ]
        //    }
        //
        if (isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            return;
        }
        object eventVar = this.safeString(message, "event");
        if (isTrue(isEqual(eventVar, "subscribe")))
        {
            this.handleSubscriptionStatus(client as WebSocketClient, message);
            return;
        }
        if (isTrue(isEqual(eventVar, "unsubscribe")))
        {
            this.handleUnSubscribe(client as WebSocketClient, message);
            return;
        }
        object channel = this.safeString(message, "channel", "");
        object channelParts = ((string)channel).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object channelType = this.safeValue(channelParts, 1);
        object v4Methods = new Dictionary<string, object>() {
            { "usertrades", this.handleMyTrades },
            { "candlesticks", this.handleOHLCV },
            { "orders", this.handleOrder },
            { "positions", this.handlePositions },
            { "tickers", this.handleTicker },
            { "book_ticker", this.handleBidAsk },
            { "trades", this.handleTrades },
            { "order_book_update", this.handleOrderBook },
            { "balances", this.handleBalance },
            { "liquidates", this.handleLiquidation },
        };
        object method = this.safeValue(v4Methods, channelType);
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
        object requestId = this.safeString(message, "request_id");
        if (isTrue(isEqual(requestId, "authenticated")))
        {
            this.handleAuthenticationMessage(client as WebSocketClient, message);
            return;
        }
        if (isTrue(!isEqual(requestId, null)))
        {
            object data = this.safeDict(message, "data");
            // use safeValue as result may be Array or an Object
            object result = this.safeValue(data, "result");
            object ack = this.safeBool(message, "ack");
            if (isTrue(!isEqual(ack, true)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {result, requestId});
            }
        }
    }

    public virtual object getUrlByMarket(object market)
    {
        object baseUrl = getValue(getValue(this.urls, "api"), getValue(market, "type"));
        if (isTrue(getValue(market, "contract")))
        {
            return ((bool) isTrue(getValue(market, "linear"))) ? getValue(baseUrl, "usdt") : getValue(baseUrl, "btc");
        } else
        {
            return baseUrl;
        }
    }

    public virtual object getTypeByMarket(object market)
    {
        if (isTrue(getValue(market, "spot")))
        {
            return "spot";
        } else if (isTrue(getValue(market, "option")))
        {
            return "options";
        } else
        {
            return "futures";
        }
    }

    public virtual object getUrlByMarketType(object type, object isInverse = null)
    {
        isInverse ??= false;
        object api = getValue(this.urls, "api");
        object url = getValue(api, type);
        if (isTrue(isTrue((isEqual(type, "swap"))) || isTrue((isEqual(type, "future")))))
        {
            return ((bool) isTrue(isInverse)) ? getValue(url, "btc") : getValue(url, "usdt");
        } else
        {
            return url;
        }
    }

    public virtual object getMarketTypeByUrl(object url)
    {
        object findBy = new Dictionary<string, object>() {
            { "op-", "option" },
            { "delivery", "future" },
            { "fx", "swap" },
        };
        object keys = new List<object>(((IDictionary<string,object>)findBy).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object value = getValue(findBy, key);
            if (isTrue(isGreaterThanOrEqual(getIndexOf(url, key), 0)))
            {
                return value;
            }
        }
        return "spot";
    }

    public virtual object requestId()
    {
        // their support said that reqid must be an int32, not documented
        object reqid = this.sum(this.safeInteger(this.options, "reqid", 0), 1);
        ((IDictionary<string,object>)this.options)["reqid"] = reqid;
        return reqid;
    }

    public async virtual Task<object> subscribePublic(object url, object messageHash, object payload, object channel, object parameters = null, object subscription = null)
    {
        parameters ??= new Dictionary<string, object>();
        object requestId = this.requestId();
        object time = this.seconds();
        object request = new Dictionary<string, object>() {
            { "id", requestId },
            { "time", time },
            { "channel", channel },
            { "event", "subscribe" },
            { "payload", payload },
        };
        if (isTrue(!isEqual(subscription, null)))
        {
            var client = this.client(url);
            if (!isTrue((inOp(((WebSocketClient)client).subscriptions, messageHash))))
            {
                object tempSubscriptionHash = ((object)requestId).ToString();
                ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)tempSubscriptionHash] = messageHash;
            }
        }
        object message = this.extend(request, parameters);
        return await this.watch(url, messageHash, message, messageHash, subscription);
    }

    public async virtual Task<object> subscribePublicMultiple(object url, object messageHashes, object payload, object channel, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object requestId = this.requestId();
        object time = this.seconds();
        object request = new Dictionary<string, object>() {
            { "id", requestId },
            { "time", time },
            { "channel", channel },
            { "event", "subscribe" },
            { "payload", payload },
        };
        object message = this.extend(request, parameters);
        return await this.watchMultiple(url, messageHashes, message, messageHashes);
    }

    public async virtual Task<object> unSubscribePublicMultiple(object url, object topic, object symbols, object messageHashes, object subMessageHashes, object payload, object channel, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object requestId = this.requestId();
        object time = this.seconds();
        object request = new Dictionary<string, object>() {
            { "id", requestId },
            { "time", time },
            { "channel", channel },
            { "event", "unsubscribe" },
            { "payload", payload },
        };
        object sub = new Dictionary<string, object>() {
            { "id", ((object)requestId).ToString() },
            { "topic", topic },
            { "unsubscribe", true },
            { "messageHashes", messageHashes },
            { "subMessageHashes", subMessageHashes },
            { "symbols", symbols },
        };
        object message = this.extend(request, parameters);
        return await this.watchMultiple(url, messageHashes, message, messageHashes, sub);
    }

    public async virtual Task<object> authenticate(object url, object messageType)
    {
        object channel = add(messageType, ".login");
        var client = this.client(url);
        object messageHash = "authenticated";
        var future = client.future(messageHash);
        object authenticated = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(authenticated, null)))
        {
            return await this.requestPrivate(url, new Dictionary<string, object>() {}, channel, messageHash);
        }
        return future;
    }

    public virtual void handleAuthenticationMessage(WebSocketClient client, object message)
    {
        object messageHash = "authenticated";
        var future = this.safeValue((client as WebSocketClient).futures, messageHash);
        (future as Future).resolve(true);
    }

    public async virtual Task<object> requestPrivate(object url, object reqParams, object channel, object requestId = null)
    {
        this.checkRequiredCredentials();
        // uid is required for some subscriptions only so it's not a part of required credentials
        object eventVar = "api";
        if (isTrue(isEqual(requestId, null)))
        {
            object reqId = this.requestId();
            requestId = ((object)reqId).ToString();
        }
        object messageHash = requestId;
        object time = this.seconds();
        // unfortunately, PHP demands double quotes for the escaped newline symbol
        object signatureString = String.Join("\n", ((IList<object>)new List<object>() {eventVar, channel, this.json(reqParams), ((object)time).ToString()}).ToArray()); // eslint-disable-line quotes
        object signature = this.hmac(this.encode(signatureString), this.encode(this.secret), sha512, "hex");
        object payload = new Dictionary<string, object>() {
            { "req_id", requestId },
            { "timestamp", ((object)time).ToString() },
            { "api_key", this.apiKey },
            { "signature", signature },
            { "req_param", reqParams },
        };
        object request = new Dictionary<string, object>() {
            { "id", requestId },
            { "time", time },
            { "channel", channel },
            { "event", eventVar },
            { "payload", payload },
        };
        return await this.watch(url, messageHash, request, messageHash, requestId);
    }

    public async virtual Task<object> subscribePrivate(object url, object messageHash, object payload, object channel, object parameters, object requiresUid = null)
    {
        requiresUid ??= false;
        this.checkRequiredCredentials();
        // uid is required for some subscriptions only so it's not a part of required credentials
        if (isTrue(requiresUid))
        {
            if (isTrue(isTrue(isEqual(this.uid, null)) || isTrue(isEqual(((string)this.uid).Length, 0))))
            {
                throw new ArgumentsRequired ((string)add(this.id, " requires uid to subscribe")) ;
            }
            object idArray = new List<object>() {this.uid};
            if (isTrue(isEqual(payload, null)))
            {
                payload = idArray;
            } else
            {
                payload = this.arrayConcat(idArray, payload);
            }
        }
        object time = this.seconds();
        object eventVar = "subscribe";
        object signaturePayload = add(add(add(add(add(add(add("channel=", channel), "&"), "event="), eventVar), "&"), "time="), ((object)time).ToString());
        object signature = this.hmac(this.encode(signaturePayload), this.encode(this.secret), sha512, "hex");
        object auth = new Dictionary<string, object>() {
            { "method", "api_key" },
            { "KEY", this.apiKey },
            { "SIGN", signature },
        };
        object requestId = this.requestId();
        object request = new Dictionary<string, object>() {
            { "id", requestId },
            { "time", time },
            { "channel", channel },
            { "event", eventVar },
            { "auth", auth },
        };
        if (isTrue(!isEqual(payload, null)))
        {
            ((IDictionary<string,object>)request)["payload"] = payload;
        }
        var client = this.client(url);
        if (!isTrue((inOp(((WebSocketClient)client).subscriptions, messageHash))))
        {
            object tempSubscriptionHash = ((object)requestId).ToString();
            // in case of authenticationError we will throw
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)tempSubscriptionHash] = messageHash;
        }
        object message = this.extend(request, parameters);
        return await this.watch(url, messageHash, message, messageHash, messageHash);
    }
}
