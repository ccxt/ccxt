namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class htx { public htx(object args = null) : base(args) { } }
public partial class htx : ccxt.htx
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "createOrderWs", false },
                { "editOrderWs", false },
                { "fetchOpenOrdersWs", false },
                { "fetchOrderWs", false },
                { "cancelOrderWs", false },
                { "cancelOrdersWs", false },
                { "cancelAllOrdersWs", false },
                { "fetchTradesWs", false },
                { "fetchBalanceWs", false },
                { "watchOrderBook", true },
                { "watchOrders", true },
                { "watchTickers", false },
                { "watchTicker", true },
                { "watchTrades", true },
                { "watchMyTrades", true },
                { "watchBalance", true },
                { "watchOHLCV", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "api", new Dictionary<string, object>() {
                            { "spot", new Dictionary<string, object>() {
                                { "public", "wss://{hostname}/ws" },
                                { "private", "wss://{hostname}/ws/v2" },
                                { "feed", "wss://{hostname}/feed" },
                            } },
                            { "future", new Dictionary<string, object>() {
                                { "linear", new Dictionary<string, object>() {
                                    { "public", "wss://api.hbdm.com/linear-swap-ws" },
                                    { "private", "wss://api.hbdm.com/linear-swap-notification" },
                                } },
                                { "inverse", new Dictionary<string, object>() {
                                    { "public", "wss://api.hbdm.com/ws" },
                                    { "private", "wss://api.hbdm.com/notification" },
                                } },
                            } },
                            { "swap", new Dictionary<string, object>() {
                                { "inverse", new Dictionary<string, object>() {
                                    { "public", "wss://api.hbdm.com/swap-ws" },
                                    { "private", "wss://api.hbdm.com/swap-notification" },
                                } },
                                { "linear", new Dictionary<string, object>() {
                                    { "public", "wss://api.hbdm.com/linear-swap-ws" },
                                    { "private", "wss://api.hbdm.com/linear-swap-notification" },
                                } },
                            } },
                        } },
                        { "api-aws", new Dictionary<string, object>() {
                            { "spot", new Dictionary<string, object>() {
                                { "public", "wss://api-aws.huobi.pro/ws" },
                                { "private", "wss://api-aws.huobi.pro/ws/v2" },
                                { "feed", "wss://{hostname}/feed" },
                            } },
                            { "future", new Dictionary<string, object>() {
                                { "linear", new Dictionary<string, object>() {
                                    { "public", "wss://api.hbdm.vn/linear-swap-ws" },
                                    { "private", "wss://api.hbdm.vn/linear-swap-notification" },
                                } },
                                { "inverse", new Dictionary<string, object>() {
                                    { "public", "wss://api.hbdm.vn/ws" },
                                    { "private", "wss://api.hbdm.vn/notification" },
                                } },
                            } },
                            { "swap", new Dictionary<string, object>() {
                                { "linear", new Dictionary<string, object>() {
                                    { "public", "wss://api.hbdm.vn/linear-swap-ws" },
                                    { "private", "wss://api.hbdm.vn/linear-swap-notification" },
                                } },
                                { "inverse", new Dictionary<string, object>() {
                                    { "public", "wss://api.hbdm.vn/swap-ws" },
                                    { "private", "wss://api.hbdm.vn/swap-notification" },
                                } },
                            } },
                        } },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "tradesLimit", 1000 },
                { "OHLCVLimit", 1000 },
                { "api", "api" },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "maxRetries", 3 },
                } },
                { "ws", new Dictionary<string, object>() {
                    { "gunzip", true },
                } },
                { "watchTicker", new Dictionary<string, object>() {
                    { "name", "market.{marketId}.detail" },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "ws", new Dictionary<string, object>() {
                    { "exact", new Dictionary<string, object>() {
                        { "bad-request", typeof(BadRequest) },
                        { "2002", typeof(AuthenticationError) },
                        { "2021", typeof(BadRequest) },
                        { "2001", typeof(BadSymbol) },
                        { "2011", typeof(BadSymbol) },
                        { "2040", typeof(BadRequest) },
                        { "4007", typeof(BadRequest) },
                    } },
                } },
            } },
        });
    }

    public virtual object requestId()
    {
        object requestId = this.sum(this.safeInteger(this.options, "requestId", 0), 1);
        ((IDictionary<string,object>)this.options)["requestId"] = requestId;
        return ((object)requestId).ToString();
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name huobi#watchTicker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object options = this.safeValue(this.options, "watchTicker", new Dictionary<string, object>() {});
        object topic = this.safeString(options, "name", "market.{marketId}.detail");
        if (isTrue(isTrue(isEqual(topic, "market.{marketId}.ticker")) && isTrue(!isEqual(getValue(market, "type"), "spot"))))
        {
            throw new BadRequest ((string)add(this.id, " watchTicker() with name market.{marketId}.ticker is only allowed for spot markets, use market.{marketId}.detail instead")) ;
        }
        object messageHash = this.implodeParams(topic, new Dictionary<string, object>() {
            { "marketId", getValue(market, "id") },
        });
        object url = this.getUrlByMarketType(getValue(market, "type"), getValue(market, "linear"));
        return await this.subscribePublic(url, symbol, messageHash, null, parameters);
    }

    public virtual object handleTicker(WebSocketClient client, object message)
    {
        //
        // "market.btcusdt.detail"
        //     {
        //         "ch": "market.btcusdt.detail",
        //         "ts": 1583494163784,
        //         "tick": {
        //             "id": 209988464418,
        //             "low": 8988,
        //             "high": 9155.41,
        //             "open": 9078.91,
        //             "close": 9136.46,
        //             "vol": 237813910.5928412,
        //             "amount": 26184.202558551195,
        //             "version": 209988464418,
        //             "count": 265673
        //         }
        //     }
        // "market.btcusdt.bbo"
        //     {
        //         "ch": "market.btcusdt.bbo",
        //         "ts": 1671941599613,
        //         "tick": {
        //             "seqId": 161499562790,
        //             "ask": 16829.51,
        //             "askSize": 0.707776,
        //             "bid": 16829.5,
        //             "bidSize": 1.685945,
        //             "quoteTime": 1671941599612,
        //             "symbol": "btcusdt"
        //         }
        //     }
        //
        object tick = this.safeValue(message, "tick", new Dictionary<string, object>() {});
        object ch = this.safeString(message, "ch");
        object parts = ((string)ch).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(parts, 1);
        object market = this.safeMarket(marketId);
        object ticker = this.parseTicker(tick, market);
        object timestamp = this.safeValue(message, "ts");
        ((IDictionary<string,object>)ticker)["timestamp"] = timestamp;
        ((IDictionary<string,object>)ticker)["datetime"] = this.iso8601(timestamp);
        object symbol = getValue(ticker, "symbol");
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, ch});
        return message;
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#watchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object messageHash = add(add("market.", getValue(market, "id")), ".trade.detail");
        object url = this.getUrlByMarketType(getValue(market, "type"), getValue(market, "linear"));
        object trades = await this.subscribePublic(url, symbol, messageHash, null, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual object handleTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //         "ch": "market.btcusdt.trade.detail",
        //         "ts": 1583495834011,
        //         "tick": {
        //             "id": 105004645372,
        //             "ts": 1583495833751,
        //             "data": [
        //                 {
        //                     "id": 1.050046453727319e+22,
        //                     "ts": 1583495833751,
        //                     "tradeId": 102090727790,
        //                     "amount": 0.003893,
        //                     "price": 9150.01,
        //                     "direction": "sell"
        //                 }
        //             ]
        //         }
        //     }
        //
        object tick = this.safeValue(message, "tick", new Dictionary<string, object>() {});
        object data = this.safeValue(tick, "data", new Dictionary<string, object>() {});
        object ch = this.safeString(message, "ch");
        object parts = ((string)ch).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(parts, 1);
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object tradesCache = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(tradesCache, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            tradesCache = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = tradesCache;
        }
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object trade = this.parseTrade(getValue(data, i), market);
            callDynamically(tradesCache, "append", new object[] {trade});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {tradesCache, ch});
        return message;
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#watchOHLCV
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object interval = this.safeString(this.timeframes, timeframe, timeframe);
        object messageHash = add(add(add("market.", getValue(market, "id")), ".kline."), interval);
        object url = this.getUrlByMarketType(getValue(market, "type"), getValue(market, "linear"));
        object ohlcv = await this.subscribePublic(url, symbol, messageHash, null, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "ch": "market.btcusdt.kline.1min",
        //         "ts": 1583501786794,
        //         "tick": {
        //             "id": 1583501760,
        //             "open": 9094.5,
        //             "close": 9094.51,
        //             "low": 9094.5,
        //             "high": 9094.51,
        //             "amount": 0.44639786263800907,
        //             "vol": 4059.76919054,
        //             "count": 16
        //         }
        //     }
        //
        object ch = this.safeString(message, "ch");
        object parts = ((string)ch).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(parts, 1);
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object interval = this.safeString(parts, 3);
        object timeframe = this.findTimeframe(interval);
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
        }
        object tick = this.safeValue(message, "tick");
        object parsed = this.parseOHLCV(tick, market);
        callDynamically(stored, "append", new object[] {parsed});
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, ch});
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#watchOrderBook
        * @see https://huobiapi.github.io/docs/dm/v1/en/#subscribe-market-depth-data
        * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#subscribe-incremental-market-depth-data
        * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-subscribe-incremental-market-depth-data
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object allowedLimits = new List<object>() {20, 150};
        // 2) 5-level/20-level incremental MBP is a tick by tick feed,
        // which means whenever there is an order book change at that level, it pushes an update;
        // 150-levels/400-level incremental MBP feed is based on the gap
        // between two snapshots at 100ms interval.
        if (isTrue(isEqual(limit, null)))
        {
            limit = ((bool) isTrue(getValue(market, "spot"))) ? 150 : 20;
        }
        if (!isTrue(this.inArray(limit, allowedLimits)))
        {
            throw new ExchangeError ((string)add(this.id, " watchOrderBook market accepts limits of 20 and 150 only")) ;
        }
        object messageHash = null;
        if (isTrue(getValue(market, "spot")))
        {
            messageHash = add(add(add("market.", getValue(market, "id")), ".mbp."), ((object)limit).ToString());
        } else
        {
            messageHash = add(add(add(add("market.", getValue(market, "id")), ".depth.size_"), ((object)limit).ToString()), ".high_freq");
        }
        object url = this.getUrlByMarketType(getValue(market, "type"), getValue(market, "linear"), false, true);
        object method = this.handleOrderBookSubscription;
        if (!isTrue(getValue(market, "spot")))
        {
            parameters = this.extend(parameters);
            ((IDictionary<string,object>)parameters)["data_type"] = "incremental";
            method = null;
        }
        object orderbook = await this.subscribePublic(url, symbol, messageHash, method, parameters);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBookSnapshot(WebSocketClient client, object message, object subscription)
    {
        //
        //     {
        //         "id": 1583473663565,
        //         "rep": "market.btcusdt.mbp.150",
        //         "status": "ok",
        //         "ts": 1698359289261,
        //         "data": {
        //             "seqNum": 104999417756,
        //             "bids": [
        //                 [9058.27, 0],
        //                 [9058.43, 0],
        //                 [9058.99, 0],
        //             ],
        //             "asks": [
        //                 [9084.27, 0.2],
        //                 [9085.69, 0],
        //                 [9085.81, 0],
        //             ]
        //         }
        //     }
        //
        object symbol = this.safeString(subscription, "symbol");
        object messageHash = this.safeString(subscription, "messageHash");
        object id = this.safeString(message, "id");
        object lastTimestamp = this.safeInteger(subscription, "lastTimestamp");
        try
        {
            object orderbook = getValue(this.orderbooks, symbol);
            object data = this.safeValue(message, "data");
            object messages = (orderbook as ccxt.pro.OrderBook).cache;
            object firstMessage = this.safeValue(messages, 0, new Dictionary<string, object>() {});
            object snapshot = this.parseOrderBook(data, symbol);
            object tick = this.safeValue(firstMessage, "tick");
            object sequence = this.safeInteger(tick, "prevSeqNum");
            object nonce = this.safeInteger(data, "seqNum");
            ((IDictionary<string,object>)snapshot)["nonce"] = nonce;
            object snapshotTimestamp = this.safeInteger(message, "ts");
            ((IDictionary<string,object>)subscription)["lastTimestamp"] = snapshotTimestamp;
            object snapshotLimit = this.safeInteger(subscription, "limit");
            object snapshotOrderBook = this.orderBook(snapshot, snapshotLimit);
            callDynamically(client as WebSocketClient, "resolve", new object[] {snapshotOrderBook, id});
            if (isTrue(isTrue((isEqual(sequence, null))) || isTrue((isLessThan(nonce, sequence)))))
            {
                object maxAttempts = this.handleOption("watchOrderBook", "maxRetries", 3);
                object numAttempts = this.safeInteger(subscription, "numAttempts", 0);
                // retry to synchronize if we have not reached maxAttempts yet
                if (isTrue(isLessThan(numAttempts, maxAttempts)))
                {
                    // safety guard
                    if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
                    {
                        numAttempts = this.sum(numAttempts, 1);
                        object delayTime = this.sum(1000, subtract(lastTimestamp, snapshotTimestamp));
                        ((IDictionary<string,object>)subscription)["numAttempts"] = numAttempts;
                        ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)messageHash] = subscription;
                        this.delay(delayTime,  this.watchOrderBookSnapshot, new object[] { client, message, subscription});
                    }
                } else
                {
                    throw new InvalidNonce ((string)add(add(add(add(add(this.id, " failed to synchronize WebSocket feed with the snapshot for symbol "), symbol), " in "), ((object)maxAttempts).ToString()), " attempts")) ;
                }
            } else
            {
                (orderbook as IOrderBook).reset(snapshot);
                // unroll the accumulated deltas
                for (object i = 0; isLessThan(i, getArrayLength(messages)); postFixIncrement(ref i))
                {
                    this.handleOrderBookMessage(client as WebSocketClient, getValue(messages, i));
                }
                (orderbook as ccxt.pro.OrderBook).cache = new List<object>() {};
                ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
                callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
            }
        } catch(Exception e)
        {
            ((WebSocketClient)client).reject(e, messageHash);
        }
    }

    public async virtual Task<object> watchOrderBookSnapshot(WebSocketClient client, object message, object subscription)
    {
        object messageHash = this.safeString(subscription, "messageHash");
        object symbol = this.safeString(subscription, "symbol");
        object limit = this.safeInteger(subscription, "limit");
        object timestamp = this.safeInteger(message, "ts");
        object parameters = this.safeValue(subscription, "params");
        object attempts = this.safeInteger(subscription, "numAttempts", 0);
        object market = this.market(symbol);
        object url = this.getUrlByMarketType(getValue(market, "type"), getValue(market, "linear"), false, true);
        object requestId = this.requestId();
        object request = new Dictionary<string, object>() {
            { "req", messageHash },
            { "id", requestId },
        };
        // this is a temporary subscription by a specific requestId
        // it has a very short lifetime until the snapshot is received over ws
        object snapshotSubscription = new Dictionary<string, object>() {
            { "id", requestId },
            { "messageHash", messageHash },
            { "symbol", symbol },
            { "limit", limit },
            { "params", parameters },
            { "numAttempts", attempts },
            { "lastTimestamp", timestamp },
            { "method", this.handleOrderBookSnapshot },
        };
        try
        {
            object orderbook = await this.watch(url, requestId, request, requestId, snapshotSubscription);
            return (orderbook as IOrderBook).limit();
        } catch(Exception e)
        {

            ((WebSocketClient)client).reject(e, messageHash);
        }
        return null;
    }

    public override void handleDelta(object bookside, object delta)
    {
        object price = this.safeFloat(delta, 0);
        object amount = this.safeFloat(delta, 1);
        (bookside as IOrderBookSide).store(price, amount);
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    public virtual void handleOrderBookMessage(WebSocketClient client, object message)
    {
        // spot markets
        //
        //     {
        //         "ch": "market.btcusdt.mbp.150",
        //         "ts": 1583472025885,
        //         "tick": {
        //             "seqNum": 104998984994,
        //             "prevSeqNum": 104998984977,
        //             "bids": [
        //                 [9058.27, 0],
        //                 [9058.43, 0],
        //                 [9058.99, 0],
        //             ],
        //             "asks": [
        //                 [9084.27, 0.2],
        //                 [9085.69, 0],
        //                 [9085.81, 0],
        //             ]
        //         }
        //     }
        //
        // non-spot market update
        //
        //     {
        //         "ch":"market.BTC220218.depth.size_150.high_freq",
        //         "tick":{
        //             "asks":[],
        //             "bids":[
        //                 [43445.74,1],
        //                 [43444.48,0 ],
        //                 [40593.92,9]
        //             ],
        //             "ch":"market.BTC220218.depth.size_150.high_freq",
        //             "event":"update",
        //             "id":152727500274,
        //             "mrid":152727500274,
        //             "ts":1645023376098,
        //             "version":37536690
        //         },
        //         "ts":1645023376098
        //     }
        // non-spot market snapshot
        //
        //     {
        //         "ch":"market.BTC220218.depth.size_150.high_freq",
        //         "tick":{
        //             "asks":[
        //                 [43445.74,1],
        //                 [43444.48,0 ],
        //                 [40593.92,9]
        //             ],
        //             "bids":[
        //                 [43445.74,1],
        //                 [43444.48,0 ],
        //                 [40593.92,9]
        //             ],
        //             "ch":"market.BTC220218.depth.size_150.high_freq",
        //             "event":"snapshot",
        //             "id":152727500274,
        //             "mrid":152727500274,
        //             "ts":1645023376098,
        //             "version":37536690
        //         },
        //         "ts":1645023376098
        //     }
        //
        object ch = this.safeValue(message, "ch");
        object parts = ((string)ch).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(parts, 1);
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object orderbook = getValue(this.orderbooks, symbol);
        object tick = this.safeValue(message, "tick", new Dictionary<string, object>() {});
        object seqNum = this.safeInteger(tick, "seqNum");
        object prevSeqNum = this.safeInteger(tick, "prevSeqNum");
        object eventVar = this.safeString(tick, "event");
        object version = this.safeInteger(tick, "version");
        object timestamp = this.safeInteger(message, "ts");
        if (isTrue(isEqual(eventVar, "snapshot")))
        {
            object snapshot = this.parseOrderBook(tick, symbol, timestamp);
            (orderbook as IOrderBook).reset(snapshot);
            ((IDictionary<string,object>)orderbook)["nonce"] = version;
        }
        if (isTrue(isTrue((!isEqual(prevSeqNum, null))) && isTrue(isGreaterThan(prevSeqNum, getValue(orderbook, "nonce")))))
        {
            throw new InvalidNonce ((string)add(this.id, " watchOrderBook() received a mesage out of order")) ;
        }
        object spotConditon = isTrue(getValue(market, "spot")) && isTrue((isEqual(prevSeqNum, getValue(orderbook, "nonce"))));
        object nonSpotCondition = isTrue(getValue(market, "contract")) && isTrue((isEqual(subtract(version, 1), getValue(orderbook, "nonce"))));
        if (isTrue(isTrue(spotConditon) || isTrue(nonSpotCondition)))
        {
            object asks = this.safeValue(tick, "asks", new List<object>() {});
            object bids = this.safeValue(tick, "bids", new List<object>() {});
            this.handleDeltas(getValue(orderbook, "asks"), asks);
            this.handleDeltas(getValue(orderbook, "bids"), bids);
            ((IDictionary<string,object>)orderbook)["nonce"] = ((bool) isTrue(spotConditon)) ? seqNum : version;
            ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        }
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        // deltas
        //
        // spot markets
        //
        //     {
        //         "ch": "market.btcusdt.mbp.150",
        //         "ts": 1583472025885,
        //         "tick": {
        //             "seqNum": 104998984994,
        //             "prevSeqNum": 104998984977,
        //             "bids": [
        //                 [9058.27, 0],
        //                 [9058.43, 0],
        //                 [9058.99, 0],
        //             ],
        //             "asks": [
        //                 [9084.27, 0.2],
        //                 [9085.69, 0],
        //                 [9085.81, 0],
        //             ]
        //         }
        //     }
        //
        // non spot markets
        //
        //     {
        //         "ch":"market.BTC220218.depth.size_150.high_freq",
        //         "tick":{
        //             "asks":[],
        //             "bids":[
        //                 [43445.74,1],
        //                 [43444.48,0 ],
        //                 [40593.92,9]
        //             ],
        //             "ch":"market.BTC220218.depth.size_150.high_freq",
        //             "event":"update",
        //             "id":152727500274,
        //             "mrid":152727500274,
        //             "ts":1645023376098,
        //             "version":37536690
        //         },
        //         "ts":1645023376098
        //     }
        //
        object messageHash = this.safeString(message, "ch");
        object tick = this.safeValue(message, "tick");
        object eventVar = this.safeString(tick, "event");
        object ch = this.safeValue(message, "ch");
        object parts = ((string)ch).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(parts, 1);
        object symbol = this.safeSymbol(marketId);
        object orderbook = this.safeValue(this.orderbooks, symbol);
        if (isTrue(isEqual(orderbook, null)))
        {
            object size = this.safeString(parts, 3);
            object sizeParts = ((string)size).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
            object limit = this.safeInteger(sizeParts, 1);
            orderbook = this.orderBook(new Dictionary<string, object>() {}, limit);
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
        }
        if (isTrue(isTrue((isEqual(eventVar, null))) && isTrue((isEqual(getValue(orderbook, "nonce"), null)))))
        {
            ((IList<object>)(orderbook as ccxt.pro.OrderBook).cache).Add(message);
        } else
        {
            this.handleOrderBookMessage(client as WebSocketClient, message);
            callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
        }
    }

    public virtual void handleOrderBookSubscription(WebSocketClient client, object message, object subscription)
    {
        object symbol = this.safeString(subscription, "symbol");
        object market = this.market(symbol);
        object limit = this.safeInteger(subscription, "limit");
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
        if (isTrue(getValue(market, "spot")))
        {
            this.spawn(this.watchOrderBookSnapshot, new object[] { client, message, subscription});
        }
    }

    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#watchMyTrades
        * @description watches information on multiple trades made by the user
        * @param {string} symbol unified market symbol of the market trades were made in
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trade structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        await this.loadMarkets();
        object type = null;
        object marketId = "*"; // wildcard
        object market = null;
        object messageHash = null;
        object channel = null;
        object trades = null;
        object subType = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            type = getValue(market, "type");
            subType = ((bool) isTrue(getValue(market, "linear"))) ? "linear" : "inverse";
            marketId = getValue(market, "lowercaseId");
        } else
        {
            type = this.safeString(this.options, "defaultType", "spot");
            type = this.safeString(parameters, "type", type);
            subType = this.safeString2(this.options, "subType", "defaultSubType", "linear");
            subType = this.safeString(parameters, "subType", subType);
            parameters = this.omit(parameters, new List<object>() {"type", "subType"});
        }
        if (isTrue(isEqual(type, "spot")))
        {
            object mode = null;
            if (isTrue(isEqual(mode, null)))
            {
                mode = this.safeString2(this.options, "watchMyTrades", "mode", "0");
                mode = this.safeString(parameters, "mode", mode);
                parameters = this.omit(parameters, "mode");
            }
            messageHash = add(add(add(add("trade.clearing", "#"), marketId), "#"), mode);
            channel = messageHash;
        } else
        {
            object channelAndMessageHash = this.getOrderChannelAndMessageHash(type, subType, market, parameters);
            channel = this.safeString(channelAndMessageHash, 0);
            object orderMessageHash = this.safeString(channelAndMessageHash, 1);
            // we will take advantage of the order messageHash because already handles stuff
            // like symbol/margin/subtype/type variations
            messageHash = add(add(orderMessageHash, ":"), "trade");
        }
        trades = await this.subscribePrivate(channel, messageHash, type, subType, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual object getOrderChannelAndMessageHash(object type, object subType, object market = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object messageHash = null;
        object channel = null;
        object orderType = this.safeString(this.options, "orderType", "orders"); // orders or matchOrders
        orderType = this.safeString(parameters, "orderType", orderType);
        parameters = this.omit(parameters, "orderType");
        object marketCode = ((bool) isTrue((!isEqual(market, null)))) ? ((string)getValue(market, "lowercaseId")).ToLower() : null;
        object baseId = ((bool) isTrue((!isEqual(market, null)))) ? getValue(market, "baseId") : null;
        object prefix = orderType;
        messageHash = prefix;
        if (isTrue(isEqual(subType, "linear")))
        {
            // USDT Margined Contracts Example: LTC/USDT:USDT
            object marginMode = this.safeString(parameters, "margin", "cross");
            object marginPrefix = ((bool) isTrue((isEqual(marginMode, "cross")))) ? add(prefix, "_cross") : prefix;
            messageHash = marginPrefix;
            if (isTrue(!isEqual(marketCode, null)))
            {
                messageHash = add(messageHash, add(".", marketCode));
                channel = messageHash;
            } else
            {
                channel = add(add(marginPrefix, "."), "*");
            }
        } else if (isTrue(isEqual(type, "future")))
        {
            // inverse futures Example: BCH/USD:BCH-220408
            if (isTrue(!isEqual(baseId, null)))
            {
                channel = add(add(prefix, "."), ((string)baseId).ToLower());
                messageHash = channel;
            } else
            {
                channel = add(add(prefix, "."), "*");
            }
        } else
        {
            // inverse swaps: Example: BTC/USD:BTC
            if (isTrue(!isEqual(marketCode, null)))
            {
                channel = add(add(prefix, "."), marketCode);
                messageHash = channel;
            } else
            {
                channel = add(add(prefix, "."), "*");
            }
        }
        return new List<object>() {channel, messageHash};
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#watchOrders
        * @description watches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
        object subType = null;
        object market = null;
        object suffix = "*"; // wildcard
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            type = getValue(market, "type");
            suffix = getValue(market, "lowercaseId");
            subType = ((bool) isTrue(getValue(market, "linear"))) ? "linear" : "inverse";
        } else
        {
            type = this.safeString(this.options, "defaultType", "spot");
            type = this.safeString(parameters, "type", type);
            subType = this.safeString2(this.options, "subType", "defaultSubType", "linear");
            subType = this.safeString(parameters, "subType", subType);
            parameters = this.omit(parameters, new List<object>() {"type", "subType"});
        }
        object messageHash = null;
        object channel = null;
        if (isTrue(isEqual(type, "spot")))
        {
            messageHash = add(add("orders", "#"), suffix);
            channel = messageHash;
        } else
        {
            object channelAndMessageHash = this.getOrderChannelAndMessageHash(type, subType, market, parameters);
            channel = this.safeString(channelAndMessageHash, 0);
            messageHash = this.safeString(channelAndMessageHash, 1);
        }
        object orders = await this.subscribePrivate(channel, messageHash, type, subType, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(orders, since, limit, "timestamp", true);
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //     {
        //         "action":"push",
        //         "ch":"orders#btcusdt", // or "orders#*" for global subscriptions
        //         "data": {
        //             "orderSource": "spot-web",
        //             "orderCreateTime": 1645116048355,
        //             "accountId": 44234548,
        //             "orderPrice": "100",
        //             "orderSize": "0.05",
        //             "symbol": "ethusdt",
        //             "type": "buy-limit",
        //             "orderId": "478861479986886",
        //             "eventType": "creation",
        //             "clientOrderId": '',
        //             "orderStatus": "submitted"
        //         }
        //     }
        //
        // spot wrapped trade
        //
        //     {
        //         "action": "push",
        //         "ch": "orders#ltcusdt",
        //         "data": {
        //             "tradePrice": "130.01",
        //             "tradeVolume": "0.0385",
        //             "tradeTime": 1648714741525,
        //             "aggressor": true,
        //             "execAmt": "0.0385",
        //             "orderSource": "spot-web",
        //             "orderSize": "0.0385",
        //             "remainAmt": "0",
        //             "tradeId": 101541578884,
        //             "symbol": "ltcusdt",
        //             "type": "sell-market",
        //             "eventType": "trade",
        //             "clientOrderId": '',
        //             "orderStatus": "filled",
        //             "orderId": 509835753860328
        //         }
        //     }
        //
        // non spot order
        //
        // {
        //     "contract_type": "swap",
        //     "pair": "LTC-USDT",
        //     "business_type": "swap",
        //     "op": "notify",
        //     "topic": "orders_cross.ltc-usdt",
        //     "ts": 1650354508696,
        //     "symbol": "LTC",
        //     "contract_code": "LTC-USDT",
        //     "volume": 1,
        //     "price": 110.34,
        //     "order_price_type": "lightning",
        //     "direction": "sell",
        //     "offset": "close",
        //     "status": 6,
        //     "lever_rate": 1,
        //     "order_id": "966002354015051776",
        //     "order_id_str": "966002354015051776",
        //     "client_order_id": null,
        //     "order_source": "web",
        //     "order_type": 1,
        //     "created_at": 1650354508649,
        //     "trade_volume": 1,
        //     "trade_turnover": 11.072,
        //     "fee": -0.005536,
        //     "trade_avg_price": 110.72,
        //     "margin_frozen": 0,
        //     "profit": -0.045,
        //     "trade": [
        //       {
        //         "trade_fee": -0.005536,
        //         "fee_asset": "USDT",
        //         "real_profit": 0.473,
        //         "profit": -0.045,
        //         "trade_id": 86678766507,
        //         "id": "86678766507-966002354015051776-1",
        //         "trade_volume": 1,
        //         "trade_price": 110.72,
        //         "trade_turnover": 11.072,
        //         "created_at": 1650354508656,
        //         "role": "taker"
        //       }
        //     ],
        //     "canceled_at": 0,
        //     "fee_asset": "USDT",
        //     "margin_asset": "USDT",
        //     "uid": "359305390",
        //     "liquidation_type": "0",
        //     "margin_mode": "cross",
        //     "margin_account": "USDT",
        //     "is_tpsl": 0,
        //     "real_profit": 0.473,
        //     "trade_partition": "USDT",
        //     "reduce_only": 1
        //   }
        //
        //
        object messageHash = this.safeString2(message, "ch", "topic");
        object data = this.safeValue(message, "data");
        object marketId = this.safeString(message, "contract_code");
        if (isTrue(isEqual(marketId, null)))
        {
            marketId = this.safeString(data, "symbol");
        }
        object market = this.safeMarket(marketId);
        object parsedOrder = null;
        if (isTrue(!isEqual(data, null)))
        {
            // spot updates
            object eventType = this.safeString(data, "eventType");
            if (isTrue(isEqual(eventType, "trade")))
            {
                // when a spot order is filled we get an update message
                // with the trade info
                object parsedTrade = this.parseOrderTrade(data, market);
                // inject trade in existing order by faking an order object
                object orderId = this.safeString(parsedTrade, "order");
                object trades = new List<object>() {parsedTrade};
                object status = this.parseOrderStatus(this.safeString2(data, "orderStatus", "status", "closed"));
                object filled = this.safeString(data, "execAmt");
                object remaining = this.safeString(data, "remainAmt");
                object order = new Dictionary<string, object>() {
                    { "id", orderId },
                    { "trades", trades },
                    { "status", status },
                    { "symbol", getValue(market, "symbol") },
                    { "filled", this.parseNumber(filled) },
                    { "remaining", this.parseNumber(remaining) },
                };
                parsedOrder = order;
            } else
            {
                parsedOrder = this.parseWsOrder(data, market);
            }
        } else
        {
            // contract branch
            parsedOrder = this.parseWsOrder(message, market);
            object rawTrades = this.safeValue(message, "trade", new List<object>() {});
            object tradesLength = getArrayLength(rawTrades);
            if (isTrue(isGreaterThan(tradesLength, 0)))
            {
                object tradesObject = new Dictionary<string, object>() {
                    { "trades", rawTrades },
                    { "ch", messageHash },
                    { "symbol", marketId },
                };
                // inject order params in every trade
                object extendTradeParams = new Dictionary<string, object>() {
                    { "order", this.safeString(parsedOrder, "id") },
                    { "type", this.safeString(parsedOrder, "type") },
                    { "side", this.safeString(parsedOrder, "side") },
                };
                // trades arrive inside an order update
                // we're forwarding them to handleMyTrade
                // so they can be properly resolved
                this.handleMyTrade(client as WebSocketClient, tradesObject, extendTradeParams);
            }
        }
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object cachedOrders = this.orders;
        callDynamically(cachedOrders, "append", new object[] {parsedOrder});
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageHash});
        // when we make a global subscription (for contracts only) our message hash can't have a symbol/currency attached
        // so we're removing it here
        object genericMessageHash = ((string)messageHash).Replace((string)add(".", getValue(market, "lowercaseId")), (string)"");
        object lowerCaseBaseId = this.safeStringLower(market, "baseId");
        genericMessageHash = ((string)genericMessageHash).Replace((string)add(".", lowerCaseBaseId), (string)"");
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, genericMessageHash});
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        // spot
        //
        //     {
        //         "orderSource": "spot-web",
        //         "orderCreateTime": 1645116048355, // creating only
        //         "accountId": 44234548,
        //         "orderPrice": "100",
        //         "orderSize": "0.05",
        //         "orderValue": "3.71676361", // market-buy only
        //         "symbol": "ethusdt",
        //         "type": "buy-limit",
        //         "orderId": "478861479986886",
        //         "eventType": "creation",
        //         "clientOrderId": '',
        //         "orderStatus": "submitted"
        //         "lastActTime":1645118621810 // except creating
        //         "execAmt":"0"
        //     }
        //
        // swap order
        //
        //     {
        //         "contract_type": "swap",
        //         "pair": "LTC-USDT",
        //         "business_type": "swap",
        //         "op": "notify",
        //         "topic": "orders_cross.ltc-usdt",
        //         "ts": 1648717911384,
        //         "symbol": "LTC",
        //         "contract_code": "LTC-USDT",
        //         "volume": 1,
        //         "price": 129.13,
        //         "order_price_type": "lightning",
        //         "direction": "sell",
        //         "offset": "close",
        //         "status": 6,
        //         "lever_rate": 5,
        //         "order_id": "959137967397068800",
        //         "order_id_str": "959137967397068800",
        //         "client_order_id": null,
        //         "order_source": "web",
        //         "order_type": 1,
        //         "created_at": 1648717911344,
        //         "trade_volume": 1,
        //         "trade_turnover": 12.952,
        //         "fee": -0.006476,
        //         "trade_avg_price": 129.52,
        //         "margin_frozen": 0,
        //         "profit": -0.005,
        //         "trade": [
        //             {
        //                 "trade_fee": -0.006476,
        //                 "fee_asset": "USDT",
        //                 "real_profit": -0.005,
        //                 "profit": -0.005,
        //                 "trade_id": 83619995370,
        //                 "id": "83619995370-959137967397068800-1",
        //                 "trade_volume": 1,
        //                 "trade_price": 129.52,
        //                 "trade_turnover": 12.952,
        //                 "created_at": 1648717911352,
        //                 "role": "taker"
        //             }
        //         ],
        //         "canceled_at": 0,
        //         "fee_asset": "USDT",
        //         "margin_asset": "USDT",
        //         "uid": "359305390",
        //         "liquidation_type": "0",
        //         "margin_mode": "cross",
        //         "margin_account": "USDT",
        //         "is_tpsl": 0,
        //         "real_profit": -0.005,
        //         "trade_partition": "USDT",
        //         "reduce_only": 1
        //     }
        //
        //     {
        //         "op":"notify",
        //         "topic":"orders.ada",
        //         "ts":1604388667226,
        //         "symbol":"ADA",
        //         "contract_type":"quarter",
        //         "contract_code":"ADA201225",
        //         "volume":1,
        //         "price":0.0905,
        //         "order_price_type":"post_only",
        //         "direction":"sell",
        //         "offset":"open",
        //         "status":6,
        //         "lever_rate":20,
        //         "order_id":773207641127878656,
        //         "order_id_str":"773207641127878656",
        //         "client_order_id":null,
        //         "order_source":"web",
        //         "order_type":1,
        //         "created_at":1604388667146,
        //         "trade_volume":1,
        //         "trade_turnover":10,
        //         "fee":-0.022099447513812154,
        //         "trade_avg_price":0.0905,
        //         "margin_frozen":0,
        //         "profit":0,
        //         "trade":[],
        //         "canceled_at":0,
        //         "fee_asset":"ADA",
        //         "uid":"123456789",
        //         "liquidation_type":"0",
        //         "is_tpsl": 0,
        //         "real_profit": 0
        //     }
        //
        object lastTradeTimestamp = this.safeInteger2(order, "lastActTime", "ts");
        object created = this.safeInteger(order, "orderCreateTime");
        object marketId = this.safeString2(order, "contract_code", "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeSymbol(marketId, market);
        object amount = this.safeString2(order, "orderSize", "volume");
        object status = this.parseOrderStatus(this.safeString2(order, "orderStatus", "status"));
        object id = this.safeString2(order, "orderId", "order_id");
        object clientOrderId = this.safeString2(order, "clientOrderId", "client_order_id");
        object price = this.safeString2(order, "orderPrice", "price");
        object filled = this.safeString(order, "execAmt");
        object typeSide = this.safeString(order, "type");
        object feeCost = this.safeString(order, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrencyId = this.safeString(order, "fee_asset");
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", this.safeCurrencyCode(feeCurrencyId) },
            };
        }
        object avgPrice = this.safeString(order, "trade_avg_price");
        object rawTrades = this.safeValue(order, "trade");
        object typeSideParts = new List<object>() {};
        if (isTrue(!isEqual(typeSide, null)))
        {
            typeSideParts = ((string)typeSide).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
        }
        object type = this.safeStringLower(typeSideParts, 1);
        if (isTrue(isEqual(type, null)))
        {
            type = this.safeString(order, "order_price_type");
        }
        object side = this.safeStringLower(typeSideParts, 0);
        if (isTrue(isEqual(side, null)))
        {
            side = this.safeString(order, "direction");
        }
        object cost = this.safeString(order, "orderValue");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", created },
            { "datetime", this.iso8601(created) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "status", status },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "filled", filled },
            { "remaining", null },
            { "cost", cost },
            { "fee", fee },
            { "average", avgPrice },
            { "trades", rawTrades },
        }, market);
    }

    public virtual object parseOrderTrade(object trade, object market = null)
    {
        // spot private wrapped trade
        //
        //     {
        //         "tradePrice": "130.01",
        //         "tradeVolume": "0.0385",
        //         "tradeTime": 1648714741525,
        //         "aggressor": true,
        //         "execAmt": "0.0385",
        //         "orderSource": "spot-web",
        //         "orderSize": "0.0385",
        //         "remainAmt": "0",
        //         "tradeId": 101541578884,
        //         "symbol": "ltcusdt",
        //         "type": "sell-market",
        //         "eventType": "trade",
        //         "clientOrderId": '',
        //         "orderStatus": "filled",
        //         "orderId": 509835753860328
        //     }
        //
        market = this.safeMarket(null, market);
        object symbol = getValue(market, "symbol");
        object tradeId = this.safeString(trade, "tradeId");
        object price = this.safeString(trade, "tradePrice");
        object amount = this.safeString(trade, "tradeVolume");
        object order = this.safeString(trade, "orderId");
        object timestamp = this.safeInteger(trade, "tradeTime");
        object type = this.safeString(trade, "type");
        object side = null;
        if (isTrue(!isEqual(type, null)))
        {
            object typeParts = ((string)type).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            side = getValue(typeParts, 0);
            type = getValue(typeParts, 1);
        }
        object aggressor = this.safeValue(trade, "aggressor");
        object takerOrMaker = null;
        if (isTrue(!isEqual(aggressor, null)))
        {
            takerOrMaker = ((bool) isTrue(aggressor)) ? "taker" : "maker";
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", tradeId },
            { "order", order },
            { "type", type },
            { "takerOrMaker", takerOrMaker },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", null },
        }, market);
    }

    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name huobi#watchPositions
        * @see https://www.huobi.com/en-in/opend/newApiPages/?id=8cb7de1c-77b5-11ed-9966-0242ac110003
        * @see https://www.huobi.com/en-in/opend/newApiPages/?id=8cb7df0f-77b5-11ed-9966-0242ac110003
        * @see https://www.huobi.com/en-in/opend/newApiPages/?id=28c34a7d-77ae-11ed-9966-0242ac110003
        * @see https://www.huobi.com/en-in/opend/newApiPages/?id=5d5156b5-77b6-11ed-9966-0242ac110003
        * @description watch all open positions. Note: huobi has one channel for each marginMode and type
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object messageHash = "";
        if (!isTrue(this.isEmpty(symbols)))
        {
            market = this.getMarketFromSymbols(symbols);
            messageHash = add("::", String.Join(",", ((IList<object>)symbols).ToArray()));
        }
        object type = null;
        object subType = null;
        if (isTrue(!isEqual(market, null)))
        {
            type = getValue(market, "type");
            subType = ((bool) isTrue(getValue(market, "linear"))) ? "linear" : "inverse";
        } else
        {
            var typeparametersVariable = this.handleMarketTypeAndParams("watchPositions", market, parameters);
            type = ((IList<object>)typeparametersVariable)[0];
            parameters = ((IList<object>)typeparametersVariable)[1];
            if (isTrue(isEqual(type, "spot")))
            {
                type = "future";
            }
            var subTypeparametersVariable = this.handleOptionAndParams(parameters, "watchPositions", "subType", subType);
            subType = ((IList<object>)subTypeparametersVariable)[0];
            parameters = ((IList<object>)subTypeparametersVariable)[1];
        }
        symbols = this.marketSymbols(symbols);
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("watchPositions", parameters, "cross");
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object isLinear = (isEqual(subType, "linear"));
        object url = this.getUrlByMarketType(type, isLinear, true);
        messageHash = add(add(marginMode, ":positions"), messageHash);
        object channel = ((bool) isTrue((isEqual(marginMode, "cross")))) ? "positions_cross.*" : "positions.*";
        object newPositions = await this.subscribePrivate(channel, messageHash, type, subType, parameters);
        if (isTrue(this.newUpdates))
        {
            return newPositions;
        }
        return this.filterBySymbolsSinceLimit(getValue(getValue(this.positions, url), marginMode), symbols, since, limit, false);
    }

    public virtual void handlePositions(WebSocketClient client, object message)
    {
        //
        //    {
        //        op: 'notify',
        //        topic: 'positions_cross',
        //        ts: 1696767149650,
        //        event: 'snapshot',
        //        data: [
        //          {
        //            contract_type: 'swap',
        //            pair: 'BTC-USDT',
        //            business_type: 'swap',
        //            liquidation_price: null,
        //            symbol: 'BTC',
        //            contract_code: 'BTC-USDT',
        //            volume: 1,
        //            available: 1,
        //            frozen: 0,
        //            cost_open: 27802.2,
        //            cost_hold: 27802.2,
        //            profit_unreal: 0.0175,
        //            profit_rate: 0.000629446590557581,
        //            profit: 0.0175,
        //            margin_asset: 'USDT',
        //            position_margin: 27.8197,
        //            lever_rate: 1,
        //            direction: 'buy',
        //            last_price: 27819.7,
        //            margin_mode: 'cross',
        //            margin_account: 'USDT',
        //            trade_partition: 'USDT',
        //            position_mode: 'dual_side'
        //          },
        //        ]
        //    }
        //
        object url = client.url;
        object topic = this.safeString(message, "topic", "");
        object marginMode = ((bool) isTrue((isEqual(topic, "positions_cross")))) ? "cross" : "isolated";
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new Dictionary<string, object>() {};
        }
        object clientPositions = this.safeValue(this.positions, url);
        if (isTrue(isEqual(clientPositions, null)))
        {
            ((IDictionary<string,object>)this.positions)[(string)url] = new Dictionary<string, object>() {};
        }
        object clientMarginModePositions = this.safeValue(clientPositions, marginMode);
        if (isTrue(isEqual(clientMarginModePositions, null)))
        {
            ((IDictionary<string,object>)getValue(this.positions, url))[(string)marginMode] = new ArrayCacheBySymbolBySide();
        }
        object cache = getValue(getValue(this.positions, url), marginMode);
        object rawPositions = this.safeValue(message, "data", new List<object>() {});
        object newPositions = new List<object>() {};
        object timestamp = this.safeInteger(message, "ts");
        for (object i = 0; isLessThan(i, getArrayLength(rawPositions)); postFixIncrement(ref i))
        {
            object rawPosition = getValue(rawPositions, i);
            object position = this.parsePosition(rawPosition);
            ((IDictionary<string,object>)position)["timestamp"] = timestamp;
            ((IDictionary<string,object>)position)["datetime"] = this.iso8601(timestamp);
            ((IList<object>)newPositions).Add(position);
            callDynamically(cache, "append", new object[] {position});
        }
        object messageHashes = this.findMessageHashes(client as WebSocketClient, add(marginMode, ":positions::"));
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object positions = this.filterByArray(newPositions, "symbol", symbols, false);
            if (!isTrue(this.isEmpty(positions)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {positions, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newPositions, add(marginMode, ":positions")});
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @name huobi#watchBalance
        * @description watch balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchBalance", null, parameters, "linear");
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object isUnifiedAccount = this.safeValue2(parameters, "isUnifiedAccount", "unified", false);
        parameters = this.omit(parameters, new List<object>() {"isUnifiedAccount", "unified"});
        await this.loadMarkets();
        object messageHash = null;
        object channel = null;
        object marginMode = null;
        if (isTrue(isEqual(type, "spot")))
        {
            object mode = this.safeString2(this.options, "watchBalance", "mode", "2");
            mode = this.safeString(parameters, "mode", mode);
            messageHash = add(add("accounts.update", "#"), mode);
            channel = messageHash;
        } else
        {
            object symbol = this.safeString(parameters, "symbol");
            object currency = this.safeString(parameters, "currency");
            object market = ((bool) isTrue((!isEqual(symbol, null)))) ? this.market(symbol) : null;
            object currencyCode = ((bool) isTrue((!isEqual(currency, null)))) ? this.currency(currency) : null;
            marginMode = this.safeString(parameters, "margin", "cross");
            parameters = this.omit(parameters, new List<object>() {"currency", "symbol", "margin"});
            object prefix = "accounts";
            messageHash = prefix;
            if (isTrue(isEqual(subType, "linear")))
            {
                if (isTrue(isUnifiedAccount))
                {
                    // usdt contracts account
                    prefix = "accounts_unify";
                    messageHash = prefix;
                    channel = add(add(prefix, "."), "usdt");
                } else
                {
                    // usdt contracts account
                    prefix = ((bool) isTrue((isEqual(marginMode, "cross")))) ? add(prefix, "_cross") : prefix;
                    messageHash = prefix;
                    if (isTrue(isEqual(marginMode, "isolated")))
                    {
                        // isolated margin only allows filtering by symbol3
                        if (isTrue(!isEqual(symbol, null)))
                        {
                            messageHash = add(messageHash, add(".", getValue(market, "id")));
                            channel = messageHash;
                        } else
                        {
                            // subscribe to all
                            channel = add(add(prefix, "."), "*");
                        }
                    } else
                    {
                        // cross margin
                        if (isTrue(!isEqual(currencyCode, null)))
                        {
                            channel = add(add(prefix, "."), getValue(currencyCode, "id"));
                            messageHash = channel;
                        } else
                        {
                            // subscribe to all
                            channel = add(add(prefix, "."), "*");
                        }
                    }
                }
            } else if (isTrue(isEqual(type, "future")))
            {
                // inverse futures account
                if (isTrue(!isEqual(currencyCode, null)))
                {
                    messageHash = add(messageHash, add(".", getValue(currencyCode, "id")));
                    channel = messageHash;
                } else
                {
                    // subscribe to all
                    channel = add(add(prefix, "."), "*");
                }
            } else
            {
                // inverse swaps account
                if (isTrue(!isEqual(market, null)))
                {
                    messageHash = add(messageHash, add(".", getValue(market, "id")));
                    channel = messageHash;
                } else
                {
                    // subscribe to all
                    channel = add(add(prefix, "."), "*");
                }
            }
        }
        object subscriptionParams = new Dictionary<string, object>() {
            { "type", type },
            { "subType", subType },
            { "margin", marginMode },
        };
        // we are differentiating the channel from the messageHash for global subscriptions (*)
        // because huobi returns a different topic than the topic sent. Example: we send
        // "accounts.*" and "accounts" is returned so we're setting channel = "accounts.*" and
        // messageHash = "accounts" allowing handleBalance to freely resolve the topic in the message
        return await this.subscribePrivate(channel, messageHash, type, subType, parameters, subscriptionParams);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        // spot
        //
        //     {
        //         "action": "push",
        //         "ch": "accounts.update#0",
        //         "data": {
        //             "currency": "btc",
        //             "accountId": 123456,
        //             "balance": "23.111",
        //             "available": "2028.699426619837209087",
        //             "changeType": "transfer",
        //             "accountType":"trade",
        //             "seqNum": "86872993928",
        //             "changeTime": 1568601800000
        //         }
        //     }
        //
        // inverse future
        //
        //     {
        //         "op":"notify",
        //         "topic":"accounts.ada",
        //         "ts":1604388667226,
        //         "event":"order.match",
        //         "data":[
        //             {
        //                 "symbol":"ADA",
        //                 "margin_balance":446.417641681222726716,
        //                 "margin_static":445.554085945257745136,
        //                 "margin_position":11.049723756906077348,
        //                 "margin_frozen":0,
        //                 "margin_available":435.367917924316649368,
        //                 "profit_real":21.627049781983019459,
        //                 "profit_unreal":0.86355573596498158,
        //                 "risk_rate":40.000796572150656768,
        //                 "liquidation_price":0.018674308027108984,
        //                 "withdraw_available":423.927036163274725677,
        //                 "lever_rate":20,
        //                 "adjust_factor":0.4
        //             }
        //         ],
        //         "uid":"123456789"
        //     }
        //
        // usdt / linear future, swap
        //
        //     {
        //         "op":"notify",
        //         "topic":"accounts.btc-usdt", // or "accounts" for global subscriptions
        //         "ts":1603711370689,
        //         "event":"order.open",
        //         "data":[
        //             {
        //                 "margin_mode":"cross",
        //                 "margin_account":"USDT",
        //                 "margin_asset":"USDT",
        //                 "margin_balance":30.959342395,
        //                 "margin_static":30.959342395,
        //                 "margin_position":0,
        //                 "margin_frozen":10,
        //                 "profit_real":0,
        //                 "profit_unreal":0,
        //                 "withdraw_available":20.959342395,
        //                 "risk_rate":153.796711975,
        //                 "position_mode":"dual_side",
        //                 "contract_detail":[
        //                     {
        //                         "symbol":"LTC",
        //                         "contract_code":"LTC-USDT",
        //                         "margin_position":0,
        //                         "margin_frozen":0,
        //                         "margin_available":20.959342395,
        //                         "profit_unreal":0,
        //                         "liquidation_price":null,
        //                         "lever_rate":1,
        //                         "adjust_factor":0.01,
        //                         "contract_type":"swap",
        //                         "pair":"LTC-USDT",
        //                         "business_type":"swap",
        //                         "trade_partition":"USDT"
        //                     },
        //                 ],
        //                 "futures_contract_detail":[],
        //             }
        //         ]
        //     }
        //
        // inverse future
        //
        //     {
        //         "op":"notify",
        //         "topic":"accounts.ada",
        //         "ts":1604388667226,
        //         "event":"order.match",
        //         "data":[
        //             {
        //                 "symbol":"ADA",
        //                 "margin_balance":446.417641681222726716,
        //                 "margin_static":445.554085945257745136,
        //                 "margin_position":11.049723756906077348,
        //                 "margin_frozen":0,
        //                 "margin_available":435.367917924316649368,
        //                 "profit_real":21.627049781983019459,
        //                 "profit_unreal":0.86355573596498158,
        //                 "risk_rate":40.000796572150656768,
        //                 "liquidation_price":0.018674308027108984,
        //                 "withdraw_available":423.927036163274725677,
        //                 "lever_rate":20,
        //                 "adjust_factor":0.4
        //             }
        //         ],
        //         "uid":"123456789"
        //     }
        //
        object channel = this.safeString(message, "ch");
        object data = this.safeValue(message, "data", new List<object>() {});
        object timestamp = this.safeInteger(data, "changeTime", this.safeInteger(message, "ts"));
        ((IDictionary<string,object>)this.balance)["timestamp"] = timestamp;
        ((IDictionary<string,object>)this.balance)["datetime"] = this.iso8601(timestamp);
        ((IDictionary<string,object>)this.balance)["info"] = data;
        if (isTrue(!isEqual(channel, null)))
        {
            // spot balance
            object currencyId = this.safeString(data, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(data, "available");
            ((IDictionary<string,object>)account)["total"] = this.safeString(data, "balance");
            ((IDictionary<string,object>)this.balance)[(string)code] = account;
            this.balance = this.safeBalance(this.balance);
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, channel});
        } else
        {
            // contract balance
            object dataLength = getArrayLength(data);
            if (isTrue(isEqual(dataLength, 0)))
            {
                return;
            }
            object first = this.safeValue(data, 0, new Dictionary<string, object>() {});
            object topic = this.safeString(message, "topic");
            object splitTopic = ((string)topic).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
            object messageHash = this.safeString(splitTopic, 0);
            object subscription = this.safeValue2(((WebSocketClient)client).subscriptions, messageHash, add(messageHash, ".*"));
            if (isTrue(isEqual(subscription, null)))
            {
                // if subscription not found means that we subscribed to a specific currency/symbol
                // and we use the first data entry to find it
                // Example: topic = 'accounts'
                // client.subscription hash = 'accounts.usdt'
                // we do 'accounts' + '.' + data[0]]['margin_asset'] to get it
                object currencyId = this.safeString2(first, "margin_asset", "symbol");
                messageHash = add(messageHash, add(".", ((string)currencyId).ToLower()));
                subscription = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
            }
            object type = this.safeString(subscription, "type");
            object subType = this.safeString(subscription, "subType");
            if (isTrue(isEqual(topic, "accounts_unify")))
            {
                // {
                //     "margin_asset": "USDT",
                //     "margin_static": 10,
                //     "cross_margin_static": 10,
                //     "margin_balance": 10,
                //     "cross_profit_unreal": 0,
                //     "margin_frozen": 0,
                //     "withdraw_available": 10,
                //     "cross_risk_rate": null,
                //     "cross_swap": [],
                //     "cross_future": [],
                //     "isolated_swap": []
                // }
                object marginAsset = this.safeString(first, "margin_asset");
                object code = this.safeCurrencyCode(marginAsset);
                object marginFrozen = this.safeString(first, "margin_frozen");
                object unifiedAccount = this.account();
                ((IDictionary<string,object>)unifiedAccount)["free"] = this.safeString(first, "withdraw_available");
                ((IDictionary<string,object>)unifiedAccount)["used"] = marginFrozen;
                ((IDictionary<string,object>)this.balance)[(string)code] = unifiedAccount;
                this.balance = this.safeBalance(this.balance);
                callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, "accounts_unify"});
            } else if (isTrue(isEqual(subType, "linear")))
            {
                object margin = this.safeString(subscription, "margin");
                if (isTrue(isEqual(margin, "cross")))
                {
                    object fieldName = ((bool) isTrue((isEqual(type, "future")))) ? "futures_contract_detail" : "contract_detail";
                    object balances = this.safeValue(first, fieldName, new List<object>() {});
                    object balancesLength = getArrayLength(balances);
                    if (isTrue(isGreaterThan(balancesLength, 0)))
                    {
                        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
                        {
                            object balance = getValue(balances, i);
                            object marketId = this.safeString2(balance, "contract_code", "margin_account");
                            object market = this.safeMarket(marketId);
                            object currencyId = this.safeString(balance, "margin_asset");
                            object currency = this.safeCurrency(currencyId);
                            object code = this.safeString(market, "settle", getValue(currency, "code"));
                            // the exchange outputs positions for delisted markets
                            // https://www.huobi.com/support/en-us/detail/74882968522337
                            // we skip it if the market was delisted
                            if (isTrue(!isEqual(code, null)))
                            {
                                object account = this.account();
                                ((IDictionary<string,object>)account)["free"] = this.safeString2(balance, "margin_balance", "margin_available");
                                ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "margin_frozen");
                                object accountsByCode = new Dictionary<string, object>() {};
                                ((IDictionary<string,object>)accountsByCode)[(string)code] = account;
                                object symbol = getValue(market, "symbol");
                                ((IDictionary<string,object>)this.balance)[(string)symbol] = this.safeBalance(accountsByCode);
                            }
                        }
                    }
                } else
                {
                    // isolated margin
                    for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
                    {
                        object isolatedBalance = getValue(data, i);
                        object account = this.account();
                        ((IDictionary<string,object>)account)["free"] = this.safeString(isolatedBalance, "margin_balance", "margin_available");
                        ((IDictionary<string,object>)account)["used"] = this.safeString(isolatedBalance, "margin_frozen");
                        object currencyId = this.safeString2(isolatedBalance, "margin_asset", "symbol");
                        object code = this.safeCurrencyCode(currencyId);
                        ((IDictionary<string,object>)this.balance)[(string)code] = account;
                        this.balance = this.safeBalance(this.balance);
                    }
                }
            } else
            {
                // inverse branch
                for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
                {
                    object balance = getValue(data, i);
                    object currencyId = this.safeString(balance, "symbol");
                    object code = this.safeCurrencyCode(currencyId);
                    object account = this.account();
                    ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "margin_available");
                    ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "margin_frozen");
                    ((IDictionary<string,object>)this.balance)[(string)code] = account;
                    this.balance = this.safeBalance(this.balance);
                }
            }
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, messageHash});
        }
    }

    public virtual void handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //     {
        //         "id": 1583414227,
        //         "status": "ok",
        //         "subbed": "market.btcusdt.mbp.150",
        //         "ts": 1583414229143
        //     }
        //
        object id = this.safeString(message, "id");
        object subscriptionsById = this.indexBy(((WebSocketClient)client).subscriptions, "id");
        object subscription = this.safeValue(subscriptionsById, id);
        if (isTrue(!isEqual(subscription, null)))
        {
            object method = this.safeValue(subscription, "method");
            if (isTrue(!isEqual(method, null)))
            {
                DynamicInvoker.InvokeMethod(method, new object[] { client, message, subscription});
                return;
            }
            // clean up
            if (isTrue(inOp(((WebSocketClient)client).subscriptions, id)))
            {

            }
        }
    }

    public virtual object handleSystemStatus(WebSocketClient client, object message)
    {
        //
        // todo: answer the question whether handleSystemStatus should be renamed
        // and unified as handleStatus for any usage pattern that
        // involves system status and maintenance updates
        //
        //     {
        //         "id": "1578090234088", // connectId
        //         "type": "welcome",
        //     }
        //
        return message;
    }

    public virtual void handleSubject(WebSocketClient client, object message)
    {
        // spot
        //     {
        //         "ch": "market.btcusdt.mbp.150",
        //         "ts": 1583472025885,
        //         "tick": {
        //             "seqNum": 104998984994,
        //             "prevSeqNum": 104998984977,
        //             "bids": [
        //                 [9058.27, 0],
        //                 [9058.43, 0],
        //                 [9058.99, 0],
        //             ],
        //             "asks": [
        //                 [9084.27, 0.2],
        //                 [9085.69, 0],
        //                 [9085.81, 0],
        //             ]
        //         }
        //     }
        // non spot
        //
        //     {
        //         "ch":"market.BTC220218.depth.size_150.high_freq",
        //         "tick":{
        //             "asks":[],
        //             "bids":[
        //                 [43445.74,1],
        //                 [43444.48,0 ],
        //                 [40593.92,9]
        //             ],
        //             "ch":"market.BTC220218.depth.size_150.high_freq",
        //             "event":"update",
        //             "id":152727500274,
        //             "mrid":152727500274,
        //             "ts":1645023376098,
        //             "version":37536690
        //         },
        //         "ts":1645023376098
        //     }
        //
        // spot private trade
        //
        //     {
        //         "action":"push",
        //         "ch":"trade.clearing#ltcusdt#1",
        //         "data":{
        //             "eventType":"trade",
        //             "symbol":"ltcusdt",
        //             // ...
        //         },
        //     }
        //
        // spot order
        //
        //     {
        //         "action":"push",
        //         "ch":"orders#btcusdt",
        //         "data": {
        //             "orderSide":"buy",
        //             "lastActTime":1583853365586,
        //             "clientOrderId":"abc123",
        //             "orderStatus":"rejected",
        //             "symbol":"btcusdt",
        //             "eventType":"trigger",
        //             "errCode": 2002,
        //             "errMessage":"invalid.client.order.id (NT)"
        //         }
        //     }
        //
        // contract order
        //
        //     {
        //         "op":"notify",
        //         "topic":"orders.ada",
        //         "ts":1604388667226,
        //         // ?
        //     }
        //
        object ch = this.safeValue(message, "ch", "");
        object parts = ((string)ch).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object type = this.safeString(parts, 0);
        if (isTrue(isEqual(type, "market")))
        {
            object methodName = this.safeString(parts, 2);
            object methods = new Dictionary<string, object>() {
                { "depth", this.handleOrderBook },
                { "mbp", this.handleOrderBook },
                { "detail", this.handleTicker },
                { "bbo", this.handleTicker },
                { "ticker", this.handleTicker },
                { "trade", this.handleTrades },
                { "kline", this.handleOHLCV },
            };
            object method = this.safeValue(methods, methodName);
            if (isTrue(!isEqual(method, null)))
            {
                DynamicInvoker.InvokeMethod(method, new object[] { client, message});
                return;
            }
        }
        // private spot subjects
        object privateParts = ((string)ch).Split(new [] {((string)"#")}, StringSplitOptions.None).ToList<object>();
        object privateType = this.safeString(privateParts, 0, "");
        if (isTrue(isEqual(privateType, "trade.clearing")))
        {
            this.handleMyTrade(client as WebSocketClient, message);
            return;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(privateType, "accounts.update"), 0)))
        {
            this.handleBalance(client as WebSocketClient, message);
            return;
        }
        if (isTrue(isEqual(privateType, "orders")))
        {
            this.handleOrder(client as WebSocketClient, message);
            return;
        }
        // private contract subjects
        object op = this.safeString(message, "op");
        if (isTrue(isEqual(op, "notify")))
        {
            object topic = this.safeString(message, "topic", "");
            if (isTrue(isGreaterThanOrEqual(getIndexOf(topic, "orders"), 0)))
            {
                this.handleOrder(client as WebSocketClient, message);
            }
            if (isTrue(isGreaterThanOrEqual(getIndexOf(topic, "account"), 0)))
            {
                this.handleBalance(client as WebSocketClient, message);
            }
            if (isTrue(isGreaterThanOrEqual(getIndexOf(topic, "positions"), 0)))
            {
                this.handlePositions(client as WebSocketClient, message);
            }
        }
    }

    public async virtual Task pong(WebSocketClient client, object message)
    {
        try
        {
            object ping = this.safeInteger(message, "ping");
            if (isTrue(!isEqual(ping, null)))
            {
                await client.send(new Dictionary<string, object>() {
                    { "pong", ping },
                });
                return;
            }
            object action = this.safeString(message, "action");
            if (isTrue(isEqual(action, "ping")))
            {
                object data = this.safeValue(message, "data");
                object pingTs = this.safeInteger(data, "ts");
                await client.send(new Dictionary<string, object>() {
                    { "action", "pong" },
                    { "data", new Dictionary<string, object>() {
                        { "ts", pingTs },
                    } },
                });
                return;
            }
            object op = this.safeString(message, "op");
            if (isTrue(isEqual(op, "ping")))
            {
                object pingTs = this.safeInteger(message, "ts");
                await client.send(new Dictionary<string, object>() {
                    { "op", "pong" },
                    { "ts", pingTs },
                });
            }
        } catch(Exception e)
        {
            var error = new NetworkError(add(add(this.id, " pong failed "), this.json(e)));
            ((WebSocketClient)client).reset(error);
        }
    }

    public virtual void handlePing(WebSocketClient client, object message)
    {
        this.spawn(this.pong, new object[] { client, message});
    }

    public virtual void handleAuthenticate(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //     {
        //         "action": "req",
        //         "code": 200,
        //         "ch": "auth",
        //         "data": {}
        //     }
        //
        // non spot
        //
        //    {
        //        "op": "auth",
        //        "type": "api",
        //        "err-code": 0,
        //        "ts": 1645200307319,
        //        "data": { "user-id": "35930539" }
        //    }
        //
        object promise = getValue(client.futures, "authenticated");
        callDynamically(promise, "resolve", new object[] {message});
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //     {
        //         "action": "sub",
        //         "code": 2002,
        //         "ch": "accounts.update#2",
        //         "message": "invalid.auth.state"
        //      }
        //
        //     {
        //         "ts": 1586323747018,
        //         "status": "error",
        //         'err-code': "bad-request",
        //         'err-msg': "invalid mbp.150.symbol linkusdt",
        //         "id": "2"
        //     }
        //
        //     {
        //         "op": "sub",
        //         "cid": "1",
        //         "topic": "accounts_unify.USDT",
        //         "err-code": 4007,
        //         'err-msg': "Non - single account user is not available, please check through the cross and isolated account asset interface",
        //         "ts": 1698419490189
        //     }
        //
        object status = this.safeString(message, "status");
        if (isTrue(isEqual(status, "error")))
        {
            object id = this.safeString(message, "id");
            object subscriptionsById = this.indexBy(((WebSocketClient)client).subscriptions, "id");
            object subscription = this.safeValue(subscriptionsById, id);
            if (isTrue(!isEqual(subscription, null)))
            {
                object errorCode = this.safeString(message, "err-code");
                try
                {
                    this.throwExactlyMatchedException(getValue(getValue(this.exceptions, "ws"), "exact"), errorCode, this.json(message));
                } catch(Exception e)
                {
                    object messageHash = this.safeString(subscription, "messageHash");
                    ((WebSocketClient)client).reject(e, messageHash);
                    ((WebSocketClient)client).reject(e, id);
                    if (isTrue(inOp(((WebSocketClient)client).subscriptions, id)))
                    {

                    }
                }
            }
            return false;
        }
        object code = this.safeInteger2(message, "code", "err-code");
        if (isTrue(isTrue(!isEqual(code, null)) && isTrue((isTrue((!isEqual(code, 200))) && isTrue((!isEqual(code, 0)))))))
        {
            object feedback = add(add(this.id, " "), this.json(message));
            try
            {
                this.throwExactlyMatchedException(getValue(getValue(this.exceptions, "ws"), "exact"), code, feedback);
            } catch(Exception e)
            {
                if (isTrue(e is AuthenticationError))
                {
                    ((WebSocketClient)client).reject(e, "auth");
                    object method = "auth";
                    if (isTrue(inOp(((WebSocketClient)client).subscriptions, method)))
                    {

                    }
                    return false;
                } else
                {
                    ((WebSocketClient)client).reject(e);
                }
            }
        }
        return message;
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            //
            //     {"id":1583414227,"status":"ok","subbed":"market.btcusdt.mbp.150","ts":1583414229143}
            //
            // first ping format
            //
            //    {"ping": 1645106821667 }
            //
            // second ping format
            //
            //    {"action":"ping","data":{"ts":1645106821667}}
            //
            // third pong format
            //
            //
            // auth spot
            //
            //     {
            //         "action": "req",
            //         "code": 200,
            //         "ch": "auth",
            //         "data": {}
            //     }
            //
            // auth non spot
            //
            //    {
            //        "op": "auth",
            //        "type": "api",
            //        "err-code": 0,
            //        "ts": 1645200307319,
            //        "data": { "user-id": "35930539" }
            //    }
            //
            // trade
            //
            //     {
            //         "action":"push",
            //         "ch":"trade.clearing#ltcusdt#1",
            //         "data":{
            //             "eventType":"trade",
            //             // ?
            //         }
            //     }
            //
            if (isTrue(inOp(message, "id")))
            {
                this.handleSubscriptionStatus(client as WebSocketClient, message);
                return;
            }
            if (isTrue(inOp(message, "action")))
            {
                object action = this.safeString(message, "action");
                if (isTrue(isEqual(action, "ping")))
                {
                    this.handlePing(client as WebSocketClient, message);
                    return;
                }
                if (isTrue(isEqual(action, "sub")))
                {
                    this.handleSubscriptionStatus(client as WebSocketClient, message);
                    return;
                }
            }
            if (isTrue(inOp(message, "ch")))
            {
                if (isTrue(isEqual(getValue(message, "ch"), "auth")))
                {
                    this.handleAuthenticate(client as WebSocketClient, message);
                    return;
                } else
                {
                    // route by channel aka topic aka subject
                    this.handleSubject(client as WebSocketClient, message);
                    return;
                }
            }
            if (isTrue(inOp(message, "op")))
            {
                object op = this.safeString(message, "op");
                if (isTrue(isEqual(op, "ping")))
                {
                    this.handlePing(client as WebSocketClient, message);
                    return;
                }
                if (isTrue(isEqual(op, "auth")))
                {
                    this.handleAuthenticate(client as WebSocketClient, message);
                    return;
                }
                if (isTrue(isEqual(op, "sub")))
                {
                    this.handleSubscriptionStatus(client as WebSocketClient, message);
                    return;
                }
                if (isTrue(isEqual(op, "notify")))
                {
                    this.handleSubject(client as WebSocketClient, message);
                    return;
                }
            }
            if (isTrue(inOp(message, "ping")))
            {
                this.handlePing(client as WebSocketClient, message);
            }
        }
    }

    public virtual void handleMyTrade(WebSocketClient client, object message, object extendParams = null)
    {
        //
        // spot
        //
        //     {
        //         "action":"push",
        //         "ch":"trade.clearing#ltcusdt#1",
        //         "data":{
        //             "eventType":"trade",
        //             "symbol":"ltcusdt",
        //             "orderId":"478862728954426",
        //             "orderSide":"buy",
        //             "orderType":"buy-market",
        //             "accountId":44234548,
        //             "source":"spot-web",
        //             "orderValue":"5.01724137",
        //             "orderCreateTime":1645124660365,
        //             "orderStatus":"filled",
        //             "feeCurrency":"ltc",
        //             "tradePrice":"118.89",
        //             "tradeVolume":"0.042200701236437042",
        //             "aggressor":true,
        //             "tradeId":101539740584,
        //             "tradeTime":1645124660368,
        //             "transactFee":"0.000041778694224073",
        //             "feeDeduct":"0",
        //             "feeDeductType":""
        //         }
        //     }
        //
        // contract
        //
        //     {
        //         "symbol": "ADA/USDT:USDT"
        //         "ch": "orders_cross.ada-usdt"
        //         "trades": [
        //             {
        //                 "trade_fee":-0.022099447513812154,
        //                 "fee_asset":"ADA",
        //                 "trade_id":113913755890,
        //                 "id":"113913755890-773207641127878656-1",
        //                 "trade_volume":1,
        //                 "trade_price":0.0905,
        //                 "trade_turnover":10,
        //                 "created_at":1604388667194,
        //                 "profit":0,
        //                 "real_profit": 0,
        //                 "role":"maker"
        //             }
        //         ],
        //     }
        //
        extendParams ??= new Dictionary<string, object>();
        if (isTrue(isEqual(this.myTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            this.myTrades = new ArrayCacheBySymbolById(limit);
        }
        object cachedTrades = this.myTrades;
        object messageHash = this.safeString(message, "ch");
        if (isTrue(!isEqual(messageHash, null)))
        {
            object data = this.safeValue(message, "data");
            if (isTrue(!isEqual(data, null)))
            {
                object parsed = this.parseWsTrade(data);
                object symbol = this.safeString(parsed, "symbol");
                if (isTrue(!isEqual(symbol, null)))
                {
                    callDynamically(cachedTrades, "append", new object[] {parsed});
                    callDynamically(client as WebSocketClient, "resolve", new object[] {this.myTrades, messageHash});
                }
            } else
            {
                // this trades object is artificially created
                // in handleOrder
                object rawTrades = this.safeValue(message, "trades", new List<object>() {});
                object marketId = this.safeValue(message, "symbol");
                object market = this.market(marketId);
                for (object i = 0; isLessThan(i, getArrayLength(rawTrades)); postFixIncrement(ref i))
                {
                    object trade = getValue(rawTrades, i);
                    object parsedTrade = this.parseTrade(trade, market);
                    // add extra params (side, type, ...) coming from the order
                    parsedTrade = this.extend(parsedTrade, extendParams);
                    callDynamically(cachedTrades, "append", new object[] {parsedTrade});
                }
                // messageHash here is the orders one, so
                // we have to recreate the trades messageHash = orderMessageHash + ':' + 'trade'
                object tradesHash = add(add(messageHash, ":"), "trade");
                callDynamically(client as WebSocketClient, "resolve", new object[] {this.myTrades, tradesHash});
                // when we make an global order sub we have to send the channel like this
                // ch = orders_cross.* and we store messageHash = 'orders_cross'
                // however it is returned with the specific order update symbol: ch = orders_cross.btc-usd
                // since this is a global sub, our messageHash does not specify any symbol (ex: orders_cross:trade)
                // so we must remove it
                object genericOrderHash = ((string)messageHash).Replace((string)add(".", getValue(market, "lowercaseId")), (string)"");
                object lowerCaseBaseId = this.safeStringLower(market, "baseId");
                genericOrderHash = ((string)genericOrderHash).Replace((string)add(".", lowerCaseBaseId), (string)"");
                object genericTradesHash = add(add(genericOrderHash, ":"), "trade");
                callDynamically(client as WebSocketClient, "resolve", new object[] {this.myTrades, genericTradesHash});
            }
        }
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        // spot private
        //
        //     {
        //         "eventType":"trade",
        //         "symbol":"ltcusdt",
        //         "orderId":"478862728954426",
        //         "orderSide":"buy",
        //         "orderType":"buy-market",
        //         "accountId":44234548,
        //         "source":"spot-web",
        //         "orderValue":"5.01724137",
        //         "orderCreateTime":1645124660365,
        //         "orderStatus":"filled",
        //         "feeCurrency":"ltc",
        //         "tradePrice":"118.89",
        //         "tradeVolume":"0.042200701236437042",
        //         "aggressor":true,
        //         "tradeId":101539740584,
        //         "tradeTime":1645124660368,
        //         "transactFee":"0.000041778694224073",
        //         "feeDeduct":"0",
        //         "feeDeductType":""
        //     }
        //
        object symbol = this.safeSymbol(this.safeString(trade, "symbol"));
        object side = this.safeString2(trade, "side", "orderSide");
        object tradeId = this.safeString(trade, "tradeId");
        object price = this.safeString(trade, "tradePrice");
        object amount = this.safeString(trade, "tradeVolume");
        object order = this.safeString(trade, "orderId");
        object timestamp = this.safeInteger(trade, "tradeTime");
        market = this.market(symbol);
        object orderType = this.safeString(trade, "orderType");
        object aggressor = this.safeValue(trade, "aggressor");
        object takerOrMaker = null;
        if (isTrue(!isEqual(aggressor, null)))
        {
            takerOrMaker = ((bool) isTrue(aggressor)) ? "taker" : "maker";
        }
        object type = null;
        object orderTypeParts = new List<object>() {};
        if (isTrue(!isEqual(orderType, null)))
        {
            orderTypeParts = ((string)orderType).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            type = this.safeString(orderTypeParts, 1);
        }
        object fee = null;
        object feeCurrency = this.safeCurrencyCode(this.safeString(trade, "feeCurrency"));
        if (isTrue(!isEqual(feeCurrency, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", this.safeString(trade, "transactFee") },
                { "currency", feeCurrency },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", tradeId },
            { "order", order },
            { "type", type },
            { "takerOrMaker", takerOrMaker },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    public virtual object getUrlByMarketType(object type, object isLinear = null, object isPrivate = null, object isFeed = null)
    {
        isLinear ??= true;
        isPrivate ??= false;
        isFeed ??= false;
        object api = this.safeString(this.options, "api", "api");
        object hostname = new Dictionary<string, object>() {
            { "hostname", this.hostname },
        };
        object hostnameURL = null;
        object url = null;
        if (isTrue(isEqual(type, "spot")))
        {
            if (isTrue(isPrivate))
            {
                hostnameURL = getValue(getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), api), "spot"), "private");
            } else
            {
                if (isTrue(isFeed))
                {
                    hostnameURL = getValue(getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), api), "spot"), "feed");
                } else
                {
                    hostnameURL = getValue(getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), api), "spot"), "public");
                }
            }
            url = this.implodeParams(hostnameURL, hostname);
        } else
        {
            object baseUrl = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), api), type);
            object subTypeUrl = ((bool) isTrue(isLinear)) ? getValue(baseUrl, "linear") : getValue(baseUrl, "inverse");
            url = ((bool) isTrue(isPrivate)) ? getValue(subTypeUrl, "private") : getValue(subTypeUrl, "public");
        }
        return url;
    }

    public async virtual Task<object> subscribePublic(object url, object symbol, object messageHash, object method = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object requestId = this.requestId();
        object request = new Dictionary<string, object>() {
            { "sub", messageHash },
            { "id", requestId },
        };
        object subscription = new Dictionary<string, object>() {
            { "id", requestId },
            { "messageHash", messageHash },
            { "symbol", symbol },
            { "params", parameters },
        };
        if (isTrue(!isEqual(method, null)))
        {
            ((IDictionary<string,object>)subscription)["method"] = method;
        }
        return await this.watch(url, messageHash, this.extend(request, parameters), messageHash, subscription);
    }

    public async virtual Task<object> subscribePrivate(object channel, object messageHash, object type, object subtype, object parameters = null, object subscriptionParams = null)
    {
        parameters ??= new Dictionary<string, object>();
        subscriptionParams ??= new Dictionary<string, object>();
        object requestId = this.requestId();
        object subscription = new Dictionary<string, object>() {
            { "id", requestId },
            { "messageHash", messageHash },
            { "params", parameters },
        };
        object extendedSubsription = this.extend(subscription, subscriptionParams);
        object request = null;
        if (isTrue(isEqual(type, "spot")))
        {
            request = new Dictionary<string, object>() {
                { "action", "sub" },
                { "ch", channel },
            };
        } else
        {
            request = new Dictionary<string, object>() {
                { "op", "sub" },
                { "topic", channel },
                { "cid", requestId },
            };
        }
        object isLinear = isEqual(subtype, "linear");
        object url = this.getUrlByMarketType(type, isLinear, true);
        object hostname = ((bool) isTrue((isEqual(type, "spot")))) ? getValue(getValue(this.urls, "hostnames"), "spot") : getValue(getValue(this.urls, "hostnames"), "contract");
        object authParams = new Dictionary<string, object>() {
            { "type", type },
            { "url", url },
            { "hostname", hostname },
        };
        if (isTrue(isEqual(type, "spot")))
        {
            ((IDictionary<string,object>)getValue(this.options, "ws"))["gunzip"] = false;
        }
        await this.authenticate(authParams);
        return await this.watch(url, messageHash, this.extend(request, parameters), channel, extendedSubsription);
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object url = this.safeString(parameters, "url");
        object hostname = this.safeString(parameters, "hostname");
        object type = this.safeString(parameters, "type");
        if (isTrue(isTrue(isTrue(isEqual(url, null)) || isTrue(isEqual(hostname, null))) || isTrue(isEqual(type, null))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " authenticate requires a url, hostname and type argument")) ;
        }
        this.checkRequiredCredentials();
        object messageHash = "authenticated";
        object relativePath = ((string)url).Replace((string)add("wss://", hostname), (string)"");
        var client = this.client(url);
        var future = client.future(messageHash);
        object authenticated = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(authenticated, null)))
        {
            object timestamp = this.ymdhms(this.milliseconds(), "T");
            object signatureParams = null;
            if (isTrue(isEqual(type, "spot")))
            {
                signatureParams = new Dictionary<string, object>() {
                    { "accessKey", this.apiKey },
                    { "signatureMethod", "HmacSHA256" },
                    { "signatureVersion", "2.1" },
                    { "timestamp", timestamp },
                };
            } else
            {
                signatureParams = new Dictionary<string, object>() {
                    { "AccessKeyId", this.apiKey },
                    { "SignatureMethod", "HmacSHA256" },
                    { "SignatureVersion", "2" },
                    { "Timestamp", timestamp },
                };
            }
            signatureParams = this.keysort(signatureParams);
            object auth = this.urlencode(signatureParams);
            object payload = String.Join("\n", ((IList<object>)new List<object>() {"GET", hostname, relativePath, auth}).ToArray()); // eslint-disable-line quotes
            object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha256, "base64");
            object request = null;
            if (isTrue(isEqual(type, "spot")))
            {
                object newParams = new Dictionary<string, object>() {
                    { "authType", "api" },
                    { "accessKey", this.apiKey },
                    { "signatureMethod", "HmacSHA256" },
                    { "signatureVersion", "2.1" },
                    { "timestamp", timestamp },
                    { "signature", signature },
                };
                request = new Dictionary<string, object>() {
                    { "params", newParams },
                    { "action", "req" },
                    { "ch", "auth" },
                };
            } else
            {
                request = new Dictionary<string, object>() {
                    { "op", "auth" },
                    { "type", "api" },
                    { "AccessKeyId", this.apiKey },
                    { "SignatureMethod", "HmacSHA256" },
                    { "SignatureVersion", "2" },
                    { "Timestamp", timestamp },
                    { "Signature", signature },
                };
            }
            object requestId = this.requestId();
            object subscription = new Dictionary<string, object>() {
                { "id", requestId },
                { "messageHash", messageHash },
                { "params", parameters },
            };
            this.watch(url, messageHash, request, messageHash, subscription);
        }
        return await (future as Exchange.Future);
    }
}
