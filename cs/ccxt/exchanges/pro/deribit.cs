namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class deribit { public deribit(object args = null) : base(args) { } }
public partial class deribit : ccxt.deribit
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchBalance", true },
                { "watchTicker", true },
                { "watchTickers", false },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
                { "watchMyTrades", true },
                { "watchOrders", true },
                { "watchOrderBook", true },
                { "watchOrderBookForSymbols", true },
                { "watchOHLCV", true },
                { "watchOHLCVForSymbols", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "test", new Dictionary<string, object>() {
                    { "ws", "wss://test.deribit.com/ws/api/v2" },
                } },
                { "api", new Dictionary<string, object>() {
                    { "ws", "wss://www.deribit.com/ws/api/v2" },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "ws", new Dictionary<string, object>() {
                    { "timeframes", new Dictionary<string, object>() {
                        { "1m", "1" },
                        { "3m", "3" },
                        { "5m", "5" },
                        { "15m", "15" },
                        { "30m", "30" },
                        { "1h", "60" },
                        { "2h", "120" },
                        { "4h", "180" },
                        { "6h", "360" },
                        { "12h", "720" },
                        { "1d", "1D" },
                    } },
                    { "watchTradesForSymbols", new Dictionary<string, object>() {
                        { "interval", "100ms" },
                    } },
                    { "watchOrderBookForSymbols", new Dictionary<string, object>() {
                        { "interval", "100ms" },
                        { "useDepthEndpoint", false },
                        { "depth", "20" },
                        { "group", "none" },
                    } },
                } },
                { "currencies", new List<object>() {"BTC", "ETH", "SOL", "USDC"} },
            } },
            { "streaming", new Dictionary<string, object>() {} },
            { "exceptions", new Dictionary<string, object>() {} },
        });
    }

    public virtual object requestId()
    {
        object requestId = this.sum(this.safeInteger(this.options, "requestId", 0), 1);
        ((IDictionary<string,object>)this.options)["requestId"] = requestId;
        return requestId;
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @name deribit#watchBalance
        * @see https://docs.deribit.com/#user-portfolio-currency
        * @description watch balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.authenticate(parameters);
        object messageHash = "balance";
        object url = getValue(getValue(this.urls, "api"), "ws");
        object currencies = this.safeValue(this.options, "currencies", new List<object>() {});
        object channels = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currencyCode = getValue(currencies, i);
            ((IList<object>)channels).Add(add("user.portfolio.", currencyCode));
        }
        object subscribe = new Dictionary<string, object>() {
            { "jsonrpc", "2.0" },
            { "method", "private/subscribe" },
            { "params", new Dictionary<string, object>() {
                { "channels", channels },
            } },
            { "id", this.requestId() },
        };
        object request = this.deepExtend(subscribe, parameters);
        return await this.watch(url, messageHash, request, messageHash, request);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        // subscription
        //     {
        //         "jsonrpc": "2.0",
        //         "method": "subscription",
        //         "params": {
        //             "channel": "user.portfolio.btc",
        //             "data": {
        //                 "total_pl": 0,
        //                 "session_upl": 0,
        //                 "session_rpl": 0,
        //                 "projected_maintenance_margin": 0,
        //                 "projected_initial_margin": 0,
        //                 "projected_delta_total": 0,
        //                 "portfolio_margining_enabled": false,
        //                 "options_vega": 0,
        //                 "options_value": 0,
        //                 "options_theta": 0,
        //                 "options_session_upl": 0,
        //                 "options_session_rpl": 0,
        //                 "options_pl": 0,
        //                 "options_gamma": 0,
        //                 "options_delta": 0,
        //                 "margin_balance": 0.0015,
        //                 "maintenance_margin": 0,
        //                 "initial_margin": 0,
        //                 "futures_session_upl": 0,
        //                 "futures_session_rpl": 0,
        //                 "futures_pl": 0,
        //                 "fee_balance": 0,
        //                 "estimated_liquidation_ratio_map": {},
        //                 "estimated_liquidation_ratio": 0,
        //                 "equity": 0.0015,
        //                 "delta_total_map": {},
        //                 "delta_total": 0,
        //                 "currency": "BTC",
        //                 "balance": 0.0015,
        //                 "available_withdrawal_funds": 0.0015,
        //                 "available_funds": 0.0015
        //             }
        //         }
        //     }
        //
        object parameters = this.safeValue(message, "params", new Dictionary<string, object>() {});
        object data = this.safeValue(parameters, "data", new Dictionary<string, object>() {});
        ((IDictionary<string,object>)this.balance)["info"] = data;
        object currencyId = this.safeString(data, "currency");
        object currencyCode = this.safeCurrencyCode(currencyId);
        object balance = this.parseBalance(data);
        ((IDictionary<string,object>)this.balance)[(string)currencyCode] = balance;
        object messageHash = "balance";
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, messageHash});
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name deribit#watchTicker
        * @see https://docs.deribit.com/#ticker-instrument_name-interval
        * @description watches a price ticker, a statistical calculation with the information for a specific market.
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {str} [params.interval] specify aggregation and frequency of notifications. Possible values: 100ms, raw
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object interval = this.safeString(parameters, "interval", "100ms");
        parameters = this.omit(parameters, "interval");
        await this.loadMarkets();
        if (isTrue(isEqual(interval, "raw")))
        {
            await this.authenticate();
        }
        object channel = add(add(add("ticker.", getValue(market, "id")), "."), interval);
        object message = new Dictionary<string, object>() {
            { "jsonrpc", "2.0" },
            { "method", "public/subscribe" },
            { "params", new Dictionary<string, object>() {
                { "channels", new List<object>() {add(add(add("ticker.", getValue(market, "id")), "."), interval)} },
            } },
            { "id", this.requestId() },
        };
        object request = this.deepExtend(message, parameters);
        return await this.watch(url, channel, request, channel, request);
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        //     {
        //         "jsonrpc": "2.0",
        //         "method": "subscription",
        //         "params": {
        //             "channel": "ticker.BTC_USDC-PERPETUAL.raw",
        //             "data": {
        //                 "timestamp": 1655393725040,
        //                 "stats": [Object],
        //                 "state": "open",
        //                 "settlement_price": 21729.5891,
        //                 "open_interest": 164.501,
        //                 "min_price": 20792.9376,
        //                 "max_price": 21426.225,
        //                 "mark_price": 21109.555,
        //                 "last_price": 21132,
        //                 "instrument_name": "BTC_USDC-PERPETUAL",
        //                 "index_price": 21122.3937,
        //                 "funding_8h": -0.00022427,
        //                 "estimated_delivery_price": 21122.3937,
        //                 "current_funding": -0.00010782,
        //                 "best_bid_price": 21106,
        //                 "best_bid_amount": 1.143,
        //                 "best_ask_price": 21113,
        //                 "best_ask_amount": 0.327
        //             }
        //         }
        //     }
        //
        object parameters = this.safeValue(message, "params", new Dictionary<string, object>() {});
        object data = this.safeValue(parameters, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "instrument_name");
        object symbol = this.safeSymbol(marketId);
        object ticker = this.parseTicker(data);
        object messageHash = this.safeString(parameters, "channel");
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name deribit#watchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://docs.deribit.com/#trades-instrument_name-interval
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {str} [params.interval] specify aggregation and frequency of notifications. Possible values: 100ms, raw
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["callerMethodName"] = "watchTrades";
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name deribit#watchTradesForSymbols
        * @description get the list of most recent trades for a list of symbols
        * @see https://docs.deribit.com/#trades-instrument_name-interval
        * @param {string[]} symbols unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        object interval = null;
        var intervalparametersVariable = this.handleOptionAndParams(parameters, "watchTradesForSymbols", "interval", "100ms");
        interval = ((IList<object>)intervalparametersVariable)[0];
        parameters = ((IList<object>)intervalparametersVariable)[1];
        if (isTrue(isEqual(interval, "raw")))
        {
            await this.authenticate();
        }
        object trades = await this.watchMultipleWrapper("trades", interval, symbols, parameters);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeDict(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //         "jsonrpc": "2.0",
        //         "method": "subscription",
        //         "params": {
        //             "channel": "trades.BTC_USDC-PERPETUAL.100ms",
        //             "data": [{
        //                 "trade_seq": 501899,
        //                 "trade_id": "USDC-2436803",
        //                 "timestamp": 1655397355998,
        //                 "tick_direction": 2,
        //                 "price": 21026,
        //                 "mark_price": 21019.9719,
        //                 "instrument_name": "BTC_USDC-PERPETUAL",
        //                 "index_price": 21031.7847,
        //                 "direction": "buy",
        //                 "amount": 0.049
        //             }]
        //         }
        //     }
        //
        object parameters = this.safeDict(message, "params", new Dictionary<string, object>() {});
        object channel = this.safeString(parameters, "channel", "");
        object parts = ((string)channel).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(parts, 1);
        object interval = this.safeString(parts, 2);
        object symbol = this.safeSymbol(marketId);
        object market = this.safeMarket(marketId);
        object trades = this.safeList(parameters, "data", new List<object>() {});
        if (isTrue(isEqual(this.safeValue(this.trades, symbol), null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = new ArrayCache(limit);
        }
        object stored = getValue(this.trades, symbol);
        for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
        {
            object trade = getValue(trades, i);
            object parsed = this.parseTrade(trade, market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        object messageHash = add(add(add("trades|", symbol), "|"), interval);
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.trades, symbol), messageHash});
    }

    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name deribit#watchMyTrades
        * @description get the list of trades associated with the user
        * @see https://docs.deribit.com/#user-trades-instrument_name-interval
        * @param {string} symbol unified symbol of the market to fetch trades for. Use 'any' to watch all trades
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {str} [params.interval] specify aggregation and frequency of notifications. Possible values: 100ms, raw
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.authenticate(parameters);
        if (isTrue(!isEqual(symbol, null)))
        {
            await this.loadMarkets();
            symbol = this.symbol(symbol);
        }
        object url = getValue(getValue(this.urls, "api"), "ws");
        object interval = this.safeString(parameters, "interval", "raw");
        parameters = this.omit(parameters, "interval");
        object channel = add("user.trades.any.any.", interval);
        object message = new Dictionary<string, object>() {
            { "jsonrpc", "2.0" },
            { "method", "private/subscribe" },
            { "params", new Dictionary<string, object>() {
                { "channels", new List<object>() {channel} },
            } },
            { "id", this.requestId() },
        };
        object request = this.deepExtend(message, parameters);
        object trades = await this.watch(url, channel, request, channel, request);
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleMyTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //         "jsonrpc": "2.0",
        //         "method": "subscription",
        //         "params": {
        //             "channel": "user.trades.any.any.raw",
        //             "data": [{
        //                 "trade_seq": 149546319,
        //                 "trade_id": "219381310",
        //                 "timestamp": 1655421193564,
        //                 "tick_direction": 0,
        //                 "state": "filled",
        //                 "self_trade": false,
        //                 "reduce_only": false,
        //                 "profit_loss": 0,
        //                 "price": 20236.5,
        //                 "post_only": false,
        //                 "order_type": "market",
        //                 "order_id": "46108941243",
        //                 "matching_id": null,
        //                 "mark_price": 20233.96,
        //                 "liquidity": "T",
        //                 "instrument_name": "BTC-PERPETUAL",
        //                 "index_price": 20253.31,
        //                 "fee_currency": "BTC",
        //                 "fee": 2.5e-7,
        //                 "direction": "buy",
        //                 "amount": 10
        //             }]
        //         }
        //     }
        //
        object parameters = this.safeValue(message, "params", new Dictionary<string, object>() {});
        object channel = this.safeString(parameters, "channel", "");
        object trades = this.safeValue(parameters, "data", new List<object>() {});
        object cachedTrades = this.myTrades;
        if (isTrue(isEqual(cachedTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            cachedTrades = new ArrayCacheBySymbolById(limit);
        }
        object parsed = this.parseTrades(trades);
        object marketIds = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(parsed)); postFixIncrement(ref i))
        {
            object trade = getValue(parsed, i);
            callDynamically(cachedTrades, "append", new object[] {trade});
            object symbol = getValue(trade, "symbol");
            ((IDictionary<string,object>)marketIds)[(string)symbol] = true;
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {cachedTrades, channel});
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name deribit#watchOrderBook
        * @see https://docs.deribit.com/#book-instrument_name-group-depth-interval
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.interval] Frequency of notifications. Events will be aggregated over this interval. Possible values: 100ms, raw
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["callerMethodName"] = "watchOrderBook";
        return await this.watchOrderBookForSymbols(new List<object>() {symbol}, limit, parameters);
    }

    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name deribit#watchOrderBookForSymbols
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://docs.deribit.com/#book-instrument_name-group-depth-interval
        * @param {string[]} symbols unified array of symbols
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        object interval = null;
        var intervalparametersVariable = this.handleOptionAndParams(parameters, "watchOrderBookForSymbols", "interval", "100ms");
        interval = ((IList<object>)intervalparametersVariable)[0];
        parameters = ((IList<object>)intervalparametersVariable)[1];
        if (isTrue(isEqual(interval, "raw")))
        {
            await this.authenticate();
        }
        object descriptor = "";
        object useDepthEndpoint = null; // for more info, see comment in .options
        var useDepthEndpointparametersVariable = this.handleOptionAndParams(parameters, "watchOrderBookForSymbols", "useDepthEndpoint", false);
        useDepthEndpoint = ((IList<object>)useDepthEndpointparametersVariable)[0];
        parameters = ((IList<object>)useDepthEndpointparametersVariable)[1];
        if (isTrue(useDepthEndpoint))
        {
            object depth = null;
            var depthparametersVariable = this.handleOptionAndParams(parameters, "watchOrderBookForSymbols", "depth", "20");
            depth = ((IList<object>)depthparametersVariable)[0];
            parameters = ((IList<object>)depthparametersVariable)[1];
            object group = null;
            var groupparametersVariable = this.handleOptionAndParams(parameters, "watchOrderBookForSymbols", "group", "none");
            group = ((IList<object>)groupparametersVariable)[0];
            parameters = ((IList<object>)groupparametersVariable)[1];
            descriptor = add(add(add(add(group, "."), depth), "."), interval);
        } else
        {
            descriptor = interval;
        }
        object orderbook = await this.watchMultipleWrapper("book", descriptor, symbols, parameters);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //  snapshot
        //     {
        //         "jsonrpc": "2.0",
        //         "method": "subscription",
        //         "params": {
        //             "channel": "book.BTC_USDC-PERPETUAL.raw",
        //             "data": {
        //                 "type": "snapshot",
        //                 "timestamp": 1655395057025,
        //                 "instrument_name": "BTC_USDC-PERPETUAL",
        //                 "change_id": 1550694837,
        //                 "bids": [
        //                     ["new", 20987, 0.487],
        //                     ["new", 20986, 0.238],
        //                 ],
        //                 "asks": [
        //                     ["new", 20999, 0.092],
        //                     ["new", 21000, 1.238],
        //                 ]
        //             }
        //         }
        //     }
        //
        //  change
        //     {
        //         "jsonrpc": "2.0",
        //         "method": "subscription",
        //         "params": {
        //             "channel": "book.BTC_USDC-PERPETUAL.raw",
        //             "data": {
        //                 "type": "change",
        //                 "timestamp": 1655395168086,
        //                 "prev_change_id": 1550724481,
        //                 "instrument_name": "BTC_USDC-PERPETUAL",
        //                 "change_id": 1550724483,
        //                 "bids": [
        //                     ["new", 20977, 0.109],
        //                     ["delete", 20975, 0]
        //                 ],
        //                 "asks": []
        //             }
        //         }
        //     }
        //
        object parameters = this.safeValue(message, "params", new Dictionary<string, object>() {});
        object data = this.safeValue(parameters, "data", new Dictionary<string, object>() {});
        object channel = this.safeString(parameters, "channel");
        object parts = ((string)channel).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object descriptor = "";
        object partsLength = getArrayLength(parts);
        object isDetailed = isEqual(partsLength, 5);
        if (isTrue(isDetailed))
        {
            object group = this.safeString(parts, 2);
            object depth = this.safeString(parts, 3);
            object interval = this.safeString(parts, 4);
            descriptor = add(add(add(add(group, "."), depth), "."), interval);
        } else
        {
            object interval = this.safeString(parts, 2);
            descriptor = interval;
        }
        object marketId = this.safeString(data, "instrument_name");
        object symbol = this.safeSymbol(marketId);
        object timestamp = this.safeInteger(data, "timestamp");
        object storedOrderBook = this.safeValue(this.orderbooks, symbol);
        if (isTrue(isEqual(storedOrderBook, null)))
        {
            storedOrderBook = this.countedOrderBook();
        }
        object asks = this.safeValue(data, "asks", new List<object>() {});
        object bids = this.safeValue(data, "bids", new List<object>() {});
        this.handleDeltas(getValue(storedOrderBook, "asks"), asks);
        this.handleDeltas(getValue(storedOrderBook, "bids"), bids);
        ((IDictionary<string,object>)storedOrderBook)["nonce"] = timestamp;
        ((IDictionary<string,object>)storedOrderBook)["timestamp"] = timestamp;
        ((IDictionary<string,object>)storedOrderBook)["datetime"] = this.iso8601(timestamp);
        ((IDictionary<string,object>)storedOrderBook)["symbol"] = symbol;
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = storedOrderBook;
        object messageHash = add(add(add("book|", symbol), "|"), descriptor);
        callDynamically(client as WebSocketClient, "resolve", new object[] {storedOrderBook, messageHash});
    }

    public virtual object cleanOrderBook(object data)
    {
        object bids = this.safeValue(data, "bids", new List<object>() {});
        object asks = this.safeValue(data, "asks", new List<object>() {});
        object cleanedBids = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(bids)); postFixIncrement(ref i))
        {
            ((IList<object>)cleanedBids).Add(new List<object>() {getValue(getValue(bids, i), 1), getValue(getValue(bids, i), 2)});
        }
        object cleanedAsks = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(asks)); postFixIncrement(ref i))
        {
            ((IList<object>)cleanedAsks).Add(new List<object>() {getValue(getValue(asks, i), 1), getValue(getValue(asks, i), 2)});
        }
        ((IDictionary<string,object>)data)["bids"] = cleanedBids;
        ((IDictionary<string,object>)data)["asks"] = cleanedAsks;
        return data;
    }

    public override void handleDelta(object bookside, object delta)
    {
        object price = getValue(delta, 1);
        object amount = getValue(delta, 2);
        if (isTrue(isTrue(isEqual(getValue(delta, 0), "new")) || isTrue(isEqual(getValue(delta, 0), "change"))))
        {
            (bookside as IOrderBookSide).store(price, amount, 1);
        } else if (isTrue(isEqual(getValue(delta, 0), "delete")))
        {
            (bookside as IOrderBookSide).store(price, amount, 0);
        }
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name deribit#watchOrders
        * @see https://docs.deribit.com/#user-orders-instrument_name-raw
        * @description watches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate(parameters);
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
        }
        object url = getValue(getValue(this.urls, "api"), "ws");
        object currency = this.safeString(parameters, "currency", "any");
        object interval = this.safeString(parameters, "interval", "raw");
        object kind = this.safeString(parameters, "kind", "any");
        parameters = this.omit(parameters, "interval", "currency", "kind");
        object channel = add(add(add(add(add("user.orders.", kind), "."), currency), "."), interval);
        object message = new Dictionary<string, object>() {
            { "jsonrpc", "2.0" },
            { "method", "private/subscribe" },
            { "params", new Dictionary<string, object>() {
                { "channels", new List<object>() {channel} },
            } },
            { "id", this.requestId() },
        };
        object request = this.deepExtend(message, parameters);
        object orders = await this.watch(url, channel, request, channel, request);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleOrders(WebSocketClient client, object message)
    {
        // Does not return a snapshot of current orders
        //
        //     {
        //         "jsonrpc": "2.0",
        //         "method": "subscription",
        //         "params": {
        //             "channel": "user.orders.any.any.raw",
        //             "data": {
        //                 "web": true,
        //                 "time_in_force": "good_til_cancelled",
        //                 "replaced": false,
        //                 "reduce_only": false,
        //                 "profit_loss": 0,
        //                 "price": 50000,
        //                 "post_only": false,
        //                 "order_type": "limit",
        //                 "order_state": "open",
        //                 "order_id": "46094375191",
        //                 "max_show": 10,
        //                 "last_update_timestamp": 1655401625037,
        //                 "label": '',
        //                 "is_liquidation": false,
        //                 "instrument_name": "BTC-PERPETUAL",
        //                 "filled_amount": 0,
        //                 "direction": "sell",
        //                 "creation_timestamp": 1655401625037,
        //                 "commission": 0,
        //                 "average_price": 0,
        //                 "api": false,
        //                 "amount": 10
        //             }
        //         }
        //     }
        //
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object parameters = this.safeValue(message, "params", new Dictionary<string, object>() {});
        object channel = this.safeString(parameters, "channel", "");
        object data = this.safeValue(parameters, "data", new Dictionary<string, object>() {});
        object orders = new List<object>() {};
        if (isTrue(((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            orders = this.parseOrders(data);
        } else
        {
            object order = this.parseOrder(data);
            orders = new List<object>() {order};
        }
        object cachedOrders = this.orders;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            callDynamically(cachedOrders, "append", new object[] {getValue(orders, i)});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, channel});
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name deribit#watchOHLCV
        * @see https://docs.deribit.com/#chart-trades-instrument_name-resolution
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbol = this.symbol(symbol);
        object ohlcvs = await this.watchOHLCVForSymbols(new List<object>() {new List<object>() {symbol, timeframe}}, since, limit, parameters);
        return getValue(getValue(ohlcvs, symbol), timeframe);
    }

    public async override Task<object> watchOHLCVForSymbols(object symbolsAndTimeframes, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name deribit#watchOHLCVForSymbols
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://docs.deribit.com/#chart-trades-instrument_name-resolution
        * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        parameters ??= new Dictionary<string, object>();
        object symbolsLength = getArrayLength(symbolsAndTimeframes);
        if (isTrue(isTrue(isEqual(symbolsLength, 0)) || !isTrue(((getValue(symbolsAndTimeframes, 0) is IList<object>) || (getValue(symbolsAndTimeframes, 0).GetType().IsGenericType && getValue(symbolsAndTimeframes, 0).GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [[\'BTC/USDT\', \'1m\'], [\'LTC/USDT\', \'5m\']]")) ;
        }
        var symboltimeframecandlesVariable = await this.watchMultipleWrapper("chart.trades", null, symbolsAndTimeframes, parameters);
        var symbol = ((IList<object>) symboltimeframecandlesVariable)[0];
        var timeframe = ((IList<object>) symboltimeframecandlesVariable)[1];
        var candles = ((IList<object>) symboltimeframecandlesVariable)[2];
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(candles, "getLimit", new object[] {symbol, limit});
        }
        object filtered = this.filterBySinceLimit(candles, since, limit, 0, true);
        return this.createOHLCVObject(symbol, timeframe, filtered);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "jsonrpc": "2.0",
        //         "method": "subscription",
        //         "params": {
        //             "channel": "chart.trades.BTC_USDC-PERPETUAL.1",
        //             "data": {
        //                 "volume": 0,
        //                 "tick": 1655403420000,
        //                 "open": 20951,
        //                 "low": 20951,
        //                 "high": 20951,
        //                 "cost": 0,
        //                 "close": 20951
        //             }
        //         }
        //     }
        //
        object parameters = this.safeDict(message, "params", new Dictionary<string, object>() {});
        object channel = this.safeString(parameters, "channel", "");
        object parts = ((string)channel).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(parts, 2);
        object rawTimeframe = this.safeString(parts, 3);
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object wsOptions = this.safeDict(this.options, "ws", new Dictionary<string, object>() {});
        object timeframes = this.safeDict(wsOptions, "timeframes", new Dictionary<string, object>() {});
        object unifiedTimeframe = this.findTimeframe(rawTimeframe, timeframes);
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeDict(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        if (isTrue(isEqual(this.safeValue(getValue(this.ohlcvs, symbol), unifiedTimeframe), null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)unifiedTimeframe] = new ArrayCacheByTimestamp(limit);
        }
        object stored = getValue(getValue(this.ohlcvs, symbol), unifiedTimeframe);
        object ohlcv = this.safeDict(parameters, "data", new Dictionary<string, object>() {});
        // data contains a single OHLCV candle
        object parsed = this.parseWsOHLCV(ohlcv, market);
        callDynamically(stored, "append", new object[] {parsed});
        ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)unifiedTimeframe] = stored;
        object resolveData = new List<object>() {symbol, unifiedTimeframe, stored};
        object messageHash = add(add(add("chart.trades|", symbol), "|"), rawTimeframe);
        callDynamically(client as WebSocketClient, "resolve", new object[] {resolveData, messageHash});
    }

    public override object parseWsOHLCV(object ohlcv, object market = null)
    {
        //
        //    {
        //        "c": "28909.0",
        //        "o": "28915.4",
        //        "h": "28915.4",
        //        "l": "28896.1",
        //        "v": "27.6919",
        //        "T": 1696687499999,
        //        "t": 1696687440000
        //    }
        //
        return new List<object> {this.safeInteger(ohlcv, "tick"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    public async virtual Task<object> watchMultipleWrapper(object channelName, object channelDescriptor, object symbolsArray = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object url = getValue(getValue(this.urls, "api"), "ws");
        object rawSubscriptions = new List<object>() {};
        object messageHashes = new List<object>() {};
        object isOHLCV = (isEqual(channelName, "chart.trades"));
        object symbols = ((bool) isTrue(isOHLCV)) ? this.getListFromObjectValues(symbolsArray, 0) : symbolsArray;
        this.marketSymbols(symbols, null, false);
        for (object i = 0; isLessThan(i, getArrayLength(symbolsArray)); postFixIncrement(ref i))
        {
            object current = getValue(symbolsArray, i);
            object market = null;
            if (isTrue(isOHLCV))
            {
                market = this.market(getValue(current, 0));
                object unifiedTf = getValue(current, 1);
                object rawTf = this.safeString(this.timeframes, unifiedTf, unifiedTf);
                channelDescriptor = rawTf;
            } else
            {
                market = this.market(current);
            }
            object message = add(add(add(add(channelName, "."), getValue(market, "id")), "."), channelDescriptor);
            ((IList<object>)rawSubscriptions).Add(message);
            ((IList<object>)messageHashes).Add(add(add(add(add(channelName, "|"), getValue(market, "symbol")), "|"), channelDescriptor));
        }
        object request = new Dictionary<string, object>() {
            { "jsonrpc", "2.0" },
            { "method", "public/subscribe" },
            { "params", new Dictionary<string, object>() {
                { "channels", rawSubscriptions },
            } },
            { "id", this.requestId() },
        };
        object extendedRequest = this.deepExtend(request, parameters);
        object maxMessageByteLimit = subtract(32768, 1); // 'Message Too Big: limit 32768B'
        object jsonedText = this.json(extendedRequest);
        if (isTrue(isGreaterThanOrEqual(((string)jsonedText).Length, maxMessageByteLimit)))
        {
            throw new ExchangeError ((string)add(this.id, " requested subscription length over limit, try to reduce symbols amount")) ;
        }
        return await this.watchMultiple(url, messageHashes, extendedRequest, rawSubscriptions);
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        //
        // error
        //     {
        //         "jsonrpc": "2.0",
        //         "id": 1,
        //         "error": {
        //             "message": "Invalid params",
        //             "data": {
        //                 "reason": "invalid format",
        //                 "param": "nonce"
        //             },
        //             "code": -32602
        //         },
        //         "usIn": "1655391709417993",
        //         "usOut": "1655391709418049",
        //         "usDiff": 56,
        //         "testnet": false
        //     }
        //
        // subscribe
        //     {
        //         "jsonrpc": "2.0",
        //         "id": 2,
        //         "result": ["ticker.BTC_USDC-PERPETUAL.raw"],
        //         "usIn": "1655393625889396",
        //         "usOut": "1655393625889518",
        //         "usDiff": 122,
        //         "testnet": false
        //     }
        //
        // notification
        //     {
        //         "jsonrpc": "2.0",
        //         "method": "subscription",
        //         "params": {
        //             "channel": "ticker.BTC_USDC-PERPETUAL.raw",
        //             "data": {
        //                 "timestamp": 1655393724752,
        //                 "stats": [Object],
        //                 "state": "open",
        //                 "settlement_price": 21729.5891,
        //                 "open_interest": 164.501,
        //                 "min_price": 20792.9001,
        //                 "max_price": 21426.1864,
        //                 "mark_price": 21109.4757,
        //                 "last_price": 21132,
        //                 "instrument_name": "BTC_USDC-PERPETUAL",
        //                 "index_price": 21122.3937,
        //                 "funding_8h": -0.00022427,
        //                 "estimated_delivery_price": 21122.3937,
        //                 "current_funding": -0.00011158,
        //                 "best_bid_price": 21106,
        //                 "best_bid_amount": 1.143,
        //                 "best_ask_price": 21113,
        //                 "best_ask_amount": 0.402
        //             }
        //         }
        //     }
        //
        object error = this.safeValue(message, "error");
        if (isTrue(!isEqual(error, null)))
        {
            throw new ExchangeError ((string)add(add(this.id, " "), this.json(error))) ;
        }
        object parameters = this.safeValue(message, "params");
        object channel = this.safeString(parameters, "channel");
        if (isTrue(!isEqual(channel, null)))
        {
            object parts = ((string)channel).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
            object channelId = this.safeString(parts, 0);
            object userHandlers = new Dictionary<string, object>() {
                { "trades", this.handleMyTrades },
                { "portfolio", this.handleBalance },
                { "orders", this.handleOrders },
            };
            object handlers = new Dictionary<string, object>() {
                { "ticker", this.handleTicker },
                { "book", this.handleOrderBook },
                { "trades", this.handleTrades },
                { "chart", this.handleOHLCV },
                { "user", this.safeValue(userHandlers, this.safeString(parts, 1)) },
            };
            object handler = this.safeValue(handlers, channelId);
            if (isTrue(!isEqual(handler, null)))
            {
                DynamicInvoker.InvokeMethod(handler, new object[] { client, message});
                return;
            }
            throw new NotSupported ((string)add(add(this.id, " no handler found for this message "), this.json(message))) ;
        }
        object result = this.safeValue(message, "result", new Dictionary<string, object>() {});
        object accessToken = this.safeString(result, "access_token");
        if (isTrue(!isEqual(accessToken, null)))
        {
            this.handleAuthenticationMessage(client as WebSocketClient, message);
        }
    }

    public virtual object handleAuthenticationMessage(WebSocketClient client, object message)
    {
        //
        //     {
        //         "jsonrpc": "2.0",
        //         "id": 1,
        //         "result": {
        //             "token_type": "bearer",
        //             "scope": "account:read_write block_trade:read_write connection custody:read_write mainaccount name:ccxt trade:read_write wallet:read_write",
        //             "refresh_token": "1686927372328.1EzFBRmt.logRQWXkPA1oE_Tk0gRsls9Hau7YN6a321XUBnxvR4x6cryhbkKcniUJU-czA8_zKXrqQGpQmfoDwhLIjIsWCvRuu6otbg-LKWlrtTX1GQqLcPaTTHAdZGTMV-HM8HiS03QBd9MIXWRfF53sKj2hdR9nZPZ6MH1XrkpAZPB_peuEEB9wlcc3elzWEZFtCmiy1fnQ8TPHwAJMt3nuUmEcMLt_-F554qrsg_-I66D9xMiifJj4dBemdPfV_PkGPRIwIoKlxDjyv2-xfCw-4eKyo6Hu1m2h6gT1DPOTxSXcBgfBQjpi-_uY3iAIj7U6xjC46PHthEdquhEuCTZl7UfCRZSAWwZA",
        //             "expires_in": 31536000,
        //             "access_token": "1686923272328.1CkwEx-u.qHradpIulmuoeboKMEi8PkQ1_4DF8yFE2zywBTtkD32sruVC53b1HwL5OWRuh2nYAndXff4xuXIMRkkEfMAFCeq24prihxxinoS8DDVkKBxedGx4CUPJFeXjmh7wuRGqQOLg1plXOpbF3fwF2KPEkAuETwcpcVY6K9HUVjutNRfxFe2TR7CvuS9x8TATvoPeu7H1ezYl-LkKSaRifdTXuwituXgp4oDbPRyQLniEBWuYF9rY7qbABxuOJlXI1VZ63u7Bh0mGWei-KeVeqHGNpy6OgrFRPXPxa9_U7vaxCyHW3zZ9959TQ1QUMLWtUX-NLBEv3BT5eCieW9HORYIOKfsgkpd3"
        //         },
        //         "usIn": "1655391872327712",
        //         "usOut": "1655391872328515",
        //         "usDiff": 803,
        //         "testnet": false
        //     }
        //
        object messageHash = "authenticated";
        callDynamically(client as WebSocketClient, "resolve", new object[] {message, messageHash});
        return message;
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object url = getValue(getValue(this.urls, "api"), "ws");
        var client = this.client(url);
        object time = this.milliseconds();
        object timeString = this.numberToString(time);
        object nonce = timeString;
        object messageHash = "authenticated";
        var future = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(future, null)))
        {
            this.checkRequiredCredentials();
            object requestId = this.requestId();
            object signature = this.hmac(this.encode(add(add(add(timeString, "\n"), nonce), "\n")), this.encode(this.secret), sha256);
            object request = new Dictionary<string, object>() {
                { "jsonrpc", "2.0" },
                { "id", requestId },
                { "method", "public/auth" },
                { "params", new Dictionary<string, object>() {
                    { "grant_type", "client_signature" },
                    { "client_id", this.apiKey },
                    { "timestamp", time },
                    { "signature", signature },
                    { "nonce", nonce },
                    { "data", "" },
                } },
            };
            future = await this.watch(url, messageHash, this.extend(request, parameters), messageHash);
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)messageHash] = future;
        }
        return future;
    }
}
