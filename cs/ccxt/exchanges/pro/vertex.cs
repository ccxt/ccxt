namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class vertex { public vertex(object args = null) : base(args) { } }
public partial class vertex : ccxt.vertex
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchBalance", false },
                { "watchMyTrades", true },
                { "watchOHLCV", false },
                { "watchOrderBook", true },
                { "watchOrders", true },
                { "watchTicker", true },
                { "watchTickers", false },
                { "watchTrades", true },
                { "watchTradesForSymbols", false },
                { "watchPositions", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", "wss://gateway.prod.vertexprotocol.com/v1/subscribe" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "ws", "wss://gateway.sepolia-test.vertexprotocol.com/v1/subscribe" },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", false },
                { "secret", false },
                { "walletAddress", true },
                { "privateKey", true },
            } },
            { "options", new Dictionary<string, object>() {
                { "tradesLimit", 1000 },
                { "ordersLimit", 1000 },
                { "requestId", new Dictionary<string, object>() {} },
                { "watchPositions", new Dictionary<string, object>() {
                    { "fetchPositionsSnapshot", true },
                    { "awaitPositionsSnapshot", true },
                } },
                { "ws", new Dictionary<string, object>() {
                    { "inflate", true },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "keepAlive", 30000 },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "ws", new Dictionary<string, object>() {
                    { "exact", new Dictionary<string, object>() {
                        { "Auth is needed.", typeof(AuthenticationError) },
                    } },
                } },
            } },
        });
    }

    public virtual object requestId(object url)
    {
        object options = this.safeDict(this.options, "requestId", new Dictionary<string, object>() {});
        object previousValue = this.safeInteger(options, url, 0);
        object newValue = this.sum(previousValue, 1);
        ((IDictionary<string,object>)getValue(this.options, "requestId"))[(string)url] = newValue;
        return newValue;
    }

    public async virtual Task<object> watchPublic(object messageHash, object message)
    {
        object url = getValue(getValue(this.urls, "api"), "ws");
        object requestId = this.requestId(url);
        object subscribe = new Dictionary<string, object>() {
            { "id", requestId },
        };
        object request = this.extend(subscribe, message);
        object wsOptions = new Dictionary<string, object>() {
            { "headers", new Dictionary<string, object>() {
                { "Sec-WebSocket-Extensions", "permessage-deflate" },
            } },
        };
        ((IDictionary<string,object>)this.options)["ws"] = new Dictionary<string, object>() {
            { "options", wsOptions },
        };
        return await this.watch(url, messageHash, request, messageHash, subscribe);
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name vertex#watchTrades
        * @description watches information on multiple trades made in a market
        * @see https://docs.vertexprotocol.com/developer-resources/api/subscriptions/streams
        * @param {string} symbol unified market symbol of the market trades were made in
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trade structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object name = "trade";
        object topic = add(add(getValue(market, "id"), "@"), name);
        object request = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "stream", new Dictionary<string, object>() {
                { "type", name },
                { "product_id", this.parseToNumeric(getValue(market, "id")) },
            } },
        };
        object message = this.extend(request, parameters);
        object trades = await this.watchPublic(topic, message);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {getValue(market, "symbol"), limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleTrade(WebSocketClient client, object message)
    {
        //
        // {
        //     "type": "trade",
        //     "timestamp": "1676151190656903000", // timestamp of the event in nanoseconds
        //     "product_id": 1,
        //     "price": "1000", // price the trade happened at, multiplied by 1e18
        //     // both taker_qty and maker_qty have the same value;
        //     // set to filled amount (min amount of taker and maker) when matching against book
        //     // set to matched amm base amount when matching against amm
        //     "taker_qty": "1000",
        //     "maker_qty": "1000",
        //     "is_taker_buyer": true,
        //     "is_maker_amm": true // true when maker is amm
        // }
        //
        object topic = this.safeString(message, "type");
        object marketId = this.safeString(message, "product_id");
        object trade = this.parseWsTrade(message);
        object symbol = getValue(trade, "symbol");
        if (!isTrue((inOp(this.trades, symbol))))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            var stored = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        object trades = getValue(this.trades, symbol);
        callDynamically(trades, "append", new object[] {trade});
        ((IDictionary<string,object>)this.trades)[(string)symbol] = trades;
        callDynamically(client as WebSocketClient, "resolve", new object[] {trades, add(add(marketId, "@"), topic)});
    }

    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name vertex#watchMyTrades
        * @description watches information on multiple trades made by the user
        * @see https://docs.vertexprotocol.com/developer-resources/api/subscriptions/streams
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.user] user address, will default to this.walletAddress if not provided
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchMyTrades requires a symbol.")) ;
        }
        await this.loadMarkets();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("watchMyTrades", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object market = this.market(symbol);
        object name = "fill";
        object topic = add(add(getValue(market, "id"), "@"), name);
        object request = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "stream", new Dictionary<string, object>() {
                { "type", name },
                { "product_id", this.parseToNumeric(getValue(market, "id")) },
                { "subaccount", this.convertAddressToSender(userAddress) },
            } },
        };
        object message = this.extend(request, parameters);
        object trades = await this.watchPublic(topic, message);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleMyTrades(WebSocketClient client, object message)
    {
        //
        // {
        //     "type": "fill",
        //     "timestamp": "1676151190656903000", // timestamp of the event in nanoseconds
        //     "product_id": 1,
        //     // the subaccount that placed this order
        //     "subaccount": "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43746573743000000000000000",
        //     // hash of the order that uniquely identifies it
        //     "order_digest": "0xf4f7a8767faf0c7f72251a1f9e5da590f708fd9842bf8fcdeacbaa0237958fff",
        //     // the amount filled, multiplied by 1e18
        //     "filled_qty": "1000",
        //     // the amount outstanding unfilled, multiplied by 1e18
        //     "remaining_qty": "2000",
        //     // the original order amount, multiplied by 1e18
        //     "original_qty": "3000",
        //     // fill price
        //     "price": "24991000000000000000000",
        //     // true for `taker`, false for `maker`
        //     "is_taker": true,
        //     "is_bid": true,
        //     // true when matching against amm
        //     "is_against_amm": true,
        //     // an optional `order id` that can be provided when placing an order
        //     "id": 100
        // }
        //
        object topic = this.safeString(message, "type");
        object marketId = this.safeString(message, "product_id");
        if (isTrue(isEqual(this.myTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            this.myTrades = new ArrayCacheBySymbolById(limit);
        }
        object trades = this.myTrades;
        object parsed = this.parseWsTrade(message);
        callDynamically(trades, "append", new object[] {parsed});
        callDynamically(client as WebSocketClient, "resolve", new object[] {trades, add(add(marketId, "@"), topic)});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        // watchTrades
        // {
        //     "type": "trade",
        //     "timestamp": "1676151190656903000", // timestamp of the event in nanoseconds
        //     "product_id": 1,
        //     "price": "1000", // price the trade happened at, multiplied by 1e18
        //     // both taker_qty and maker_qty have the same value;
        //     // set to filled amount (min amount of taker and maker) when matching against book
        //     // set to matched amm base amount when matching against amm
        //     "taker_qty": "1000",
        //     "maker_qty": "1000",
        //     "is_taker_buyer": true,
        //     "is_maker_amm": true // true when maker is amm
        // }
        // watchMyTrades
        // {
        //     "type": "fill",
        //     "timestamp": "1676151190656903000", // timestamp of the event in nanoseconds
        //     "product_id": 1,
        //     // the subaccount that placed this order
        //     "subaccount": "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43746573743000000000000000",
        //     // hash of the order that uniquely identifies it
        //     "order_digest": "0xf4f7a8767faf0c7f72251a1f9e5da590f708fd9842bf8fcdeacbaa0237958fff",
        //     // the amount filled, multiplied by 1e18
        //     "filled_qty": "1000",
        //     // the amount outstanding unfilled, multiplied by 1e18
        //     "remaining_qty": "2000",
        //     // the original order amount, multiplied by 1e18
        //     "original_qty": "3000",
        //     // fill price
        //     "price": "24991000000000000000000",
        //     // true for `taker`, false for `maker`
        //     "is_taker": true,
        //     "is_bid": true,
        //     // true when matching against amm
        //     "is_against_amm": true,
        //     // an optional `order id` that can be provided when placing an order
        //     "id": 100
        // }
        //
        object marketId = this.safeString(trade, "product_id");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object price = this.convertFromX18(this.safeString(trade, "price"));
        object amount = this.convertFromX18(this.safeString2(trade, "taker_qty", "filled_qty"));
        object cost = Precise.stringMul(price, amount);
        object timestamp = this.safeIntegerProduct(trade, "timestamp", 0.000001);
        object takerOrMaker = null;
        object isTaker = this.safeBool(trade, "is_taker");
        if (isTrue(!isEqual(isTaker, null)))
        {
            takerOrMaker = ((bool) isTrue((isTaker))) ? "taker" : "maker";
        }
        object side = null;
        object isBid = this.safeBool(trade, "is_bid");
        if (isTrue(!isEqual(isBid, null)))
        {
            side = ((bool) isTrue((isBid))) ? "buy" : "sell";
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "order", this.safeString2(trade, "digest", "id") },
            { "takerOrMaker", takerOrMaker },
            { "type", null },
            { "fee", null },
            { "info", trade },
        }, market);
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name vertex#watchTicker
        * @see https://docs.vertexprotocol.com/developer-resources/api/subscriptions/streams
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "best_bid_offer";
        object market = this.market(symbol);
        object topic = add(add(getValue(market, "id"), "@"), name);
        object request = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "stream", new Dictionary<string, object>() {
                { "type", name },
                { "product_id", this.parseToNumeric(getValue(market, "id")) },
            } },
        };
        object message = this.extend(request, parameters);
        return await this.watchPublic(topic, message);
    }

    public virtual object parseWsTicker(object ticker, object market = null)
    {
        //
        // {
        //     "type": "best_bid_offer",
        //     "timestamp": "1676151190656903000", // timestamp of the event in nanoseconds
        //     "product_id": 1,
        //     "bid_price": "1000", // the highest bid price, multiplied by 1e18
        //     "bid_qty": "1000", // quantity at the huighest bid, multiplied by 1e18.
        //                        // i.e. if this is USDC with 6 decimals, one USDC
        //                        // would be 1e12
        //     "ask_price": "1000", // lowest ask price
        //     "ask_qty": "1000" // quantity at the lowest ask
        // }
        //
        object timestamp = this.safeIntegerProduct(ticker, "timestamp", 0.000001);
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(null, market) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.convertFromX18(this.safeString(ticker, "bid_price")) },
            { "bidVolume", this.convertFromX18(this.safeString(ticker, "bid_qty")) },
            { "ask", this.convertFromX18(this.safeString(ticker, "ask_price")) },
            { "askVolume", this.convertFromX18(this.safeString(ticker, "ask_qty")) },
            { "vwap", null },
            { "open", null },
            { "close", null },
            { "last", null },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", null },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    public virtual object handleTicker(WebSocketClient client, object message)
    {
        //
        // {
        //     "type": "best_bid_offer",
        //     "timestamp": "1676151190656903000", // timestamp of the event in nanoseconds
        //     "product_id": 1,
        //     "bid_price": "1000", // the highest bid price, multiplied by 1e18
        //     "bid_qty": "1000", // quantity at the huighest bid, multiplied by 1e18.
        //                        // i.e. if this is USDC with 6 decimals, one USDC
        //                        // would be 1e12
        //     "ask_price": "1000", // lowest ask price
        //     "ask_qty": "1000" // quantity at the lowest ask
        // }
        //
        object marketId = this.safeString(message, "product_id");
        object market = this.safeMarket(marketId);
        object ticker = this.parseWsTicker(message, market);
        ((IDictionary<string,object>)ticker)["symbol"] = getValue(market, "symbol");
        ((IDictionary<string,object>)this.tickers)[(string)getValue(market, "symbol")] = ticker;
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, add(marketId, "@best_bid_offer")});
        return message;
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name vertex#watchOrderBook
        * @see https://docs.vertexprotocol.com/developer-resources/api/subscriptions/streams
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return.
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "book_depth";
        object market = this.market(symbol);
        object messageHash = add(add(getValue(market, "id"), "@"), name);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object requestId = this.requestId(url);
        object request = new Dictionary<string, object>() {
            { "id", requestId },
            { "method", "subscribe" },
            { "stream", new Dictionary<string, object>() {
                { "type", name },
                { "product_id", this.parseToNumeric(getValue(market, "id")) },
            } },
        };
        object subscription = new Dictionary<string, object>() {
            { "id", ((object)requestId).ToString() },
            { "name", name },
            { "symbol", symbol },
            { "method", this.handleOrderBookSubscription },
            { "limit", limit },
            { "params", parameters },
        };
        object message = this.extend(request, parameters);
        object orderbook = await this.watch(url, messageHash, message, messageHash, subscription);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBookSubscription(WebSocketClient client, object message, object subscription)
    {
        object defaultLimit = this.safeInteger(this.options, "watchOrderBookLimit", 1000);
        object limit = this.safeInteger(subscription, "limit", defaultLimit);
        object symbol = this.safeString(subscription, "symbol"); // watchOrderBook
        if (isTrue(inOp(this.orderbooks, symbol)))
        {
            ((IDictionary<string,object>)this.orderbooks).Remove((string)symbol);
        }
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
        this.spawn(this.fetchOrderBookSnapshot, new object[] { client, message, subscription});
    }

    public async virtual Task fetchOrderBookSnapshot(WebSocketClient client, object message, object subscription)
    {
        object symbol = this.safeString(subscription, "symbol");
        object market = this.market(symbol);
        object messageHash = add(getValue(market, "id"), "@book_depth");
        try
        {
            object defaultLimit = this.safeInteger(this.options, "watchOrderBookLimit", 1000);
            object limit = this.safeInteger(subscription, "limit", defaultLimit);
            object parameters = this.safeValue(subscription, "params");
            object snapshot = await this.fetchRestOrderBookSafe(symbol, limit, parameters);
            if (isTrue(isEqual(this.safeValue(this.orderbooks, symbol), null)))
            {
                // if the orderbook is dropped before the snapshot is received
                return;
            }
            object orderbook = getValue(this.orderbooks, symbol);
            (orderbook as IOrderBook).reset(snapshot);
            object messages = (orderbook as ccxt.pro.OrderBook).cache;
            for (object i = 0; isLessThan(i, getArrayLength(messages)); postFixIncrement(ref i))
            {
                object messageItem = getValue(messages, i);
                object lastTimestamp = this.parseToInt(Precise.stringDiv(this.safeString(messageItem, "last_max_timestamp"), "1000000"));
                if (isTrue(isLessThan(lastTimestamp, getValue(orderbook, "timestamp"))))
                {
                    continue;
                } else
                {
                    this.handleOrderBookMessage(client as WebSocketClient, messageItem, orderbook);
                }
            }
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
            callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
        } catch(Exception e)
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
            ((WebSocketClient)client).reject(e, messageHash);
        }
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //
        // the feed does not include a snapshot, just the deltas
        //
        // {
        //     "type":"book_depth",
        //     // book depth aggregates a number of events once every 50ms
        //     // these are the minimum and maximum timestamps from
        //     // events that contributed to this response
        //     "min_timestamp": "1683805381879572835",
        //     "max_timestamp": "1683805381879572835",
        //     // the max_timestamp of the last book_depth event for this product
        //     "last_max_timestamp": "1683805381771464799",
        //     "product_id":1,
        //     // changes to the bid side of the book in the form of [[price, new_qty]]
        //     "bids":[["21594490000000000000000","51007390115411548"]],
        //     // changes to the ask side of the book in the form of [[price, new_qty]]
        //     "asks":[["21694490000000000000000","0"],["21695050000000000000000","0"]]
        // }
        //
        object marketId = this.safeString(message, "product_id");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        if (!isTrue((inOp(this.orderbooks, symbol))))
        {
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook();
        }
        object orderbook = getValue(this.orderbooks, symbol);
        object timestamp = this.safeInteger(orderbook, "timestamp");
        if (isTrue(isEqual(timestamp, null)))
        {
            // Buffer the events you receive from the stream.
            ((IList<object>)(orderbook as ccxt.pro.OrderBook).cache).Add(message);
        } else
        {
            object lastTimestamp = this.parseToInt(Precise.stringDiv(this.safeString(message, "last_max_timestamp"), "1000000"));
            if (isTrue(isGreaterThan(lastTimestamp, timestamp)))
            {
                this.handleOrderBookMessage(client as WebSocketClient, message, orderbook);
                callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, add(marketId, "@book_depth")});
            }
        }
    }

    public virtual object handleOrderBookMessage(WebSocketClient client, object message, object orderbook)
    {
        object timestamp = this.parseToInt(Precise.stringDiv(this.safeString(message, "last_max_timestamp"), "1000000"));
        // convert from X18
        object data = new Dictionary<string, object>() {
            { "bids", new List<object>() {} },
            { "asks", new List<object>() {} },
        };
        object bids = this.safeList(message, "bids", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(bids)); postFixIncrement(ref i))
        {
            object bid = getValue(bids, i);
            ((IList<object>)getValue(data, "bids")).Add(new List<object> {this.convertFromX18(getValue(bid, 0)), this.convertFromX18(getValue(bid, 1))});
        }
        object asks = this.safeList(message, "asks", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(asks)); postFixIncrement(ref i))
        {
            object ask = getValue(asks, i);
            ((IList<object>)getValue(data, "asks")).Add(new List<object> {this.convertFromX18(getValue(ask, 0)), this.convertFromX18(getValue(ask, 1))});
        }
        this.handleDeltas(getValue(orderbook, "asks"), this.safeList(data, "asks", new List<object>() {}));
        this.handleDeltas(getValue(orderbook, "bids"), this.safeList(data, "bids", new List<object>() {}));
        ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
        ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        return orderbook;
    }

    public override void handleDelta(object bookside, object delta)
    {
        object price = this.safeFloat(delta, 0);
        object amount = this.safeFloat(delta, 1);
        (bookside as IOrderBookSide).store(price, amount);
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    public virtual object handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //     {
        //         "result": null,
        //         "id": 1574649734450
        //     }
        //
        object id = this.safeString(message, "id");
        object subscriptionsById = this.indexBy(((WebSocketClient)client).subscriptions, "id");
        object subscription = this.safeValue(subscriptionsById, id, new Dictionary<string, object>() {});
        object method = this.safeValue(subscription, "method");
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message, subscription});
        }
        return message;
    }

    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name vertex#watchPositions
        * @see https://docs.vertexprotocol.com/developer-resources/api/subscriptions/streams
        * @description watch all open positions
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the exchange API endpoint
        * @param {string} [params.user] user address, will default to this.walletAddress if not provided
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        if (!isTrue(this.isEmpty(symbols)))
        {
            if (isTrue(isGreaterThan(getArrayLength(symbols), 1)))
            {
                throw new NotSupported ((string)add(this.id, " watchPositions require only one symbol.")) ;
            }
        } else
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchPositions require one symbol.")) ;
        }
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("watchPositions", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object url = getValue(getValue(this.urls, "api"), "ws");
        var client = this.client(url);
        this.setPositionsCache(client as WebSocketClient, symbols, parameters);
        object fetchPositionsSnapshot = this.handleOption("watchPositions", "fetchPositionsSnapshot", true);
        object awaitPositionsSnapshot = this.handleOption("watchPositions", "awaitPositionsSnapshot", true);
        if (isTrue(isTrue(isTrue(fetchPositionsSnapshot) && isTrue(awaitPositionsSnapshot)) && isTrue(isEqual(this.positions, null))))
        {
            object snapshot = await client.future("fetchPositionsSnapshot");
            return this.filterBySymbolsSinceLimit(snapshot, symbols, since, limit, true);
        }
        object name = "position_change";
        object market = this.market(getValue(symbols, 0));
        object topic = add(add(getValue(market, "id"), "@"), name);
        object request = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "stream", new Dictionary<string, object>() {
                { "type", name },
                { "product_id", this.parseToNumeric(getValue(market, "id")) },
                { "subaccount", this.convertAddressToSender(userAddress) },
            } },
        };
        object message = this.extend(request, parameters);
        object newPositions = await this.watchPublic(topic, message);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(newPositions, "getLimit", new object[] {getValue(symbols, 0), limit});
        }
        return this.filterBySymbolsSinceLimit(this.positions, symbols, since, limit, true);
    }

    public virtual void setPositionsCache(WebSocketClient client, object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object fetchPositionsSnapshot = this.handleOption("watchPositions", "fetchPositionsSnapshot", false);
        if (isTrue(fetchPositionsSnapshot))
        {
            object messageHash = "fetchPositionsSnapshot";
            if (!isTrue((inOp(client.futures, messageHash))))
            {
                client.future(messageHash);
                this.spawn(this.loadPositionsSnapshot, new object[] { client, messageHash, symbols, parameters});
            }
        } else
        {
            this.positions = new ArrayCacheBySymbolBySide();
        }
    }

    public async virtual Task loadPositionsSnapshot(WebSocketClient client, object messageHash, object symbols, object parameters)
    {
        object positions = await this.fetchPositions(symbols, parameters);
        this.positions = new ArrayCacheBySymbolBySide();
        object cache = this.positions;
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object position = getValue(positions, i);
            callDynamically(cache, "append", new object[] {position});
        }
        // don't remove the future from the .futures cache
        var future = getValue(client.futures, messageHash);
        (future as Future).resolve(cache);
        callDynamically(client as WebSocketClient, "resolve", new object[] {cache, "positions"});
    }

    public virtual void handlePositions(WebSocketClient client, object message)
    {
        //
        // {
        //     "type":"position_change",
        //     "timestamp": "1676151190656903000", // timestamp of event in nanoseconds
        //     "product_id":1,
        //      // whether this is a position change for the LP token for this product
        //     "is_lp":false,
        //     // subaccount who's position changed
        //     "subaccount":"0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43706d00000000000000000000",
        //     // new amount for this product
        //     "amount":"51007390115411548",
        //     // new quote balance for this product; zero for everything except non lp perps
        //     // the negative of the entry cost of the perp
        //     "v_quote_amount":"0"
        // }
        //
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new ArrayCacheBySymbolBySide();
        }
        object cache = this.positions;
        object topic = this.safeString(message, "type");
        object marketId = this.safeString(message, "product_id");
        object market = this.safeMarket(marketId);
        object position = this.parseWsPosition(message, market);
        callDynamically(cache, "append", new object[] {position});
        callDynamically(client as WebSocketClient, "resolve", new object[] {position, add(add(marketId, "@"), topic)});
    }

    public virtual object parseWsPosition(object position, object market = null)
    {
        //
        // {
        //     "type":"position_change",
        //     "timestamp": "1676151190656903000", // timestamp of event in nanoseconds
        //     "product_id":1,
        //      // whether this is a position change for the LP token for this product
        //     "is_lp":false,
        //     // subaccount who's position changed
        //     "subaccount":"0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43706d00000000000000000000",
        //     // new amount for this product
        //     "amount":"51007390115411548",
        //     // new quote balance for this product; zero for everything except non lp perps
        //     // the negative of the entry cost of the perp
        //     "v_quote_amount":"0"
        // }
        //
        object marketId = this.safeString(position, "product_id");
        market = this.safeMarket(marketId);
        object contractSize = this.convertFromX18(this.safeString(position, "amount"));
        object side = "buy";
        if (isTrue(Precise.stringLt(contractSize, "1")))
        {
            side = "sell";
        }
        object timestamp = this.parseToInt(Precise.stringDiv(this.safeString(position, "timestamp"), "1000000"));
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", this.safeString(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "entryPrice", null },
            { "notional", null },
            { "leverage", null },
            { "unrealizedPnl", null },
            { "contracts", null },
            { "contractSize", this.parseNumber(contractSize) },
            { "marginRatio", null },
            { "liquidationPrice", null },
            { "markPrice", null },
            { "lastPrice", null },
            { "collateral", null },
            { "marginMode", "cross" },
            { "marginType", null },
            { "side", side },
            { "percentage", null },
            { "hedged", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    public virtual void handleAuth(WebSocketClient client, object message)
    {
        //
        // { result: null, id: 1 }
        //
        object messageHash = "authenticated";
        object error = this.safeString(message, "error");
        if (isTrue(isEqual(error, null)))
        {
            // client.resolve (message, messageHash);
            var future = this.safeValue((client as WebSocketClient).futures, "authenticated");
            (future as Future).resolve(true);
        } else
        {
            var authError = new AuthenticationError(this.json(message));
            ((WebSocketClient)client).reject(authError, messageHash);
            // allows further authentication attempts
            if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
            {
                ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)"authenticated");
            }
        }
    }

    public virtual object buildWsAuthenticationSig(object message, object chainId, object verifyingContractAddress)
    {
        object messageTypes = new Dictionary<string, object>() {
            { "StreamAuthentication", new List<object>() {new Dictionary<string, object>() {
    { "name", "sender" },
    { "type", "bytes32" },
}, new Dictionary<string, object>() {
    { "name", "expiration" },
    { "type", "uint64" },
}} },
        };
        return this.buildSig(chainId, messageTypes, message, verifyingContractAddress);
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object url = getValue(getValue(this.urls, "api"), "ws");
        var client = this.client(url);
        object messageHash = "authenticated";
        var future = client.future(messageHash);
        object authenticated = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(authenticated, null)))
        {
            object requestId = this.requestId(url);
            object contracts = await this.queryContracts();
            object chainId = this.safeString(contracts, "chain_id");
            object verifyingContractAddress = this.safeString(contracts, "endpoint_addr");
            object now = this.nonce();
            object nonce = add(now, 90000);
            object authentication = new Dictionary<string, object>() {
                { "sender", this.convertAddressToSender(this.walletAddress) },
                { "expiration", nonce },
            };
            object request = new Dictionary<string, object>() {
                { "id", requestId },
                { "method", "authenticate" },
                { "tx", new Dictionary<string, object>() {
                    { "sender", getValue(authentication, "sender") },
                    { "expiration", this.numberToString(getValue(authentication, "expiration")) },
                } },
                { "signature", this.buildWsAuthenticationSig(authentication, chainId, verifyingContractAddress) },
            };
            object message = this.extend(request, parameters);
            this.watch(url, messageHash, message, messageHash);
        }
        return await (future as Exchange.Future);
    }

    public async virtual Task<object> watchPrivate(object messageHash, object message, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticate(parameters);
        object url = getValue(getValue(this.urls, "api"), "ws");
        object requestId = this.requestId(url);
        object subscribe = new Dictionary<string, object>() {
            { "id", requestId },
        };
        object request = this.extend(subscribe, message);
        return await this.watch(url, messageHash, request, messageHash, subscribe);
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name vertex#watchOrders
        * @description watches information on multiple orders made by the user
        * @see https://docs.vertexprotocol.com/developer-resources/api/subscriptions/streams
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchOrders requires a symbol.")) ;
        }
        this.checkRequiredCredentials();
        await this.loadMarkets();
        object name = "order_update";
        object market = this.market(symbol);
        object topic = add(add(getValue(market, "id"), "@"), name);
        object request = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "stream", new Dictionary<string, object>() {
                { "type", name },
                { "subaccount", this.convertAddressToSender(this.walletAddress) },
                { "product_id", this.parseToNumeric(getValue(market, "id")) },
            } },
        };
        object message = this.extend(request, parameters);
        object orders = await this.watchPrivate(topic, message);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual object parseWsOrderStatus(object status)
    {
        if (isTrue(!isEqual(status, null)))
        {
            object statuses = new Dictionary<string, object>() {
                { "filled", "open" },
                { "placed", "open" },
                { "cancelled", "canceled" },
            };
            return this.safeString(statuses, status, status);
        }
        return status;
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        // {
        //     "type": "order_update",
        //     // timestamp of the event in nanoseconds
        //     "timestamp": "1695081920633151000",
        //     "product_id": 1,
        //     // order digest
        //     "digest": "0xf7712b63ccf70358db8f201e9bf33977423e7a63f6a16f6dab180bdd580f7c6c",
        //     // remaining amount to be filled.
        //     // will be `0` if the order is either fully filled or cancelled.
        //     "amount": "82000000000000000",
        //     // any of: "filled", "cancelled", "placed"
        //     "reason": "filled"
        //     // an optional `order id` that can be provided when placing an order
        //     "id": 100
        // }
        //
        object marketId = this.safeString(order, "product_id");
        object timestamp = this.parseToInt(Precise.stringDiv(this.safeString(order, "timestamp"), "1000000"));
        object remainingString = this.convertFromX18(this.safeString(order, "amount"));
        object remaining = this.parseToNumeric(remainingString);
        object status = this.parseWsOrderStatus(this.safeString(order, "reason"));
        if (isTrue(isTrue(Precise.stringEq(remainingString, "0")) && isTrue(isEqual(status, "open"))))
        {
            status = "closed";
        }
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString2(order, "digest", "id") },
            { "clientOrderId", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", null },
            { "symbol", symbol },
            { "type", null },
            { "timeInForce", null },
            { "postOnly", null },
            { "reduceOnly", null },
            { "side", null },
            { "price", null },
            { "triggerPrice", null },
            { "amount", null },
            { "cost", null },
            { "average", null },
            { "filled", null },
            { "remaining", remaining },
            { "status", status },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public virtual void handleOrderUpdate(WebSocketClient client, object message)
    {
        //
        // {
        //     "type": "order_update",
        //     // timestamp of the event in nanoseconds
        //     "timestamp": "1695081920633151000",
        //     "product_id": 1,
        //     // order digest
        //     "digest": "0xf7712b63ccf70358db8f201e9bf33977423e7a63f6a16f6dab180bdd580f7c6c",
        //     // remaining amount to be filled.
        //     // will be `0` if the order is either fully filled or cancelled.
        //     "amount": "82000000000000000",
        //     // any of: "filled", "cancelled", "placed"
        //     "reason": "filled"
        //     // an optional `order id` that can be provided when placing an order
        //     "id": 100
        // }
        //
        object topic = this.safeString(message, "type");
        object marketId = this.safeString(message, "product_id");
        object parsed = this.parseWsOrder(message);
        object symbol = this.safeString(parsed, "symbol");
        object orderId = this.safeString(parsed, "id");
        if (isTrue(!isEqual(symbol, null)))
        {
            if (isTrue(isEqual(this.orders, null)))
            {
                object limit = this.safeInteger(this.options, "ordersLimit", 1000);
                this.orders = new ArrayCacheBySymbolById(limit);
            }
            object cachedOrders = this.orders;
            object orders = this.safeDict((cachedOrders as ArrayCacheBySymbolById).hashmap, symbol, new Dictionary<string, object>() {});
            object order = this.safeDict(orders, orderId);
            if (isTrue(!isEqual(order, null)))
            {
                ((IDictionary<string,object>)parsed)["timestamp"] = this.safeInteger(order, "timestamp");
                ((IDictionary<string,object>)parsed)["datetime"] = this.safeString(order, "datetime");
            }
            callDynamically(cachedOrders, "append", new object[] {parsed});
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, add(add(marketId, "@"), topic)});
        }
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        //
        // {
        //     result: null,
        //     error: 'error parsing request: missing field `expiration`',
        //     id: 0
        // }
        //
        object errorMessage = this.safeString(message, "error");
        try
        {
            if (isTrue(!isEqual(errorMessage, null)))
            {
                object feedback = add(add(this.id, " "), this.json(message));
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorMessage, feedback);
            }
            return false;
        } catch(Exception error)
        {
            if (isTrue(error is AuthenticationError))
            {
                object messageHash = "authenticated";
                ((WebSocketClient)client).reject(error, messageHash);
                if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
                {
                    ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
                }
            } else
            {
                ((WebSocketClient)client).reject(error);
            }
            return true;
        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            return;
        }
        object methods = new Dictionary<string, object>() {
            { "trade", this.handleTrade },
            { "best_bid_offer", this.handleTicker },
            { "book_depth", this.handleOrderBook },
            { "fill", this.handleMyTrades },
            { "position_change", this.handlePositions },
            { "order_update", this.handleOrderUpdate },
        };
        object eventVar = this.safeString(message, "type");
        object method = this.safeValue(methods, eventVar);
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
            return;
        }
        object requestId = this.safeString(message, "id");
        if (isTrue(!isEqual(requestId, null)))
        {
            this.handleSubscriptionStatus(client as WebSocketClient, message);
            return;
        }
        // check whether it's authentication
        object auth = this.safeValue((client as WebSocketClient).futures, "authenticated");
        if (isTrue(!isEqual(auth, null)))
        {
            this.handleAuth(client as WebSocketClient, message);
        }
    }
}
