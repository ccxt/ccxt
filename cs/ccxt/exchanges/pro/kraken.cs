namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class kraken { public kraken(object args = null) : base(args) { } }
public partial class kraken : ccxt.kraken
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchBalance", false },
                { "watchMyTrades", true },
                { "watchOHLCV", true },
                { "watchOrderBook", true },
                { "watchOrderBookForSymbols", true },
                { "watchOrders", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
                { "createOrderWs", true },
                { "editOrderWs", true },
                { "cancelOrderWs", true },
                { "cancelOrdersWs", true },
                { "cancelAllOrdersWs", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://ws.kraken.com" },
                        { "private", "wss://ws-auth.kraken.com" },
                        { "beta", "wss://beta-ws.kraken.com" },
                        { "beta-private", "wss://beta-ws-auth.kraken.com" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "tradesLimit", 1000 },
                { "OHLCVLimit", 1000 },
                { "ordersLimit", 1000 },
                { "symbolsByOrderId", new Dictionary<string, object>() {} },
                { "checksum", true },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "ws", new Dictionary<string, object>() {
                    { "exact", new Dictionary<string, object>() {
                        { "Event(s) not found", typeof(BadRequest) },
                    } },
                    { "broad", new Dictionary<string, object>() {
                        { "Already subscribed", typeof(BadRequest) },
                        { "Currency pair not in ISO 4217-A3 format", typeof(BadSymbol) },
                        { "Malformed request", typeof(BadRequest) },
                        { "Pair field must be an array", typeof(BadRequest) },
                        { "Pair field unsupported for this subscription type", typeof(BadRequest) },
                        { "Pair(s) not found", typeof(BadSymbol) },
                        { "Subscription book depth must be an integer", typeof(BadRequest) },
                        { "Subscription depth not supported", typeof(BadRequest) },
                        { "Subscription field must be an object", typeof(BadRequest) },
                        { "Subscription name invalid", typeof(BadRequest) },
                        { "Subscription object unsupported field", typeof(BadRequest) },
                        { "Subscription ohlc interval must be an integer", typeof(BadRequest) },
                        { "Subscription ohlc interval not supported", typeof(BadRequest) },
                        { "Subscription ohlc requires interval", typeof(BadRequest) },
                        { "EAccount:Invalid permissions", typeof(PermissionDenied) },
                        { "EAuth:Account temporary disabled", typeof(AccountSuspended) },
                        { "EAuth:Account unconfirmed", typeof(AuthenticationError) },
                        { "EAuth:Rate limit exceeded", typeof(RateLimitExceeded) },
                        { "EAuth:Too many requests", typeof(RateLimitExceeded) },
                        { "EDatabase: Internal error (to be deprecated)", typeof(ExchangeError) },
                        { "EGeneral:Internal error[:<code>]", typeof(ExchangeError) },
                        { "EGeneral:Invalid arguments", typeof(BadRequest) },
                        { "EOrder:Cannot open opposing position", typeof(InvalidOrder) },
                        { "EOrder:Cannot open position", typeof(InvalidOrder) },
                        { "EOrder:Insufficient funds (insufficient user funds)", typeof(InsufficientFunds) },
                        { "EOrder:Insufficient margin (exchange does not have sufficient funds to allow margin trading)", typeof(InsufficientFunds) },
                        { "EOrder:Invalid price", typeof(InvalidOrder) },
                        { "EOrder:Margin allowance exceeded", typeof(InvalidOrder) },
                        { "EOrder:Margin level too low", typeof(InvalidOrder) },
                        { "EOrder:Margin position size exceeded (client would exceed the maximum position size for this pair)", typeof(InvalidOrder) },
                        { "EOrder:Order minimum not met (volume too low)", typeof(InvalidOrder) },
                        { "EOrder:Orders limit exceeded", typeof(InvalidOrder) },
                        { "EOrder:Positions limit exceeded", typeof(InvalidOrder) },
                        { "EOrder:Rate limit exceeded", typeof(RateLimitExceeded) },
                        { "EOrder:Scheduled orders limit exceeded", typeof(InvalidOrder) },
                        { "EOrder:Unknown position", typeof(OrderNotFound) },
                        { "EOrder:Unknown order", typeof(OrderNotFound) },
                        { "EOrder:Invalid order", typeof(InvalidOrder) },
                        { "EService:Deadline elapsed", typeof(ExchangeNotAvailable) },
                        { "EService:Market in cancel_only mode", typeof(NotSupported) },
                        { "EService:Market in limit_only mode", typeof(NotSupported) },
                        { "EService:Market in post_only mode", typeof(NotSupported) },
                        { "EService:Unavailable", typeof(ExchangeNotAvailable) },
                        { "ETrade:Invalid request", typeof(BadRequest) },
                    } },
                } },
            } },
        });
    }

    public async override Task<object> createOrderWs(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#createOrderWs
        * @see https://docs.kraken.com/websockets/#message-addOrder
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object token = await this.authenticate();
        object market = this.market(symbol);
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        object requestId = this.requestId();
        object messageHash = requestId;
        object request = new Dictionary<string, object>() {
            { "event", "addOrder" },
            { "token", token },
            { "reqid", requestId },
            { "ordertype", type },
            { "type", side },
            { "pair", getValue(market, "wsId") },
            { "volume", this.amountToPrecision(symbol, amount) },
        };
        var requestparametersVariable = this.orderRequest("createOrderWs", symbol, type, request, price, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        return await this.watch(url, messageHash, this.extend(request, parameters), messageHash);
    }

    public virtual void handleCreateEditOrder(WebSocketClient client, object message)
    {
        //
        //  createOrder
        //    {
        //        "descr": "sell 0.00010000 XBTUSDT @ market",
        //        "event": "addOrderStatus",
        //        "reqid": 1,
        //        "status": "ok",
        //        "txid": "OAVXZH-XIE54-JCYYDG"
        //    }
        //  editOrder
        //    {
        //        "descr": "order edited price = 9000.00000000",
        //        "event": "editOrderStatus",
        //        "originaltxid": "O65KZW-J4AW3-VFS74A",
        //        "reqid": 3,
        //        "status": "ok",
        //        "txid": "OTI672-HJFAO-XOIPPK"
        //    }
        //
        object order = this.parseOrder(message);
        object messageHash = this.safeValue(message, "reqid");
        callDynamically(client as WebSocketClient, "resolve", new object[] {order, messageHash});
    }

    public async override Task<object> editOrderWs(object id, object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#editOrderWs
        * @description edit a trade order
        * @see https://docs.kraken.com/websockets/#message-editOrder
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of the currency you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object token = await this.authenticate();
        object market = this.market(symbol);
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        object requestId = this.requestId();
        object messageHash = requestId;
        object request = new Dictionary<string, object>() {
            { "event", "editOrder" },
            { "token", token },
            { "reqid", requestId },
            { "orderid", id },
            { "pair", getValue(market, "wsId") },
            { "volume", this.amountToPrecision(symbol, amount) },
        };
        var requestparametersVariable = this.orderRequest("editOrderWs", symbol, type, request, price, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        return await this.watch(url, messageHash, this.extend(request, parameters), messageHash);
    }

    public async override Task<object> cancelOrdersWs(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#cancelOrdersWs
        * @see https://docs.kraken.com/websockets/#message-cancelOrder
        * @description cancel multiple orders
        * @param {string[]} ids order ids
        * @param {string} symbol unified market symbol, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object token = await this.authenticate();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        object requestId = this.requestId();
        object messageHash = requestId;
        object request = new Dictionary<string, object>() {
            { "event", "cancelOrder" },
            { "token", token },
            { "reqid", requestId },
            { "txid", ids },
        };
        return await this.watch(url, messageHash, this.extend(request, parameters), messageHash);
    }

    public async override Task<object> cancelOrderWs(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#cancelOrderWs
        * @see https://docs.kraken.com/websockets/#message-cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object token = await this.authenticate();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        object requestId = this.requestId();
        object messageHash = requestId;
        object clientOrderId = this.safeValue2(parameters, "userref", "clientOrderId", id);
        parameters = this.omit(parameters, new List<object>() {"userref", "clientOrderId"});
        object request = new Dictionary<string, object>() {
            { "event", "cancelOrder" },
            { "token", token },
            { "reqid", requestId },
            { "txid", new List<object>() {clientOrderId} },
        };
        return await this.watch(url, messageHash, this.extend(request, parameters), messageHash);
    }

    public virtual void handleCancelOrder(WebSocketClient client, object message)
    {
        //
        //  success
        //    {
        //        "event": "cancelOrderStatus",
        //        "status": "ok"
        //        "reqid": 1,
        //    }
        //
        object reqId = this.safeValue(message, "reqid");
        callDynamically(client as WebSocketClient, "resolve", new object[] {message, reqId});
    }

    public async override Task<object> cancelAllOrdersWs(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#cancelAllOrdersWs
        * @see https://docs.kraken.com/websockets/#message-cancelAll
        * @description cancel all open orders
        * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(!isEqual(symbol, null)))
        {
            throw new NotSupported ((string)add(this.id, " cancelAllOrdersWs () does not support cancelling orders in a specific market.")) ;
        }
        await this.loadMarkets();
        object token = await this.authenticate();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        object requestId = this.requestId();
        object messageHash = requestId;
        object request = new Dictionary<string, object>() {
            { "event", "cancelAll" },
            { "token", token },
            { "reqid", requestId },
        };
        return await this.watch(url, messageHash, this.extend(request, parameters), messageHash);
    }

    public virtual void handleCancelAllOrders(WebSocketClient client, object message)
    {
        //
        //    {
        //        "count": 2,
        //        "event": "cancelAllStatus",
        //        "status": "ok",
        //        "reqId": 1
        //    }
        //
        object reqId = this.safeValue(message, "reqid");
        callDynamically(client as WebSocketClient, "resolve", new object[] {message, reqId});
    }

    public virtual void handleTicker(WebSocketClient client, object message, object subscription)
    {
        //
        //     [
        //         0, // channelID
        //         {
        //             "a": [ "5525.40000", 1, "1.000" ], // ask, wholeAskVolume, askVolume
        //             "b": [ "5525.10000", 1, "1.000" ], // bid, wholeBidVolume, bidVolume
        //             "c": [ "5525.10000", "0.00398963" ], // closing price, volume
        //             "h": [ "5783.00000", "5783.00000" ], // high price today, high price 24h ago
        //             "l": [ "5505.00000", "5505.00000" ], // low price today, low price 24h ago
        //             "o": [ "5760.70000", "5763.40000" ], // open price today, open price 24h ago
        //             "p": [ "5631.44067", "5653.78939" ], // vwap today, vwap 24h ago
        //             "t": [ 11493, 16267 ], // number of trades today, 24 hours ago
        //             "v": [ "2634.11501494", "3591.17907851" ], // volume today, volume 24 hours ago
        //         },
        //         "ticker",
        //         "XBT/USD"
        //     ]
        //
        object wsName = getValue(message, 3);
        object market = this.safeValue(getValue(this.options, "marketsByWsName"), wsName);
        object symbol = getValue(market, "symbol");
        object messageHash = this.getMessageHash("ticker", null, symbol);
        object ticker = getValue(message, 1);
        object vwap = this.safeString(getValue(ticker, "p"), 0);
        object quoteVolume = null;
        object baseVolume = this.safeString(getValue(ticker, "v"), 0);
        if (isTrue(isTrue(!isEqual(baseVolume, null)) && isTrue(!isEqual(vwap, null))))
        {
            quoteVolume = Precise.stringMul(baseVolume, vwap);
        }
        object last = this.safeString(getValue(ticker, "c"), 0);
        object result = this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "high", this.safeString(getValue(ticker, "h"), 0) },
            { "low", this.safeString(getValue(ticker, "l"), 0) },
            { "bid", this.safeString(getValue(ticker, "b"), 0) },
            { "bidVolume", this.safeString(getValue(ticker, "b"), 2) },
            { "ask", this.safeString(getValue(ticker, "a"), 0) },
            { "askVolume", this.safeString(getValue(ticker, "a"), 2) },
            { "vwap", vwap },
            { "open", this.safeString(getValue(ticker, "o"), 0) },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        });
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = result;
        callDynamically(client as WebSocketClient, "resolve", new object[] {result, messageHash});
    }

    public virtual void handleTrades(WebSocketClient client, object message, object subscription)
    {
        //
        //     [
        //         0, // channelID
        //         [ //     price        volume         time             side type misc
        //             [ "5541.20000", "0.15850568", "1534614057.321596", "s", "l", "" ],
        //             [ "6060.00000", "0.02455000", "1534614057.324998", "b", "l", "" ],
        //         ],
        //         "trade",
        //         "XBT/USD"
        //     ]
        //
        object wsName = this.safeString(message, 3);
        object name = this.safeString(message, 2);
        object market = this.safeValue(getValue(this.options, "marketsByWsName"), wsName);
        object symbol = getValue(market, "symbol");
        object messageHash = this.getMessageHash(name, null, symbol);
        object stored = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        object trades = this.safeValue(message, 1, new List<object>() {});
        object parsed = this.parseTrades(trades, market);
        for (object i = 0; isLessThan(i, getArrayLength(parsed)); postFixIncrement(ref i))
        {
            callDynamically(stored, "append", new object[] {getValue(parsed, i)});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public virtual void handleOHLCV(WebSocketClient client, object message, object subscription)
    {
        //
        //     [
        //         216, // channelID
        //         [
        //             "1574454214.962096", // Time, seconds since epoch
        //             "1574454240.000000", // End timestamp of the interval
        //             "0.020970", // Open price at midnight UTC
        //             "0.020970", // Intraday high price
        //             "0.020970", // Intraday low price
        //             "0.020970", // Closing price at midnight UTC
        //             "0.020970", // Volume weighted average price
        //             "0.08636138", // Accumulated volume today
        //             1, // Number of trades today
        //         ],
        //         "ohlc-1", // Channel Name of subscription
        //         "ETH/XBT", // Asset pair
        //     ]
        //
        object info = this.safeValue(subscription, "subscription", new Dictionary<string, object>() {});
        object interval = this.safeInteger(info, "interval");
        object name = this.safeString(info, "name");
        object wsName = this.safeString(message, 3);
        object market = this.safeValue(getValue(this.options, "marketsByWsName"), wsName);
        object symbol = getValue(market, "symbol");
        object timeframe = this.findTimeframe(interval);
        object duration = this.parseTimeframe(timeframe);
        if (isTrue(!isEqual(timeframe, null)))
        {
            object candle = this.safeValue(message, 1);
            object messageHash = add(add(add(add(name, ":"), timeframe), ":"), wsName);
            object timestamp = this.safeFloat(candle, 1);
            timestamp = subtract(timestamp, duration);
            object ts = this.parseToInt(multiply(timestamp, 1000));
            object result = new List<object>() {ts, this.safeFloat(candle, 2), this.safeFloat(candle, 3), this.safeFloat(candle, 4), this.safeFloat(candle, 5), this.safeFloat(candle, 7)};
            ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
            object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
            if (isTrue(isEqual(stored, null)))
            {
                object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
                stored = new ArrayCacheByTimestamp(limit);
                ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
            }
            callDynamically(stored, "append", new object[] {result});
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        }
    }

    public virtual object requestId()
    {
        // their support said that reqid must be an int32, not documented
        object reqid = this.sum(this.safeInteger(this.options, "reqid", 0), 1);
        ((IDictionary<string,object>)this.options)["reqid"] = reqid;
        return reqid;
    }

    public async virtual Task<object> watchPublic(object name, object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object wsName = this.safeValue(getValue(market, "info"), "wsname");
        object messageHash = add(add(name, ":"), wsName);
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "public");
        object requestId = this.requestId();
        object subscribe = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "reqid", requestId },
            { "pair", new List<object>() {wsName} },
            { "subscription", new Dictionary<string, object>() {
                { "name", name },
            } },
        };
        object request = this.deepExtend(subscribe, parameters);
        return await this.watch(url, messageHash, request, messageHash);
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name kraken#watchTicker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbol = this.symbol(symbol);
        object tickers = await this.watchTickers(new List<object>() {symbol}, parameters);
        return getValue(tickers, symbol);
    }

    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#watchTickers
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object ticker = await this.watchMultiHelper("ticker", "ticker", symbols, null, parameters);
        if (isTrue(this.newUpdates))
        {
            object result = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)result)[(string)getValue(ticker, "symbol")] = ticker;
            return result;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#watchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://docs.kraken.com/websockets/#message-trade
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#watchTradesForSymbols
        * @see https://docs.kraken.com/websockets/#message-trade
        * @description get the list of most recent trades for a list of symbols
        * @param {string[]} symbols unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        object trades = await this.watchMultiHelper("trade", "trade", symbols, null, parameters);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeList(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#watchOrderBook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://docs.kraken.com/websockets/#message-book
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchOrderBookForSymbols(new List<object>() {symbol}, limit, parameters);
    }

    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#watchOrderBookForSymbols
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://docs.kraken.com/websockets/#message-book
        * @param {string[]} symbols unified array of symbols
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(this.inArray(limit, new List<object>() {10, 25, 100, 500, 1000})))
            {
                ((IDictionary<string,object>)request)["subscription"] = new Dictionary<string, object>() {
                    { "depth", limit },
                };
            } else
            {
                throw new NotSupported ((string)add(this.id, " watchOrderBook accepts limit values of 10, 25, 100, 500 and 1000 only")) ;
            }
        }
        object orderbook = await this.watchMultiHelper("orderbook", "book", symbols, new Dictionary<string, object>() {
            { "limit", limit },
        }, this.extend(request, parameters));
        return (orderbook as IOrderBook).limit();
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#watchOHLCV
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "ohlc";
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object wsName = this.safeValue(getValue(market, "info"), "wsname");
        object messageHash = add(add(add(add(name, ":"), timeframe), ":"), wsName);
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "public");
        object requestId = this.requestId();
        object subscribe = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "reqid", requestId },
            { "pair", new List<object>() {wsName} },
            { "subscription", new Dictionary<string, object>() {
                { "name", name },
                { "interval", this.safeValue(this.timeframes, timeframe, timeframe) },
            } },
        };
        object request = this.deepExtend(subscribe, parameters);
        object ohlcv = await this.watch(url, messageHash, request, messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public async override Task<object> loadMarkets(object reload = null, object parameters = null)
    {
        reload ??= false;
        parameters ??= new Dictionary<string, object>();
        object markets = await base.loadMarkets(reload, parameters);
        object marketsByWsName = this.safeValue(this.options, "marketsByWsName");
        if (isTrue(isTrue((isEqual(marketsByWsName, null))) || isTrue(reload)))
        {
            marketsByWsName = new Dictionary<string, object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(this.symbols, i);
                object market = getValue(this.markets, symbol);
                if (isTrue(getValue(market, "darkpool")))
                {
                    object info = this.safeValue(market, "info", new Dictionary<string, object>() {});
                    object altname = this.safeString(info, "altname");
                    object wsName = add(add(slice(altname, 0, 3), "/"), slice(altname, 3, null));
                    ((IDictionary<string,object>)marketsByWsName)[(string)wsName] = market;
                } else
                {
                    object info = this.safeValue(market, "info", new Dictionary<string, object>() {});
                    object wsName = this.safeString(info, "wsname");
                    ((IDictionary<string,object>)marketsByWsName)[(string)wsName] = market;
                }
            }
            ((IDictionary<string,object>)this.options)["marketsByWsName"] = marketsByWsName;
        }
        return markets;
    }

    public async virtual Task<object> watchHeartbeat(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object eventVar = "heartbeat";
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "public");
        return await this.watch(url, eventVar);
    }

    public virtual void handleHeartbeat(WebSocketClient client, object message)
    {
        //
        // every second (approx) if no other updates are sent
        //
        //     { "event": "heartbeat" }
        //
        object eventVar = this.safeString(message, "event");
        callDynamically(client as WebSocketClient, "resolve", new object[] {message, eventVar});
    }

    public virtual void handleOrderBook(WebSocketClient client, object message, object subscription)
    {
        //
        // first message (snapshot)
        //
        //     [
        //         1234, // channelID
        //         {
        //             "as": [
        //                 [ "5541.30000", "2.50700000", "1534614248.123678" ],
        //                 [ "5541.80000", "0.33000000", "1534614098.345543" ],
        //                 [ "5542.70000", "0.64700000", "1534614244.654432" ]
        //             ],
        //             "bs": [
        //                 [ "5541.20000", "1.52900000", "1534614248.765567" ],
        //                 [ "5539.90000", "0.30000000", "1534614241.769870" ],
        //                 [ "5539.50000", "5.00000000", "1534613831.243486" ]
        //             ]
        //         },
        //         "book-10",
        //         "XBT/USD"
        //     ]
        //
        // subsequent updates
        //
        //     [
        //         1234,
        //         { // optional
        //             "a": [
        //                 [ "5541.30000", "2.50700000", "1534614248.456738" ],
        //                 [ "5542.50000", "0.40100000", "1534614248.456738" ]
        //             ]
        //         },
        //         { // optional
        //             "b": [
        //                 [ "5541.30000", "0.00000000", "1534614335.345903" ]
        //             ]
        //         },
        //         "book-10",
        //         "XBT/USD"
        //     ]
        //
        object messageLength = getArrayLength(message);
        object wsName = getValue(message, subtract(messageLength, 1));
        object bookDepthString = getValue(message, subtract(messageLength, 2));
        object parts = ((string)bookDepthString).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
        object depth = this.safeInteger(parts, 1, 10);
        object market = this.safeValue(getValue(this.options, "marketsByWsName"), wsName);
        object symbol = getValue(market, "symbol");
        object timestamp = null;
        object messageHash = this.getMessageHash("orderbook", null, symbol);
        // if this is a snapshot
        if (isTrue(inOp(getValue(message, 1), "as")))
        {
            // todo get depth from marketsByWsName
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, depth);
            object orderbook = getValue(this.orderbooks, symbol);
            object sides = new Dictionary<string, object>() {
                { "as", "asks" },
                { "bs", "bids" },
            };
            object keys = new List<object>(((IDictionary<string,object>)sides).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
            {
                object key = getValue(keys, i);
                object side = getValue(sides, key);
                object bookside = getValue(orderbook, side);
                object deltas = this.safeValue(getValue(message, 1), key, new List<object>() {});
                timestamp = this.customHandleDeltas(bookside, deltas, timestamp);
            }
            ((IDictionary<string,object>)orderbook)["symbol"] = symbol;
            ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
            callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
        } else
        {
            object orderbook = getValue(this.orderbooks, symbol);
            // else, if this is an orderbook update
            object a = null;
            object b = null;
            object c = null;
            if (isTrue(isEqual(messageLength, 5)))
            {
                a = this.safeValue(getValue(message, 1), "a", new List<object>() {});
                b = this.safeValue(getValue(message, 2), "b", new List<object>() {});
                c = this.safeInteger(getValue(message, 1), "c");
                c = this.safeInteger(getValue(message, 2), "c", c);
            } else
            {
                c = this.safeInteger(getValue(message, 1), "c");
                if (isTrue(inOp(getValue(message, 1), "a")))
                {
                    a = this.safeValue(getValue(message, 1), "a", new List<object>() {});
                } else
                {
                    b = this.safeValue(getValue(message, 1), "b", new List<object>() {});
                }
            }
            object storedAsks = getValue(orderbook, "asks");
            object storedBids = getValue(orderbook, "bids");
            object example = null;
            if (isTrue(!isEqual(a, null)))
            {
                timestamp = this.customHandleDeltas(storedAsks, a, timestamp);
                example = this.safeValue(a, 0);
            }
            if (isTrue(!isEqual(b, null)))
            {
                timestamp = this.customHandleDeltas(storedBids, b, timestamp);
                example = this.safeValue(b, 0);
            }
            // don't remove this line or I will poop on your face
            (orderbook as IOrderBook).limit();
            object checksum = this.safeBool(this.options, "checksum", true);
            if (isTrue(checksum))
            {
                object priceString = this.safeString(example, 0);
                object amountString = this.safeString(example, 1);
                object priceParts = ((string)priceString).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
                object amountParts = ((string)amountString).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
                object priceLength = subtract(((string)getValue(priceParts, 1)).Length, 0);
                object amountLength = subtract(((string)getValue(amountParts, 1)).Length, 0);
                object payloadArray = new List<object>() {};
                if (isTrue(!isEqual(c, null)))
                {
                    for (object i = 0; isLessThan(i, 10); postFixIncrement(ref i))
                    {
                        object formatted = add(this.formatNumber(getValue(getValue(storedAsks, i), 0), priceLength), this.formatNumber(getValue(getValue(storedAsks, i), 1), amountLength));
                        ((IList<object>)payloadArray).Add(formatted);
                    }
                    for (object i = 0; isLessThan(i, 10); postFixIncrement(ref i))
                    {
                        object formatted = add(this.formatNumber(getValue(getValue(storedBids, i), 0), priceLength), this.formatNumber(getValue(getValue(storedBids, i), 1), amountLength));
                        ((IList<object>)payloadArray).Add(formatted);
                    }
                }
                object payload = String.Join("", ((IList<object>)payloadArray).ToArray());
                object localChecksum = this.crc32(payload, false);
                if (isTrue(!isEqual(localChecksum, c)))
                {
                    var error = new InvalidNonce(add(this.id, " invalid checksum"));


                    ((WebSocketClient)client).reject(error, messageHash);
                    return;
                }
            }
            ((IDictionary<string,object>)orderbook)["symbol"] = symbol;
            ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
            callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
        }
    }

    public virtual object formatNumber(object n, object length)
    {
        object stringNumber = this.numberToString(n);
        object parts = ((string)stringNumber).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object integer = this.safeString(parts, 0);
        object decimals = this.safeString(parts, 1, "");
        object paddedDecimals = (decimals as String).PadRight(Convert.ToInt32(length), Convert.ToChar("0"));
        object joined = add(integer, paddedDecimals);
        object i = 0;
        while (isEqual(getValue(joined, i), "0"))
        {
            i = add(i, 1);
        }
        if (isTrue(isGreaterThan(i, 0)))
        {
            return slice(joined, i, null);
        } else
        {
            return joined;
        }
    }

    public virtual object customHandleDeltas(object bookside, object deltas, object timestamp = null)
    {
        for (object j = 0; isLessThan(j, getArrayLength(deltas)); postFixIncrement(ref j))
        {
            object delta = getValue(deltas, j);
            object price = this.parseNumber(getValue(delta, 0));
            object amount = this.parseNumber(getValue(delta, 1));
            object oldTimestamp = ((bool) isTrue(timestamp)) ? timestamp : 0;
            timestamp = mathMax(oldTimestamp, this.parseToInt(multiply(parseFloat(getValue(delta, 2)), 1000)));
            (bookside as IOrderBookSide).store(price, amount);
        }
        return timestamp;
    }

    public virtual object handleSystemStatus(WebSocketClient client, object message)
    {
        //
        // todo: answer the question whether handleSystemStatus should be renamed
        // and unified as handleStatus for any usage pattern that
        // involves system status and maintenance updates
        //
        //     {
        //         "connectionID": 15527282728335292000,
        //         "event": "systemStatus",
        //         "status": "online", // online|maintenance|(custom status tbd)
        //         "version": "0.2.0"
        //     }
        //
        return message;
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        var client = this.client(url);
        object authenticated = "authenticated";
        object subscription = this.safeValue(((WebSocketClient)client).subscriptions, authenticated);
        if (isTrue(isEqual(subscription, null)))
        {
            object response = await this.privatePostGetWebSocketsToken(parameters);
            //
            //     {
            //         "error":[],
            //         "result":{
            //             "token":"xeAQ\/RCChBYNVh53sTv1yZ5H4wIbwDF20PiHtTF+4UI",
            //             "expires":900
            //         }
            //     }
            //
            subscription = this.safeValue(response, "result");
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)authenticated] = subscription;
        }
        return this.safeString(subscription, "token");
    }

    public async virtual Task<object> watchPrivate(object name, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object token = await this.authenticate();
        object subscriptionHash = name;
        object messageHash = name;
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
            messageHash = add(messageHash, add(":", symbol));
        }
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        object requestId = this.requestId();
        object subscribe = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "reqid", requestId },
            { "subscription", new Dictionary<string, object>() {
                { "name", name },
                { "token", token },
            } },
        };
        object request = this.deepExtend(subscribe, parameters);
        object result = await this.watch(url, messageHash, request, subscriptionHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(result, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(result, symbol, since, limit);
    }

    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#watchMyTrades
        * @description watches information on multiple trades made by the user
        * @param {string} symbol unified market symbol of the market trades were made in
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trade structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchPrivate("ownTrades", symbol, since, limit, parameters);
    }

    public virtual void handleMyTrades(WebSocketClient client, object message, object subscription = null)
    {
        //
        //     [
        //         [
        //             {
        //                 "TT5UC3-GOIRW-6AZZ6R": {
        //                     "cost": "1493.90107",
        //                     "fee": "3.88415",
        //                     "margin": "0.00000",
        //                     "ordertxid": "OTLAS3-RRHUF-NDWH5A",
        //                     "ordertype": "market",
        //                     "pair": "XBT/USDT",
        //                     "postxid": "TKH2SE-M7IF5-CFI7LT",
        //                     "price": "6851.50005",
        //                     "time": "1586822919.335498",
        //                     "type": "sell",
        //                     "vol": "0.21804000"
        //                 }
        //             },
        //             {
        //                 "TIY6G4-LKLAI-Y3GD4A": {
        //                     "cost": "22.17134",
        //                     "fee": "0.05765",
        //                     "margin": "0.00000",
        //                     "ordertxid": "ODQXS7-MOLK6-ICXKAA",
        //                     "ordertype": "market",
        //                     "pair": "ETH/USD",
        //                     "postxid": "TKH2SE-M7IF5-CFI7LT",
        //                     "price": "169.97999",
        //                     "time": "1586340530.895739",
        //                     "type": "buy",
        //                     "vol": "0.13043500"
        //                 }
        //             },
        //         ],
        //         "ownTrades",
        //         { sequence: 1 }
        //     ]
        //
        object allTrades = this.safeValue(message, 0, new List<object>() {});
        object allTradesLength = getArrayLength(allTrades);
        if (isTrue(isGreaterThan(allTradesLength, 0)))
        {
            if (isTrue(isEqual(this.myTrades, null)))
            {
                object limit = this.safeInteger(this.options, "tradesLimit", 1000);
                this.myTrades = new ArrayCache(limit);
            }
            object stored = this.myTrades;
            object symbols = new Dictionary<string, object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(allTrades)); postFixIncrement(ref i))
            {
                object trades = this.safeValue(allTrades, i, new Dictionary<string, object>() {});
                object ids = new List<object>(((IDictionary<string,object>)trades).Keys);
                for (object j = 0; isLessThan(j, getArrayLength(ids)); postFixIncrement(ref j))
                {
                    object id = getValue(ids, j);
                    object trade = getValue(trades, id);
                    object parsed = this.parseWsTrade(this.extend(new Dictionary<string, object>() {
                        { "id", id },
                    }, trade));
                    callDynamically(stored, "append", new object[] {parsed});
                    object symbol = getValue(parsed, "symbol");
                    ((IDictionary<string,object>)symbols)[(string)symbol] = true;
                }
            }
            object name = "ownTrades";
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.myTrades, name});
            object keys = new List<object>(((IDictionary<string,object>)symbols).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
            {
                object messageHash = add(add(name, ":"), getValue(keys, i));
                callDynamically(client as WebSocketClient, "resolve", new object[] {this.myTrades, messageHash});
            }
        }
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        //     {
        //         "id": "TIMIRG-WUNNE-RRJ6GT", // injected from outside
        //         "ordertxid": "OQRPN2-LRHFY-HIFA7D",
        //         "postxid": "TKH2SE-M7IF5-CFI7LT",
        //         "pair": "USDCUSDT",
        //         "time": 1586340086.457,
        //         "type": "sell",
        //         "ordertype": "market",
        //         "price": "0.99860000",
        //         "cost": "22.16892001",
        //         "fee": "0.04433784",
        //         "vol": "22.20000000",
        //         "margin": "0.00000000",
        //         "misc": ''
        //     }
        //
        //     {
        //         "id": "TIY6G4-LKLAI-Y3GD4A",
        //         "cost": "22.17134",
        //         "fee": "0.05765",
        //         "margin": "0.00000",
        //         "ordertxid": "ODQXS7-MOLK6-ICXKAA",
        //         "ordertype": "market",
        //         "pair": "ETH/USD",
        //         "postxid": "TKH2SE-M7IF5-CFI7LT",
        //         "price": "169.97999",
        //         "time": "1586340530.895739",
        //         "type": "buy",
        //         "vol": "0.13043500"
        //     }
        //
        object wsName = this.safeString(trade, "pair");
        market = this.safeValue(getValue(this.options, "marketsByWsName"), wsName, market);
        object symbol = null;
        object orderId = this.safeString(trade, "ordertxid");
        object id = this.safeString2(trade, "id", "postxid");
        object timestamp = this.safeTimestamp(trade, "time");
        object side = this.safeString(trade, "type");
        object type = this.safeString(trade, "ordertype");
        object price = this.safeFloat(trade, "price");
        object amount = this.safeFloat(trade, "vol");
        object cost = null;
        object fee = null;
        if (isTrue(inOp(trade, "fee")))
        {
            object currency = null;
            if (isTrue(!isEqual(market, null)))
            {
                currency = getValue(market, "quote");
            }
            fee = new Dictionary<string, object>() {
                { "cost", this.safeFloat(trade, "fee") },
                { "currency", currency },
            };
        }
        if (isTrue(!isEqual(market, null)))
        {
            symbol = getValue(market, "symbol");
        }
        if (isTrue(!isEqual(price, null)))
        {
            if (isTrue(!isEqual(amount, null)))
            {
                cost = multiply(price, amount);
            }
        }
        return new Dictionary<string, object>() {
            { "id", id },
            { "order", orderId },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", type },
            { "side", side },
            { "takerOrMaker", null },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "fee", fee },
        };
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#watchOrders
        * @see https://docs.kraken.com/websockets/#message-openOrders
        * @description watches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of  orde structures to retrieve
        * @param {object} [params] maximum number of orderic to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchPrivate("openOrders", symbol, since, limit, parameters);
    }

    public virtual void handleOrders(WebSocketClient client, object message, object subscription = null)
    {
        //
        //     [
        //         [
        //             {
        //                 "OGTT3Y-C6I3P-XRI6HX": {
        //                     "cost": "0.00000",
        //                     "descr": {
        //                         "close": "",
        //                         "leverage": "0:1",
        //                         "order": "sell 10.00345345 XBT/EUR @ limit 34.50000 with 0:1 leverage",
        //                         "ordertype": "limit",
        //                         "pair": "XBT/EUR",
        //                         "price": "34.50000",
        //                         "price2": "0.00000",
        //                         "type": "sell"
        //                     },
        //                     "expiretm": "0.000000",
        //                     "fee": "0.00000",
        //                     "limitprice": "34.50000",
        //                     "misc": "",
        //                     "oflags": "fcib",
        //                     "opentm": "0.000000",
        //                     "price": "34.50000",
        //                     "refid": "OKIVMP-5GVZN-Z2D2UA",
        //                     "starttm": "0.000000",
        //                     "status": "open",
        //                     "stopprice": "0.000000",
        //                     "userref": 0,
        //                     "vol": "10.00345345",
        //                     "vol_exec": "0.00000000"
        //                 }
        //             },
        //             {
        //                 "OGTT3Y-C6I3P-XRI6HX": {
        //                     "cost": "0.00000",
        //                     "descr": {
        //                         "close": "",
        //                         "leverage": "0:1",
        //                         "order": "sell 0.00000010 XBT/EUR @ limit 5334.60000 with 0:1 leverage",
        //                         "ordertype": "limit",
        //                         "pair": "XBT/EUR",
        //                         "price": "5334.60000",
        //                         "price2": "0.00000",
        //                         "type": "sell"
        //                     },
        //                     "expiretm": "0.000000",
        //                     "fee": "0.00000",
        //                     "limitprice": "5334.60000",
        //                     "misc": "",
        //                     "oflags": "fcib",
        //                     "opentm": "0.000000",
        //                     "price": "5334.60000",
        //                     "refid": "OKIVMP-5GVZN-Z2D2UA",
        //                     "starttm": "0.000000",
        //                     "status": "open",
        //                     "stopprice": "0.000000",
        //                     "userref": 0,
        //                     "vol": "0.00000010",
        //                     "vol_exec": "0.00000000"
        //                 }
        //             },
        //         ],
        //         "openOrders",
        //         { "sequence": 234 }
        //     ]
        //
        // status-change
        //
        //     [
        //         [
        //             { "OGTT3Y-C6I3P-XRI6HX": { "status": "closed" }},
        //             { "OGTT3Y-C6I3P-XRI6HX": { "status": "closed" }},
        //         ],
        //         "openOrders",
        //         { "sequence": 59342 }
        //     ]
        //
        object allOrders = this.safeValue(message, 0, new List<object>() {});
        object allOrdersLength = getArrayLength(allOrders);
        if (isTrue(isGreaterThan(allOrdersLength, 0)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            if (isTrue(isEqual(this.orders, null)))
            {
                this.orders = new ArrayCacheBySymbolById(limit);
            }
            object stored = this.orders;
            object symbols = new Dictionary<string, object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(allOrders)); postFixIncrement(ref i))
            {
                object orders = this.safeValue(allOrders, i, new Dictionary<string, object>() {});
                object ids = new List<object>(((IDictionary<string,object>)orders).Keys);
                for (object j = 0; isLessThan(j, getArrayLength(ids)); postFixIncrement(ref j))
                {
                    object id = getValue(ids, j);
                    object order = getValue(orders, id);
                    object parsed = this.parseWsOrder(order);
                    ((IDictionary<string,object>)parsed)["id"] = id;
                    object symbol = null;
                    object symbolsByOrderId = this.safeValue(this.options, "symbolsByOrderId", new Dictionary<string, object>() {});
                    if (isTrue(!isEqual(getValue(parsed, "symbol"), null)))
                    {
                        symbol = getValue(parsed, "symbol");
                        ((IDictionary<string,object>)symbolsByOrderId)[(string)id] = symbol;
                        ((IDictionary<string,object>)this.options)["symbolsByOrderId"] = symbolsByOrderId;
                    } else
                    {
                        symbol = this.safeString(symbolsByOrderId, id);
                    }
                    object previousOrders = this.safeValue((stored as ArrayCacheBySymbolById).hashmap, symbol);
                    object previousOrder = this.safeValue(previousOrders, id);
                    object newOrder = parsed;
                    if (isTrue(!isEqual(previousOrder, null)))
                    {
                        object newRawOrder = this.extend(getValue(previousOrder, "info"), getValue(newOrder, "info"));
                        newOrder = this.parseWsOrder(newRawOrder);
                        ((IDictionary<string,object>)newOrder)["id"] = id;
                    }
                    object length = getArrayLength(stored);
                    if (isTrue(isTrue(isEqual(length, limit)) && isTrue((isEqual(previousOrder, null)))))
                    {
                        object first = getValue(stored, 0);
                        if (isTrue(inOp(symbolsByOrderId, getValue(first, "id"))))
                        {

                        }
                    }
                    callDynamically(stored, "append", new object[] {newOrder});
                    ((IDictionary<string,object>)symbols)[(string)symbol] = true;
                }
            }
            object name = "openOrders";
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, name});
            object keys = new List<object>(((IDictionary<string,object>)symbols).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
            {
                object messageHash = add(add(name, ":"), getValue(keys, i));
                callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageHash});
            }
        }
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        // createOrder
        //    {
        //        "avg_price": "0.00000",
        //        "cost": "0.00000",
        //        "descr": {
        //            "close": null,
        //            "leverage": null,
        //            "order": "sell 0.01000000 ETH/USDT @ limit 1900.00000",
        //            "ordertype": "limit",
        //            "pair": "ETH/USDT",
        //            "price": "1900.00000",
        //            "price2": "0.00000",
        //            "type": "sell"
        //        },
        //        "expiretm": null,
        //        "fee": "0.00000",
        //        "limitprice": "0.00000",
        //        "misc": '',
        //        "oflags": "fciq",
        //        "opentm": "1667522705.757622",
        //        "refid": null,
        //        "starttm": null,
        //        "status": "open",
        //        "stopprice": "0.00000",
        //        "timeinforce": "GTC",
        //        "userref": 0,
        //        "vol": "0.01000000",
        //        "vol_exec": "0.00000000"
        //    }
        //
        object description = this.safeValue(order, "descr", new Dictionary<string, object>() {});
        object orderDescription = this.safeString(description, "order");
        object side = null;
        object type = null;
        object wsName = null;
        object price = null;
        object amount = null;
        if (isTrue(!isEqual(orderDescription, null)))
        {
            object parts = ((string)orderDescription).Split(new [] {((string)" ")}, StringSplitOptions.None).ToList<object>();
            side = this.safeString(parts, 0);
            amount = this.safeString(parts, 1);
            wsName = this.safeString(parts, 2);
            type = this.safeString(parts, 4);
            price = this.safeString(parts, 5);
        }
        side = this.safeString(description, "type", side);
        type = this.safeString(description, "ordertype", type);
        wsName = this.safeString(description, "pair", wsName);
        market = this.safeValue(getValue(this.options, "marketsByWsName"), wsName, market);
        object symbol = null;
        object timestamp = this.safeTimestamp(order, "opentm");
        amount = this.safeString(order, "vol", amount);
        object filled = this.safeString(order, "vol_exec");
        object fee = null;
        object cost = this.safeString(order, "cost");
        price = this.safeString(description, "price", price);
        if (isTrue(isTrue((isEqual(price, null))) || isTrue((Precise.stringEq(price, "0.0")))))
        {
            price = this.safeString(description, "price2");
        }
        if (isTrue(isTrue((isEqual(price, null))) || isTrue((Precise.stringEq(price, "0.0")))))
        {
            price = this.safeString(order, "price", price);
        }
        object average = this.safeString2(order, "avg_price", "price");
        if (isTrue(!isEqual(market, null)))
        {
            symbol = getValue(market, "symbol");
            if (isTrue(inOp(order, "fee")))
            {
                object flags = getValue(order, "oflags");
                object feeCost = this.safeString(order, "fee");
                fee = new Dictionary<string, object>() {
                    { "cost", feeCost },
                    { "rate", null },
                };
                if (isTrue(isGreaterThanOrEqual(getIndexOf(flags, "fciq"), 0)))
                {
                    ((IDictionary<string,object>)fee)["currency"] = getValue(market, "quote");
                } else if (isTrue(isGreaterThanOrEqual(getIndexOf(flags, "fcib"), 0)))
                {
                    ((IDictionary<string,object>)fee)["currency"] = getValue(market, "base");
                }
            }
        }
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object id = this.safeString(order, "id");
        if (isTrue(isEqual(id, null)))
        {
            object txid = this.safeValue(order, "txid");
            id = this.safeString(txid, 0);
        }
        object clientOrderId = this.safeString(order, "userref");
        object rawTrades = this.safeValue(order, "trades");
        object trades = null;
        if (isTrue(!isEqual(rawTrades, null)))
        {
            trades = this.parseTrades(rawTrades, market, null, null, new Dictionary<string, object>() {
                { "order", id },
            });
        }
        object stopPrice = this.safeNumber(order, "stopprice");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "info", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "status", status },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "cost", cost },
            { "amount", amount },
            { "filled", filled },
            { "average", average },
            { "remaining", null },
            { "fee", fee },
            { "trades", trades },
        });
    }

    public async virtual Task<object> watchMultiHelper(object unifiedName, object channelName, object symbols = null, object subscriptionArgs = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        // symbols are required
        symbols = this.marketSymbols(symbols, null, false, true, false);
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            ((IList<object>)messageHashes).Add(this.getMessageHash(unifiedName, null, this.symbol(getValue(symbols, i))));
        }
        // for WS subscriptions, we can't use .marketIds (symbols), instead a custom is field needed
        object markets = this.marketsForSymbols(symbols);
        object wsMarketIds = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object wsMarketId = this.safeString(getValue(getValue(markets, i), "info"), "wsname");
            ((IList<object>)wsMarketIds).Add(wsMarketId);
        }
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "reqid", this.requestId() },
            { "pair", wsMarketIds },
            { "subscription", new Dictionary<string, object>() {
                { "name", channelName },
            } },
        };
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "public");
        return await this.watchMultiple(url, messageHashes, this.deepExtend(request, parameters), messageHashes, subscriptionArgs);
    }

    public virtual object getMessageHash(object unifiedElementName, object subChannelName = null, object symbol = null)
    {
        // unifiedElementName can be : orderbook, trade, ticker, bidask ...
        // subChannelName only applies to channel that needs specific variation (i.e. depth_50, depth_100..) to be selected
        object withSymbol = !isEqual(symbol, null);
        object messageHash = unifiedElementName;
        if (!isTrue(withSymbol))
        {
            messageHash = add(messageHash, "s");
        } else
        {
            messageHash = add(messageHash, add("@", symbol));
        }
        if (isTrue(!isEqual(subChannelName, null)))
        {
            messageHash = add(messageHash, add("#", subChannelName));
        }
        return messageHash;
    }

    public virtual void handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        // public
        //
        //     {
        //         "channelID": 210,
        //         "channelName": "book-10",
        //         "event": "subscriptionStatus",
        //         "reqid": 1574146735269,
        //         "pair": "ETH/XBT",
        //         "status": "subscribed",
        //         "subscription": { depth: 10, name: "book" }
        //     }
        //
        // private
        //
        //     {
        //         "channelName": "openOrders",
        //         "event": "subscriptionStatus",
        //         "reqid": 1,
        //         "status": "subscribed",
        //         "subscription": { maxratecount: 125, name: "openOrders" }
        //     }
        //
        object channelId = this.safeString(message, "channelID");
        if (isTrue(!isEqual(channelId, null)))
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)channelId] = message;
        }
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //     {
        //         "errorMessage": "Currency pair not in ISO 4217-A3 format foobar",
        //         "event": "subscriptionStatus",
        //         "pair": "foobar",
        //         "reqid": 1574146735269,
        //         "status": "error",
        //         "subscription": { name: "ticker" }
        //     }
        //
        object errorMessage = this.safeString(message, "errorMessage");
        if (isTrue(!isEqual(errorMessage, null)))
        {
            object requestId = this.safeValue(message, "reqid");
            if (isTrue(!isEqual(requestId, null)))
            {
                object broad = getValue(getValue(this.exceptions, "ws"), "broad");
                object broadKey = this.findBroadlyMatchedKey(broad, errorMessage);
                object exception = null;
                if (isTrue(isEqual(broadKey, null)))
                {
                    exception = new ExchangeError(                    ((string)errorMessage)); // c# requirement to convert the errorMessage to string
                } else
                {
                    exception = this.newException(getValue(broad, broadKey), errorMessage);
                }
                ((WebSocketClient)client).reject(exception, requestId);
                return false;
            }
        }
        return true;
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (isTrue(((message is IList<object>) || (message.GetType().IsGenericType && message.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            object channelId = this.safeString(message, 0);
            object subscription = this.safeValue(((WebSocketClient)client).subscriptions, channelId, new Dictionary<string, object>() {});
            object info = this.safeValue(subscription, "subscription", new Dictionary<string, object>() {});
            object messageLength = getArrayLength(message);
            object channelName = this.safeString(message, subtract(messageLength, 2));
            object name = this.safeString(info, "name");
            object methods = new Dictionary<string, object>() {
                { "book", this.handleOrderBook },
                { "ohlc", this.handleOHLCV },
                { "ticker", this.handleTicker },
                { "trade", this.handleTrades },
                { "openOrders", this.handleOrders },
                { "ownTrades", this.handleMyTrades },
            };
            object method = this.safeValue2(methods, name, channelName);
            if (isTrue(!isEqual(method, null)))
            {
                DynamicInvoker.InvokeMethod(method, new object[] { client, message, subscription});
            }
        } else
        {
            if (isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
            {
                object eventVar = this.safeString(message, "event");
                object methods = new Dictionary<string, object>() {
                    { "heartbeat", this.handleHeartbeat },
                    { "systemStatus", this.handleSystemStatus },
                    { "subscriptionStatus", this.handleSubscriptionStatus },
                    { "addOrderStatus", this.handleCreateEditOrder },
                    { "editOrderStatus", this.handleCreateEditOrder },
                    { "cancelOrderStatus", this.handleCancelOrder },
                    { "cancelAllStatus", this.handleCancelAllOrders },
                };
                object method = this.safeValue(methods, eventVar);
                if (isTrue(!isEqual(method, null)))
                {
                    DynamicInvoker.InvokeMethod(method, new object[] { client, message});
                }
            }
        }
    }
}
