namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class kraken { public kraken(object args = null) : base(args) { } }
public partial class kraken : ccxt.kraken
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchBalance", true },
                { "watchMyTrades", true },
                { "watchOHLCV", true },
                { "watchOrderBook", true },
                { "watchOrderBookForSymbols", true },
                { "watchOrders", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchBidsAsks", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
                { "createOrderWs", true },
                { "editOrderWs", true },
                { "cancelOrderWs", true },
                { "cancelOrdersWs", true },
                { "cancelAllOrdersWs", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://ws.kraken.com" },
                        { "private", "wss://ws-auth.kraken.com" },
                        { "privateV2", "wss://ws-auth.kraken.com/v2" },
                        { "publicV2", "wss://ws.kraken.com/v2" },
                        { "beta", "wss://beta-ws.kraken.com" },
                        { "beta-private", "wss://beta-ws-auth.kraken.com" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "tradesLimit", 1000 },
                { "OHLCVLimit", 1000 },
                { "ordersLimit", 1000 },
                { "symbolsByOrderId", new Dictionary<string, object>() {} },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "checksum", false },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "ping", this.ping },
                { "keepAlive", 6000 },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "ws", new Dictionary<string, object>() {
                    { "exact", new Dictionary<string, object>() {
                        { "Event(s) not found", typeof(BadRequest) },
                    } },
                    { "broad", new Dictionary<string, object>() {
                        { "Already subscribed", typeof(BadRequest) },
                        { "Currency pair not in ISO 4217-A3 format", typeof(BadSymbol) },
                        { "Currency pair not supported", typeof(BadSymbol) },
                        { "Malformed request", typeof(BadRequest) },
                        { "Pair field must be an array", typeof(BadRequest) },
                        { "Pair field unsupported for this subscription type", typeof(BadRequest) },
                        { "Pair(s) not found", typeof(BadSymbol) },
                        { "Subscription book depth must be an integer", typeof(BadRequest) },
                        { "Subscription depth not supported", typeof(BadRequest) },
                        { "Subscription field must be an object", typeof(BadRequest) },
                        { "Subscription name invalid", typeof(BadRequest) },
                        { "Subscription object unsupported field", typeof(BadRequest) },
                        { "Subscription ohlc interval must be an integer", typeof(BadRequest) },
                        { "Subscription ohlc interval not supported", typeof(BadRequest) },
                        { "Subscription ohlc requires interval", typeof(BadRequest) },
                        { "EAccount:Invalid permissions", typeof(PermissionDenied) },
                        { "EAuth:Account temporary disabled", typeof(AccountSuspended) },
                        { "EAuth:Account unconfirmed", typeof(AuthenticationError) },
                        { "EAuth:Rate limit exceeded", typeof(RateLimitExceeded) },
                        { "EAuth:Too many requests", typeof(RateLimitExceeded) },
                        { "EDatabase: Internal error (to be deprecated)", typeof(ExchangeError) },
                        { "EGeneral:Internal error[:<code>]", typeof(ExchangeError) },
                        { "EGeneral:Invalid arguments", typeof(BadRequest) },
                        { "EOrder:Cannot open opposing position", typeof(InvalidOrder) },
                        { "EOrder:Cannot open position", typeof(InvalidOrder) },
                        { "EOrder:Insufficient funds (insufficient user funds)", typeof(InsufficientFunds) },
                        { "EOrder:Insufficient margin (exchange does not have sufficient funds to allow margin trading)", typeof(InsufficientFunds) },
                        { "EOrder:Invalid price", typeof(InvalidOrder) },
                        { "EOrder:Margin allowance exceeded", typeof(InvalidOrder) },
                        { "EOrder:Margin level too low", typeof(InvalidOrder) },
                        { "EOrder:Margin position size exceeded (client would exceed the maximum position size for this pair)", typeof(InvalidOrder) },
                        { "EOrder:Order minimum not met (volume too low)", typeof(InvalidOrder) },
                        { "EOrder:Orders limit exceeded", typeof(InvalidOrder) },
                        { "EOrder:Positions limit exceeded", typeof(InvalidOrder) },
                        { "EOrder:Rate limit exceeded", typeof(RateLimitExceeded) },
                        { "EOrder:Scheduled orders limit exceeded", typeof(InvalidOrder) },
                        { "EOrder:Unknown position", typeof(OrderNotFound) },
                        { "EOrder:Unknown order", typeof(OrderNotFound) },
                        { "EOrder:Invalid order", typeof(InvalidOrder) },
                        { "EService:Deadline elapsed", typeof(ExchangeNotAvailable) },
                        { "EService:Market in cancel_only mode", typeof(NotSupported) },
                        { "EService:Market in limit_only mode", typeof(NotSupported) },
                        { "EService:Market in post_only mode", typeof(NotSupported) },
                        { "EService:Unavailable", typeof(ExchangeNotAvailable) },
                        { "ETrade:Invalid request", typeof(BadRequest) },
                        { "ESession:Invalid session", typeof(AuthenticationError) },
                    } },
                } },
            } },
        });
    }

    public virtual object orderRequestWs(object method, object symbol, object type, object request, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object isLimitOrder = ((string)type).EndsWith(((string)"limit")); // supporting limit, stop-loss-limit, take-profit-limit, etc
        if (isTrue(isLimitOrder))
        {
            if (isTrue(isEqual(price, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " limit orders require a price argument")) ;
            }
            ((IDictionary<string,object>)getValue(request, "params"))["limit_price"] = this.parseToNumeric(this.priceToPrecision(symbol, price));
        }
        object isMarket = (isEqual(type, "market"));
        object postOnly = null;
        var postOnlyparametersVariable = this.handlePostOnly(isMarket, false, parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)getValue(request, "params"))["post_only"] = true;
        }
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)getValue(request, "params"))["cl_ord_id"] = clientOrderId;
        }
        object cost = this.safeString(parameters, "cost");
        if (isTrue(!isEqual(cost, null)))
        {
            ((IDictionary<string,object>)getValue(request, "params"))["order_qty"] = this.parseToNumeric(this.costToPrecision(symbol, cost));
        }
        object stopLoss = this.safeDict(parameters, "stopLoss", new Dictionary<string, object>() {});
        object takeProfit = this.safeDict(parameters, "takeProfit", new Dictionary<string, object>() {});
        object presetStopLoss = this.safeString(stopLoss, "triggerPrice");
        object presetTakeProfit = this.safeString(takeProfit, "triggerPrice");
        object presetStopLossLimit = this.safeString(stopLoss, "price");
        object presetTakeProfitLimit = this.safeString(takeProfit, "price");
        object isPresetStopLoss = !isEqual(presetStopLoss, null);
        object isPresetTakeProfit = !isEqual(presetTakeProfit, null);
        object stopLossPrice = this.safeString(parameters, "stopLossPrice");
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        object isStopLossPriceOrder = !isEqual(stopLossPrice, null);
        object isTakeProfitPriceOrder = !isEqual(takeProfitPrice, null);
        object trailingAmount = this.safeString(parameters, "trailingAmount");
        object trailingPercent = this.safeString(parameters, "trailingPercent");
        object trailingLimitAmount = this.safeString(parameters, "trailingLimitAmount");
        object trailingLimitPercent = this.safeString(parameters, "trailingLimitPercent");
        object isTrailingAmountOrder = !isEqual(trailingAmount, null);
        object isTrailingPercentOrder = !isEqual(trailingPercent, null);
        object isTrailingLimitAmountOrder = !isEqual(trailingLimitAmount, null);
        object isTrailingLimitPercentOrder = !isEqual(trailingLimitPercent, null);
        object offset = this.safeString(parameters, "offset", ""); // can set this to - for minus
        object trailingAmountString = ((bool) isTrue((!isEqual(trailingAmount, null)))) ? add(offset, this.numberToString(trailingAmount)) : null;
        object trailingPercentString = ((bool) isTrue((!isEqual(trailingPercent, null)))) ? add(offset, this.numberToString(trailingPercent)) : null;
        object trailingLimitAmountString = ((bool) isTrue((!isEqual(trailingLimitAmount, null)))) ? add(offset, this.numberToString(trailingLimitAmount)) : null;
        object trailingLimitPercentString = ((bool) isTrue((!isEqual(trailingLimitPercent, null)))) ? add(offset, this.numberToString(trailingLimitPercent)) : null;
        object priceType = ((bool) isTrue((isTrue(isTrailingPercentOrder) || isTrue(isTrailingLimitPercentOrder)))) ? "pct" : "quote";
        if (isTrue(isEqual(method, "createOrderWs")))
        {
            object reduceOnly = this.safeBool(parameters, "reduceOnly");
            if (isTrue(reduceOnly))
            {
                ((IDictionary<string,object>)getValue(request, "params"))["reduce_only"] = true;
            }
            object timeInForce = this.safeStringLower(parameters, "timeInForce");
            if (isTrue(!isEqual(timeInForce, null)))
            {
                ((IDictionary<string,object>)getValue(request, "params"))["time_in_force"] = timeInForce;
            }
            parameters = this.omit(parameters, new List<object>() {"reduceOnly", "timeInForce"});
            if (isTrue(isTrue(isTrue(isTrue(isTrue(isTrue(isStopLossPriceOrder) || isTrue(isTakeProfitPriceOrder)) || isTrue(isTrailingAmountOrder)) || isTrue(isTrailingPercentOrder)) || isTrue(isTrailingLimitAmountOrder)) || isTrue(isTrailingLimitPercentOrder)))
            {
                ((IDictionary<string,object>)getValue(request, "params"))["triggers"] = new Dictionary<string, object>() {};
            }
            if (isTrue(isTrue(isPresetStopLoss) || isTrue(isPresetTakeProfit)))
            {
                ((IDictionary<string,object>)getValue(request, "params"))["conditional"] = new Dictionary<string, object>() {};
                if (isTrue(isPresetStopLoss))
                {
                    ((IDictionary<string,object>)getValue(getValue(request, "params"), "conditional"))["order_type"] = "stop-loss";
                    ((IDictionary<string,object>)getValue(getValue(request, "params"), "conditional"))["trigger_price"] = this.parseToNumeric(this.priceToPrecision(symbol, presetStopLoss));
                } else if (isTrue(isPresetTakeProfit))
                {
                    ((IDictionary<string,object>)getValue(getValue(request, "params"), "conditional"))["order_type"] = "take-profit";
                    ((IDictionary<string,object>)getValue(getValue(request, "params"), "conditional"))["trigger_price"] = this.parseToNumeric(this.priceToPrecision(symbol, presetTakeProfit));
                }
                if (isTrue(!isEqual(presetStopLossLimit, null)))
                {
                    ((IDictionary<string,object>)getValue(getValue(request, "params"), "conditional"))["order_type"] = "stop-loss-limit";
                    ((IDictionary<string,object>)getValue(getValue(request, "params"), "conditional"))["limit_price"] = this.parseToNumeric(this.priceToPrecision(symbol, presetStopLossLimit));
                } else if (isTrue(!isEqual(presetTakeProfitLimit, null)))
                {
                    ((IDictionary<string,object>)getValue(getValue(request, "params"), "conditional"))["order_type"] = "take-profit-limit";
                    ((IDictionary<string,object>)getValue(getValue(request, "params"), "conditional"))["limit_price"] = this.parseToNumeric(this.priceToPrecision(symbol, presetTakeProfitLimit));
                }
                parameters = this.omit(parameters, new List<object>() {"stopLoss", "takeProfit"});
            } else if (isTrue(isTrue(isStopLossPriceOrder) || isTrue(isTakeProfitPriceOrder)))
            {
                if (isTrue(isStopLossPriceOrder))
                {
                    ((IDictionary<string,object>)getValue(getValue(request, "params"), "triggers"))["price"] = this.parseToNumeric(this.priceToPrecision(symbol, stopLossPrice));
                    if (isTrue(isLimitOrder))
                    {
                        ((IDictionary<string,object>)getValue(request, "params"))["order_type"] = "stop-loss-limit";
                    } else
                    {
                        ((IDictionary<string,object>)getValue(request, "params"))["order_type"] = "stop-loss";
                    }
                } else
                {
                    ((IDictionary<string,object>)getValue(getValue(request, "params"), "triggers"))["price"] = this.parseToNumeric(this.priceToPrecision(symbol, takeProfitPrice));
                    if (isTrue(isLimitOrder))
                    {
                        ((IDictionary<string,object>)getValue(request, "params"))["order_type"] = "take-profit-limit";
                    } else
                    {
                        ((IDictionary<string,object>)getValue(request, "params"))["order_type"] = "take-profit";
                    }
                }
            } else if (isTrue(isTrue(isTrue(isTrue(isTrailingAmountOrder) || isTrue(isTrailingPercentOrder)) || isTrue(isTrailingLimitAmountOrder)) || isTrue(isTrailingLimitPercentOrder)))
            {
                ((IDictionary<string,object>)getValue(getValue(request, "params"), "triggers"))["price_type"] = priceType;
                if (isTrue(!isTrue(isLimitOrder) && isTrue((isTrue(isTrailingAmountOrder) || isTrue(isTrailingPercentOrder)))))
                {
                    ((IDictionary<string,object>)getValue(request, "params"))["order_type"] = "trailing-stop";
                    if (isTrue(isTrailingAmountOrder))
                    {
                        ((IDictionary<string,object>)getValue(getValue(request, "params"), "triggers"))["price"] = this.parseToNumeric(trailingAmountString);
                    } else
                    {
                        ((IDictionary<string,object>)getValue(getValue(request, "params"), "triggers"))["price"] = this.parseToNumeric(trailingPercentString);
                    }
                } else
                {
                    // trailing limit orders are not conventionally supported because the static limit_price_type param is not available for trailing-stop-limit orders
                    ((IDictionary<string,object>)getValue(request, "params"))["limit_price_type"] = priceType;
                    ((IDictionary<string,object>)getValue(request, "params"))["order_type"] = "trailing-stop-limit";
                    if (isTrue(isTrailingLimitAmountOrder))
                    {
                        ((IDictionary<string,object>)getValue(getValue(request, "params"), "triggers"))["price"] = this.parseToNumeric(trailingLimitAmountString);
                    } else
                    {
                        ((IDictionary<string,object>)getValue(getValue(request, "params"), "triggers"))["price"] = this.parseToNumeric(trailingLimitPercentString);
                    }
                }
            }
        } else if (isTrue(isEqual(method, "editOrderWs")))
        {
            if (isTrue(isTrue(isPresetStopLoss) || isTrue(isPresetTakeProfit)))
            {
                throw new NotSupported ((string)add(this.id, " editing the stopLoss and takeProfit on existing orders is currently not supported")) ;
            }
            if (isTrue(isTrue(isStopLossPriceOrder) || isTrue(isTakeProfitPriceOrder)))
            {
                if (isTrue(isStopLossPriceOrder))
                {
                    ((IDictionary<string,object>)getValue(request, "params"))["trigger_price"] = this.parseToNumeric(this.priceToPrecision(symbol, stopLossPrice));
                } else
                {
                    ((IDictionary<string,object>)getValue(request, "params"))["trigger_price"] = this.parseToNumeric(this.priceToPrecision(symbol, takeProfitPrice));
                }
            } else if (isTrue(isTrue(isTrue(isTrue(isTrailingAmountOrder) || isTrue(isTrailingPercentOrder)) || isTrue(isTrailingLimitAmountOrder)) || isTrue(isTrailingLimitPercentOrder)))
            {
                ((IDictionary<string,object>)getValue(request, "params"))["trigger_price_type"] = priceType;
                if (isTrue(!isTrue(isLimitOrder) && isTrue((isTrue(isTrailingAmountOrder) || isTrue(isTrailingPercentOrder)))))
                {
                    if (isTrue(isTrailingAmountOrder))
                    {
                        ((IDictionary<string,object>)getValue(request, "params"))["trigger_price"] = this.parseToNumeric(trailingAmountString);
                    } else
                    {
                        ((IDictionary<string,object>)getValue(request, "params"))["trigger_price"] = this.parseToNumeric(trailingPercentString);
                    }
                } else
                {
                    ((IDictionary<string,object>)getValue(request, "params"))["limit_price_type"] = priceType;
                    if (isTrue(isTrailingLimitAmountOrder))
                    {
                        ((IDictionary<string,object>)getValue(request, "params"))["trigger_price"] = this.parseToNumeric(trailingLimitAmountString);
                    } else
                    {
                        ((IDictionary<string,object>)getValue(request, "params"))["trigger_price"] = this.parseToNumeric(trailingLimitPercentString);
                    }
                }
            }
        }
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "cost", "offset", "stopLossPrice", "takeProfitPrice", "trailingAmount", "trailingPercent", "trailingLimitAmount", "trailingLimitPercent"});
        return new List<object>() {request, parameters};
    }

    /**
     * @method
     * @name kraken#createOrderWs
     * @description create a trade order
     * @see https://docs.kraken.com/api/docs/websocket-v2/add_order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createOrderWs(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object token = await this.authenticate();
        object market = this.market(symbol);
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "privateV2");
        object requestId = this.requestId();
        object messageHash = this.numberToString(requestId);
        object request = new Dictionary<string, object>() {
            { "method", "add_order" },
            { "params", new Dictionary<string, object>() {
                { "order_type", type },
                { "side", side },
                { "order_qty", this.parseToNumeric(this.amountToPrecision(symbol, amount)) },
                { "symbol", getValue(market, "symbol") },
                { "token", token },
            } },
            { "req_id", requestId },
        };
        var requestparametersVariable = this.orderRequestWs("createOrderWs", symbol, type, request, amount, price, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        return await this.watch(url, messageHash, this.extend(request, parameters), messageHash);
    }

    public virtual void handleCreateEditOrder(WebSocketClient client, object message)
    {
        //
        //  createOrder
        //     {
        //         "method": "add_order",
        //         "req_id": 1,
        //         "result": {
        //             "order_id": "OXM2QD-EALR2-YBAVEU"
        //         },
        //         "success": true,
        //         "time_in": "2025-05-13T10:12:13.876173Z",
        //         "time_out": "2025-05-13T10:12:13.890137Z"
        //     }
        //
        //  editOrder
        //     {
        //         "method": "amend_order",
        //         "req_id": 1,
        //         "result": {
        //             "amend_id": "TYDLSQ-OYNYU-3MNRER",
        //             "order_id": "OGL7HR-SWFO4-NRQTHO"
        //         },
        //         "success": true,
        //         "time_in": "2025-05-14T13:54:10.840342Z",
        //         "time_out": "2025-05-14T13:54:10.855046Z"
        //     }
        //
        object result = this.safeDict(message, "result", new Dictionary<string, object>() {});
        object order = this.parseOrder(result);
        object messageHash = this.safeString2(message, "reqid", "req_id");
        callDynamically(client as WebSocketClient, "resolve", new object[] {order, messageHash});
    }

    /**
     * @method
     * @name kraken#editOrderWs
     * @description edit a trade order
     * @see https://docs.kraken.com/api/docs/websocket-v2/amend_order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of the currency you want to trade in units of the base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> editOrderWs(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object token = await this.authenticate();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "privateV2");
        object requestId = this.requestId();
        object messageHash = this.numberToString(requestId);
        object request = new Dictionary<string, object>() {
            { "method", "amend_order" },
            { "params", new Dictionary<string, object>() {
                { "order_id", id },
                { "order_qty", this.parseToNumeric(this.amountToPrecision(symbol, amount)) },
                { "token", token },
            } },
            { "req_id", requestId },
        };
        var requestparametersVariable = this.orderRequestWs("editOrderWs", symbol, type, request, amount, price, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        return await this.watch(url, messageHash, this.extend(request, parameters), messageHash);
    }

    /**
     * @method
     * @name kraken#cancelOrdersWs
     * @description cancel multiple orders
     * @see https://docs.kraken.com/api/docs/websocket-v2/cancel_order
     * @param {string[]} ids order ids
     * @param {string} [symbol] unified market symbol, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelOrdersWs(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(!isEqual(symbol, null)))
        {
            throw new NotSupported ((string)add(this.id, " cancelOrdersWs () does not support cancelling orders for a specific symbol.")) ;
        }
        await this.loadMarkets();
        object token = await this.authenticate();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "privateV2");
        object requestId = this.requestId();
        object messageHash = this.numberToString(requestId);
        object request = new Dictionary<string, object>() {
            { "method", "cancel_order" },
            { "params", new Dictionary<string, object>() {
                { "order_id", ids },
                { "token", token },
            } },
            { "req_id", requestId },
        };
        return await this.watch(url, messageHash, this.extend(request, parameters), messageHash);
    }

    /**
     * @method
     * @name kraken#cancelOrderWs
     * @description cancels an open order
     * @see https://docs.kraken.com/api/docs/websocket-v2/cancel_order
     * @param {string} id order id
     * @param {string} [symbol] unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelOrderWs(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(!isEqual(symbol, null)))
        {
            throw new NotSupported ((string)add(this.id, " cancelOrderWs () does not support cancelling orders for a specific symbol.")) ;
        }
        await this.loadMarkets();
        object token = await this.authenticate();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "privateV2");
        object requestId = this.requestId();
        object messageHash = this.numberToString(requestId);
        object request = new Dictionary<string, object>() {
            { "method", "cancel_order" },
            { "params", new Dictionary<string, object>() {
                { "order_id", new List<object>() {id} },
                { "token", token },
            } },
            { "req_id", requestId },
        };
        return await this.watch(url, messageHash, this.extend(request, parameters), messageHash);
    }

    public virtual void handleCancelOrder(WebSocketClient client, object message)
    {
        //
        //     {
        //         "method": "cancel_order",
        //         "req_id": 123456789,
        //         "result": {
        //             "order_id": "OKAGJC-YHIWK-WIOZWG"
        //         },
        //         "success": true,
        //         "time_in": "2023-09-21T14:36:57.428972Z",
        //         "time_out": "2023-09-21T14:36:57.437952Z"
        //     }
        //
        object reqId = this.safeString(message, "req_id");
        callDynamically(client as WebSocketClient, "resolve", new object[] {message, reqId});
    }

    /**
     * @method
     * @name kraken#cancelAllOrdersWs
     * @description cancel all open orders
     * @see https://docs.kraken.com/api/docs/websocket-v2/cancel_all
     * @param {string} [symbol] unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelAllOrdersWs(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(!isEqual(symbol, null)))
        {
            throw new NotSupported ((string)add(this.id, " cancelAllOrdersWs () does not support cancelling orders in a specific market.")) ;
        }
        await this.loadMarkets();
        object token = await this.authenticate();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "privateV2");
        object requestId = this.requestId();
        object messageHash = this.numberToString(requestId);
        object request = new Dictionary<string, object>() {
            { "method", "cancel_all" },
            { "params", new Dictionary<string, object>() {
                { "token", token },
            } },
            { "req_id", requestId },
        };
        return await this.watch(url, messageHash, this.extend(request, parameters), messageHash);
    }

    public virtual void handleCancelAllOrders(WebSocketClient client, object message)
    {
        //
        //     {
        //         "method": "cancel_all",
        //         "req_id": 123456789,
        //         "result": {
        //             "count": 1
        //         },
        //         "success": true,
        //         "time_in": "2023-09-21T14:36:57.428972Z",
        //         "time_out": "2023-09-21T14:36:57.437952Z"
        //     }
        //
        object reqId = this.safeString(message, "req_id");
        callDynamically(client as WebSocketClient, "resolve", new object[] {message, reqId});
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        //     {
        //         "channel": "ticker",
        //         "type": "snapshot",
        //         "data": [
        //             {
        //                 "symbol": "BTC/USD",
        //                 "bid": 108359.8,
        //                 "bid_qty": 0.01362603,
        //                 "ask": 108359.9,
        //                 "ask_qty": 17.17988863,
        //                 "last": 108359.8,
        //                 "volume": 2158.32346723,
        //                 "vwap": 108894.5,
        //                 "low": 106824,
        //                 "high": 111300,
        //                 "change": -2679.9,
        //                 "change_pct": -2.41
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(message, "data", new List<object>() {});
        object ticker = getValue(data, 0);
        object symbol = this.safeString(ticker, "symbol");
        object messageHash = this.getMessageHash("ticker", null, symbol);
        object vwap = this.safeString(ticker, "vwap");
        object quoteVolume = null;
        object baseVolume = this.safeString(ticker, "volume");
        if (isTrue(isTrue(!isEqual(baseVolume, null)) && isTrue(!isEqual(vwap, null))))
        {
            quoteVolume = Precise.stringMul(baseVolume, vwap);
        }
        object last = this.safeString(ticker, "last");
        object result = this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(ticker, "bid") },
            { "bidVolume", this.safeString(ticker, "bid_qty") },
            { "ask", this.safeString(ticker, "ask") },
            { "askVolume", this.safeString(ticker, "ask_qty") },
            { "vwap", vwap },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", this.safeString(ticker, "change") },
            { "percentage", this.safeString(ticker, "change_pct") },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        });
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = result;
        callDynamically(client as WebSocketClient, "resolve", new object[] {result, messageHash});
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //         "channel": "trade",
        //         "type": "update",
        //         "data": [
        //             {
        //                 "symbol": "MATIC/USD",
        //                 "side": "sell",
        //                 "price": 0.5117,
        //                 "qty": 40.0,
        //                 "ord_type": "market",
        //                 "trade_id": 4665906,
        //                 "timestamp": "2023-09-25T07:49:37.708706Z"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(message, "data", new List<object>() {});
        object trade = getValue(data, 0);
        object symbol = this.safeString(trade, "symbol");
        object messageHash = this.getMessageHash("trade", null, symbol);
        object stored = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        object market = this.market(symbol);
        object parsed = this.parseTrades(data, market);
        for (object i = 0; isLessThan(i, getArrayLength(parsed)); postFixIncrement(ref i))
        {
            callDynamically(stored, "append", new object[] {getValue(parsed, i)});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "channel": "ohlc",
        //         "type": "update",
        //         "timestamp": "2023-10-04T16:26:30.524394914Z",
        //         "data": [
        //             {
        //                 "symbol": "MATIC/USD",
        //                 "open": 0.5624,
        //                 "high": 0.5628,
        //                 "low": 0.5622,
        //                 "close": 0.5627,
        //                 "trades": 12,
        //                 "volume": 30927.68066226,
        //                 "vwap": 0.5626,
        //                 "interval_begin": "2023-10-04T16:25:00.000000000Z",
        //                 "interval": 5,
        //                 "timestamp": "2023-10-04T16:30:00.000000Z"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(message, "data", new List<object>() {});
        object first = getValue(data, 0);
        object marketId = this.safeString(first, "symbol");
        object symbol = this.safeSymbol(marketId);
        if (!isTrue((inOp(this.ohlcvs, symbol))))
        {
            ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = new Dictionary<string, object>() {};
        }
        object interval = this.safeInteger(first, "interval");
        object timeframe = this.findTimeframe(interval);
        object messageHash = this.getMessageHash("ohlcv", null, symbol);
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
        }
        object ohlcvsLength = getArrayLength(data);
        for (object i = 0; isLessThan(i, ohlcvsLength); postFixIncrement(ref i))
        {
            object candle = getValue(data, subtract(subtract(ohlcvsLength, i), 1));
            object datetime = this.safeString(candle, "timestamp");
            object timestamp = this.parse8601(datetime);
            object parsed = new List<object>() {timestamp, this.safeString(candle, "open"), this.safeString(candle, "high"), this.safeString(candle, "low"), this.safeString(candle, "close"), this.safeString(candle, "volume")};
            callDynamically(stored, "append", new object[] {parsed});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public virtual object requestId()
    {
        // their support said that reqid must be an int32, not documented
        this.lockId();
        object reqid = this.sum(this.safeInteger(this.options, "reqid", 0), 1);
        ((IDictionary<string,object>)this.options)["reqid"] = reqid;
        this.unlockId();
        return reqid;
    }

    /**
     * @method
     * @name kraken#watchTicker
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://docs.kraken.com/api/docs/websocket-v2/ticker
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbol = this.symbol(symbol);
        object tickers = await this.watchTickers(new List<object>() {symbol}, parameters);
        return getValue(tickers, symbol);
    }

    /**
     * @method
     * @name kraken#watchTickers
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://docs.kraken.com/api/docs/websocket-v2/ticker
     * @param {string[]} symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
     */
    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        object ticker = await this.watchMultiHelper("ticker", "ticker", symbols, null, parameters);
        if (isTrue(this.newUpdates))
        {
            object result = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)result)[(string)getValue(ticker, "symbol")] = ticker;
            return result;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    /**
     * @method
     * @name kraken#watchBidsAsks
     * @description watches best bid & ask for symbols
     * @see https://docs.kraken.com/api/docs/websocket-v2/ticker
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
     */
    public async override Task<object> watchBidsAsks(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false);
        ((IDictionary<string,object>)parameters)["event_trigger"] = "bbo";
        object ticker = await this.watchMultiHelper("bidask", "ticker", symbols, null, parameters);
        if (isTrue(this.newUpdates))
        {
            object result = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)result)[(string)getValue(ticker, "symbol")] = ticker;
            return result;
        }
        return this.filterByArray(this.bidsasks, "symbol", symbols);
    }

    /**
     * @method
     * @name kraken#watchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://docs.kraken.com/api/docs/websocket-v2/trade
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    /**
     * @method
     * @name kraken#watchTradesForSymbols
     * @description get the list of most recent trades for a list of symbols
     * @see https://docs.kraken.com/api/docs/websocket-v2/trade
     * @param {string[]} symbols unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
     */
    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object trades = await this.watchMultiHelper("trade", "trade", symbols, null, parameters);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeList(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    /**
     * @method
     * @name kraken#watchOrderBook
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://docs.kraken.com/api/docs/websocket-v2/book
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.watchOrderBookForSymbols(new List<object>() {symbol}, limit, parameters);
    }

    /**
     * @method
     * @name kraken#watchOrderBookForSymbols
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://docs.kraken.com/api/docs/websocket-v2/book
     * @param {string[]} symbols unified array of symbols
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object requiredParams = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(this.inArray(limit, new List<object>() {10, 25, 100, 500, 1000})))
            {
                ((IDictionary<string,object>)requiredParams)["depth"] = limit; // default 10, valid options 10, 25, 100, 500, 1000
            } else
            {
                throw new NotSupported ((string)add(this.id, " watchOrderBook accepts limit values of 10, 25, 100, 500 and 1000 only")) ;
            }
        }
        object orderbook = await this.watchMultiHelper("orderbook", "book", symbols, new Dictionary<string, object>() {
            { "limit", limit },
        }, this.extend(requiredParams, parameters));
        return (orderbook as IOrderBook).limit();
    }

    /**
     * @method
     * @name kraken#watchOHLCV
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://docs.kraken.com/api/docs/websocket-v2/ohlc
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "ohlc";
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "publicV2");
        object requestId = this.requestId();
        object messageHash = this.getMessageHash("ohlcv", null, symbol);
        object subscribe = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "params", new Dictionary<string, object>() {
                { "channel", name },
                { "symbol", new List<object>() {symbol} },
                { "interval", this.safeValue(this.timeframes, timeframe, timeframe) },
            } },
            { "req_id", requestId },
        };
        object request = this.deepExtend(subscribe, parameters);
        object ohlcv = await this.watch(url, messageHash, request, messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, "timestamp", true);
    }

    public async override Task<object> loadMarkets(object reload = null, object parameters = null)
    {
        reload ??= false;
        parameters ??= new Dictionary<string, object>();
        object markets = await base.loadMarkets(reload, parameters);
        object marketsByWsName = this.safeValue(this.options, "marketsByWsName");
        if (isTrue(isTrue((isEqual(marketsByWsName, null))) || isTrue(reload)))
        {
            marketsByWsName = new Dictionary<string, object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(this.symbols, i);
                object market = getValue(this.markets, symbol);
                object info = this.safeValue(market, "info", new Dictionary<string, object>() {});
                object wsName = this.safeString(info, "wsname");
                ((IDictionary<string,object>)marketsByWsName)[(string)wsName] = market;
            }
            ((IDictionary<string,object>)this.options)["marketsByWsName"] = marketsByWsName;
        }
        return markets;
    }

    public override object ping(WebSocketClient client)
    {
        object url = client.url;
        object request = new Dictionary<string, object>() {};
        if (isTrue(isGreaterThanOrEqual(getIndexOf(url, "v2"), 0)))
        {
            ((IDictionary<string,object>)request)["method"] = "ping";
        } else
        {
            ((IDictionary<string,object>)request)["event"] = "ping";
        }
        return request;
    }

    public virtual object handlePong(WebSocketClient client, object message)
    {
        client.lastPong = this.milliseconds();
        return message;
    }

    public async virtual Task<object> watchHeartbeat(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object eventVar = "heartbeat";
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "publicV2");
        return await this.watch(url, eventVar);
    }

    public virtual void handleHeartbeat(WebSocketClient client, object message)
    {
        //
        // every second (approx) if no other updates are sent
        //
        //     { "channel": "heartbeat" }
        //
        object eventVar = this.safeString(message, "channel");
        callDynamically(client as WebSocketClient, "resolve", new object[] {message, eventVar});
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        // first message (snapshot)
        //
        //     {
        //         "channel": "book",
        //         "type": "snapshot",
        //         "data": [
        //             {
        //                 "symbol": "MATIC/USD",
        //                 "bids": [
        //                     {
        //                         "price": 0.5666,
        //                         "qty": 4831.75496356
        //                     },
        //                     {
        //                         "price": 0.5665,
        //                         "qty": 6658.22734739
        //                     }
        //                 ],
        //                 "asks": [
        //                     {
        //                         "price": 0.5668,
        //                         "qty": 4410.79769741
        //                     },
        //                     {
        //                         "price": 0.5669,
        //                         "qty": 4655.40412487
        //                     }
        //                 ],
        //                 "checksum": 2439117997
        //             }
        //         ]
        //     }
        //
        // subsequent updates
        //
        //     {
        //         "channel": "book",
        //         "type": "update",
        //         "data": [
        //             {
        //                 "symbol": "MATIC/USD",
        //                 "bids": [
        //                     {
        //                         "price": 0.5657,
        //                         "qty": 1098.3947558
        //                     }
        //                 ],
        //                 "asks": [],
        //                 "checksum": 2114181697,
        //                 "timestamp": "2023-10-06T17:35:55.440295Z"
        //             }
        //         ]
        //     }
        //
        object type = this.safeString(message, "type");
        object data = this.safeList(message, "data", new List<object>() {});
        object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
        object symbol = this.safeString(first, "symbol");
        object a = this.safeValue(first, "asks", new List<object>() {});
        object b = this.safeValue(first, "bids", new List<object>() {});
        object c = this.safeInteger(first, "checksum");
        object messageHash = this.getMessageHash("orderbook", null, symbol);
        object orderbook = null;
        if (isTrue(isEqual(type, "update")))
        {
            orderbook = getValue(this.orderbooks, symbol);
            object storedAsks = getValue(orderbook, "asks");
            object storedBids = getValue(orderbook, "bids");
            if (isTrue(!isEqual(a, null)))
            {
                this.customHandleDeltas(storedAsks, a);
            }
            if (isTrue(!isEqual(b, null)))
            {
                this.customHandleDeltas(storedBids, b);
            }
            object datetime = this.safeString(first, "timestamp");
            ((IDictionary<string,object>)orderbook)["symbol"] = symbol;
            ((IDictionary<string,object>)orderbook)["timestamp"] = this.parse8601(datetime);
            ((IDictionary<string,object>)orderbook)["datetime"] = datetime;
        } else
        {
            // snapshot
            object depth = getArrayLength(a);
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, depth);
            orderbook = getValue(this.orderbooks, symbol);
            object keys = new List<object>() {"asks", "bids"};
            for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
            {
                object key = getValue(keys, i);
                object bookside = getValue(orderbook, key);
                object deltas = this.safeValue(first, key, new List<object>() {});
                if (isTrue(isGreaterThan(getArrayLength(deltas), 0)))
                {
                    this.customHandleDeltas(bookside, deltas);
                }
            }
            ((IDictionary<string,object>)orderbook)["symbol"] = symbol;
        }
        (orderbook as IOrderBook).limit();
        // checksum temporarily disabled because the exchange checksum was not reliable
        object checksum = this.handleOption("watchOrderBook", "checksum", false);
        if (isTrue(checksum))
        {
            object payloadArray = new List<object>() {};
            if (isTrue(!isEqual(c, null)))
            {
                object checkAsks = getValue(orderbook, "asks");
                object checkBids = getValue(orderbook, "bids");
                // const checkAsks = asks.map ((elem) => [ elem['price'], elem['qty'] ]);
                // const checkBids = bids.map ((elem) => [ elem['price'], elem['qty'] ]);
                for (object i = 0; isLessThan(i, 10); postFixIncrement(ref i))
                {
                    object currentAsk = this.safeValue(checkAsks, i, new Dictionary<string, object>() {});
                    object formattedAsk = add(this.formatNumber(getValue(currentAsk, 0)), this.formatNumber(getValue(currentAsk, 1)));
                    ((IList<object>)payloadArray).Add(formattedAsk);
                }
                for (object i = 0; isLessThan(i, 10); postFixIncrement(ref i))
                {
                    object currentBid = this.safeValue(checkBids, i, new Dictionary<string, object>() {});
                    object formattedBid = add(this.formatNumber(getValue(currentBid, 0)), this.formatNumber(getValue(currentBid, 1)));
                    ((IList<object>)payloadArray).Add(formattedBid);
                }
            }
            object payload = String.Join("", ((IList<object>)payloadArray).ToArray());
            object localChecksum = this.crc32(payload, false);
            if (isTrue(!isEqual(localChecksum, c)))
            {
                var error = new ChecksumError(add(add(this.id, " "), this.orderbookChecksumMessage(symbol)));
                ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
                ((IDictionary<string,object>)this.orderbooks).Remove((string)symbol);
                ((WebSocketClient)client).reject(error, messageHash);
                return;
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public virtual void customHandleDeltas(object bookside, object deltas)
    {
        // const sortOrder = (key === 'bids') ? true : false;
        for (object j = 0; isLessThan(j, getArrayLength(deltas)); postFixIncrement(ref j))
        {
            object delta = getValue(deltas, j);
            object price = this.safeNumber(delta, "price");
            object amount = this.safeNumber(delta, "qty");
            (bookside as IOrderBookSide).store(price, amount);
        }
    }

    public virtual object formatNumber(object data)
    {
        object parts = ((string)data).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        object integer = this.safeString(parts, 0);
        object decimals = this.safeString(parts, 1, "");
        object joinedResult = add(integer, decimals);
        object i = 0;
        while (isEqual(getValue(joinedResult, i), "0"))
        {
            i = add(i, 1);
        }
        if (isTrue(isGreaterThan(i, 0)))
        {
            joinedResult = slice(joinedResult, i, null);
        }
        return joinedResult;
    }

    public virtual object handleSystemStatus(WebSocketClient client, object message)
    {
        //
        // todo: answer the question whether handleSystemStatus should be renamed
        // and unified as handleStatus for any usage pattern that
        // involves system status and maintenance updates
        //
        //     {
        //         "connectionID": 15527282728335292000,
        //         "event": "systemStatus",
        //         "status": "online", // online|maintenance|(custom status tbd)
        //         "version": "0.2.0"
        //     }
        //
        // v2
        //     {
        //         channel: 'status',
        //         type: 'update',
        //         data: [
        //             {
        //                 version: '2.0.10',
        //                 system: 'online',
        //                 api_version: 'v2',
        //                 connection_id: 6447481662169813000
        //             }
        //         ]
        //     }
        //
        return message;
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        var client = this.client(url);
        object authenticated = "authenticated";
        object subscription = this.safeValue(((WebSocketClient)client).subscriptions, authenticated);
        object now = this.seconds();
        object start = this.safeInteger(subscription, "start");
        object expires = this.safeInteger(subscription, "expires");
        if (isTrue(isTrue((isEqual(subscription, null))) || isTrue((isTrue((!isEqual(subscription, null))) && isTrue(isLessThanOrEqual((add(start, expires)), now))))))
        {
            // https://docs.kraken.com/api/docs/rest-api/get-websockets-token
            object response = await this.privatePostGetWebSocketsToken(parameters);
            //
            //     {
            //         "error":[],
            //         "result":{
            //             "token":"xeAQ\/RCChBYNVh53sTv1yZ5H4wIbwDF20PiHtTF+4UI",
            //             "expires":900
            //         }
            //     }
            //
            subscription = this.safeDict(response, "result");
            ((IDictionary<string,object>)subscription)["start"] = now;
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)authenticated] = subscription;
        }
        return this.safeString(subscription, "token");
    }

    public async virtual Task<object> watchPrivate(object name, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object token = await this.authenticate();
        object subscriptionHash = "executions";
        object messageHash = name;
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
            messageHash = add(messageHash, add(":", symbol));
        }
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "privateV2");
        object requestId = this.requestId();
        object subscribe = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "params", new Dictionary<string, object>() {
                { "channel", "executions" },
                { "token", token },
            } },
            { "req_id", requestId },
        };
        if (isTrue(!isEqual(parameters, null)))
        {
            ((IDictionary<string,object>)subscribe)["params"] = this.deepExtend(getValue(subscribe, "params"), parameters);
        }
        object result = await this.watch(url, messageHash, subscribe, subscriptionHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(result, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(result, symbol, since, limit);
    }

    /**
     * @method
     * @name kraken#watchMyTrades
     * @description watches information on multiple trades made by the user
     * @see https://docs.kraken.com/api/docs/websocket-v2/executions
     * @param {string} symbol unified market symbol of the market trades were made in
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trade structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
     */
    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["snap_trades"] = true;
        return await this.watchPrivate("myTrades", symbol, since, limit, parameters);
    }

    public virtual void handleMyTrades(WebSocketClient client, object message, object subscription = null)
    {
        //
        //     {
        //         "channel": "executions",
        //         "type": "update",
        //         "data": [
        //             {
        //                 "order_id": "O6NTZC-K6FRH-ATWBCK",
        //                 "exec_id": "T5DIUI-5N4KO-Z5BPXK",
        //                 "exec_type": "trade",
        //                 "trade_id": 8253473,
        //                 "symbol": "USDC/USD",
        //                 "side": "sell",
        //                 "last_qty": 15.44,
        //                 "last_price": 1.0002,
        //                 "liquidity_ind": "t",
        //                 "cost": 15.443088,
        //                 "order_userref": 0,
        //                 "order_status": "filled",
        //                 "order_type": "market",
        //                 "fee_usd_equiv": 0.03088618,
        //                 "fees": [
        //                     {
        //                         "asset": "USD",
        //                         "qty": 0.3458
        //                     }
        //                 ]
        //             }
        //         ],
        //         "sequence": 10
        //     }
        //
        object allTrades = this.safeList(message, "data", new List<object>() {});
        object allTradesLength = getArrayLength(allTrades);
        if (isTrue(isGreaterThan(allTradesLength, 0)))
        {
            if (isTrue(isEqual(this.myTrades, null)))
            {
                object limit = this.safeInteger(this.options, "tradesLimit", 1000);
                this.myTrades = new ArrayCache(limit);
            }
            object stored = this.myTrades;
            object symbols = new Dictionary<string, object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(allTrades)); postFixIncrement(ref i))
            {
                object trade = this.safeDict(allTrades, i, new Dictionary<string, object>() {});
                object parsed = this.parseWsTrade(trade);
                callDynamically(stored, "append", new object[] {parsed});
                object symbol = getValue(parsed, "symbol");
                ((IDictionary<string,object>)symbols)[(string)symbol] = true;
            }
            object name = "myTrades";
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.myTrades, name});
            object keys = new List<object>(((IDictionary<string,object>)symbols).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
            {
                object messageHash = add(add(name, ":"), getValue(keys, i));
                callDynamically(client as WebSocketClient, "resolve", new object[] {this.myTrades, messageHash});
            }
        }
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        //     {
        //         "order_id": "O6NTZC-K6FRH-ATWBCK",
        //         "exec_id": "T5DIUI-5N4KO-Z5BPXK",
        //         "exec_type": "trade",
        //         "trade_id": 8253473,
        //         "symbol": "USDC/USD",
        //         "side": "sell",
        //         "last_qty": 15.44,
        //         "last_price": 1.0002,
        //         "liquidity_ind": "t",
        //         "cost": 15.443088,
        //         "order_userref": 0,
        //         "order_status": "filled",
        //         "order_type": "market",
        //         "fee_usd_equiv": 0.03088618,
        //         "fees": [
        //             {
        //                 "asset": "USD",
        //                 "qty": 0.3458
        //             }
        //         ]
        //     }
        //
        object symbol = this.safeString(trade, "symbol");
        if (isTrue(!isEqual(market, null)))
        {
            symbol = getValue(market, "symbol");
        }
        object fee = null;
        if (isTrue(inOp(trade, "fees")))
        {
            object fees = this.safeList(trade, "fees", new List<object>() {});
            object firstFee = this.safeDict(fees, 0, new Dictionary<string, object>() {});
            fee = new Dictionary<string, object>() {
                { "cost", this.safeNumber(firstFee, "qty") },
                { "currency", this.safeString(firstFee, "asset") },
            };
        }
        object datetime = this.safeString(trade, "timestamp");
        object liquidityIndicator = this.safeString(trade, "liquidity_ind");
        object takerOrMaker = ((bool) isTrue((isEqual(liquidityIndicator, "t")))) ? "taker" : "maker";
        return new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString(trade, "exec_id") },
            { "order", this.safeString(trade, "order_id") },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "symbol", symbol },
            { "type", this.safeString(trade, "order_type") },
            { "side", this.safeString(trade, "side") },
            { "takerOrMaker", takerOrMaker },
            { "price", this.safeNumber(trade, "last_price") },
            { "amount", this.safeNumber(trade, "last_qty") },
            { "cost", this.safeNumber(trade, "cost") },
            { "fee", fee },
        };
    }

    /**
     * @method
     * @name kraken#watchOrders
     * @description watches information on multiple orders made by the user
     * @see https://docs.kraken.com/api/docs/websocket-v2/executions
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of  orde structures to retrieve
     * @param {object} [params] maximum number of orderic to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.watchPrivate("orders", symbol, since, limit, this.extend(parameters, new Dictionary<string, object>() {
            { "snap_orders", true },
        }));
    }

    public virtual void handleOrders(WebSocketClient client, object message, object subscription = null)
    {
        //
        //     {
        //         "channel": "executions",
        //         "type": "update",
        //         "data": [
        //             {
        //                 "order_id": "OK4GJX-KSTLS-7DZZO5",
        //                 "order_userref": 3,
        //                 "symbol": "BTC/USD",
        //                 "order_qty": 0.005,
        //                 "cum_cost": 0.0,
        //                 "time_in_force": "GTC",
        //                 "exec_type": "pending_new",
        //                 "side": "sell",
        //                 "order_type": "limit",
        //                 "limit_price_type": "static",
        //                 "limit_price": 26500.0,
        //                 "stop_price": 0.0,
        //                 "order_status": "pending_new",
        //                 "fee_usd_equiv": 0.0,
        //                 "fee_ccy_pref": "fciq",
        //                 "timestamp": "2023-09-22T10:33:05.709950Z"
        //             }
        //         ],
        //         "sequence": 8
        //     }
        //
        object allOrders = this.safeList(message, "data", new List<object>() {});
        object allOrdersLength = getArrayLength(allOrders);
        if (isTrue(isGreaterThan(allOrdersLength, 0)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            if (isTrue(isEqual(this.orders, null)))
            {
                this.orders = new ArrayCacheBySymbolById(limit);
            }
            object stored = this.orders;
            object symbols = new Dictionary<string, object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(allOrders)); postFixIncrement(ref i))
            {
                object order = this.safeDict(allOrders, i, new Dictionary<string, object>() {});
                object id = this.safeString(order, "order_id");
                object parsed = this.parseWsOrder(order);
                object symbol = this.safeString(order, "symbol");
                object previousOrders = this.safeValue((stored as ArrayCache).hashmap, symbol);
                object previousOrder = this.safeValue(previousOrders, id);
                object newOrder = parsed;
                if (isTrue(!isEqual(previousOrder, null)))
                {
                    object newRawOrder = this.extend(getValue(previousOrder, "info"), getValue(newOrder, "info"));
                    newOrder = this.parseWsOrder(newRawOrder);
                }
                object length = getArrayLength(stored);
                if (isTrue(isTrue(isEqual(length, limit)) && isTrue((isEqual(previousOrder, null)))))
                {
                    object first = getValue(stored, 0);
                    object symbolsByOrderId = this.safeValue(this.options, "symbolsByOrderId", new Dictionary<string, object>() {});
                    if (isTrue(inOp(symbolsByOrderId, getValue(first, "id"))))
                    {
                        ((IDictionary<string,object>)symbolsByOrderId).Remove((string)getValue(first, "id"));
                    }
                }
                callDynamically(stored, "append", new object[] {newOrder});
                if (isTrue(!isEqual(symbol, null)))
                {
                    ((IDictionary<string,object>)symbols)[(string)symbol] = true;
                }
            }
            object name = "orders";
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, name});
            object keys = new List<object>(((IDictionary<string,object>)symbols).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
            {
                object messageHash = add(add(name, ":"), getValue(keys, i));
                callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageHash});
            }
        }
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        // watchOrders
        //
        // open order
        //     {
        //         "order_id": "OK4GJX-KSTLS-7DZZO5",
        //         "order_userref": 3,
        //         "symbol": "BTC/USD",
        //         "order_qty": 0.005,
        //         "cum_cost": 0.0,
        //         "time_in_force": "GTC",
        //         "exec_type": "pending_new",
        //         "side": "sell",
        //         "order_type": "limit",
        //         "limit_price_type": "static",
        //         "limit_price": 26500.0,
        //         "stop_price": 0.0,
        //         "order_status": "pending_new",
        //         "fee_usd_equiv": 0.0,
        //         "fee_ccy_pref": "fciq",
        //         "timestamp": "2023-09-22T10:33:05.709950Z"
        //     }
        //
        // canceled order
        //
        //     {
        //         "timestamp": "2025-10-11T15:11:47.695226Z",
        //         "order_status": "canceled",
        //         "exec_type": "canceled",
        //         "order_userref": 0,
        //         "order_id": "OGAB7Y-BKX5F-PTK5RW",
        //         "cum_qty": 0,
        //         "cum_cost": 0,
        //         "fee_usd_equiv": 0,
        //         "avg_price": 0,
        //         "cancel_reason": "User requested",
        //         "reason": "User requested"
        //     }
        //
        object fee = new Dictionary<string, object>() {
            { "cost", this.safeString(order, "fee_usd_equiv") },
            { "currency", "USD" },
        };
        object stopPrice = this.safeString(order, "stop_price");
        object datetime = this.safeString(order, "timestamp");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(order, "order_id") },
            { "clientOrderId", this.safeString(order, "order_userref") },
            { "info", order },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "lastTradeTimestamp", null },
            { "status", this.parseOrderStatus(this.safeString(order, "order_status")) },
            { "symbol", this.safeString(order, "symbol") },
            { "type", this.safeString(order, "order_type") },
            { "timeInForce", this.safeString(order, "time_in_force") },
            { "postOnly", null },
            { "side", this.safeString(order, "side") },
            { "price", this.safeString(order, "limit_price") },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "cost", this.safeString(order, "cum_cost") },
            { "amount", this.safeString2(order, "order_qty", "cum_qty") },
            { "filled", null },
            { "average", this.safeString(order, "avg_price") },
            { "remaining", null },
            { "fee", fee },
            { "trades", null },
        });
    }

    public async virtual Task<object> watchMultiHelper(object unifiedName, object channelName, object symbols = null, object subscriptionArgs = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        // symbols are required
        symbols = this.marketSymbols(symbols, null, false, true, false);
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object eventTrigger = this.safeString(parameters, "event_trigger");
            if (isTrue(!isEqual(eventTrigger, null)))
            {
                ((IList<object>)messageHashes).Add(this.getMessageHash(channelName, null, this.symbol(getValue(symbols, i))));
            } else
            {
                ((IList<object>)messageHashes).Add(this.getMessageHash(unifiedName, null, this.symbol(getValue(symbols, i))));
            }
        }
        object request = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "params", new Dictionary<string, object>() {
                { "channel", channelName },
                { "symbol", symbols },
            } },
            { "req_id", this.requestId() },
        };
        ((IDictionary<string,object>)request)["params"] = this.deepExtend(getValue(request, "params"), parameters);
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "publicV2");
        return await this.watchMultiple(url, messageHashes, request, messageHashes, subscriptionArgs);
    }

    /**
     * @method
     * @name kraken#watchBalance
     * @description watch balance and get the amount of funds available for trading or funds locked in orders
     * @see https://docs.kraken.com/api/docs/websocket-v2/balances
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
     */
    public async override Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object token = await this.authenticate();
        object messageHash = "balances";
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "privateV2");
        object requestId = this.requestId();
        object subscribe = new Dictionary<string, object>() {
            { "method", "subscribe" },
            { "req_id", requestId },
            { "params", new Dictionary<string, object>() {
                { "channel", "balances" },
                { "token", token },
            } },
        };
        object request = this.deepExtend(subscribe, parameters);
        return await this.watch(url, messageHash, request, messageHash);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        //     {
        //         "channel": "balances",
        //         "data": [
        //             {
        //                 "asset": "BTC",
        //                 "asset_class": "currency",
        //                 "balance": 1.2,
        //                 "wallets": [
        //                     {
        //                         "type": "spot",
        //                         "id": "main",
        //                         "balance": 1.2
        //                     }
        //                 ]
        //             }
        //         ],
        //         "type": "snapshot",
        //         "sequence": 1
        //     }
        //
        object data = this.safeList(message, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {
            { "info", message },
        };
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object currencyId = this.safeString(getValue(data, i), "asset");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            object eq = this.safeString(getValue(data, i), "balance");
            ((IDictionary<string,object>)account)["total"] = eq;
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        object type = "spot";
        object balance = this.safeBalance(result);
        object oldBalance = this.safeValue(this.balance, type, new Dictionary<string, object>() {});
        object newBalance = this.deepExtend(oldBalance, balance);
        ((IDictionary<string,object>)this.balance)[(string)type] = this.safeBalance(newBalance);
        object channel = this.safeString(message, "channel");
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, type), channel});
    }

    public virtual object getMessageHash(object unifiedElementName, object subChannelName = null, object symbol = null)
    {
        // unifiedElementName can be : orderbook, trade, ticker, bidask ...
        // subChannelName only applies to channel that needs specific variation (i.e. depth_50, depth_100..) to be selected
        object withSymbol = !isEqual(symbol, null);
        object messageHash = unifiedElementName;
        if (!isTrue(withSymbol))
        {
            messageHash = add(messageHash, "s");
        } else
        {
            messageHash = add(messageHash, add("@", symbol));
        }
        if (isTrue(!isEqual(subChannelName, null)))
        {
            messageHash = add(messageHash, add("#", subChannelName));
        }
        return messageHash;
    }

    public virtual void handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        // public
        //
        //     {
        //         "channelID": 210,
        //         "channelName": "book-10",
        //         "event": "subscriptionStatus",
        //         "reqid": 1574146735269,
        //         "pair": "ETH/XBT",
        //         "status": "subscribed",
        //         "subscription": { depth: 10, name: "book" }
        //     }
        //
        // private
        //
        //     {
        //         "channelName": "openOrders",
        //         "event": "subscriptionStatus",
        //         "reqid": 1,
        //         "status": "subscribed",
        //         "subscription": { maxratecount: 125, name: "openOrders" }
        //     }
        //
        object channelId = this.safeString(message, "channelID");
        if (isTrue(!isEqual(channelId, null)))
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)channelId] = message;
        }
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //     {
        //         "errorMessage": "Currency pair not in ISO 4217-A3 format foobar",
        //         "event": "subscriptionStatus",
        //         "pair": "foobar",
        //         "reqid": 1574146735269,
        //         "status": "error",
        //         "subscription": { name: "ticker" }
        //     }
        //
        // v2
        //     {
        //         "error": "Unsupported field: 'price' for the given msg type: add order",
        //         "method": "add_order",
        //         "success": false,
        //         "time_in": "2025-05-13T08:59:44.803511Z",
        //         "time_out": "2025-05-13T08:59:44.803542Z'
        //     }
        //
        object errorMessage = this.safeString2(message, "errorMessage", "error");
        if (isTrue(!isEqual(errorMessage, null)))
        {
            object requestId = this.safeString2(message, "reqid", "req_id");
            object broad = getValue(getValue(this.exceptions, "ws"), "broad");
            object broadKey = this.findBroadlyMatchedKey(broad, errorMessage);
            object exception = null;
            if (isTrue(isEqual(broadKey, null)))
            {
                exception = new ExchangeError(                ((string)errorMessage)); // c# requirement to convert the errorMessage to string
            } else
            {
                exception = this.newException(getValue(broad, broadKey), errorMessage);
            }
            if (isTrue(!isEqual(requestId, null)))
            {
                ((WebSocketClient)client).reject(exception, requestId);
            }
            return false;
        }
        return true;
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        object channel = this.safeString(message, "channel");
        if (isTrue(!isEqual(channel, null)))
        {
            if (isTrue(isEqual(channel, "executions")))
            {
                object data = this.safeList(message, "data", new List<object>() {});
                object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
                object execType = this.safeString(first, "exec_type");
                channel = ((bool) isTrue((isEqual(execType, "trade")))) ? "myTrades" : "orders";
            }
            object methods = new Dictionary<string, object>() {
                { "balances", this.handleBalance },
                { "book", this.handleOrderBook },
                { "ohlc", this.handleOHLCV },
                { "ticker", this.handleTicker },
                { "trade", this.handleTrades },
                { "myTrades", this.handleMyTrades },
                { "orders", this.handleOrders },
            };
            object method = this.safeValue(methods, channel);
            if (isTrue(!isEqual(method, null)))
            {
                DynamicInvoker.InvokeMethod(method, new object[] { client, message});
            }
        }
        if (isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            object eventVar = this.safeString2(message, "event", "method");
            object methods = new Dictionary<string, object>() {
                { "heartbeat", this.handleHeartbeat },
                { "systemStatus", this.handleSystemStatus },
                { "subscriptionStatus", this.handleSubscriptionStatus },
                { "add_order", this.handleCreateEditOrder },
                { "amend_order", this.handleCreateEditOrder },
                { "cancel_order", this.handleCancelOrder },
                { "cancel_all", this.handleCancelAllOrders },
                { "pong", this.handlePong },
            };
            object method = this.safeValue(methods, eventVar);
            if (isTrue(!isEqual(method, null)))
            {
                DynamicInvoker.InvokeMethod(method, new object[] { client, message});
            }
        }
    }
}
