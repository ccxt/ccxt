namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class bullish { public bullish(object args = null) : base(args) { } }
public partial class bullish : ccxt.bullish
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchTicker", true },
                { "watchTickers", false },
                { "watchOrderBook", true },
                { "watchOrders", true },
                { "watchTrades", true },
                { "watchPositions", true },
                { "watchMyTrades", true },
                { "watchBalance", true },
                { "watchOHLCV", false },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://api.exchange.bullish.com" },
                        { "private", "wss://api.exchange.bullish.com/trading-api/v1/private-data" },
                    } },
                } },
                { "test", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://api.simnext.bullish-test.com" },
                        { "private", "wss://api.simnext.bullish-test.com/trading-api/v1/private-data" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "ws", new Dictionary<string, object>() {
                    { "cookies", new Dictionary<string, object>() {} },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "ping", this.ping },
                { "keepAlive", 99000 },
            } },
        });
    }

    public virtual object requestId()
    {
        object requestId = this.sum(this.safeInteger(this.options, "requestId", 0), 1);
        ((IDictionary<string,object>)this.options)["requestId"] = requestId;
        return requestId;
    }

    public override object ping(WebSocketClient client)
    {
        // bullish does not support built-in ws protocol-level ping-pong
        // https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--keep-websocket-open
        object id = ((object)this.requestId()).ToString();
        return new Dictionary<string, object>() {
            { "jsonrpc", "2.0" },
            { "type", "command" },
            { "method", "keepalivePing" },
            { "params", new Dictionary<string, object>() {} },
            { "id", id },
        };
    }

    public virtual object handlePong(WebSocketClient client, object message)
    {
        //
        //     {
        //         "id": "7",
        //         "jsonrpc": "2.0",
        //         "result": {
        //             "responseCodeName": "OK",
        //             "responseCode": "200",
        //             "message": "Keep alive pong"
        //         }
        //     }
        //
        client.lastPong = this.milliseconds();
        return message;  // current line is for transpilation compatibility
    }

    public async virtual Task<object> watchPublic(object url, object messageHash, object request = null, object parameters = null)
    {
        request ??= new Dictionary<string, object>();
        parameters ??= new Dictionary<string, object>();
        object id = ((object)this.requestId()).ToString();
        object message = new Dictionary<string, object>() {
            { "jsonrpc", "2.0" },
            { "type", "command" },
            { "method", "subscribe" },
            { "params", request },
            { "id", id },
        };
        object fullUrl = add(getValue(getValue(getValue(this.urls, "api"), "ws"), "public"), url);
        return await this.watch(fullUrl, messageHash, this.deepExtend(message, parameters), messageHash);
    }

    public async virtual Task<object> watchPrivate(object messageHash, object subscribeHash, object request = null, object parameters = null)
    {
        request ??= new Dictionary<string, object>();
        parameters ??= new Dictionary<string, object>();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        object token = await this.handleToken();
        object cookies = new Dictionary<string, object>() {
            { "JWT_COOKIE", token },
        };
        ((IDictionary<string,object>)getValue(this.options, "ws"))["cookies"] = cookies;
        object id = ((object)this.requestId()).ToString();
        object message = new Dictionary<string, object>() {
            { "jsonrpc", "2.0" },
            { "type", "command" },
            { "method", "subscribe" },
            { "params", request },
            { "id", id },
        };
        object result = await this.watch(url, messageHash, this.deepExtend(message, parameters), subscribeHash);
        return result;
    }

    /**
     * @method
     * @name bullish#watchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--unified-anonymous-trades-websocket-unauthenticated
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object messageHash = add("trades::", getValue(market, "symbol"));
        object url = "/trading-api/v1/market-data/trades";
        object request = new Dictionary<string, object>() {
            { "topic", "anonymousTrades" },
            { "symbol", getValue(market, "id") },
        };
        object trades = await this.watchPublic(url, messageHash, request, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        //     {
        //         "type": "snapshot",
        //         "dataType": "V1TAAnonymousTradeUpdate",
        //         "data": {
        //             "trades": [
        //                 {
        //                     "tradeId": "100086000000609304",
        //                     "isTaker": true,
        //                     "price": "104889.2063",
        //                     "createdAtTimestamp": "1749124509118",
        //                     "quantity": "0.01000000",
        //                     "publishedAtTimestamp": "1749124531466",
        //                     "side": "BUY",
        //                     "createdAtDatetime": "2025-06-05T11:55:09.118Z",
        //                     "symbol": "BTCUSDC"
        //                 }
        //             ],
        //             "createdAtTimestamp": "1749124509118",
        //             "publishedAtTimestamp": "1749124531466",
        //             "symbol": "BTCUSDC"
        //         }
        //     }
        //
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "symbol");
        object symbol = this.safeSymbol(marketId);
        object market = this.market(symbol);
        object rawTrades = this.safeList(data, "trades", new List<object>() {});
        object trades = this.parseTrades(rawTrades, market);
        if (!isTrue((inOp(this.trades, symbol))))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            var tradesArrayCache = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = tradesArrayCache;
        }
        object tradesArray = getValue(this.trades, symbol);
        for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
        {
            callDynamically(tradesArray, "append", new object[] {getValue(trades, i)});
        }
        ((IDictionary<string,object>)this.trades)[(string)symbol] = tradesArray;
        object messageHash = add("trades::", getValue(market, "symbol"));
        callDynamically(client as WebSocketClient, "resolve", new object[] {tradesArray, messageHash});
    }

    /**
     * @method
     * @name bullish#watchTicker
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--anonymous-market-data-price-tick-unauthenticated
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "public"), "/trading-api/v1/market-data/tick/"), getValue(market, "id"));
        object messageHash = add("ticker::", symbol);
        return await this.watch(url, messageHash, parameters, messageHash);  // no need to send a subscribe message, the server sends a ticker update on connect
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        //     {
        //         "type": "update",
        //         "dataType": "V1TATickerResponse",
        //         "data": {
        //             "askVolume": "0.00100822",
        //             "average": "104423.1806",
        //             "baseVolume": "472.83799258",
        //             "bestAsk": "104324.6000",
        //             "bestBid": "104324.5000",
        //             "bidVolume": "0.00020146",
        //             "change": "-198.4864",
        //             "close": "104323.9374",
        //             "createdAtTimestamp": "1749132838951",
        //             "publishedAtTimestamp": "1749132838955",
        //             "high": "105966.6577",
        //             "last": "104323.9374",
        //             "lastTradeDatetime": "2025-06-05T14:13:56.111Z",
        //             "lastTradeSize": "0.02396100",
        //             "low": "104246.6662",
        //             "open": "104522.4238",
        //             "percentage": "-0.19",
        //             "quoteVolume": "49662592.6712",
        //             "symbol": "BTC-USDC-PERP",
        //             "type": "ticker",
        //             "vwap": "105030.6996",
        //             "currentPrice": "104324.7747",
        //             "ammData": [
        //                 {
        //                     "feeTierId": "1",
        //                     "currentPrice": "104324.7747",
        //                     "baseReservesQuantity": "8.27911366",
        //                     "quoteReservesQuantity": "1067283.0234",
        //                     "bidSpreadFee": "0.00000000",
        //                     "askSpreadFee": "0.00000000"
        //                 }
        //             ],
        //             "createdAtDatetime": "2025-06-05T14:13:58.951Z",
        //             "markPrice": "104289.6884",
        //             "fundingRate": "-0.000192",
        //             "openInterest": "92.24146651"
        //         }
        //     }
        //
        object updateType = this.safeString(message, "type", "");
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "symbol");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object parsed = null;
        if (isTrue((isEqual(updateType, "snapshot"))))
        {
            parsed = this.parseTicker(data, market);
        } else if (isTrue(isEqual(updateType, "update")))
        {
            object ticker = this.safeDict(this.tickers, symbol, new Dictionary<string, object>() {});
            object rawTicker = this.safeDict(ticker, "info", new Dictionary<string, object>() {});
            object merged = this.extend(rawTicker, data);
            parsed = this.parseTicker(merged, market);
        }
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = parsed;
        object messageHash = add("ticker::", symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.tickers, symbol), messageHash});
    }

    /**
     * @method
     * @name bullish#watchOrderBook
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--multi-orderbook-websocket-unauthenticated
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object url = "/trading-api/v1/market-data/orderbook";
        object messageHash = add("orderbook::", getValue(market, "symbol"));
        object request = new Dictionary<string, object>() {
            { "topic", "l2Orderbook" },
            { "symbol", getValue(market, "id") },
        };
        object orderbook = await this.watchPublic(url, messageHash, request, parameters);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //     {
        //         "type": "snapshot",
        //         "dataType": "V1TALevel2",
        //         "data": {
        //             "timestamp": "1749372632028",
        //             "bids": [
        //                 "105523.3000",
        //                 "0.00046045",
        //             ],
        //             "asks": [
        //                 "105523.4000",
        //                 "0.00117112",
        //             ],
        //             "publishedAtTimestamp": "1749372632073",
        //             "datetime": "2025-06-08T08:50:32.028Z",
        //             "sequenceNumberRange": [ 1967862061, 1967862062 ],
        //             "symbol": "BTCUSDC"
        //         }
        //     }
        //
        // current channel is 'l2Orderbook' which returns only snapshots
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "symbol");
        object symbol = this.safeSymbol(marketId);
        object messageHash = add("orderbook::", symbol);
        object timestamp = this.safeInteger(data, "timestamp");
        if (!isTrue((inOp(this.orderbooks, symbol))))
        {
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook();
        }
        object orderbook = getValue(this.orderbooks, symbol);
        object bids = this.separateBidsOrAsks(this.safeList(data, "bids", new List<object>() {}));
        object asks = this.separateBidsOrAsks(this.safeList(data, "asks", new List<object>() {}));
        object snapshot = new Dictionary<string, object>() {
            { "bids", bids },
            { "asks", asks },
        };
        object parsed = this.parseOrderBook(snapshot, symbol, timestamp);
        object sequenceNumberRange = this.safeList(data, "sequenceNumberRange", new List<object>() {});
        if (isTrue(isGreaterThan(getArrayLength(sequenceNumberRange), 0)))
        {
            object lastIndex = subtract(getArrayLength(sequenceNumberRange), 1);
            ((IDictionary<string,object>)parsed)["nonce"] = this.safeInteger(sequenceNumberRange, lastIndex);
        }
        (orderbook as IOrderBook).reset(parsed);
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public virtual object separateBidsOrAsks(object entry)
    {
        object result = new List<object>() {};
        // 300 = '54885.0000000'
        // 301 = '0.06141566'
        // 302 ='53714.0000000'
        for (object i = 0; isLessThan(i, getArrayLength(entry)); postFixIncrement(ref i))
        {
            if (isTrue(!isEqual(mod(i, 2), 0)))
            {
                continue;
            }
            object price = this.safeString(entry, i);
            object amount = this.safeString(entry, add(i, 1));
            ((IList<object>)result).Add(new List<object>() {price, amount});
        }
        return result;
    }

    /**
     * @method
     * @name bullish#watchOrders
     * @description watches information on multiple orders made by the user
     * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--private-data-websocket-authenticated
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.tradingAccountId] the trading account id to fetch entries for
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object subscribeHash = "orders";
        object messageHash = subscribeHash;
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
            messageHash = add(add(messageHash, "::"), symbol);
        }
        object request = new Dictionary<string, object>() {
            { "topic", "orders" },
        };
        object tradingAccountId = this.safeString(parameters, "tradingAccountId");
        if (isTrue(!isEqual(tradingAccountId, null)))
        {
            ((IDictionary<string,object>)request)["tradingAccountId"] = tradingAccountId;
            parameters = this.omit(parameters, "tradingAccountId");
        }
        object orders = await this.watchPrivate(messageHash, subscribeHash, request, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleOrders(WebSocketClient client, object message)
    {
        // snapshot
        //     {
        //         "type": "snapshot",
        //         "tradingAccountId": "111309424211255",
        //         "dataType": "V1TAOrder",
        //         "data": [ ... ] // could be an empty list or a list of orders
        //     }
        //
        // update
        //     {
        //         "type": "update",
        //         "tradingAccountId": "111309424211255",
        //         "dataType": "V1TAOrder",
        //         "data": {
        //             "status": "OPEN",
        //             "createdAtTimestamp": "1751893427971",
        //             "quoteFee": "0.000000",
        //             "stopPrice": null,
        //             "quantityFilled": "0.00000000",
        //             "handle": null,
        //             "clientOrderId": null,
        //             "quantity": "0.10000000",
        //             "margin": false,
        //             "side": "BUY",
        //             "createdAtDatetime": "2025-07-07T13:03:47.971Z",
        //             "isLiquidation": false,
        //             "borrowedQuoteQuantity": null,
        //             "borrowedBaseQuantity": null,
        //             "timeInForce": "GTC",
        //             "borrowedQuantity": null,
        //             "baseFee": "0.000000",
        //             "quoteAmount": "0.0000000",
        //             "price": "0.0000000",
        //             "statusReason": "Order accepted",
        //             "type": "MKT",
        //             "statusReasonCode": 6014,
        //             "allowBorrow": false,
        //             "orderId": "862317981870850049",
        //             "publishedAtTimestamp": "1751893427975",
        //             "symbol": "ETHUSDT",
        //             "averageFillPrice": null
        //         }
        //     }
        //
        object type = this.safeString(message, "type");
        object rawOrders = new List<object>() {};
        if (isTrue(isEqual(type, "update")))
        {
            object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
            ((IList<object>)rawOrders).Add(data); // update is a single order
        } else
        {
            rawOrders = this.safeList(message, "data", new List<object>() {}); // snapshot is a list of orders
        }
        if (isTrue(isGreaterThan(getArrayLength(rawOrders), 0)))
        {
            if (isTrue(isEqual(this.orders, null)))
            {
                object limit = this.safeInteger(this.options, "ordersLimit", 1000);
                this.orders = new ArrayCacheBySymbolById(limit);
            }
            object orders = this.orders;
            object symbols = new Dictionary<string, object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(rawOrders)); postFixIncrement(ref i))
            {
                object rawOrder = getValue(rawOrders, i);
                object parsedOrder = this.parseOrder(rawOrder);
                callDynamically(orders, "append", new object[] {parsedOrder});
                object symbol = this.safeString(parsedOrder, "symbol");
                ((IDictionary<string,object>)symbols)[(string)symbol] = true;
            }
            object messageHash = "orders";
            callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
            object keys = new List<object>(((IDictionary<string,object>)symbols).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
            {
                object hashSymbol = getValue(keys, i);
                object symbolMessageHash = add(add(messageHash, "::"), hashSymbol);
                callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, symbolMessageHash});
            }
        }
    }

    /**
     * @method
     * @name bullish#watchMyTrades
     * @description watches information on multiple trades made by the user
     * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--private-data-websocket-authenticated
     * @param {string} symbol unified market symbol of the market trades were made in
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trade structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.tradingAccountId] the trading account id to fetch entries for
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object subscribeHash = "myTrades";
        object messageHash = subscribeHash;
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
            messageHash = add(messageHash, add("::", symbol));
        }
        object request = new Dictionary<string, object>() {
            { "topic", "trades" },
        };
        object tradingAccountId = this.safeString(parameters, "tradingAccountId");
        if (isTrue(!isEqual(tradingAccountId, null)))
        {
            ((IDictionary<string,object>)request)["tradingAccountId"] = tradingAccountId;
            parameters = this.omit(parameters, "tradingAccountId");
        }
        object trades = await this.watchPrivate(messageHash, subscribeHash, request, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleMyTrades(WebSocketClient client, object message)
    {
        //
        // snapshot
        //     {
        //         "type": "snapshot",
        //         "tradingAccountId": "111309424211255",
        //         "dataType": "V1TATrade",
        //         "data": [ ... ] // could be an empty list or a list of trades
        //     }
        //
        // update
        //     {
        //         "type": "update",
        //         "tradingAccountId": "111309424211255",
        //         "dataType": "V1TATrade",
        //         "data": {
        //             "clientOtcTradeId": null,
        //             "tradeId": "100203000003940164",
        //             "baseFee": "0.00000000",
        //             "isTaker": true,
        //             "quoteAmount": "253.6012195",
        //             "price": "2536.0121950",
        //             "createdAtTimestamp": "1751914859840",
        //             "quoteFee": "0.0000000",
        //             "tradeRebateAmount": null,
        //             "tradeRebateAssetSymbol": null,
        //             "handle": null,
        //             "otcTradeId": null,
        //             "otcMatchId": null,
        //             "orderId": "862407873644725249",
        //             "quantity": "0.10000000",
        //             "publishedAtTimestamp": "1751914859843",
        //             "side": "SELL",
        //             "createdAtDatetime": "2025-07-07T19:00:59.840Z",
        //             "symbol": "ETHUSDT"
        //         }
        //     }
        //
        object type = this.safeString(message, "type");
        object rawTrades = new List<object>() {};
        if (isTrue(isEqual(type, "update")))
        {
            object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
            ((IList<object>)rawTrades).Add(data); // update is a single trade
        } else
        {
            rawTrades = this.safeList(message, "data", new List<object>() {}); // snapshot is a list of trades
        }
        if (isTrue(isGreaterThan(getArrayLength(rawTrades), 0)))
        {
            if (isTrue(isEqual(this.myTrades, null)))
            {
                object limit = this.safeInteger(this.options, "tradesLimit", 1000);
                this.myTrades = new ArrayCacheBySymbolById(limit);
            }
            object trades = this.myTrades;
            object symbols = new Dictionary<string, object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(rawTrades)); postFixIncrement(ref i))
            {
                object rawTrade = getValue(rawTrades, i);
                object parsedTrade = this.parseTrade(rawTrade);
                callDynamically(trades, "append", new object[] {parsedTrade});
                object symbol = this.safeString(parsedTrade, "symbol");
                ((IDictionary<string,object>)symbols)[(string)symbol] = true;
            }
            object messageHash = "myTrades";
            callDynamically(client as WebSocketClient, "resolve", new object[] {trades, messageHash});
            object keys = new List<object>(((IDictionary<string,object>)symbols).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
            {
                object hashSymbol = getValue(keys, i);
                object symbolMessageHash = add(add(messageHash, "::"), hashSymbol);
                callDynamically(client as WebSocketClient, "resolve", new object[] {this.myTrades, symbolMessageHash});
            }
        }
    }

    /**
     * @method
     * @name bullish#watchBalance
     * @description watch balance and get the amount of funds available for trading or funds locked in orders
     * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--private-data-websocket-authenticated
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.tradingAccountId] the trading account id to fetch entries for
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "topic", "assetAccounts" },
        };
        object messageHash = "balance";
        object tradingAccountId = this.safeString(parameters, "tradingAccountId");
        if (isTrue(!isEqual(tradingAccountId, null)))
        {
            parameters = this.omit(parameters, "tradingAccountId");
            ((IDictionary<string,object>)request)["tradingAccountId"] = tradingAccountId;
            messageHash = add(messageHash, add("::", tradingAccountId));
        }
        return await this.watchPrivate(messageHash, messageHash, request, parameters);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        // snapshot
        //     {
        //         "type": "snapshot",
        //         "tradingAccountId": "111309424211255",
        //         "dataType": "V1TAAssetAccount",
        //         "data": [
        //             {
        //                 "updatedAtTimestamp": "1751989627509",
        //                 "borrowedQuantity": "0.0000",
        //                 "tradingAccountId": "111309424211255",
        //                 "loanedQuantity": "0.0000",
        //                 "lockedQuantity": "0.0000",
        //                 "assetId": "5",
        //                 "assetSymbol": "USDC",
        //                 "publishedAtTimestamp": "1751989627512",
        //                 "availableQuantity": "999672939.8767",
        //                 "updatedAtDatetime": "2025-07-08T15:47:07.509Z"
        //             }
        //         ]
        //     }
        //
        // update
        //     {
        //         "type": "update",
        //         "tradingAccountId": "111309424211255",
        //         "dataType": "V1TAAssetAccount",
        //         "data": {
        //             "updatedAtTimestamp": "1751989627509",
        //             "borrowedQuantity": "0.0000",
        //             "tradingAccountId": "111309424211255",
        //             "loanedQuantity": "0.0000",
        //             "lockedQuantity": "0.0000",
        //             "assetId": "5",
        //             "assetSymbol": "USDC",
        //             "publishedAtTimestamp": "1751989627512",
        //             "availableQuantity": "999672939.8767",
        //             "updatedAtDatetime": "2025-07-08T15:47:07.509Z"
        //         }
        //     }
        //
        object tradingAccountId = this.safeString(message, "tradingAccountId");
        if (!isTrue((inOp(this.balance, tradingAccountId))))
        {
            ((IDictionary<string,object>)this.balance)[(string)tradingAccountId] = new Dictionary<string, object>() {};
        }
        object messageType = this.safeString(message, "type");
        if (isTrue(isEqual(messageType, "snapshot")))
        {
            object data = this.safeList(message, "data", new List<object>() {});
            ((IDictionary<string,object>)this.balance)[(string)tradingAccountId] = this.parseBalance(data);
        } else
        {
            object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
            object assetId = this.safeString(data, "assetSymbol");
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(data, "availableQuantity");
            ((IDictionary<string,object>)account)["used"] = this.safeString(data, "lockedQuantity");
            object code = this.safeCurrencyCode(assetId);
            ((IDictionary<string,object>)getValue(this.balance, tradingAccountId))[(string)code] = account;
            ((IDictionary<string,object>)getValue(this.balance, tradingAccountId))["info"] = message;
            ((IDictionary<string,object>)this.balance)[(string)tradingAccountId] = this.safeBalance(getValue(this.balance, tradingAccountId));
        }
        object messageHash = "balance";
        object tradingAccountIdHash = add("::", tradingAccountId);
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, tradingAccountId), messageHash});
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, tradingAccountId), add(messageHash, tradingAccountIdHash)});
    }

    /**
     * @method
     * @name bullish#watchPositions
     * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--private-data-websocket-authenticated
     * @description watch all open positions
     * @param {string[]} [symbols] list of unified market symbols
     * @param {int} [since] the earliest time in ms to fetch positions for
     * @param {int} [limit] the maximum number of positions to retrieve
     * @param {object} params extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
     */
    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object subscribeHash = "positions";
        object messageHash = subscribeHash;
        if (!isTrue(this.isEmpty(symbols)))
        {
            symbols = this.marketSymbols(symbols);
            messageHash = add(messageHash, add("::", String.Join(",", ((IList<object>)symbols).ToArray())));
        }
        object request = new Dictionary<string, object>() {
            { "topic", "derivativesPositionsV2" },
        };
        object positions = await this.watchPrivate(messageHash, subscribeHash, request, parameters);
        if (isTrue(this.newUpdates))
        {
            return positions;
        }
        return this.filterBySymbolsSinceLimit(positions, symbols, since, limit, true);
    }

    public virtual void handlePositions(WebSocketClient client, object message)
    {
        // exchange does not return messages for sandbox mode
        // current method is implemented blindly
        // todo: check if this works with not-sandbox mode
        object messageType = this.safeString(message, "type");
        object rawPositions = new List<object>() {};
        if (isTrue(isEqual(messageType, "update")))
        {
            object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
            ((IList<object>)rawPositions).Add(data);
        } else
        {
            rawPositions = this.safeList(message, "data", new List<object>() {});
        }
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new ArrayCacheBySymbolBySide();
        }
        object positions = this.positions;
        object newPositions = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rawPositions)); postFixIncrement(ref i))
        {
            object rawPosition = getValue(rawPositions, i);
            object position = this.parsePosition(rawPosition);
            callDynamically(positions, "append", new object[] {position});
            ((IList<object>)newPositions).Add(position);
        }
        object messageHashes = this.findMessageHashes(client as WebSocketClient, "positions::");
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object symbolPositions = this.filterByArray(newPositions, "symbol", symbols, false);
            if (!isTrue(this.isEmpty(symbolPositions)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {symbolPositions, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {positions, "positions"});
    }

    public virtual void handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //     {
        //         "data": {
        //             "errorCode": 401,
        //             "errorCodeName": "UNAUTHORIZED",
        //             "message": "Unable to authenticate; JWT is missing/invalid or unauthorised to access account"
        //         },
        //         "dataType": "V1TAErrorResponse",
        //         "type": "error"
        //     }
        //
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object feedback = add(add(this.id, " "), this.json(data));
        try
        {
            object errorCode = this.safeString(data, "errorCode");
            object errorCodeName = this.safeString(data, "errorCodeName");
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), errorCodeName, feedback);
            throw new ExchangeError ((string)feedback) ;
        } catch(Exception e)
        {
            ((WebSocketClient)client).reject(e);
        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        object dataType = this.safeString(message, "dataType");
        object result = this.safeDict(message, "result");
        if (isTrue(!isEqual(result, null)))
        {
            object response = this.safeString(result, "message");
            if (isTrue(isEqual(response, "Keep alive pong")))
            {
                this.handlePong(client as WebSocketClient, message);
            }
        } else if (isTrue(!isEqual(dataType, null)))
        {
            if (isTrue(isEqual(dataType, "V1TAAnonymousTradeUpdate")))
            {
                this.handleTrades(client as WebSocketClient, message);
            }
            if (isTrue(isEqual(dataType, "V1TATickerResponse")))
            {
                this.handleTicker(client as WebSocketClient, message);
            }
            if (isTrue(isEqual(dataType, "V1TALevel2")))
            {
                this.handleOrderBook(client as WebSocketClient, message);
            }
            if (isTrue(isEqual(dataType, "V1TAOrder")))
            {
                this.handleOrders(client as WebSocketClient, message);
            }
            if (isTrue(isEqual(dataType, "V1TATrade")))
            {
                this.handleMyTrades(client as WebSocketClient, message);
            }
            if (isTrue(isEqual(dataType, "V1TAAssetAccount")))
            {
                this.handleBalance(client as WebSocketClient, message);
            }
            if (isTrue(isEqual(dataType, "V1TAErrorResponse")))
            {
                this.handleErrorMessage(client as WebSocketClient, message);
            }
        }
    }
}
