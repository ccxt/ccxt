namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class xt { public xt(object args = null) : base(args) { } }
public partial class xt : ccxt.xt
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchOHLCV", true },
                { "watchOrderBook", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", false },
                { "watchBalance", true },
                { "watchOrders", true },
                { "watchMyTrades", true },
                { "watchPositions", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "spot", "wss://stream.xt.com" },
                        { "contract", "wss://fstream.xt.com/ws" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "tradesLimit", 1000 },
                { "ordersLimit", 1000 },
                { "OHLCVLimit", 1000 },
                { "watchTicker", new Dictionary<string, object>() {
                    { "method", "ticker" },
                } },
                { "watchTickers", new Dictionary<string, object>() {
                    { "method", "tickers" },
                } },
                { "watchPositions", new Dictionary<string, object>() {
                    { "type", "swap" },
                    { "fetchPositionsSnapshot", true },
                    { "awaitPositionsSnapshot", true },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "keepAlive", 20000 },
                { "ping", this.ping },
            } },
            { "token", null },
        });
    }

    /**
     * @ignore
     * @method
     * @description required for private endpoints
     * @param {string} isContract true for contract trades
     * @see https://doc.xt.com/#websocket_privategetToken
     * @see https://doc.xt.com/#futures_user_websocket_v2base
     * @returns {string} listen key / access token
     */
    public async virtual Task<object> getListenKey(object isContract)
    {
        this.checkRequiredCredentials();
        object tradeType = ((bool) isTrue(isContract)) ? "contract" : "spot";
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), tradeType);
        if (!isTrue(isContract))
        {
            url = add(url, "/private");
        }
        var client = this.client(url);
        object token = this.safeString(((WebSocketClient)client).subscriptions, "token");
        if (isTrue(isEqual(token, null)))
        {
            if (isTrue(isContract))
            {
                object response = await this.privateLinearGetFutureUserV1UserListenKey();
                //
                //    {
                //        returnCode: '0',
                //        msgInfo: 'success',
                //        error: null,
                //        result: '3BC1D71D6CF96DA3458FC35B05B633351684511731128'
                //    }
                //
                ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)["token"] = this.safeString(response, "result");
            } else
            {
                object response = await this.privateSpotPostWsToken();
                //
                //    {
                //        "rc": 0,
                //        "mc": "SUCCESS",
                //        "ma": [],
                //        "result": {
                //            "token": "eyJhbqGciOiJSUzI1NiJ9.eyJhY2NvdW50SWQiOiIyMTQ2Mjg1MzIyNTU5Iiwic3ViIjoibGh4dDRfMDAwMUBzbmFwbWFpbC5jYyIsInNjb3BlIjoiYXV0aCIsImlzcyI6Inh0LmNvbSIsImxhc3RBdXRoVGltZSI6MTY2MzgxMzY5MDk1NSwic2lnblR5cGUiOiJBSyIsInVzZXJOYW1lIjoibGh4dDRfMDAwMUBzbmFwbWFpbC5jYyIsImV4cCI6MTY2NjQwNTY5MCwiZGV2aWNlIjoidW5rbm93biIsInVzZXJJZCI6MjE0NjI4NTMyMjU1OX0.h3zJlJBQrK2x1HvUxsKivnn6PlSrSDXXXJ7WqHAYSrN2CG5XPTKc4zKnTVoYFbg6fTS0u1fT8wH7wXqcLWXX71vm0YuP8PCvdPAkUIq4-HyzltbPr5uDYd0UByx0FPQtq1exvsQGe7evXQuDXx3SEJXxEqUbq_DNlXPTq_JyScI",
                //            "refreshToken": "eyJhbGciOiqJSUzI1NiJ9.eyJhY2NvdW50SWQiOiIyMTQ2Mjg1MzIyNTU5Iiwic3ViIjoibGh4dDRfMDAwMUBzbmFwbWFpbC5jYyIsInNjb3BlIjoicmVmcmVzaCIsImlzcyI6Inh0LmNvbSIsImxhc3RBdXRoVGltZSI6MTY2MzgxMzY5MDk1NSwic2lnblR5cGUiOiJBSyIsInVzZXJOYW1lIjoibGh4dDRfMDAwMUBzbmFwbWFpbC5jYyIsImV4cCI6MTY2NjQwNTY5MCwiZGV2aWNlIjoidW5rbm93biIsInVzZXJJZCI6MjE0NjI4NTMyMjU1OX0.Fs3YVm5YrEOzzYOSQYETSmt9iwxUHBovh2u73liv1hLUec683WGfktA_s28gMk4NCpZKFeQWFii623FvdfNoteXR0v1yZ2519uNvNndtuZICDdv3BQ4wzW1wIHZa1skxFfqvsDnGdXpjqu9UFSbtHwxprxeYfnxChNk4ssei430"
                //        }
                //    }
                //
                object result = this.safeDict(response, "result");
                ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)["token"] = this.safeString(result, "accessToken");
            }
        }
        return getValue(((WebSocketClient)client).subscriptions, "token");
    }

    public override object getCacheIndex(object orderbook, object cache)
    {
        // return the first index of the cache that can be applied to the orderbook or -1 if not possible
        object nonce = this.safeInteger(orderbook, "nonce");
        object firstDelta = this.safeValue(cache, 0);
        object firstDeltaNonce = this.safeInteger2(firstDelta, "i", "u");
        if (isTrue(isLessThan(nonce, subtract(firstDeltaNonce, 1))))
        {
            return -1;
        }
        for (object i = 0; isLessThan(i, getArrayLength(cache)); postFixIncrement(ref i))
        {
            object delta = getValue(cache, i);
            object deltaNonce = this.safeInteger2(delta, "i", "u");
            if (isTrue(isGreaterThanOrEqual(deltaNonce, nonce)))
            {
                return i;
            }
        }
        return getArrayLength(cache);
    }

    public override void handleDelta(object orderbook, object delta)
    {
        ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger2(delta, "i", "u");
        object obAsks = this.safeList(delta, "a", new List<object>() {});
        object obBids = this.safeList(delta, "b", new List<object>() {});
        object bids = getValue(orderbook, "bids");
        object asks = getValue(orderbook, "asks");
        for (object i = 0; isLessThan(i, getArrayLength(obBids)); postFixIncrement(ref i))
        {
            object bid = getValue(obBids, i);
            object price = this.safeNumber(bid, 0);
            object quantity = this.safeNumber(bid, 1);
            (bids as IOrderBookSide).store(price, quantity);
        }
        for (object i = 0; isLessThan(i, getArrayLength(obAsks)); postFixIncrement(ref i))
        {
            object ask = getValue(obAsks, i);
            object price = this.safeNumber(ask, 0);
            object quantity = this.safeNumber(ask, 1);
            (asks as IOrderBookSide).store(price, quantity);
        }
    }

    /**
     * @ignore
     * @method
     * @description Connects to a websocket channel
     * @see https://doc.xt.com/#websocket_privaterequestFormat
     * @see https://doc.xt.com/#futures_market_websocket_v2base
     * @param {string} name name of the channel
     * @param {string} access public or private
     * @param {string} methodName the name of the CCXT class method
     * @param {object} [market] CCXT market
     * @param {string[]} [symbols] unified market symbols
     * @param {object} params extra parameters specific to the xt api
     * @returns {object} data from the websocket stream
     */
    public async virtual Task<object> subscribe(object name, object access, object methodName, object market = null, object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object privateAccess = isEqual(access, "private");
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams(methodName, market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object isContract = (!isEqual(type, "spot"));
        object subscribe = new Dictionary<string, object>() {
            { "method", ((bool) isTrue(isContract)) ? "SUBSCRIBE" : "subscribe" },
            { "id", add(this.numberToString(this.milliseconds()), name) },
        };
        if (isTrue(privateAccess))
        {
            if (!isTrue(isContract))
            {
                ((IDictionary<string,object>)subscribe)["params"] = new List<object>() {name};
                ((IDictionary<string,object>)subscribe)["listenKey"] = await this.getListenKey(isContract);
            } else
            {
                object listenKey = await this.getListenKey(isContract);
                object param = add(add(name, "@"), listenKey);
                ((IDictionary<string,object>)subscribe)["params"] = new List<object>() {param};
            }
        } else
        {
            ((IDictionary<string,object>)subscribe)["params"] = new List<object>() {name};
        }
        object tradeType = ((bool) isTrue(isContract)) ? "contract" : "spot";
        object messageHash = add(add(name, "::"), tradeType);
        if (isTrue(!isEqual(symbols, null)))
        {
            messageHash = add(add(messageHash, "::"), String.Join(",", ((IList<object>)symbols).ToArray()));
        }
        object request = this.extend(subscribe, parameters);
        object tail = access;
        if (isTrue(isContract))
        {
            tail = ((bool) isTrue(privateAccess)) ? "user" : "market";
        }
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), tradeType), "/"), tail);
        return await this.watch(url, messageHash, request, messageHash);
    }

    /**
     * @method
     * @name xt#watchTicker
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://doc.xt.com/#websocket_publictickerRealTime
     * @see https://doc.xt.com/#futures_market_websocket_v2tickerRealTime
     * @see https://doc.xt.com/#futures_market_websocket_v2aggTickerRealTime
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} params extra parameters specific to the xt api endpoint
     * @param {string} [params.method] 'agg_ticker' (contract only) or 'ticker', default = 'ticker' - the endpoint that will be streamed
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object options = this.safeDict(this.options, "watchTicker");
        object defaultMethod = this.safeString(options, "method", "ticker");
        object method = this.safeString(parameters, "method", defaultMethod);
        object name = add(add(method, "@"), getValue(market, "id"));
        return await this.subscribe(name, "public", "watchTicker", market, null, parameters);
    }

    /**
     * @method
     * @name xt#watchTicker
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://doc.xt.com/#websocket_publicallTicker
     * @see https://doc.xt.com/#futures_market_websocket_v2allTicker
     * @see https://doc.xt.com/#futures_market_websocket_v2allAggTicker
     * @param {string} [symbols] unified market symbols
     * @param {object} params extra parameters specific to the xt api endpoint
     * @param {string} [params.method] 'agg_tickers' (contract only) or 'tickers', default = 'tickers' - the endpoint that will be streamed
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure}
     */
    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object options = this.safeDict(this.options, "watchTickers");
        object defaultMethod = this.safeString(options, "method", "tickers");
        object name = this.safeString(parameters, "method", defaultMethod);
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            market = this.market(getValue(symbols, 0));
        }
        object tickers = await this.subscribe(name, "public", "watchTickers", market, symbols, parameters);
        if (isTrue(this.newUpdates))
        {
            return tickers;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    /**
     * @method
     * @name hitbtc#watchOHLCV
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://doc.xt.com/#websocket_publicsymbolKline
     * @see https://doc.xt.com/#futures_market_websocket_v2symbolKline
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe 1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w, or 1M
     * @param {int} [since] not used by xt watchOHLCV
     * @param {int} [limit] not used by xt watchOHLCV
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object name = add(add(add("kline@", getValue(market, "id")), ","), timeframe);
        object ohlcv = await this.subscribe(name, "public", "watchOHLCV", market, null, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    /**
     * @method
     * @name xt#watchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://doc.xt.com/#websocket_publicdealRecord
     * @see https://doc.xt.com/#futures_market_websocket_v2dealRecord
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object name = add("trade@", getValue(market, "id"));
        object trades = await this.subscribe(name, "public", "watchTrades", market, null, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp");
    }

    /**
     * @method
     * @name xt#watchOrderBook
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://doc.xt.com/#websocket_publiclimitDepth
     * @see https://doc.xt.com/#websocket_publicincreDepth
     * @see https://doc.xt.com/#futures_market_websocket_v2limitDepth
     * @see https://doc.xt.com/#futures_market_websocket_v2increDepth
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] not used by xt watchOrderBook
     * @param {object} params extra parameters specific to the xt api endpoint
     * @param {int} [params.levels] 5, 10, 20, or 50
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object levels = this.safeString(parameters, "levels");
        parameters = this.omit(parameters, "levels");
        object name = add("depth_update@", getValue(market, "id"));
        if (isTrue(!isEqual(levels, null)))
        {
            name = add(add(add("depth@", getValue(market, "id")), ","), levels);
        }
        object orderbook = await this.subscribe(name, "public", "watchOrderBook", market, null, parameters);
        return (orderbook as IOrderBook).limit();
    }

    /**
     * @method
     * @name xt#watchOrders
     * @description watches information on multiple orders made by the user
     * @see https://doc.xt.com/#websocket_privateorderChange
     * @see https://doc.xt.com/#futures_user_websocket_v2order
     * @param {string} [symbol] unified market symbol
     * @param {int} [since] not used by xt watchOrders
     * @param {int} [limit] the maximum number of orders to return
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "order";
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object orders = await this.subscribe(name, "private", "watchOrders", market, null, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(orders, since, limit, "timestamp");
    }

    /**
     * @method
     * @name xt#watchMyTrades
     * @description watches information on multiple trades made by the user
     * @see https://doc.xt.com/#websocket_privateorderDeal
     * @see https://doc.xt.com/#futures_user_websocket_v2trade
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of  orde structures to retrieve
     * @param {object} params extra parameters specific to the kucoin api endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "trade";
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object trades = await this.subscribe(name, "private", "watchMyTrades", market, null, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp");
    }

    /**
     * @method
     * @name xt#watchOrders
     * @description watches information on multiple orders made by the user
     * @see https://doc.xt.com/#websocket_privatebalanceChange
     * @see https://doc.xt.com/#futures_user_websocket_v2balance
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object[]} a list of [balance structures]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "balance";
        return await this.subscribe(name, "private", "watchBalance", null, null, parameters);
    }

    /**
     * @method
     * @name xt#watchPositions
     * @see https://doc.xt.com/#futures_user_websocket_v2position
     * @description watch all open positions
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {number} [since] since timestamp
     * @param {number} [limit] limit
     * @param {object} params extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
     */
    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "contract"), "/"), "user");
        var client = this.client(url);
        this.setPositionsCache(client);
        object fetchPositionsSnapshot = this.handleOption("watchPositions", "fetchPositionsSnapshot", true);
        object awaitPositionsSnapshot = this.handleOption("watchPositions", "awaitPositionsSnapshot", true);
        object cache = this.positions;
        if (isTrue(isTrue(isTrue(fetchPositionsSnapshot) && isTrue(awaitPositionsSnapshot)) && isTrue(this.isEmpty(cache))))
        {
            object snapshot = await client.future("fetchPositionsSnapshot");
            return this.filterBySymbolsSinceLimit(snapshot, symbols, since, limit, true);
        }
        object name = "position";
        object newPositions = await this.subscribe(name, "private", "watchPositions", null, null, parameters);
        if (isTrue(this.newUpdates))
        {
            return newPositions;
        }
        return this.filterBySymbolsSinceLimit(cache, symbols, since, limit, true);
    }

    public virtual void setPositionsCache(WebSocketClient client)
    {
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new ArrayCacheBySymbolBySide();
        }
        object fetchPositionsSnapshot = this.handleOption("watchPositions", "fetchPositionsSnapshot");
        if (isTrue(fetchPositionsSnapshot))
        {
            object messageHash = "fetchPositionsSnapshot";
            if (!isTrue((inOp(client.futures, messageHash))))
            {
                client.future(messageHash);
                this.spawn(this.loadPositionsSnapshot, new object[] { client, messageHash});
            }
        }
    }

    public async virtual Task loadPositionsSnapshot(WebSocketClient client, object messageHash)
    {
        object positions = await this.fetchPositions(null);
        this.positions = new ArrayCacheBySymbolBySide();
        object cache = this.positions;
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object position = getValue(positions, i);
            object contracts = this.safeNumber(position, "contracts", 0);
            if (isTrue(isGreaterThan(contracts, 0)))
            {
                callDynamically(cache, "append", new object[] {position});
            }
        }
        // don't remove the future from the .futures cache
        var future = getValue(client.futures, messageHash);
        (future as Future).resolve(cache);
        callDynamically(client as WebSocketClient, "resolve", new object[] {cache, "position::contract"});
    }

    public virtual void handlePosition(WebSocketClient client, object message)
    {
        //
        //    {
        //      topic: 'position',
        //      event: 'position',
        //      data: {
        //        accountId: 245296,
        //        accountType: 0,
        //        symbol: 'eth_usdt',
        //        contractType: 'PERPETUAL',
        //        positionType: 'CROSSED',
        //        positionSide: 'LONG',
        //        positionSize: '1',
        //        closeOrderSize: '0',
        //        availableCloseSize: '1',
        //        realizedProfit: '-0.0121',
        //        entryPrice: '2637.87',
        //        openOrderSize: '1',
        //        isolatedMargin: '2.63787',
        //        openOrderMarginFrozen: '2.78832014',
        //        underlyingType: 'U_BASED',
        //        leverage: 10,
        //        welfareAccount: false,
        //        profitFixedLatest: {},
        //        closeProfit: '0.0000',
        //        totalFee: '-0.0158',
        //        totalFundFee: '0.0037',
        //        markPrice: '2690.96'
        //      }
        //    }
        //
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new ArrayCacheBySymbolBySide();
        }
        object cache = this.positions;
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object position = this.parsePosition(data);
        callDynamically(cache, "append", new object[] {position});
        object messageHashes = this.findMessageHashes(client as WebSocketClient, "position::contract");
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object positions = this.filterByArray(new List<object>() {position}, "symbol", symbols, false);
            if (!isTrue(this.isEmpty(positions)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {positions, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {new List<object>() {position}, "position::contract"});
    }

    public virtual object handleTicker(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //    {
        //        topic: 'ticker',
        //        event: 'ticker@btc_usdt',
        //        data: {
        //           s: 'btc_usdt',            // symbol
        //           t: 1683501935877,         // time(Last transaction time)
        //           cv: '-82.67',             // priceChangeValue(24 hour price change)
        //           cr: '-0.0028',            // priceChangeRate 24-hour price change (percentage)
        //           o: '28823.87',            // open price
        //           c: '28741.20',            // close price
        //           h: '29137.64',            // highest price
        //           l: '28660.93',            // lowest price
        //           q: '6372.601573',         // quantity
        //           v: '184086075.2772391'    // volume
        //        }
        //    }
        //
        // contract
        //
        //    {
        //        "topic": "ticker",
        //        "event": "ticker@btc_usdt",
        //        "data": {
        //            "s": "btc_index",  // trading pair
        //            "o": "49000",      // opening price
        //            "c": "50000",      // closing price
        //            "h": "0.1",        // highest price
        //            "l": "0.1",        // lowest price
        //            "a": "0.1",        // volume
        //            "v": "0.1",        // turnover
        //            "ch": "0.21",      // quote change
        //            "t": 123124124     // timestamp
        //       }
        //    }
        //
        // agg_ticker (contract)
        //
        //    {
        //        "topic": "agg_ticker",
        //        "event": "agg_ticker@btc_usdt",
        //        "data": {
        //            "s": "btc_index",          // trading pair
        //            "o": "49000",              // opening price
        //            "c": "50000",              // closing price
        //            "h": "0.1",                // highest price
        //            "l": "0.1",                // lowest price
        //            "a": "0.1",                // volume
        //            "v": "0.1",                // turnover
        //            "ch": "0.21",              // quote change
        //            "i": "0.21" ,              // index price
        //            "m": "0.21",               // mark price
        //            "bp": "0.21",              // bid price
        //            "ap": "0.21" ,             // ask price
        //            "t": 123124124             // timestamp
        //       }
        //    }
        //
        object data = this.safeDict(message, "data");
        object marketId = this.safeString(data, "s");
        if (isTrue(!isEqual(marketId, null)))
        {
            object cv = this.safeString(data, "cv");
            object isSpot = !isEqual(cv, null);
            object ticker = this.parseTicker(data);
            object symbol = getValue(ticker, "symbol");
            ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
            object eventVar = this.safeString(message, "event");
            object messageHashTail = ((bool) isTrue(isSpot)) ? "spot" : "contract";
            object messageHash = add(add(eventVar, "::"), messageHashTail);
            callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
        }
        return message;
    }

    public virtual object handleTickers(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //    {
        //        topic: 'tickers',
        //        event: 'tickers',
        //        data: [
        //            {
        //                s: 'elon_usdt',
        //                t: 1683502958381,
        //                cv: '-0.0000000125',
        //                cr: '-0.0495',
        //                o: '0.0000002522',
        //                c: '0.0000002397',
        //                h: '0.0000002690',
        //                l: '0.0000002371',
        //                q: '3803783034.0000000000',
        //                v: '955.3260820022'
        //            },
        //            ...
        //        ]
        //    }
        //
        // contract
        //
        //    {
        //        "topic": "tickers",
        //        "event": "tickers",
        //        "data": [
        //            {
        //                "s": "btc_index",  // trading pair
        //                "o": "49000",      // opening price
        //                "c": "50000",      // closing price
        //                "h": "0.1",        // highest price
        //                "l": "0.1",        // lowest price
        //                "a": "0.1",        // volume
        //                "v": "0.1",        // turnover
        //                "ch": "0.21",      // quote change
        //                "t": 123124124     // timestamp
        //            }
        //        ]
        //    }
        //
        // agg_ticker (contract)
        //
        //    {
        //        "topic": "agg_tickers",
        //        "event": "agg_tickers",
        //        "data": [
        //            {
        //                "s": "btc_index",          // trading pair
        //                "o": "49000",              // opening price
        //                "c": "50000",              // closing price
        //                "h": "0.1",                // highest price
        //                "l": "0.1",                // lowest price
        //                "a": "0.1",                // volume
        //                "v": "0.1",                // turnover
        //                "ch": "0.21",              // quote change
        //                "i": "0.21" ,              // index price
        //                "m": "0.21",               // mark price
        //                "bp": "0.21",              // bid price
        //                "ap": "0.21" ,             // ask price
        //                "t": 123124124             // timestamp
        //            }
        //        ]
        //    }
        //
        object data = this.safeList(message, "data", new List<object>() {});
        object firstTicker = this.safeDict(data, 0);
        object spotTest = this.safeString2(firstTicker, "cv", "aq");
        object tradeType = ((bool) isTrue((!isEqual(spotTest, null)))) ? "spot" : "contract";
        object newTickers = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object tickerData = getValue(data, i);
            object ticker = this.parseTicker(tickerData);
            object symbol = getValue(ticker, "symbol");
            ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
            ((IList<object>)newTickers).Add(ticker);
        }
        object messageHashStart = add(add(this.safeString(message, "topic"), "::"), tradeType);
        object messageHashes = this.findMessageHashes(client as WebSocketClient, add(messageHashStart, "::"));
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 2);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object tickers = this.filterByArray(newTickers, "symbol", symbols);
            object tickersSymbols = new List<object>(((IDictionary<string,object>)tickers).Keys);
            object numTickers = getArrayLength(tickersSymbols);
            if (isTrue(isGreaterThan(numTickers, 0)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {tickers, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.tickers, messageHashStart});
        return message;
    }

    public virtual object handleOHLCV(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //    {
        //        "topic": "kline",
        //        "event": "kline@btc_usdt,5m",
        //        "data": {
        //            "s": "btc_usdt",        // symbol
        //            "t": 1656043200000,     // time
        //            "i": "5m",              // interval
        //            "o": "44000",           // open price
        //            "c": "50000",           // close price
        //            "h": "52000",           // highest price
        //            "l": "36000",           // lowest price
        //            "q": "34.2",            // qty(quantity)
        //            "v": "230000"           // volume
        //        }
        //    }
        //
        // contract
        //
        //    {
        //        "topic": "kline",
        //        "event": "kline@btc_usdt,5m",
        //        "data": {
        //            "s": "btc_index",      // trading pair
        //            "o": "49000",          // opening price
        //            "c": "50000",          // closing price
        //            "h": "0.1",            // highest price
        //            "l": "0.1",            // lowest price
        //            "a": "0.1",            // volume
        //            "v": "0.1",            // turnover
        //            "ch": "0.21",          // quote change
        //            "t": 123124124         // timestamp
        //        }
        //    }
        //
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "s");
        if (isTrue(!isEqual(marketId, null)))
        {
            object timeframe = this.safeString(data, "i");
            object tradeType = ((bool) isTrue((inOp(data, "q")))) ? "spot" : "contract";
            object market = this.safeMarket(marketId, null, null, tradeType);
            object symbol = getValue(market, "symbol");
            object parsed = this.parseOHLCV(data, market);
            ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeDict(this.ohlcvs, symbol, new Dictionary<string, object>() {});
            object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
            if (isTrue(isEqual(stored, null)))
            {
                object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
                stored = new ArrayCacheByTimestamp(limit);
                ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
            }
            callDynamically(stored, "append", new object[] {parsed});
            object eventVar = this.safeString(message, "event");
            object messageHash = add(add(eventVar, "::"), tradeType);
            callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        }
        return message;
    }

    public virtual object handleTrade(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //    {
        //        topic: 'trade',
        //        event: 'trade@btc_usdt',
        //        data: {
        //            s: 'btc_usdt',
        //            i: '228825383103928709',
        //            t: 1684258222702,
        //            p: '27003.65',
        //            q: '0.000796',
        //            b: true
        //        }
        //    }
        //
        // contract
        //
        //    {
        //        "topic": "trade",
        //        "event": "trade@btc_usdt",
        //        "data": {
        //            "s": "btc_index",  // trading pair
        //            "p": "50000",      // price
        //            "a": "0.1"         // Quantity
        //            "m": "BID"         // Deal side  BID:Buy ASK:Sell
        //            "t": 123124124     // timestamp
        //        }
        //    }
        //
        object data = this.safeDict(message, "data");
        object marketId = this.safeStringLower(data, "s");
        if (isTrue(!isEqual(marketId, null)))
        {
            object trade = this.parseTrade(data);
            object i = this.safeString(data, "i");
            object tradeType = ((bool) isTrue((!isEqual(i, null)))) ? "spot" : "contract";
            object market = this.safeMarket(marketId, null, null, tradeType);
            object symbol = getValue(market, "symbol");
            object eventVar = this.safeString(message, "event");
            object tradesArray = this.safeValue(this.trades, symbol);
            if (isTrue(isEqual(tradesArray, null)))
            {
                object tradesLimit = this.safeInteger(this.options, "tradesLimit", 1000);
                tradesArray = new ArrayCache(tradesLimit);
                ((IDictionary<string,object>)this.trades)[(string)symbol] = tradesArray;
            }
            callDynamically(tradesArray, "append", new object[] {trade});
            object messageHash = add(add(eventVar, "::"), tradeType);
            callDynamically(client as WebSocketClient, "resolve", new object[] {tradesArray, messageHash});
        }
        return message;
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //    {
        //        "topic": "depth",
        //        "event": "depth@btc_usdt,20",
        //        "data": {
        //            "s": "btc_usdt",        // symbol
        //            "fi": 1681433733351,    // firstUpdateId = previous lastUpdateId + 1
        //            "i": 1681433733371,     // updateId
        //            "a": [                  // asks(sell order)
        //                [                   // [0]price, [1]quantity
        //                    "34000",        // price
        //                    "1.2"           // quantity
        //                ],
        //                [
        //                    "34001",
        //                    "2.3"
        //                ]
        //            ],
        //            "b": [                   // bids(buy order)
        //                [
        //                    "32000",
        //                    "0.2"
        //                ],
        //                [
        //                    "31000",
        //                    "0.5"
        //                ]
        //            ]
        //        }
        //    }
        //
        // contract
        //
        //    {
        //        "topic": "depth",
        //        "event": "depth@btc_usdt,20",
        //        "data": {
        //            s: "btc_usdt",
        //            pu: "548111455664",
        //            fu: "548111455665",
        //            u: "548111455667",
        //            a: [
        //                [
        //                    "26841.5",
        //                    "50210",
        //                ],
        //            ],
        //            b: [
        //                [
        //                    "26841",
        //                    "67075",
        //                ],
        //            ],
        //            t: 1684530667083,
        //        }
        //    }
        //
        object data = this.safeDict(message, "data");
        object marketId = this.safeString(data, "s");
        if (isTrue(!isEqual(marketId, null)))
        {
            object eventVar = this.safeString(message, "event");
            object splitEvent = ((string)eventVar).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            eventVar = this.safeString(splitEvent, 0);
            object tradeType = ((bool) isTrue((inOp(data, "fu")))) ? "contract" : "spot";
            object market = this.safeMarket(marketId, null, null, tradeType);
            object symbol = getValue(market, "symbol");
            object obAsks = this.safeList(data, "a");
            object obBids = this.safeList(data, "b");
            object messageHash = add(add(eventVar, "::"), tradeType);
            if (!isTrue((inOp(this.orderbooks, symbol))))
            {
                object subscription = this.safeDict(((WebSocketClient)client).subscriptions, messageHash, new Dictionary<string, object>() {});
                object limit = this.safeInteger(subscription, "limit");
                ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
            }
            object orderbook = getValue(this.orderbooks, symbol);
            object nonce = this.safeInteger(orderbook, "nonce");
            if (isTrue(isEqual(nonce, null)))
            {
                object cacheLength = getArrayLength((orderbook as ccxt.pro.OrderBook).cache);
                object snapshotDelay = this.handleOption("watchOrderBook", "snapshotDelay", 25);
                if (isTrue(isEqual(cacheLength, snapshotDelay)))
                {
                    this.spawn(this.loadOrderBook, new object[] { client, messageHash, symbol});
                }
                ((IList<object>)(orderbook as ccxt.pro.OrderBook).cache).Add(data);
                return;
            }
            if (isTrue(!isEqual(obAsks, null)))
            {
                object asks = getValue(orderbook, "asks");
                for (object i = 0; isLessThan(i, getArrayLength(obAsks)); postFixIncrement(ref i))
                {
                    object ask = getValue(obAsks, i);
                    object price = this.safeNumber(ask, 0);
                    object quantity = this.safeNumber(ask, 1);
                    (asks as IOrderBookSide).store(price, quantity);
                }
            }
            if (isTrue(!isEqual(obBids, null)))
            {
                object bids = getValue(orderbook, "bids");
                for (object i = 0; isLessThan(i, getArrayLength(obBids)); postFixIncrement(ref i))
                {
                    object bid = getValue(obBids, i);
                    object price = this.safeNumber(bid, 0);
                    object quantity = this.safeNumber(bid, 1);
                    (bids as IOrderBookSide).store(price, quantity);
                }
            }
            object timestamp = this.safeInteger(data, "t");
            ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger2(data, "i", "u");
            ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
            ((IDictionary<string,object>)orderbook)["symbol"] = symbol;
            callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
        }
    }

    public override object parseWsOrderTrade(object trade, object market = null)
    {
        //
        //    {
        //        "s": "btc_usdt",                         // symbol
        //        "t": 1656043204763,                      // time happened time
        //        "i": "6216559590087220004",              // orderId,
        //        "ci": "test123",                         // clientOrderId
        //        "st": "PARTIALLY_FILLED",                // state
        //        "sd": "BUY",                             // side BUY/SELL
        //        "eq": "2",                               // executedQty executed quantity
        //        "ap": "30000",                           // avg price
        //        "f": "0.002"                             // fee
        //    }
        //
        // contract
        //
        //    {
        //        "symbol": "btc_usdt",                    // Trading pair
        //        "orderId": "1234",                       // Order Id
        //        "origQty": "34244",                      // Original Quantity
        //        "avgPrice": "123",                       // Quantity
        //        "price": "1111",                         // Average price
        //        "executedQty": "34244",                  // Volume (Cont)
        //        "orderSide": "BUY",                      // BUY, SELL
        //        "positionSide": "LONG",                  // LONG, SHORT
        //        "marginFrozen": "123",                   // Occupied margin
        //        "sourceType": "default",                 // DEFAULT:normal order,ENTRUST:plan commission,PROFIR:Take Profit and Stop Loss
        //        "sourceId" : "1231231",                  // Triggering conditions ID
        //        "state": "",                             // state:NEW：New order (unfilled);PARTIALLY_FILLED:Partial deal;PARTIALLY_CANCELED:Partial revocation;FILLED:Filled;CANCELED:Cancled;REJECTED:Order failed;EXPIRED：Expired
        //        "createTime": 1731231231,                // CreateTime
        //        "clientOrderId": "204788317630342726"
        //    }
        //
        object marketId = this.safeString(trade, "s");
        object tradeType = ((bool) isTrue((inOp(trade, "symbol")))) ? "contract" : "spot";
        market = this.safeMarket(marketId, market, null, tradeType);
        object timestamp = this.safeString(trade, "t");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "order", this.safeString(trade, "i", "orderId") },
            { "type", this.parseOrderStatus(this.safeString(trade, "st", "state")) },
            { "side", this.safeStringLower(trade, "sd", "orderSide") },
            { "takerOrMaker", null },
            { "price", this.safeNumber(trade, "price") },
            { "amount", this.safeString(trade, "origQty") },
            { "cost", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", null },
                { "cost", this.safeNumber(trade, "f") },
                { "rate", null },
            } },
        }, market);
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        // spot
        //
        //    {
        //        "s": "btc_usdt",                // symbol
        //        "bc": "btc",                    // base currency
        //        "qc": "usdt",                   // quotation currency
        //        "t": 1656043204763,             // happened time
        //        "ct": 1656043204663,            // create time
        //        "i": "6216559590087220004",     // order id,
        //        "ci": "test123",                // client order id
        //        "st": "PARTIALLY_FILLED",       // state NEW/PARTIALLY_FILLED/FILLED/CANCELED/REJECTED/EXPIRED
        //        "sd": "BUY",                    // side BUY/SELL
        //        "tp": "LIMIT",                  // type LIMIT/MARKET
        //        "oq":  "4"                      // original quantity
        //        "oqq":  48000,                  // original quotation quantity
        //        "eq": "2",                      // executed quantity
        //        "lq": "2",                      // remaining quantity
        //        "p": "4000",                    // price
        //        "ap": "30000",                  // avg price
        //        "f":"0.002"                     // fee
        //    }
        //
        // contract
        //
        //    {
        //        "symbol": "btc_usdt",                    // Trading pair
        //        "orderId": "1234",                       // Order Id
        //        "origQty": "34244",                      // Original Quantity
        //        "avgPrice": "123",                       // Quantity
        //        "price": "1111",                         // Average price
        //        "executedQty": "34244",                  // Volume (Cont)
        //        "orderSide": "BUY",                      // BUY, SELL
        //        "positionSide": "LONG",                  // LONG, SHORT
        //        "marginFrozen": "123",                   // Occupied margin
        //        "sourceType": "default",                 // DEFAULT:normal order,ENTRUST:plan commission,PROFIR:Take Profit and Stop Loss
        //        "sourceId" : "1231231",                  // Triggering conditions ID
        //        "state": "",                             // state:NEW：New order (unfilled);PARTIALLY_FILLED:Partial deal;PARTIALLY_CANCELED:Partial revocation;FILLED:Filled;CANCELED:Cancled;REJECTED:Order failed;EXPIRED：Expired
        //        "createTime": 1731231231,                // CreateTime
        //        "clientOrderId": "204788317630342726"
        //    }
        //
        object marketId = this.safeString2(order, "s", "symbol");
        object tradeType = ((bool) isTrue((inOp(order, "symbol")))) ? "contract" : "spot";
        market = this.safeMarket(marketId, market, null, tradeType);
        object timestamp = this.safeInteger2(order, "ct", "createTime");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString2(order, "i", "orderId") },
            { "clientOrderId", this.safeString2(order, "ci", "clientOrderId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", getValue(market, "symbol") },
            { "type", getValue(market, "type") },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", this.safeStringLower2(order, "sd", "orderSide") },
            { "price", this.safeNumber2(order, "p", "price") },
            { "stopPrice", null },
            { "stopLoss", null },
            { "takeProfit", null },
            { "amount", this.safeString2(order, "oq", "origQty") },
            { "filled", this.safeString2(order, "eq", "executedQty") },
            { "remaining", this.safeString(order, "lq") },
            { "cost", null },
            { "average", this.safeString2(order, "ap", "avgPrice") },
            { "status", this.parseOrderStatus(this.safeString(order, "st", "state")) },
            { "fee", new Dictionary<string, object>() {
                { "currency", null },
                { "cost", this.safeNumber(order, "f") },
            } },
            { "trades", null },
        }, market);
    }

    public virtual object handleOrder(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //    {
        //        "topic": "order",
        //        "event": "order",
        //        "data": {
        //            "s": "btc_usdt",                // symbol
        //            "t": 1656043204763,             // time happened time
        //            "i": "6216559590087220004",     // orderId,
        //            "ci": "test123",                // clientOrderId
        //            "st": "PARTIALLY_FILLED",       // state
        //            "sd": "BUY",                    // side BUY/SELL
        //            "eq": "2",                      // executedQty executed quantity
        //            "ap": "30000",                  // avg price
        //            "f": "0.002"                    // fee
        //        }
        //    }
        //
        // contract
        //
        //    {
        //        "topic": "order",
        //        "event": "order@123456",
        //        "data": {
        //             "symbol": "btc_usdt",                    // Trading pair
        //             "orderId": "1234",                       // Order Id
        //             "origQty": "34244",                      // Original Quantity
        //             "avgPrice": "123",                       // Quantity
        //             "price": "1111",                         // Average price
        //             "executedQty": "34244",                  // Volume (Cont)
        //             "orderSide": "BUY",                      // BUY, SELL
        //             "positionSide": "LONG",                  // LONG, SHORT
        //             "marginFrozen": "123",                   // Occupied margin
        //             "sourceType": "default",                 // DEFAULT:normal order,ENTRUST:plan commission,PROFIR:Take Profit and Stop Loss
        //             "sourceId" : "1231231",                  // Triggering conditions ID
        //             "state": "",                             // state:NEW：New order (unfilled);PARTIALLY_FILLED:Partial deal;PARTIALLY_CANCELED:Partial revocation;FILLED:Filled;CANCELED:Cancled;REJECTED:Order failed;EXPIRED：Expired
        //             "createTime": 1731231231,                // CreateTime
        //             "clientOrderId": "204788317630342726"
        //           }
        //    }
        //
        object orders = this.orders;
        if (isTrue(isEqual(orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit");
            orders = new ArrayCacheBySymbolById(limit);
            this.orders = orders;
        }
        object order = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString2(order, "s", "symbol");
        if (isTrue(!isEqual(marketId, null)))
        {
            object tradeType = ((bool) isTrue((inOp(order, "symbol")))) ? "contract" : "spot";
            object market = this.safeMarket(marketId, null, null, tradeType);
            object parsed = this.parseWsOrder(order, market);
            callDynamically(orders, "append", new object[] {parsed});
            callDynamically(client as WebSocketClient, "resolve", new object[] {orders, add("order::", tradeType)});
        }
        return message;
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //    {
        //        topic: 'balance',
        //        event: 'balance',
        //        data: {
        //            a: 3513677381884,
        //            t: 1684250056775,
        //            c: 'usdt',
        //            b: '7.71000000',
        //            f: '0.00000000',
        //            z: 'SPOT'
        //        }
        //    }
        //
        // contract
        //
        //    {
        //        "topic": "balance",
        //        "event": "balance@123456",
        //        "data": {
        //            "coin": "usdt",
        //            "underlyingType": 1,                          // 1:Coin-M,2:USDT-M
        //            "walletBalance": "123",                       // Balance
        //            "openOrderMarginFrozen": "123",               // Frozen order
        //            "isolatedMargin": "213",                      // Isolated Margin
        //            "crossedMargin": "0"                          // Crossed Margin
        //            "availableBalance": '2.256114450000000000',
        //            "coupon": '0',
        //            "bonus": '0'
        //        }
        //    }
        //
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object currencyId = this.safeString2(data, "c", "coin");
        object code = this.safeCurrencyCode(currencyId);
        object account = this.account();
        ((IDictionary<string,object>)account)["free"] = this.safeString(data, "availableBalance");
        ((IDictionary<string,object>)account)["used"] = this.safeString(data, "f");
        ((IDictionary<string,object>)account)["total"] = this.safeString2(data, "b", "walletBalance");
        ((IDictionary<string,object>)this.balance)[(string)code] = account;
        this.balance = this.safeBalance(this.balance);
        object tradeType = ((bool) isTrue((inOp(data, "coin")))) ? "contract" : "spot";
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, add("balance::", tradeType)});
    }

    public virtual void handleMyTrades(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //    {
        //        "topic": "trade",
        //        "event": "trade",
        //        "data": {
        //            "s": "btc_usdt",                // symbol
        //            "t": 1656043204763,             // time
        //            "i": "6316559590087251233",     // tradeId
        //            "oi": "6216559590087220004",    // orderId
        //            "p": "30000",                   // trade price
        //            "q": "3",                       // qty quantity
        //            "v": "90000"                    // volume trade amount
        //        }
        //    }
        //
        // contract
        //
        //    {
        //       "topic": "trade",
        //       "event": "trade@123456",
        //       "data": {
        //            "symbol": 'btc_usdt',
        //            "orderSide": 'SELL',
        //            "positionSide": 'LONG',
        //            "orderId": '231485367663419328',
        //            "price": '27152.7',
        //            "quantity": '33',
        //            "marginUnfrozen": '2.85318000',
        //            "timestamp": 1684892412565
        //        }
        //    }
        //
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object stored = this.myTrades;
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCacheBySymbolById(limit);
            this.myTrades = stored;
        }
        object parsedTrade = this.parseTrade(data);
        object market = this.market(getValue(parsedTrade, "symbol"));
        callDynamically(stored, "append", new object[] {parsedTrade});
        object tradeType = ((bool) isTrue(getValue(market, "contract"))) ? "contract" : "spot";
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, add("trade::", tradeType)});
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        object eventVar = this.safeString(message, "event");
        if (isTrue(isEqual(eventVar, "pong")))
        {
            client.onPong();
        } else if (isTrue(!isEqual(eventVar, null)))
        {
            object topic = this.safeString(message, "topic");
            object methods = new Dictionary<string, object>() {
                { "kline", this.handleOHLCV },
                { "depth", this.handleOrderBook },
                { "depth_update", this.handleOrderBook },
                { "ticker", this.handleTicker },
                { "agg_ticker", this.handleTicker },
                { "tickers", this.handleTickers },
                { "agg_tickers", this.handleTickers },
                { "balance", this.handleBalance },
                { "order", this.handleOrder },
                { "position", this.handlePosition },
            };
            object method = this.safeValue(methods, topic);
            if (isTrue(isEqual(topic, "trade")))
            {
                object data = this.safeDict(message, "data");
                if (isTrue(isTrue((inOp(data, "oi"))) || isTrue((inOp(data, "orderId")))))
                {
                    method = this.handleMyTrades;
                } else
                {
                    method = this.handleTrade;
                }
            }
            if (isTrue(!isEqual(method, null)))
            {
                DynamicInvoker.InvokeMethod(method, new object[] { client, message});
            }
        }
    }

    public override object ping(WebSocketClient client)
    {
        client.lastPong = this.milliseconds();
        return "ping";
    }

    public virtual void handleErrorMessage(WebSocketClient client, object message)
    {
        //
        //    {
        //        "id": "123",
        //        "code": 401,
        //        "msg": "token expire"
        //    }
        //
        object msg = this.safeString(message, "msg");
        if (isTrue(isTrue((isEqual(msg, "invalid_listen_key"))) || isTrue((isEqual(msg, "token expire")))))
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)["token"] = null;
            this.getListenKey(true);
            return;
        }
        ((WebSocketClient)client).reject(message);
    }
}
