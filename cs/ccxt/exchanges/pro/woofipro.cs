namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class woofipro { public woofipro(object args = null) : base(args) { } }
public partial class woofipro : ccxt.woofipro
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchBalance", true },
                { "watchMyTrades", true },
                { "watchOHLCV", true },
                { "watchOrderBook", true },
                { "watchOrders", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchBidsAsks", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", false },
                { "watchPositions", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://ws-evm.orderly.org/ws/stream" },
                        { "private", "wss://ws-private-evm.orderly.org/v2/ws/private/stream" },
                    } },
                } },
                { "test", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://testnet-ws-evm.orderly.org/ws/stream" },
                        { "private", "wss://testnet-ws-private-evm.orderly.org/v2/ws/private/stream" },
                    } },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "accountId", true },
            } },
            { "options", new Dictionary<string, object>() {
                { "tradesLimit", 1000 },
                { "ordersLimit", 1000 },
                { "requestId", new Dictionary<string, object>() {} },
                { "watchPositions", new Dictionary<string, object>() {
                    { "fetchPositionsSnapshot", true },
                    { "awaitPositionsSnapshot", true },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "ping", this.ping },
                { "keepAlive", 10000 },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "ws", new Dictionary<string, object>() {
                    { "exact", new Dictionary<string, object>() {
                        { "Auth is needed.", typeof(AuthenticationError) },
                    } },
                } },
            } },
        });
    }

    public virtual object requestId(object url)
    {
        object options = this.safeDict(this.options, "requestId", new Dictionary<string, object>() {});
        object previousValue = this.safeInteger(options, url, 0);
        object newValue = this.sum(previousValue, 1);
        ((IDictionary<string,object>)getValue(this.options, "requestId"))[(string)url] = newValue;
        return newValue;
    }

    public async virtual Task<object> watchPublic(object messageHash, object message)
    {
        // the default id
        object id = "OqdphuyCtYWxwzhxyLLjOWNdFP7sQt8RPWzmb5xY";
        if (isTrue(!isEqual(this.accountId, null)))
        {
            id = this.accountId;
        }
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "public"), "/"), id);
        object requestId = this.requestId(url);
        object subscribe = new Dictionary<string, object>() {
            { "id", requestId },
        };
        object request = this.extend(subscribe, message);
        return await this.watch(url, messageHash, request, messageHash, subscribe);
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#watchOrderBook
        * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/public/orderbook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return.
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "orderbook";
        object market = this.market(symbol);
        object topic = add(add(getValue(market, "id"), "@"), name);
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "topic", topic },
        };
        object message = this.extend(request, parameters);
        object orderbook = await this.watchPublic(topic, message);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        //     {
        //         "topic": "PERP_BTC_USDC@orderbook",
        //         "ts": 1650121915308,
        //         "data": {
        //             "symbol": "PERP_BTC_USDC",
        //             "bids": [
        //                 [
        //                     0.30891,
        //                     2469.98
        //                 ]
        //             ],
        //             "asks": [
        //                 [
        //                     0.31075,
        //                     2379.63
        //                 ]
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "symbol");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object topic = this.safeString(message, "topic");
        if (!isTrue((inOp(this.orderbooks, symbol))))
        {
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook();
        }
        object orderbook = getValue(this.orderbooks, symbol);
        object timestamp = this.safeInteger(message, "ts");
        object snapshot = this.parseOrderBook(data, symbol, timestamp, "bids", "asks");
        (orderbook as IOrderBook).reset(snapshot);
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, topic});
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#watchTicker
        * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/public/24-hour-ticker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object name = "ticker";
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object topic = add(add(getValue(market, "id"), "@"), name);
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "topic", topic },
        };
        object message = this.extend(request, parameters);
        return await this.watchPublic(topic, message);
    }

    public virtual object parseWsTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "symbol": "PERP_BTC_USDC",
        //         "open": 19441.5,
        //         "close": 20147.07,
        //         "high": 20761.87,
        //         "low": 19320.54,
        //         "volume": 2481.103,
        //         "amount": 50037935.0286,
        //         "count": 3689
        //     }
        //
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(null, market) },
            { "timestamp", null },
            { "datetime", null },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", null },
            { "bidVolume", null },
            { "ask", null },
            { "askVolume", null },
            { "vwap", null },
            { "open", this.safeString(ticker, "open") },
            { "close", this.safeString(ticker, "close") },
            { "last", null },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "volume") },
            { "quoteVolume", this.safeString(ticker, "amount") },
            { "info", ticker },
        }, market);
    }

    public virtual object handleTicker(WebSocketClient client, object message)
    {
        //
        //     {
        //         "topic": "PERP_BTC_USDC@ticker",
        //         "ts": 1657120017000,
        //         "data": {
        //             "symbol": "PERP_BTC_USDC",
        //             "open": 19441.5,
        //             "close": 20147.07,
        //             "high": 20761.87,
        //             "low": 19320.54,
        //             "volume": 2481.103,
        //             "amount": 50037935.0286,
        //             "count": 3689
        //         }
        //     }
        //
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object topic = this.safeString(message, "topic");
        object marketId = this.safeString(data, "symbol");
        object market = this.safeMarket(marketId);
        object timestamp = this.safeInteger(message, "ts");
        ((IDictionary<string,object>)data)["date"] = timestamp;
        object ticker = this.parseWsTicker(data, market);
        ((IDictionary<string,object>)ticker)["symbol"] = getValue(market, "symbol");
        ((IDictionary<string,object>)this.tickers)[(string)getValue(market, "symbol")] = ticker;
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, topic});
        return message;
    }

    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#watchTickers
        * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/public/24-hour-tickers
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
        * @param {string[]} symbols unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object name = "tickers";
        object topic = name;
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "topic", topic },
        };
        object message = this.extend(request, parameters);
        object tickers = await this.watchPublic(topic, message);
        return this.filterByArray(tickers, "symbol", symbols);
    }

    public virtual void handleTickers(WebSocketClient client, object message)
    {
        //
        //     {
        //         "topic":"tickers",
        //         "ts":1618820615000,
        //         "data":[
        //             {
        //                 "symbol":"PERP_NEAR_USDC",
        //                 "open":16.297,
        //                 "close":17.183,
        //                 "high":24.707,
        //                 "low":11.997,
        //                 "volume":0,
        //                 "amount":0,
        //                 "count":0
        //             },
        //         ...
        //         ]
        //     }
        //
        object topic = this.safeString(message, "topic");
        object data = this.safeList(message, "data", new List<object>() {});
        object timestamp = this.safeInteger(message, "ts");
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object marketId = this.safeString(getValue(data, i), "symbol");
            object market = this.safeMarket(marketId);
            object ticker = this.parseWsTicker(this.extend(getValue(data, i), new Dictionary<string, object>() {
                { "date", timestamp },
            }), market);
            ((IDictionary<string,object>)this.tickers)[(string)getValue(market, "symbol")] = ticker;
            ((IList<object>)result).Add(ticker);
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {result, topic});
    }

    public async override Task<object> watchBidsAsks(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#watchBidsAsks
        * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/public/bbos
        * @description watches best bid & ask for symbols
        * @param {string[]} symbols unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object name = "bbos";
        object topic = name;
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "topic", topic },
        };
        object message = this.extend(request, parameters);
        object tickers = await this.watchPublic(topic, message);
        return this.filterByArray(tickers, "symbol", symbols);
    }

    public virtual void handleBidAsk(WebSocketClient client, object message)
    {
        //
        //     {
        //       "topic": "bbos",
        //       "ts": 1726212495000,
        //       "data": [
        //         {
        //           "symbol": "PERP_WOO_USDC",
        //           "ask": 0.16570,
        //           "askSize": 4224,
        //           "bid": 0.16553,
        //           "bidSize": 6645
        //         }
        //       ]
        //     }
        //
        object topic = this.safeString(message, "topic");
        object data = this.safeList(message, "data", new List<object>() {});
        object timestamp = this.safeInteger(message, "ts");
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object ticker = this.parseWsBidAsk(this.extend(getValue(data, i), new Dictionary<string, object>() {
                { "ts", timestamp },
            }));
            ((IDictionary<string,object>)this.tickers)[(string)getValue(ticker, "symbol")] = ticker;
            ((IList<object>)result).Add(ticker);
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {result, topic});
    }

    public virtual object parseWsBidAsk(object ticker, object market = null)
    {
        object marketId = this.safeString(ticker, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeString(market, "symbol");
        object timestamp = this.safeInteger(ticker, "ts");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "ask", this.safeString(ticker, "ask") },
            { "askVolume", this.safeString(ticker, "askSize") },
            { "bid", this.safeString(ticker, "bid") },
            { "bidVolume", this.safeString(ticker, "bidSize") },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#watchOHLCV
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/public/k-line
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isTrue(isTrue(isTrue(isTrue(isTrue(isTrue(isTrue((!isEqual(timeframe, "1m"))) && isTrue((!isEqual(timeframe, "5m")))) && isTrue((!isEqual(timeframe, "15m")))) && isTrue((!isEqual(timeframe, "30m")))) && isTrue((!isEqual(timeframe, "1h")))) && isTrue((!isEqual(timeframe, "1d")))) && isTrue((!isEqual(timeframe, "1w")))) && isTrue((!isEqual(timeframe, "1M")))))
        {
            throw new NotSupported ((string)add(this.id, " watchOHLCV timeframe argument must be 1m, 5m, 15m, 30m, 1h, 1d, 1w, 1M")) ;
        }
        object market = this.market(symbol);
        object interval = this.safeString(this.timeframes, timeframe, timeframe);
        object name = "kline";
        object topic = add(add(add(add(getValue(market, "id"), "@"), name), "_"), interval);
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "topic", topic },
        };
        object message = this.extend(request, parameters);
        object ohlcv = await this.watchPublic(topic, message);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {getValue(market, "symbol"), limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "topic":"PERP_BTC_USDC@kline_1m",
        //         "ts":1618822432146,
        //         "data":{
        //             "symbol":"PERP_BTC_USDC",
        //             "type":"1m",
        //             "open":56948.97,
        //             "close":56891.76,
        //             "high":56948.97,
        //             "low":56889.06,
        //             "volume":44.00947568,
        //             "amount":2504584.9,
        //             "startTime":1618822380000,
        //             "endTime":1618822440000
        //         }
        //     }
        //
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object topic = this.safeString(message, "topic");
        object marketId = this.safeString(data, "symbol");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object interval = this.safeString(data, "type");
        object timeframe = this.findTimeframe(interval);
        object parsed = new List<object> {this.safeInteger(data, "startTime"), this.safeNumber(data, "open"), this.safeNumber(data, "high"), this.safeNumber(data, "low"), this.safeNumber(data, "close"), this.safeNumber(data, "volume")};
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
        }
        object ohlcvCache = getValue(getValue(this.ohlcvs, symbol), timeframe);
        callDynamically(ohlcvCache, "append", new object[] {parsed});
        callDynamically(client as WebSocketClient, "resolve", new object[] {ohlcvCache, topic});
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#watchTrades
        * @description watches information on multiple trades made in a market
        * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/public/trade
        * @param {string} symbol unified market symbol of the market trades were made in
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trade structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object topic = add(getValue(market, "id"), "@trade");
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "topic", topic },
        };
        object message = this.extend(request, parameters);
        object trades = await this.watchPublic(topic, message);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {getValue(market, "symbol"), limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleTrade(WebSocketClient client, object message)
    {
        //
        // {
        //     "topic":"PERP_ADA_USDC@trade",
        //     "ts":1618820361552,
        //     "data":{
        //         "symbol":"PERP_ADA_USDC",
        //         "price":1.27988,
        //         "size":300,
        //         "side":"BUY",
        //     }
        // }
        //
        object topic = this.safeString(message, "topic");
        object timestamp = this.safeInteger(message, "ts");
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "symbol");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object trade = this.parseWsTrade(this.extend(data, new Dictionary<string, object>() {
            { "timestamp", timestamp },
        }), market);
        if (!isTrue((inOp(this.trades, symbol))))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            var stored = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        object trades = getValue(this.trades, symbol);
        callDynamically(trades, "append", new object[] {trade});
        ((IDictionary<string,object>)this.trades)[(string)symbol] = trades;
        callDynamically(client as WebSocketClient, "resolve", new object[] {trades, topic});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        //     {
        //         "symbol":"PERP_ADA_USDC",
        //         "timestamp":1618820361552,
        //         "price":1.27988,
        //         "size":300,
        //         "side":"BUY",
        //     }
        // private stream
        //     {
        //         symbol: 'PERP_XRP_USDC',
        //         clientOrderId: '',
        //         orderId: 1167632251,
        //         type: 'MARKET',
        //         side: 'BUY',
        //         quantity: 20,
        //         price: 0,
        //         tradeId: '1715179456664012',
        //         executedPrice: 0.5276,
        //         executedQuantity: 20,
        //         fee: 0.006332,
        //         feeAsset: 'USDC',
        //         totalExecutedQuantity: 20,
        //         avgPrice: 0.5276,
        //         averageExecutedPrice: 0.5276,
        //         status: 'FILLED',
        //         reason: '',
        //         totalFee: 0.006332,
        //         visible: 0,
        //         visibleQuantity: 0,
        //         timestamp: 1715179456660,
        //         orderTag: 'CCXT',
        //         createdTime: 1715179456656,
        //         maker: false
        //     }
        //
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object price = this.safeString2(trade, "executedPrice", "price");
        object amount = this.safeString2(trade, "executedQuantity", "size");
        object cost = Precise.stringMul(price, amount);
        object side = this.safeStringLower(trade, "side");
        object timestamp = this.safeInteger(trade, "timestamp");
        object takerOrMaker = null;
        object maker = this.safeBool(trade, "maker");
        if (isTrue(!isEqual(maker, null)))
        {
            takerOrMaker = ((bool) isTrue(maker)) ? "maker" : "taker";
        }
        object fee = null;
        object feeValue = this.safeString(trade, "fee");
        if (isTrue(!isEqual(feeValue, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeValue },
                { "currency", this.safeCurrencyCode(this.safeString(trade, "feeAsset")) },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", this.safeString(trade, "tradeId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "order", this.safeString(trade, "orderId") },
            { "takerOrMaker", takerOrMaker },
            { "type", this.safeStringLower(trade, "type") },
            { "fee", fee },
            { "info", trade },
        }, market);
    }

    public virtual void handleAuth(WebSocketClient client, object message)
    {
        //
        //     {
        //         "event": "auth",
        //         "success": true,
        //         "ts": 1657463158812
        //     }
        //
        object messageHash = "authenticated";
        object success = this.safeValue(message, "success");
        if (isTrue(success))
        {
            // client.resolve (message, messageHash);
            var future = this.safeValue((client as WebSocketClient).futures, "authenticated");
            (future as Future).resolve(true);
        } else
        {
            var error = new AuthenticationError(this.json(message));
            ((WebSocketClient)client).reject(error, messageHash);
            // allows further authentication attempts
            if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
            {
                ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)"authenticated");
            }
        }
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "private"), "/"), this.accountId);
        var client = this.client(url);
        object messageHash = "authenticated";
        object eventVar = "auth";
        var future = client.future(messageHash);
        object authenticated = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(authenticated, null)))
        {
            object ts = ((object)this.nonce()).ToString();
            object auth = ts;
            object secret = this.secret;
            if (isTrue(isGreaterThanOrEqual(getIndexOf(secret, "ed25519:"), 0)))
            {
                object parts = ((string)secret).Split(new [] {((string)"ed25519:")}, StringSplitOptions.None).ToList<object>();
                secret = getValue(parts, 1);
            }
            object signature = eddsa(this.encode(auth), this.base58ToBinary(secret), ed25519);
            object request = new Dictionary<string, object>() {
                { "event", eventVar },
                { "params", new Dictionary<string, object>() {
                    { "orderly_key", this.apiKey },
                    { "sign", signature },
                    { "timestamp", ts },
                } },
            };
            object message = this.extend(request, parameters);
            this.watch(url, messageHash, message, messageHash);
        }
        return await (future as Exchange.Future);
    }

    public async virtual Task<object> watchPrivate(object messageHash, object message, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticate(parameters);
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "private"), "/"), this.accountId);
        object requestId = this.requestId(url);
        object subscribe = new Dictionary<string, object>() {
            { "id", requestId },
        };
        object request = this.extend(subscribe, message);
        return await this.watch(url, messageHash, request, messageHash, subscribe);
    }

    public async virtual Task<object> watchPrivateMultiple(object messageHashes, object message, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticate(parameters);
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "private"), "/"), this.accountId);
        object requestId = this.requestId(url);
        object subscribe = new Dictionary<string, object>() {
            { "id", requestId },
        };
        object request = this.extend(subscribe, message);
        return await this.watchMultiple(url, messageHashes, request, messageHashes, subscribe);
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#watchOrders
        * @description watches information on multiple orders made by the user
        * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/private/execution-report
        * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/private/algo-execution-report
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {bool} [params.trigger] true if trigger order
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object trigger = this.safeBool2(parameters, "stop", "trigger", false);
        object topic = ((bool) isTrue((trigger))) ? "algoexecutionreport" : "executionreport";
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        object messageHash = topic;
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            symbol = getValue(market, "symbol");
            messageHash = add(messageHash, add(":", symbol));
        }
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "topic", topic },
        };
        object message = this.extend(request, parameters);
        object orders = await this.watchPrivate(messageHash, message);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#watchMyTrades
        * @description watches information on multiple trades made by the user
        * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/private/execution-report
        * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/private/algo-execution-report
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {bool} [params.trigger] true if trigger order
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object trigger = this.safeBool2(parameters, "stop", "trigger", false);
        object topic = ((bool) isTrue((trigger))) ? "algoexecutionreport" : "executionreport";
        parameters = this.omit(parameters, "stop");
        object messageHash = "myTrades";
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            symbol = getValue(market, "symbol");
            messageHash = add(messageHash, add(":", symbol));
        }
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "topic", topic },
        };
        object message = this.extend(request, parameters);
        object orders = await this.watchPrivate(messageHash, message);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        //     {
        //         "symbol": "PERP_BTC_USDT",
        //         "clientOrderId": 0,
        //         "orderId": 52952826,
        //         "type": "LIMIT",
        //         "side": "SELL",
        //         "quantity": 0.01,
        //         "price": 22000,
        //         "tradeId": 0,
        //         "executedPrice": 0,
        //         "executedQuantity": 0,
        //         "fee": 0,
        //         "feeAsset": "USDT",
        //         "totalExecutedQuantity": 0,
        //         "status": "NEW",
        //         "reason": '',
        //         "orderTag": "default",
        //         "totalFee": 0,
        //         "visible": 0.01,
        //         "timestamp": 1657515556799,
        //         "reduceOnly": false,
        //         "maker": false
        //     }
        // algo order
        //     {
        //         "symbol":"PERP_MATIC_USDC",
        //         "rootAlgoOrderId":123,
        //         "parentAlgoOrderId":123,
        //         "algoOrderId":123,
        //         "orderTag":"some tags",
        //         "algoType": "STOP",
        //         "clientOrderId":"client_id",
        //         "type":"LIMIT",
        //         "side":"BUY",
        //         "quantity":7029.0,
        //         "price":0.7699,
        //         "tradeId":0,
        //         "triggerTradePrice":0,
        //         "triggerTime":1234567,
        //         "triggered": false,
        //         "activated": false,
        //         "executedPrice":0.0,
        //         "executedQuantity":0.0,
        //         "fee":0.0,
        //         "feeAsset":"USDC",
        //         "totalExecutedQuantity":0.0,
        //         "averageExecutedQuantity":0.0,
        //         "avgPrice":0,
        //         "triggerPrice":0.0,
        //         "triggerPriceType":"STOP",
        //         "isActivated": false,
        //         "status":"NEW",
        //         "rootAlgoStatus": "FILLED",
        //         "algoStatus": "FILLED",
        //         "reason":"",
        //         "totalFee":0.0,
        //         "visible": 7029.0,
        //         "visibleQuantity":7029.0,
        //         "timestamp":1704679472448,
        //         "maker":false,
        //         "isMaker":false,
        //         "createdTime":1704679472448
        //     }
        //
        object orderId = this.safeString(order, "orderId");
        object marketId = this.safeString(order, "symbol");
        market = this.market(marketId);
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger(order, "timestamp");
        object fee = new Dictionary<string, object>() {
            { "cost", this.safeString(order, "totalFee") },
            { "currency", this.safeString(order, "feeAsset") },
        };
        object priceString = this.safeString(order, "price");
        object price = this.safeNumber(order, "price");
        object avgPrice = this.safeNumber(order, "avgPrice");
        if (isTrue(isTrue(Precise.stringEq(priceString, "0")) && isTrue((!isEqual(avgPrice, null)))))
        {
            price = avgPrice;
        }
        object amount = this.safeString(order, "quantity");
        object side = this.safeStringLower(order, "side");
        object type = this.safeStringLower(order, "type");
        object filled = this.safeNumber(order, "totalExecutedQuantity");
        object totalExecQuantity = this.safeString(order, "totalExecutedQuantity");
        object remaining = amount;
        if (isTrue(Precise.stringGe(amount, totalExecQuantity)))
        {
            remaining = Precise.stringSub(remaining, totalExecQuantity);
        }
        object rawStatus = this.safeString(order, "status");
        object status = this.parseOrderStatus(rawStatus);
        object trades = null;
        object clientOrderId = this.safeString(order, "clientOrderId");
        object triggerPrice = this.safeNumber(order, "triggerPrice");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "symbol", symbol },
            { "id", orderId },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", timestamp },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", triggerPrice },
            { "triggerPrice", triggerPrice },
            { "amount", amount },
            { "cost", null },
            { "average", null },
            { "filled", filled },
            { "remaining", remaining },
            { "status", status },
            { "fee", fee },
            { "trades", trades },
        });
    }

    public virtual void handleOrderUpdate(WebSocketClient client, object message)
    {
        //
        //     {
        //         "topic": "executionreport",
        //         "ts": 1657515556799,
        //         "data": {
        //             "symbol": "PERP_BTC_USDT",
        //             "clientOrderId": 0,
        //             "orderId": 52952826,
        //             "type": "LIMIT",
        //             "side": "SELL",
        //             "quantity": 0.01,
        //             "price": 22000,
        //             "tradeId": 0,
        //             "executedPrice": 0,
        //             "executedQuantity": 0,
        //             "fee": 0,
        //             "feeAsset": "USDT",
        //             "totalExecutedQuantity": 0,
        //             "status": "NEW",
        //             "reason": '',
        //             "orderTag": "default",
        //             "totalFee": 0,
        //             "visible": 0.01,
        //             "timestamp": 1657515556799,
        //             "maker": false
        //         }
        //     }
        //
        object topic = this.safeString(message, "topic");
        object data = this.safeValue(message, "data");
        if (isTrue(((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            // algoexecutionreport
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object order = getValue(data, i);
                object tradeId = this.omitZero(this.safeString(data, "tradeId"));
                if (isTrue(!isEqual(tradeId, null)))
                {
                    this.handleMyTrade(client as WebSocketClient, order);
                }
                this.handleOrder(client as WebSocketClient, order, topic);
            }
        } else
        {
            // executionreport
            object tradeId = this.omitZero(this.safeString(data, "tradeId"));
            if (isTrue(!isEqual(tradeId, null)))
            {
                this.handleMyTrade(client as WebSocketClient, data);
            }
            this.handleOrder(client as WebSocketClient, data, topic);
        }
    }

    public virtual void handleOrder(WebSocketClient client, object message, object topic)
    {
        object parsed = this.parseWsOrder(message);
        object symbol = this.safeString(parsed, "symbol");
        object orderId = this.safeString(parsed, "id");
        if (isTrue(!isEqual(symbol, null)))
        {
            if (isTrue(isEqual(this.orders, null)))
            {
                object limit = this.safeInteger(this.options, "ordersLimit", 1000);
                this.orders = new ArrayCacheBySymbolById(limit);
            }
            object cachedOrders = this.orders;
            object orders = this.safeDict((cachedOrders as ArrayCacheBySymbolById).hashmap, symbol, new Dictionary<string, object>() {});
            object order = this.safeDict(orders, orderId);
            if (isTrue(!isEqual(order, null)))
            {
                object fee = this.safeValue(order, "fee");
                if (isTrue(!isEqual(fee, null)))
                {
                    ((IDictionary<string,object>)parsed)["fee"] = fee;
                }
                object fees = this.safeList(order, "fees");
                if (isTrue(!isEqual(fees, null)))
                {
                    ((IDictionary<string,object>)parsed)["fees"] = fees;
                }
                ((IDictionary<string,object>)parsed)["trades"] = this.safeList(order, "trades");
                ((IDictionary<string,object>)parsed)["timestamp"] = this.safeInteger(order, "timestamp");
                ((IDictionary<string,object>)parsed)["datetime"] = this.safeString(order, "datetime");
            }
            callDynamically(cachedOrders, "append", new object[] {parsed});
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, topic});
            object messageHashSymbol = add(add(topic, ":"), symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageHashSymbol});
        }
    }

    public virtual void handleMyTrade(WebSocketClient client, object message)
    {
        //
        // {
        //     symbol: 'PERP_XRP_USDC',
        //     clientOrderId: '',
        //     orderId: 1167632251,
        //     type: 'MARKET',
        //     side: 'BUY',
        //     quantity: 20,
        //     price: 0,
        //     tradeId: '1715179456664012',
        //     executedPrice: 0.5276,
        //     executedQuantity: 20,
        //     fee: 0.006332,
        //     feeAsset: 'USDC',
        //     totalExecutedQuantity: 20,
        //     avgPrice: 0.5276,
        //     averageExecutedPrice: 0.5276,
        //     status: 'FILLED',
        //     reason: '',
        //     totalFee: 0.006332,
        //     visible: 0,
        //     visibleQuantity: 0,
        //     timestamp: 1715179456660,
        //     orderTag: 'CCXT',
        //     createdTime: 1715179456656,
        //     maker: false
        // }
        //
        object messageHash = "myTrades";
        object marketId = this.safeString(message, "symbol");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object trade = this.parseWsTrade(message, market);
        object trades = this.myTrades;
        if (isTrue(isEqual(trades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            trades = new ArrayCacheBySymbolById(limit);
            this.myTrades = trades;
        }
        callDynamically(trades, "append", new object[] {trade});
        callDynamically(client as WebSocketClient, "resolve", new object[] {trades, messageHash});
        object symbolSpecificMessageHash = add(add(messageHash, ":"), symbol);
        callDynamically(client as WebSocketClient, "resolve", new object[] {trades, symbolSpecificMessageHash});
    }

    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#watchPositions
        * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/private/position-push
        * @description watch all open positions
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object messageHashes = new List<object>() {};
        symbols = this.marketSymbols(symbols);
        if (!isTrue(this.isEmpty(symbols)))
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                ((IList<object>)messageHashes).Add(add("positions::", symbol));
            }
        } else
        {
            ((IList<object>)messageHashes).Add("positions");
        }
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), "private"), "/"), this.accountId);
        var client = this.client(url);
        this.setPositionsCache(client as WebSocketClient, symbols);
        object fetchPositionsSnapshot = this.handleOption("watchPositions", "fetchPositionsSnapshot", true);
        object awaitPositionsSnapshot = this.handleOption("watchPositions", "awaitPositionsSnapshot", true);
        if (isTrue(isTrue(isTrue(fetchPositionsSnapshot) && isTrue(awaitPositionsSnapshot)) && isTrue(isEqual(this.positions, null))))
        {
            object snapshot = await client.future("fetchPositionsSnapshot");
            return this.filterBySymbolsSinceLimit(snapshot, symbols, since, limit, true);
        }
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "topic", "position" },
        };
        object newPositions = await this.watchPrivateMultiple(messageHashes, request, parameters);
        if (isTrue(this.newUpdates))
        {
            return newPositions;
        }
        return this.filterBySymbolsSinceLimit(this.positions, symbols, since, limit, true);
    }

    public virtual void setPositionsCache(WebSocketClient client, object type, object symbols = null)
    {
        object fetchPositionsSnapshot = this.handleOption("watchPositions", "fetchPositionsSnapshot", false);
        if (isTrue(fetchPositionsSnapshot))
        {
            object messageHash = "fetchPositionsSnapshot";
            if (!isTrue((inOp(client.futures, messageHash))))
            {
                client.future(messageHash);
                this.spawn(this.loadPositionsSnapshot, new object[] { client, messageHash});
            }
        } else
        {
            this.positions = new ArrayCacheBySymbolBySide();
        }
    }

    public async virtual Task loadPositionsSnapshot(WebSocketClient client, object messageHash)
    {
        object positions = await this.fetchPositions();
        this.positions = new ArrayCacheBySymbolBySide();
        object cache = this.positions;
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object position = getValue(positions, i);
            object contracts = this.safeString(position, "contracts", "0");
            if (isTrue(Precise.stringGt(contracts, "0")))
            {
                callDynamically(cache, "append", new object[] {position});
            }
        }
        // don't remove the future from the .futures cache
        var future = getValue(client.futures, messageHash);
        (future as Future).resolve(cache);
        callDynamically(client as WebSocketClient, "resolve", new object[] {cache, "positions"});
    }

    public virtual void handlePositions(WebSocketClient client, object message)
    {
        //
        //    {
        //        "topic":"position",
        //        "ts":1705292345255,
        //        "data":{
        //           "positions":[
        //              {
        //                     "symbol":"PERP_ETH_USDC",
        //                     "positionQty":3.1408,
        //                     "costPosition":5706.51952,
        //                     "lastSumUnitaryFunding":0.804,
        //                     "sumUnitaryFundingVersion":0,
        //                     "pendingLongQty":0.0,
        //                     "pendingShortQty":-1.0,
        //                     "settlePrice":1816.9,
        //                     "averageOpenPrice":1804.51490427,
        //                     "unsettledPnl":-2.79856,
        //                     "pnl24H":-338.90179488,
        //                     "fee24H":4.242423,
        //                     "markPrice":1816.2,
        //                     "estLiqPrice":0.0,
        //                     "version":179967,
        //                     "imrwithOrders":0.1,
        //                     "mmrwithOrders":0.05,
        //                     "mmr":0.05,
        //                     "imr":0.1,
        //                     "timestamp":1685154032762
        //              }
        //           ]
        //        }
        //    }
        //
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object rawPositions = this.safeList(data, "positions", new List<object>() {});
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new ArrayCacheBySymbolBySide();
        }
        object cache = this.positions;
        object newPositions = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rawPositions)); postFixIncrement(ref i))
        {
            object rawPosition = getValue(rawPositions, i);
            object marketId = this.safeString(rawPosition, "symbol");
            object market = this.safeMarket(marketId);
            object position = this.parseWsPosition(rawPosition, market);
            ((IList<object>)newPositions).Add(position);
            callDynamically(cache, "append", new object[] {position});
            object messageHash = add("positions::", getValue(market, "symbol"));
            callDynamically(client as WebSocketClient, "resolve", new object[] {position, messageHash});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newPositions, "positions"});
    }

    public virtual object parseWsPosition(object position, object market = null)
    {
        //
        //     {
        //         "symbol":"PERP_ETH_USDC",
        //         "positionQty":3.1408,
        //         "costPosition":5706.51952,
        //         "lastSumUnitaryFunding":0.804,
        //         "sumUnitaryFundingVersion":0,
        //         "pendingLongQty":0.0,
        //         "pendingShortQty":-1.0,
        //         "settlePrice":1816.9,
        //         "averageOpenPrice":1804.51490427,
        //         "unsettledPnl":-2.79856,
        //         "pnl24H":-338.90179488,
        //         "fee24H":4.242423,
        //         "markPrice":1816.2,
        //         "estLiqPrice":0.0,
        //         "version":179967,
        //         "imrwithOrders":0.1,
        //         "mmrwithOrders":0.05,
        //         "mmr":0.05,
        //         "imr":0.1,
        //         "timestamp":1685154032762
        //     }
        //
        object contract = this.safeString(position, "symbol");
        market = this.safeMarket(contract, market);
        object size = this.safeString(position, "positionQty");
        object side = null;
        if (isTrue(Precise.stringGt(size, "0")))
        {
            side = "long";
        } else
        {
            side = "short";
        }
        object contractSize = this.safeString(market, "contractSize");
        object markPrice = this.safeString(position, "markPrice");
        object timestamp = this.safeInteger(position, "timestamp");
        object entryPrice = this.safeString(position, "averageOpenPrice");
        object unrealisedPnl = this.safeString(position, "unsettledPnl");
        size = Precise.stringAbs(size);
        object notional = Precise.stringMul(size, markPrice);
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", this.safeString(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "entryPrice", this.parseNumber(entryPrice) },
            { "notional", this.parseNumber(notional) },
            { "leverage", null },
            { "unrealizedPnl", this.parseNumber(unrealisedPnl) },
            { "contracts", this.parseNumber(size) },
            { "contractSize", this.parseNumber(contractSize) },
            { "marginRatio", null },
            { "liquidationPrice", this.safeNumber(position, "estLiqPrice") },
            { "markPrice", this.parseNumber(markPrice) },
            { "lastPrice", null },
            { "collateral", null },
            { "marginMode", "cross" },
            { "marginType", null },
            { "side", side },
            { "percentage", null },
            { "hedged", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @name woofipro#watchBalance
        * @description watch balance and get the amount of funds available for trading or funds locked in orders
        * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/private/balance
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object topic = "balance";
        object messageHash = topic;
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "topic", topic },
        };
        object message = this.extend(request, parameters);
        return await this.watchPrivate(messageHash, message);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        //     {
        //         "topic":"balance",
        //         "ts":1651836695254,
        //         "data":{
        //             "balances":{
        //                 "USDC":{
        //                     "holding":5555815.47398272,
        //                     "frozen":0,
        //                     "interest":0,
        //                     "pendingShortQty":0,
        //                     "pendingExposure":0,
        //                     "pendingLongQty":0,
        //                     "pendingLongExposure":0,
        //                     "version":894,
        //                     "staked":51370692,
        //                     "unbonding":0,
        //                     "vault":0,
        //                     "averageOpenPrice":0.00000574,
        //                     "pnl24H":0,
        //                     "fee24H":0.01914,
        //                     "markPrice":0.31885
        //                 }
        //             }
        //         }
        //     }
        //
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object balances = this.safeDict(data, "balances", new Dictionary<string, object>() {});
        object keys = new List<object>(((IDictionary<string,object>)balances).Keys);
        object ts = this.safeInteger(message, "ts");
        ((IDictionary<string,object>)this.balance)["info"] = data;
        ((IDictionary<string,object>)this.balance)["timestamp"] = ts;
        ((IDictionary<string,object>)this.balance)["datetime"] = this.iso8601(ts);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object value = getValue(balances, key);
            object code = this.safeCurrencyCode(key);
            object account = ((bool) isTrue((inOp(this.balance, code)))) ? getValue(this.balance, code) : this.account();
            object total = this.safeString(value, "holding");
            object used = this.safeString(value, "frozen");
            ((IDictionary<string,object>)account)["total"] = total;
            ((IDictionary<string,object>)account)["used"] = used;
            ((IDictionary<string,object>)account)["free"] = Precise.stringSub(total, used);
            ((IDictionary<string,object>)this.balance)[(string)code] = account;
        }
        this.balance = this.safeBalance(this.balance);
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.balance, "balance"});
    }

    public virtual object handleErrorMessage(WebSocketClient client, object message)
    {
        //
        // {"id":"1","event":"subscribe","success":false,"ts":1710780997216,"errorMsg":"Auth is needed."}
        //
        if (!isTrue((inOp(message, "success"))))
        {
            return false;
        }
        object success = this.safeBool(message, "success");
        if (isTrue(success))
        {
            return false;
        }
        object errorMessage = this.safeString(message, "errorMsg");
        try
        {
            if (isTrue(!isEqual(errorMessage, null)))
            {
                object feedback = add(add(this.id, " "), this.json(message));
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorMessage, feedback);
            }
            return false;
        } catch(Exception error)
        {
            if (isTrue(error is AuthenticationError))
            {
                object messageHash = "authenticated";
                ((WebSocketClient)client).reject(error, messageHash);
                if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
                {
                    ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
                }
            } else
            {
                ((WebSocketClient)client).reject(error);
            }
            return true;
        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            return;
        }
        object methods = new Dictionary<string, object>() {
            { "ping", this.handlePing },
            { "pong", this.handlePong },
            { "subscribe", this.handleSubscribe },
            { "orderbook", this.handleOrderBook },
            { "ticker", this.handleTicker },
            { "tickers", this.handleTickers },
            { "kline", this.handleOHLCV },
            { "trade", this.handleTrade },
            { "auth", this.handleAuth },
            { "executionreport", this.handleOrderUpdate },
            { "algoexecutionreport", this.handleOrderUpdate },
            { "position", this.handlePositions },
            { "balance", this.handleBalance },
            { "bbos", this.handleBidAsk },
        };
        object eventVar = this.safeString(message, "event");
        object method = this.safeValue(methods, eventVar);
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
            return;
        }
        object topic = this.safeString(message, "topic");
        if (isTrue(!isEqual(topic, null)))
        {
            method = this.safeValue(methods, topic);
            if (isTrue(!isEqual(method, null)))
            {
                DynamicInvoker.InvokeMethod(method, new object[] { client, message});
                return;
            }
            object splitTopic = ((string)topic).Split(new [] {((string)"@")}, StringSplitOptions.None).ToList<object>();
            object splitLength = getArrayLength(splitTopic);
            if (isTrue(isEqual(splitLength, 2)))
            {
                object name = this.safeString(splitTopic, 1);
                method = this.safeValue(methods, name);
                if (isTrue(!isEqual(method, null)))
                {
                    DynamicInvoker.InvokeMethod(method, new object[] { client, message});
                    return;
                }
                object splitName = ((string)name).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
                object splitNameLength = getArrayLength(splitTopic);
                if (isTrue(isEqual(splitNameLength, 2)))
                {
                    method = this.safeValue(methods, this.safeString(splitName, 0));
                    if (isTrue(!isEqual(method, null)))
                    {
                        DynamicInvoker.InvokeMethod(method, new object[] { client, message});
                    }
                }
            }
        }
    }

    public override object ping(WebSocketClient client)
    {
        return new Dictionary<string, object>() {
            { "event", "ping" },
        };
    }

    public virtual object handlePing(WebSocketClient client, object message)
    {
        return new Dictionary<string, object>() {
            { "event", "pong" },
        };
    }

    public virtual object handlePong(WebSocketClient client, object message)
    {
        //
        // { event: "pong", ts: 1614667590000 }
        //
        client.lastPong = this.milliseconds();
        return message;
    }

    public virtual object handleSubscribe(WebSocketClient client, object message)
    {
        //
        //     {
        //         "id": "666888",
        //         "event": "subscribe",
        //         "success": true,
        //         "ts": 1657117712212
        //     }
        //
        return message;
    }
}
