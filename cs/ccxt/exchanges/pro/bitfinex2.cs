namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class bitfinex2 { public bitfinex2(object args = null) : base(args) { } }
public partial class bitfinex2 : ccxt.bitfinex2
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchTicker", true },
                { "watchTickers", false },
                { "watchOrderBook", true },
                { "watchTrades", true },
                { "watchMyTrades", true },
                { "watchBalance", true },
                { "watchOHLCV", true },
                { "watchOrders", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "public", "wss://api-pub.bitfinex.com/ws/2" },
                        { "private", "wss://api.bitfinex.com/ws/2" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "prec", "P0" },
                    { "freq", "F0" },
                } },
                { "ordersLimit", 1000 },
                { "checksum", true },
            } },
        });
    }

    public async virtual Task<object> subscribe(object channel, object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = getValue(market, "id");
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "public");
        var client = this.client(url);
        object messageHash = add(add(channel, ":"), marketId);
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "channel", channel },
            { "symbol", marketId },
        };
        object result = await this.watch(url, messageHash, this.deepExtend(request, parameters), messageHash, new Dictionary<string, object>() {
            { "checksum", false },
        });
        object checksum = this.safeBool(this.options, "checksum", true);
        if (isTrue(isTrue(isTrue(checksum) && !isTrue(getValue(getValue(((WebSocketClient)client).subscriptions, messageHash), "checksum"))) && isTrue((isEqual(channel, "book")))))
        {
            ((IDictionary<string,object>)getValue(((WebSocketClient)client).subscriptions, messageHash))["checksum"] = true;
            await client.send(new Dictionary<string, object>() {
                { "event", "conf" },
                { "flags", 131072 },
            });
        }
        return result;
    }

    public async virtual Task<object> subscribePrivate(object messageHash)
    {
        await this.loadMarkets();
        await this.authenticate();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        return await this.watch(url, messageHash, null, 1);
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex2#watchOHLCV
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object interval = this.safeString(this.timeframes, timeframe, timeframe);
        object channel = "candles";
        object key = add(add(add("trade:", interval), ":"), getValue(market, "id"));
        object messageHash = add(add(add(add(channel, ":"), interval), ":"), getValue(market, "id"));
        object request = new Dictionary<string, object>() {
            { "event", "subscribe" },
            { "channel", channel },
            { "key", key },
        };
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "public");
        // not using subscribe here because this message has a different format
        object ohlcv = await this.watch(url, messageHash, this.deepExtend(request, parameters), messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message, object subscription)
    {
        //
        // initial snapshot
        //   [
        //       341527, // channel id
        //       [
        //          [
        //             1654705860000, // timestamp
        //             1802.6, // open
        //             1800.3, // close
        //             1802.8, // high
        //             1800.3, // low
        //             86.49588236 // volume
        //          ],
        //          [
        //             1654705800000,
        //             1803.6,
        //             1802.6,
        //             1804.9,
        //             1802.3,
        //             74.6348086
        //          ],
        //          [
        //             1654705740000,
        //             1802.5,
        //             1803.2,
        //             1804.4,
        //             1802.4,
        //             23.61801085
        //          ]
        //       ]
        //   ]
        //
        // update
        //   [
        //       211171,
        //       [
        //          1654705680000,
        //          1801,
        //          1802.4,
        //          1802.9,
        //          1800.4,
        //          23.91911091
        //       ]
        //   ]
        //
        object data = this.safeValue(message, 1, new List<object>() {});
        object ohlcvs = null;
        object first = this.safeValue(data, 0);
        if (isTrue(((first is IList<object>) || (first.GetType().IsGenericType && first.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            // snapshot
            ohlcvs = data;
        } else
        {
            // update
            ohlcvs = new List<object>() {data};
        }
        object channel = this.safeValue(subscription, "channel");
        object key = this.safeString(subscription, "key");
        object keyParts = ((string)key).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
        object interval = this.safeString(keyParts, 1);
        object marketId = key;
        marketId = ((string)marketId).Replace((string)"trade:", (string)"");
        marketId = ((string)marketId).Replace((string)add(interval, ":"), (string)"");
        object market = this.safeMarket(marketId);
        object timeframe = this.findTimeframe(interval);
        object symbol = getValue(market, "symbol");
        object messageHash = add(add(add(add(channel, ":"), interval), ":"), marketId);
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
        }
        object ohlcvsLength = getArrayLength(ohlcvs);
        for (object i = 0; isLessThan(i, ohlcvsLength); postFixIncrement(ref i))
        {
            object ohlcv = getValue(ohlcvs, subtract(subtract(ohlcvsLength, i), 1));
            object parsed = this.parseOHLCV(ohlcv, market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex2#watchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        object trades = await this.subscribe("trades", symbol, parameters);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex2#watchMyTrades
        * @description watches information on multiple trades made by the user
        * @param {string} symbol unified market symbol of the market trades were made in
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trade structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object messageHash = "myTrade";
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            messageHash = add(messageHash, add(":", getValue(market, "id")));
        }
        object trades = await this.subscribePrivate(messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex2#watchTicker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.subscribe("ticker", symbol, parameters);
    }

    public virtual void handleMyTrade(WebSocketClient client, object message, object subscription = null)
    {
        //
        // trade execution
        // [
        //     0,
        //     "te", // or tu
        //     [
        //        1133411090,
        //        "tLTCUST",
        //        1655110144598,
        //        97084883506,
        //        0.1,
        //        42.821,
        //        "EXCHANGE MARKET",
        //        42.799,
        //        -1,
        //        null,
        //        null,
        //        1655110144596
        //     ]
        // ]
        //
        subscription ??= new Dictionary<string, object>();
        object name = "myTrade";
        object data = this.safeValue(message, 2);
        object trade = this.parseWsTrade(data);
        object symbol = getValue(trade, "symbol");
        object market = this.market(symbol);
        object messageHash = add(add(name, ":"), getValue(market, "id"));
        if (isTrue(isEqual(this.myTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            this.myTrades = new ArrayCacheBySymbolById(limit);
        }
        object tradesArray = this.myTrades;
        callDynamically(tradesArray, "append", new object[] {trade});
        this.myTrades = tradesArray;
        // generic subscription
        callDynamically(client as WebSocketClient, "resolve", new object[] {tradesArray, name});
        // specific subscription
        callDynamically(client as WebSocketClient, "resolve", new object[] {tradesArray, messageHash});
    }

    public virtual void handleTrades(WebSocketClient client, object message, object subscription)
    {
        //
        // initial snapshot
        //
        //    [
        //        188687, // channel id
        //        [
        //          [ 1128060675, 1654701572690, 0.00217533, 1815.3 ], // id, mts, amount, price
        //          [ 1128060665, 1654701551231, -0.00280472, 1814.1 ],
        //          [ 1128060664, 1654701550996, -0.00364444, 1814.1 ],
        //          [ 1128060656, 1654701527730, -0.00265203, 1814.2 ],
        //          [ 1128060647, 1654701505193, 0.00262395, 1815.2 ],
        //          [ 1128060642, 1654701484656, -0.13411443, 1816 ],
        //          [ 1128060641, 1654701484656, -0.00088557, 1816 ],
        //          [ 1128060639, 1654701478326, -0.002, 1816 ],
        //        ]
        //    ]
        // update
        //
        //    [
        //        360141,
        //        "te",
        //        [
        //            1128060969, // id
        //            1654702500098, // mts
        //            0.00325131, // amount positive buy, negative sell
        //            1818.5, // price
        //        ],
        //    ]
        //
        //
        object channel = this.safeValue(subscription, "channel");
        object marketId = this.safeString(subscription, "symbol");
        object market = this.safeMarket(marketId);
        object messageHash = add(add(channel, ":"), marketId);
        object tradesLimit = this.safeInteger(this.options, "tradesLimit", 1000);
        object symbol = getValue(market, "symbol");
        object stored = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(stored, null)))
        {
            stored = new ArrayCache(tradesLimit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        object messageLength = getArrayLength(message);
        if (isTrue(isEqual(messageLength, 2)))
        {
            // initial snapshot
            object trades = this.safeList(message, 1, new List<object>() {});
            // needs to be reversed to make chronological order
            object length = getArrayLength(trades);
            for (object i = 0; isLessThan(i, length); postFixIncrement(ref i))
            {
                object index = subtract(subtract(length, i), 1);
                object parsed = this.parseWsTrade(getValue(trades, index), market);
                callDynamically(stored, "append", new object[] {parsed});
            }
        } else
        {
            // update
            object type = this.safeString(message, 1);
            if (isTrue(isEqual(type, "tu")))
            {
                // don't resolve for a duplicate update
                // since te and tu updates are duplicated on the public stream
                return;
            }
            object trade = this.safeValue(message, 2, new List<object>() {});
            object parsed = this.parseWsTrade(trade, market);
            callDynamically(stored, "append", new object[] {parsed});
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        //    [
        //        1128060969, // id
        //        1654702500098, // mts
        //        0.00325131, // amount positive buy, negative sell
        //        1818.5, // price
        //    ]
        //
        // trade execution
        //
        //    [
        //        1133411090, // id
        //        "tLTCUST", // symbol
        //        1655110144598, // create ms
        //        97084883506, // order id
        //        0.1, // amount
        //        42.821, // price
        //        "EXCHANGE MARKET", // order type
        //        42.799, // order price
        //        -1, // maker
        //        null, // fee
        //        null, // fee currency
        //        1655110144596 // cid
        //    ]
        //
        // trade update
        //
        //    [
        //       1133411090,
        //       "tLTCUST",
        //       1655110144598,
        //       97084883506,
        //       0.1,
        //       42.821,
        //       "EXCHANGE MARKET",
        //       42.799,
        //       -1,
        //       -0.0002,
        //       "LTC",
        //       1655110144596
        //    ]
        //
        object numFields = getArrayLength(trade);
        object isPublic = isLessThanOrEqual(numFields, 8);
        object marketId = ((bool) isTrue((!isTrue(isPublic)))) ? this.safeString(trade, 1) : null;
        market = this.safeMarket(marketId, market);
        object createdKey = ((bool) isTrue(isPublic)) ? 1 : 2;
        object priceKey = ((bool) isTrue(isPublic)) ? 3 : 5;
        object amountKey = ((bool) isTrue(isPublic)) ? 2 : 4;
        marketId = getValue(market, "id");
        object type = this.safeString(trade, 6);
        if (isTrue(!isEqual(type, null)))
        {
            if (isTrue(isGreaterThan(getIndexOf(type, "LIMIT"), -1)))
            {
                type = "limit";
            } else if (isTrue(isGreaterThan(getIndexOf(type, "MARKET"), -1)))
            {
                type = "market";
            }
        }
        object orderId = ((bool) isTrue((!isTrue(isPublic)))) ? this.safeString(trade, 3) : null;
        object id = this.safeString(trade, 0);
        object timestamp = this.safeInteger(trade, createdKey);
        object price = this.safeString(trade, priceKey);
        object amountString = this.safeString(trade, amountKey);
        object amount = this.parseNumber(Precise.stringAbs(amountString));
        object side = null;
        if (isTrue(!isEqual(amount, null)))
        {
            side = ((bool) isTrue(Precise.stringGt(amountString, "0"))) ? "buy" : "sell";
        }
        object symbol = this.safeSymbol(marketId, market);
        object feeValue = this.safeString(trade, 9);
        object fee = null;
        if (isTrue(!isEqual(feeValue, null)))
        {
            object currencyId = this.safeString(trade, 10);
            object code = this.safeCurrencyCode(currencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeValue },
                { "currency", code },
            };
        }
        object maker = this.safeInteger(trade, 8);
        object takerOrMaker = null;
        if (isTrue(!isEqual(maker, null)))
        {
            takerOrMaker = ((bool) isTrue((isEqual(maker, -1)))) ? "taker" : "maker";
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", id },
            { "order", orderId },
            { "type", type },
            { "takerOrMaker", takerOrMaker },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    public virtual void handleTicker(WebSocketClient client, object message, object subscription)
    {
        //
        // [
        //    340432, // channel ID
        //     [
        //         236.62,        // 1 BID float Price of last highest bid
        //         9.0029,        // 2 BID_SIZE float Size of the last highest bid
        //         236.88,        // 3 ASK float Price of last lowest ask
        //         7.1138,        // 4 ASK_SIZE float Size of the last lowest ask
        //         -1.02,         // 5 DAILY_CHANGE float Amount that the last price has changed since yesterday
        //         0,             // 6 DAILY_CHANGE_PERC float Amount that the price has changed expressed in percentage terms
        //         236.52,        // 7 LAST_PRICE float Price of the last trade.
        //         5191.36754297, // 8 VOLUME float Daily volume
        //         250.01,        // 9 HIGH float Daily high
        //         220.05,        // 10 LOW float Daily low
        //     ]
        //  ]
        //
        object ticker = this.safeValue(message, 1);
        object marketId = this.safeString(subscription, "symbol");
        object market = this.safeMarket(marketId);
        object symbol = this.safeSymbol(marketId);
        object parsed = this.parseWsTicker(ticker, market);
        object channel = "ticker";
        object messageHash = add(add(channel, ":"), marketId);
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = parsed;
        callDynamically(client as WebSocketClient, "resolve", new object[] {parsed, messageHash});
    }

    public virtual object parseWsTicker(object ticker, object market = null)
    {
        //
        //     [
        //         236.62,        // 1 BID float Price of last highest bid
        //         9.0029,        // 2 BID_SIZE float Size of the last highest bid
        //         236.88,        // 3 ASK float Price of last lowest ask
        //         7.1138,        // 4 ASK_SIZE float Size of the last lowest ask
        //         -1.02,         // 5 DAILY_CHANGE float Amount that the last price has changed since yesterday
        //         0,             // 6 DAILY_CHANGE_PERC float Amount that the price has changed expressed in percentage terms
        //         236.52,        // 7 LAST_PRICE float Price of the last trade.
        //         5191.36754297, // 8 VOLUME float Daily volume
        //         250.01,        // 9 HIGH float Daily high
        //         220.05,        // 10 LOW float Daily low
        //     ]
        //
        market = this.safeMarket(null, market);
        object symbol = getValue(market, "symbol");
        object last = this.safeString(ticker, 6);
        object change = this.safeString(ticker, 4);
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "high", this.safeString(ticker, 8) },
            { "low", this.safeString(ticker, 9) },
            { "bid", this.safeString(ticker, 0) },
            { "bidVolume", this.safeString(ticker, 1) },
            { "ask", this.safeString(ticker, 2) },
            { "askVolume", this.safeString(ticker, 3) },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", change },
            { "percentage", this.safeString(ticker, 5) },
            { "average", null },
            { "baseVolume", this.safeString(ticker, 7) },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex2#watchOrderBook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(isTrue((!isEqual(limit, 25))) && isTrue((!isEqual(limit, 100)))))
            {
                throw new ExchangeError ((string)add(this.id, " watchOrderBook limit argument must be undefined, 25 or 100")) ;
            }
        }
        object options = this.safeValue(this.options, "watchOrderBook", new Dictionary<string, object>() {});
        object prec = this.safeString(options, "prec", "P0");
        object freq = this.safeString(options, "freq", "F0");
        object request = new Dictionary<string, object>() {
            { "prec", prec },
            { "freq", freq },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["len"] = limit; // string, number of price points, '25', '100', default = '25'
        }
        object orderbook = await this.subscribe("book", symbol, this.deepExtend(request, parameters));
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBook(WebSocketClient client, object message, object subscription)
    {
        //
        // first message (snapshot)
        //
        //     [
        //         18691, // channel id
        //         [
        //             [ 7364.8, 10, 4.354802 ], // price, count, size > 0 = bid
        //             [ 7364.7, 1, 0.00288831 ],
        //             [ 7364.3, 12, 0.048 ],
        //             [ 7364.9, 3, -0.42028976 ], // price, count, size < 0 = ask
        //             [ 7365, 1, -0.25 ],
        //             [ 7365.5, 1, -0.00371937 ],
        //         ]
        //     ]
        //
        // subsequent updates
        //
        //     [
        //         358169, // channel id
        //         [
        //            1807.1, // price
        //            0, // cound
        //            1 // size
        //         ]
        //     ]
        //
        object marketId = this.safeString(subscription, "symbol");
        object symbol = this.safeSymbol(marketId);
        object channel = "book";
        object messageHash = add(add(channel, ":"), marketId);
        object prec = this.safeString(subscription, "prec", "P0");
        object isRaw = (isEqual(prec, "R0"));
        // if it is an initial snapshot
        object orderbook = this.safeValue(this.orderbooks, symbol);
        if (isTrue(isEqual(orderbook, null)))
        {
            object limit = this.safeInteger(subscription, "len");
            if (isTrue(isRaw))
            {
                // raw order books
                ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.indexedOrderBook(new Dictionary<string, object>() {}, limit);
            } else
            {
                // P0, P1, P2, P3, P4
                ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.countedOrderBook(new Dictionary<string, object>() {}, limit);
            }
            orderbook = getValue(this.orderbooks, symbol);
            if (isTrue(isRaw))
            {
                object deltas = getValue(message, 1);
                for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
                {
                    object delta = getValue(deltas, i);
                    object delta2 = getValue(delta, 2);
                    object size = ((bool) isTrue((isLessThan(delta2, 0)))) ? prefixUnaryNeg(ref delta2) : delta2;
                    object side = ((bool) isTrue((isLessThan(delta2, 0)))) ? "asks" : "bids";
                    object bookside = getValue(orderbook, side);
                    object idString = this.safeString(delta, 0);
                    object price = this.safeFloat(delta, 1);
                    (bookside as IOrderBookSide).store(price, size, idString);
                }
            } else
            {
                object deltas = getValue(message, 1);
                for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
                {
                    object delta = getValue(deltas, i);
                    object amount = this.safeNumber(delta, 2);
                    object counter = this.safeNumber(delta, 1);
                    object price = this.safeNumber(delta, 0);
                    object size = ((bool) isTrue((isLessThan(amount, 0)))) ? prefixUnaryNeg(ref amount) : amount;
                    object side = ((bool) isTrue((isLessThan(amount, 0)))) ? "asks" : "bids";
                    object bookside = getValue(orderbook, side);
                    (bookside as IOrderBookSide).store(price, size, counter);
                }
            }
            ((IDictionary<string,object>)orderbook)["symbol"] = symbol;
            callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
        } else
        {
            object deltas = getValue(message, 1);
            object orderbookItem = getValue(this.orderbooks, symbol);
            if (isTrue(isRaw))
            {
                object price = this.safeString(deltas, 1);
                object deltas2 = getValue(deltas, 2);
                object size = ((bool) isTrue((isLessThan(deltas2, 0)))) ? prefixUnaryNeg(ref deltas2) : deltas2;
                object side = ((bool) isTrue((isLessThan(deltas2, 0)))) ? "asks" : "bids";
                object bookside = getValue(orderbookItem, side);
                // price = 0 means that you have to remove the order from your book
                object amount = ((bool) isTrue(Precise.stringGt(price, "0"))) ? size : "0";
                object idString = this.safeString(deltas, 0);
                (bookside as IOrderBookSide).store(this.parseNumber(price), this.parseNumber(amount), idString);
            } else
            {
                object amount = this.safeString(deltas, 2);
                object counter = this.safeString(deltas, 1);
                object price = this.safeString(deltas, 0);
                object size = ((bool) isTrue(Precise.stringLt(amount, "0"))) ? Precise.stringNeg(amount) : amount;
                object side = ((bool) isTrue(Precise.stringLt(amount, "0"))) ? "asks" : "bids";
                object bookside = getValue(orderbookItem, side);
                (bookside as IOrderBookSide).store(this.parseNumber(price), this.parseNumber(size), this.parseNumber(counter));
            }
            callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
        }
    }

    public virtual void handleChecksum(WebSocketClient client, object message, object subscription)
    {
        //
        // [ 173904, "cs", -890884919 ]
        //
        object marketId = this.safeString(subscription, "symbol");
        object symbol = this.safeSymbol(marketId);
        object channel = "book";
        object messageHash = add(add(channel, ":"), marketId);
        object book = this.safeValue(this.orderbooks, symbol);
        if (isTrue(isEqual(book, null)))
        {
            return;
        }
        object depth = 25; // covers the first 25 bids and asks
        object stringArray = new List<object>() {};
        object bids = getValue(book, "bids");
        object asks = getValue(book, "asks");
        object prec = this.safeString(subscription, "prec", "P0");
        object isRaw = (isEqual(prec, "R0"));
        object idToCheck = ((bool) isTrue(isRaw)) ? 2 : 0;
        // pepperoni pizza from bitfinex
        for (object i = 0; isLessThan(i, depth); postFixIncrement(ref i))
        {
            object bid = this.safeValue(bids, i);
            object ask = this.safeValue(asks, i);
            if (isTrue(!isEqual(bid, null)))
            {
                ((IList<object>)stringArray).Add(this.numberToString(getValue(getValue(bids, i), idToCheck)));
                ((IList<object>)stringArray).Add(this.numberToString(getValue(getValue(bids, i), 1)));
            }
            if (isTrue(!isEqual(ask, null)))
            {
                ((IList<object>)stringArray).Add(this.numberToString(getValue(getValue(asks, i), idToCheck)));
                object aski1 = getValue(getValue(asks, i), 1);
                ((IList<object>)stringArray).Add(this.numberToString(prefixUnaryNeg(ref aski1)));
            }
        }
        object payload = String.Join(":", ((IList<object>)stringArray).ToArray());
        object localChecksum = this.crc32(payload, true);
        object responseChecksum = this.safeInteger(message, 2);
        if (isTrue(!isEqual(responseChecksum, localChecksum)))
        {
            var error = new InvalidNonce(add(this.id, " invalid checksum"));
            ((WebSocketClient)client).reject(error, messageHash);
        }
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bitfinex2#watchBalance
        * @description watch balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {str} [params.type] spot or contract if not provided this.options['defaultType'] is used
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object balanceType = this.safeString(parameters, "wallet", "exchange"); // exchange, margin
        parameters = this.omit(parameters, "wallet");
        object messageHash = add("balance:", balanceType);
        return await this.subscribePrivate(messageHash);
    }

    public virtual void handleBalance(WebSocketClient client, object message, object subscription)
    {
        //
        // snapshot (exchange + margin together)
        //   [
        //       0,
        //       "ws",
        //       [
        //           [
        //               "exchange",
        //               "LTC",
        //               0.05479727,
        //               0,
        //               null,
        //               "Trading fees for 0.05 LTC (LTCUST) @ 51.872 on BFX (0.2%)",
        //               null,
        //           ]
        //           [
        //               "margin",
        //               "USTF0",
        //               11.960650700086292,
        //               0,
        //               null,
        //               "Trading fees for 0.1 LTCF0 (LTCF0:USTF0) @ 51.844 on BFX (0.065%)",
        //               null,
        //           ],
        //       ],
        //   ]
        //
        // spot
        //   [
        //       0,
        //       "wu",
        //       [
        //         "exchange",
        //         "LTC", // currency
        //         0.06729727, // wallet balance
        //         0, // unsettled balance
        //         0.06729727, // available balance might be null
        //         "Exchange 0.4 LTC for UST @ 65.075",
        //         {
        //           "reason": "TRADE",
        //           "order_id": 96596397973,
        //           "order_id_oppo": 96596632735,
        //           "trade_price": "65.075",
        //           "trade_amount": "-0.4",
        //           "order_cid": 1654636218766,
        //           "order_gid": null
        //         }
        //       ]
        //   ]
        //
        // margin
        //
        //   [
        //       "margin",
        //       "USTF0",
        //       11.960650700086292, // total
        //       0,
        //       6.776250700086292, // available
        //       "Trading fees for 0.1 LTCF0 (LTCF0:USTF0) @ 51.844 on BFX (0.065%)",
        //       null
        //   ]
        //
        object updateType = this.safeValue(message, 1);
        object data = null;
        if (isTrue(isEqual(updateType, "ws")))
        {
            data = this.safeValue(message, 2);
        } else
        {
            data = new List<object> {this.safeValue(message, 2)};
        }
        object updatedTypes = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object rawBalance = getValue(data, i);
            object currencyId = this.safeString(rawBalance, 1);
            object code = this.safeCurrencyCode(currencyId);
            object balance = this.parseWsBalance(rawBalance);
            object balanceType = this.safeString(rawBalance, 0);
            object oldBalance = this.safeValue(this.balance, balanceType, new Dictionary<string, object>() {});
            ((IDictionary<string,object>)oldBalance)[(string)code] = balance;
            ((IDictionary<string,object>)oldBalance)["info"] = message;
            ((IDictionary<string,object>)this.balance)[(string)balanceType] = this.safeBalance(oldBalance);
            ((IDictionary<string,object>)updatedTypes)[(string)balanceType] = true;
        }
        object updatesKeys = new List<object>(((IDictionary<string,object>)updatedTypes).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(updatesKeys)); postFixIncrement(ref i))
        {
            object type = getValue(updatesKeys, i);
            object messageHash = add("balance:", type);
            callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, type), messageHash});
        }
    }

    public virtual object parseWsBalance(object balance)
    {
        //
        //     [
        //         "exchange",
        //         "LTC",
        //         0.05479727, // balance
        //         0,
        //         null, // available null if not calculated yet
        //         "Trading fees for 0.05 LTC (LTCUST) @ 51.872 on BFX (0.2%)",
        //         null,
        //     ]
        //
        object totalBalance = this.safeString(balance, 2);
        object availableBalance = this.safeString(balance, 4);
        object account = this.account();
        if (isTrue(!isEqual(availableBalance, null)))
        {
            ((IDictionary<string,object>)account)["free"] = availableBalance;
        }
        ((IDictionary<string,object>)account)["total"] = totalBalance;
        return account;
    }

    public virtual object handleSystemStatus(WebSocketClient client, object message)
    {
        //
        //     {
        //         "event": "info",
        //         "version": 2,
        //         "serverId": "e293377e-7bb7-427e-b28c-5db045b2c1d1",
        //         "platform": { status: 1 }, // 1 for operative, 0 for maintenance
        //     }
        //
        return message;
    }

    public virtual object handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //     {
        //         "event": "subscribed",
        //         "channel": "book",
        //         "chanId": 67473,
        //         "symbol": "tBTCUSD",
        //         "prec": "P0",
        //         "freq": "F0",
        //         "len": "25",
        //         "pair": "BTCUSD"
        //     }
        //
        object channelId = this.safeString(message, "chanId");
        ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)channelId] = message;
        return message;
    }

    public async virtual Task<object> authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "private");
        var client = this.client(url);
        object messageHash = "authenticated";
        var future = client.future(messageHash);
        object authenticated = this.safeValue(((WebSocketClient)client).subscriptions, messageHash);
        if (isTrue(isEqual(authenticated, null)))
        {
            object nonce = this.milliseconds();
            object payload = add("AUTH", ((object)nonce).ToString());
            object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha384, "hex");
            object eventVar = "auth";
            object request = new Dictionary<string, object>() {
                { "apiKey", this.apiKey },
                { "authSig", signature },
                { "authNonce", nonce },
                { "authPayload", payload },
                { "event", eventVar },
            };
            object message = this.extend(request, parameters);
            this.watch(url, messageHash, message, messageHash);
        }
        return future;
    }

    public virtual void handleAuthenticationMessage(WebSocketClient client, object message)
    {
        object messageHash = "authenticated";
        object status = this.safeString(message, "status");
        if (isTrue(isEqual(status, "OK")))
        {
            // we resolve the future here permanently so authentication only happens once
            var future = this.safeValue((client as WebSocketClient).futures, messageHash);
            (future as Future).resolve(true);
        } else
        {
            var error = new AuthenticationError(this.json(message));
            ((WebSocketClient)client).reject(error, messageHash);
            // allows further authentication attempts
            if (isTrue(inOp(((WebSocketClient)client).subscriptions, messageHash)))
            {

            }
        }
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex2#watchOrders
        * @description watches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object messageHash = "orders";
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            messageHash = add(messageHash, add(":", getValue(market, "id")));
        }
        object orders = await this.subscribePrivate(messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleOrders(WebSocketClient client, object message, object subscription)
    {
        //
        // limit order
        //    [
        //        0,
        //        "on", // ou or oc
        //        [
        //           96923856256, // order id
        //           null, // gid
        //           1655029337026, // cid
        //           "tLTCUST", // symbol
        //           1655029337027, // created timestamp
        //           1655029337029, // updated timestamp
        //           0.1, // amount
        //           0.1, // amount_orig
        //           "EXCHANGE LIMIT", // order type
        //           null, // type_prev
        //           null, // mts_tif
        //           null, // placeholder
        //           0, // flags
        //           "ACTIVE", // status
        //           null,
        //           null,
        //           30, // price
        //           0, // price average
        //           0, // price_trailling
        //           0, // price_aux_limit
        //           null,
        //           null,
        //           null,
        //           0, // notify
        //           0,
        //           null,
        //           null,
        //           null,
        //           "BFX",
        //           null,
        //           null,
        //        ]
        //    ]
        //
        object data = this.safeValue(message, 2, new List<object>() {});
        object messageType = this.safeString(message, 1);
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object orders = this.orders;
        object symbolIds = new Dictionary<string, object>() {};
        if (isTrue(isEqual(messageType, "os")))
        {
            object snapshotLength = getArrayLength(data);
            if (isTrue(isEqual(snapshotLength, 0)))
            {
                return;
            }
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object value = getValue(data, i);
                object parsed = this.parseWsOrder(value);
                object symbol = getValue(parsed, "symbol");
                ((IDictionary<string,object>)symbolIds)[(string)symbol] = true;
                callDynamically(orders, "append", new object[] {parsed});
            }
        } else
        {
            object parsed = this.parseWsOrder(data);
            callDynamically(orders, "append", new object[] {parsed});
            object symbol = getValue(parsed, "symbol");
            ((IDictionary<string,object>)symbolIds)[(string)symbol] = true;
        }
        object name = "orders";
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, name});
        object keys = new List<object>(((IDictionary<string,object>)symbolIds).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object symbol = getValue(keys, i);
            object market = this.market(symbol);
            object messageHash = add(add(name, ":"), getValue(market, "id"));
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageHash});
        }
    }

    public virtual object parseWsOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "ACTIVE", "open" },
            { "CANCELED", "canceled" },
            { "EXECUTED", "closed" },
            { "PARTIALLY", "open" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        //   [
        //       97084883506, // order id
        //       null,
        //       1655110144596, // clientOrderId
        //       "tLTCUST", // symbol
        //       1655110144596, // created timestamp
        //       1655110144598, // updated timestamp
        //       0, // amount
        //       0.1, // amount_orig negative if sell order
        //       "EXCHANGE MARKET", // type
        //       null,
        //       null,
        //       null,
        //       0,
        //       "EXECUTED @ 42.821(0.1)", // status
        //       null,
        //       null,
        //       42.799, // price
        //       42.821, // price average
        //       0, // price trailling
        //       0, // price_aux_limit
        //       null,
        //       null,
        //       null,
        //       0,
        //       0,
        //       null,
        //       null,
        //       null,
        //       "BFX",
        //       null,
        //       null,
        //       {}
        //   ]
        //
        object id = this.safeString(order, 0);
        object clientOrderId = this.safeString(order, 1);
        object marketId = this.safeString(order, 3);
        object symbol = this.safeSymbol(marketId);
        market = this.safeMarket(symbol);
        object amount = this.safeString(order, 7);
        object side = "buy";
        if (isTrue(Precise.stringLt(amount, "0")))
        {
            amount = Precise.stringAbs(amount);
            side = "sell";
        }
        object remaining = Precise.stringAbs(this.safeString(order, 6));
        object type = this.safeString(order, 8);
        if (isTrue(isGreaterThan(getIndexOf(type, "LIMIT"), -1)))
        {
            type = "limit";
        } else if (isTrue(isGreaterThan(getIndexOf(type, "MARKET"), -1)))
        {
            type = "market";
        }
        object rawState = this.safeString(order, 13);
        object stateParts = ((string)rawState).Split(new [] {((string)" ")}, StringSplitOptions.None).ToList<object>();
        object trimmedStatus = this.safeString(stateParts, 0);
        object status = this.parseWsOrderStatus(trimmedStatus);
        object price = this.safeString(order, 16);
        object timestamp = this.safeInteger2(order, 5, 4);
        object average = this.safeString(order, 17);
        object stopPrice = this.omitZero(this.safeString(order, 18));
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", symbol },
            { "type", type },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "average", average },
            { "amount", amount },
            { "remaining", remaining },
            { "filled", null },
            { "status", status },
            { "fee", null },
            { "cost", null },
            { "trades", null },
        }, market);
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        object channelId = this.safeString(message, 0);
        //
        //     [
        //         1231,
        //         "hb",
        //     ]
        //
        // auth message
        //    {
        //        "event": "auth",
        //        "status": "OK",
        //        "chanId": 0,
        //        "userId": 3159883,
        //        "auth_id": "ac7108e7-2f26-424d-9982-c24700dc02ca",
        //        "caps": {
        //          "orders": { read: 1, write: 1 },
        //          "account": { read: 1, write: 1 },
        //          "funding": { read: 1, write: 1 },
        //          "history": { read: 1, write: 0 },
        //          "wallets": { read: 1, write: 1 },
        //          "withdraw": { read: 0, write: 1 },
        //          "positions": { read: 1, write: 1 },
        //          "ui_withdraw": { read: 0, write: 0 }
        //        }
        //    }
        //
        if (isTrue(((message is IList<object>) || (message.GetType().IsGenericType && message.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            if (isTrue(isEqual(getValue(message, 1), "hb")))
            {
                return;  // skip heartbeats within subscription channels for now
            }
            object subscription = this.safeValue(((WebSocketClient)client).subscriptions, channelId, new Dictionary<string, object>() {});
            object channel = this.safeString(subscription, "channel");
            object name = this.safeString(message, 1);
            object publicMethods = new Dictionary<string, object>() {
                { "book", this.handleOrderBook },
                { "cs", this.handleChecksum },
                { "candles", this.handleOHLCV },
                { "ticker", this.handleTicker },
                { "trades", this.handleTrades },
            };
            object privateMethods = new Dictionary<string, object>() {
                { "os", this.handleOrders },
                { "ou", this.handleOrders },
                { "on", this.handleOrders },
                { "oc", this.handleOrders },
                { "wu", this.handleBalance },
                { "ws", this.handleBalance },
                { "tu", this.handleMyTrade },
            };
            object method = null;
            if (isTrue(isEqual(channelId, "0")))
            {
                method = this.safeValue(privateMethods, name);
            } else
            {
                method = this.safeValue2(publicMethods, name, channel);
            }
            if (isTrue(!isEqual(method, null)))
            {
                DynamicInvoker.InvokeMethod(method, new object[] { client, message, subscription});
            }
        } else
        {
            object eventVar = this.safeString(message, "event");
            if (isTrue(!isEqual(eventVar, null)))
            {
                object methods = new Dictionary<string, object>() {
                    { "info", this.handleSystemStatus },
                    { "subscribed", this.handleSubscriptionStatus },
                    { "auth", this.handleAuthenticationMessage },
                };
                object method = this.safeValue(methods, eventVar);
                if (isTrue(!isEqual(method, null)))
                {
                    DynamicInvoker.InvokeMethod(method, new object[] { client, message});
                }
            }
        }
    }
}
