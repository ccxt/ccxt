namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class binance { public binance(object args = null) : base(args) { } }
public partial class binance : ccxt.binance
{
    public override object describe()
    {
        object superDescribe = base.describe();
        return this.deepExtend(superDescribe, this.describeData());
    }

    public virtual object describeData()
    {
        return new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchBalance", true },
                { "watchLiquidations", true },
                { "watchLiquidationsForSymbols", true },
                { "watchMyLiquidations", true },
                { "watchMyLiquidationsForSymbols", true },
                { "watchBidsAsks", true },
                { "watchMyTrades", true },
                { "watchOHLCV", true },
                { "watchOHLCVForSymbols", true },
                { "watchOrderBook", true },
                { "watchOrderBookForSymbols", true },
                { "watchOrders", true },
                { "watchOrdersForSymbols", true },
                { "watchPositions", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchMarkPrices", true },
                { "watchMarkPrice", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
                { "createOrderWs", true },
                { "editOrderWs", true },
                { "cancelOrderWs", true },
                { "cancelOrdersWs", false },
                { "cancelAllOrdersWs", true },
                { "fetchBalanceWs", true },
                { "fetchDepositsWs", false },
                { "fetchMarketsWs", false },
                { "fetchMyTradesWs", true },
                { "fetchOHLCVWs", true },
                { "fetchOrderBookWs", true },
                { "fetchOpenOrdersWs", true },
                { "fetchOrderWs", true },
                { "fetchOrdersWs", true },
                { "fetchPositionWs", true },
                { "fetchPositionForSymbolWs", true },
                { "fetchPositionsWs", true },
                { "fetchTickerWs", true },
                { "fetchTradesWs", true },
                { "fetchTradingFeesWs", false },
                { "fetchWithdrawalsWs", false },
            } },
            { "urls", new Dictionary<string, object>() {
                { "test", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "spot", "wss://stream.testnet.binance.vision/ws" },
                        { "margin", "wss://stream.testnet.binance.vision/ws" },
                        { "future", "wss://fstream.binancefuture.com/ws" },
                        { "delivery", "wss://dstream.binancefuture.com/ws" },
                        { "ws-api", new Dictionary<string, object>() {
                            { "spot", "wss://ws-api.testnet.binance.vision/ws-api/v3" },
                            { "future", "wss://testnet.binancefuture.com/ws-fapi/v1" },
                            { "delivery", "wss://testnet.binancefuture.com/ws-dapi/v1" },
                        } },
                    } },
                } },
                { "demo", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "spot", "wss://demo-stream.binance.com/ws" },
                        { "margin", "wss://demo-stream.binance.com/ws" },
                        { "future", "wss://fstream.binancefuture.com/ws" },
                        { "delivery", "wss://dstream.binancefuture.com/ws" },
                        { "ws-api", new Dictionary<string, object>() {
                            { "spot", "wss://demo-ws-api.binance.com/ws-api/v3" },
                            { "future", "wss://testnet.binancefuture.com/ws-fapi/v1" },
                            { "delivery", "wss://testnet.binancefuture.com/ws-dapi/v1" },
                        } },
                    } },
                } },
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "spot", "wss://stream.binance.com:9443/ws" },
                        { "margin", "wss://stream.binance.com:9443/ws" },
                        { "future", "wss://fstream.binance.com/ws" },
                        { "delivery", "wss://dstream.binance.com/ws" },
                        { "ws-api", new Dictionary<string, object>() {
                            { "spot", "wss://ws-api.binance.com:443/ws-api/v3" },
                            { "future", "wss://ws-fapi.binance.com/ws-fapi/v1" },
                            { "delivery", "wss://ws-dapi.binance.com/ws-dapi/v1" },
                        } },
                        { "papi", "wss://fstream.binance.com/pm/ws" },
                    } },
                } },
                { "doc", "https://developers.binance.com/en" },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "keepAlive", 180000 },
            } },
            { "options", new Dictionary<string, object>() {
                { "returnRateLimits", false },
                { "streamLimits", new Dictionary<string, object>() {
                    { "spot", 50 },
                    { "margin", 50 },
                    { "future", 50 },
                    { "delivery", 50 },
                } },
                { "subscriptionLimitByStream", new Dictionary<string, object>() {
                    { "spot", 200 },
                    { "margin", 200 },
                    { "future", 200 },
                    { "delivery", 200 },
                } },
                { "streamBySubscriptionsHash", this.createSafeDictionary() },
                { "streamIndex", -1 },
                { "watchOrderBookRate", 100 },
                { "liquidationsLimit", 1000 },
                { "myLiquidationsLimit", 1000 },
                { "tradesLimit", 1000 },
                { "ordersLimit", 1000 },
                { "OHLCVLimit", 1000 },
                { "requestId", this.createSafeDictionary() },
                { "watchOrderBookLimit", 1000 },
                { "watchTrades", new Dictionary<string, object>() {
                    { "name", "trade" },
                } },
                { "watchTicker", new Dictionary<string, object>() {
                    { "name", "ticker" },
                } },
                { "watchTickers", new Dictionary<string, object>() {
                    { "name", "ticker" },
                } },
                { "watchOHLCV", new Dictionary<string, object>() {
                    { "name", "kline" },
                } },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "maxRetries", 3 },
                    { "checksum", true },
                } },
                { "watchBalance", new Dictionary<string, object>() {
                    { "fetchBalanceSnapshot", false },
                    { "awaitBalanceSnapshot", true },
                } },
                { "watchLiquidationsForSymbols", new Dictionary<string, object>() {
                    { "defaultType", "swap" },
                } },
                { "watchPositions", new Dictionary<string, object>() {
                    { "fetchPositionsSnapshot", true },
                    { "awaitPositionsSnapshot", true },
                } },
                { "wallet", "wb" },
                { "listenKeyRefreshRate", 1200000 },
                { "ws", new Dictionary<string, object>() {
                    { "cost", 5 },
                } },
                { "tickerChannelsMap", new Dictionary<string, object>() {
                    { "24hrTicker", "ticker" },
                    { "24hrMiniTicker", "miniTicker" },
                    { "markPriceUpdate", "markPrice" },
                    { "1hTicker", "ticker_1h" },
                    { "4hTicker", "ticker_4h" },
                    { "1dTicker", "ticker_1d" },
                    { "bookTicker", "bookTicker" },
                } },
            } },
        };
    }

    public virtual object requestId(object url)
    {
        object options = this.safeDict(this.options, "requestId", this.createSafeDictionary());
        object previousValue = this.safeInteger(options, url, 0);
        object newValue = this.sum(previousValue, 1);
        ((IDictionary<string,object>)getValue(this.options, "requestId"))[(string)url] = newValue;
        return newValue;
    }

    public virtual object isSpotUrl(WebSocketClient client)
    {
        return isTrue((isGreaterThan(getIndexOf(client.url, "/stream"), -1))) || isTrue((isGreaterThan(getIndexOf(client.url, "demo-stream"), -1)));
    }

    public virtual object stream(object type, object subscriptionHash, object numSubscriptions = null)
    {
        numSubscriptions ??= 1;
        object streamBySubscriptionsHash = this.safeDict(this.options, "streamBySubscriptionsHash", this.createSafeDictionary());
        object stream = this.safeString(streamBySubscriptionsHash, subscriptionHash);
        if (isTrue(isEqual(stream, null)))
        {
            object streamIndex = this.safeInteger(this.options, "streamIndex", -1);
            object streamLimits = this.safeValue(this.options, "streamLimits");
            object streamLimit = this.safeInteger(streamLimits, type);
            streamIndex = add(streamIndex, 1);
            object normalizedIndex = mod(streamIndex, streamLimit);
            ((IDictionary<string,object>)this.options)["streamIndex"] = streamIndex;
            stream = this.numberToString(normalizedIndex);
            ((IDictionary<string,object>)getValue(this.options, "streamBySubscriptionsHash"))[(string)subscriptionHash] = stream;
            object subscriptionsByStreams = this.safeValue(this.options, "numSubscriptionsByStream");
            if (isTrue(isEqual(subscriptionsByStreams, null)))
            {
                ((IDictionary<string,object>)this.options)["numSubscriptionsByStream"] = this.createSafeDictionary();
            }
            object subscriptionsByStream = this.safeInteger(getValue(this.options, "numSubscriptionsByStream"), stream, 0);
            object newNumSubscriptions = add(subscriptionsByStream, numSubscriptions);
            object subscriptionLimitByStream = this.safeInteger(getValue(this.options, "subscriptionLimitByStream"), type, 200);
            if (isTrue(isGreaterThan(newNumSubscriptions, subscriptionLimitByStream)))
            {
                throw new BadRequest ((string)add(this.id, " reached the limit of subscriptions by stream. Increase the number of streams, or increase the stream limit or subscription limit by stream if the exchange allows.")) ;
            }
            ((IDictionary<string,object>)getValue(this.options, "numSubscriptionsByStream"))[(string)stream] = add(subscriptionsByStream, numSubscriptions);
        }
        return stream;
    }

    /**
     * @method
     * @name binance#watchLiquidations
     * @description watch the public liquidations of a trading pair
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Liquidation-Order-Streams
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Liquidation-Order-Streams
     * @param {string} symbol unified CCXT market symbol
     * @param {int} [since] the earliest time in ms to fetch liquidations for
     * @param {int} [limit] the maximum number of liquidation structures to retrieve
     * @param {object} [params] exchange specific parameters for the bitmex api endpoint
     * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
     */
    public async override Task<object> watchLiquidations(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.watchLiquidationsForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    /**
     * @method
     * @name binance#watchLiquidationsForSymbols
     * @description watch the public liquidations of a trading pair
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-Market-Liquidation-Order-Streams
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-Market-Liquidation-Order-Streams
     * @param {string[]} symbols list of unified market symbols
     * @param {int} [since] the earliest time in ms to fetch liquidations for
     * @param {int} [limit] the maximum number of liquidation structures to retrieve
     * @param {object} [params] exchange specific parameters for the bitmex api endpoint
     * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
     */
    public async override Task<object> watchLiquidationsForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object subscriptionHashes = new List<object>() {};
        object messageHashes = new List<object>() {};
        object streamHash = "liquidations";
        symbols = this.marketSymbols(symbols, null, true, true);
        if (isTrue(this.isEmpty(symbols)))
        {
            ((IList<object>)subscriptionHashes).Add(add("!", "forceOrder@arr"));
            ((IList<object>)messageHashes).Add("liquidations");
        } else
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object market = this.market(getValue(symbols, i));
                ((IList<object>)subscriptionHashes).Add(add(getValue(market, "lowercaseId"), "@forceOrder"));
                ((IList<object>)messageHashes).Add(add("liquidations::", getValue(symbols, i)));
            }
            streamHash = add(streamHash, add("::", String.Join(",", ((IList<object>)symbols).ToArray())));
        }
        object firstMarket = this.getMarketFromSymbols(symbols);
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchLiquidationsForSymbols", firstMarket, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            throw new BadRequest ((string)add(this.id, " watchLiquidationsForSymbols is not supported for spot symbols")) ;
        }
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchLiquidationsForSymbols", firstMarket, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(this.isLinear(type, subType)))
        {
            type = "future";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            type = "delivery";
        }
        object numSubscriptions = getArrayLength(subscriptionHashes);
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "/"), this.stream(type, streamHash, numSubscriptions));
        object requestId = this.requestId(url);
        object request = new Dictionary<string, object>() {
            { "method", "SUBSCRIBE" },
            { "params", subscriptionHashes },
            { "id", requestId },
        };
        object subscribe = new Dictionary<string, object>() {
            { "id", requestId },
        };
        object newLiquidations = await this.watchMultiple(url, messageHashes, this.extend(request, parameters), subscriptionHashes, subscribe);
        if (isTrue(this.newUpdates))
        {
            return newLiquidations;
        }
        return this.filterBySymbolsSinceLimit(this.liquidations, symbols, since, limit, true);
    }

    public virtual void handleLiquidation(WebSocketClient client, object message)
    {
        //
        // future
        //    {
        //        "e":"forceOrder",
        //        "E":1698871323061,
        //        "o":{
        //           "s":"BTCUSDT",
        //           "S":"BUY",
        //           "o":"LIMIT",
        //           "f":"IOC",
        //           "q":"1.437",
        //           "p":"35100.81",
        //           "ap":"34959.70",
        //           "X":"FILLED",
        //           "l":"1.437",
        //           "z":"1.437",
        //           "T":1698871323059
        //        }
        //    }
        // delivery
        //    {
        //        "e":"forceOrder",              // Event Type
        //        "E": 1591154240950,            // Event Time
        //        "o":{
        //            "s":"BTCUSD_200925",       // Symbol
        //            "ps": "BTCUSD",            // Pair
        //            "S":"SELL",                // Side
        //            "o":"LIMIT",               // Order Type
        //            "f":"IOC",                 // Time in Force
        //            "q":"1",                   // Original Quantity
        //            "p":"9425.5",              // Price
        //            "ap":"9496.5",             // Average Price
        //            "X":"FILLED",              // Order Status
        //            "l":"1",                   // Order Last Filled Quantity
        //            "z":"1",                   // Order Filled Accumulated Quantity
        //            "T": 1591154240949,        // Order Trade Time
        //        }
        //    }
        //
        object rawLiquidation = this.safeValue(message, "o", new Dictionary<string, object>() {});
        object marketId = this.safeString(rawLiquidation, "s");
        object market = this.safeMarket(marketId, null, "", "contract");
        object symbol = getValue(market, "symbol");
        object liquidation = this.parseWsLiquidation(rawLiquidation, market);
        object liquidations = this.safeValue(this.liquidations, symbol);
        if (isTrue(isEqual(liquidations, null)))
        {
            object limit = this.safeInteger(this.options, "liquidationsLimit", 1000);
            liquidations = new ArrayCache(limit);
        }
        callDynamically(liquidations, "append", new object[] {liquidation});
        ((IDictionary<string,object>)this.liquidations)[(string)symbol] = liquidations;
        callDynamically(client as WebSocketClient, "resolve", new object[] {new List<object>() {liquidation}, "liquidations"});
        callDynamically(client as WebSocketClient, "resolve", new object[] {new List<object>() {liquidation}, add("liquidations::", symbol)});
    }

    public virtual object parseWsLiquidation(object liquidation, object market = null)
    {
        //
        // future
        //    {
        //        "s":"BTCUSDT",
        //        "S":"BUY",
        //        "o":"LIMIT",
        //        "f":"IOC",
        //        "q":"1.437",
        //        "p":"35100.81",
        //        "ap":"34959.70",
        //        "X":"FILLED",
        //        "l":"1.437",
        //        "z":"1.437",
        //        "T":1698871323059
        //    }
        // delivery
        //    {
        //        "s":"BTCUSD_200925",       // Symbol
        //        "ps": "BTCUSD",            // Pair
        //        "S":"SELL",                // Side
        //        "o":"LIMIT",               // Order Type
        //        "f":"IOC",                 // Time in Force
        //        "q":"1",                   // Original Quantity
        //        "p":"9425.5",              // Price
        //        "ap":"9496.5",             // Average Price
        //        "X":"FILLED",              // Order Status
        //        "l":"1",                   // Order Last Filled Quantity
        //        "z":"1",                   // Order Filled Accumulated Quantity
        //        "T": 1591154240949,        // Order Trade Time
        //    }
        // myLiquidation
        //    {
        //        "s":"BTCUSDT",              // Symbol
        //        "c":"TEST",                 // Client Order Id
        //          // special client order id:
        //          // starts with "autoclose-": liquidation order
        //          // "adl_autoclose": ADL auto close order
        //          // "settlement_autoclose-": settlement order for delisting or delivery
        //        "S":"SELL",                 // Side
        //        "o":"TRAILING_STOP_MARKET", // Order Type
        //        "f":"GTC",                  // Time in Force
        //        "q":"0.001",                // Original Quantity
        //        "p":"0",                    // Original Price
        //        "ap":"0",                   // Average Price
        //        "sp":"7103.04",             // Stop Price. Please ignore with TRAILING_STOP_MARKET order
        //        "x":"NEW",                  // Execution Type
        //        "X":"NEW",                  // Order Status
        //        "i":8886774,                // Order Id
        //        "l":"0",                    // Order Last Filled Quantity
        //        "z":"0",                    // Order Filled Accumulated Quantity
        //        "L":"0",                    // Last Filled Price
        //        "N":"USDT",                 // Commission Asset, will not push if no commission
        //        "n":"0",                    // Commission, will not push if no commission
        //        "T":1568879465650,          // Order Trade Time
        //        "t":0,                      // Trade Id
        //        "b":"0",                    // Bids Notional
        //        "a":"9.91",                 // Ask Notional
        //        "m":false,                  // Is this trade the maker side?
        //        "R":false,                  // Is this reduce only
        //        "wt":"CONTRACT_PRICE",      // Stop Price Working Type
        //        "ot":"TRAILING_STOP_MARKET",// Original Order Type
        //        "ps":"LONG",                // Position Side
        //        "cp":false,                 // If Close-All, pushed with conditional order
        //        "AP":"7476.89",             // Activation Price, only puhed with TRAILING_STOP_MARKET order
        //        "cr":"5.0",                 // Callback Rate, only puhed with TRAILING_STOP_MARKET order
        //        "pP": false,                // If price protection is turned on
        //        "si": 0,                    // ignore
        //        "ss": 0,                    // ignore
        //        "rp":"0",                   // Realized Profit of the trade
        //        "V":"EXPIRE_TAKER",         // STP mode
        //        "pm":"OPPONENT",            // Price match mode
        //        "gtd":0                     // TIF GTD order auto cancel time
        //    }
        //
        object marketId = this.safeString(liquidation, "s");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(liquidation, "T");
        return this.safeLiquidation(new Dictionary<string, object>() {
            { "info", liquidation },
            { "symbol", this.safeSymbol(marketId, market) },
            { "contracts", this.safeNumber(liquidation, "l") },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "price", this.safeNumber(liquidation, "ap") },
            { "side", this.safeStringLower(liquidation, "S") },
            { "baseValue", null },
            { "quoteValue", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        });
    }

    /**
     * @method
     * @name binance#watchMyLiquidations
     * @description watch the private liquidations of a trading pair
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/user-data-streams/Event-Order-Update
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/user-data-streams/Event-Order-Update
     * @param {string} symbol unified CCXT market symbol
     * @param {int} [since] the earliest time in ms to fetch liquidations for
     * @param {int} [limit] the maximum number of liquidation structures to retrieve
     * @param {object} [params] exchange specific parameters for the bitmex api endpoint
     * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
     */
    public async override Task<object> watchMyLiquidations(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return this.watchMyLiquidationsForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    /**
     * @method
     * @name binance#watchMyLiquidationsForSymbols
     * @description watch the private liquidations of a trading pair
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/user-data-streams/Event-Order-Update
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/user-data-streams/Event-Order-Update
     * @param {string[]} symbols list of unified market symbols
     * @param {int} [since] the earliest time in ms to fetch liquidations for
     * @param {int} [limit] the maximum number of liquidation structures to retrieve
     * @param {object} [params] exchange specific parameters for the bitmex api endpoint
     * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
     */
    public async override Task<object> watchMyLiquidationsForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, true, true, true);
        object market = this.getMarketFromSymbols(symbols);
        object messageHashes = new List<object>() {"myLiquidations"};
        if (!isTrue(this.isEmpty(symbols)))
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                ((IList<object>)messageHashes).Add(add("myLiquidations::", symbol));
            }
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchMyLiquidationsForSymbols", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchMyLiquidationsForSymbols", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(this.isLinear(type, subType)))
        {
            type = "future";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            type = "delivery";
        }
        await this.authenticate(parameters);
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "/"), getValue(getValue(this.options, type), "listenKey"));
        object message = null;
        object newLiquidations = await this.watchMultiple(url, messageHashes, message, new List<object>() {type});
        if (isTrue(this.newUpdates))
        {
            return newLiquidations;
        }
        return this.filterBySymbolsSinceLimit(this.liquidations, symbols, since, limit);
    }

    public virtual void handleMyLiquidation(WebSocketClient client, object message)
    {
        //
        //    {
        //        "s":"BTCUSDT",              // Symbol
        //        "c":"TEST",                 // Client Order Id
        //          // special client order id:
        //          // starts with "autoclose-": liquidation order
        //          // "adl_autoclose": ADL auto close order
        //          // "settlement_autoclose-": settlement order for delisting or delivery
        //        "S":"SELL",                 // Side
        //        "o":"TRAILING_STOP_MARKET", // Order Type
        //        "f":"GTC",                  // Time in Force
        //        "q":"0.001",                // Original Quantity
        //        "p":"0",                    // Original Price
        //        "ap":"0",                   // Average Price
        //        "sp":"7103.04",             // Stop Price. Please ignore with TRAILING_STOP_MARKET order
        //        "x":"NEW",                  // Execution Type
        //        "X":"NEW",                  // Order Status
        //        "i":8886774,                // Order Id
        //        "l":"0",                    // Order Last Filled Quantity
        //        "z":"0",                    // Order Filled Accumulated Quantity
        //        "L":"0",                    // Last Filled Price
        //        "N":"USDT",                 // Commission Asset, will not push if no commission
        //        "n":"0",                    // Commission, will not push if no commission
        //        "T":1568879465650,          // Order Trade Time
        //        "t":0,                      // Trade Id
        //        "b":"0",                    // Bids Notional
        //        "a":"9.91",                 // Ask Notional
        //        "m":false,                  // Is this trade the maker side?
        //        "R":false,                  // Is this reduce only
        //        "wt":"CONTRACT_PRICE",      // Stop Price Working Type
        //        "ot":"TRAILING_STOP_MARKET",// Original Order Type
        //        "ps":"LONG",                // Position Side
        //        "cp":false,                 // If Close-All, pushed with conditional order
        //        "AP":"7476.89",             // Activation Price, only puhed with TRAILING_STOP_MARKET order
        //        "cr":"5.0",                 // Callback Rate, only puhed with TRAILING_STOP_MARKET order
        //        "pP": false,                // If price protection is turned on
        //        "si": 0,                    // ignore
        //        "ss": 0,                    // ignore
        //        "rp":"0",                   // Realized Profit of the trade
        //        "V":"EXPIRE_TAKER",         // STP mode
        //        "pm":"OPPONENT",            // Price match mode
        //        "gtd":0                     // TIF GTD order auto cancel time
        //    }
        //
        object orderType = this.safeString(message, "o");
        if (isTrue(!isEqual(orderType, "LIQUIDATION")))
        {
            return;
        }
        object marketId = this.safeString(message, "s");
        object market = this.safeMarket(marketId);
        object symbol = this.safeSymbol(marketId);
        object liquidation = this.parseWsLiquidation(message, market);
        object myLiquidations = this.safeValue(this.myLiquidations, symbol);
        if (isTrue(isEqual(myLiquidations, null)))
        {
            object limit = this.safeInteger(this.options, "myLiquidationsLimit", 1000);
            myLiquidations = new ArrayCache(limit);
        }
        callDynamically(myLiquidations, "append", new object[] {liquidation});
        ((IDictionary<string,object>)this.myLiquidations)[(string)symbol] = myLiquidations;
        callDynamically(client as WebSocketClient, "resolve", new object[] {new List<object>() {liquidation}, "myLiquidations"});
        callDynamically(client as WebSocketClient, "resolve", new object[] {new List<object>() {liquidation}, add("myLiquidations::", symbol)});
    }

    /**
     * @method
     * @name binance#watchOrderBook
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#partial-book-depth-streams
     * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#diff-depth-stream
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        //
        // todo add support for <levels>-snapshots (depth)
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/web-socket-streams.md#partial-book-depth-streams        // <symbol>@depth<levels>@100ms or <symbol>@depth<levels> (1000ms)
        // valid <levels> are 5, 10, or 20
        //
        // default 100, max 1000, valid limits 5, 10, 20, 50, 100, 500, 1000
        //
        // notice the differences between trading futures and spot trading
        // the algorithms use different urls in step 1
        // delta caching and merging also differs in steps 4, 5, 6
        //
        // spot/margin
        // https://binance-docs.github.io/apidocs/spot/en/#how-to-manage-a-local-order-book-correctly
        //
        // 1. Open a stream to wss://stream.binance.com:9443/ws/bnbbtc@depth.
        // 2. Buffer the events you receive from the stream.
        // 3. Get a depth snapshot from https://www.binance.com/api/v1/depth?symbol=BNBBTC&limit=1000 .
        // 4. Drop any event where u is <= lastUpdateId in the snapshot.
        // 5. The first processed event should have U <= lastUpdateId+1 AND u >= lastUpdateId+1.
        // 6. While listening to the stream, each new event's U should be equal to the previous event's u+1.
        // 7. The data in each event is the absolute quantity for a price level.
        // 8. If the quantity is 0, remove the price level.
        // 9. Receiving an event that removes a price level that is not in your local order book can happen and is normal.
        //
        // futures
        // https://binance-docs.github.io/apidocs/futures/en/#how-to-manage-a-local-order-book-correctly
        //
        // 1. Open a stream to wss://fstream.binance.com/stream?streams=btcusdt@depth.
        // 2. Buffer the events you receive from the stream. For same price, latest received update covers the previous one.
        // 3. Get a depth snapshot from https://fapi.binance.com/fapi/v1/depth?symbol=BTCUSDT&limit=1000 .
        // 4. Drop any event where u is < lastUpdateId in the snapshot.
        // 5. The first processed event should have U <= lastUpdateId AND u >= lastUpdateId
        // 6. While listening to the stream, each new event's pu should be equal to the previous event's u, otherwise initialize the process from step 3.
        // 7. The data in each event is the absolute quantity for a price level.
        // 8. If the quantity is 0, remove the price level.
        // 9. Receiving an event that removes a price level that is not in your local order book can happen and is normal.
        //
        parameters ??= new Dictionary<string, object>();
        return await this.watchOrderBookForSymbols(new List<object>() {symbol}, limit, parameters);
    }

    /**
     * @method
     * @name binance#watchOrderBookForSymbols
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#partial-book-depth-streams
     * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#diff-depth-stream
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
     * @param {string[]} symbols unified array of symbols
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false, true, true);
        object firstMarket = this.market(getValue(symbols, 0));
        object type = getValue(firstMarket, "type");
        if (isTrue(getValue(firstMarket, "contract")))
        {
            type = ((bool) isTrue(getValue(firstMarket, "linear"))) ? "future" : "delivery";
        }
        object name = "depth";
        object streamHash = "multipleOrderbook";
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(isGreaterThan(symbolsLength, 200)))
            {
                throw new BadRequest ((string)add(this.id, " watchOrderBookForSymbols() accepts 200 symbols at most. To watch more symbols call watchOrderBookForSymbols() multiple times")) ;
            }
            streamHash = add(streamHash, add("::", String.Join(",", ((IList<object>)symbols).ToArray())));
        }
        object watchOrderBookRate = this.safeString(this.options, "watchOrderBookRate", "100");
        object subParams = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = this.market(symbol);
            ((IList<object>)messageHashes).Add(add("orderbook::", symbol));
            object subscriptionHash = add(add(getValue(market, "lowercaseId"), "@"), name);
            object symbolHash = add(add(add(subscriptionHash, "@"), watchOrderBookRate), "ms");
            ((IList<object>)subParams).Add(symbolHash);
        }
        object messageHashesLength = getArrayLength(messageHashes);
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "/"), this.stream(type, streamHash, messageHashesLength));
        object requestId = this.requestId(url);
        object request = new Dictionary<string, object>() {
            { "method", "SUBSCRIBE" },
            { "params", subParams },
            { "id", requestId },
        };
        object subscription = new Dictionary<string, object>() {
            { "id", ((object)requestId).ToString() },
            { "name", name },
            { "symbols", symbols },
            { "method", this.handleOrderBookSubscription },
            { "limit", limit },
            { "type", type },
            { "params", parameters },
        };
        object orderbook = await this.watchMultiple(url, messageHashes, this.extend(request, parameters), messageHashes, subscription);
        return (orderbook as IOrderBook).limit();
    }

    /**
     * @method
     * @name binance#unWatchOrderBookForSymbols
     * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#partial-book-depth-streams
     * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#diff-depth-stream
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
     * @param {string[]} symbols unified array of symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> unWatchOrderBookForSymbols(object symbols, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false, true, true);
        object firstMarket = this.market(getValue(symbols, 0));
        object type = getValue(firstMarket, "type");
        if (isTrue(getValue(firstMarket, "contract")))
        {
            type = ((bool) isTrue(getValue(firstMarket, "linear"))) ? "future" : "delivery";
        }
        object name = "depth";
        object streamHash = "multipleOrderbook";
        if (isTrue(!isEqual(symbols, null)))
        {
            streamHash = add(streamHash, add("::", String.Join(",", ((IList<object>)symbols).ToArray())));
        }
        object watchOrderBookRate = this.safeString(this.options, "watchOrderBookRate", "100");
        object subParams = new List<object>() {};
        object subMessageHashes = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = this.market(symbol);
            ((IList<object>)subMessageHashes).Add(add("orderbook::", symbol));
            ((IList<object>)messageHashes).Add(add("unsubscribe:orderbook:", symbol));
            object subscriptionHash = add(add(getValue(market, "lowercaseId"), "@"), name);
            object symbolHash = add(add(add(subscriptionHash, "@"), watchOrderBookRate), "ms");
            ((IList<object>)subParams).Add(symbolHash);
        }
        object messageHashesLength = getArrayLength(subMessageHashes);
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "/"), this.stream(type, streamHash, messageHashesLength));
        object requestId = this.requestId(url);
        object request = new Dictionary<string, object>() {
            { "method", "UNSUBSCRIBE" },
            { "params", subParams },
            { "id", requestId },
        };
        object subscription = new Dictionary<string, object>() {
            { "unsubscribe", true },
            { "id", ((object)requestId).ToString() },
            { "symbols", symbols },
            { "subMessageHashes", subMessageHashes },
            { "messageHashes", messageHashes },
            { "topic", "orderbook" },
        };
        return await this.watchMultiple(url, messageHashes, this.extend(request, parameters), messageHashes, subscription);
    }

    /**
     * @method
     * @name binance#unWatchOrderBook
     * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#partial-book-depth-streams
     * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#diff-depth-stream
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
     * @param {string} symbol unified array of symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> unWatchOrderBook(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.unWatchOrderBookForSymbols(new List<object>() {symbol}, parameters);
    }

    /**
     * @method
     * @name binance#fetchOrderBookWs
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#order-book
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/websocket-api/Order-Book
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBookWs(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object payload = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)payload)["limit"] = limit;
        }
        object marketType = this.getMarketType("fetchOrderBookWs", market, parameters);
        if (isTrue(!isEqual(marketType, "future")))
        {
            throw new BadRequest ((string)add(this.id, " fetchOrderBookWs only supports swap markets")) ;
        }
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "ws-api"), marketType);
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "createOrderWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        ((IDictionary<string,object>)payload)["returnRateLimits"] = returnRateLimits;
        parameters = this.omit(parameters, "test");
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "depth" },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleFetchOrderBook },
        };
        object orderbook = await this.watch(url, messageHash, message, messageHash, subscription);
        ((IDictionary<string,object>)orderbook)["symbol"] = getValue(market, "symbol");
        return orderbook;
    }

    public virtual void handleFetchOrderBook(WebSocketClient client, object message)
    {
        //
        //    {
        //        "id":"51e2affb-0aba-4821-ba75-f2625006eb43",
        //        "status":200,
        //        "result":{
        //            "lastUpdateId":1027024,
        //            "E":1589436922972,
        //            "T":1589436922959,
        //            "bids":[
        //               [
        //                  "4.00000000",
        //                  "431.00000000"
        //               ]
        //            ],
        //            "asks":[
        //               [
        //                  "4.00000200",
        //                  "12.00000000"
        //               ]
        //            ]
        //        }
        //    }
        //
        object messageHash = this.safeString(message, "id");
        object result = this.safeDict(message, "result");
        object timestamp = this.safeInteger(result, "T");
        object orderbook = this.parseOrderBook(result, null, timestamp);
        ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger2(result, "lastUpdateId", "u");
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public async virtual Task fetchOrderBookSnapshot(WebSocketClient client, object message, object subscription)
    {
        object symbol = this.safeString(subscription, "symbol");
        object messageHash = add("orderbook::", symbol);
        try
        {
            object defaultLimit = this.safeInteger(this.options, "watchOrderBookLimit", 1000);
            object type = this.safeValue(subscription, "type");
            object limit = this.safeInteger(subscription, "limit", defaultLimit);
            object parameters = this.safeValue(subscription, "params");
            // 3. Get a depth snapshot from https://www.binance.com/api/v1/depth?symbol=BNBBTC&limit=1000 .
            // todo: this is a synch blocking call - make it async
            // default 100, max 1000, valid limits 5, 10, 20, 50, 100, 500, 1000
            object snapshot = await this.fetchRestOrderBookSafe(symbol, limit, parameters);
            if (isTrue(isEqual(this.safeValue(this.orderbooks, symbol), null)))
            {
                // if the orderbook is dropped before the snapshot is received
                return;
            }
            object orderbook = getValue(this.orderbooks, symbol);
            (orderbook as IOrderBook).reset(snapshot);
            // unroll the accumulated deltas
            object messages = (orderbook as ccxt.pro.OrderBook).cache;
            (orderbook as ccxt.pro.OrderBook).cache = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(messages)); postFixIncrement(ref i))
            {
                object messageItem = getValue(messages, i);
                object U = this.safeInteger(messageItem, "U");
                object u = this.safeInteger(messageItem, "u");
                object pu = this.safeInteger(messageItem, "pu");
                if (isTrue(isEqual(type, "future")))
                {
                    // 4. Drop any event where u is < lastUpdateId in the snapshot
                    if (isTrue(isLessThan(u, getValue(orderbook, "nonce"))))
                    {
                        continue;
                    }
                    // 5. The first processed event should have U <= lastUpdateId AND u >= lastUpdateId
                    if (isTrue(isTrue(isTrue((isLessThanOrEqual(U, getValue(orderbook, "nonce")))) && isTrue((isGreaterThanOrEqual(u, getValue(orderbook, "nonce"))))) || isTrue((isEqual(pu, getValue(orderbook, "nonce"))))))
                    {
                        this.handleOrderBookMessage(client as WebSocketClient, messageItem, orderbook);
                    }
                } else
                {
                    // 4. Drop any event where u is <= lastUpdateId in the snapshot
                    if (isTrue(isLessThanOrEqual(u, getValue(orderbook, "nonce"))))
                    {
                        continue;
                    }
                    // 5. The first processed event should have U <= lastUpdateId+1 AND u >= lastUpdateId+1
                    if (isTrue(isTrue((isLessThanOrEqual((subtract(U, 1)), getValue(orderbook, "nonce")))) && isTrue((isGreaterThanOrEqual((subtract(u, 1)), getValue(orderbook, "nonce"))))))
                    {
                        this.handleOrderBookMessage(client as WebSocketClient, messageItem, orderbook);
                    }
                }
            }
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
            callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
        } catch(Exception e)
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
            ((WebSocketClient)client).reject(e, messageHash);
        }
    }

    public override void handleDelta(object bookside, object delta)
    {
        object price = this.safeFloat(delta, 0);
        object amount = this.safeFloat(delta, 1);
        (bookside as IOrderBookSide).store(price, amount);
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    public virtual object handleOrderBookMessage(WebSocketClient client, object message, object orderbook)
    {
        object u = this.safeInteger(message, "u");
        this.handleDeltas(getValue(orderbook, "asks"), this.safeValue(message, "a", new List<object>() {}));
        this.handleDeltas(getValue(orderbook, "bids"), this.safeValue(message, "b", new List<object>() {}));
        ((IDictionary<string,object>)orderbook)["nonce"] = u;
        object timestamp = this.safeInteger(message, "E");
        ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
        ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        return orderbook;
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        // initial snapshot is fetched with ccxt's fetchOrderBook
        // the feed does not include a snapshot, just the deltas
        //
        //     {
        //         "e": "depthUpdate", // Event type
        //         "E": 1577554482280, // Event time
        //         "s": "BNBBTC", // Symbol
        //         "U": 157, // First update ID in event
        //         "u": 160, // Final update ID in event
        //         "b": [ // bids
        //             [ "0.0024", "10" ], // price, size
        //         ],
        //         "a": [ // asks
        //             [ "0.0026", "100" ], // price, size
        //         ]
        //     }
        //
        object isSpot = this.isSpotUrl(client);
        object marketType = ((bool) isTrue((isSpot))) ? "spot" : "contract";
        object marketId = this.safeString(message, "s");
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        object messageHash = add("orderbook::", symbol);
        if (!isTrue((inOp(this.orderbooks, symbol))))
        {
            //
            // https://github.com/ccxt/ccxt/issues/6672
            //
            // Sometimes Binance sends the first delta before the subscription
            // confirmation arrives. At that point the orderbook is not
            // initialized yet and the snapshot has not been requested yet
            // therefore it is safe to drop these premature messages.
            //
            return;
        }
        object orderbook = getValue(this.orderbooks, symbol);
        object nonce = this.safeInteger(orderbook, "nonce");
        if (isTrue(isEqual(nonce, null)))
        {
            // 2. Buffer the events you receive from the stream.
            ((IList<object>)(orderbook as ccxt.pro.OrderBook).cache).Add(message);
        } else
        {
            try
            {
                object U = this.safeInteger(message, "U");
                object u = this.safeInteger(message, "u");
                object pu = this.safeInteger(message, "pu");
                if (isTrue(isEqual(pu, null)))
                {
                    // spot
                    // 4. Drop any event where u is <= lastUpdateId in the snapshot
                    if (isTrue(isGreaterThan(u, getValue(orderbook, "nonce"))))
                    {
                        object timestamp = this.safeInteger(orderbook, "timestamp");
                        object conditional = null;
                        if (isTrue(isEqual(timestamp, null)))
                        {
                            // 5. The first processed event should have U <= lastUpdateId+1 AND u >= lastUpdateId+1
                            conditional = isTrue((isLessThanOrEqual((subtract(U, 1)), getValue(orderbook, "nonce")))) && isTrue((isGreaterThanOrEqual((subtract(u, 1)), getValue(orderbook, "nonce"))));
                        } else
                        {
                            // 6. While listening to the stream, each new event's U should be equal to the previous event's u+1.
                            conditional = (isEqual((subtract(U, 1)), getValue(orderbook, "nonce")));
                        }
                        if (isTrue(conditional))
                        {
                            this.handleOrderBookMessage(client as WebSocketClient, message, orderbook);
                            if (isTrue(isLessThan(nonce, getValue(orderbook, "nonce"))))
                            {
                                callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
                            }
                        } else
                        {
                            object checksum = this.handleOption("watchOrderBook", "checksum", true);
                            if (isTrue(checksum))
                            {
                                throw new ChecksumError ((string)add(add(this.id, " "), this.orderbookChecksumMessage(symbol))) ;
                            }
                        }
                    }
                } else
                {
                    // future
                    // 4. Drop any event where u is < lastUpdateId in the snapshot
                    if (isTrue(isGreaterThanOrEqual(u, getValue(orderbook, "nonce"))))
                    {
                        // 5. The first processed event should have U <= lastUpdateId AND u >= lastUpdateId
                        // 6. While listening to the stream, each new event's pu should be equal to the previous event's u, otherwise initialize the process from step 3
                        if (isTrue(isTrue((isLessThanOrEqual(U, getValue(orderbook, "nonce")))) || isTrue((isEqual(pu, getValue(orderbook, "nonce"))))))
                        {
                            this.handleOrderBookMessage(client as WebSocketClient, message, orderbook);
                            if (isTrue(isLessThanOrEqual(nonce, getValue(orderbook, "nonce"))))
                            {
                                callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
                            }
                        } else
                        {
                            object checksum = this.handleOption("watchOrderBook", "checksum", true);
                            if (isTrue(checksum))
                            {
                                throw new ChecksumError ((string)add(add(this.id, " "), this.orderbookChecksumMessage(symbol))) ;
                            }
                        }
                    }
                }
            } catch(Exception e)
            {
                ((IDictionary<string,object>)this.orderbooks).Remove((string)symbol);
                ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)messageHash);
                ((WebSocketClient)client).reject(e, messageHash);
            }
        }
    }

    public virtual void handleOrderBookSubscription(WebSocketClient client, object message, object subscription)
    {
        object defaultLimit = this.safeInteger(this.options, "watchOrderBookLimit", 1000);
        // const messageHash = this.safeString (subscription, 'messageHash');
        object symbolOfSubscription = this.safeString(subscription, "symbol"); // watchOrderBook
        object symbols = this.safeValue(subscription, "symbols", new List<object>() {symbolOfSubscription}); // watchOrderBookForSymbols
        object limit = this.safeInteger(subscription, "limit", defaultLimit);
        // handle list of symbols
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            if (isTrue(inOp(this.orderbooks, symbol)))
            {
                ((IDictionary<string,object>)this.orderbooks).Remove((string)symbol);
            }
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
            subscription = this.extend(subscription, new Dictionary<string, object>() {
                { "symbol", symbol },
            });
            // fetch the snapshot in a separate async call
            this.spawn(this.fetchOrderBookSnapshot, new object[] { client, message, subscription});
        }
    }

    public virtual object handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //     {
        //         "result": null,
        //         "id": 1574649734450
        //     }
        //
        object id = this.safeString(message, "id");
        object subscriptionsById = this.indexBy(((WebSocketClient)client).subscriptions, "id");
        object subscription = this.safeValue(subscriptionsById, id, new Dictionary<string, object>() {});
        object method = this.safeValue(subscription, "method");
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message, subscription});
        }
        object isUnSubMessage = this.safeBool(subscription, "unsubscribe", false);
        if (isTrue(isUnSubMessage))
        {
            this.handleUnSubscription(client as WebSocketClient, subscription);
        }
        return message;
    }

    public virtual void handleUnSubscription(WebSocketClient client, object subscription)
    {
        object messageHashes = this.safeList(subscription, "messageHashes", new List<object>() {});
        object subMessageHashes = this.safeList(subscription, "subMessageHashes", new List<object>() {});
        for (object j = 0; isLessThan(j, getArrayLength(messageHashes)); postFixIncrement(ref j))
        {
            object unsubHash = getValue(messageHashes, j);
            object subHash = getValue(subMessageHashes, j);
            this.cleanUnsubscription(client as WebSocketClient, subHash, unsubHash);
        }
        this.cleanCache(subscription);
    }

    /**
     * @method
     * @name binance#watchTradesForSymbols
     * @description get the list of most recent trades for a list of symbols
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#aggregate-trades
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#recent-trades
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Aggregate-Trade-Streams
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Aggregate-Trade-Streams
     * @param {string[]} symbols unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.name] the name of the method to call, 'trade' or 'aggTrade', default is 'trade'
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false, true, true);
        object streamHash = "multipleTrades";
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(isGreaterThan(symbolsLength, 200)))
            {
                throw new BadRequest ((string)add(this.id, " watchTradesForSymbols() accepts 200 symbols at most. To watch more symbols call watchTradesForSymbols() multiple times")) ;
            }
            streamHash = add(streamHash, add("::", String.Join(",", ((IList<object>)symbols).ToArray())));
        }
        object name = null;
        var nameparametersVariable = this.handleOptionAndParams(parameters, "watchTradesForSymbols", "name", "trade");
        name = ((IList<object>)nameparametersVariable)[0];
        parameters = ((IList<object>)nameparametersVariable)[1];
        parameters = this.omit(parameters, "callerMethodName");
        object firstMarket = this.market(getValue(symbols, 0));
        object type = getValue(firstMarket, "type");
        if (isTrue(getValue(firstMarket, "contract")))
        {
            type = ((bool) isTrue(getValue(firstMarket, "linear"))) ? "future" : "delivery";
        }
        object messageHashes = new List<object>() {};
        object subParams = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = this.market(symbol);
            ((IList<object>)messageHashes).Add(add("trade::", symbol));
            object rawHash = add(add(getValue(market, "lowercaseId"), "@"), name);
            ((IList<object>)subParams).Add(rawHash);
        }
        object query = this.omit(parameters, "type");
        object subParamsLength = getArrayLength(subParams);
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "/"), this.stream(type, streamHash, subParamsLength));
        object requestId = this.requestId(url);
        object request = new Dictionary<string, object>() {
            { "method", "SUBSCRIBE" },
            { "params", subParams },
            { "id", requestId },
        };
        object subscribe = new Dictionary<string, object>() {
            { "id", requestId },
        };
        object trades = await this.watchMultiple(url, messageHashes, this.extend(request, query), messageHashes, subscribe);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeValue(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    /**
     * @method
     * @name binance#unWatchTradesForSymbols
     * @description unsubscribes from the trades channel
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#aggregate-trades
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#recent-trades
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Aggregate-Trade-Streams
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Aggregate-Trade-Streams
     * @param {string[]} symbols unified symbol of the market to fetch trades for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.name] the name of the method to call, 'trade' or 'aggTrade', default is 'trade'
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> unWatchTradesForSymbols(object symbols, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false, true, true);
        object streamHash = "multipleTrades";
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(isGreaterThan(symbolsLength, 200)))
            {
                throw new BadRequest ((string)add(this.id, " watchTradesForSymbols() accepts 200 symbols at most. To watch more symbols call watchTradesForSymbols() multiple times")) ;
            }
            streamHash = add(streamHash, add("::", String.Join(",", ((IList<object>)symbols).ToArray())));
        }
        object name = null;
        var nameparametersVariable = this.handleOptionAndParams(parameters, "watchTradesForSymbols", "name", "trade");
        name = ((IList<object>)nameparametersVariable)[0];
        parameters = ((IList<object>)nameparametersVariable)[1];
        parameters = this.omit(parameters, "callerMethodName");
        object firstMarket = this.market(getValue(symbols, 0));
        object type = getValue(firstMarket, "type");
        if (isTrue(getValue(firstMarket, "contract")))
        {
            type = ((bool) isTrue(getValue(firstMarket, "linear"))) ? "future" : "delivery";
        }
        object subMessageHashes = new List<object>() {};
        object subParams = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = this.market(symbol);
            ((IList<object>)subMessageHashes).Add(add("trade::", symbol));
            ((IList<object>)messageHashes).Add(add("unsubscribe:trade:", symbol));
            object rawHash = add(add(getValue(market, "lowercaseId"), "@"), name);
            ((IList<object>)subParams).Add(rawHash);
        }
        object query = this.omit(parameters, "type");
        object subParamsLength = getArrayLength(subParams);
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "/"), this.stream(type, streamHash, subParamsLength));
        object requestId = this.requestId(url);
        object request = new Dictionary<string, object>() {
            { "method", "UNSUBSCRIBE" },
            { "params", subParams },
            { "id", requestId },
        };
        object subscription = new Dictionary<string, object>() {
            { "unsubscribe", true },
            { "id", ((object)requestId).ToString() },
            { "subMessageHashes", subMessageHashes },
            { "messageHashes", messageHashes },
            { "symbols", symbols },
            { "topic", "trades" },
        };
        return await this.watchMultiple(url, messageHashes, this.extend(request, query), messageHashes, subscription);
    }

    /**
     * @method
     * @name binance#unWatchTrades
     * @description unsubscribes from the trades channel
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#aggregate-trades
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#recent-trades
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Aggregate-Trade-Streams
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Aggregate-Trade-Streams
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.name] the name of the method to call, 'trade' or 'aggTrade', default is 'trade'
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> unWatchTrades(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        return await this.unWatchTradesForSymbols(new List<object>() {symbol}, parameters);
    }

    /**
     * @method
     * @name binance#watchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#aggregate-trades
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#recent-trades
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Aggregate-Trade-Streams
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Aggregate-Trade-Streams
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.name] the name of the method to call, 'trade' or 'aggTrade', default is 'trade'
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["callerMethodName"] = "watchTrades";
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        // public watchTrades
        //
        //     {
        //         "e": "trade",       // event type
        //         "E": 1579481530911, // event time
        //         "s": "ETHBTC",      // symbol
        //         "t": 158410082,     // trade id
        //         "p": "0.01914100",  // price
        //         "q": "0.00700000",  // quantity
        //         "b": 586187049,     // buyer order id
        //         "a": 586186710,     // seller order id
        //         "T": 1579481530910, // trade time
        //         "m": false,         // is the buyer the market maker
        //         "M": true           // binance docs say it should be ignored
        //     }
        //
        //     {
        //        "e": "aggTrade",  // Event type
        //        "E": 123456789,   // Event time
        //        "s": "BNBBTC",    // Symbol
        //        "a": 12345,       // Aggregate trade ID
        //        "p": "0.001",     // Price
        //        "q": "100",       // Quantity
        //        "f": 100,         // First trade ID
        //        "l": 105,         // Last trade ID
        //        "T": 123456785,   // Trade time
        //        "m": true,        // Is the buyer the market maker?
        //        "M": true         // Ignore
        //     }
        //
        // private watchMyTrades spot
        //
        //     {
        //         "e": "executionReport",
        //         "E": 1611063861489,
        //         "s": "BNBUSDT",
        //         "c": "m4M6AD5MF3b1ERe65l4SPq",
        //         "S": "BUY",
        //         "o": "MARKET",
        //         "f": "GTC",
        //         "q": "2.00000000",
        //         "p": "0.00000000",
        //         "P": "0.00000000",
        //         "F": "0.00000000",
        //         "g": -1,
        //         "C": '',
        //         "x": "TRADE",
        //         "X": "PARTIALLY_FILLED",
        //         "r": "NONE",
        //         "i": 1296882607,
        //         "l": "0.33200000",
        //         "z": "0.33200000",
        //         "L": "46.86600000",
        //         "n": "0.00033200",
        //         "N": "BNB",
        //         "T": 1611063861488,
        //         "t": 109747654,
        //         "I": 2696953381,
        //         "w": false,
        //         "m": false,
        //         "M": true,
        //         "O": 1611063861488,
        //         "Z": "15.55951200",
        //         "Y": "15.55951200",
        //         "Q": "0.00000000"
        //     }
        //
        // private watchMyTrades future/delivery
        //
        //     {
        //         "s": "BTCUSDT",
        //         "c": "pb2jD6ZQHpfzSdUac8VqMK",
        //         "S": "SELL",
        //         "o": "MARKET",
        //         "f": "GTC",
        //         "q": "0.001",
        //         "p": "0",
        //         "ap": "33468.46000",
        //         "sp": "0",
        //         "x": "TRADE",
        //         "X": "FILLED",
        //         "i": 13351197194,
        //         "l": "0.001",
        //         "z": "0.001",
        //         "L": "33468.46",
        //         "n": "0.00027086",
        //         "N": "BNB",
        //         "T": 1612095165362,
        //         "t": 458032604,
        //         "b": "0",
        //         "a": "0",
        //         "m": false,
        //         "R": false,
        //         "wt": "CONTRACT_PRICE",
        //         "ot": "MARKET",
        //         "ps": "BOTH",
        //         "cp": false,
        //         "rp": "0.00335000",
        //         "pP": false,
        //         "si": 0,
        //         "ss": 0
        //     }
        //
        object executionType = this.safeString(trade, "x");
        object isTradeExecution = (isEqual(executionType, "TRADE"));
        if (!isTrue(isTradeExecution))
        {
            return this.parseTrade(trade, market);
        }
        object id = this.safeString2(trade, "t", "a");
        object timestamp = this.safeInteger(trade, "T");
        object price = this.safeString2(trade, "L", "p");
        object amount = this.safeString(trade, "q");
        if (isTrue(isTradeExecution))
        {
            amount = this.safeString(trade, "l", amount);
        }
        object cost = this.safeString(trade, "Y");
        if (isTrue(isEqual(cost, null)))
        {
            if (isTrue(isTrue((!isEqual(price, null))) && isTrue((!isEqual(amount, null)))))
            {
                cost = Precise.stringMul(price, amount);
            }
        }
        object marketId = this.safeString(trade, "s");
        object marketType = ((bool) isTrue((inOp(trade, "ps")))) ? "contract" : "spot";
        object symbol = this.safeSymbol(marketId, null, null, marketType);
        object side = this.safeStringLower(trade, "S");
        object takerOrMaker = null;
        object orderId = this.safeString(trade, "i");
        if (isTrue(inOp(trade, "m")))
        {
            if (isTrue(isEqual(side, null)))
            {
                side = ((bool) isTrue(getValue(trade, "m"))) ? "sell" : "buy"; // this is reversed intentionally
            }
            takerOrMaker = ((bool) isTrue(getValue(trade, "m"))) ? "maker" : "taker";
        }
        object fee = null;
        object feeCost = this.safeString(trade, "n");
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrencyId = this.safeString(trade, "N");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrencyCode },
            };
        }
        object type = this.safeStringLower(trade, "o");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", id },
            { "order", orderId },
            { "type", type },
            { "takerOrMaker", takerOrMaker },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "fee", fee },
        });
    }

    public virtual void handleTrade(WebSocketClient client, object message)
    {
        // the trade streams push raw trade information in real-time
        // each trade has a unique buyer and seller
        object isSpot = this.isSpotUrl(client);
        object marketType = ((bool) isTrue((isSpot))) ? "spot" : "contract";
        object marketId = this.safeString(message, "s");
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        object messageHash = add("trade::", symbol);
        object trade = this.parseWsTrade(message, market);
        object tradesArray = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(tradesArray, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            tradesArray = new ArrayCache(limit);
        }
        callDynamically(tradesArray, "append", new object[] {trade});
        ((IDictionary<string,object>)this.trades)[(string)symbol] = tradesArray;
        callDynamically(client as WebSocketClient, "resolve", new object[] {tradesArray, messageHash});
    }

    /**
     * @method
     * @name binance#watchOHLCV
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#klines
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {object} [params.timezone] if provided, kline intervals are interpreted in that timezone instead of UTC, example '+08:00'
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        ((IDictionary<string,object>)parameters)["callerMethodName"] = "watchOHLCV";
        object result = await this.watchOHLCVForSymbols(new List<object>() {new List<object>() {symbol, timeframe}}, since, limit, parameters);
        return getValue(getValue(result, symbol), timeframe);
    }

    /**
     * @method
     * @name binance#watchOHLCVForSymbols
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#klines
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
     * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {object} [params.timezone] if provided, kline intervals are interpreted in that timezone instead of UTC, example '+08:00'
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCVForSymbols(object symbolsAndTimeframes, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object klineType = null;
        var klineTypeparametersVariable = this.handleParamString2(parameters, "channel", "name", "kline");
        klineType = ((IList<object>)klineTypeparametersVariable)[0];
        parameters = ((IList<object>)klineTypeparametersVariable)[1];
        object symbols = this.getListFromObjectValues(symbolsAndTimeframes, 0);
        object marketSymbols = this.marketSymbols(symbols, null, false, false, true);
        object firstMarket = this.market(getValue(marketSymbols, 0));
        object type = getValue(firstMarket, "type");
        if (isTrue(getValue(firstMarket, "contract")))
        {
            type = ((bool) isTrue(getValue(firstMarket, "linear"))) ? "future" : "delivery";
        }
        object isSpot = (isEqual(type, "spot"));
        object timezone = null;
        var timezoneparametersVariable = this.handleParamString(parameters, "timezone", null);
        timezone = ((IList<object>)timezoneparametersVariable)[0];
        parameters = ((IList<object>)timezoneparametersVariable)[1];
        object isUtc8 = isTrue((!isEqual(timezone, null))) && isTrue((isTrue((isEqual(timezone, "+08:00"))) || isTrue(Precise.stringEq(timezone, "8"))));
        object rawHashes = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbolsAndTimeframes)); postFixIncrement(ref i))
        {
            object symAndTf = getValue(symbolsAndTimeframes, i);
            object symbolString = getValue(symAndTf, 0);
            object timeframeString = getValue(symAndTf, 1);
            object interval = this.safeString(this.timeframes, timeframeString, timeframeString);
            object market = this.market(symbolString);
            object marketId = getValue(market, "lowercaseId");
            if (isTrue(isEqual(klineType, "indexPriceKline")))
            {
                // weird behavior for index price kline we can't use the perp suffix
                marketId = ((string)marketId).Replace((string)"_perp", (string)"");
            }
            object shouldUseUTC8 = (isTrue(isUtc8) && isTrue(isSpot));
            object suffix = "@+08:00";
            object utcSuffix = ((bool) isTrue(shouldUseUTC8)) ? suffix : "";
            ((IList<object>)rawHashes).Add(add(add(add(add(add(marketId, "@"), klineType), "_"), interval), utcSuffix));
            ((IList<object>)messageHashes).Add(add(add(add("ohlcv::", getValue(market, "symbol")), "::"), timeframeString));
        }
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "/"), this.stream(type, "multipleOHLCV"));
        object requestId = this.requestId(url);
        object request = new Dictionary<string, object>() {
            { "method", "SUBSCRIBE" },
            { "params", rawHashes },
            { "id", requestId },
        };
        object subscribe = new Dictionary<string, object>() {
            { "id", requestId },
        };
        parameters = this.omit(parameters, "callerMethodName");
        var symboltimeframecandlesVariable = await this.watchMultiple(url, messageHashes, this.extend(request, parameters), messageHashes, subscribe);
        var symbol = ((IList<object>) symboltimeframecandlesVariable)[0];
        var timeframe = ((IList<object>) symboltimeframecandlesVariable)[1];
        var candles = ((IList<object>) symboltimeframecandlesVariable)[2];
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(candles, "getLimit", new object[] {symbol, limit});
        }
        object filtered = this.filterBySinceLimit(candles, since, limit, 0, true);
        return this.createOHLCVObject(symbol, timeframe, filtered);
    }

    /**
     * @method
     * @name binance#unWatchOHLCVForSymbols
     * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#klines
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
     * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {object} [params.timezone] if provided, kline intervals are interpreted in that timezone instead of UTC, example '+08:00'
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> unWatchOHLCVForSymbols(object symbolsAndTimeframes, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object klineType = null;
        var klineTypeparametersVariable = this.handleParamString2(parameters, "channel", "name", "kline");
        klineType = ((IList<object>)klineTypeparametersVariable)[0];
        parameters = ((IList<object>)klineTypeparametersVariable)[1];
        object symbols = this.getListFromObjectValues(symbolsAndTimeframes, 0);
        object marketSymbols = this.marketSymbols(symbols, null, false, false, true);
        object firstMarket = this.market(getValue(marketSymbols, 0));
        object type = getValue(firstMarket, "type");
        if (isTrue(getValue(firstMarket, "contract")))
        {
            type = ((bool) isTrue(getValue(firstMarket, "linear"))) ? "future" : "delivery";
        }
        object isSpot = (isEqual(type, "spot"));
        object timezone = null;
        var timezoneparametersVariable = this.handleParamString(parameters, "timezone", null);
        timezone = ((IList<object>)timezoneparametersVariable)[0];
        parameters = ((IList<object>)timezoneparametersVariable)[1];
        object isUtc8 = isTrue((!isEqual(timezone, null))) && isTrue((isTrue((isEqual(timezone, "+08:00"))) || isTrue(Precise.stringEq(timezone, "8"))));
        object rawHashes = new List<object>() {};
        object subMessageHashes = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbolsAndTimeframes)); postFixIncrement(ref i))
        {
            object symAndTf = getValue(symbolsAndTimeframes, i);
            object symbolString = getValue(symAndTf, 0);
            object timeframeString = getValue(symAndTf, 1);
            object interval = this.safeString(this.timeframes, timeframeString, timeframeString);
            object market = this.market(symbolString);
            object marketId = getValue(market, "lowercaseId");
            if (isTrue(isEqual(klineType, "indexPriceKline")))
            {
                // weird behavior for index price kline we can't use the perp suffix
                marketId = ((string)marketId).Replace((string)"_perp", (string)"");
            }
            object shouldUseUTC8 = (isTrue(isUtc8) && isTrue(isSpot));
            object suffix = "@+08:00";
            object utcSuffix = ((bool) isTrue(shouldUseUTC8)) ? suffix : "";
            ((IList<object>)rawHashes).Add(add(add(add(add(add(marketId, "@"), klineType), "_"), interval), utcSuffix));
            ((IList<object>)subMessageHashes).Add(add(add(add("ohlcv::", getValue(market, "symbol")), "::"), timeframeString));
            ((IList<object>)messageHashes).Add(add(add(add("unsubscribe::ohlcv::", getValue(market, "symbol")), "::"), timeframeString));
        }
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "/"), this.stream(type, "multipleOHLCV"));
        object requestId = this.requestId(url);
        object request = new Dictionary<string, object>() {
            { "method", "UNSUBSCRIBE" },
            { "params", rawHashes },
            { "id", requestId },
        };
        object subscribe = new Dictionary<string, object>() {
            { "unsubscribe", true },
            { "id", ((object)requestId).ToString() },
            { "symbols", symbols },
            { "symbolsAndTimeframes", symbolsAndTimeframes },
            { "subMessageHashes", subMessageHashes },
            { "messageHashes", messageHashes },
            { "topic", "ohlcv" },
        };
        parameters = this.omit(parameters, "callerMethodName");
        return await this.watchMultiple(url, messageHashes, this.extend(request, parameters), messageHashes, subscribe);
    }

    /**
     * @method
     * @name binance#unWatchOHLCV
     * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#klines
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {object} [params.timezone] if provided, kline intervals are interpreted in that timezone instead of UTC, example '+08:00'
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async virtual Task<object> unWatchOHLCV(object symbol, object timeframe = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        ((IDictionary<string,object>)parameters)["callerMethodName"] = "watchOHLCV";
        return await this.unWatchOHLCVForSymbols(new List<object>() {new List<object>() {symbol, timeframe}}, parameters);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "e": "kline",
        //         "E": 1579482921215,
        //         "s": "ETHBTC",
        //         "k": {
        //             "t": 1579482900000,
        //             "T": 1579482959999,
        //             "s": "ETHBTC",
        //             "i": "1m",
        //             "f": 158411535,
        //             "L": 158411550,
        //             "o": "0.01913200",
        //             "c": "0.01913500",
        //             "h": "0.01913700",
        //             "l": "0.01913200",
        //             "v": "5.08400000",
        //             "n": 16,
        //             "x": false,
        //             "q": "0.09728060",
        //             "V": "3.30200000",
        //             "Q": "0.06318500",
        //             "B": "0"
        //         }
        //     }
        //
        object eventVar = this.safeString(message, "e");
        object eventMap = new Dictionary<string, object>() {
            { "indexPrice_kline", "indexPriceKline" },
            { "markPrice_kline", "markPriceKline" },
        };
        eventVar = this.safeString(eventMap, eventVar, eventVar);
        object kline = this.safeValue(message, "k");
        object marketId = this.safeString2(kline, "s", "ps");
        if (isTrue(isEqual(eventVar, "indexPriceKline")))
        {
            // indexPriceKline doesn't have the _PERP suffix
            marketId = this.safeString(message, "ps");
        }
        object interval = this.safeString(kline, "i");
        // use a reverse lookup in a static map instead
        object unifiedTimeframe = this.findTimeframe(interval);
        object parsed = new List<object> {this.safeInteger(kline, "t"), this.safeFloat(kline, "o"), this.safeFloat(kline, "h"), this.safeFloat(kline, "l"), this.safeFloat(kline, "c"), this.safeFloat(kline, "v")};
        object isSpot = this.isSpotUrl(client);
        object marketType = ((bool) isTrue((isSpot))) ? "spot" : "contract";
        object symbol = this.safeSymbol(marketId, null, null, marketType);
        object messageHash = add(add(add("ohlcv::", symbol), "::"), unifiedTimeframe);
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), unifiedTimeframe);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)unifiedTimeframe] = stored;
        }
        callDynamically(stored, "append", new object[] {parsed});
        object resolveData = new List<object>() {symbol, unifiedTimeframe, stored};
        callDynamically(client as WebSocketClient, "resolve", new object[] {resolveData, messageHash});
    }

    /**
     * @method
     * @name binance#fetchTickerWs
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.method] method to use can be ticker.price or ticker.book
     * @param {boolean} [params.returnRateLimits] return the rate limits for the exchange
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickerWs(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object payload = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object type = this.getMarketType("fetchTickerWs", market, parameters);
        if (isTrue(!isEqual(type, "future")))
        {
            throw new BadRequest ((string)add(this.id, " fetchTickerWs only supports swap markets")) ;
        }
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "ws-api"), type);
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleTickerWs },
        };
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "fetchTickerWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        ((IDictionary<string,object>)payload)["returnRateLimits"] = returnRateLimits;
        parameters = this.omit(parameters, "test");
        object method = null;
        var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchTickerWs", "method", "ticker.book");
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", method },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        object ticker = await this.watch(url, messageHash, message, messageHash, subscription);
        return ticker;
    }

    /**
     * @method
     * @name binance#fetchOHLCVWs
     * @description query historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#klines
     * @param {string} symbol unified symbol of the market to query OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} since timestamp in ms of the earliest candle to fetch
     * @param {int} limit the maximum amount of candles to fetch
     * @param {object} params extra parameters specific to the exchange API endpoint
     * @param {int} params.until timestamp in ms of the earliest candle to fetch
     *
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {string} params.timeZone default=0 (UTC)
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCVWs(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketType = this.getMarketType("fetchOHLCVWs", market, parameters);
        if (isTrue(isTrue(!isEqual(marketType, "spot")) && isTrue(!isEqual(marketType, "future"))))
        {
            throw new BadRequest ((string)add(this.id, " fetchOHLCVWs only supports spot or swap markets")) ;
        }
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "ws-api"), marketType);
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCVWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        object payload = new Dictionary<string, object>() {
            { "symbol", this.marketId(symbol) },
            { "returnRateLimits", returnRateLimits },
            { "interval", getValue(this.timeframes, timeframe) },
        };
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)payload)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)payload)["limit"] = limit;
        }
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)payload)["endTime"] = until;
        }
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "klines" },
            { "params", this.extend(payload, parameters) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleFetchOHLCV },
        };
        return await this.watch(url, messageHash, message, messageHash, subscription);
    }

    public virtual void handleFetchOHLCV(WebSocketClient client, object message)
    {
        //
        //    {
        //        "id": "1dbbeb56-8eea-466a-8f6e-86bdcfa2fc0b",
        //        "status": 200,
        //        "result": [
        //            [
        //                1655971200000,      // Kline open time
        //                "0.01086000",       // Open price
        //                "0.01086600",       // High price
        //                "0.01083600",       // Low price
        //                "0.01083800",       // Close price
        //                "2290.53800000",    // Volume
        //                1655974799999,      // Kline close time
        //                "24.85074442",      // Quote asset volume
        //                2283,               // Number of trades
        //                "1171.64000000",    // Taker buy base asset volume
        //                "12.71225884",      // Taker buy quote asset volume
        //                "0"                 // Unused field, ignore
        //            ]
        //        ],
        //        "rateLimits": [
        //            {
        //                "rateLimitType": "REQUEST_WEIGHT",
        //                "interval": "MINUTE",
        //                "intervalNum": 1,
        //                "limit": 6000,
        //                "count": 2
        //            }
        //        ]
        //    }
        //
        object result = this.safeList(message, "result");
        object parsed = this.parseOHLCVs(result);
        // use a reverse lookup in a static map instead
        object messageHash = this.safeString(message, "id");
        callDynamically(client as WebSocketClient, "resolve", new object[] {parsed, messageHash});
    }

    /**
     * @method
     * @name binance#watchTicker
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-mini-ticker-stream
     * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-mini-tickers-stream
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Individual-Symbol-Ticker-Streams
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-Market-Mini-Tickers-Stream
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-Market-Mini-Tickers-Stream
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Individual-Symbol-Ticker-Streams
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.name] stream to use can be ticker or miniTicker
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbol = this.symbol(symbol);
        object tickers = await this.watchTickers(new List<object>() {symbol}, this.extend(parameters, new Dictionary<string, object>() {
            { "callerMethodName", "watchTicker" },
        }));
        return getValue(tickers, symbol);
    }

    /**
     * @method
     * @name binance#watchMarkPrice
     * @description watches a mark price for a specific market
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Mark-Price-Stream
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async virtual Task<object> watchMarkPrice(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbol = this.symbol(symbol);
        object tickers = await this.watchMarkPrices(new List<object>() {symbol}, this.extend(parameters, new Dictionary<string, object>() {
            { "callerMethodName", "watchMarkPrice" },
        }));
        return getValue(tickers, symbol);
    }

    /**
     * @method
     * @name binance#watchMarkPrices
     * @description watches the mark price for all markets
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Mark-Price-Stream-for-All-market
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async virtual Task<object> watchMarkPrices(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object channelName = null;
        // for now watchmarkPrice uses the same messageHash as watchTicker
        // so it's impossible to watch both at the same time
        // refactor this to use different messageHashes
        var channelNameparametersVariable = this.handleOptionAndParams(parameters, "watchMarkPrices", "name", "markPrice");
        channelName = ((IList<object>)channelNameparametersVariable)[0];
        parameters = ((IList<object>)channelNameparametersVariable)[1];
        object newTickers = await this.watchMultiTickerHelper("watchMarkPrices", channelName, symbols, parameters);
        if (isTrue(this.newUpdates))
        {
            return newTickers;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    /**
     * @method
     * @name binance#watchTickers
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
     * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-mini-ticker-stream
     * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-mini-tickers-stream
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Individual-Symbol-Ticker-Streams
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-Market-Mini-Tickers-Stream
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-Market-Mini-Tickers-Stream
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Individual-Symbol-Ticker-Streams
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object channelName = null;
        var channelNameparametersVariable = this.handleOptionAndParams(parameters, "watchTickers", "name", "ticker");
        channelName = ((IList<object>)channelNameparametersVariable)[0];
        parameters = ((IList<object>)channelNameparametersVariable)[1];
        if (isTrue(isEqual(channelName, "bookTicker")))
        {
            throw new BadRequest ((string)add(this.id, " deprecation notice - to subscribe for bids-asks, use watch_bids_asks() method instead")) ;
        }
        object newTickers = await this.watchMultiTickerHelper("watchTickers", channelName, symbols, parameters);
        if (isTrue(this.newUpdates))
        {
            return newTickers;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    /**
     * @method
     * @name binance#unWatchTickers
     * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
     * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-mini-ticker-stream
     * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-mini-tickers-stream
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Individual-Symbol-Ticker-Streams
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-Market-Mini-Tickers-Stream
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-Market-Mini-Tickers-Stream
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Individual-Symbol-Ticker-Streams
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> unWatchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object channelName = null;
        var channelNameparametersVariable = this.handleOptionAndParams(parameters, "watchTickers", "name", "ticker");
        channelName = ((IList<object>)channelNameparametersVariable)[0];
        parameters = ((IList<object>)channelNameparametersVariable)[1];
        if (isTrue(isEqual(channelName, "bookTicker")))
        {
            throw new BadRequest ((string)add(this.id, " deprecation notice - to subscribe for bids-asks, use watch_bids_asks() method instead")) ;
        }
        await this.loadMarkets();
        object methodName = "watchTickers";
        symbols = this.marketSymbols(symbols, null, true, false, true);
        object firstMarket = null;
        object marketType = null;
        object symbolsDefined = (!isEqual(symbols, null));
        if (isTrue(symbolsDefined))
        {
            firstMarket = this.market(getValue(symbols, 0));
        }
        var marketTypeparametersVariable = this.handleMarketTypeAndParams(methodName, firstMarket, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams(methodName, firstMarket, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object rawMarketType = null;
        if (isTrue(this.isLinear(marketType, subType)))
        {
            rawMarketType = "future";
        } else if (isTrue(this.isInverse(marketType, subType)))
        {
            rawMarketType = "delivery";
        } else if (isTrue(isEqual(marketType, "spot")))
        {
            rawMarketType = marketType;
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " "), methodName), "() does not support options markets")) ;
        }
        object isBidAsk = (isEqual(channelName, "bookTicker"));
        object subscriptionArgs = new List<object>() {};
        object subMessageHashes = new List<object>() {};
        object messageHashes = new List<object>() {};
        if (isTrue(symbolsDefined))
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                object market = this.market(symbol);
                ((IList<object>)subscriptionArgs).Add(add(add(getValue(market, "lowercaseId"), "@"), channelName));
                ((IList<object>)subMessageHashes).Add(this.getMessageHash(channelName, getValue(market, "symbol"), isBidAsk));
                ((IList<object>)messageHashes).Add(add("unsubscribe:ticker:", symbol));
            }
        } else
        {
            if (isTrue(isBidAsk))
            {
                if (isTrue(isEqual(marketType, "spot")))
                {
                    throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires symbols for this channel for spot markets")) ;
                }
                ((IList<object>)subscriptionArgs).Add(add("!", channelName));
            } else
            {
                ((IList<object>)subscriptionArgs).Add(add(add("!", channelName), "@arr"));
            }
            ((IList<object>)subMessageHashes).Add(this.getMessageHash(channelName, null, isBidAsk));
            ((IList<object>)messageHashes).Add("unsubscribe:ticker");
        }
        object streamHash = channelName;
        if (isTrue(symbolsDefined))
        {
            streamHash = add(add(channelName, "::"), String.Join(",", ((IList<object>)symbols).ToArray()));
        }
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), rawMarketType), "/"), this.stream(rawMarketType, streamHash));
        object requestId = this.requestId(url);
        object request = new Dictionary<string, object>() {
            { "method", "UNSUBSCRIBE" },
            { "params", subscriptionArgs },
            { "id", requestId },
        };
        object subscription = new Dictionary<string, object>() {
            { "unsubscribe", true },
            { "id", ((object)requestId).ToString() },
            { "subMessageHashes", subMessageHashes },
            { "messageHashes", subMessageHashes },
            { "symbols", symbols },
            { "topic", "ticker" },
        };
        return await this.watchMultiple(url, subMessageHashes, this.extend(request, parameters), subMessageHashes, subscription);
    }

    /**
     * @method
     * @name binance#unWatchTicker
     * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
     * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-mini-ticker-stream
     * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-mini-tickers-stream
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Individual-Symbol-Ticker-Streams
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-Market-Mini-Tickers-Stream
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-Market-Mini-Tickers-Stream
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Individual-Symbol-Ticker-Streams
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> unWatchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.unWatchTickers(new List<object>() {symbol}, parameters);
    }

    /**
     * @method
     * @name binance#watchBidsAsks
     * @description watches best bid & ask for symbols
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#symbol-order-book-ticker
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-Book-Tickers-Stream
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-Book-Tickers-Stream
     * @param {string[]} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchBidsAsks(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, true, false, true);
        object result = await this.watchMultiTickerHelper("watchBidsAsks", "bookTicker", symbols, parameters);
        if (isTrue(this.newUpdates))
        {
            return result;
        }
        return this.filterByArray(this.bidsasks, "symbol", symbols);
    }

    public async virtual Task<object> watchMultiTickerHelper(object methodName, object channelName, object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, true, false, true);
        object isBidAsk = (isEqual(channelName, "bookTicker"));
        object isMarkPrice = (isEqual(channelName, "markPrice"));
        object use1sFreq = this.safeBool(parameters, "use1sFreq", true);
        object firstMarket = null;
        object marketType = null;
        object symbolsDefined = (!isEqual(symbols, null));
        if (isTrue(symbolsDefined))
        {
            firstMarket = this.market(getValue(symbols, 0));
        }
        object defaultMarket = ((bool) isTrue((isMarkPrice))) ? "swap" : null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams(methodName, firstMarket, parameters, defaultMarket);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams(methodName, firstMarket, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object rawMarketType = null;
        if (isTrue(this.isLinear(marketType, subType)))
        {
            rawMarketType = "future";
        } else if (isTrue(this.isInverse(marketType, subType)))
        {
            rawMarketType = "delivery";
        } else if (isTrue(isEqual(marketType, "spot")))
        {
            rawMarketType = marketType;
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " "), methodName), "() does not support options markets")) ;
        }
        object subscriptionArgs = new List<object>() {};
        object messageHashes = new List<object>() {};
        object suffix = "";
        if (isTrue(isMarkPrice))
        {
            suffix = ((bool) isTrue((use1sFreq))) ? "@1s" : "";
        }
        if (isTrue(symbolsDefined))
        {
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                object market = this.market(symbol);
                ((IList<object>)subscriptionArgs).Add(add(add(add(getValue(market, "lowercaseId"), "@"), channelName), suffix));
                ((IList<object>)messageHashes).Add(this.getMessageHash(channelName, getValue(market, "symbol"), isBidAsk));
            }
        } else
        {
            if (isTrue(isBidAsk))
            {
                if (isTrue(isEqual(marketType, "spot")))
                {
                    throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires symbols for this channel for spot markets")) ;
                }
                ((IList<object>)subscriptionArgs).Add(add("!", channelName));
            } else if (isTrue(isMarkPrice))
            {
                ((IList<object>)subscriptionArgs).Add(add(add(add("!", channelName), "@arr"), suffix));
            } else
            {
                ((IList<object>)subscriptionArgs).Add(add(add("!", channelName), "@arr"));
            }
            ((IList<object>)messageHashes).Add(this.getMessageHash(channelName, null, isBidAsk));
        }
        object streamHash = channelName;
        if (isTrue(symbolsDefined))
        {
            streamHash = add(add(channelName, "::"), String.Join(",", ((IList<object>)symbols).ToArray()));
        }
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), rawMarketType), "/"), this.stream(rawMarketType, streamHash));
        object requestId = this.requestId(url);
        object request = new Dictionary<string, object>() {
            { "method", "SUBSCRIBE" },
            { "params", subscriptionArgs },
            { "id", requestId },
        };
        object subscribe = new Dictionary<string, object>() {
            { "id", requestId },
        };
        object result = await this.watchMultiple(url, messageHashes, this.deepExtend(request, parameters), subscriptionArgs, subscribe);
        // for efficiency, we have two type of returned structure here - if symbols array was provided, then individual
        // ticker dict comes in, otherwise all-tickers dict comes in
        if (!isTrue(symbolsDefined))
        {
            return result;
        } else
        {
            object newDict = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)newDict)[(string)getValue(result, "symbol")] = result;
            return newDict;
        }
    }

    public virtual object parseWsTicker(object message, object marketType)
    {
        // markPrice
        //   {
        //       "e": "markPriceUpdate",   // Event type
        //       "E": 1562305380000,       // Event time
        //       "s": "BTCUSDT",           // Symbol
        //       "p": "11794.15000000",    // Mark price
        //       "i": "11784.62659091",    // Index price
        //       "P": "11784.25641265",    // Estimated Settle Price, only useful in the last hour before the settlement starts
        //       "r": "0.00038167",        // Funding rate
        //       "T": 1562306400000        // Next funding time
        //   }
        //
        // ticker
        //     {
        //         "e": "24hrTicker",      // event type
        //         "E": 1579485598569,     // event time
        //         "s": "ETHBTC",          // symbol
        //         "p": "-0.00004000",     // price change
        //         "P": "-0.209",          // price change percent
        //         "w": "0.01920495",      // weighted average price
        //         "x": "0.01916500",      // the price of the first trade before the 24hr rolling window
        //         "c": "0.01912500",      // last (closing) price
        //         "Q": "0.10400000",      // last quantity
        //         "b": "0.01912200",      // best bid
        //         "B": "4.10400000",      // best bid quantity
        //         "a": "0.01912500",      // best ask
        //         "A": "0.00100000",      // best ask quantity
        //         "o": "0.01916500",      // open price
        //         "h": "0.01956500",      // high price
        //         "l": "0.01887700",      // low price
        //         "v": "173518.11900000", // base volume
        //         "q": "3332.40703994",   // quote volume
        //         "O": 1579399197842,     // open time
        //         "C": 1579485597842,     // close time
        //         "F": 158251292,         // first trade id
        //         "L": 158414513,         // last trade id
        //         "n": 163222,            // total number of trades
        //     }
        //
        // miniTicker
        //     {
        //         "e": "24hrMiniTicker",
        //         "E": 1671617114585,
        //         "s": "MOBBUSD",
        //         "c": "0.95900000",
        //         "o": "0.91200000",
        //         "h": "1.04000000",
        //         "l": "0.89400000",
        //         "v": "2109995.32000000",
        //         "q": "2019254.05788000"
        //     }
        // fetchTickerWs
        //     {
        //         "symbol":"BTCUSDT",
        //         "price":"72606.70",
        //         "time":1712526204284
        //     }
        // fetchTickerWs - ticker.book
        //     {
        //         "lastUpdateId":1027024,
        //         "symbol":"BTCUSDT",
        //         "bidPrice":"4.00000000",
        //         "bidQty":"431.00000000",
        //         "askPrice":"4.00000200",
        //         "askQty":"9.00000000",
        //         "time":1589437530011,
        //      }
        //
        object marketId = this.safeString2(message, "s", "symbol");
        object symbol = this.safeSymbol(marketId, null, null, marketType);
        object eventVar = this.safeString(message, "e", "bookTicker");
        if (isTrue(isEqual(eventVar, "24hrTicker")))
        {
            eventVar = "ticker";
        }
        if (isTrue(isEqual(eventVar, "markPriceUpdate")))
        {
            // handle this separately because some fields clash with the ticker fields
            return this.safeTicker(new Dictionary<string, object>() {
                { "symbol", symbol },
                { "timestamp", this.safeInteger(message, "E") },
                { "datetime", this.iso8601(this.safeInteger(message, "E")) },
                { "info", message },
                { "markPrice", this.safeString(message, "p") },
                { "indexPrice", this.safeString(message, "i") },
            });
        }
        object timestamp = null;
        if (isTrue(isEqual(eventVar, "bookTicker")))
        {
            // take the event timestamp, if available, for spot tickers it is not
            timestamp = this.safeInteger2(message, "E", "time");
        } else
        {
            // take the timestamp of the closing price for candlestick streams
            timestamp = this.safeIntegerN(message, new List<object>() {"C", "E", "time"});
        }
        object market = this.safeMarket(marketId, null, null, marketType);
        object last = this.safeString2(message, "c", "price");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(message, "h") },
            { "low", this.safeString(message, "l") },
            { "bid", this.safeString2(message, "b", "bidPrice") },
            { "bidVolume", this.safeString2(message, "B", "bidQty") },
            { "ask", this.safeString2(message, "a", "askPrice") },
            { "askVolume", this.safeString2(message, "A", "askQty") },
            { "vwap", this.safeString(message, "w") },
            { "open", this.safeString(message, "o") },
            { "close", last },
            { "last", last },
            { "previousClose", this.safeString(message, "x") },
            { "change", this.safeString(message, "p") },
            { "percentage", this.safeString(message, "P") },
            { "average", null },
            { "baseVolume", this.safeString(message, "v") },
            { "quoteVolume", this.safeString(message, "q") },
            { "info", message },
        }, market);
    }

    public virtual void handleTickerWs(WebSocketClient client, object message)
    {
        //
        // ticker.price
        //    {
        //        "id":"1",
        //        "status":200,
        //        "result":{
        //            "symbol":"BTCUSDT",
        //            "price":"73178.50",
        //            "time":1712527052374
        //        }
        //    }
        // ticker.book
        //    {
        //        "id":"9d32157c-a556-4d27-9866-66760a174b57",
        //        "status":200,
        //        "result":{
        //            "lastUpdateId":1027024,
        //            "symbol":"BTCUSDT",
        //            "bidPrice":"4.00000000",
        //            "bidQty":"431.00000000",
        //            "askPrice":"4.00000200",
        //            "askQty":"9.00000000",
        //            "time":1589437530011   // Transaction time
        //        }
        //    }
        //
        object messageHash = this.safeString(message, "id");
        object result = this.safeValue(message, "result", new Dictionary<string, object>() {});
        object ticker = this.parseWsTicker(result, "future");
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
    }

    public virtual void handleBidsAsks(WebSocketClient client, object message)
    {
        //
        // arrives one symbol dict or array of symbol dicts
        //
        //     {
        //         "u": 7488717758,
        //         "s": "BTCUSDT",
        //         "b": "28621.74000000",
        //         "B": "1.43278800",
        //         "a": "28621.75000000",
        //         "A": "2.52500800"
        //     }
        //
        this.handleTickersAndBidsAsks(client as WebSocketClient, message, "bidasks");
    }

    public virtual void handleTickers(WebSocketClient client, object message)
    {
        //
        // arrives one symbol dict or array of symbol dicts
        //
        //     {
        //         "e": "24hrTicker",      // event type
        //         "E": 1579485598569,     // event time
        //         "s": "ETHBTC",          // symbol
        //         "p": "-0.00004000",     // price change
        //         "P": "-0.209",          // price change percent
        //         "w": "0.01920495",      // weighted average price
        //         "x": "0.01916500",      // the price of the first trade before the 24hr rolling window
        //         "c": "0.01912500",      // last (closing) price
        //         "Q": "0.10400000",      // last quantity
        //         "b": "0.01912200",      // best bid
        //         "B": "4.10400000",      // best bid quantity
        //         "a": "0.01912500",      // best ask
        //         "A": "0.00100000",      // best ask quantity
        //         "o": "0.01916500",      // open price
        //         "h": "0.01956500",      // high price
        //         "l": "0.01887700",      // low price
        //         "v": "173518.11900000", // base volume
        //         "q": "3332.40703994",   // quote volume
        //         "O": 1579399197842,     // open time
        //         "C": 1579485597842,     // close time
        //         "F": 158251292,         // first trade id
        //         "L": 158414513,         // last trade id
        //         "n": 163222,            // total number of trades
        //     }
        //
        this.handleTickersAndBidsAsks(client as WebSocketClient, message, "tickers");
    }

    public virtual void handleTickersAndBidsAsks(WebSocketClient client, object message, object methodType)
    {
        object isSpot = this.isSpotUrl(client);
        object marketType = ((bool) isTrue((isSpot))) ? "spot" : "contract";
        object isBidAsk = (isEqual(methodType, "bidasks"));
        object channelName = null;
        object resolvedMessageHashes = new List<object>() {};
        object rawTickers = new List<object>() {};
        object newTickers = new Dictionary<string, object>() {};
        if (isTrue(((message is IList<object>) || (message.GetType().IsGenericType && message.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            rawTickers = message;
        } else
        {
            ((IList<object>)rawTickers).Add(message);
        }
        for (object i = 0; isLessThan(i, getArrayLength(rawTickers)); postFixIncrement(ref i))
        {
            object ticker = getValue(rawTickers, i);
            object eventVar = this.safeString(ticker, "e");
            if (isTrue(isBidAsk))
            {
                eventVar = "bookTicker"; // as noted in `handleMessage`, bookTicker doesn't have identifier, so manually set here
            }
            channelName = this.safeString(getValue(this.options, "tickerChannelsMap"), eventVar, eventVar);
            if (isTrue(isEqual(channelName, null)))
            {
                continue;
            }
            object parsedTicker = this.parseWsTicker(ticker, marketType);
            object symbol = getValue(parsedTicker, "symbol");
            ((IDictionary<string,object>)newTickers)[(string)symbol] = parsedTicker;
            if (isTrue(isBidAsk))
            {
                ((IDictionary<string,object>)this.bidsasks)[(string)symbol] = parsedTicker;
            } else
            {
                ((IDictionary<string,object>)this.tickers)[(string)symbol] = parsedTicker;
            }
            object messageHash = this.getMessageHash(channelName, symbol, isBidAsk);
            ((IList<object>)resolvedMessageHashes).Add(messageHash);
            callDynamically(client as WebSocketClient, "resolve", new object[] {parsedTicker, messageHash});
        }
        // resolve batch endpoint
        object length = getArrayLength(resolvedMessageHashes);
        if (isTrue(isGreaterThan(length, 0)))
        {
            object batchMessageHash = this.getMessageHash(channelName, null, isBidAsk);
            callDynamically(client as WebSocketClient, "resolve", new object[] {newTickers, batchMessageHash});
        }
    }

    public virtual object getMessageHash(object channelName, object symbol, object isBidAsk)
    {
        object prefix = ((bool) isTrue(isBidAsk)) ? "bidask" : "ticker";
        if (isTrue(!isEqual(symbol, null)))
        {
            return add(add(add(add(prefix, ":"), channelName), "@"), symbol);
        } else
        {
            return add(add(add(prefix, "s"), ":"), channelName);
        }
    }

    public virtual object signParams(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object extendedParams = this.extend(new Dictionary<string, object>() {
            { "timestamp", this.nonce() },
            { "apiKey", this.apiKey },
        }, parameters);
        object defaultRecvWindow = this.safeInteger(this.options, "recvWindow");
        if (isTrue(!isEqual(defaultRecvWindow, null)))
        {
            ((IDictionary<string,object>)parameters)["recvWindow"] = defaultRecvWindow;
        }
        object recvWindow = this.safeInteger(parameters, "recvWindow");
        if (isTrue(!isEqual(recvWindow, null)))
        {
            ((IDictionary<string,object>)parameters)["recvWindow"] = recvWindow;
        }
        extendedParams = this.keysort(extendedParams);
        object query = this.urlencode(extendedParams);
        object signature = null;
        if (isTrue(isGreaterThan(getIndexOf(this.secret, "PRIVATE KEY"), -1)))
        {
            if (isTrue(isGreaterThan(((string)this.secret).Length, 120)))
            {
                signature = rsa(query, this.secret, sha256);
            } else
            {
                signature = eddsa(this.encode(query), this.secret, ed25519);
            }
        } else
        {
            signature = this.hmac(this.encode(query), this.encode(this.secret), sha256);
        }
        ((IDictionary<string,object>)extendedParams)["signature"] = signature;
        return extendedParams;
    }

    /**
     * Ensures a User Data Stream WebSocket subscription is active for the specified scope
     * @param marketType {string} only support on 'spot'
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/user-data-stream-requests#subscribe-to-user-data-stream-through-signature-subscription-user_data Binance User Data Stream Documentation}
     * @returns Promise<number> The subscription ID for the user data stream
     */
    public async virtual Task ensureUserDataStreamWsSubscribeSignature(object marketType = null)
    {
        marketType ??= "spot";
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "ws-api"), marketType);
        var client = this.client(url);
        object subscriptions = ((WebSocketClient)client).subscriptions;
        object subscriptionsKeys = new List<object>(((IDictionary<string,object>)subscriptions).Keys);
        object accountType = this.getAccountTypeFromSubscriptions(subscriptionsKeys);
        if (isTrue(isEqual(accountType, marketType)))
        {
            return;
        }
        ((IDictionary<string,object>)((WebSocketClient)client).subscriptions)[(string)marketType] = true;
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "userDataStream.subscribe.signature" },
            { "params", this.signParams(new Dictionary<string, object>() {}) },
        };
        object subscription = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", this.handleUserDataStreamSubscribe },
            { "subscription", marketType },
        };
        await this.watch(url, messageHash, message, messageHash, subscription);
    }

    public virtual void handleUserDataStreamSubscribe(WebSocketClient client, object message)
    {
        //
        //   {
        //     "id": 1,
        //     "status": 200,
        //     "result": {
        //         "subscriptionId": 0
        //     }
        //   }
        //
        object messageHash = this.safeString(message, "id");
        object subscriptions = ((WebSocketClient)client).subscriptions;
        object subscriptionsKeys = new List<object>(((IDictionary<string,object>)subscriptions).Keys);
        object accountType = this.getAccountTypeFromSubscriptions(subscriptionsKeys);
        object result = this.safeDict(message, "result", new Dictionary<string, object>() {});
        object subscriptionId = this.safeInteger(result, "subscriptionId");
        if (isTrue(isEqual(subscriptionId, null)))
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)accountType);
            ((WebSocketClient)client).reject(message, accountType);
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {message, messageHash});
    }

    public async virtual Task authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object time = this.milliseconds();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("authenticate", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("authenticate", null, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object isPortfolioMargin = null;
        var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "authenticate", "papi", "portfolioMargin", false);
        isPortfolioMargin = ((IList<object>)isPortfolioMarginparametersVariable)[0];
        parameters = ((IList<object>)isPortfolioMarginparametersVariable)[1];
        if (isTrue(this.isLinear(type, subType)))
        {
            type = "future";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            type = "delivery";
        }
        // For spot use WebSocket API signature subscription
        if (isTrue(isEqual(type, "spot")))
        {
            await this.ensureUserDataStreamWsSubscribeSignature("spot");
            return;
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("authenticate", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object isIsolatedMargin = (isEqual(marginMode, "isolated"));
        object isCrossMargin = isTrue((isEqual(marginMode, "cross"))) || isTrue((isEqual(marginMode, null)));
        object symbol = this.safeString(parameters, "symbol");
        parameters = this.omit(parameters, "symbol");
        object options = this.safeValue(this.options, type, new Dictionary<string, object>() {});
        object lastAuthenticatedTime = this.safeInteger(options, "lastAuthenticatedTime", 0);
        object listenKeyRefreshRate = this.safeInteger(this.options, "listenKeyRefreshRate", 1200000);
        object delay = this.sum(listenKeyRefreshRate, 10000);
        if (isTrue(isGreaterThan(subtract(time, lastAuthenticatedTime), delay)))
        {
            object response = null;
            if (isTrue(isPortfolioMargin))
            {
                response = await this.papiPostListenKey(parameters);
                parameters = this.extend(parameters, new Dictionary<string, object>() {
                    { "portfolioMargin", true },
                });
            } else if (isTrue(isEqual(type, "future")))
            {
                response = await this.fapiPrivatePostListenKey(parameters);
            } else if (isTrue(isEqual(type, "delivery")))
            {
                response = await this.dapiPrivatePostListenKey(parameters);
            } else if (isTrue(isTrue(isEqual(type, "margin")) && isTrue(isCrossMargin)))
            {
                response = await this.sapiPostUserDataStream(parameters);
            } else if (isTrue(isIsolatedMargin))
            {
                if (isTrue(isEqual(symbol, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " authenticate() requires a symbol argument for isolated margin mode")) ;
                }
                object marketId = this.marketId(symbol);
                parameters = this.extend(parameters, new Dictionary<string, object>() {
                    { "symbol", marketId },
                });
                response = await this.sapiPostUserDataStreamIsolated(parameters);
            } else
            {
                response = await this.publicPostUserDataStream(parameters);
            }
            ((IDictionary<string,object>)this.options)[(string)type] = this.extend(options, new Dictionary<string, object>() {
                { "listenKey", this.safeString(response, "listenKey") },
                { "lastAuthenticatedTime", time },
            });
            this.delay(listenKeyRefreshRate,  this.keepAliveListenKey, new object[] { parameters});
        }
    }

    public async virtual Task keepAliveListenKey(object parameters = null)
    {
        // https://binance-docs.github.io/apidocs/spot/en/#listen-key-spot
        parameters ??= new Dictionary<string, object>();
        object type = this.safeString2(this.options, "defaultType", "authenticate", "spot");
        type = this.safeString(parameters, "type", type);
        object isPortfolioMargin = null;
        var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "keepAliveListenKey", "papi", "portfolioMargin", false);
        isPortfolioMargin = ((IList<object>)isPortfolioMarginparametersVariable)[0];
        parameters = ((IList<object>)isPortfolioMarginparametersVariable)[1];
        object subTypeInfo = this.handleSubTypeAndParams("keepAliveListenKey", null, parameters);
        object subType = getValue(subTypeInfo, 0);
        if (isTrue(this.isLinear(type, subType)))
        {
            type = "future";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            type = "delivery";
        }
        object options = this.safeValue(this.options, type, new Dictionary<string, object>() {});
        object listenKey = this.safeString(options, "listenKey");
        if (isTrue(isEqual(listenKey, null)))
        {
            // A network error happened: we can't renew a listen key that does not exist.
            return;
        }
        object request = new Dictionary<string, object>() {};
        object symbol = this.safeString(parameters, "symbol");
        parameters = this.omit(parameters, new List<object>() {"type", "symbol"});
        object time = this.milliseconds();
        try
        {
            if (isTrue(isPortfolioMargin))
            {
                await this.papiPutListenKey(this.extend(request, parameters));
                parameters = this.extend(parameters, new Dictionary<string, object>() {
                    { "portfolioMargin", true },
                });
            } else if (isTrue(isEqual(type, "future")))
            {
                await this.fapiPrivatePutListenKey(this.extend(request, parameters));
            } else if (isTrue(isEqual(type, "delivery")))
            {
                await this.dapiPrivatePutListenKey(this.extend(request, parameters));
            } else
            {
                ((IDictionary<string,object>)request)["listenKey"] = listenKey;
                if (isTrue(isEqual(type, "margin")))
                {
                    ((IDictionary<string,object>)request)["symbol"] = symbol;
                    await this.sapiPutUserDataStream(this.extend(request, parameters));
                } else
                {
                    await this.publicPutUserDataStream(this.extend(request, parameters));
                }
            }
        } catch(Exception error)
        {
            object urlType = type;
            if (isTrue(isPortfolioMargin))
            {
                urlType = "papi";
            }
            object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), urlType), "/"), getValue(getValue(this.options, type), "listenKey"));
            var client = this.client(url);
            object messageHashes = new List<object>(((IDictionary<string, ccxt.Exchange.Future>)client.futures).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
            {
                object messageHash = getValue(messageHashes, i);
                ((WebSocketClient)client).reject(error, messageHash);
            }
            ((IDictionary<string,object>)this.options)[(string)type] = this.extend(options, new Dictionary<string, object>() {
                { "listenKey", null },
                { "lastAuthenticatedTime", 0 },
            });
            return;
        }
        ((IDictionary<string,object>)this.options)[(string)type] = this.extend(options, new Dictionary<string, object>() {
            { "listenKey", listenKey },
            { "lastAuthenticatedTime", time },
        });
        // whether or not to schedule another listenKey keepAlive request
        object clients = new List<object>(((IDictionary<string, ccxt.Exchange.WebSocketClient>)this.clients).Values);
        object listenKeyRefreshRate = this.safeInteger(this.options, "listenKeyRefreshRate", 1200000);
        for (object i = 0; isLessThan(i, getArrayLength(clients)); postFixIncrement(ref i))
        {
            var client = getValue(clients, i);
            object subscriptionKeys = new List<object>(((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Keys);
            for (object j = 0; isLessThan(j, getArrayLength(subscriptionKeys)); postFixIncrement(ref j))
            {
                object subscribeType = getValue(subscriptionKeys, j);
                if (isTrue(isEqual(subscribeType, type)))
                {
                    this.delay(listenKeyRefreshRate,  this.keepAliveListenKey, new object[] { parameters});
                    return;
                }
            }
        }
    }

    public virtual void setBalanceCache(WebSocketClient client, object type, object isPortfolioMargin = null)
    {
        isPortfolioMargin ??= false;
        if (isTrue(isTrue((inOp(((WebSocketClient)client).subscriptions, type))) && isTrue((inOp(this.balance, type)))))
        {
            return;
        }
        object options = this.safeValue(this.options, "watchBalance");
        object fetchBalanceSnapshot = this.safeBool(options, "fetchBalanceSnapshot", false);
        if (isTrue(fetchBalanceSnapshot))
        {
            object messageHash = add(type, ":fetchBalanceSnapshot");
            if (!isTrue((inOp(client.futures, messageHash))))
            {
                client.future(messageHash);
                this.spawn(this.loadBalanceSnapshot, new object[] { client, messageHash, type, isPortfolioMargin});
            }
        } else
        {
            ((IDictionary<string,object>)this.balance)[(string)type] = new Dictionary<string, object>() {};
        }
    }

    public async virtual Task loadBalanceSnapshot(WebSocketClient client, object messageHash, object type, object isPortfolioMargin)
    {
        object parameters = new Dictionary<string, object>() {
            { "type", type },
        };
        if (isTrue(isPortfolioMargin))
        {
            ((IDictionary<string,object>)parameters)["portfolioMargin"] = true;
        }
        object response = await this.fetchBalance(parameters);
        ((IDictionary<string,object>)this.balance)[(string)type] = this.extend(response, this.safeValue(this.balance, type, new Dictionary<string, object>() {}));
        // don't remove the future from the .futures cache
        var future = getValue(client.futures, messageHash);
        (future as Future).resolve();
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, type), add(type, ":balance")});
    }

    /**
     * @method
     * @name binance#fetchBalanceWs
     * @description fetch balance and get the amount of funds available for trading or funds locked in orders
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/websocket-api/Futures-Account-Balance
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/account-requests#account-information-user_data
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/account/websocket-api
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string|undefined} [params.type] 'future', 'delivery', 'savings', 'funding', or 'spot'
     * @param {string|undefined} [params.marginMode] 'cross' or 'isolated', for margin trading, uses this.options.defaultMarginMode if not passed, defaults to undefined/None/null
     * @param {string[]|undefined} [params.symbols] unified market symbols, only used in isolated margin mode
     * @param {string|undefined} [params.method] method to use. Can be account.balance, account.status, v2/account.balance or v2/account.status
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalanceWs(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = this.getMarketType("fetchBalanceWs", null, parameters);
        if (isTrue(isTrue(isTrue(!isEqual(type, "spot")) && isTrue(!isEqual(type, "future"))) && isTrue(!isEqual(type, "delivery"))))
        {
            throw new BadRequest ((string)add(this.id, " fetchBalanceWs only supports spot or swap markets")) ;
        }
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "ws-api"), type);
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "fetchBalanceWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        object payload = new Dictionary<string, object>() {
            { "returnRateLimits", returnRateLimits },
        };
        object method = null;
        var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchBalanceWs", "method", "account.status");
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", method },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", ((bool) isTrue((isEqual(method, "account.status")))) ? this.handleAccountStatusWs : this.handleBalanceWs },
        };
        return await this.watch(url, messageHash, message, messageHash, subscription);
    }

    public virtual void handleBalanceWs(WebSocketClient client, object message)
    {
        //
        //
        object messageHash = this.safeString(message, "id");
        object rawBalance = null;
        if (isTrue(((getValue(message, "result") is IList<object>) || (getValue(message, "result").GetType().IsGenericType && getValue(message, "result").GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            // account.balance
            rawBalance = this.safeList(message, "result", new List<object>() {});
        } else
        {
            // account.status
            object result = this.safeDict(message, "result", new Dictionary<string, object>() {});
            rawBalance = this.safeList(result, "assets", new List<object>() {});
        }
        object parsedBalances = this.parseBalanceCustom(rawBalance);
        callDynamically(client as WebSocketClient, "resolve", new object[] {parsedBalances, messageHash});
    }

    public virtual void handleAccountStatusWs(WebSocketClient client, object message)
    {
        //
        // spot
        //    {
        //        "id": "605a6d20-6588-4cb9-afa0-b0ab087507ba",
        //        "status": 200,
        //        "result": {
        //            "makerCommission": 15,
        //            "takerCommission": 15,
        //            "buyerCommission": 0,
        //            "sellerCommission": 0,
        //            "canTrade": true,
        //            "canWithdraw": true,
        //            "canDeposit": true,
        //            "commissionRates": {
        //                "maker": "0.00150000",
        //                "taker": "0.00150000",
        //                "buyer": "0.00000000",
        //                "seller": "0.00000000"
        //            },
        //            "brokered": false,
        //            "requireSelfTradePrevention": false,
        //            "updateTime": 1660801833000,
        //            "accountType": "SPOT",
        //            "balances": [{
        //                    "asset": "BNB",
        //                    "free": "0.00000000",
        //                    "locked": "0.00000000"
        //                },
        //                {
        //                    "asset": "BTC",
        //                    "free": "1.3447112",
        //                    "locked": "0.08600000"
        //                },
        //                {
        //                    "asset": "USDT",
        //                    "free": "1021.21000000",
        //                    "locked": "0.00000000"
        //                }
        //            ],
        //            "permissions": [
        //                "SPOT"
        //            ]
        //        }
        //    }
        // swap
        //
        object messageHash = this.safeString(message, "id");
        object result = this.safeDict(message, "result", new Dictionary<string, object>() {});
        object parsedBalances = this.parseBalanceCustom(result);
        callDynamically(client as WebSocketClient, "resolve", new object[] {parsedBalances, messageHash});
    }

    /**
     * @method
     * @name binance#fetchPositionWs
     * @description fetch data on an open position
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/Position-Information
     * @param {string} symbol unified market symbol of the market the position is held in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositionWs(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchPositionsWs(new List<object>() {symbol}, parameters);
    }

    /**
     * @method
     * @name binance#fetchPositionsWs
     * @description fetch all open positions
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/Position-Information
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/websocket-api/Position-Information
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.returnRateLimits] set to true to return rate limit informations, defaults to false.
     * @param {string|undefined} [params.method] method to use. Can be account.position or v2/account.position
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositionsWs(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object payload = new Dictionary<string, object>() {};
        object market = null;
        symbols = this.marketSymbols(symbols, "swap", true, true, true);
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(isEqual(symbolsLength, 1)))
            {
                market = this.market(getValue(symbols, 0));
                ((IDictionary<string,object>)payload)["symbol"] = getValue(market, "id");
            }
        }
        object type = this.getMarketType("fetchPositionsWs", market, parameters);
        if (isTrue(isTrue(!isEqual(type, "future")) && isTrue(!isEqual(type, "delivery"))))
        {
            throw new BadRequest ((string)add(this.id, " fetchPositionsWs only supports swap markets")) ;
        }
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "ws-api"), type);
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "fetchPositionsWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        ((IDictionary<string,object>)payload)["returnRateLimits"] = returnRateLimits;
        object method = null;
        var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchPositionsWs", "method", "account.position");
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", method },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handlePositionsWs },
        };
        object result = await this.watch(url, messageHash, message, messageHash, subscription);
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public virtual void handlePositionsWs(WebSocketClient client, object message)
    {
        //
        //    {
        //        id: '1',
        //        status: 200,
        //        result: [
        //            {
        //                symbol: 'BTCUSDT',
        //                positionAmt: '-0.014',
        //                entryPrice: '42901.1',
        //                breakEvenPrice: '30138.83333142',
        //                markPrice: '71055.98470333',
        //                unRealizedProfit: '-394.16838584',
        //                liquidationPrice: '137032.02272908',
        //                leverage: '123',
        //                maxNotionalValue: '50000',
        //                marginType: 'cross',
        //                isolatedMargin: '0.00000000',
        //                isAutoAddMargin: 'false',
        //                positionSide: 'BOTH',
        //                notional: '-994.78378584',
        //                isolatedWallet: '0',
        //                updateTime: 1708906343111,
        //                isolated: false,
        //                adlQuantile: 2
        //            },
        //            ...
        //        ]
        //    }
        //
        //
        object messageHash = this.safeString(message, "id");
        object result = this.safeList(message, "result", new List<object>() {});
        object positions = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
        {
            object parsed = this.parsePositionRisk(getValue(result, i));
            object entryPrice = this.safeString(parsed, "entryPrice");
            if (isTrue(isTrue(isTrue((!isEqual(entryPrice, "0"))) && isTrue((!isEqual(entryPrice, "0.0")))) && isTrue((!isEqual(entryPrice, "0.00000000")))))
            {
                ((IList<object>)positions).Add(parsed);
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {positions, messageHash});
    }

    /**
     * @method
     * @name binance#watchBalance
     * @description watch balance and get the amount of funds available for trading or funds locked in orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.portfolioMargin] set to true if you would like to watch the balance of a portfolio margin account
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate(parameters);
        object defaultType = this.safeString(this.options, "defaultType", "spot");
        object type = this.safeString(parameters, "type", defaultType);
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchBalance", null, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object isPortfolioMargin = null;
        var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "watchBalance", "papi", "portfolioMargin", false);
        isPortfolioMargin = ((IList<object>)isPortfolioMarginparametersVariable)[0];
        parameters = ((IList<object>)isPortfolioMarginparametersVariable)[1];
        if (isTrue(this.isLinear(type, subType)))
        {
            type = "future";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            type = "delivery";
        }
        object url = "";
        object urlType = type;
        if (isTrue(isEqual(type, "spot")))
        {
            // route to WebSocket API connection where the user data stream is subscribed
            url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "ws-api"), type);
        } else
        {
            if (isTrue(isPortfolioMargin))
            {
                urlType = "papi";
            }
            url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), urlType), "/"), getValue(getValue(this.options, type), "listenKey"));
        }
        var client = this.client(url);
        this.setBalanceCache(client as WebSocketClient, type, isPortfolioMargin);
        this.setPositionsCache(client as WebSocketClient, type, null, isPortfolioMargin);
        object options = this.safeDict(this.options, "watchBalance");
        object fetchBalanceSnapshot = this.safeBool(options, "fetchBalanceSnapshot", false);
        object awaitBalanceSnapshot = this.safeBool(options, "awaitBalanceSnapshot", true);
        if (isTrue(isTrue(fetchBalanceSnapshot) && isTrue(awaitBalanceSnapshot)))
        {
            await client.future(add(type, ":fetchBalanceSnapshot"));
        }
        object messageHash = add(type, ":balance");
        object message = null;
        return await this.watch(url, messageHash, message, type);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        // sent upon a balance update not related to orders
        //
        //     {
        //         "e": "balanceUpdate",
        //         "E": 1629352505586,
        //         "a": "IOTX",
        //         "d": "0.43750000",
        //         "T": 1629352505585
        //     }
        //
        // sent upon creating or filling an order
        //
        //     {
        //         "e": "outboundAccountPosition", // Event type
        //         "E": 1564034571105,             // Event Time
        //         "u": 1564034571073,             // Time of last account update
        //         "B": [                          // Balances Array
        //             {
        //                 "a": "ETH",                 // Asset
        //                 "f": "10000.000000",        // Free
        //                 "l": "0.000000"             // Locked
        //             }
        //         ]
        //     }
        //
        // future/delivery
        //
        //     {
        //         "e": "ACCOUNT_UPDATE",            // Event Type
        //         "E": 1564745798939,               // Event Time
        //         "T": 1564745798938 ,              // Transaction
        //         "i": "SfsR",                      // Account Alias
        //         "a": {                            // Update Data
        //             "m":"ORDER",                  // Event reason type
        //             "B":[                         // Balances
        //                 {
        //                     "a":"BTC",                // Asset
        //                     "wb":"122624.12345678",   // Wallet Balance
        //                     "cw":"100.12345678"       // Cross Wallet Balance
        //                 },
        //             ],
        //             "P":[
        //                 {
        //                     "s":"BTCUSD_200925",      // Symbol
        //                     "pa":"0",                 // Position Amount
        //                     "ep":"0.0",               // Entry Price
        //                     "cr":"200",               // (Pre-fee) Accumulated Realized
        //                     "up":"0",                 // Unrealized PnL
        //                     "mt":"isolated",          // Margin Type
        //                     "iw":"0.00000000",        // Isolated Wallet (if isolated position)
        //                     "ps":"BOTH"               // Position Side
        //                 },
        //             ]
        //         }
        //     }
        // externalLockUpdate
        //    {
        //        "e": "externalLockUpdate",  // Event Type
        //        "E": 1581557507324,         // Event Time
        //        "a": "NEO",                 // Asset
        //        "d": "10.00000000",         // Delta
        //        "T": 1581557507268          // Transaction Time
        //    }
        //
        object wallet = this.safeString(this.options, "wallet", "wb"); // cw for cross wallet
        // each account is connected to a different endpoint
        object subscriptions = ((WebSocketClient)client).subscriptions;
        object subscriptionsKeys = new List<object>(((IDictionary<string,object>)subscriptions).Keys);
        object accountType = this.getAccountTypeFromSubscriptions(subscriptionsKeys);
        object messageHash = add(accountType, ":balance");
        if (isTrue(isEqual(getValue(this.balance, accountType), null)))
        {
            ((IDictionary<string,object>)this.balance)[(string)accountType] = new Dictionary<string, object>() {};
        }
        ((IDictionary<string,object>)getValue(this.balance, accountType))["info"] = message;
        object eventVar = this.safeString(message, "e");
        if (isTrue(isEqual(eventVar, "balanceUpdate")))
        {
            object currencyId = this.safeString(message, "a");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            object delta = this.safeString(message, "d");
            if (isTrue(inOp(getValue(this.balance, accountType), code)))
            {
                object previousValue = getValue(getValue(getValue(this.balance, accountType), code), "free");
                if (isTrue(!(previousValue is string)))
                {
                    previousValue = this.numberToString(previousValue);
                }
                ((IDictionary<string,object>)account)["free"] = Precise.stringAdd(previousValue, delta);
            } else
            {
                ((IDictionary<string,object>)account)["free"] = delta;
            }
            ((IDictionary<string,object>)getValue(this.balance, accountType))[(string)code] = account;
        } else
        {
            message = this.safeDict(message, "a", message);
            object B = this.safeList(message, "B");
            for (object i = 0; isLessThan(i, getArrayLength(B)); postFixIncrement(ref i))
            {
                object entry = getValue(B, i);
                object currencyId = this.safeString(entry, "a");
                object code = this.safeCurrencyCode(currencyId);
                object account = this.account();
                ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "f");
                ((IDictionary<string,object>)account)["used"] = this.safeString(entry, "l");
                ((IDictionary<string,object>)account)["total"] = this.safeString(entry, wallet);
                ((IDictionary<string,object>)getValue(this.balance, accountType))[(string)code] = account;
            }
        }
        object timestamp = this.safeInteger(message, "E");
        ((IDictionary<string,object>)getValue(this.balance, accountType))["timestamp"] = timestamp;
        ((IDictionary<string,object>)getValue(this.balance, accountType))["datetime"] = this.iso8601(timestamp);
        ((IDictionary<string,object>)this.balance)[(string)accountType] = this.safeBalance(getValue(this.balance, accountType));
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, accountType), messageHash});
    }

    public virtual object getAccountTypeFromSubscriptions(object subscriptions)
    {
        object accountType = "";
        for (object i = 0; isLessThan(i, getArrayLength(subscriptions)); postFixIncrement(ref i))
        {
            object subscription = getValue(subscriptions, i);
            if (isTrue(isTrue(isTrue(isTrue((isEqual(subscription, "spot"))) || isTrue((isEqual(subscription, "margin")))) || isTrue((isEqual(subscription, "future")))) || isTrue((isEqual(subscription, "delivery")))))
            {
                accountType = subscription;
                break;
            }
        }
        return accountType;
    }

    public virtual object getMarketType(object method, object market, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams(method, market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams(method, market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(this.isLinear(type, subType)))
        {
            type = "future";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            type = "delivery";
        }
        return type;
    }

    /**
     * @method
     * @name binance#createOrderWs
     * @description create a trade order
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#place-new-order-trade
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/New-Order
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/websocket-api
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float|undefined} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} params.test test order, default false
     * @param {boolean} params.returnRateLimits set to true to return rate limit information, default false
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrderWs(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketType = this.getMarketType("createOrderWs", market, parameters);
        if (isTrue(isTrue(isTrue(!isEqual(marketType, "spot")) && isTrue(!isEqual(marketType, "future"))) && isTrue(!isEqual(marketType, "delivery"))))
        {
            throw new BadRequest ((string)add(this.id, " createOrderWs only supports spot or swap markets")) ;
        }
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "ws-api"), marketType);
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object sor = this.safeBool2(parameters, "sor", "SOR", false);
        parameters = this.omit(parameters, "sor", "SOR");
        object payload = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "createOrderWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        ((IDictionary<string,object>)payload)["returnRateLimits"] = returnRateLimits;
        object test = this.safeBool(parameters, "test", false);
        parameters = this.omit(parameters, "test");
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "order.place" },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        if (isTrue(test))
        {
            if (isTrue(sor))
            {
                ((IDictionary<string,object>)message)["method"] = "sor.order.test";
            } else
            {
                ((IDictionary<string,object>)message)["method"] = "order.test";
            }
        }
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleOrderWs },
        };
        return await this.watch(url, messageHash, message, messageHash, subscription);
    }

    public virtual void handleOrderWs(WebSocketClient client, object message)
    {
        //
        //    {
        //        "id": 1,
        //        "status": 200,
        //        "result": {
        //          "symbol": "BTCUSDT",
        //          "orderId": 7663053,
        //          "orderListId": -1,
        //          "clientOrderId": "x-R4BD3S82d8959d0f5114499487a614",
        //          "transactTime": 1687642291434,
        //          "price": "25000.00000000",
        //          "origQty": "0.00100000",
        //          "executedQty": "0.00000000",
        //          "cummulativeQuoteQty": "0.00000000",
        //          "status": "NEW",
        //          "timeInForce": "GTC",
        //          "type": "LIMIT",
        //          "side": "BUY",
        //          "workingTime": 1687642291434,
        //          "fills": [],
        //          "selfTradePreventionMode": "NONE"
        //        },
        //        "rateLimits": [
        //          {
        //            "rateLimitType": "ORDERS",
        //            "interval": "SECOND",
        //            "intervalNum": 10,
        //            "limit": 50,
        //            "count": 1
        //          },
        //          {
        //            "rateLimitType": "ORDERS",
        //            "interval": "DAY",
        //            "intervalNum": 1,
        //            "limit": 160000,
        //            "count": 1
        //          },
        //          {
        //            "rateLimitType": "REQUEST_WEIGHT",
        //            "interval": "MINUTE",
        //            "intervalNum": 1,
        //            "limit": 1200,
        //            "count": 12
        //          }
        //        ]
        //    }
        //
        object messageHash = this.safeString(message, "id");
        object result = this.safeDict(message, "result", new Dictionary<string, object>() {});
        object order = this.parseOrder(result);
        callDynamically(client as WebSocketClient, "resolve", new object[] {order, messageHash});
    }

    public virtual void handleOrdersWs(WebSocketClient client, object message)
    {
        //
        //    {
        //        "id": 1,
        //        "status": 200,
        //        "result": [{
        //            "symbol": "BTCUSDT",
        //            "orderId": 7665584,
        //            "orderListId": -1,
        //            "clientOrderId": "x-R4BD3S82b54769abdd3e4b57874c52",
        //            "price": "26000.00000000",
        //            "origQty": "0.00100000",
        //            "executedQty": "0.00000000",
        //            "cummulativeQuoteQty": "0.00000000",
        //            "status": "NEW",
        //            "timeInForce": "GTC",
        //            "type": "LIMIT",
        //            "side": "BUY",
        //            "stopPrice": "0.00000000",
        //            "icebergQty": "0.00000000",
        //            "time": 1687642884646,
        //            "updateTime": 1687642884646,
        //            "isWorking": true,
        //            "workingTime": 1687642884646,
        //            "origQuoteOrderQty": "0.00000000",
        //            "selfTradePreventionMode": "NONE"
        //        },
        //        ...
        //        ],
        //        "rateLimits": [{
        //            "rateLimitType": "REQUEST_WEIGHT",
        //            "interval": "MINUTE",
        //            "intervalNum": 1,
        //            "limit": 1200,
        //            "count": 14
        //        }]
        //    }
        //
        object messageHash = this.safeString(message, "id");
        object result = this.safeList(message, "result", new List<object>() {});
        object orders = this.parseOrders(result);
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
    }

    /**
     * @method
     * @name binance#editOrderWs
     * @description edit a trade order
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#cancel-and-replace-order-trade
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/Modify-Order
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/websocket-api/Modify-Order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of the currency you want to trade in units of the base currency
     * @param {float|undefined} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> editOrderWs(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketType = this.getMarketType("editOrderWs", market, parameters);
        if (isTrue(isTrue(isTrue(!isEqual(marketType, "spot")) && isTrue(!isEqual(marketType, "future"))) && isTrue(!isEqual(marketType, "delivery"))))
        {
            throw new BadRequest ((string)add(this.id, " editOrderWs only supports spot or swap markets")) ;
        }
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "ws-api"), marketType);
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object isSwap = (isTrue(isEqual(marketType, "future")) || isTrue(isEqual(marketType, "delivery")));
        object payload = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            payload = this.editSpotOrderRequest(id, symbol, type, side, amount, price, parameters);
        } else if (isTrue(isSwap))
        {
            payload = this.editContractOrderRequest(id, symbol, type, side, amount, price, parameters);
        }
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "editOrderWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        ((IDictionary<string,object>)payload)["returnRateLimits"] = returnRateLimits;
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", ((bool) isTrue((isSwap))) ? "order.modify" : "order.cancelReplace" },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleEditOrderWs },
        };
        return await this.watch(url, messageHash, message, messageHash, subscription);
    }

    public virtual void handleEditOrderWs(WebSocketClient client, object message)
    {
        //
        // spot
        //    {
        //        "id": 1,
        //        "status": 200,
        //        "result": {
        //            "cancelResult": "SUCCESS",
        //            "newOrderResult": "SUCCESS",
        //            "cancelResponse": {
        //                "symbol": "BTCUSDT",
        //                "origClientOrderId": "x-R4BD3S82813c5d7ffa594104917de2",
        //                "orderId": 7665177,
        //                "orderListId": -1,
        //                "clientOrderId": "mbrnbQsQhtCXCLY45d5q7S",
        //                "price": "26000.00000000",
        //                "origQty": "0.00100000",
        //                "executedQty": "0.00000000",
        //                "cummulativeQuoteQty": "0.00000000",
        //                "status": "CANCELED",
        //                "timeInForce": "GTC",
        //                "type": "LIMIT",
        //                "side": "BUY",
        //                "selfTradePreventionMode": "NONE"
        //            },
        //            "newOrderResponse": {
        //                "symbol": "BTCUSDT",
        //                "orderId": 7665584,
        //                "orderListId": -1,
        //                "clientOrderId": "x-R4BD3S82b54769abdd3e4b57874c52",
        //                "transactTime": 1687642884646,
        //                "price": "26000.00000000",
        //                "origQty": "0.00100000",
        //                "executedQty": "0.00000000",
        //                "cummulativeQuoteQty": "0.00000000",
        //                "status": "NEW",
        //                "timeInForce": "GTC",
        //                "type": "LIMIT",
        //                "side": "BUY",
        //                "workingTime": 1687642884646,
        //                "fills": [],
        //                "selfTradePreventionMode": "NONE"
        //            }
        //        },
        //        "rateLimits": [{
        //                "rateLimitType": "ORDERS",
        //                "interval": "SECOND",
        //                "intervalNum": 10,
        //                "limit": 50,
        //                "count": 1
        //            },
        //            {
        //                "rateLimitType": "ORDERS",
        //                "interval": "DAY",
        //                "intervalNum": 1,
        //                "limit": 160000,
        //                "count": 3
        //            },
        //            {
        //                "rateLimitType": "REQUEST_WEIGHT",
        //                "interval": "MINUTE",
        //                "intervalNum": 1,
        //                "limit": 1200,
        //                "count": 12
        //            }
        //        ]
        //    }
        // swap
        //    {
        //        "id":"1",
        //        "status":200,
        //        "result":{
        //            "orderId":667061487,
        //            "symbol":"LTCUSDT",
        //            "status":"NEW",
        //            "clientOrderId":"x-xcKtGhcu91a74c818749ee42c0f70",
        //            "price":"82.00",
        //            "avgPrice":"0.00",
        //            "origQty":"1.000",
        //            "executedQty":"0.000",
        //            "cumQty":"0.000",
        //            "cumQuote":"0.00000",
        //            "timeInForce":"GTC",
        //            "type":"LIMIT",
        //            "reduceOnly":false,
        //            "closePosition":false,
        //            "side":"BUY",
        //            "positionSide":"BOTH",
        //            "stopPrice":"0.00",
        //            "workingType":"CONTRACT_PRICE",
        //            "priceProtect":false,
        //            "origType":"LIMIT",
        //            "priceMatch":"NONE",
        //            "selfTradePreventionMode":"NONE",
        //            "goodTillDate":0,
        //            "updateTime":1712918927511
        //        }
        //    }
        //
        object messageHash = this.safeString(message, "id");
        object result = this.safeDict(message, "result", new Dictionary<string, object>() {});
        object newSpotOrder = this.safeDict(result, "newOrderResponse");
        object order = null;
        if (isTrue(!isEqual(newSpotOrder, null)))
        {
            order = this.parseOrder(newSpotOrder);
        } else
        {
            order = this.parseOrder(result);
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {order, messageHash});
    }

    /**
     * @method
     * @name binance#cancelOrderWs
     * @description cancel multiple orders
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#cancel-order-trade
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/Cancel-Order
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/websocket-api/Cancel-Order
     * @param {string} id order id
     * @param {string} [symbol] unified market symbol, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string|undefined} [params.cancelRestrictions] Supported values: ONLY_NEW - Cancel will succeed if the order status is NEW. ONLY_PARTIALLY_FILLED - Cancel will succeed if order status is PARTIALLY_FILLED.
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrderWs(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new BadRequest ((string)add(this.id, " cancelOrderWs requires a symbol")) ;
        }
        object market = this.market(symbol);
        object type = this.getMarketType("cancelOrderWs", market, parameters);
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "ws-api"), type);
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "cancelOrderWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        object payload = new Dictionary<string, object>() {
            { "symbol", this.marketId(symbol) },
            { "returnRateLimits", returnRateLimits },
        };
        object clientOrderId = this.safeString2(parameters, "origClientOrderId", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)payload)["origClientOrderId"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)payload)["orderId"] = this.parseToInt(id);
        }
        parameters = this.omit(parameters, new List<object>() {"origClientOrderId", "clientOrderId"});
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "order.cancel" },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleOrderWs },
        };
        return await this.watch(url, messageHash, message, messageHash, subscription);
    }

    /**
     * @method
     * @name binance#cancelAllOrdersWs
     * @description cancel all open orders in a market
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#cancel-open-orders-trade
     * @param {string} [symbol] unified market symbol of the market to cancel orders in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrdersWs(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object type = this.getMarketType("cancelAllOrdersWs", market, parameters);
        if (isTrue(!isEqual(type, "spot")))
        {
            throw new BadRequest ((string)add(this.id, " cancelAllOrdersWs only supports spot markets")) ;
        }
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "ws-api"), type);
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "cancelAllOrdersWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        object payload = new Dictionary<string, object>() {
            { "symbol", this.marketId(symbol) },
            { "returnRateLimits", returnRateLimits },
        };
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "openOrders.cancelAll" },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleOrdersWs },
        };
        return await this.watch(url, messageHash, message, messageHash, subscription);
    }

    /**
     * @method
     * @name binance#fetchOrderWs
     * @description fetches information on an order made by the user
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#query-order-user_data
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/Query-Order
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/websocket-api/Query-Order
     * @param {string} id order id
     * @param {string} [symbol] unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrderWs(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new BadRequest ((string)add(this.id, " cancelOrderWs requires a symbol")) ;
        }
        object market = this.market(symbol);
        object type = this.getMarketType("fetchOrderWs", market, parameters);
        if (isTrue(isTrue(isTrue(!isEqual(type, "spot")) && isTrue(!isEqual(type, "future"))) && isTrue(!isEqual(type, "delivery"))))
        {
            throw new BadRequest ((string)add(this.id, " fetchOrderWs only supports spot or swap markets")) ;
        }
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "ws-api"), type);
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "fetchOrderWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        object payload = new Dictionary<string, object>() {
            { "symbol", this.marketId(symbol) },
            { "returnRateLimits", returnRateLimits },
        };
        object clientOrderId = this.safeString2(parameters, "origClientOrderId", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)payload)["origClientOrderId"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)payload)["orderId"] = this.parseToInt(id);
        }
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "order.status" },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleOrderWs },
        };
        return await this.watch(url, messageHash, message, messageHash, subscription);
    }

    /**
     * @method
     * @name binance#fetchOrdersWs
     * @description fetches information on multiple orders made by the user
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#order-lists
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int|undefined} [since] the earliest time in ms to fetch orders for
     * @param {int|undefined} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.orderId] order id to begin at
     * @param {int} [params.startTime] earliest time in ms to retrieve orders for
     * @param {int} [params.endTime] latest time in ms to retrieve orders for
     * @param {int} [params.limit] the maximum number of order structures to retrieve
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrdersWs(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new BadRequest ((string)add(this.id, " fetchOrdersWs requires a symbol")) ;
        }
        object market = this.market(symbol);
        object type = this.getMarketType("fetchOrdersWs", market, parameters);
        if (isTrue(!isEqual(type, "spot")))
        {
            throw new BadRequest ((string)add(this.id, " fetchOrdersWs only supports spot markets")) ;
        }
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "ws-api"), type);
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "fetchOrderWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        object payload = new Dictionary<string, object>() {
            { "symbol", this.marketId(symbol) },
            { "returnRateLimits", returnRateLimits },
        };
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "allOrders" },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleOrdersWs },
        };
        object orders = await this.watch(url, messageHash, message, messageHash, subscription);
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit);
    }

    /**
     * @method
     * @name binance#fetchClosedOrdersWs
     * @description fetch closed orders
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#order-lists
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrdersWs(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object orders = await this.fetchOrdersWs(symbol, since, limit, parameters);
        object closedOrders = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object order = getValue(orders, i);
            if (isTrue(isEqual(getValue(order, "status"), "closed")))
            {
                ((IList<object>)closedOrders).Add(order);
            }
        }
        return closedOrders;
    }

    /**
     * @method
     * @name binance#fetchOpenOrdersWs
     * @description fetch all unfilled currently open orders
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#current-open-orders-user_data
     * @param {string} symbol unified market symbol
     * @param {int|undefined} [since] the earliest time in ms to fetch open orders for
     * @param {int|undefined} [limit] the maximum number of open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrdersWs(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object type = this.getMarketType("fetchOpenOrdersWs", market, parameters);
        if (isTrue(isTrue(!isEqual(type, "spot")) && isTrue(!isEqual(type, "future"))))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenOrdersWs only supports spot or swap markets")) ;
        }
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "ws-api"), type);
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "fetchOrderWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        object payload = new Dictionary<string, object>() {
            { "returnRateLimits", returnRateLimits },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            ((IDictionary<string,object>)payload)["symbol"] = this.marketId(symbol);
        }
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "openOrders.status" },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleOrdersWs },
        };
        object orders = await this.watch(url, messageHash, message, messageHash, subscription);
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit);
    }

    /**
     * @method
     * @name binance#watchOrders
     * @description watches information on multiple orders made by the user
     * @see https://developers.binance.com/docs/binance-spot-api-docs/user-data-stream#order-update
     * @see https://developers.binance.com/docs/margin_trading/trade-data-stream/Event-Order-Update
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/user-data-streams/Event-Order-Update
     * @param {string} symbol unified market symbol of the market the orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string|undefined} [params.marginMode] 'cross' or 'isolated', for spot margin
     * @param {boolean} [params.portfolioMargin] set to true if you would like to watch portfolio margin account orders
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object messageHash = "orders";
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            messageHash = add(messageHash, add(":", symbol));
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchOrders", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(this.isLinear(type, subType)))
        {
            type = "future";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            type = "delivery";
        }
        parameters = this.extend(parameters, new Dictionary<string, object>() {
            { "type", type },
            { "symbol", symbol },
        }); // needed inside authenticate for isolated margin
        await this.authenticate(parameters);
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("watchOrders", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object urlType = type;
        if (isTrue(isTrue((isEqual(type, "margin"))) || isTrue((isTrue((isEqual(type, "spot"))) && isTrue((!isEqual(marginMode, null)))))))
        {
            urlType = "spot"; // spot-margin shares the same stream as regular spot
        }
        object isPortfolioMargin = null;
        var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "watchOrders", "papi", "portfolioMargin", false);
        isPortfolioMargin = ((IList<object>)isPortfolioMarginparametersVariable)[0];
        parameters = ((IList<object>)isPortfolioMarginparametersVariable)[1];
        object url = "";
        if (isTrue(isEqual(type, "spot")))
        {
            // route orders to ws-api user data stream
            url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "ws-api"), type);
        } else
        {
            if (isTrue(isPortfolioMargin))
            {
                urlType = "papi";
            }
            url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), urlType), "/"), getValue(getValue(this.options, type), "listenKey"));
        }
        var client = this.client(url);
        this.setBalanceCache(client as WebSocketClient, type, isPortfolioMargin);
        this.setPositionsCache(client as WebSocketClient, type, null, isPortfolioMargin);
        object message = null;
        object orders = await this.watch(url, messageHash, message, type);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        // spot
        //
        //     {
        //         "e": "executionReport",        // Event type
        //         "E": 1499405658658,            // Event time
        //         "s": "ETHBTC",                 // Symbol
        //         "c": "mUvoqJxFIILMdfAW5iGSOW", // Client order ID
        //         "S": "BUY",                    // Side
        //         "o": "LIMIT",                  // Order type
        //         "f": "GTC",                    // Time in force
        //         "q": "1.00000000",             // Order quantity
        //         "p": "0.10264410",             // Order price
        //         "P": "0.00000000",             // Stop price
        //         "F": "0.00000000",             // Iceberg quantity
        //         "g": -1,                       // OrderListId
        //         "C": null,                     // Original client order ID; This is the ID of the order being canceled
        //         "x": "NEW",                    // Current execution type
        //         "X": "NEW",                    // Current order status
        //         "r": "NONE",                   // Order reject reason; will be an error code.
        //         "i": 4293153,                  // Order ID
        //         "l": "0.00000000",             // Last executed quantity
        //         "z": "0.00000000",             // Cumulative filled quantity
        //         "L": "0.00000000",             // Last executed price
        //         "n": "0",                      // Commission amount
        //         "N": null,                     // Commission asset
        //         "T": 1499405658657,            // Transaction time
        //         "t": -1,                       // Trade ID
        //         "I": 8641984,                  // Ignore
        //         "w": true,                     // Is the order on the book?
        //         "m": false,                    // Is this trade the maker side?
        //         "M": false,                    // Ignore
        //         "O": 1499405658657,            // Order creation time
        //         "Z": "0.00000000",             // Cumulative quote asset transacted quantity
        //         "Y": "0.00000000"              // Last quote asset transacted quantity (i.e. lastPrice * lastQty),
        //         "Q": "0.00000000"              // Quote Order Qty
        //     }
        //
        // future
        //
        //     {
        //         "s":"BTCUSDT",                 // Symbol
        //         "c":"TEST",                    // Client Order Id
        //                                        // special client order id:
        //                                        // starts with "autoclose-": liquidation order
        //                                        // "adl_autoclose": ADL auto close order
        //         "S":"SELL",                    // Side
        //         "o":"TRAILING_STOP_MARKET",    // Order Type
        //         "f":"GTC",                     // Time in Force
        //         "q":"0.001",                   // Original Quantity
        //         "p":"0",                       // Original Price
        //         "ap":"0",                      // Average Price
        //         "sp":"7103.04",                // Stop Price. Please ignore with TRAILING_STOP_MARKET order
        //         "x":"NEW",                     // Execution Type
        //         "X":"NEW",                     // Order Status
        //         "i":8886774,                   // Order Id
        //         "l":"0",                       // Order Last Filled Quantity
        //         "z":"0",                       // Order Filled Accumulated Quantity
        //         "L":"0",                       // Last Filled Price
        //         "N":"USDT",                    // Commission Asset, will not push if no commission
        //         "n":"0",                       // Commission, will not push if no commission
        //         "T":1568879465651,             // Order Trade Time
        //         "t":0,                         // Trade Id
        //         "b":"0",                       // Bids Notional
        //         "a":"9.91",                    // Ask Notional
        //         "m":false,                     // Is this trade the maker side?
        //         "R":false,                     // Is this reduce only
        //         "wt":"CONTRACT_PRICE",         // Stop Price Working Type
        //         "ot":"TRAILING_STOP_MARKET",   // Original Order Type
        //         "ps":"LONG",                   // Position Side
        //         "cp":false,                    // If Close-All, pushed with conditional order
        //         "AP":"7476.89",                // Activation Price, only puhed with TRAILING_STOP_MARKET order
        //         "cr":"5.0",                    // Callback Rate, only puhed with TRAILING_STOP_MARKET order
        //         "rp":"0"                       // Realized Profit of the trade
        //     }
        //
        object executionType = this.safeString(order, "x");
        object orderId = this.safeString(order, "i");
        object marketId = this.safeString(order, "s");
        object marketType = ((bool) isTrue((inOp(order, "ps")))) ? "contract" : "spot";
        object symbol = this.safeSymbol(marketId, null, null, marketType);
        object timestamp = this.safeInteger(order, "O");
        object T = this.safeInteger(order, "T");
        object lastTradeTimestamp = null;
        if (isTrue(isTrue(isTrue(isEqual(executionType, "NEW")) || isTrue(isEqual(executionType, "AMENDMENT"))) || isTrue(isEqual(executionType, "CANCELED"))))
        {
            if (isTrue(isEqual(timestamp, null)))
            {
                timestamp = T;
            }
        } else if (isTrue(isEqual(executionType, "TRADE")))
        {
            lastTradeTimestamp = T;
        }
        object lastUpdateTimestamp = T;
        object fee = null;
        object feeCost = this.safeString(order, "n");
        if (isTrue(isTrue((!isEqual(feeCost, null))) && isTrue((Precise.stringGt(feeCost, "0")))))
        {
            object feeCurrencyId = this.safeString(order, "N");
            object feeCurrency = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrency },
            };
        }
        object price = this.safeString(order, "p");
        object amount = this.safeString(order, "q");
        object side = this.safeStringLower(order, "S");
        object type = this.safeStringLower(order, "o");
        object filled = this.safeString(order, "z");
        object cost = this.safeString(order, "Z");
        object average = this.safeString(order, "ap");
        object rawStatus = this.safeString(order, "X");
        object status = this.parseOrderStatus(rawStatus);
        object trades = null;
        object clientOrderId = this.safeString(order, "C");
        if (isTrue(isTrue((isEqual(clientOrderId, null))) || isTrue((isEqual(((string)clientOrderId).Length, 0)))))
        {
            clientOrderId = this.safeString(order, "c");
        }
        object stopPrice = this.safeString2(order, "P", "sp");
        object timeInForce = this.safeString(order, "f");
        if (isTrue(isEqual(timeInForce, "GTX")))
        {
            // GTX means "Good Till Crossing" and is an equivalent way of saying Post Only
            timeInForce = "PO";
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "symbol", symbol },
            { "id", orderId },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "lastUpdateTimestamp", lastUpdateTimestamp },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", null },
            { "reduceOnly", this.safeBool(order, "R") },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "amount", amount },
            { "cost", cost },
            { "average", average },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", fee },
            { "trades", trades },
        });
    }

    public virtual void handleOrderUpdate(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //     {
        //         "e": "executionReport",        // Event type
        //         "E": 1499405658658,            // Event time
        //         "s": "ETHBTC",                 // Symbol
        //         "c": "mUvoqJxFIILMdfAW5iGSOW", // Client order ID
        //         "S": "BUY",                    // Side
        //         "o": "LIMIT",                  // Order type
        //         "f": "GTC",                    // Time in force
        //         "q": "1.00000000",             // Order quantity
        //         "p": "0.10264410",             // Order price
        //         "P": "0.00000000",             // Stop price
        //         "F": "0.00000000",             // Iceberg quantity
        //         "g": -1,                       // OrderListId
        //         "C": null,                     // Original client order ID; This is the ID of the order being canceled
        //         "x": "NEW",                    // Current execution type
        //         "X": "NEW",                    // Current order status
        //         "r": "NONE",                   // Order reject reason; will be an error code.
        //         "i": 4293153,                  // Order ID
        //         "l": "0.00000000",             // Last executed quantity
        //         "z": "0.00000000",             // Cumulative filled quantity
        //         "L": "0.00000000",             // Last executed price
        //         "n": "0",                      // Commission amount
        //         "N": null,                     // Commission asset
        //         "T": 1499405658657,            // Transaction time
        //         "t": -1,                       // Trade ID
        //         "I": 8641984,                  // Ignore
        //         "w": true,                     // Is the order on the book?
        //         "m": false,                    // Is this trade the maker side?
        //         "M": false,                    // Ignore
        //         "O": 1499405658657,            // Order creation time
        //         "Z": "0.00000000",             // Cumulative quote asset transacted quantity
        //         "Y": "0.00000000"              // Last quote asset transacted quantity (i.e. lastPrice * lastQty),
        //         "Q": "0.00000000"              // Quote Order Qty
        //     }
        //
        // future
        //
        //     {
        //         "e":"ORDER_TRADE_UPDATE",           // Event Type
        //         "E":1568879465651,                  // Event Time
        //         "T":1568879465650,                  // Trasaction Time
        //         "o": {
        //             "s":"BTCUSDT",                  // Symbol
        //             "c":"TEST",                     // Client Order Id
        //                                             // special client order id:
        //                                             // starts with "autoclose-": liquidation order
        //                                             // "adl_autoclose": ADL auto close order
        //             "S":"SELL",                     // Side
        //             "o":"TRAILING_STOP_MARKET",     // Order Type
        //             "f":"GTC",                      // Time in Force
        //             "q":"0.001",                    // Original Quantity
        //             "p":"0",                        // Original Price
        //             "ap":"0",                       // Average Price
        //             "sp":"7103.04",                 // Stop Price. Please ignore with TRAILING_STOP_MARKET order
        //             "x":"NEW",                      // Execution Type
        //             "X":"NEW",                      // Order Status
        //             "i":8886774,                    // Order Id
        //             "l":"0",                        // Order Last Filled Quantity
        //             "z":"0",                        // Order Filled Accumulated Quantity
        //             "L":"0",                        // Last Filled Price
        //             "N":"USDT",                     // Commission Asset, will not push if no commission
        //             "n":"0",                        // Commission, will not push if no commission
        //             "T":1568879465651,              // Order Trade Time
        //             "t":0,                          // Trade Id
        //             "b":"0",                        // Bids Notional
        //             "a":"9.91",                     // Ask Notional
        //             "m":false,                      // Is this trade the maker side?
        //             "R":false,                      // Is this reduce only
        //             "wt":"CONTRACT_PRICE",          // Stop Price Working Type
        //             "ot":"TRAILING_STOP_MARKET",    // Original Order Type
        //             "ps":"LONG",                    // Position Side
        //             "cp":false,                     // If Close-All, pushed with conditional order
        //             "AP":"7476.89",                 // Activation Price, only puhed with TRAILING_STOP_MARKET order
        //             "cr":"5.0",                     // Callback Rate, only puhed with TRAILING_STOP_MARKET order
        //             "rp":"0"                        // Realized Profit of the trade
        //         }
        //     }
        //
        object e = this.safeString(message, "e");
        if (isTrue(isEqual(e, "ORDER_TRADE_UPDATE")))
        {
            message = this.safeDict(message, "o", message);
        }
        this.handleMyTrade(client as WebSocketClient, message);
        this.handleOrder(client as WebSocketClient, message);
        this.handleMyLiquidation(client as WebSocketClient, message);
    }

    /**
     * @method
     * @name binance#watchPositions
     * @description watch all open positions
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {number} [since] since timestamp
     * @param {number} [limit] limit
     * @param {object} params extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.portfolioMargin] set to true if you would like to watch positions in a portfolio margin account
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
     */
    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object messageHash = "";
        symbols = this.marketSymbols(symbols);
        if (!isTrue(this.isEmpty(symbols)))
        {
            market = this.getMarketFromSymbols(symbols);
            messageHash = add("::", String.Join(",", ((IList<object>)symbols).ToArray()));
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchPositions", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(isTrue(isEqual(type, "spot")) || isTrue(isEqual(type, "margin"))))
        {
            type = "future";
        }
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchPositions", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(this.isLinear(type, subType)))
        {
            type = "future";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            type = "delivery";
        }
        object marketTypeObject = new Dictionary<string, object>() {};
        ((IDictionary<string,object>)marketTypeObject)["type"] = type;
        ((IDictionary<string,object>)marketTypeObject)["subType"] = subType;
        await this.authenticate(this.extend(marketTypeObject, parameters));
        messageHash = add(add(type, ":positions"), messageHash);
        object isPortfolioMargin = null;
        var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "watchPositions", "papi", "portfolioMargin", false);
        isPortfolioMargin = ((IList<object>)isPortfolioMarginparametersVariable)[0];
        parameters = ((IList<object>)isPortfolioMarginparametersVariable)[1];
        object urlType = type;
        if (isTrue(isPortfolioMargin))
        {
            urlType = "papi";
        }
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), urlType), "/"), getValue(getValue(this.options, type), "listenKey"));
        var client = this.client(url);
        this.setBalanceCache(client as WebSocketClient, type, isPortfolioMargin);
        this.setPositionsCache(client as WebSocketClient, type, symbols, isPortfolioMargin);
        object fetchPositionsSnapshot = this.handleOption("watchPositions", "fetchPositionsSnapshot", true);
        object awaitPositionsSnapshot = this.handleOption("watchPositions", "awaitPositionsSnapshot", true);
        object cache = this.safeValue(this.positions, type);
        if (isTrue(isTrue(isTrue(fetchPositionsSnapshot) && isTrue(awaitPositionsSnapshot)) && isTrue(isEqual(cache, null))))
        {
            object snapshot = await client.future(add(type, ":fetchPositionsSnapshot"));
            return this.filterBySymbolsSinceLimit(snapshot, symbols, since, limit, true);
        }
        object newPositions = await this.watch(url, messageHash, null, type);
        if (isTrue(this.newUpdates))
        {
            return newPositions;
        }
        return this.filterBySymbolsSinceLimit(cache, symbols, since, limit, true);
    }

    public virtual void setPositionsCache(WebSocketClient client, object type, object symbols = null, object isPortfolioMargin = null)
    {
        isPortfolioMargin ??= false;
        if (isTrue(isEqual(type, "spot")))
        {
            return;
        }
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new Dictionary<string, object>() {};
        }
        if (isTrue(inOp(this.positions, type)))
        {
            return;
        }
        object fetchPositionsSnapshot = this.handleOption("watchPositions", "fetchPositionsSnapshot", false);
        if (isTrue(fetchPositionsSnapshot))
        {
            object messageHash = add(type, ":fetchPositionsSnapshot");
            if (!isTrue((inOp(client.futures, messageHash))))
            {
                client.future(messageHash);
                this.spawn(this.loadPositionsSnapshot, new object[] { client, messageHash, type, isPortfolioMargin});
            }
        } else
        {
            ((IDictionary<string,object>)this.positions)[(string)type] = new ArrayCacheBySymbolBySide();
        }
    }

    public async virtual Task loadPositionsSnapshot(WebSocketClient client, object messageHash, object type, object isPortfolioMargin)
    {
        object parameters = new Dictionary<string, object>() {
            { "type", type },
        };
        if (isTrue(isPortfolioMargin))
        {
            ((IDictionary<string,object>)parameters)["portfolioMargin"] = true;
        }
        object positions = await this.fetchPositions(null, parameters);
        ((IDictionary<string,object>)this.positions)[(string)type] = new ArrayCacheBySymbolBySide();
        object cache = getValue(this.positions, type);
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object position = getValue(positions, i);
            object contracts = this.safeNumber(position, "contracts", 0);
            if (isTrue(isGreaterThan(contracts, 0)))
            {
                callDynamically(cache, "append", new object[] {position});
            }
        }
        // don't remove the future from the .futures cache
        var future = getValue(client.futures, messageHash);
        (future as Future).resolve(cache);
        callDynamically(client as WebSocketClient, "resolve", new object[] {cache, add(type, ":position")});
    }

    public virtual void handlePositions(WebSocketClient client, object message)
    {
        //
        //     {
        //         e: 'ACCOUNT_UPDATE',
        //         T: 1667881353112,
        //         E: 1667881353115,
        //         a: {
        //             B: [{
        //                 a: 'USDT',
        //                 wb: '1127.95750089',
        //                 cw: '1040.82091149',
        //                 bc: '0'
        //             }],
        //             P: [{
        //                 s: 'BTCUSDT',
        //                 pa: '-0.089',
        //                 ep: '19700.03933',
        //                 cr: '-1260.24809979',
        //                 up: '1.53058860',
        //                 mt: 'isolated',
        //                 iw: '87.13658940',
        //                 ps: 'BOTH',
        //                 ma: 'USDT'
        //             }],
        //             m: 'ORDER'
        //         }
        //     }
        //
        // each account is connected to a different endpoint
        // and has exactly one subscriptionhash which is the account type
        object subscriptions = ((WebSocketClient)client).subscriptions;
        object subscriptionsKeys = new List<object>(((IDictionary<string,object>)subscriptions).Keys);
        object accountType = this.getAccountTypeFromSubscriptions(subscriptionsKeys);
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new Dictionary<string, object>() {};
        }
        if (!isTrue((inOp(this.positions, accountType))))
        {
            ((IDictionary<string,object>)this.positions)[(string)accountType] = new ArrayCacheBySymbolBySide();
        }
        object cache = getValue(this.positions, accountType);
        object data = this.safeDict(message, "a", new Dictionary<string, object>() {});
        object rawPositions = this.safeList(data, "P", new List<object>() {});
        object newPositions = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rawPositions)); postFixIncrement(ref i))
        {
            object rawPosition = getValue(rawPositions, i);
            object position = this.parseWsPosition(rawPosition);
            object timestamp = this.safeInteger(message, "E");
            ((IDictionary<string,object>)position)["timestamp"] = timestamp;
            ((IDictionary<string,object>)position)["datetime"] = this.iso8601(timestamp);
            ((IList<object>)newPositions).Add(position);
            callDynamically(cache, "append", new object[] {position});
        }
        object messageHashes = this.findMessageHashes(client as WebSocketClient, add(accountType, ":positions::"));
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object positions = this.filterByArray(newPositions, "symbol", symbols, false);
            if (!isTrue(this.isEmpty(positions)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {positions, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newPositions, add(accountType, ":positions")});
    }

    public virtual object parseWsPosition(object position, object market = null)
    {
        //
        //     {
        //         "s": "BTCUSDT", // Symbol
        //         "pa": "0", // Position Amount
        //         "ep": "0.00000", // Entry Price
        //         "cr": "200", // (Pre-fee) Accumulated Realized
        //         "up": "0", // Unrealized PnL
        //         "mt": "isolated", // Margin Type
        //         "iw": "0.00000000", // Isolated Wallet (if isolated position)
        //         "ps": "BOTH" // Position Side
        //     }
        //
        object marketId = this.safeString(position, "s");
        object contracts = this.safeString(position, "pa");
        object contractsAbs = Precise.stringAbs(this.safeString(position, "pa"));
        object positionSide = this.safeStringLower(position, "ps");
        object hedged = true;
        if (isTrue(isEqual(positionSide, "both")))
        {
            hedged = false;
            if (!isTrue(Precise.stringEq(contracts, "0")))
            {
                if (isTrue(Precise.stringLt(contracts, "0")))
                {
                    positionSide = "short";
                } else
                {
                    positionSide = "long";
                }
            }
        }
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", this.safeSymbol(marketId, null, null, "contract") },
            { "notional", null },
            { "marginMode", this.safeString(position, "mt") },
            { "liquidationPrice", null },
            { "entryPrice", this.safeNumber(position, "ep") },
            { "unrealizedPnl", this.safeNumber(position, "up") },
            { "percentage", null },
            { "contracts", this.parseNumber(contractsAbs) },
            { "contractSize", null },
            { "markPrice", null },
            { "side", positionSide },
            { "hedged", hedged },
            { "timestamp", null },
            { "datetime", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "collateral", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "leverage", null },
            { "marginRatio", null },
        });
    }

    /**
     * @method
     * @name binance#fetchMyTradesWs
     * @description fetch all trades made by the user
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/account-requests#account-trade-history-user_data
     * @param {string} symbol unified market symbol
     * @param {int|undefined} [since] the earliest time in ms to fetch trades for
     * @param {int|undefined} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.endTime] the latest time in ms to fetch trades for
     * @param {int} [params.fromId] first trade Id to fetch
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTradesWs(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new BadRequest ((string)add(this.id, " fetchMyTradesWs requires a symbol")) ;
        }
        object market = this.market(symbol);
        object type = this.getMarketType("fetchMyTradesWs", market, parameters);
        if (isTrue(isTrue(!isEqual(type, "spot")) && isTrue(!isEqual(type, "future"))))
        {
            throw new BadRequest ((string)add(add(add(this.id, " fetchMyTradesWs does not support "), type), " markets")) ;
        }
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "ws-api"), type);
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTradesWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        object payload = new Dictionary<string, object>() {
            { "symbol", this.marketId(symbol) },
            { "returnRateLimits", returnRateLimits },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)payload)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)payload)["limit"] = limit;
        }
        object fromId = this.safeInteger(parameters, "fromId");
        if (isTrue(isTrue(!isEqual(fromId, null)) && isTrue(!isEqual(since, null))))
        {
            throw new BadRequest ((string)add(this.id, " fetchMyTradesWs does not support fetching by both fromId and since parameters at the same time")) ;
        }
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "myTrades" },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleTradesWs },
        };
        object trades = await this.watch(url, messageHash, message, messageHash, subscription);
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit);
    }

    /**
     * @method
     * @name binance#fetchTradesWs
     * @description fetch all trades made by the user
     * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#recent-trades
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve, default=500, max=1000
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     *
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {int} [params.fromId] trade ID to begin at
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchTradesWs(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object type = this.getMarketType("fetchTradesWs", market, parameters);
        if (isTrue(isTrue(!isEqual(type, "spot")) && isTrue(!isEqual(type, "future"))))
        {
            throw new BadRequest ((string)add(add(add(this.id, " fetchTradesWs does not support "), type), " markets")) ;
        }
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "ws-api"), type);
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "fetchTradesWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        object payload = new Dictionary<string, object>() {
            { "symbol", this.marketId(symbol) },
            { "returnRateLimits", returnRateLimits },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)payload)["limit"] = limit;
        }
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "trades.historical" },
            { "params", this.extend(payload, parameters) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleTradesWs },
        };
        object trades = await this.watch(url, messageHash, message, messageHash, subscription);
        return this.filterBySinceLimit(trades, since, limit);
    }

    public virtual void handleTradesWs(WebSocketClient client, object message)
    {
        //
        // fetchMyTradesWs
        //
        //    {
        //        "id": "f4ce6a53-a29d-4f70-823b-4ab59391d6e8",
        //        "status": 200,
        //        "result": [
        //            {
        //                "symbol": "BTCUSDT",
        //                "id": 1650422481,
        //                "orderId": 12569099453,
        //                "orderListId": -1,
        //                "price": "23416.10000000",
        //                "qty": "0.00635000",
        //                "quoteQty": "148.69223500",
        //                "commission": "0.00000000",
        //                "commissionAsset": "BNB",
        //                "time": 1660801715793,
        //                "isBuyer": false,
        //                "isMaker": true,
        //                "isBestMatch": true
        //            },
        //            ...
        //        ],
        //    }
        //
        // fetchTradesWs
        //
        //    {
        //        "id": "f4ce6a53-a29d-4f70-823b-4ab59391d6e8",
        //        "status": 200,
        //        "result": [
        //            {
        //                "id": 0,
        //                "price": "0.00005000",
        //                "qty": "40.00000000",
        //                "quoteQty": "0.00200000",
        //                "time": 1500004800376,
        //                "isBuyerMaker": true,
        //                "isBestMatch": true
        //            }
        //            ...
        //        ],
        //    }
        //
        object messageHash = this.safeString(message, "id");
        object result = this.safeList(message, "result", new List<object>() {});
        object trades = this.parseTrades(result);
        callDynamically(client as WebSocketClient, "resolve", new object[] {trades, messageHash});
    }

    /**
     * @method
     * @name binance#watchMyTrades
     * @description watches information on multiple trades made by the user
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.portfolioMargin] set to true if you would like to watch trades in a portfolio margin account
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        var typeparametersVariable = this.handleMarketTypeAndParams("watchMyTrades", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchMyTrades", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(this.isLinear(type, subType)))
        {
            type = "future";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            type = "delivery";
        }
        object messageHash = "myTrades";
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
            messageHash = add(messageHash, add(":", symbol));
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "type", getValue(market, "type") },
                { "symbol", symbol },
            });
        }
        await this.authenticate(parameters);
        object urlType = type; // we don't change type because the listening key is different
        if (isTrue(isEqual(type, "margin")))
        {
            urlType = "spot"; // spot-margin shares the same stream as regular spot
        }
        object isPortfolioMargin = null;
        var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "watchMyTrades", "papi", "portfolioMargin", false);
        isPortfolioMargin = ((IList<object>)isPortfolioMarginparametersVariable)[0];
        parameters = ((IList<object>)isPortfolioMarginparametersVariable)[1];
        object url = "";
        if (isTrue(isEqual(type, "spot")))
        {
            url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "ws-api"), type);
        } else
        {
            if (isTrue(isPortfolioMargin))
            {
                urlType = "papi";
            }
            url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), urlType), "/"), getValue(getValue(this.options, type), "listenKey"));
        }
        var client = this.client(url);
        this.setBalanceCache(client as WebSocketClient, type, isPortfolioMargin);
        this.setPositionsCache(client as WebSocketClient, type, null, isPortfolioMargin);
        object message = null;
        object trades = await this.watch(url, messageHash, message, type);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleMyTrade(WebSocketClient client, object message)
    {
        object messageHash = "myTrades";
        object executionType = this.safeString(message, "x");
        if (isTrue(isEqual(executionType, "TRADE")))
        {
            object trade = this.parseWsTrade(message);
            object orderId = this.safeString(trade, "order");
            object tradeFee = this.safeDict(trade, "fee", new Dictionary<string, object>() {});
            tradeFee = this.extend(new Dictionary<string, object>() {}, tradeFee);
            object symbol = this.safeString(trade, "symbol");
            if (isTrue(isTrue(isTrue(!isEqual(orderId, null)) && isTrue(!isEqual(tradeFee, null))) && isTrue(!isEqual(symbol, null))))
            {
                object cachedOrders = this.orders;
                if (isTrue(!isEqual(cachedOrders, null)))
                {
                    object orders = this.safeValue((cachedOrders as ArrayCacheBySymbolById).hashmap, symbol, new Dictionary<string, object>() {});
                    object order = this.safeValue(orders, orderId);
                    if (isTrue(!isEqual(order, null)))
                    {
                        // accumulate order fees
                        object fees = this.safeValue(order, "fees");
                        object fee = this.safeValue(order, "fee");
                        if (!isTrue(this.isEmpty(fees)))
                        {
                            object insertNewFeeCurrency = true;
                            for (object i = 0; isLessThan(i, getArrayLength(fees)); postFixIncrement(ref i))
                            {
                                object orderFee = getValue(fees, i);
                                if (isTrue(isEqual(getValue(orderFee, "currency"), getValue(tradeFee, "currency"))))
                                {
                                    object feeCost = this.sum(getValue(tradeFee, "cost"), getValue(orderFee, "cost"));
                                    ((IDictionary<string,object>)getValue(getValue(order, "fees"), i))["cost"] = parseFloat(this.currencyToPrecision(getValue(tradeFee, "currency"), feeCost));
                                    insertNewFeeCurrency = false;
                                    break;
                                }
                            }
                            if (isTrue(insertNewFeeCurrency))
                            {
                                ((IList<object>)getValue(order, "fees")).Add(tradeFee);
                            }
                        } else if (isTrue(!isEqual(fee, null)))
                        {
                            if (isTrue(isEqual(getValue(fee, "currency"), getValue(tradeFee, "currency"))))
                            {
                                object feeCost = this.sum(getValue(fee, "cost"), getValue(tradeFee, "cost"));
                                ((IDictionary<string,object>)getValue(order, "fee"))["cost"] = parseFloat(this.currencyToPrecision(getValue(tradeFee, "currency"), feeCost));
                            } else if (isTrue(isEqual(getValue(fee, "currency"), null)))
                            {
                                ((IDictionary<string,object>)order)["fee"] = tradeFee;
                            } else
                            {
                                ((IDictionary<string,object>)order)["fees"] = new List<object>() {fee, tradeFee};
                                ((IDictionary<string,object>)order)["fee"] = null;
                            }
                        } else
                        {
                            ((IDictionary<string,object>)order)["fee"] = tradeFee;
                        }
                        // save this trade in the order
                        object orderTrades = this.safeList(order, "trades", new List<object>() {});
                        ((IList<object>)orderTrades).Add(trade);
                        ((IDictionary<string,object>)order)["trades"] = orderTrades;
                    }
                }
            }
            if (isTrue(isEqual(this.myTrades, null)))
            {
                object limit = this.safeInteger(this.options, "tradesLimit", 1000);
                this.myTrades = new ArrayCacheBySymbolById(limit);
            }
            object myTrades = this.myTrades;
            callDynamically(myTrades, "append", new object[] {trade});
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.myTrades, messageHash});
            object messageHashSymbol = add(add(messageHash, ":"), symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.myTrades, messageHashSymbol});
        }
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        object parsed = this.parseWsOrder(message);
        object symbol = this.safeString(parsed, "symbol");
        object orderId = this.safeString(parsed, "id");
        if (isTrue(!isEqual(symbol, null)))
        {
            if (isTrue(isEqual(this.orders, null)))
            {
                object limit = this.safeInteger(this.options, "ordersLimit", 1000);
                this.orders = new ArrayCacheBySymbolById(limit);
            }
            object cachedOrders = this.orders;
            object orders = this.safeValue((cachedOrders as ArrayCacheBySymbolById).hashmap, symbol, new Dictionary<string, object>() {});
            object order = this.safeValue(orders, orderId);
            if (isTrue(!isEqual(order, null)))
            {
                object fee = this.safeValue(order, "fee");
                if (isTrue(!isEqual(fee, null)))
                {
                    ((IDictionary<string,object>)parsed)["fee"] = fee;
                }
                object fees = this.safeValue(order, "fees");
                if (isTrue(!isEqual(fees, null)))
                {
                    ((IDictionary<string,object>)parsed)["fees"] = fees;
                }
                ((IDictionary<string,object>)parsed)["trades"] = this.safeValue(order, "trades");
                object timestamp = this.safeInteger(parsed, "timestamp");
                if (isTrue(isEqual(timestamp, null)))
                {
                    ((IDictionary<string,object>)parsed)["timestamp"] = this.safeInteger(order, "timestamp");
                    ((IDictionary<string,object>)parsed)["datetime"] = this.safeString(order, "datetime");
                }
            }
            callDynamically(cachedOrders, "append", new object[] {parsed});
            object messageHash = "orders";
            object symbolSpecificMessageHash = add("orders:", symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {cachedOrders, messageHash});
            callDynamically(client as WebSocketClient, "resolve", new object[] {cachedOrders, symbolSpecificMessageHash});
        }
    }

    public virtual void handleAcountUpdate(WebSocketClient client, object message)
    {
        this.handleBalance(client as WebSocketClient, message);
        this.handlePositions(client as WebSocketClient, message);
    }

    public virtual void handleWsError(WebSocketClient client, object message)
    {
        //
        //    {
        //        "error": {
        //            "code": 2,
        //            "msg": "Invalid request: invalid stream"
        //        },
        //        "id": 1
        //    }
        //
        object id = this.safeString(message, "id");
        object rejected = false;
        object error = this.safeDict(message, "error", new Dictionary<string, object>() {});
        object code = this.safeInteger(error, "code");
        object msg = this.safeString(error, "msg");
        try
        {
            this.handleErrors(code, msg, client.url, "", new Dictionary<string, object>() {}, this.json(error), error, new Dictionary<string, object>() {}, new Dictionary<string, object>() {});
        } catch(Exception e)
        {
            rejected = true;
            // private endpoint uses id as messageHash
            ((WebSocketClient)client).reject(e, id);
            // public endpoint stores messageHash in subscriptions
            object subscriptionKeys = new List<object>(((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(subscriptionKeys)); postFixIncrement(ref i))
            {
                object subscriptionHash = getValue(subscriptionKeys, i);
                object subscriptionId = this.safeString(getValue(((WebSocketClient)client).subscriptions, subscriptionHash), "id");
                object subscription = this.safeString(getValue(((WebSocketClient)client).subscriptions, subscriptionHash), "subscription");
                if (isTrue(isEqual(id, subscriptionId)))
                {
                    ((WebSocketClient)client).reject(e, subscriptionHash);
                    if (isTrue(!isEqual(subscription, null)))
                    {
                        ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)subscription);
                    }
                }
            }
        }
        if (!isTrue(rejected))
        {
            ((WebSocketClient)client).reject(message, id);
        }
        // reset connection if 5xx error
        object codeString = this.safeString(error, "code");
        if (isTrue(isTrue((!isEqual(codeString, null))) && isTrue((isEqual(getValue(codeString, 0), "5")))))
        {
            ((WebSocketClient)client).reset(message);
        }
    }

    public virtual void handleEventStreamTerminated(WebSocketClient client, object message)
    {
        //
        //    {
        //        e: 'eventStreamTerminated',
        //        E: 1757896885229
        //    }
        //
        object eventVar = this.safeString(message, "e");
        object subscriptions = ((WebSocketClient)client).subscriptions;
        object subscriptionsKeys = new List<object>(((IDictionary<string,object>)subscriptions).Keys);
        object accountType = this.getAccountTypeFromSubscriptions(subscriptionsKeys);
        if (isTrue(isEqual(eventVar, "eventStreamTerminated")))
        {
            ((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Remove((string)accountType);
            ((WebSocketClient)client).reject(message, accountType);
        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        // handle WebSocketAPI
        object eventMsg = this.safeDict(message, "event");
        if (isTrue(!isEqual(eventMsg, null)))
        {
            message = eventMsg;
        }
        object status = this.safeString(message, "status");
        object error = this.safeValue(message, "error");
        if (isTrue(isTrue((!isEqual(error, null))) || isTrue((isTrue(!isEqual(status, null)) && isTrue(!isEqual(status, "200"))))))
        {
            this.handleWsError(client as WebSocketClient, message);
            return;
        }
        // user subscription wraps message in subscriptionId and event
        object id = this.safeString(message, "id");
        object subscriptions = this.safeValue(((WebSocketClient)client).subscriptions, id);
        object method = this.safeValue(subscriptions, "method");
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
            return;
        }
        // handle other APIs
        object methods = new Dictionary<string, object>() {
            { "depthUpdate", this.handleOrderBook },
            { "trade", this.handleTrade },
            { "aggTrade", this.handleTrade },
            { "kline", this.handleOHLCV },
            { "markPrice_kline", this.handleOHLCV },
            { "indexPrice_kline", this.handleOHLCV },
            { "1hTicker@arr", this.handleTickers },
            { "4hTicker@arr", this.handleTickers },
            { "1dTicker@arr", this.handleTickers },
            { "24hrTicker@arr", this.handleTickers },
            { "24hrMiniTicker@arr", this.handleTickers },
            { "1hTicker", this.handleTickers },
            { "4hTicker", this.handleTickers },
            { "1dTicker", this.handleTickers },
            { "24hrTicker", this.handleTickers },
            { "24hrMiniTicker", this.handleTickers },
            { "markPriceUpdate", this.handleTickers },
            { "markPriceUpdate@arr", this.handleTickers },
            { "bookTicker", this.handleBidsAsks },
            { "outboundAccountPosition", this.handleBalance },
            { "balanceUpdate", this.handleBalance },
            { "ACCOUNT_UPDATE", this.handleAcountUpdate },
            { "executionReport", this.handleOrderUpdate },
            { "ORDER_TRADE_UPDATE", this.handleOrderUpdate },
            { "forceOrder", this.handleLiquidation },
            { "eventStreamTerminated", this.handleEventStreamTerminated },
            { "externalLockUpdate", this.handleBalance },
        };
        object eventVar = this.safeString(message, "e");
        if (isTrue(((message is IList<object>) || (message.GetType().IsGenericType && message.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            object data = getValue(message, 0);
            eventVar = add(this.safeString(data, "e"), "@arr");
        }
        method = this.safeValue(methods, eventVar);
        if (isTrue(isEqual(method, null)))
        {
            object requestId = this.safeString(message, "id");
            if (isTrue(!isEqual(requestId, null)))
            {
                this.handleSubscriptionStatus(client as WebSocketClient, message);
                return;
            }
            // special case for the real-time bookTicker, since it comes without an event identifier
            //
            //     {
            //         "u": 7488717758,
            //         "s": "BTCUSDT",
            //         "b": "28621.74000000",
            //         "B": "1.43278800",
            //         "a": "28621.75000000",
            //         "A": "2.52500800"
            //     }
            //
            if (isTrue(isTrue(isTrue(isEqual(eventVar, null)) && isTrue((inOp(message, "a")))) && isTrue((inOp(message, "b")))))
            {
                this.handleBidsAsks(client as WebSocketClient, message);
            }
        } else
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
    }
}
