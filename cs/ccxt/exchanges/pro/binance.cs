namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class binance { public binance(object args = null) : base(args) { } }
public partial class binance : ccxt.binance
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchBalance", true },
                { "watchMyTrades", true },
                { "watchOHLCV", true },
                { "watchOHLCVForSymbols", false },
                { "watchOrderBook", true },
                { "watchOrderBookForSymbols", true },
                { "watchOrders", true },
                { "watchOrdersForSymbols", true },
                { "watchPositions", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
                { "createOrderWs", true },
                { "editOrderWs", true },
                { "cancelOrderWs", true },
                { "cancelOrdersWs", false },
                { "cancelAllOrdersWs", true },
                { "fetchBalanceWs", true },
                { "fetchDepositsWs", false },
                { "fetchMarketsWs", false },
                { "fetchMyTradesWs", true },
                { "fetchOHLCVWs", true },
                { "fetchOpenOrdersWs", true },
                { "fetchOrderWs", true },
                { "fetchOrdersWs", true },
                { "fetchTradesWs", true },
                { "fetchTradingFeesWs", false },
                { "fetchWithdrawalsWs", false },
            } },
            { "urls", new Dictionary<string, object>() {
                { "test", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "spot", "wss://testnet.binance.vision/ws" },
                        { "margin", "wss://testnet.binance.vision/ws" },
                        { "future", "wss://fstream.binancefuture.com/ws" },
                        { "delivery", "wss://dstream.binancefuture.com/ws" },
                        { "ws", "wss://testnet.binance.vision/ws-api/v3" },
                    } },
                } },
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "spot", "wss://stream.binance.com:9443/ws" },
                        { "margin", "wss://stream.binance.com:9443/ws" },
                        { "future", "wss://fstream.binance.com/ws" },
                        { "delivery", "wss://dstream.binance.com/ws" },
                        { "ws", "wss://ws-api.binance.com:443/ws-api/v3" },
                        { "papi", "wss://fstream.binance.com/pm/ws" },
                    } },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "keepAlive", 180000 },
            } },
            { "options", new Dictionary<string, object>() {
                { "returnRateLimits", false },
                { "streamLimits", new Dictionary<string, object>() {
                    { "spot", 50 },
                    { "margin", 50 },
                    { "future", 50 },
                    { "delivery", 50 },
                } },
                { "subscriptionLimitByStream", new Dictionary<string, object>() {
                    { "spot", 200 },
                    { "margin", 200 },
                    { "future", 200 },
                    { "delivery", 200 },
                } },
                { "streamBySubscriptionsHash", new Dictionary<string, object>() {} },
                { "streamIndex", -1 },
                { "watchOrderBookRate", 100 },
                { "tradesLimit", 1000 },
                { "ordersLimit", 1000 },
                { "OHLCVLimit", 1000 },
                { "requestId", new Dictionary<string, object>() {} },
                { "watchOrderBookLimit", 1000 },
                { "watchTrades", new Dictionary<string, object>() {
                    { "name", "trade" },
                } },
                { "watchTicker", new Dictionary<string, object>() {
                    { "name", "ticker" },
                } },
                { "watchTickers", new Dictionary<string, object>() {
                    { "name", "ticker" },
                } },
                { "watchOHLCV", new Dictionary<string, object>() {
                    { "name", "kline" },
                } },
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "maxRetries", 3 },
                } },
                { "watchBalance", new Dictionary<string, object>() {
                    { "fetchBalanceSnapshot", false },
                    { "awaitBalanceSnapshot", true },
                } },
                { "watchPositions", new Dictionary<string, object>() {
                    { "fetchPositionsSnapshot", true },
                    { "awaitPositionsSnapshot", true },
                } },
                { "wallet", "wb" },
                { "listenKeyRefreshRate", 1200000 },
                { "ws", new Dictionary<string, object>() {
                    { "cost", 5 },
                } },
            } },
        });
    }

    public virtual object requestId(object url)
    {
        object options = this.safeValue(this.options, "requestId", new Dictionary<string, object>() {});
        object previousValue = this.safeInteger(options, url, 0);
        object newValue = this.sum(previousValue, 1);
        ((IDictionary<string,object>)getValue(this.options, "requestId"))[(string)url] = newValue;
        return newValue;
    }

    public virtual object stream(object type, object subscriptionHash, object numSubscriptions = null)
    {
        numSubscriptions ??= 1;
        object streamBySubscriptionsHash = this.safeValue(this.options, "streamBySubscriptionsHash", new Dictionary<string, object>() {});
        object stream = this.safeString(streamBySubscriptionsHash, subscriptionHash);
        if (isTrue(isEqual(stream, null)))
        {
            object streamIndex = this.safeInteger(this.options, "streamIndex", -1);
            object streamLimits = this.safeValue(this.options, "streamLimits");
            object streamLimit = this.safeInteger(streamLimits, type);
            streamIndex = add(streamIndex, 1);
            object normalizedIndex = mod(streamIndex, streamLimit);
            ((IDictionary<string,object>)this.options)["streamIndex"] = streamIndex;
            stream = this.numberToString(normalizedIndex);
            ((IDictionary<string,object>)getValue(this.options, "streamBySubscriptionsHash"))[(string)subscriptionHash] = stream;
            object subscriptionsByStreams = this.safeValue(this.options, "numSubscriptionsByStream");
            if (isTrue(isEqual(subscriptionsByStreams, null)))
            {
                ((IDictionary<string,object>)this.options)["numSubscriptionsByStream"] = new Dictionary<string, object>() {};
            }
            object subscriptionsByStream = this.safeInteger(getValue(this.options, "numSubscriptionsByStream"), stream, 0);
            object newNumSubscriptions = add(subscriptionsByStream, numSubscriptions);
            object subscriptionLimitByStream = this.safeInteger(getValue(this.options, "subscriptionLimitByStream"), type, 200);
            if (isTrue(isGreaterThan(newNumSubscriptions, subscriptionLimitByStream)))
            {
                throw new BadRequest ((string)add(this.id, " reached the limit of subscriptions by stream. Increase the number of streams, or increase the stream limit or subscription limit by stream if the exchange allows.")) ;
            }
            ((IDictionary<string,object>)getValue(this.options, "numSubscriptionsByStream"))[(string)stream] = add(subscriptionsByStream, numSubscriptions);
        }
        return stream;
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#watchOrderBook
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        //
        // todo add support for <levels>-snapshots (depth)
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/web-socket-streams.md#partial-book-depth-streams        // <symbol>@depth<levels>@100ms or <symbol>@depth<levels> (1000ms)
        // valid <levels> are 5, 10, or 20
        //
        // default 100, max 1000, valid limits 5, 10, 20, 50, 100, 500, 1000
        //
        // notice the differences between trading futures and spot trading
        // the algorithms use different urls in step 1
        // delta caching and merging also differs in steps 4, 5, 6
        //
        // spot/margin
        // https://binance-docs.github.io/apidocs/spot/en/#how-to-manage-a-local-order-book-correctly
        //
        // 1. Open a stream to wss://stream.binance.com:9443/ws/bnbbtc@depth.
        // 2. Buffer the events you receive from the stream.
        // 3. Get a depth snapshot from https://www.binance.com/api/v1/depth?symbol=BNBBTC&limit=1000 .
        // 4. Drop any event where u is <= lastUpdateId in the snapshot.
        // 5. The first processed event should have U <= lastUpdateId+1 AND u >= lastUpdateId+1.
        // 6. While listening to the stream, each new event's U should be equal to the previous event's u+1.
        // 7. The data in each event is the absolute quantity for a price level.
        // 8. If the quantity is 0, remove the price level.
        // 9. Receiving an event that removes a price level that is not in your local order book can happen and is normal.
        //
        // futures
        // https://binance-docs.github.io/apidocs/futures/en/#how-to-manage-a-local-order-book-correctly
        //
        // 1. Open a stream to wss://fstream.binance.com/stream?streams=btcusdt@depth.
        // 2. Buffer the events you receive from the stream. For same price, latest received update covers the previous one.
        // 3. Get a depth snapshot from https://fapi.binance.com/fapi/v1/depth?symbol=BTCUSDT&limit=1000 .
        // 4. Drop any event where u is < lastUpdateId in the snapshot.
        // 5. The first processed event should have U <= lastUpdateId AND u >= lastUpdateId
        // 6. While listening to the stream, each new event's pu should be equal to the previous event's u, otherwise initialize the process from step 3.
        // 7. The data in each event is the absolute quantity for a price level.
        // 8. If the quantity is 0, remove the price level.
        // 9. Receiving an event that removes a price level that is not in your local order book can happen and is normal.
        //
        parameters ??= new Dictionary<string, object>();
        return await this.watchOrderBookForSymbols(new List<object>() {symbol}, limit, parameters);
    }

    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#watchOrderBookForSymbols
        * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string[]} symbols unified array of symbols
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false, true, true);
        object firstMarket = this.market(getValue(symbols, 0));
        object type = getValue(firstMarket, "type");
        if (isTrue(getValue(firstMarket, "contract")))
        {
            type = ((bool) isTrue(getValue(firstMarket, "linear"))) ? "future" : "delivery";
        }
        object name = "depth";
        object streamHash = "multipleOrderbook";
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(isGreaterThan(symbolsLength, 200)))
            {
                throw new BadRequest ((string)add(this.id, " watchOrderBookForSymbols() accepts 200 symbols at most. To watch more symbols call watchOrderBookForSymbols() multiple times")) ;
            }
            streamHash = add(streamHash, add("::", String.Join(",", ((IList<object>)symbols).ToArray())));
        }
        object watchOrderBookRate = this.safeString(this.options, "watchOrderBookRate", "100");
        object subParams = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = this.market(symbol);
            object messageHash = add(add(getValue(market, "lowercaseId"), "@"), name);
            ((IList<object>)messageHashes).Add(messageHash);
            object symbolHash = add(add(add(messageHash, "@"), watchOrderBookRate), "ms");
            ((IList<object>)subParams).Add(symbolHash);
        }
        object messageHashesLength = getArrayLength(messageHashes);
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "/"), this.stream(type, streamHash, messageHashesLength));
        object requestId = this.requestId(url);
        object request = new Dictionary<string, object>() {
            { "method", "SUBSCRIBE" },
            { "params", subParams },
            { "id", requestId },
        };
        object subscription = new Dictionary<string, object>() {
            { "id", ((object)requestId).ToString() },
            { "name", name },
            { "symbols", symbols },
            { "method", this.handleOrderBookSubscription },
            { "limit", limit },
            { "type", type },
            { "params", parameters },
        };
        object message = this.extend(request, parameters);
        object orderbook = await this.watchMultiple(url, messageHashes, message, messageHashes, subscription);
        return (orderbook as IOrderBook).limit();
    }

    public async virtual Task fetchOrderBookSnapshot(WebSocketClient client, object message, object subscription)
    {
        object name = this.safeString(subscription, "name");
        object symbol = this.safeString(subscription, "symbol");
        object market = this.market(symbol);
        object messageHash = add(add(getValue(market, "lowercaseId"), "@"), name);
        try
        {
            object defaultLimit = this.safeInteger(this.options, "watchOrderBookLimit", 1000);
            object type = this.safeValue(subscription, "type");
            object limit = this.safeInteger(subscription, "limit", defaultLimit);
            object parameters = this.safeValue(subscription, "params");
            // 3. Get a depth snapshot from https://www.binance.com/api/v1/depth?symbol=BNBBTC&limit=1000 .
            // todo: this is a synch blocking call - make it async
            // default 100, max 1000, valid limits 5, 10, 20, 50, 100, 500, 1000
            object snapshot = await this.fetchRestOrderBookSafe(symbol, limit, parameters);
            object orderbook = this.safeValue(this.orderbooks, symbol);
            if (isTrue(isEqual(orderbook, null)))
            {
                // if the orderbook is dropped before the snapshot is received
                return;
            }
            (orderbook as IOrderBook).reset(snapshot);
            // unroll the accumulated deltas
            object messages = (orderbook as ccxt.pro.OrderBook).cache;
            for (object i = 0; isLessThan(i, getArrayLength(messages)); postFixIncrement(ref i))
            {
                object messageItem = getValue(messages, i);
                object U = this.safeInteger(messageItem, "U");
                object u = this.safeInteger(messageItem, "u");
                object pu = this.safeInteger(messageItem, "pu");
                if (isTrue(isEqual(type, "future")))
                {
                    // 4. Drop any event where u is < lastUpdateId in the snapshot
                    if (isTrue(isLessThan(u, getValue(orderbook, "nonce"))))
                    {
                        continue;
                    }
                    // 5. The first processed event should have U <= lastUpdateId AND u >= lastUpdateId
                    if (isTrue(isTrue(isTrue((isLessThanOrEqual(U, getValue(orderbook, "nonce")))) && isTrue((isGreaterThanOrEqual(u, getValue(orderbook, "nonce"))))) || isTrue((isEqual(pu, getValue(orderbook, "nonce"))))))
                    {
                        this.handleOrderBookMessage(client as WebSocketClient, messageItem, orderbook);
                    }
                } else
                {
                    // 4. Drop any event where u is <= lastUpdateId in the snapshot
                    if (isTrue(isLessThanOrEqual(u, getValue(orderbook, "nonce"))))
                    {
                        continue;
                    }
                    // 5. The first processed event should have U <= lastUpdateId+1 AND u >= lastUpdateId+1
                    if (isTrue(isTrue((isLessThanOrEqual((subtract(U, 1)), getValue(orderbook, "nonce")))) && isTrue((isGreaterThanOrEqual((subtract(u, 1)), getValue(orderbook, "nonce"))))))
                    {
                        this.handleOrderBookMessage(client as WebSocketClient, messageItem, orderbook);
                    }
                }
            }
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
            callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
        } catch(Exception e)
        {

            ((WebSocketClient)client).reject(e, messageHash);
        }
    }

    public override void handleDelta(object bookside, object delta)
    {
        object price = this.safeFloat(delta, 0);
        object amount = this.safeFloat(delta, 1);
        (bookside as IOrderBookSide).store(price, amount);
    }

    public override void handleDeltas(object bookside, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(bookside, getValue(deltas, i));
        }
    }

    public virtual object handleOrderBookMessage(WebSocketClient client, object message, object orderbook)
    {
        object u = this.safeInteger(message, "u");
        this.handleDeltas(getValue(orderbook, "asks"), this.safeValue(message, "a", new List<object>() {}));
        this.handleDeltas(getValue(orderbook, "bids"), this.safeValue(message, "b", new List<object>() {}));
        ((IDictionary<string,object>)orderbook)["nonce"] = u;
        object timestamp = this.safeInteger(message, "E");
        ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
        ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        return orderbook;
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        // initial snapshot is fetched with ccxt's fetchOrderBook
        // the feed does not include a snapshot, just the deltas
        //
        //     {
        //         "e": "depthUpdate", // Event type
        //         "E": 1577554482280, // Event time
        //         "s": "BNBBTC", // Symbol
        //         "U": 157, // First update ID in event
        //         "u": 160, // Final update ID in event
        //         "b": [ // bids
        //             [ "0.0024", "10" ], // price, size
        //         ],
        //         "a": [ // asks
        //             [ "0.0026", "100" ], // price, size
        //         ]
        //     }
        //
        object isTestnetSpot = isGreaterThan(getIndexOf(client.url, "testnet"), 0);
        object isSpotMainNet = isGreaterThan(getIndexOf(client.url, "/stream.binance."), 0);
        object isSpot = isTrue(isTestnetSpot) || isTrue(isSpotMainNet);
        object marketType = ((bool) isTrue(isSpot)) ? "spot" : "contract";
        object marketId = this.safeString(message, "s");
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        object name = "depth";
        object messageHash = add(add(getValue(market, "lowercaseId"), "@"), name);
        object orderbook = this.safeValue(this.orderbooks, symbol);
        if (isTrue(isEqual(orderbook, null)))
        {
            //
            // https://github.com/ccxt/ccxt/issues/6672
            //
            // Sometimes Binance sends the first delta before the subscription
            // confirmation arrives. At that point the orderbook is not
            // initialized yet and the snapshot has not been requested yet
            // therefore it is safe to drop these premature messages.
            //
            return;
        }
        object nonce = this.safeInteger(orderbook, "nonce");
        if (isTrue(isEqual(nonce, null)))
        {
            // 2. Buffer the events you receive from the stream.
            ((IList<object>)(orderbook as ccxt.pro.OrderBook).cache).Add(message);
        } else
        {
            try
            {
                object U = this.safeInteger(message, "U");
                object u = this.safeInteger(message, "u");
                object pu = this.safeInteger(message, "pu");
                if (isTrue(isEqual(pu, null)))
                {
                    // spot
                    // 4. Drop any event where u is <= lastUpdateId in the snapshot
                    if (isTrue(isGreaterThan(u, getValue(orderbook, "nonce"))))
                    {
                        object timestamp = this.safeInteger(orderbook, "timestamp");
                        object conditional = null;
                        if (isTrue(isEqual(timestamp, null)))
                        {
                            // 5. The first processed event should have U <= lastUpdateId+1 AND u >= lastUpdateId+1
                            conditional = isTrue((isLessThanOrEqual((subtract(U, 1)), getValue(orderbook, "nonce")))) && isTrue((isGreaterThanOrEqual((subtract(u, 1)), getValue(orderbook, "nonce"))));
                        } else
                        {
                            // 6. While listening to the stream, each new event's U should be equal to the previous event's u+1.
                            conditional = (isEqual((subtract(U, 1)), getValue(orderbook, "nonce")));
                        }
                        if (isTrue(conditional))
                        {
                            this.handleOrderBookMessage(client as WebSocketClient, message, orderbook);
                            if (isTrue(isLessThan(nonce, getValue(orderbook, "nonce"))))
                            {
                                callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
                            }
                        } else
                        {
                            throw new ExchangeError ((string)add(this.id, " handleOrderBook received an out-of-order nonce")) ;
                        }
                    }
                } else
                {
                    // future
                    // 4. Drop any event where u is < lastUpdateId in the snapshot
                    if (isTrue(isGreaterThanOrEqual(u, getValue(orderbook, "nonce"))))
                    {
                        // 5. The first processed event should have U <= lastUpdateId AND u >= lastUpdateId
                        // 6. While listening to the stream, each new event's pu should be equal to the previous event's u, otherwise initialize the process from step 3
                        if (isTrue(isTrue((isLessThanOrEqual(U, getValue(orderbook, "nonce")))) || isTrue((isEqual(pu, getValue(orderbook, "nonce"))))))
                        {
                            this.handleOrderBookMessage(client as WebSocketClient, message, orderbook);
                            if (isTrue(isLessThanOrEqual(nonce, getValue(orderbook, "nonce"))))
                            {
                                callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
                            }
                        } else
                        {
                            throw new ExchangeError ((string)add(this.id, " handleOrderBook received an out-of-order nonce")) ;
                        }
                    }
                }
            } catch(Exception e)
            {


                ((WebSocketClient)client).reject(e, messageHash);
            }
        }
    }

    public virtual void handleOrderBookSubscription(WebSocketClient client, object message, object subscription)
    {
        object defaultLimit = this.safeInteger(this.options, "watchOrderBookLimit", 1000);
        // const messageHash = this.safeString (subscription, 'messageHash');
        object symbolOfSubscription = this.safeString(subscription, "symbol"); // watchOrderBook
        object symbols = this.safeValue(subscription, "symbols", new List<object>() {symbolOfSubscription}); // watchOrderBookForSymbols
        object limit = this.safeInteger(subscription, "limit", defaultLimit);
        // handle list of symbols
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            if (isTrue(inOp(this.orderbooks, symbol)))
            {

            }
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = this.orderBook(new Dictionary<string, object>() {}, limit);
            subscription = this.extend(subscription, new Dictionary<string, object>() {
                { "symbol", symbol },
            });
            // fetch the snapshot in a separate async call
            this.spawn(this.fetchOrderBookSnapshot, new object[] { client, message, subscription});
        }
    }

    public virtual object handleSubscriptionStatus(WebSocketClient client, object message)
    {
        //
        //     {
        //         "result": null,
        //         "id": 1574649734450
        //     }
        //
        object id = this.safeString(message, "id");
        object subscriptionsById = this.indexBy(((WebSocketClient)client).subscriptions, "id");
        object subscription = this.safeValue(subscriptionsById, id, new Dictionary<string, object>() {});
        object method = this.safeValue(subscription, "method");
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message, subscription});
        }
        return message;
    }

    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#watchTradesForSymbols
        * @description get the list of most recent trades for a list of symbols
        * @param {string[]} symbols unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, false, true, true);
        object streamHash = "multipleTrades";
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(isGreaterThan(symbolsLength, 200)))
            {
                throw new BadRequest ((string)add(this.id, " watchTradesForSymbols() accepts 200 symbols at most. To watch more symbols call watchTradesForSymbols() multiple times")) ;
            }
            streamHash = add(streamHash, add("::", String.Join(",", ((IList<object>)symbols).ToArray())));
        }
        object options = this.safeValue(this.options, "watchTradesForSymbols", new Dictionary<string, object>() {});
        object name = this.safeString(options, "name", "trade");
        object firstMarket = this.market(getValue(symbols, 0));
        object type = getValue(firstMarket, "type");
        if (isTrue(getValue(firstMarket, "contract")))
        {
            type = ((bool) isTrue(getValue(firstMarket, "linear"))) ? "future" : "delivery";
        }
        object subParams = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = this.market(symbol);
            object currentMessageHash = add(add(getValue(market, "lowercaseId"), "@"), name);
            ((IList<object>)subParams).Add(currentMessageHash);
        }
        object query = this.omit(parameters, "type");
        object subParamsLength = getArrayLength(subParams);
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "/"), this.stream(type, streamHash, subParamsLength));
        object requestId = this.requestId(url);
        object request = new Dictionary<string, object>() {
            { "method", "SUBSCRIBE" },
            { "params", subParams },
            { "id", requestId },
        };
        object subscribe = new Dictionary<string, object>() {
            { "id", requestId },
        };
        object trades = await this.watchMultiple(url, subParams, this.extend(request, query), subParams, subscribe);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeValue(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#watchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        //
        // public watchTrades
        //
        //     {
        //         "e": "trade",       // event type
        //         "E": 1579481530911, // event time
        //         "s": "ETHBTC",      // symbol
        //         "t": 158410082,     // trade id
        //         "p": "0.01914100",  // price
        //         "q": "0.00700000",  // quantity
        //         "b": 586187049,     // buyer order id
        //         "a": 586186710,     // seller order id
        //         "T": 1579481530910, // trade time
        //         "m": false,         // is the buyer the market maker
        //         "M": true           // binance docs say it should be ignored
        //     }
        //
        //     {
        //        "e": "aggTrade",  // Event type
        //        "E": 123456789,   // Event time
        //        "s": "BNBBTC",    // Symbol
        //        "a": 12345,       // Aggregate trade ID
        //        "p": "0.001",     // Price
        //        "q": "100",       // Quantity
        //        "f": 100,         // First trade ID
        //        "l": 105,         // Last trade ID
        //        "T": 123456785,   // Trade time
        //        "m": true,        // Is the buyer the market maker?
        //        "M": true         // Ignore
        //     }
        //
        // private watchMyTrades spot
        //
        //     {
        //         "e": "executionReport",
        //         "E": 1611063861489,
        //         "s": "BNBUSDT",
        //         "c": "m4M6AD5MF3b1ERe65l4SPq",
        //         "S": "BUY",
        //         "o": "MARKET",
        //         "f": "GTC",
        //         "q": "2.00000000",
        //         "p": "0.00000000",
        //         "P": "0.00000000",
        //         "F": "0.00000000",
        //         "g": -1,
        //         "C": '',
        //         "x": "TRADE",
        //         "X": "PARTIALLY_FILLED",
        //         "r": "NONE",
        //         "i": 1296882607,
        //         "l": "0.33200000",
        //         "z": "0.33200000",
        //         "L": "46.86600000",
        //         "n": "0.00033200",
        //         "N": "BNB",
        //         "T": 1611063861488,
        //         "t": 109747654,
        //         "I": 2696953381,
        //         "w": false,
        //         "m": false,
        //         "M": true,
        //         "O": 1611063861488,
        //         "Z": "15.55951200",
        //         "Y": "15.55951200",
        //         "Q": "0.00000000"
        //     }
        //
        // private watchMyTrades future/delivery
        //
        //     {
        //         "s": "BTCUSDT",
        //         "c": "pb2jD6ZQHpfzSdUac8VqMK",
        //         "S": "SELL",
        //         "o": "MARKET",
        //         "f": "GTC",
        //         "q": "0.001",
        //         "p": "0",
        //         "ap": "33468.46000",
        //         "sp": "0",
        //         "x": "TRADE",
        //         "X": "FILLED",
        //         "i": 13351197194,
        //         "l": "0.001",
        //         "z": "0.001",
        //         "L": "33468.46",
        //         "n": "0.00027086",
        //         "N": "BNB",
        //         "T": 1612095165362,
        //         "t": 458032604,
        //         "b": "0",
        //         "a": "0",
        //         "m": false,
        //         "R": false,
        //         "wt": "CONTRACT_PRICE",
        //         "ot": "MARKET",
        //         "ps": "BOTH",
        //         "cp": false,
        //         "rp": "0.00335000",
        //         "pP": false,
        //         "si": 0,
        //         "ss": 0
        //     }
        //
        object executionType = this.safeString(trade, "x");
        object isTradeExecution = (isEqual(executionType, "TRADE"));
        if (!isTrue(isTradeExecution))
        {
            return this.parseTrade(trade, market);
        }
        object id = this.safeString2(trade, "t", "a");
        object timestamp = this.safeInteger(trade, "T");
        object price = this.safeString2(trade, "L", "p");
        object amount = this.safeString(trade, "q");
        if (isTrue(isTradeExecution))
        {
            amount = this.safeString(trade, "l", amount);
        }
        object cost = this.safeString(trade, "Y");
        if (isTrue(isEqual(cost, null)))
        {
            if (isTrue(isTrue((!isEqual(price, null))) && isTrue((!isEqual(amount, null)))))
            {
                cost = Precise.stringMul(price, amount);
            }
        }
        object marketId = this.safeString(trade, "s");
        object marketType = ((bool) isTrue((inOp(trade, "ps")))) ? "contract" : "spot";
        object symbol = this.safeSymbol(marketId, null, null, marketType);
        object side = this.safeStringLower(trade, "S");
        object takerOrMaker = null;
        object orderId = this.safeString(trade, "i");
        if (isTrue(inOp(trade, "m")))
        {
            if (isTrue(isEqual(side, null)))
            {
                side = ((bool) isTrue(getValue(trade, "m"))) ? "sell" : "buy"; // this is reversed intentionally
            }
            takerOrMaker = ((bool) isTrue(getValue(trade, "m"))) ? "maker" : "taker";
        }
        object fee = null;
        object feeCost = this.safeString(trade, "n");
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrencyId = this.safeString(trade, "N");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrencyCode },
            };
        }
        object type = this.safeStringLower(trade, "o");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", id },
            { "order", orderId },
            { "type", type },
            { "takerOrMaker", takerOrMaker },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "fee", fee },
        });
    }

    public virtual void handleTrade(WebSocketClient client, object message)
    {
        // the trade streams push raw trade information in real-time
        // each trade has a unique buyer and seller
        object isSpot = (isTrue((isGreaterThan(getIndexOf(client.url, "wss://stream.binance.com"), -1))) || isTrue((isGreaterThan(getIndexOf(client.url, "/testnet.binance"), -1))));
        object marketType = ((bool) isTrue((isSpot))) ? "spot" : "contract";
        object marketId = this.safeString(message, "s");
        object market = this.safeMarket(marketId, null, null, marketType);
        object symbol = getValue(market, "symbol");
        object lowerCaseId = this.safeStringLower(message, "s");
        object eventVar = this.safeString(message, "e");
        object messageHash = add(add(lowerCaseId, "@"), eventVar);
        object trade = this.parseWsTrade(message, market);
        object tradesArray = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(tradesArray, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            tradesArray = new ArrayCache(limit);
        }
        callDynamically(tradesArray, "append", new object[] {trade});
        ((IDictionary<string,object>)this.trades)[(string)symbol] = tradesArray;
        callDynamically(client as WebSocketClient, "resolve", new object[] {tradesArray, messageHash});
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#watchOHLCV
        * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = getValue(market, "lowercaseId");
        object interval = this.safeString(this.timeframes, timeframe, timeframe);
        object options = this.safeValue(this.options, "watchOHLCV", new Dictionary<string, object>() {});
        object nameOption = this.safeString(options, "name", "kline");
        object name = this.safeString(parameters, "name", nameOption);
        if (isTrue(isEqual(name, "indexPriceKline")))
        {
            marketId = ((string)marketId).Replace((string)"_perp", (string)"");
        }
        parameters = this.omit(parameters, "name");
        object messageHash = add(add(add(add(marketId, "@"), name), "_"), interval);
        object type = getValue(market, "type");
        if (isTrue(getValue(market, "contract")))
        {
            type = ((bool) isTrue(getValue(market, "linear"))) ? "future" : "delivery";
        }
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "/"), this.stream(type, messageHash));
        object requestId = this.requestId(url);
        object request = new Dictionary<string, object>() {
            { "method", "SUBSCRIBE" },
            { "params", new List<object>() {messageHash} },
            { "id", requestId },
        };
        object subscribe = new Dictionary<string, object>() {
            { "id", requestId },
        };
        object ohlcv = await this.watch(url, messageHash, this.extend(request, parameters), messageHash, subscribe);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        //
        //     {
        //         "e": "kline",
        //         "E": 1579482921215,
        //         "s": "ETHBTC",
        //         "k": {
        //             "t": 1579482900000,
        //             "T": 1579482959999,
        //             "s": "ETHBTC",
        //             "i": "1m",
        //             "f": 158411535,
        //             "L": 158411550,
        //             "o": "0.01913200",
        //             "c": "0.01913500",
        //             "h": "0.01913700",
        //             "l": "0.01913200",
        //             "v": "5.08400000",
        //             "n": 16,
        //             "x": false,
        //             "q": "0.09728060",
        //             "V": "3.30200000",
        //             "Q": "0.06318500",
        //             "B": "0"
        //         }
        //     }
        //
        object eventVar = this.safeString(message, "e");
        object eventMap = new Dictionary<string, object>() {
            { "indexPrice_kline", "indexPriceKline" },
            { "markPrice_kline", "markPriceKline" },
        };
        eventVar = this.safeString(eventMap, eventVar, eventVar);
        object kline = this.safeValue(message, "k");
        object marketId = this.safeString2(kline, "s", "ps");
        if (isTrue(isEqual(eventVar, "indexPriceKline")))
        {
            // indexPriceKline doesn't have the _PERP suffix
            marketId = this.safeString(message, "ps");
        }
        object lowercaseMarketId = ((string)marketId).ToLower();
        object interval = this.safeString(kline, "i");
        // use a reverse lookup in a static map instead
        object timeframe = this.findTimeframe(interval);
        object messageHash = add(add(add(add(lowercaseMarketId, "@"), eventVar), "_"), interval);
        object parsed = new List<object> {this.safeInteger(kline, "t"), this.safeFloat(kline, "o"), this.safeFloat(kline, "h"), this.safeFloat(kline, "l"), this.safeFloat(kline, "c"), this.safeFloat(kline, "v")};
        object isSpot = (isTrue((isGreaterThan(getIndexOf(client.url, "/stream"), -1))) || isTrue((isGreaterThan(getIndexOf(client.url, "/testnet.binance"), -1))));
        object marketType = ((bool) isTrue((isSpot))) ? "spot" : "contract";
        object symbol = this.safeSymbol(marketId, null, null, marketType);
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
        }
        callDynamically(stored, "append", new object[] {parsed});
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public async override Task<object> fetchOHLCVWs(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchOHLCVWs
        * @see https://binance-docs.github.io/apidocs/websocket_api/en/#klines
        * @description query historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to query OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} since timestamp in ms of the earliest candle to fetch
        * @param {int} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the exchange API endpoint
        * @param {int} params.until timestamp in ms of the earliest candle to fetch
        *
        * EXCHANGE SPECIFIC PARAMETERS
        * @param {string} params.timeZone default=0 (UTC)
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkIsSpot("fetchOHLCVWs", symbol, parameters);
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "ws");
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCVWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        object payload = new Dictionary<string, object>() {
            { "symbol", this.marketId(symbol) },
            { "returnRateLimits", returnRateLimits },
            { "interval", getValue(this.timeframes, timeframe) },
        };
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)payload)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)payload)["limit"] = limit;
        }
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)payload)["endTime"] = until;
        }
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "klines" },
            { "params", this.extend(payload, parameters) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleFetchOHLCV },
        };
        return await this.watch(url, messageHash, message, messageHash, subscription);
    }

    public virtual void handleFetchOHLCV(WebSocketClient client, object message)
    {
        //
        //    {
        //        "id": "1dbbeb56-8eea-466a-8f6e-86bdcfa2fc0b",
        //        "status": 200,
        //        "result": [
        //            [
        //                1655971200000,      // Kline open time
        //                "0.01086000",       // Open price
        //                "0.01086600",       // High price
        //                "0.01083600",       // Low price
        //                "0.01083800",       // Close price
        //                "2290.53800000",    // Volume
        //                1655974799999,      // Kline close time
        //                "24.85074442",      // Quote asset volume
        //                2283,               // Number of trades
        //                "1171.64000000",    // Taker buy base asset volume
        //                "12.71225884",      // Taker buy quote asset volume
        //                "0"                 // Unused field, ignore
        //            ]
        //        ],
        //        "rateLimits": [
        //            {
        //                "rateLimitType": "REQUEST_WEIGHT",
        //                "interval": "MINUTE",
        //                "intervalNum": 1,
        //                "limit": 6000,
        //                "count": 2
        //            }
        //        ]
        //    }
        //
        object result = this.safeList(message, "result");
        object parsed = this.parseOHLCVs(result);
        // use a reverse lookup in a static map instead
        object messageHash = this.safeString(message, "id");
        callDynamically(client as WebSocketClient, "resolve", new object[] {parsed, messageHash});
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name binance#watchTicker
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.name] stream to use can be ticker or bookTicker
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = getValue(market, "lowercaseId");
        object type = getValue(market, "type");
        if (isTrue(getValue(market, "contract")))
        {
            type = ((bool) isTrue(getValue(market, "linear"))) ? "future" : "delivery";
        }
        object options = this.safeValue(this.options, "watchTicker", new Dictionary<string, object>() {});
        object name = this.safeString(options, "name", "ticker");
        name = this.safeString(parameters, "name", name);
        parameters = this.omit(parameters, "name");
        object messageHash = add(add(marketId, "@"), name);
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "/"), this.stream(type, messageHash));
        object requestId = this.requestId(url);
        object request = new Dictionary<string, object>() {
            { "method", "SUBSCRIBE" },
            { "params", new List<object>() {messageHash} },
            { "id", requestId },
        };
        object subscribe = new Dictionary<string, object>() {
            { "id", requestId },
        };
        return await this.watch(url, messageHash, this.extend(request, parameters), messageHash, subscribe);
    }

    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#watchTickers
        * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
        * @param {string[]} symbols unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, true, true, true);
        object marketIds = this.marketIds(symbols);
        object market = null;
        object type = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            market = this.market(getValue(symbols, 0));
        }
        var typeparametersVariable = this.handleMarketTypeAndParams("watchTickers", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchTickers", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(this.isLinear(type, subType)))
        {
            type = "future";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            type = "delivery";
        }
        object options = this.safeValue(this.options, "watchTickers", new Dictionary<string, object>() {});
        object name = this.safeString(options, "name", "ticker");
        name = this.safeString(parameters, "name", name);
        parameters = this.omit(parameters, "name");
        object wsParams = new List<object>() {};
        object messageHash = "tickers";
        if (isTrue(!isEqual(symbols, null)))
        {
            messageHash = add("tickers::", String.Join(",", ((IList<object>)symbols).ToArray()));
        }
        if (isTrue(isEqual(name, "bookTicker")))
        {
            if (isTrue(isEqual(marketIds, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " watchTickers() requires symbols for bookTicker")) ;
            }
            // simulate watchTickers with subscribe multiple individual bookTicker topic
            for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
            {
                ((IList<object>)wsParams).Add(add(((string)getValue(marketIds, i)).ToLower(), "@bookTicker"));
            }
        } else
        {
            wsParams = new List<object>() {add(add("!", name), "@arr")};
        }
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), type), "/"), this.stream(type, messageHash));
        object requestId = this.requestId(url);
        object request = new Dictionary<string, object>() {
            { "method", "SUBSCRIBE" },
            { "params", wsParams },
            { "id", requestId },
        };
        object subscribe = new Dictionary<string, object>() {
            { "id", requestId },
        };
        object newTickers = await this.watch(url, messageHash, this.extend(request, parameters), messageHash, subscribe);
        if (isTrue(this.newUpdates))
        {
            return newTickers;
        }
        return this.filterByArray(this.tickers, "symbol", symbols);
    }

    public virtual object parseWsTicker(object message, object marketType)
    {
        //
        // ticker
        //     {
        //         "e": "24hrTicker",      // event type
        //         "E": 1579485598569,     // event time
        //         "s": "ETHBTC",          // symbol
        //         "p": "-0.00004000",     // price change
        //         "P": "-0.209",          // price change percent
        //         "w": "0.01920495",      // weighted average price
        //         "x": "0.01916500",      // the price of the first trade before the 24hr rolling window
        //         "c": "0.01912500",      // last (closing) price
        //         "Q": "0.10400000",      // last quantity
        //         "b": "0.01912200",      // best bid
        //         "B": "4.10400000",      // best bid quantity
        //         "a": "0.01912500",      // best ask
        //         "A": "0.00100000",      // best ask quantity
        //         "o": "0.01916500",      // open price
        //         "h": "0.01956500",      // high price
        //         "l": "0.01887700",      // low price
        //         "v": "173518.11900000", // base volume
        //         "q": "3332.40703994",   // quote volume
        //         "O": 1579399197842,     // open time
        //         "C": 1579485597842,     // close time
        //         "F": 158251292,         // first trade id
        //         "L": 158414513,         // last trade id
        //         "n": 163222,            // total number of trades
        //     }
        //
        // miniTicker
        //     {
        //         "e": "24hrMiniTicker",
        //         "E": 1671617114585,
        //         "s": "MOBBUSD",
        //         "c": "0.95900000",
        //         "o": "0.91200000",
        //         "h": "1.04000000",
        //         "l": "0.89400000",
        //         "v": "2109995.32000000",
        //         "q": "2019254.05788000"
        //     }
        //
        object eventVar = this.safeString(message, "e", "bookTicker");
        if (isTrue(isEqual(eventVar, "24hrTicker")))
        {
            eventVar = "ticker";
        }
        object timestamp = null;
        if (isTrue(isEqual(eventVar, "bookTicker")))
        {
            // take the event timestamp, if available, for spot tickers it is not
            timestamp = this.safeInteger(message, "E");
        } else
        {
            // take the timestamp of the closing price for candlestick streams
            timestamp = this.safeInteger2(message, "C", "E");
        }
        object marketId = this.safeString(message, "s");
        object symbol = this.safeSymbol(marketId, null, null, marketType);
        object market = this.safeMarket(marketId, null, null, marketType);
        object last = this.safeString(message, "c");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(message, "h") },
            { "low", this.safeString(message, "l") },
            { "bid", this.safeString(message, "b") },
            { "bidVolume", this.safeString(message, "B") },
            { "ask", this.safeString(message, "a") },
            { "askVolume", this.safeString(message, "A") },
            { "vwap", this.safeString(message, "w") },
            { "open", this.safeString(message, "o") },
            { "close", last },
            { "last", last },
            { "previousClose", this.safeString(message, "x") },
            { "change", this.safeString(message, "p") },
            { "percentage", this.safeString(message, "P") },
            { "average", null },
            { "baseVolume", this.safeString(message, "v") },
            { "quoteVolume", this.safeString(message, "q") },
            { "info", message },
        }, market);
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        // 24hr rolling window ticker statistics for a single symbol
        // These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs
        // Update Speed 1000ms
        //
        //     {
        //         "e": "24hrTicker",      // event type
        //         "E": 1579485598569,     // event time
        //         "s": "ETHBTC",          // symbol
        //         "p": "-0.00004000",     // price change
        //         "P": "-0.209",          // price change percent
        //         "w": "0.01920495",      // weighted average price
        //         "x": "0.01916500",      // the price of the first trade before the 24hr rolling window
        //         "c": "0.01912500",      // last (closing) price
        //         "Q": "0.10400000",      // last quantity
        //         "b": "0.01912200",      // best bid
        //         "B": "4.10400000",      // best bid quantity
        //         "a": "0.01912500",      // best ask
        //         "A": "0.00100000",      // best ask quantity
        //         "o": "0.01916500",      // open price
        //         "h": "0.01956500",      // high price
        //         "l": "0.01887700",      // low price
        //         "v": "173518.11900000", // base volume
        //         "q": "3332.40703994",   // quote volume
        //         "O": 1579399197842,     // open time
        //         "C": 1579485597842,     // close time
        //         "F": 158251292,         // first trade id
        //         "L": 158414513,         // last trade id
        //         "n": 163222,            // total number of trades
        //     }
        //
        object eventVar = this.safeString(message, "e", "bookTicker");
        if (isTrue(isEqual(eventVar, "24hrTicker")))
        {
            eventVar = "ticker";
        } else if (isTrue(isEqual(eventVar, "24hrMiniTicker")))
        {
            eventVar = "miniTicker";
        }
        object wsMarketId = this.safeStringLower(message, "s");
        object messageHash = add(add(wsMarketId, "@"), eventVar);
        object isSpot = (isTrue((isGreaterThan(getIndexOf(client.url, "/stream"), -1))) || isTrue((isGreaterThan(getIndexOf(client.url, "/testnet.binance"), -1))));
        object marketType = ((bool) isTrue((isSpot))) ? "spot" : "contract";
        object result = this.parseWsTicker(message, marketType);
        object symbol = getValue(result, "symbol");
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = result;
        callDynamically(client as WebSocketClient, "resolve", new object[] {result, messageHash});
        if (isTrue(isEqual(eventVar, "bookTicker")))
        {
            // watch bookTickers
            callDynamically(client as WebSocketClient, "resolve", new object[] {result, add("!", "bookTicker@arr")});
            object messageHashes = this.findMessageHashes(client as WebSocketClient, "tickers::");
            for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
            {
                object currentMessageHash = getValue(messageHashes, i);
                object parts = ((string)currentMessageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
                object symbolsString = getValue(parts, 1);
                object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
                if (isTrue(this.inArray(symbol, symbols)))
                {
                    callDynamically(client as WebSocketClient, "resolve", new object[] {result, currentMessageHash});
                }
            }
        }
    }

    public virtual void handleTickers(WebSocketClient client, object message)
    {
        object isSpot = (isTrue((isGreaterThan(getIndexOf(client.url, "/stream"), -1))) || isTrue((isGreaterThan(getIndexOf(client.url, "/testnet.binance"), -1))));
        object marketType = ((bool) isTrue((isSpot))) ? "spot" : "contract";
        object rawTickers = new List<object>() {};
        object newTickers = new Dictionary<string, object>() {};
        if (isTrue(((message is IList<object>) || (message.GetType().IsGenericType && message.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            rawTickers = message;
        } else
        {
            ((IList<object>)rawTickers).Add(message);
        }
        for (object i = 0; isLessThan(i, getArrayLength(rawTickers)); postFixIncrement(ref i))
        {
            object ticker = getValue(rawTickers, i);
            object result = this.parseWsTicker(ticker, marketType);
            object symbol = getValue(result, "symbol");
            ((IDictionary<string,object>)this.tickers)[(string)symbol] = result;
            ((IDictionary<string,object>)newTickers)[(string)symbol] = result;
        }
        object messageHashes = this.findMessageHashes(client as WebSocketClient, "tickers::");
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object tickers = this.filterByArray(newTickers, "symbol", symbols);
            object tickersSymbols = new List<object>(((IDictionary<string,object>)tickers).Keys);
            object numTickers = getArrayLength(tickersSymbols);
            if (isTrue(isGreaterThan(numTickers, 0)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {tickers, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newTickers, "tickers"});
    }

    public virtual object signParams(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object extendedParams = this.extend(new Dictionary<string, object>() {
            { "timestamp", this.nonce() },
            { "apiKey", this.apiKey },
        }, parameters);
        object defaultRecvWindow = this.safeInteger(this.options, "recvWindow");
        if (isTrue(!isEqual(defaultRecvWindow, null)))
        {
            ((IDictionary<string,object>)parameters)["recvWindow"] = defaultRecvWindow;
        }
        object recvWindow = this.safeInteger(parameters, "recvWindow");
        if (isTrue(!isEqual(recvWindow, null)))
        {
            ((IDictionary<string,object>)parameters)["recvWindow"] = recvWindow;
        }
        extendedParams = this.keysort(extendedParams);
        object query = this.urlencode(extendedParams);
        object signature = null;
        if (isTrue(isGreaterThan(getIndexOf(this.secret, "PRIVATE KEY"), -1)))
        {
            if (isTrue(isGreaterThan(((string)this.secret).Length, 120)))
            {
                signature = rsa(query, this.secret, sha256);
            } else
            {
                signature = eddsa(this.encode(query), this.secret, ed25519);
            }
        } else
        {
            signature = this.hmac(this.encode(query), this.encode(this.secret), sha256);
        }
        ((IDictionary<string,object>)extendedParams)["signature"] = signature;
        return extendedParams;
    }

    public async virtual Task authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object time = this.milliseconds();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("authenticate", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("authenticate", null, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object isPortfolioMargin = null;
        var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "authenticate", "papi", "portfolioMargin", false);
        isPortfolioMargin = ((IList<object>)isPortfolioMarginparametersVariable)[0];
        parameters = ((IList<object>)isPortfolioMarginparametersVariable)[1];
        if (isTrue(this.isLinear(type, subType)))
        {
            type = "future";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            type = "delivery";
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("authenticate", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object isIsolatedMargin = (isEqual(marginMode, "isolated"));
        object isCrossMargin = isTrue((isEqual(marginMode, "cross"))) || isTrue((isEqual(marginMode, null)));
        object symbol = this.safeString(parameters, "symbol");
        parameters = this.omit(parameters, "symbol");
        object options = this.safeValue(this.options, type, new Dictionary<string, object>() {});
        object lastAuthenticatedTime = this.safeInteger(options, "lastAuthenticatedTime", 0);
        object listenKeyRefreshRate = this.safeInteger(this.options, "listenKeyRefreshRate", 1200000);
        object delay = this.sum(listenKeyRefreshRate, 10000);
        if (isTrue(isGreaterThan(subtract(time, lastAuthenticatedTime), delay)))
        {
            object response = null;
            if (isTrue(isPortfolioMargin))
            {
                response = await this.papiPostListenKey(parameters);
            } else if (isTrue(isEqual(type, "future")))
            {
                response = await this.fapiPrivatePostListenKey(parameters);
            } else if (isTrue(isEqual(type, "delivery")))
            {
                response = await this.dapiPrivatePostListenKey(parameters);
            } else if (isTrue(isTrue(isEqual(type, "margin")) && isTrue(isCrossMargin)))
            {
                response = await this.sapiPostUserDataStream(parameters);
            } else if (isTrue(isIsolatedMargin))
            {
                if (isTrue(isEqual(symbol, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " authenticate() requires a symbol argument for isolated margin mode")) ;
                }
                object marketId = this.marketId(symbol);
                parameters = this.extend(parameters, new Dictionary<string, object>() {
                    { "symbol", marketId },
                });
                response = await this.sapiPostUserDataStreamIsolated(parameters);
            } else
            {
                response = await this.publicPostUserDataStream(parameters);
            }
            ((IDictionary<string,object>)this.options)[(string)type] = this.extend(options, new Dictionary<string, object>() {
                { "listenKey", this.safeString(response, "listenKey") },
                { "lastAuthenticatedTime", time },
            });
            this.delay(listenKeyRefreshRate,  this.keepAliveListenKey, new object[] { parameters});
        }
    }

    public async virtual Task keepAliveListenKey(object parameters = null)
    {
        // https://binance-docs.github.io/apidocs/spot/en/#listen-key-spot
        parameters ??= new Dictionary<string, object>();
        object type = this.safeString2(this.options, "defaultType", "authenticate", "spot");
        type = this.safeString(parameters, "type", type);
        object isPortfolioMargin = null;
        var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "keepAliveListenKey", "papi", "portfolioMargin", false);
        isPortfolioMargin = ((IList<object>)isPortfolioMarginparametersVariable)[0];
        parameters = ((IList<object>)isPortfolioMarginparametersVariable)[1];
        object subTypeInfo = this.handleSubTypeAndParams("keepAliveListenKey", null, parameters);
        object subType = getValue(subTypeInfo, 0);
        if (isTrue(this.isLinear(type, subType)))
        {
            type = "future";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            type = "delivery";
        }
        object options = this.safeValue(this.options, type, new Dictionary<string, object>() {});
        object listenKey = this.safeString(options, "listenKey");
        if (isTrue(isEqual(listenKey, null)))
        {
            // A network error happened: we can't renew a listen key that does not exist.
            return;
        }
        object request = new Dictionary<string, object>() {};
        object symbol = this.safeString(parameters, "symbol");
        parameters = this.omit(parameters, new List<object>() {"type", "symbol"});
        object time = this.milliseconds();
        try
        {
            if (isTrue(isPortfolioMargin))
            {
                await this.papiPutListenKey(this.extend(request, parameters));
            } else if (isTrue(isEqual(type, "future")))
            {
                await this.fapiPrivatePutListenKey(this.extend(request, parameters));
            } else if (isTrue(isEqual(type, "delivery")))
            {
                await this.dapiPrivatePutListenKey(this.extend(request, parameters));
            } else
            {
                ((IDictionary<string,object>)request)["listenKey"] = listenKey;
                if (isTrue(isEqual(type, "margin")))
                {
                    ((IDictionary<string,object>)request)["symbol"] = symbol;
                    await this.sapiPutUserDataStream(this.extend(request, parameters));
                } else
                {
                    await this.publicPutUserDataStream(this.extend(request, parameters));
                }
            }
        } catch(Exception error)
        {
            object urlType = type;
            if (isTrue(isPortfolioMargin))
            {
                urlType = "papi";
            }
            object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), urlType), "/"), getValue(getValue(this.options, type), "listenKey"));
            var client = this.client(url);
            object messageHashes = new List<object>(((IDictionary<string, ccxt.Exchange.Future>)client.futures).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
            {
                object messageHash = getValue(messageHashes, i);
                ((WebSocketClient)client).reject(error, messageHash);
            }
            ((IDictionary<string,object>)this.options)[(string)type] = this.extend(options, new Dictionary<string, object>() {
                { "listenKey", null },
                { "lastAuthenticatedTime", 0 },
            });
            return;
        }
        ((IDictionary<string,object>)this.options)[(string)type] = this.extend(options, new Dictionary<string, object>() {
            { "listenKey", listenKey },
            { "lastAuthenticatedTime", time },
        });
        // whether or not to schedule another listenKey keepAlive request
        object clients = new List<object>(((IDictionary<string, ccxt.Exchange.WebSocketClient>)this.clients).Values);
        object listenKeyRefreshRate = this.safeInteger(this.options, "listenKeyRefreshRate", 1200000);
        for (object i = 0; isLessThan(i, getArrayLength(clients)); postFixIncrement(ref i))
        {
            var client = getValue(clients, i);
            object subscriptionKeys = new List<object>(((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Keys);
            for (object j = 0; isLessThan(j, getArrayLength(subscriptionKeys)); postFixIncrement(ref j))
            {
                object subscribeType = getValue(subscriptionKeys, j);
                if (isTrue(isEqual(subscribeType, type)))
                {
                    this.delay(listenKeyRefreshRate,  this.keepAliveListenKey, new object[] { parameters});
                    return;
                }
            }
        }
    }

    public virtual void setBalanceCache(WebSocketClient client, object type, object isPortfolioMargin = null)
    {
        isPortfolioMargin ??= false;
        if (isTrue(inOp(((WebSocketClient)client).subscriptions, type)))
        {
            return;
        }
        object options = this.safeValue(this.options, "watchBalance");
        object fetchBalanceSnapshot = this.safeBool(options, "fetchBalanceSnapshot", false);
        if (isTrue(fetchBalanceSnapshot))
        {
            object messageHash = add(type, ":fetchBalanceSnapshot");
            if (!isTrue((inOp(client.futures, messageHash))))
            {
                client.future(messageHash);
                this.spawn(this.loadBalanceSnapshot, new object[] { client, messageHash, type, isPortfolioMargin});
            }
        } else
        {
            ((IDictionary<string,object>)this.balance)[(string)type] = new Dictionary<string, object>() {};
        }
    }

    public async virtual Task loadBalanceSnapshot(WebSocketClient client, object messageHash, object type, object isPortfolioMargin)
    {
        object parameters = new Dictionary<string, object>() {
            { "type", type },
        };
        if (isTrue(isPortfolioMargin))
        {
            ((IDictionary<string,object>)parameters)["portfolioMargin"] = true;
        }
        object response = await this.fetchBalance(parameters);
        ((IDictionary<string,object>)this.balance)[(string)type] = this.extend(response, this.safeValue(this.balance, type, new Dictionary<string, object>() {}));
        // don't remove the future from the .futures cache
        var future = getValue(client.futures, messageHash);
        (future as Future).resolve();
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, type), add(type, ":balance")});
    }

    public async override Task<object> fetchBalanceWs(object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchBalanceWs
        * @description fetch balance and get the amount of funds available for trading or funds locked in orders
        * @see https://binance-docs.github.io/apidocs/websocket_api/en/#account-information-user_data
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string|undefined} [params.type] 'future', 'delivery', 'savings', 'funding', or 'spot'
        * @param {string|undefined} [params.marginMode] 'cross' or 'isolated', for margin trading, uses this.options.defaultMarginMode if not passed, defaults to undefined/None/null
        * @param {string[]|undefined} [params.symbols] unified market symbols, only used in isolated margin mode
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "ws");
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "createOrderWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        object payload = new Dictionary<string, object>() {
            { "returnRateLimits", returnRateLimits },
        };
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "account.status" },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleBalanceWs },
        };
        return await this.watch(url, messageHash, message, messageHash, subscription);
    }

    public virtual void handleBalanceWs(WebSocketClient client, object message)
    {
        //
        //    {
        //        "id": "605a6d20-6588-4cb9-afa0-b0ab087507ba",
        //        "status": 200,
        //        "result": {
        //            "makerCommission": 15,
        //            "takerCommission": 15,
        //            "buyerCommission": 0,
        //            "sellerCommission": 0,
        //            "canTrade": true,
        //            "canWithdraw": true,
        //            "canDeposit": true,
        //            "commissionRates": {
        //                "maker": "0.00150000",
        //                "taker": "0.00150000",
        //                "buyer": "0.00000000",
        //                "seller": "0.00000000"
        //            },
        //            "brokered": false,
        //            "requireSelfTradePrevention": false,
        //            "updateTime": 1660801833000,
        //            "accountType": "SPOT",
        //            "balances": [{
        //                    "asset": "BNB",
        //                    "free": "0.00000000",
        //                    "locked": "0.00000000"
        //                },
        //                {
        //                    "asset": "BTC",
        //                    "free": "1.3447112",
        //                    "locked": "0.08600000"
        //                },
        //                {
        //                    "asset": "USDT",
        //                    "free": "1021.21000000",
        //                    "locked": "0.00000000"
        //                }
        //            ],
        //            "permissions": [
        //                "SPOT"
        //            ]
        //        }
        //    }
        //
        object messageHash = this.safeString(message, "id");
        object result = this.safeValue(message, "result", new Dictionary<string, object>() {});
        object parsedBalances = this.parseBalance(result);
        callDynamically(client as WebSocketClient, "resolve", new object[] {parsedBalances, messageHash});
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        /**
        * @method
        * @name binance#watchBalance
        * @description watch balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.portfolioMargin] set to true if you would like to watch the balance of a portfolio margin account
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.authenticate(parameters);
        object defaultType = this.safeString(this.options, "defaultType", "spot");
        object type = this.safeString(parameters, "type", defaultType);
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchBalance", null, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object isPortfolioMargin = null;
        var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "watchBalance", "papi", "portfolioMargin", false);
        isPortfolioMargin = ((IList<object>)isPortfolioMarginparametersVariable)[0];
        parameters = ((IList<object>)isPortfolioMarginparametersVariable)[1];
        object urlType = type;
        if (isTrue(isPortfolioMargin))
        {
            urlType = "papi";
        }
        if (isTrue(this.isLinear(type, subType)))
        {
            type = "future";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            type = "delivery";
        }
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), urlType), "/"), getValue(getValue(this.options, type), "listenKey"));
        var client = this.client(url);
        this.setBalanceCache(client as WebSocketClient, type, isPortfolioMargin);
        this.setPositionsCache(client as WebSocketClient, type, null, isPortfolioMargin);
        object options = this.safeValue(this.options, "watchBalance");
        object fetchBalanceSnapshot = this.safeBool(options, "fetchBalanceSnapshot", false);
        object awaitBalanceSnapshot = this.safeBool(options, "awaitBalanceSnapshot", true);
        if (isTrue(isTrue(fetchBalanceSnapshot) && isTrue(awaitBalanceSnapshot)))
        {
            await client.future(add(type, ":fetchBalanceSnapshot"));
        }
        object messageHash = add(type, ":balance");
        object message = null;
        return await this.watch(url, messageHash, message, type);
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        // sent upon a balance update not related to orders
        //
        //     {
        //         "e": "balanceUpdate",
        //         "E": 1629352505586,
        //         "a": "IOTX",
        //         "d": "0.43750000",
        //         "T": 1629352505585
        //     }
        //
        // sent upon creating or filling an order
        //
        //     {
        //         "e": "outboundAccountPosition", // Event type
        //         "E": 1564034571105,             // Event Time
        //         "u": 1564034571073,             // Time of last account update
        //         "B": [                          // Balances Array
        //             {
        //                 "a": "ETH",                 // Asset
        //                 "f": "10000.000000",        // Free
        //                 "l": "0.000000"             // Locked
        //             }
        //         ]
        //     }
        //
        // future/delivery
        //
        //     {
        //         "e": "ACCOUNT_UPDATE",            // Event Type
        //         "E": 1564745798939,               // Event Time
        //         "T": 1564745798938 ,              // Transaction
        //         "i": "SfsR",                      // Account Alias
        //         "a": {                            // Update Data
        //             "m":"ORDER",                  // Event reason type
        //             "B":[                         // Balances
        //                 {
        //                     "a":"BTC",                // Asset
        //                     "wb":"122624.12345678",   // Wallet Balance
        //                     "cw":"100.12345678"       // Cross Wallet Balance
        //                 },
        //             ],
        //             "P":[
        //                 {
        //                     "s":"BTCUSD_200925",      // Symbol
        //                     "pa":"0",                 // Position Amount
        //                     "ep":"0.0",               // Entry Price
        //                     "cr":"200",               // (Pre-fee) Accumulated Realized
        //                     "up":"0",                 // Unrealized PnL
        //                     "mt":"isolated",          // Margin Type
        //                     "iw":"0.00000000",        // Isolated Wallet (if isolated position)
        //                     "ps":"BOTH"               // Position Side
        //                 },
        //             ]
        //         }
        //     }
        //
        object wallet = this.safeValue(this.options, "wallet", "wb"); // cw for cross wallet
        // each account is connected to a different endpoint
        // and has exactly one subscriptionhash which is the account type
        object subscriptions = new List<object>(((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Keys);
        object accountType = getValue(subscriptions, 0);
        object messageHash = add(accountType, ":balance");
        if (isTrue(isEqual(getValue(this.balance, accountType), null)))
        {
            ((IDictionary<string,object>)this.balance)[(string)accountType] = new Dictionary<string, object>() {};
        }
        ((IDictionary<string,object>)getValue(this.balance, accountType))["info"] = message;
        object eventVar = this.safeString(message, "e");
        if (isTrue(isEqual(eventVar, "balanceUpdate")))
        {
            object currencyId = this.safeString(message, "a");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            object delta = this.safeString(message, "d");
            if (isTrue(inOp(getValue(this.balance, accountType), code)))
            {
                object previousValue = getValue(getValue(getValue(this.balance, accountType), code), "free");
                if (isTrue(!(previousValue is string)))
                {
                    previousValue = this.numberToString(previousValue);
                }
                ((IDictionary<string,object>)account)["free"] = Precise.stringAdd(previousValue, delta);
            } else
            {
                ((IDictionary<string,object>)account)["free"] = delta;
            }
            ((IDictionary<string,object>)getValue(this.balance, accountType))[(string)code] = account;
        } else
        {
            message = this.safeValue(message, "a", message);
            object B = this.safeValue(message, "B");
            for (object i = 0; isLessThan(i, getArrayLength(B)); postFixIncrement(ref i))
            {
                object entry = getValue(B, i);
                object currencyId = this.safeString(entry, "a");
                object code = this.safeCurrencyCode(currencyId);
                object account = this.account();
                ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "f");
                ((IDictionary<string,object>)account)["used"] = this.safeString(entry, "l");
                ((IDictionary<string,object>)account)["total"] = this.safeString(entry, wallet);
                ((IDictionary<string,object>)getValue(this.balance, accountType))[(string)code] = account;
            }
        }
        object timestamp = this.safeInteger(message, "E");
        ((IDictionary<string,object>)getValue(this.balance, accountType))["timestamp"] = timestamp;
        ((IDictionary<string,object>)getValue(this.balance, accountType))["datetime"] = this.iso8601(timestamp);
        ((IDictionary<string,object>)this.balance)[(string)accountType] = this.safeBalance(getValue(this.balance, accountType));
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.balance, accountType), messageHash});
    }

    public virtual void checkIsSpot(object method, object symbol, object parameters = null)
    {
        /**
        * @method
        * @ignore
        * @description checks if symbols is a spot market if not throws an error
        * @param {string} method name of the method to be checked
        * @param {string} symbol symbol or marketId of the market to be checked
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            object type = this.safeString(parameters, "type", "spot");
            object defaultType = this.safeString(this.options, "defaultType", type);
            if (isTrue(isEqual(defaultType, "spot")))
            {
                return;
            }
            throw new BadRequest ((string)add(add(add(this.id, " "), method), " only supports spot markets")) ;
        }
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new BadRequest ((string)add(add(add(this.id, " "), method), " only supports spot markets")) ;
        }
    }

    public async override Task<object> createOrderWs(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#createOrderWs
        * @see https://binance-docs.github.io/apidocs/websocket_api/en/#place-new-order-trade
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} params.test test order, default false
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkIsSpot("createOrderWs", symbol, parameters);
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "ws");
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object sor = this.safeValue2(parameters, "sor", "SOR", false);
        parameters = this.omit(parameters, "sor", "SOR");
        object payload = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "createOrderWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        ((IDictionary<string,object>)payload)["returnRateLimits"] = returnRateLimits;
        object test = this.safeBool(parameters, "test", false);
        parameters = this.omit(parameters, "test");
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "order.place" },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        if (isTrue(test))
        {
            if (isTrue(sor))
            {
                ((IDictionary<string,object>)message)["method"] = "sor.order.test";
            } else
            {
                ((IDictionary<string,object>)message)["method"] = "order.test";
            }
        }
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleOrderWs },
        };
        return await this.watch(url, messageHash, message, messageHash, subscription);
    }

    public virtual void handleOrderWs(WebSocketClient client, object message)
    {
        //
        //    {
        //        "id": 1,
        //        "status": 200,
        //        "result": {
        //          "symbol": "BTCUSDT",
        //          "orderId": 7663053,
        //          "orderListId": -1,
        //          "clientOrderId": "x-R4BD3S82d8959d0f5114499487a614",
        //          "transactTime": 1687642291434,
        //          "price": "25000.00000000",
        //          "origQty": "0.00100000",
        //          "executedQty": "0.00000000",
        //          "cummulativeQuoteQty": "0.00000000",
        //          "status": "NEW",
        //          "timeInForce": "GTC",
        //          "type": "LIMIT",
        //          "side": "BUY",
        //          "workingTime": 1687642291434,
        //          "fills": [],
        //          "selfTradePreventionMode": "NONE"
        //        },
        //        "rateLimits": [
        //          {
        //            "rateLimitType": "ORDERS",
        //            "interval": "SECOND",
        //            "intervalNum": 10,
        //            "limit": 50,
        //            "count": 1
        //          },
        //          {
        //            "rateLimitType": "ORDERS",
        //            "interval": "DAY",
        //            "intervalNum": 1,
        //            "limit": 160000,
        //            "count": 1
        //          },
        //          {
        //            "rateLimitType": "REQUEST_WEIGHT",
        //            "interval": "MINUTE",
        //            "intervalNum": 1,
        //            "limit": 1200,
        //            "count": 12
        //          }
        //        ]
        //    }
        //
        object messageHash = this.safeString(message, "id");
        object result = this.safeValue(message, "result", new Dictionary<string, object>() {});
        object order = this.parseOrder(result);
        callDynamically(client as WebSocketClient, "resolve", new object[] {order, messageHash});
    }

    public virtual void handleOrdersWs(WebSocketClient client, object message)
    {
        //
        //    {
        //        "id": 1,
        //        "status": 200,
        //        "result": [{
        //            "symbol": "BTCUSDT",
        //            "orderId": 7665584,
        //            "orderListId": -1,
        //            "clientOrderId": "x-R4BD3S82b54769abdd3e4b57874c52",
        //            "price": "26000.00000000",
        //            "origQty": "0.00100000",
        //            "executedQty": "0.00000000",
        //            "cummulativeQuoteQty": "0.00000000",
        //            "status": "NEW",
        //            "timeInForce": "GTC",
        //            "type": "LIMIT",
        //            "side": "BUY",
        //            "stopPrice": "0.00000000",
        //            "icebergQty": "0.00000000",
        //            "time": 1687642884646,
        //            "updateTime": 1687642884646,
        //            "isWorking": true,
        //            "workingTime": 1687642884646,
        //            "origQuoteOrderQty": "0.00000000",
        //            "selfTradePreventionMode": "NONE"
        //        },
        //        ...
        //        ],
        //        "rateLimits": [{
        //            "rateLimitType": "REQUEST_WEIGHT",
        //            "interval": "MINUTE",
        //            "intervalNum": 1,
        //            "limit": 1200,
        //            "count": 14
        //        }]
        //    }
        //
        object messageHash = this.safeString(message, "id");
        object result = this.safeValue(message, "result", new List<object>() {});
        object orders = this.parseOrders(result);
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, messageHash});
    }

    public async override Task<object> editOrderWs(object id, object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#editOrderWs
        * @description edit a trade order
        * @see https://binance-docs.github.io/apidocs/websocket_api/en/#cancel-and-replace-order-trade
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of the currency you want to trade in units of the base currency
        * @param {float|undefined} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkIsSpot("editOrderWs", symbol, parameters);
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "ws");
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object payload = this.editSpotOrderRequest(id, symbol, type, side, amount, price, parameters);
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "editOrderWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        ((IDictionary<string,object>)payload)["returnRateLimits"] = returnRateLimits;
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "order.cancelReplace" },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleEditOrderWs },
        };
        return await this.watch(url, messageHash, message, messageHash, subscription);
    }

    public virtual void handleEditOrderWs(WebSocketClient client, object message)
    {
        //
        //    {
        //        "id": 1,
        //        "status": 200,
        //        "result": {
        //            "cancelResult": "SUCCESS",
        //            "newOrderResult": "SUCCESS",
        //            "cancelResponse": {
        //                "symbol": "BTCUSDT",
        //                "origClientOrderId": "x-R4BD3S82813c5d7ffa594104917de2",
        //                "orderId": 7665177,
        //                "orderListId": -1,
        //                "clientOrderId": "mbrnbQsQhtCXCLY45d5q7S",
        //                "price": "26000.00000000",
        //                "origQty": "0.00100000",
        //                "executedQty": "0.00000000",
        //                "cummulativeQuoteQty": "0.00000000",
        //                "status": "CANCELED",
        //                "timeInForce": "GTC",
        //                "type": "LIMIT",
        //                "side": "BUY",
        //                "selfTradePreventionMode": "NONE"
        //            },
        //            "newOrderResponse": {
        //                "symbol": "BTCUSDT",
        //                "orderId": 7665584,
        //                "orderListId": -1,
        //                "clientOrderId": "x-R4BD3S82b54769abdd3e4b57874c52",
        //                "transactTime": 1687642884646,
        //                "price": "26000.00000000",
        //                "origQty": "0.00100000",
        //                "executedQty": "0.00000000",
        //                "cummulativeQuoteQty": "0.00000000",
        //                "status": "NEW",
        //                "timeInForce": "GTC",
        //                "type": "LIMIT",
        //                "side": "BUY",
        //                "workingTime": 1687642884646,
        //                "fills": [],
        //                "selfTradePreventionMode": "NONE"
        //            }
        //        },
        //        "rateLimits": [{
        //                "rateLimitType": "ORDERS",
        //                "interval": "SECOND",
        //                "intervalNum": 10,
        //                "limit": 50,
        //                "count": 1
        //            },
        //            {
        //                "rateLimitType": "ORDERS",
        //                "interval": "DAY",
        //                "intervalNum": 1,
        //                "limit": 160000,
        //                "count": 3
        //            },
        //            {
        //                "rateLimitType": "REQUEST_WEIGHT",
        //                "interval": "MINUTE",
        //                "intervalNum": 1,
        //                "limit": 1200,
        //                "count": 12
        //            }
        //        ]
        //    }
        //
        object messageHash = this.safeString(message, "id");
        object result = this.safeValue(message, "result", new Dictionary<string, object>() {});
        object rawOrder = this.safeValue(result, "newOrderResponse", new Dictionary<string, object>() {});
        object order = this.parseOrder(rawOrder);
        callDynamically(client as WebSocketClient, "resolve", new object[] {order, messageHash});
    }

    public async override Task<object> cancelOrderWs(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#cancelOrderWs
        * @see https://binance-docs.github.io/apidocs/websocket_api/en/#cancel-order-trade
        * @description cancel multiple orders
        * @param {string} id order id
        * @param {string} symbol unified market symbol, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string|undefined} [params.cancelRestrictions] Supported values: ONLY_NEW - Cancel will succeed if the order status is NEW. ONLY_PARTIALLY_FILLED - Cancel will succeed if order status is PARTIALLY_FILLED.
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new BadRequest ((string)add(this.id, " cancelOrderWs requires a symbol")) ;
        }
        this.checkIsSpot("cancelOrderWs", symbol, parameters);
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "ws");
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "cancelOrderWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        object payload = new Dictionary<string, object>() {
            { "symbol", this.marketId(symbol) },
            { "returnRateLimits", returnRateLimits },
        };
        object clientOrderId = this.safeValue2(parameters, "origClientOrderId", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)payload)["origClientOrderId"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)payload)["orderId"] = this.parseToInt(id);
        }
        parameters = this.omit(parameters, new List<object>() {"origClientOrderId", "clientOrderId"});
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "order.cancel" },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleOrderWs },
        };
        return await this.watch(url, messageHash, message, messageHash, subscription);
    }

    public async override Task<object> cancelAllOrdersWs(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#cancelAllOrdersWs
        * @see https://binance-docs.github.io/apidocs/websocket_api/en/#current-open-orders-user_data
        * @description cancel all open orders in a market
        * @param {string} symbol unified market symbol of the market to cancel orders in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "ws");
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "cancelAllOrdersWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        object payload = new Dictionary<string, object>() {
            { "symbol", this.marketId(symbol) },
            { "returnRateLimits", returnRateLimits },
        };
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "order.cancel" },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleOrdersWs },
        };
        return await this.watch(url, messageHash, message, messageHash, subscription);
    }

    public async override Task<object> fetchOrderWs(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchOrderWs
        * @see https://binance-docs.github.io/apidocs/websocket_api/en/#query-order-user_data
        * @description fetches information on an order made by the user
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new BadRequest ((string)add(this.id, " cancelOrderWs requires a symbol")) ;
        }
        this.checkIsSpot("fetchOrderWs", symbol, parameters);
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "ws");
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "fetchOrderWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        object payload = new Dictionary<string, object>() {
            { "symbol", this.marketId(symbol) },
            { "returnRateLimits", returnRateLimits },
        };
        object clientOrderId = this.safeValue2(parameters, "origClientOrderId", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)payload)["origClientOrderId"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)payload)["orderId"] = this.parseToInt(id);
        }
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "order.status" },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleOrderWs },
        };
        return await this.watch(url, messageHash, message, messageHash, subscription);
    }

    public async override Task<object> fetchOrdersWs(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchOrdersWs
        * @see https://binance-docs.github.io/apidocs/websocket_api/en/#account-order-history-user_data
        * @description fetches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} [since] the earliest time in ms to fetch orders for
        * @param {int|undefined} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.orderId] order id to begin at
        * @param {int} [params.startTime] earliest time in ms to retrieve orders for
        * @param {int} [params.endTime] latest time in ms to retrieve orders for
        * @param {int} [params.limit] the maximum number of order structures to retrieve
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new BadRequest ((string)add(this.id, " fetchOrdersWs requires a symbol")) ;
        }
        this.checkIsSpot("fetchOrdersWs", symbol, parameters);
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "ws");
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "fetchOrderWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        object payload = new Dictionary<string, object>() {
            { "symbol", this.marketId(symbol) },
            { "returnRateLimits", returnRateLimits },
        };
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "allOrders" },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleOrdersWs },
        };
        object orders = await this.watch(url, messageHash, message, messageHash, subscription);
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit);
    }

    public async override Task<object> fetchClosedOrdersWs(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchClosedOrdersWs
        * @see https://binance-docs.github.io/apidocs/websocket_api/en/#account-order-history-user_data
        * @description fetch closed orders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object orders = await this.fetchOrdersWs(symbol, since, limit, parameters);
        object closedOrders = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object order = getValue(orders, i);
            if (isTrue(isEqual(getValue(order, "status"), "closed")))
            {
                ((IList<object>)closedOrders).Add(order);
            }
        }
        return closedOrders;
    }

    public async override Task<object> fetchOpenOrdersWs(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchOpenOrdersWs
        * @see https://binance-docs.github.io/apidocs/websocket_api/en/#current-open-orders-user_data
        * @description fetch all unfilled currently open orders
        * @param {string} symbol unified market symbol
        * @param {int|undefined} [since] the earliest time in ms to fetch open orders for
        * @param {int|undefined} [limit] the maximum number of open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkIsSpot("fetchOpenOrdersWs", symbol);
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "ws");
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "fetchOrderWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        object payload = new Dictionary<string, object>() {
            { "returnRateLimits", returnRateLimits },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            ((IDictionary<string,object>)payload)["symbol"] = this.marketId(symbol);
        }
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "openOrders.status" },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleOrdersWs },
        };
        object orders = await this.watch(url, messageHash, message, messageHash, subscription);
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit);
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#watchOrders
        * @description watches information on multiple orders made by the user
        * @see https://binance-docs.github.io/apidocs/spot/en/#payload-order-update
        * @see https://binance-docs.github.io/apidocs/pm/en/#event-futures-order-update
        * @see https://binance-docs.github.io/apidocs/pm/en/#event-margin-order-update
        * @param {string} symbol unified market symbol of the market the orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string|undefined} [params.marginMode] 'cross' or 'isolated', for spot margin
        * @param {boolean} [params.portfolioMargin] set to true if you would like to watch portfolio margin account orders
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object messageHash = "orders";
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            messageHash = add(messageHash, add(":", symbol));
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchOrders", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(this.isLinear(type, subType)))
        {
            type = "future";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            type = "delivery";
        }
        parameters = this.extend(parameters, new Dictionary<string, object>() {
            { "type", type },
            { "symbol", symbol },
        }); // needed inside authenticate for isolated margin
        await this.authenticate(parameters);
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("watchOrders", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object urlType = type;
        if (isTrue(isTrue((isEqual(type, "margin"))) || isTrue((isTrue((isEqual(type, "spot"))) && isTrue((!isEqual(marginMode, null)))))))
        {
            urlType = "spot"; // spot-margin shares the same stream as regular spot
        }
        object isPortfolioMargin = null;
        var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "watchOrders", "papi", "portfolioMargin", false);
        isPortfolioMargin = ((IList<object>)isPortfolioMarginparametersVariable)[0];
        parameters = ((IList<object>)isPortfolioMarginparametersVariable)[1];
        if (isTrue(isPortfolioMargin))
        {
            urlType = "papi";
        }
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), urlType), "/"), getValue(getValue(this.options, type), "listenKey"));
        var client = this.client(url);
        this.setBalanceCache(client as WebSocketClient, type, isPortfolioMargin);
        this.setPositionsCache(client as WebSocketClient, type, null, isPortfolioMargin);
        object message = null;
        object orders = await this.watch(url, messageHash, message, type);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public override object parseWsOrder(object order, object market = null)
    {
        //
        // spot
        //
        //     {
        //         "e": "executionReport",        // Event type
        //         "E": 1499405658658,            // Event time
        //         "s": "ETHBTC",                 // Symbol
        //         "c": "mUvoqJxFIILMdfAW5iGSOW", // Client order ID
        //         "S": "BUY",                    // Side
        //         "o": "LIMIT",                  // Order type
        //         "f": "GTC",                    // Time in force
        //         "q": "1.00000000",             // Order quantity
        //         "p": "0.10264410",             // Order price
        //         "P": "0.00000000",             // Stop price
        //         "F": "0.00000000",             // Iceberg quantity
        //         "g": -1,                       // OrderListId
        //         "C": null,                     // Original client order ID; This is the ID of the order being canceled
        //         "x": "NEW",                    // Current execution type
        //         "X": "NEW",                    // Current order status
        //         "r": "NONE",                   // Order reject reason; will be an error code.
        //         "i": 4293153,                  // Order ID
        //         "l": "0.00000000",             // Last executed quantity
        //         "z": "0.00000000",             // Cumulative filled quantity
        //         "L": "0.00000000",             // Last executed price
        //         "n": "0",                      // Commission amount
        //         "N": null,                     // Commission asset
        //         "T": 1499405658657,            // Transaction time
        //         "t": -1,                       // Trade ID
        //         "I": 8641984,                  // Ignore
        //         "w": true,                     // Is the order on the book?
        //         "m": false,                    // Is this trade the maker side?
        //         "M": false,                    // Ignore
        //         "O": 1499405658657,            // Order creation time
        //         "Z": "0.00000000",             // Cumulative quote asset transacted quantity
        //         "Y": "0.00000000"              // Last quote asset transacted quantity (i.e. lastPrice * lastQty),
        //         "Q": "0.00000000"              // Quote Order Qty
        //     }
        //
        // future
        //
        //     {
        //         "s":"BTCUSDT",                 // Symbol
        //         "c":"TEST",                    // Client Order Id
        //                                        // special client order id:
        //                                        // starts with "autoclose-": liquidation order
        //                                        // "adl_autoclose": ADL auto close order
        //         "S":"SELL",                    // Side
        //         "o":"TRAILING_STOP_MARKET",    // Order Type
        //         "f":"GTC",                     // Time in Force
        //         "q":"0.001",                   // Original Quantity
        //         "p":"0",                       // Original Price
        //         "ap":"0",                      // Average Price
        //         "sp":"7103.04",                // Stop Price. Please ignore with TRAILING_STOP_MARKET order
        //         "x":"NEW",                     // Execution Type
        //         "X":"NEW",                     // Order Status
        //         "i":8886774,                   // Order Id
        //         "l":"0",                       // Order Last Filled Quantity
        //         "z":"0",                       // Order Filled Accumulated Quantity
        //         "L":"0",                       // Last Filled Price
        //         "N":"USDT",                    // Commission Asset, will not push if no commission
        //         "n":"0",                       // Commission, will not push if no commission
        //         "T":1568879465651,             // Order Trade Time
        //         "t":0,                         // Trade Id
        //         "b":"0",                       // Bids Notional
        //         "a":"9.91",                    // Ask Notional
        //         "m":false,                     // Is this trade the maker side?
        //         "R":false,                     // Is this reduce only
        //         "wt":"CONTRACT_PRICE",         // Stop Price Working Type
        //         "ot":"TRAILING_STOP_MARKET",   // Original Order Type
        //         "ps":"LONG",                   // Position Side
        //         "cp":false,                    // If Close-All, pushed with conditional order
        //         "AP":"7476.89",                // Activation Price, only puhed with TRAILING_STOP_MARKET order
        //         "cr":"5.0",                    // Callback Rate, only puhed with TRAILING_STOP_MARKET order
        //         "rp":"0"                       // Realized Profit of the trade
        //     }
        //
        object executionType = this.safeString(order, "x");
        object orderId = this.safeString(order, "i");
        object marketId = this.safeString(order, "s");
        object marketType = ((bool) isTrue((inOp(order, "ps")))) ? "contract" : "spot";
        object symbol = this.safeSymbol(marketId, null, null, marketType);
        object timestamp = this.safeInteger(order, "O");
        object T = this.safeInteger(order, "T");
        object lastTradeTimestamp = null;
        if (isTrue(isTrue(isTrue(isEqual(executionType, "NEW")) || isTrue(isEqual(executionType, "AMENDMENT"))) || isTrue(isEqual(executionType, "CANCELED"))))
        {
            if (isTrue(isEqual(timestamp, null)))
            {
                timestamp = T;
            }
        } else if (isTrue(isEqual(executionType, "TRADE")))
        {
            lastTradeTimestamp = T;
        }
        object lastUpdateTimestamp = T;
        object fee = null;
        object feeCost = this.safeString(order, "n");
        if (isTrue(isTrue((!isEqual(feeCost, null))) && isTrue((Precise.stringGt(feeCost, "0")))))
        {
            object feeCurrencyId = this.safeString(order, "N");
            object feeCurrency = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrency },
            };
        }
        object price = this.safeString(order, "p");
        object amount = this.safeString(order, "q");
        object side = this.safeStringLower(order, "S");
        object type = this.safeStringLower(order, "o");
        object filled = this.safeString(order, "z");
        object cost = this.safeString(order, "Z");
        object average = this.safeString(order, "ap");
        object rawStatus = this.safeString(order, "X");
        object status = this.parseOrderStatus(rawStatus);
        object trades = null;
        object clientOrderId = this.safeString(order, "C");
        if (isTrue(isTrue((isEqual(clientOrderId, null))) || isTrue((isEqual(((string)clientOrderId).Length, 0)))))
        {
            clientOrderId = this.safeString(order, "c");
        }
        object stopPrice = this.safeString2(order, "P", "sp");
        object timeInForce = this.safeString(order, "f");
        if (isTrue(isEqual(timeInForce, "GTX")))
        {
            // GTX means "Good Till Crossing" and is an equivalent way of saying Post Only
            timeInForce = "PO";
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "symbol", symbol },
            { "id", orderId },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "lastUpdateTimestamp", lastUpdateTimestamp },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", null },
            { "reduceOnly", this.safeValue(order, "R") },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "amount", amount },
            { "cost", cost },
            { "average", average },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", fee },
            { "trades", trades },
        });
    }

    public virtual void handleOrderUpdate(WebSocketClient client, object message)
    {
        //
        // spot
        //
        //     {
        //         "e": "executionReport",        // Event type
        //         "E": 1499405658658,            // Event time
        //         "s": "ETHBTC",                 // Symbol
        //         "c": "mUvoqJxFIILMdfAW5iGSOW", // Client order ID
        //         "S": "BUY",                    // Side
        //         "o": "LIMIT",                  // Order type
        //         "f": "GTC",                    // Time in force
        //         "q": "1.00000000",             // Order quantity
        //         "p": "0.10264410",             // Order price
        //         "P": "0.00000000",             // Stop price
        //         "F": "0.00000000",             // Iceberg quantity
        //         "g": -1,                       // OrderListId
        //         "C": null,                     // Original client order ID; This is the ID of the order being canceled
        //         "x": "NEW",                    // Current execution type
        //         "X": "NEW",                    // Current order status
        //         "r": "NONE",                   // Order reject reason; will be an error code.
        //         "i": 4293153,                  // Order ID
        //         "l": "0.00000000",             // Last executed quantity
        //         "z": "0.00000000",             // Cumulative filled quantity
        //         "L": "0.00000000",             // Last executed price
        //         "n": "0",                      // Commission amount
        //         "N": null,                     // Commission asset
        //         "T": 1499405658657,            // Transaction time
        //         "t": -1,                       // Trade ID
        //         "I": 8641984,                  // Ignore
        //         "w": true,                     // Is the order on the book?
        //         "m": false,                    // Is this trade the maker side?
        //         "M": false,                    // Ignore
        //         "O": 1499405658657,            // Order creation time
        //         "Z": "0.00000000",             // Cumulative quote asset transacted quantity
        //         "Y": "0.00000000"              // Last quote asset transacted quantity (i.e. lastPrice * lastQty),
        //         "Q": "0.00000000"              // Quote Order Qty
        //     }
        //
        // future
        //
        //     {
        //         "e":"ORDER_TRADE_UPDATE",           // Event Type
        //         "E":1568879465651,                  // Event Time
        //         "T":1568879465650,                  // Trasaction Time
        //         "o": {
        //             "s":"BTCUSDT",                  // Symbol
        //             "c":"TEST",                     // Client Order Id
        //                                             // special client order id:
        //                                             // starts with "autoclose-": liquidation order
        //                                             // "adl_autoclose": ADL auto close order
        //             "S":"SELL",                     // Side
        //             "o":"TRAILING_STOP_MARKET",     // Order Type
        //             "f":"GTC",                      // Time in Force
        //             "q":"0.001",                    // Original Quantity
        //             "p":"0",                        // Original Price
        //             "ap":"0",                       // Average Price
        //             "sp":"7103.04",                 // Stop Price. Please ignore with TRAILING_STOP_MARKET order
        //             "x":"NEW",                      // Execution Type
        //             "X":"NEW",                      // Order Status
        //             "i":8886774,                    // Order Id
        //             "l":"0",                        // Order Last Filled Quantity
        //             "z":"0",                        // Order Filled Accumulated Quantity
        //             "L":"0",                        // Last Filled Price
        //             "N":"USDT",                     // Commission Asset, will not push if no commission
        //             "n":"0",                        // Commission, will not push if no commission
        //             "T":1568879465651,              // Order Trade Time
        //             "t":0,                          // Trade Id
        //             "b":"0",                        // Bids Notional
        //             "a":"9.91",                     // Ask Notional
        //             "m":false,                      // Is this trade the maker side?
        //             "R":false,                      // Is this reduce only
        //             "wt":"CONTRACT_PRICE",          // Stop Price Working Type
        //             "ot":"TRAILING_STOP_MARKET",    // Original Order Type
        //             "ps":"LONG",                    // Position Side
        //             "cp":false,                     // If Close-All, pushed with conditional order
        //             "AP":"7476.89",                 // Activation Price, only puhed with TRAILING_STOP_MARKET order
        //             "cr":"5.0",                     // Callback Rate, only puhed with TRAILING_STOP_MARKET order
        //             "rp":"0"                        // Realized Profit of the trade
        //         }
        //     }
        //
        object e = this.safeString(message, "e");
        if (isTrue(isEqual(e, "ORDER_TRADE_UPDATE")))
        {
            message = this.safeValue(message, "o", message);
        }
        this.handleMyTrade(client as WebSocketClient, message);
        this.handleOrder(client as WebSocketClient, message);
    }

    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#watchPositions
        * @description watch all open positions
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.portfolioMargin] set to true if you would like to watch positions in a portfolio margin account
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object messageHash = "";
        symbols = this.marketSymbols(symbols);
        if (!isTrue(this.isEmpty(symbols)))
        {
            market = this.getMarketFromSymbols(symbols);
            messageHash = add("::", String.Join(",", ((IList<object>)symbols).ToArray()));
        }
        object marketTypeObject = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(market, null)))
        {
            ((IDictionary<string,object>)marketTypeObject)["type"] = getValue(market, "type");
            ((IDictionary<string,object>)marketTypeObject)["subType"] = getValue(market, "subType");
        }
        await this.authenticate(this.extend(marketTypeObject, parameters));
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("watchPositions", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(isTrue(isEqual(type, "spot")) || isTrue(isEqual(type, "margin"))))
        {
            type = "future";
        }
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchPositions", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(this.isLinear(type, subType)))
        {
            type = "future";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            type = "delivery";
        }
        messageHash = add(add(type, ":positions"), messageHash);
        object isPortfolioMargin = null;
        var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "watchPositions", "papi", "portfolioMargin", false);
        isPortfolioMargin = ((IList<object>)isPortfolioMarginparametersVariable)[0];
        parameters = ((IList<object>)isPortfolioMarginparametersVariable)[1];
        object urlType = type;
        if (isTrue(isPortfolioMargin))
        {
            urlType = "papi";
        }
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), urlType), "/"), getValue(getValue(this.options, type), "listenKey"));
        var client = this.client(url);
        this.setBalanceCache(client as WebSocketClient, type, isPortfolioMargin);
        this.setPositionsCache(client as WebSocketClient, type, symbols, isPortfolioMargin);
        object fetchPositionsSnapshot = this.handleOption("watchPositions", "fetchPositionsSnapshot", true);
        object awaitPositionsSnapshot = this.safeValue("watchPositions", "awaitPositionsSnapshot", true);
        object cache = this.safeValue(this.positions, type);
        if (isTrue(isTrue(isTrue(fetchPositionsSnapshot) && isTrue(awaitPositionsSnapshot)) && isTrue(isEqual(cache, null))))
        {
            object snapshot = await client.future(add(type, ":fetchPositionsSnapshot"));
            return this.filterBySymbolsSinceLimit(snapshot, symbols, since, limit, true);
        }
        object newPositions = await this.watch(url, messageHash, null, type);
        if (isTrue(this.newUpdates))
        {
            return newPositions;
        }
        return this.filterBySymbolsSinceLimit(cache, symbols, since, limit, true);
    }

    public virtual void setPositionsCache(WebSocketClient client, object type, object symbols = null, object isPortfolioMargin = null)
    {
        isPortfolioMargin ??= false;
        if (isTrue(isEqual(type, "spot")))
        {
            return;
        }
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new Dictionary<string, object>() {};
        }
        if (isTrue(inOp(this.positions, type)))
        {
            return;
        }
        object fetchPositionsSnapshot = this.handleOption("watchPositions", "fetchPositionsSnapshot", false);
        if (isTrue(fetchPositionsSnapshot))
        {
            object messageHash = add(type, ":fetchPositionsSnapshot");
            if (!isTrue((inOp(client.futures, messageHash))))
            {
                client.future(messageHash);
                this.spawn(this.loadPositionsSnapshot, new object[] { client, messageHash, type, isPortfolioMargin});
            }
        } else
        {
            ((IDictionary<string,object>)this.positions)[(string)type] = new ArrayCacheBySymbolBySide();
        }
    }

    public async virtual Task loadPositionsSnapshot(WebSocketClient client, object messageHash, object type, object isPortfolioMargin)
    {
        object parameters = new Dictionary<string, object>() {
            { "type", type },
        };
        if (isTrue(isPortfolioMargin))
        {
            ((IDictionary<string,object>)parameters)["portfolioMargin"] = true;
        }
        object positions = await this.fetchPositions(null, parameters);
        ((IDictionary<string,object>)this.positions)[(string)type] = new ArrayCacheBySymbolBySide();
        object cache = getValue(this.positions, type);
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object position = getValue(positions, i);
            object contracts = this.safeNumber(position, "contracts", 0);
            if (isTrue(isGreaterThan(contracts, 0)))
            {
                callDynamically(cache, "append", new object[] {position});
            }
        }
        // don't remove the future from the .futures cache
        var future = getValue(client.futures, messageHash);
        (future as Future).resolve(cache);
        callDynamically(client as WebSocketClient, "resolve", new object[] {cache, add(type, ":position")});
    }

    public virtual void handlePositions(WebSocketClient client, object message)
    {
        //
        //     {
        //         e: 'ACCOUNT_UPDATE',
        //         T: 1667881353112,
        //         E: 1667881353115,
        //         a: {
        //             B: [{
        //                 a: 'USDT',
        //                 wb: '1127.95750089',
        //                 cw: '1040.82091149',
        //                 bc: '0'
        //             }],
        //             P: [{
        //                 s: 'BTCUSDT',
        //                 pa: '-0.089',
        //                 ep: '19700.03933',
        //                 cr: '-1260.24809979',
        //                 up: '1.53058860',
        //                 mt: 'isolated',
        //                 iw: '87.13658940',
        //                 ps: 'BOTH',
        //                 ma: 'USDT'
        //             }],
        //             m: 'ORDER'
        //         }
        //     }
        //
        // each account is connected to a different endpoint
        // and has exactly one subscriptionhash which is the account type
        object subscriptions = new List<object>(((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Keys);
        object accountType = getValue(subscriptions, 0);
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new Dictionary<string, object>() {};
        }
        if (!isTrue((inOp(this.positions, accountType))))
        {
            ((IDictionary<string,object>)this.positions)[(string)accountType] = new ArrayCacheBySymbolBySide();
        }
        object cache = getValue(this.positions, accountType);
        object data = this.safeValue(message, "a", new Dictionary<string, object>() {});
        object rawPositions = this.safeValue(data, "P", new List<object>() {});
        object newPositions = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rawPositions)); postFixIncrement(ref i))
        {
            object rawPosition = getValue(rawPositions, i);
            object position = this.parseWsPosition(rawPosition);
            object timestamp = this.safeInteger(message, "E");
            ((IDictionary<string,object>)position)["timestamp"] = timestamp;
            ((IDictionary<string,object>)position)["datetime"] = this.iso8601(timestamp);
            ((IList<object>)newPositions).Add(position);
            callDynamically(cache, "append", new object[] {position});
        }
        object messageHashes = this.findMessageHashes(client as WebSocketClient, add(accountType, ":positions::"));
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object positions = this.filterByArray(newPositions, "symbol", symbols, false);
            if (!isTrue(this.isEmpty(positions)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {positions, messageHash});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {newPositions, add(accountType, ":positions")});
    }

    public virtual object parseWsPosition(object position, object market = null)
    {
        //
        //     {
        //         "s": "BTCUSDT", // Symbol
        //         "pa": "0", // Position Amount
        //         "ep": "0.00000", // Entry Price
        //         "cr": "200", // (Pre-fee) Accumulated Realized
        //         "up": "0", // Unrealized PnL
        //         "mt": "isolated", // Margin Type
        //         "iw": "0.00000000", // Isolated Wallet (if isolated position)
        //         "ps": "BOTH" // Position Side
        //     }
        //
        object marketId = this.safeString(position, "s");
        object positionSide = this.safeStringLower(position, "ps");
        object hedged = !isEqual(positionSide, "both");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", this.safeSymbol(marketId, null, null, "contract") },
            { "notional", null },
            { "marginMode", this.safeString(position, "mt") },
            { "liquidationPrice", null },
            { "entryPrice", this.safeNumber(position, "ep") },
            { "unrealizedPnl", this.safeNumber(position, "up") },
            { "percentage", null },
            { "contracts", this.safeNumber(position, "pa") },
            { "contractSize", null },
            { "markPrice", null },
            { "side", positionSide },
            { "hedged", hedged },
            { "timestamp", null },
            { "datetime", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "collateral", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "leverage", null },
            { "marginRatio", null },
        });
    }

    public async override Task<object> fetchMyTradesWs(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchMyTradesWs
        * @see https://binance-docs.github.io/apidocs/websocket_api/en/#account-trade-history-user_data
        * @description fetch all trades made by the user
        * @param {string} symbol unified market symbol
        * @param {int|undefined} [since] the earliest time in ms to fetch trades for
        * @param {int|undefined} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.endTime] the latest time in ms to fetch trades for
        * @param {int} [params.fromId] first trade Id to fetch
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new BadRequest ((string)add(this.id, " fetchMyTradesWs requires a symbol")) ;
        }
        this.checkIsSpot("fetchMyTradesWs", symbol, parameters);
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "ws");
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTradesWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        object payload = new Dictionary<string, object>() {
            { "symbol", this.marketId(symbol) },
            { "returnRateLimits", returnRateLimits },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)payload)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)payload)["limit"] = limit;
        }
        object fromId = this.safeInteger(parameters, "fromId");
        if (isTrue(isTrue(!isEqual(fromId, null)) && isTrue(!isEqual(since, null))))
        {
            throw new BadRequest ((string)add(this.id, "fetchMyTradesWs does not support fetching by both fromId and since parameters at the same time")) ;
        }
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "myTrades" },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleTradesWs },
        };
        object trades = await this.watch(url, messageHash, message, messageHash, subscription);
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit);
    }

    public async override Task<object> fetchTradesWs(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchTradesWs
        * @see https://binance-docs.github.io/apidocs/websocket_api/en/#recent-trades
        * @description fetch all trades made by the user
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve, default=500, max=1000
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        *
        * EXCHANGE SPECIFIC PARAMETERS
        * @param {int} [params.fromId] trade ID to begin at
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new BadRequest ((string)add(this.id, " fetchTradesWs () requires a symbol argument")) ;
        }
        this.checkIsSpot("fetchTradesWs", symbol, parameters);
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "ws");
        object requestId = this.requestId(url);
        object messageHash = ((object)requestId).ToString();
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "fetchTradesWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        object payload = new Dictionary<string, object>() {
            { "symbol", this.marketId(symbol) },
            { "returnRateLimits", returnRateLimits },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)payload)["limit"] = limit;
        }
        object message = new Dictionary<string, object>() {
            { "id", messageHash },
            { "method", "trades.historical" },
            { "params", this.extend(payload, parameters) },
        };
        object subscription = new Dictionary<string, object>() {
            { "method", this.handleTradesWs },
        };
        object trades = await this.watch(url, messageHash, message, messageHash, subscription);
        return this.filterBySinceLimit(trades, since, limit);
    }

    public virtual void handleTradesWs(WebSocketClient client, object message)
    {
        //
        // fetchMyTradesWs
        //
        //    {
        //        "id": "f4ce6a53-a29d-4f70-823b-4ab59391d6e8",
        //        "status": 200,
        //        "result": [
        //            {
        //                "symbol": "BTCUSDT",
        //                "id": 1650422481,
        //                "orderId": 12569099453,
        //                "orderListId": -1,
        //                "price": "23416.10000000",
        //                "qty": "0.00635000",
        //                "quoteQty": "148.69223500",
        //                "commission": "0.00000000",
        //                "commissionAsset": "BNB",
        //                "time": 1660801715793,
        //                "isBuyer": false,
        //                "isMaker": true,
        //                "isBestMatch": true
        //            },
        //            ...
        //        ],
        //    }
        //
        // fetchTradesWs
        //
        //    {
        //        "id": "f4ce6a53-a29d-4f70-823b-4ab59391d6e8",
        //        "status": 200,
        //        "result": [
        //            {
        //                "id": 0,
        //                "price": "0.00005000",
        //                "qty": "40.00000000",
        //                "quoteQty": "0.00200000",
        //                "time": 1500004800376,
        //                "isBuyerMaker": true,
        //                "isBestMatch": true
        //            }
        //            ...
        //        ],
        //    }
        //
        object messageHash = this.safeString(message, "id");
        object result = this.safeValue(message, "result", new List<object>() {});
        object trades = this.parseTrades(result);
        callDynamically(client as WebSocketClient, "resolve", new object[] {trades, messageHash});
    }

    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#watchMyTrades
        * @description watches information on multiple trades made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.portfolioMargin] set to true if you would like to watch trades in a portfolio margin account
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        var typeparametersVariable = this.handleMarketTypeAndParams("watchMyTrades", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("watchMyTrades", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(this.isLinear(type, subType)))
        {
            type = "future";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            type = "delivery";
        }
        object messageHash = "myTrades";
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
            messageHash = add(messageHash, add(":", symbol));
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "type", getValue(market, "type") },
                { "symbol", symbol },
            });
        }
        await this.authenticate(parameters);
        object urlType = type; // we don't change type because the listening key is different
        if (isTrue(isEqual(type, "margin")))
        {
            urlType = "spot"; // spot-margin shares the same stream as regular spot
        }
        object isPortfolioMargin = null;
        var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "watchMyTrades", "papi", "portfolioMargin", false);
        isPortfolioMargin = ((IList<object>)isPortfolioMarginparametersVariable)[0];
        parameters = ((IList<object>)isPortfolioMarginparametersVariable)[1];
        if (isTrue(isPortfolioMargin))
        {
            urlType = "papi";
        }
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), "ws"), urlType), "/"), getValue(getValue(this.options, type), "listenKey"));
        var client = this.client(url);
        this.setBalanceCache(client as WebSocketClient, type, isPortfolioMargin);
        this.setPositionsCache(client as WebSocketClient, type, null, isPortfolioMargin);
        object message = null;
        object trades = await this.watch(url, messageHash, message, type);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleMyTrade(WebSocketClient client, object message)
    {
        object messageHash = "myTrades";
        object executionType = this.safeString(message, "x");
        if (isTrue(isEqual(executionType, "TRADE")))
        {
            object trade = this.parseWsTrade(message);
            object orderId = this.safeString(trade, "order");
            object tradeFee = this.safeValue(trade, "fee", new Dictionary<string, object>() {});
            tradeFee = this.extend(new Dictionary<string, object>() {}, tradeFee);
            object symbol = this.safeString(trade, "symbol");
            if (isTrue(isTrue(isTrue(!isEqual(orderId, null)) && isTrue(!isEqual(tradeFee, null))) && isTrue(!isEqual(symbol, null))))
            {
                object cachedOrders = this.orders;
                if (isTrue(!isEqual(cachedOrders, null)))
                {
                    object orders = this.safeValue((cachedOrders as ArrayCacheBySymbolById).hashmap, symbol, new Dictionary<string, object>() {});
                    object order = this.safeValue(orders, orderId);
                    if (isTrue(!isEqual(order, null)))
                    {
                        // accumulate order fees
                        object fees = this.safeValue(order, "fees");
                        object fee = this.safeValue(order, "fee");
                        if (!isTrue(this.isEmpty(fees)))
                        {
                            object insertNewFeeCurrency = true;
                            for (object i = 0; isLessThan(i, getArrayLength(fees)); postFixIncrement(ref i))
                            {
                                object orderFee = getValue(fees, i);
                                if (isTrue(isEqual(getValue(orderFee, "currency"), getValue(tradeFee, "currency"))))
                                {
                                    object feeCost = this.sum(getValue(tradeFee, "cost"), getValue(orderFee, "cost"));
                                    ((IDictionary<string,object>)getValue(getValue(order, "fees"), i))["cost"] = parseFloat(this.currencyToPrecision(getValue(tradeFee, "currency"), feeCost));
                                    insertNewFeeCurrency = false;
                                    break;
                                }
                            }
                            if (isTrue(insertNewFeeCurrency))
                            {
                                ((IList<object>)getValue(order, "fees")).Add(tradeFee);
                            }
                        } else if (isTrue(!isEqual(fee, null)))
                        {
                            if (isTrue(isEqual(getValue(fee, "currency"), getValue(tradeFee, "currency"))))
                            {
                                object feeCost = this.sum(getValue(fee, "cost"), getValue(tradeFee, "cost"));
                                ((IDictionary<string,object>)getValue(order, "fee"))["cost"] = parseFloat(this.currencyToPrecision(getValue(tradeFee, "currency"), feeCost));
                            } else if (isTrue(isEqual(getValue(fee, "currency"), null)))
                            {
                                ((IDictionary<string,object>)order)["fee"] = tradeFee;
                            } else
                            {
                                ((IDictionary<string,object>)order)["fees"] = new List<object>() {fee, tradeFee};
                                ((IDictionary<string,object>)order)["fee"] = null;
                            }
                        } else
                        {
                            ((IDictionary<string,object>)order)["fee"] = tradeFee;
                        }
                        // save this trade in the order
                        object orderTrades = this.safeValue(order, "trades", new List<object>() {});
                        ((IList<object>)orderTrades).Add(trade);
                        ((IDictionary<string,object>)order)["trades"] = orderTrades;
                    }
                }
            }
            if (isTrue(isEqual(this.myTrades, null)))
            {
                object limit = this.safeInteger(this.options, "tradesLimit", 1000);
                this.myTrades = new ArrayCacheBySymbolById(limit);
            }
            object myTrades = this.myTrades;
            callDynamically(myTrades, "append", new object[] {trade});
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.myTrades, messageHash});
            object messageHashSymbol = add(add(messageHash, ":"), symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.myTrades, messageHashSymbol});
        }
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        object parsed = this.parseWsOrder(message);
        object symbol = this.safeString(parsed, "symbol");
        object orderId = this.safeString(parsed, "id");
        if (isTrue(!isEqual(symbol, null)))
        {
            if (isTrue(isEqual(this.orders, null)))
            {
                object limit = this.safeInteger(this.options, "ordersLimit", 1000);
                this.orders = new ArrayCacheBySymbolById(limit);
            }
            object cachedOrders = this.orders;
            object orders = this.safeValue((cachedOrders as ArrayCacheBySymbolById).hashmap, symbol, new Dictionary<string, object>() {});
            object order = this.safeValue(orders, orderId);
            if (isTrue(!isEqual(order, null)))
            {
                object fee = this.safeValue(order, "fee");
                if (isTrue(!isEqual(fee, null)))
                {
                    ((IDictionary<string,object>)parsed)["fee"] = fee;
                }
                object fees = this.safeValue(order, "fees");
                if (isTrue(!isEqual(fees, null)))
                {
                    ((IDictionary<string,object>)parsed)["fees"] = fees;
                }
                ((IDictionary<string,object>)parsed)["trades"] = this.safeValue(order, "trades");
                object timestamp = this.safeInteger(parsed, "timestamp");
                if (isTrue(isEqual(timestamp, null)))
                {
                    ((IDictionary<string,object>)parsed)["timestamp"] = this.safeInteger(order, "timestamp");
                    ((IDictionary<string,object>)parsed)["datetime"] = this.safeString(order, "datetime");
                }
            }
            callDynamically(cachedOrders, "append", new object[] {parsed});
            object messageHash = "orders";
            object symbolSpecificMessageHash = add("orders:", symbol);
            callDynamically(client as WebSocketClient, "resolve", new object[] {cachedOrders, messageHash});
            callDynamically(client as WebSocketClient, "resolve", new object[] {cachedOrders, symbolSpecificMessageHash});
        }
    }

    public virtual void handleAcountUpdate(WebSocketClient client, object message)
    {
        this.handleBalance(client as WebSocketClient, message);
        this.handlePositions(client as WebSocketClient, message);
    }

    public virtual void handleWsError(WebSocketClient client, object message)
    {
        //
        //    {
        //        "error": {
        //            "code": 2,
        //            "msg": "Invalid request: invalid stream"
        //        },
        //        "id": 1
        //    }
        //
        object id = this.safeString(message, "id");
        object rejected = false;
        object error = this.safeValue(message, "error", new Dictionary<string, object>() {});
        object code = this.safeInteger(error, "code");
        object msg = this.safeString(error, "msg");
        try
        {
            this.handleErrors(code, msg, client.url, null, null, this.json(error), error, null, null);
        } catch(Exception e)
        {
            rejected = true;
            // private endpoint uses id as messageHash
            ((WebSocketClient)client).reject(e, id);
            // public endpoint stores messageHash in subscriptios
            object subscriptionKeys = new List<object>(((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(subscriptionKeys)); postFixIncrement(ref i))
            {
                object subscriptionHash = getValue(subscriptionKeys, i);
                object subscriptionId = this.safeString(getValue(((WebSocketClient)client).subscriptions, subscriptionHash), "id");
                if (isTrue(isEqual(id, subscriptionId)))
                {
                    ((WebSocketClient)client).reject(e, subscriptionHash);
                }
            }
        }
        if (!isTrue(rejected))
        {
            ((WebSocketClient)client).reject(message, id);
        }
        // reset connection if 5xx error
        if (isTrue(isEqual(this.safeString(code, 0), "5")))
        {
            ((WebSocketClient)client).reset(message);
        }
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        // handle WebSocketAPI
        object status = this.safeString(message, "status");
        object error = this.safeValue(message, "error");
        if (isTrue(isTrue((!isEqual(error, null))) || isTrue((isTrue(!isEqual(status, null)) && isTrue(!isEqual(status, "200"))))))
        {
            this.handleWsError(client as WebSocketClient, message);
            return;
        }
        object id = this.safeString(message, "id");
        object subscriptions = this.safeValue(((WebSocketClient)client).subscriptions, id);
        object method = this.safeValue(subscriptions, "method");
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
            return;
        }
        // handle other APIs
        object methods = new Dictionary<string, object>() {
            { "depthUpdate", this.handleOrderBook },
            { "trade", this.handleTrade },
            { "aggTrade", this.handleTrade },
            { "kline", this.handleOHLCV },
            { "markPrice_kline", this.handleOHLCV },
            { "indexPrice_kline", this.handleOHLCV },
            { "24hrTicker@arr", this.handleTickers },
            { "24hrMiniTicker@arr", this.handleTickers },
            { "24hrTicker", this.handleTicker },
            { "24hrMiniTicker", this.handleTicker },
            { "bookTicker", this.handleTicker },
            { "outboundAccountPosition", this.handleBalance },
            { "balanceUpdate", this.handleBalance },
            { "ACCOUNT_UPDATE", this.handleAcountUpdate },
            { "executionReport", this.handleOrderUpdate },
            { "ORDER_TRADE_UPDATE", this.handleOrderUpdate },
        };
        object eventVar = this.safeString(message, "e");
        if (isTrue(((message is IList<object>) || (message.GetType().IsGenericType && message.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            object data = getValue(message, 0);
            eventVar = add(this.safeString(data, "e"), "@arr");
        }
        method = this.safeValue(methods, eventVar);
        if (isTrue(isEqual(method, null)))
        {
            object requestId = this.safeString(message, "id");
            if (isTrue(!isEqual(requestId, null)))
            {
                this.handleSubscriptionStatus(client as WebSocketClient, message);
                return;
            }
            // special case for the real-time bookTicker, since it comes without an event identifier
            //
            //     {
            //         "u": 7488717758,
            //         "s": "BTCUSDT",
            //         "b": "28621.74000000",
            //         "B": "1.43278800",
            //         "a": "28621.75000000",
            //         "A": "2.52500800"
            //     }
            //
            if (isTrue(isEqual(eventVar, null)))
            {
                this.handleTicker(client as WebSocketClient, message);
                this.handleTickers(client as WebSocketClient, message);
            }
        } else
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
    }
}
