namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class coincatch : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "coincatch" },
            { "name", "CoinCatch" },
            { "countries", new List<object>() {"VG"} },
            { "rateLimit", 50 },
            { "version", "v1" },
            { "certified", false },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", true },
                { "cancelAllOrders", true },
                { "cancelAllOrdersAfter", false },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "cancelWithdraw", false },
                { "closePosition", false },
                { "createConvertTrade", false },
                { "createDepositAddress", false },
                { "createLimitBuyOrder", true },
                { "createLimitSellOrder", true },
                { "createMarketBuyOrder", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrder", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrder", true },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", true },
                { "createOrderWithTakeProfitAndStopLoss", true },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", true },
                { "createStopLossOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "createTakeProfitOrder", true },
                { "createTrailingAmountOrder", false },
                { "createTrailingPercentOrder", false },
                { "createTriggerOrder", true },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchCanceledAndClosedOrders", true },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrder", false },
                { "fetchClosedOrders", false },
                { "fetchConvertCurrencies", false },
                { "fetchConvertQuote", false },
                { "fetchConvertTrade", false },
                { "fetchConvertTradeHistory", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", false },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchLedger", true },
                { "fetchLeverage", true },
                { "fetchLeverageTiers", false },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", true },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", false },
                { "fetchOrderTrades", true },
                { "fetchPosition", true },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", true },
                { "fetchPositions", true },
                { "fetchPositionsForSymbol", true },
                { "fetchPositionsHistory", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTransactions", false },
                { "fetchTransfers", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", true },
                { "sandbox", false },
                { "setLeverage", true },
                { "setMargin", false },
                { "setMarginMode", true },
                { "setPositionMode", true },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15", "15m" },
                { "30", "30m" },
                { "1h", "1H" },
                { "2h", "2H" },
                { "4h", "4H" },
                { "6h", "6H" },
                { "12h", "12H" },
                { "1d", "1D" },
                { "3d", "3D" },
                { "1w", "1W" },
                { "1M", "1M" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/3d49065f-f05d-4573-88a2-1b5201ec6ff3" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.coincatch.com" },
                    { "private", "https://api.coincatch.com" },
                } },
                { "www", "https://www.coincatch.com/" },
                { "doc", "https://coincatch.github.io/github.io/en/" },
                { "fees", "https://www.coincatch.com/en/rate/" },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://partner.coincatch.cc/bg/92hy70391729607848548" },
                    { "discount", 0.1 },
                } },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "api/spot/v1/public/time", 1 },
                        { "api/spot/v1/public/currencies", divide(20, 3) },
                        { "api/spot/v1/market/ticker", 1 },
                        { "api/spot/v1/market/tickers", 1 },
                        { "api/spot/v1/market/fills", 2 },
                        { "api/spot/v1/market/fills-history", 2 },
                        { "api/spot/v1/market/candles", 1 },
                        { "api/spot/v1/market/history-candles", 1 },
                        { "api/spot/v1/market/depth", 1 },
                        { "api/spot/v1/market/merge-depth", 1 },
                        { "api/mix/v1/market/contracts", 1 },
                        { "api/mix/v1/market/merge-depth", 1 },
                        { "api/mix/v1/market/depth", 1 },
                        { "api/mix/v1/market/ticker", 1 },
                        { "api/mix/v1/market/tickers", 1 },
                        { "api/mix/v1/market/fills", 1 },
                        { "api/mix/v1/market/fills-history", 1 },
                        { "api/mix/v1/market/candles", 1 },
                        { "pi/mix/v1/market/index", 1 },
                        { "api/mix/v1/market/funding-time", 1 },
                        { "api/mix/v1/market/history-fundRate", 1 },
                        { "api/mix/v1/market/current-fundRate", 1 },
                        { "api/mix/v1/market/open-interest", 1 },
                        { "api/mix/v1/market/mark-price", 1 },
                        { "api/mix/v1/market/symbol-leverage", 1 },
                        { "api/mix/v1/market/queryPositionLever", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "api/spot/v1/wallet/deposit-address", 4 },
                        { "pi/spot/v1/wallet/withdrawal-list", 1 },
                        { "api/spot/v1/wallet/withdrawal-list-v2", 1 },
                        { "api/spot/v1/wallet/deposit-list", 1 },
                        { "api/spot/v1/account/getInfo", 1 },
                        { "api/spot/v1/account/assets", 2 },
                        { "api/spot/v1/account/transferRecords", 1 },
                        { "api/mix/v1/account/account", 2 },
                        { "api/mix/v1/account/accounts", 2 },
                        { "api/mix/v1/position/singlePosition-v2", 2 },
                        { "api/mix/v1/position/allPosition-v2", 4 },
                        { "api/mix/v1/account/accountBill", 2 },
                        { "api/mix/v1/account/accountBusinessBill", 4 },
                        { "api/mix/v1/order/current", 1 },
                        { "api/mix/v1/order/marginCoinCurrent", 1 },
                        { "api/mix/v1/order/history", 2 },
                        { "api/mix/v1/order/historyProductType", 4 },
                        { "api/mix/v1/order/detail", 2 },
                        { "api/mix/v1/order/fills", 2 },
                        { "api/mix/v1/order/allFills", 2 },
                        { "api/mix/v1/plan/currentPlan", 1 },
                        { "api/mix/v1/plan/historyPlan", 2 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "api/spot/v1/wallet/transfer-v2", 4 },
                        { "api/spot/v1/wallet/withdrawal-v2", 4 },
                        { "api/spot/v1/wallet/withdrawal-inner-v2", 1 },
                        { "api/spot/v1/account/bills", 2 },
                        { "api/spot/v1/trade/orders", 2 },
                        { "api/spot/v1/trade/batch-orders", new Dictionary<string, object>() {
                            { "cost", 4 },
                            { "step", 10 },
                        } },
                        { "api/spot/v1/trade/cancel-order", 1 },
                        { "api/spot/v1/trade/cancel-order-v2", 2 },
                        { "api/spot/v1/trade/cancel-symbol-order", 2 },
                        { "api/spot/v1/trade/cancel-batch-orders", 1 },
                        { "api/spot/v1/trade/cancel-batch-orders-v2", 1 },
                        { "api/spot/v1/trade/orderInfo", 1 },
                        { "api/spot/v1/trade/open-orders", 1 },
                        { "api/spot/v1/trade/history", 1 },
                        { "api/spot/v1/trade/fills", 1 },
                        { "api/spot/v1/plan/placePlan", 1 },
                        { "api/spot/v1/plan/modifyPlan", 1 },
                        { "api/spot/v1/plan/cancelPlan", 1 },
                        { "api/spot/v1/plan/currentPlan", 1 },
                        { "api/spot/v1/plan/historyPlan", 1 },
                        { "api/spot/v1/plan/batchCancelPlan", 2 },
                        { "api/mix/v1/account/open-count", 1 },
                        { "api/mix/v1/account/setLeverage", 4 },
                        { "api/mix/v1/account/setMargin", 4 },
                        { "api/mix/v1/account/setMarginMode", 4 },
                        { "api/mix/v1/account/setPositionMode", 4 },
                        { "api/mix/v1/order/placeOrder", 2 },
                        { "api/mix/v1/order/batch-orders", new Dictionary<string, object>() {
                            { "cost", 4 },
                            { "step", 10 },
                        } },
                        { "api/mix/v1/order/cancel-order", 2 },
                        { "api/mix/v1/order/cancel-batch-orders", 2 },
                        { "api/mix/v1/order/cancel-symbol-orders", 2 },
                        { "api/mix/v1/order/cancel-all-orders", 2 },
                        { "api/mix/v1/plan/placePlan", 2 },
                        { "api/mix/v1/plan/modifyPlan", 2 },
                        { "api/mix/v1/plan/modifyPlanPreset", 2 },
                        { "api/mix/v1/plan/placeTPSL", 2 },
                        { "api/mix/v1/plan/placeTrailStop", 2 },
                        { "api/mix/v1/plan/placePositionsTPSL", 2 },
                        { "api/mix/v1/plan/modifyTPSLPlan", 2 },
                        { "api/mix/v1/plan/cancelPlan", 2 },
                        { "api/mix/v1/plan/cancelSymbolPlan", 2 },
                        { "api/mix/v1/plan/cancelAllPlan", 2 },
                    } },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "password", true },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "tierBased", false },
                        { "percentage", true },
                        { "feeSide", "get" },
                        { "maker", this.parseNumber("0.001") },
                        { "taker", this.parseNumber("0.001") },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "brokerId", "47cfy" },
                { "createMarketBuyOrderRequiresPrice", true },
                { "timeframes", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "1m", "1min" },
                        { "5m", "5min" },
                        { "15m", "15min" },
                        { "30m", "30min" },
                        { "1h", "1h" },
                        { "4h", "4h" },
                        { "6h", "6h" },
                        { "12h", "12h" },
                        { "1d", "1day" },
                        { "3d", "3day" },
                        { "1w", "1week" },
                        { "1M", "1M" },
                    } },
                    { "swap", new Dictionary<string, object>() {
                        { "1m", "1m" },
                        { "3m", "3m" },
                        { "5m", "5m" },
                        { "15", "15m" },
                        { "30", "30m" },
                        { "1h", "1H" },
                        { "2h", "2H" },
                        { "4h", "4H" },
                        { "6h", "6H" },
                        { "12h", "12H" },
                        { "1d", "1D" },
                        { "3d", "3D" },
                        { "1w", "1W" },
                        { "1M", "1M" },
                    } },
                } },
                { "currencyIdsListForParseMarket", null },
                { "broker", "" },
                { "networks", new Dictionary<string, object>() {
                    { "BTC", "BITCOIN" },
                    { "ERC20", "ERC20" },
                    { "TRC20", "TRC20" },
                    { "BEP20", "BEP20" },
                    { "ARB", "ArbitrumOne" },
                    { "OPTIMISM", "Optimism" },
                    { "LTC", "LTC" },
                    { "BCH", "BCH" },
                    { "ETC", "ETC" },
                    { "SOL", "SOL" },
                    { "NEO3", "NEO3" },
                    { "STX", "stacks" },
                    { "EGLD", "Elrond" },
                    { "NEAR", "NEARProtocol" },
                    { "ACA", "AcalaToken" },
                    { "KLAY", "Klaytn" },
                    { "FTM", "Fantom" },
                    { "TERRA", "Terra" },
                    { "WAVES", "WAVES" },
                    { "TAO", "TAO" },
                    { "SUI", "SUI" },
                    { "SEI", "SEI" },
                    { "RUNE", "THORChain" },
                    { "ZIL", "ZIL" },
                    { "SXP", "Solar" },
                    { "FET", "FET" },
                    { "AVAX", "C-Chain" },
                    { "XRP", "XRP" },
                    { "EOS", "EOS" },
                    { "DOGE", "DOGECOIN" },
                    { "CAP20", "CAP20" },
                    { "MATIC", "Polygon" },
                    { "CSPR", "CSPR" },
                    { "GLMR", "Moonbeam" },
                    { "MINA", "MINA" },
                    { "CFX", "CFX" },
                    { "STRAT", "StratisEVM" },
                    { "TIA", "Celestia" },
                    { "ChilizChain", "ChilizChain" },
                    { "APT", "Aptos" },
                    { "ONT", "Ontology" },
                    { "ICP", "ICP" },
                    { "ADA", "Cardano" },
                    { "FIL", "FIL" },
                    { "CELO", "CELO" },
                    { "DOT", "DOT" },
                    { "XLM", "StellarLumens" },
                    { "ATOM", "ATOM" },
                    { "CRO", "CronosChain" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "BITCOIN", "BTC" },
                    { "ERC20", "ERC20" },
                    { "TRC20", "TRC20" },
                    { "TRX(TRC20)", "TRC20" },
                    { "BEP20", "BEP20" },
                    { "ArbitrumOne", "ARB" },
                    { "Optimism", "OPTIMISM" },
                    { "LTC", "LTC" },
                    { "BCH", "BCH" },
                    { "ETC", "ETC" },
                    { "SOL", "SOL" },
                    { "NEO3", "NEO3" },
                    { "stacks", "STX" },
                    { "Elrond", "EGLD" },
                    { "NEARProtocol", "NEAR" },
                    { "AcalaToken", "ACA" },
                    { "Klaytn", "KLAY" },
                    { "Fantom", "FTM" },
                    { "Terra", "TERRA" },
                    { "WAVES", "WAVES" },
                    { "TAO", "TAO" },
                    { "SUI", "SUI" },
                    { "SEI", "SEI" },
                    { "THORChain", "RUNE" },
                    { "ZIL", "ZIL" },
                    { "Solar", "SXP" },
                    { "FET", "FET" },
                    { "C-Chain", "AVAX" },
                    { "XRP", "XRP" },
                    { "EOS", "EOS" },
                    { "DOGECOIN", "DOGE" },
                    { "CAP20", "CAP20" },
                    { "Polygon", "MATIC" },
                    { "CSPR", "CSPR" },
                    { "Moonbeam", "GLMR" },
                    { "MINA", "MINA" },
                    { "CFXeSpace", "CFX" },
                    { "CFX", "CFX" },
                    { "StratisEVM", "STRAT" },
                    { "Celestia", "TIA" },
                    { "ChilizChain", "ChilizChain" },
                    { "Aptos", "APT" },
                    { "Ontology", "ONT" },
                    { "ICP", "ICP" },
                    { "Cardano", "ADA" },
                    { "FIL", "FIL" },
                    { "CELO", "CELO" },
                    { "DOT", "DOT" },
                    { "StellarLumens", "XLM" },
                    { "ATOM", "ATOM" },
                    { "CronosChain", "CRO" },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "22001", typeof(OrderNotFound) },
                    { "429", typeof(DDoSProtection) },
                    { "40001", typeof(AuthenticationError) },
                    { "40002", typeof(AuthenticationError) },
                    { "40003", typeof(AuthenticationError) },
                    { "40005", typeof(InvalidNonce) },
                    { "40006", typeof(AuthenticationError) },
                    { "40007", typeof(BadRequest) },
                    { "40008", typeof(InvalidNonce) },
                    { "40009", typeof(AuthenticationError) },
                    { "40011", typeof(AuthenticationError) },
                    { "40012", typeof(AuthenticationError) },
                    { "40013", typeof(ExchangeError) },
                    { "40014", typeof(PermissionDenied) },
                    { "40015", typeof(ExchangeError) },
                    { "40016", typeof(PermissionDenied) },
                    { "40017", typeof(ExchangeError) },
                    { "40018", typeof(PermissionDenied) },
                    { "40019", typeof(BadRequest) },
                    { "40020", typeof(BadRequest) },
                    { "40034", typeof(BadRequest) },
                    { "400172", typeof(BadRequest) },
                    { "40912", typeof(BadRequest) },
                    { "40913", typeof(BadRequest) },
                    { "40102", typeof(BadRequest) },
                    { "40200", typeof(OnMaintenance) },
                    { "40305", typeof(BadRequest) },
                    { "40409", typeof(ExchangeError) },
                    { "40704", typeof(ExchangeError) },
                    { "40724", typeof(BadRequest) },
                    { "40725", typeof(ExchangeError) },
                    { "40762", typeof(InsufficientFunds) },
                    { "40774", typeof(BadRequest) },
                    { "40808", typeof(BadRequest) },
                    { "43001", typeof(OrderNotFound) },
                    { "43002", typeof(InvalidOrder) },
                    { "43004", typeof(OrderNotFound) },
                    { "43005", typeof(RateLimitExceeded) },
                    { "43006", typeof(BadRequest) },
                    { "43007", typeof(BadRequest) },
                    { "43008", typeof(BadRequest) },
                    { "43009", typeof(BadRequest) },
                    { "43010", typeof(BadRequest) },
                    { "43011", typeof(BadRequest) },
                    { "43012", typeof(InsufficientFunds) },
                    { "43117", typeof(InsufficientFunds) },
                    { "43118", typeof(BadRequest) },
                    { "43122", typeof(BadRequest) },
                    { "45006", typeof(InsufficientFunds) },
                    { "45110", typeof(BadRequest) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "precisionMode", TICK_SIZE },
        });
    }

    public override object calculateRateLimiterCost(object api, object method, object path, object parameters, object config = null)
    {
        config ??= new Dictionary<string, object>();
        object step = this.safeInteger(config, "step");
        object cost = this.safeInteger(config, "cost", 1);
        object orders = this.safeList2(parameters, "orderList", "orderDataList", new List<object>() {});
        object ordersLength = getArrayLength(orders);
        if (isTrue(isTrue((!isEqual(step, null))) && isTrue((isGreaterThan(ordersLength, step)))))
        {
            object numberOfSteps = Math.Ceiling(Convert.ToDouble(divide(ordersLength, step)));
            return multiply(cost, numberOfSteps);
        } else
        {
            return cost;
        }
    }

    /**
     * @method
     * @name coincatch#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://coincatch.github.io/github.io/en/spot/#get-server-time
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetApiSpotV1PublicTime(parameters);
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1725046822028,
        //         "data": "1725046822028"
        //     }
        //
        return this.safeInteger(response, "data");
    }

    /**
     * @method
     * @name coincatch#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://coincatch.github.io/github.io/en/spot/#get-coin-list
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetApiSpotV1PublicCurrencies(parameters);
        object data = this.safeList(response, "data", new List<object>() {});
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1725102364202,
        //         "data": [
        //             {
        //                 "coinId": "1",
        //                 "coinName": "BTC",
        //                 "transfer": "true",
        //                 "chains": [
        //                     {
        //                         "chainId": "10",
        //                         "chain": "BITCOIN",
        //                         "needTag": "false",
        //                         "withdrawable": "true",
        //                         "rechargeable": "true",
        //                         "withdrawFee": "0.0005",
        //                         "extraWithDrawFee": "0",
        //                         "depositConfirm": "1",
        //                         "withdrawConfirm": "1",
        //                         "minDepositAmount": "0.00001",
        //                         "minWithdrawAmount": "0.001",
        //                         "browserUrl": "https://blockchair.com/bitcoin/transaction/"
        //                     }
        //                 ]
        //             },
        //             ...
        //         ]
        //     }
        //
        object result = new Dictionary<string, object>() {};
        object currenciesIds = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object currecy = getValue(data, i);
            object currencyId = this.safeString(currecy, "coinName");
            ((IList<object>)currenciesIds).Add(currencyId);
            object code = this.safeCurrencyCode(currencyId);
            object allowDeposit = false;
            object allowWithdraw = false;
            object minDeposit = null;
            object minWithdraw = null;
            object networks = this.safeList(currecy, "chains");
            object networksById = this.safeDict(this.options, "networksById");
            object parsedNetworks = new Dictionary<string, object>() {};
            for (object j = 0; isLessThan(j, getArrayLength(networks)); postFixIncrement(ref j))
            {
                object network = getValue(networks, j);
                object networkId = this.safeString(network, "chain");
                object networkName = this.safeString(networksById, networkId, networkId);
                object networkDepositString = this.safeString(network, "rechargeable");
                object networkDeposit = isEqual(networkDepositString, "true");
                object networkWithdrawString = this.safeString(network, "withdrawable");
                object networkWithdraw = isEqual(networkWithdrawString, "true");
                object networkMinDeposit = this.safeString(network, "minDepositAmount");
                object networkMinWithdraw = this.safeString(network, "minWithdrawAmount");
                ((IDictionary<string,object>)parsedNetworks)[(string)networkId] = new Dictionary<string, object>() {
                    { "id", networkId },
                    { "network", networkName },
                    { "limits", new Dictionary<string, object>() {
                        { "deposit", new Dictionary<string, object>() {
                            { "min", this.parseNumber(networkMinDeposit) },
                            { "max", null },
                        } },
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", this.parseNumber(networkMinWithdraw) },
                            { "max", null },
                        } },
                    } },
                    { "active", isTrue(networkDeposit) && isTrue(networkWithdraw) },
                    { "deposit", networkDeposit },
                    { "withdraw", networkWithdraw },
                    { "fee", this.safeNumber(network, "withdrawFee") },
                    { "precision", null },
                    { "info", network },
                };
                allowDeposit = ((bool) isTrue(allowDeposit)) ? allowDeposit : networkDeposit;
                allowWithdraw = ((bool) isTrue(allowWithdraw)) ? allowWithdraw : networkWithdraw;
                minDeposit = ((bool) isTrue(minDeposit)) ? Precise.stringMin(networkMinDeposit, minDeposit) : networkMinDeposit;
                minWithdraw = ((bool) isTrue(minWithdraw)) ? Precise.stringMin(networkMinWithdraw, minWithdraw) : networkMinWithdraw;
            }
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", currencyId },
                { "numericId", this.safeInteger(currecy, "coinId") },
                { "code", code },
                { "precision", null },
                { "type", null },
                { "name", null },
                { "active", isTrue(allowWithdraw) && isTrue(allowDeposit) },
                { "deposit", allowDeposit },
                { "withdraw", allowWithdraw },
                { "fee", null },
                { "limits", new Dictionary<string, object>() {
                    { "deposit", new Dictionary<string, object>() {
                        { "min", this.parseNumber(minDeposit) },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.parseNumber(minWithdraw) },
                        { "max", null },
                    } },
                } },
                { "networks", parsedNetworks },
                { "info", currecy },
            };
        }
        if (isTrue(isEqual(this.safeList(this.options, "currencyIdsListForParseMarket"), null)))
        {
            ((IDictionary<string,object>)this.options)["currencyIdsListForParseMarket"] = currenciesIds;
        }
        return result;
    }

    /**
     * @method
     * @name coincatch#fetchMarkets
     * @description retrieves data on all markets for the exchange
     * @see https://coincatch.github.io/github.io/en/spot/#get-all-tickers
     * @see https://coincatch.github.io/github.io/en/mix/#get-all-symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetApiSpotV1MarketTickers(parameters);
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1725114040155,
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "high24h": "59461.34",
        //                 "low24h": "57723.23",
        //                 "close": "59056.02",
        //                 "quoteVol": "18240112.23368",
        //                 "baseVol": "309.05564",
        //                 "usdtVol": "18240112.2336744",
        //                 "ts": "1725114038951",
        //                 "buyOne": "59055.85",
        //                 "sellOne": "59057.45",
        //                 "bidSz": "0.0139",
        //                 "askSz": "0.0139",
        //                 "openUtc0": "59126.71",
        //                 "changeUtc": "-0.0012",
        //                 "change": "0.01662"
        //             },
        //             ...
        //         ]
        //     }
        //
        if (isTrue(isEqual(this.safeList(this.options, "currencyIdsListForParseMarket"), null)))
        {
            await this.fetchCurrencies();
        }
        object spotMarkets = this.safeList(response, "data", new List<object>() {});
        object request = new Dictionary<string, object>() {};
        object productType = null;
        var productTypeparametersVariable = this.handleOptionAndParams(parameters, "fetchMarkets", "productType", productType);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object swapMarkets = new List<object>() {};
        ((IDictionary<string,object>)request)["productType"] = "umcbl";
        response = await this.publicGetApiMixV1MarketContracts(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1725297439225,
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT_UMCBL",
        //                 "makerFeeRate": "0.0002",
        //                 "takerFeeRate": "0.0006",
        //                 "feeRateUpRatio": "0.005",
        //                 "openCostUpRatio": "0.01",
        //                 "quoteCoin": "USDT",
        //                 "baseCoin": "BTC",
        //                 "buyLimitPriceRatio": "0.01",
        //                 "sellLimitPriceRatio": "0.01",
        //                 "supportMarginCoins": [ "USDT" ],
        //                 "minTradeNum": "0.001",
        //                 "priceEndStep": "1",
        //                 "volumePlace": "3",
        //                 "pricePlace": "1",
        //                 "sizeMultiplier": "0.001",
        //                 "symbolType": "perpetual",
        //                 "symbolStatus": "normal",
        //                 "offTime": "-1",
        //                 "limitOpenTime": "-1",
        //                 "maintainTime": "",
        //                 "symbolName": "BTCUSDT",
        //                 "minTradeUSDT": null,
        //                 "maxPositionNum": null,
        //                 "maxOrderNum": null
        //             }
        //         ]
        //     }
        //
        object swapUMCBL = this.safeList(response, "data", new List<object>() {});
        ((IDictionary<string,object>)request)["productType"] = "dmcbl";
        response = await this.publicGetApiMixV1MarketContracts(this.extend(request, parameters));
        //
        //     {
        //         "code":"00000",
        //         "msg":"success",
        //         "requestTime":1725297439646,
        //         "data":[
        //             {
        //                 "symbol":"BTCUSD_DMCBL",
        //                 "makerFeeRate":"0.0002",
        //                 "takerFeeRate":"0.0006",
        //                 "feeRateUpRatio":"0.005",
        //                 "openCostUpRatio":"0.01",
        //                 "quoteCoin":"USD",
        //                 "baseCoin":"BTC",
        //                 "buyLimitPriceRatio":"0.01",
        //                 "sellLimitPriceRatio":"0.01",
        //                 "supportMarginCoins":[
        //                     "BTC",
        //                     "ETH"
        //                 ],
        //                 "minTradeNum":"0.001",
        //                 "priceEndStep":"1",
        //                 "volumePlace":"3",
        //                 "pricePlace":"1",
        //                 "sizeMultiplier":"0.001",
        //                 "symbolType":"perpetual",
        //                 "symbolStatus":"normal",
        //                 "offTime":"-1",
        //                 "limitOpenTime":"-1",
        //                 "maintainTime":"",
        //                 "symbolName":"BTCUSD",
        //                 "minTradeUSDT":null,
        //                 "maxPositionNum":null,
        //                 "maxOrderNum":null
        //             }
        //         ]
        //     }
        object swapDMCBL = this.safeList(response, "data", new List<object>() {});
        object swapDMCBLExtended = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(swapDMCBL)); postFixIncrement(ref i))
        {
            object market = getValue(swapDMCBL, i);
            object supportMarginCoins = this.safeList(market, "supportMarginCoins", new List<object>() {});
            for (object j = 0; isLessThan(j, getArrayLength(supportMarginCoins)); postFixIncrement(ref j))
            {
                object settle = getValue(supportMarginCoins, j);
                object obj = new Dictionary<string, object>() {
                    { "supportMarginCoins", new List<object>() {settle} },
                };
                ((IList<object>)swapDMCBLExtended).Add(this.extend(market, obj));
            }
        }
        swapMarkets = this.arrayConcat(swapUMCBL, swapDMCBLExtended);
        object markets = this.arrayConcat(spotMarkets, swapMarkets);
        return this.parseMarkets(markets);
    }

    public override object parseMarket(object market)
    {
        //
        // spot
        //     {
        //         "symbol": "BTCUSDT",
        //         "high24h": "59461.34",
        //         "low24h": "57723.23",
        //         "close": "59056.02",
        //         "quoteVol": "18240112.23368",
        //         "baseVol": "309.05564",
        //         "usdtVol": "18240112.2336744",
        //         "ts": "1725114038951",
        //         "buyOne": "59055.85",
        //         "sellOne": "59057.45",
        //         "bidSz": "0.0139",
        //         "askSz": "0.0139",
        //         "openUtc0": "59126.71",
        //         "changeUtc": "-0.0012",
        //         "change": "0.01662"
        //     },
        //
        // swap
        //     {
        //         "symbol": "BTCUSDT_UMCBL",
        //         "makerFeeRate": "0.0002",
        //         "takerFeeRate": "0.0006",
        //         "feeRateUpRatio": "0.005",
        //         "openCostUpRatio": "0.01",
        //         "quoteCoin": "USDT",
        //         "baseCoin": "BTC",
        //         "buyLimitPriceRatio": "0.01",
        //         "sellLimitPriceRatio": "0.01",
        //         "supportMarginCoins": [ "USDT" ],
        //         "minTradeNum": "0.001",
        //         "priceEndStep": "1",
        //         "volumePlace": "3",
        //         "pricePlace": "1",
        //         "sizeMultiplier": "0.001",
        //         "symbolType": "perpetual",
        //         "symbolStatus": "normal",
        //         "offTime": "-1",
        //         "limitOpenTime": "-1",
        //         "maintainTime": "",
        //         "symbolName": "BTCUSDT",
        //         "minTradeUSDT": null,
        //         "maxPositionNum": null,
        //         "maxOrderNum": null
        //     }
        //
        object marketId = this.safeString(market, "symbol");
        object tradingFees = this.safeDict(this.fees, "trading");
        object fees = this.safeDict(tradingFees, "spot");
        object baseId = this.safeString(market, "baseCoin");
        object quoteId = this.safeString(market, "quoteCoin");
        object settleId = null;
        object suffix = "";
        object settle = null;
        object type = "spot";
        object isLinear = null;
        object isInverse = null;
        object subType = null;
        object isSpot = isEqual(baseId, null); // for now spot markets have no properties baseCoin and quoteCoin
        if (isTrue(isSpot))
        {
            object parsedMarketId = this.parseSpotMarketId(marketId);
            baseId = this.safeString(parsedMarketId, "baseId");
            quoteId = this.safeString(parsedMarketId, "quoteId");
            marketId = add(marketId, "_SPBL"); // spot markets should have current suffix
        } else
        {
            type = "swap";
            ((IDictionary<string,object>)fees)["taker"] = this.safeNumber(market, "takerFeeRate");
            ((IDictionary<string,object>)fees)["maker"] = this.safeNumber(market, "makerFeeRate");
            object supportMarginCoins = this.safeList(market, "supportMarginCoins", new List<object>() {});
            settleId = this.safeString(supportMarginCoins, 0);
            settle = this.safeCurrencyCode(settleId);
            suffix = add(":", settle);
            isLinear = isEqual(baseId, settleId); // todo check
            isInverse = isEqual(quoteId, settleId); // todo check
            if (isTrue(isLinear))
            {
                subType = "linear";
            } else if (isTrue(isInverse))
            {
                subType = "inverse";
            }
        }
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(add(bs, "/"), quote), suffix);
        object symbolStatus = this.safeString(market, "symbolStatus");
        object active = ((bool) isTrue(symbolStatus)) ? (isEqual(symbolStatus, "normal")) : null;
        object volumePlace = this.safeString(market, "volumePlace");
        object amountPrecisionString = this.parsePrecision(volumePlace);
        object pricePlace = this.safeString(market, "pricePlace");
        object priceEndStep = this.safeString(market, "priceEndStep");
        object pricePrecisionString = Precise.stringMul(this.parsePrecision(pricePlace), priceEndStep);
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", marketId },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "active", active },
            { "type", type },
            { "subType", subType },
            { "spot", isSpot },
            { "margin", ((bool) isTrue(isSpot)) ? false : null },
            { "swap", !isTrue(isSpot) },
            { "future", false },
            { "option", false },
            { "contract", !isTrue(isSpot) },
            { "settle", settle },
            { "settleId", settleId },
            { "contractSize", this.safeNumber(market, "sizeMultiplier") },
            { "linear", isLinear },
            { "inverse", isInverse },
            { "taker", this.safeNumber(fees, "taker") },
            { "maker", this.safeNumber(fees, "maker") },
            { "percentage", this.safeBool(fees, "percentage") },
            { "tierBased", this.safeBool(fees, "tierBased") },
            { "feeSide", this.safeString(fees, "feeSide") },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.parseNumber(amountPrecisionString) },
                { "price", this.parseNumber(pricePrecisionString) },
            } },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "minTradeNum") },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        });
    }

    public virtual object parseSpotMarketId(object marketId)
    {
        object baseId = null;
        object quoteId = null;
        object currencyIds = this.safeList(this.options, "currencyIdsListForParseMarket", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencyIds, i);
            object entryIndex = getIndexOf(marketId, currencyId);
            if (isTrue(isGreaterThan(entryIndex, -1)))
            {
                object restId = ((string)marketId).Replace((string)currencyId, (string)"");
                if (isTrue(isEqual(entryIndex, 0)))
                {
                    baseId = currencyId;
                    quoteId = restId;
                } else
                {
                    baseId = restId;
                    quoteId = currencyId;
                }
                break;
            }
        }
        object result = new Dictionary<string, object>() {
            { "baseId", baseId },
            { "quoteId", quoteId },
        };
        return result;
    }

    /**
     * @method
     * @name coincatch#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://coincatch.github.io/github.io/en/spot/#get-single-ticker
     * @see https://coincatch.github.io/github.io/en/mix/#get-single-symbol-ticker
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.publicGetApiSpotV1MarketTicker(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "swap")))
        {
            response = await this.publicGetApiMixV1MarketTicker(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(add(this.id, " "), "fetchTicker() is not supported for "), getValue(market, "type")), " type of markets")) ;
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTicker(data, market);
    }

    /**
     * @method
     * @name coincatch#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://coincatch.github.io/github.io/en/spot/#get-all-tickers
     * @see https://coincatch.github.io/github.io/en/mix/#get-all-symbol-ticker
     * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] 'spot' or 'swap' (default 'spot')
     * @param {string} [params.productType] 'umcbl' or 'dmcbl' (default 'umcbl') - USDT perpetual contract or Universal margin perpetual contract
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchTickers";
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, true, true);
        object market = this.getMarketFromSymbols(symbols);
        object marketType = "spot";
        var marketTypeparametersVariable = this.handleMarketTypeAndParams(methodName, market, parameters, marketType);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.publicGetApiSpotV1MarketTickers(parameters);
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            object productType = "umcbl";
            var productTypeparametersVariable = this.handleOptionAndParams(parameters, methodName, "productType", productType);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            object request = new Dictionary<string, object>() {
                { "productType", productType },
            };
            response = await this.publicGetApiMixV1MarketTickers(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), marketType), " type of markets")) ;
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTickers(data, symbols);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // spot
        //     {
        //         "symbol": "BTCUSDT",
        //         "high24h": "59461.34",
        //         "low24h": "57723.23",
        //         "close": "59056.02",
        //         "quoteVol": "18240112.23368",
        //         "baseVol": "309.05564",
        //         "usdtVol": "18240112.2336744",
        //         "ts": "1725114038951",
        //         "buyOne": "59055.85",
        //         "sellOne": "59057.45",
        //         "bidSz": "0.0139",
        //         "askSz": "0.0139",
        //         "openUtc0": "59126.71",
        //         "changeUtc": "-0.0012",
        //         "change": "0.01662"
        //     }
        //
        // swap
        //     {
        //         "symbol": "ETHUSDT_UMCBL",
        //         "last": "2540.6",
        //         "bestAsk": "2540.71",
        //         "bestBid": "2540.38",
        //         "bidSz": "12.1",
        //         "askSz": "20",
        //         "high24h": "2563.91",
        //         "low24h": "2398.3",
        //         "timestamp": "1725316687177",
        //         "priceChangePercent": "0.01134",
        //         "baseVolume": "706928.96",
        //         "quoteVolume": "1756401737.8766",
        //         "usdtVolume": "1756401737.8766",
        //         "openUtc": "2424.49",
        //         "chgUtc": "0.04789",
        //         "indexPrice": "2541.977142",
        //         "fundingRate": "0.00006",
        //         "holdingAmount": "144688.49",
        //         "deliveryStartTime": null,
        //         "deliveryTime": null,
        //         "deliveryStatus": "normal"
        //     }
        //
        object timestamp = this.safeInteger2(ticker, "ts", "timestamp");
        object marketId = this.safeString(ticker, "symbol", "");
        if (isTrue(isLessThan(getIndexOf(marketId, "_"), 0)))
        {
            marketId = add(marketId, "_SPBL"); // spot markets from tickers endpoints have no suffix specific for market id
        }
        market = this.safeMarketCustom(marketId, market);
        object last = this.safeString2(ticker, "close", "last");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high24h") },
            { "low", this.safeString(ticker, "low24h") },
            { "bid", this.safeString2(ticker, "buyOne", "bestBid") },
            { "bidVolume", this.safeString(ticker, "bidSz") },
            { "ask", this.safeString2(ticker, "sellOne", "bestAsk") },
            { "askVolume", this.safeString(ticker, "askSz") },
            { "vwap", null },
            { "open", this.safeString2(ticker, "openUtc0", "openUtc") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", Precise.stringMul(this.safeString2(ticker, "changeUtc", "chgUtc"), "100") },
            { "average", null },
            { "baseVolume", this.safeString2(ticker, "baseVol", "baseVolume") },
            { "quoteVolume", this.safeString2(ticker, "quoteVol", "quoteVolume") },
            { "indexPrice", this.safeString(ticker, "indexPrice") },
            { "markPrice", null },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name coincatch#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://coincatch.github.io/github.io/en/spot/#get-merged-depth-data
     * @see https://coincatch.github.io/github.io/en/mix/#get-merged-depth-data
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return (maximum and default value is 100)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.precision] 'scale0' (default), 'scale1', 'scale2' or 'scale3' - price accuracy, according to the selected accuracy as the step size to return the cumulative depth
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object methodName = "fetchOrderBook";
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object precision = null;
        var precisionparametersVariable = this.handleOptionAndParams(parameters, methodName, "precision");
        precision = ((IList<object>)precisionparametersVariable)[0];
        parameters = ((IList<object>)precisionparametersVariable)[1];
        if (isTrue(!isEqual(precision, null)))
        {
            ((IDictionary<string,object>)request)["precision"] = precision;
        }
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.publicGetApiSpotV1MarketMergeDepth(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "swap")))
        {
            response = await this.publicGetApiMixV1MarketMergeDepth(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), getValue(market, "type")), " type of markets")) ;
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(data, "ts");
        return this.parseOrderBook(data, symbol, timestamp, "bids", "asks");
    }

    /**
     * @method
     * @name coincatch#fetchOHLCV
     * @see https://coincatch.github.io/github.io/en/spot/#get-candle-data
     * @see https://coincatch.github.io/github.io/en/mix/#get-candle-data
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch (default 100)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @param {string} [params.price] "mark" for mark price candles
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchOHLCV";
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, methodName, "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        object marketType = getValue(market, "type");
        object timeframes = getValue(getValue(this.options, "timeframes"), marketType);
        object encodedTimeframe = this.safeString(timeframes, timeframe, timeframe);
        object maxLimit = 1000;
        object requestedLimit = limit;
        if (isTrue(isTrue((!isEqual(since, null))) || isTrue((!isEqual(until, null)))))
        {
            requestedLimit = maxLimit; // the exchange returns only last limit candles, so we have to fetch max limit if since or until are provided
        }
        if (isTrue(!isEqual(requestedLimit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = requestedLimit;
        }
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            ((IDictionary<string,object>)request)["period"] = encodedTimeframe;
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["after"] = since;
            }
            if (isTrue(!isEqual(until, null)))
            {
                ((IDictionary<string,object>)request)["before"] = until;
            }
            response = await this.publicGetApiSpotV1MarketCandles(this.extend(request, parameters));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1725142465742,
            //         "data": [
            //             {
            //                 "open": "2518.6",
            //                 "high": "2519.19",
            //                 "low": "2518.42",
            //                 "close": "2518.86",
            //                 "quoteVol": "17193.239401",
            //                 "baseVol": "6.8259",
            //                 "usdtVol": "17193.239401",
            //                 "ts": "1725142200000"
            //             },
            //             ...
            //         ]
            //     }
            //
            object data = this.safeList(response, "data", new List<object>() {});
            return this.parseOHLCVs(data, market, timeframe, since, limit);
        } else if (isTrue(getValue(market, "swap")))
        {
            ((IDictionary<string,object>)request)["granularity"] = encodedTimeframe;
            if (isTrue(isEqual(until, null)))
            {
                until = this.milliseconds();
            }
            if (isTrue(isEqual(since, null)))
            {
                object duration = this.parseTimeframe(timeframe);
                since = subtract(until, (multiply(multiply(duration, maxLimit), 1000)));
            }
            ((IDictionary<string,object>)request)["startTime"] = since; // since and until are mandatory for swap
            ((IDictionary<string,object>)request)["endTime"] = until;
            object priceType = null;
            var priceTypeparametersVariable = this.handleOptionAndParams(parameters, methodName, "price");
            priceType = ((IList<object>)priceTypeparametersVariable)[0];
            parameters = ((IList<object>)priceTypeparametersVariable)[1];
            if (isTrue(isEqual(priceType, "mark")))
            {
                ((IDictionary<string,object>)request)["kLineType"] = "market mark index";
            }
            response = await this.publicGetApiMixV1MarketCandles(this.extend(request, parameters));
            //
            //     [
            //         [
            //             "1725379020000",
            //             "57614",
            //             "57636",
            //             "57614",
            //             "57633",
            //             "28.725",
            //             "1655346.493"
            //         ],
            //         ...
            //     ]
            //
            return this.parseOHLCVs(response, market, timeframe, since, limit);
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), getValue(market, "type")), " type of markets")) ;
        }
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        return new List<object> {this.safeInteger2(ohlcv, "ts", 0), this.safeNumber2(ohlcv, "open", 1), this.safeNumber2(ohlcv, "high", 2), this.safeNumber2(ohlcv, "low", 3), this.safeNumber2(ohlcv, "close", 4), this.safeNumber2(ohlcv, "baseVol", 5)};
    }

    /**
     * @method
     * @name coincatch#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://coincatch.github.io/github.io/en/spot/#get-recent-trades
     * @see https://coincatch.github.io/github.io/en/mix/#get-fills
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest entry to fetch
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchTrades";
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, methodName, "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        object maxLimit = 1000;
        object requestLimit = limit;
        if (isTrue(isTrue((!isEqual(since, null))) || isTrue((!isEqual(until, null)))))
        {
            requestLimit = maxLimit;
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["startTime"] = since;
            }
            if (isTrue(!isEqual(until, null)))
            {
                ((IDictionary<string,object>)request)["endTime"] = until;
            }
        }
        if (isTrue(!isEqual(requestLimit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = requestLimit;
        }
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.publicGetApiSpotV1MarketFillsHistory(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "swap")))
        {
            response = await this.publicGetApiMixV1MarketFillsHistory(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), getValue(market, "type")), " type of markets")) ;
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades spot
        //     {
        //         "symbol": "ETHUSDT_SPBL",
        //         "tradeId": "1214135619719827457",
        //         "side": "Buy",
        //         "fillPrice": "2458.62",
        //         "fillQuantity": "0.4756",
        //         "fillTime": "1725198409967"
        //     }
        //
        // fetchTrades swap
        //     {
        //         "tradeId": "1214936067582234782",
        //         "price": "57998.5",
        //         "size": "1.918",
        //         "side": "Sell",
        //         "timestamp": "1725389251000",
        //         "symbol": "BTCUSDT_UMCBL"
        //     }
        //
        // fetchMyTrades spot
        //     {
        //         "accountId": "1002820815393",
        //         "symbol": "ETHUSDT_SPBL",
        //         "orderId": "1217143186968068096",
        //         "fillId": "1217143193356505089",
        //         "orderType": "market",
        //         "side": "buy",
        //         "fillPrice": "2340.55",
        //         "fillQuantity": "0.0042",
        //         "fillTotalAmount": "9.83031",
        //         "feeCcy": "ETH",
        //         "fees": "-0.0000042",
        //         "takerMakerFlag": "taker",
        //         "cTime": "1725915471400"
        //     }
        //
        // fetchMyTrades swap
        //     {
        //         "tradeId": "1225467075440189441",
        //         "symbol": "ETHUSD_DMCBL",
        //         "orderId": "1225467075288719360",
        //         "price": "2362.03",
        //         "sizeQty": "0.1",
        //         "fee": "-0.00005996",
        //         "side": "burst_close_long",
        //         "fillAmount": "236.203",
        //         "profit": "-0.0083359",
        //         "enterPointSource": "SYS",
        //         "tradeSide": "burst_close_long",
        //         "holdMode": "double_hold",
        //         "takerMakerFlag": "taker",
        //         "cTime": "1727900039539"
        //     }
        //
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarketCustom(marketId, market);
        object timestamp = this.safeIntegerN(trade, new List<object>() {"fillTime", "timestamp", "cTime"});
        object fees = this.safeString2(trade, "fees", "fee");
        object feeCost = null;
        if (isTrue(!isEqual(fees, null)))
        {
            feeCost = Precise.stringAbs(fees);
        }
        object feeCurrency = this.safeString(trade, "feeCcy");
        if (isTrue(isTrue((isEqual(feeCurrency, null))) && isTrue((!isEqual(getValue(market, "settle"), null)))))
        {
            feeCurrency = getValue(market, "settle");
        }
        object side = this.safeStringLower2(trade, "tradeSide", "side");
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", this.safeString2(trade, "tradeId", "fillId") },
            { "order", this.safeString(trade, "orderId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "type", this.safeString(trade, "orderType") },
            { "side", this.parseOrderSide(side) },
            { "takerOrMaker", this.safeString(trade, "takerMakerFlag") },
            { "price", this.safeString2(trade, "fillPrice", "price") },
            { "amount", this.safeStringN(trade, new List<object>() {"fillQuantity", "size", "sizeQty"}) },
            { "cost", this.safeString2(trade, "fillTotalAmount", "fillAmount") },
            { "fee", new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrency },
            } },
            { "info", trade },
        }, market);
    }

    /**
     * @method
     * @name coincatch#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://coincatch.github.io/github.io/en/mix/#get-current-funding-rate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = getValue(market, "id");
        object parts = ((string)marketId).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
        object request = new Dictionary<string, object>() {
            { "symbol", marketId },
            { "productType", this.safeString(parts, 1) },
        };
        object response = await this.publicGetApiMixV1MarketCurrentFundRate(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1725402130395,
        //         "data": {
        //             "symbol": "BTCUSDT_UMCBL",
        //             "fundingRate": "0.000043"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseFundingRate(data, market);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        object marketId = this.safeString(contract, "symbol");
        market = this.safeMarketCustom(marketId, market);
        object fundingRate = this.safeNumber(contract, "fundingRate");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", getValue(market, "symbol") },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", fundingRate },
            { "fundingTimestamp", null },
            { "fundingDatetime", null },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public virtual object handleOptionParamsAndRequest(object parameters, object methodName, object optionName, object request, object requestProperty, object defaultValue = null)
    {
        var optionparamsOmitedVariable = this.handleOptionAndParams(parameters, methodName, optionName, defaultValue);
        var option = ((IList<object>) optionparamsOmitedVariable)[0];
        var paramsOmited = ((IList<object>) optionparamsOmitedVariable)[1];
        if (isTrue(!isEqual(option, null)))
        {
            ((IDictionary<string,object>)request)[(string)requestProperty] = option;
        }
        return new List<object>() {request, paramsOmited};
    }

    /**
     * @method
     * @name coincatch#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://coincatch.github.io/github.io/en/mix/#get-history-funding-rate
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of entries to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.pageNo] the page number to fetch
     * @param {bool} [params.nextPage] whether to query the next page (default false)
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object maxEntriesPerRequest = 100;
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object requestedLimit = limit;
        if (isTrue(!isEqual(since, null)))
        {
            requestedLimit = maxEntriesPerRequest;
        }
        if (isTrue(!isEqual(requestedLimit, null)))
        {
            ((IDictionary<string,object>)request)["pageSize"] = requestedLimit;
        }
        object response = await this.publicGetApiMixV1MarketHistoryFundRate(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1725455810888,
        //         "data": [
        //             {
        //                 "symbol": "BTCUSD",
        //                 "fundingRate": "0.000635",
        //                 "settleTime": "1724889600000"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object timestamp = this.safeInteger(entry, "settleTime");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", this.safeSymbol(this.safeString(entry, "symbol"), market, null, "swap") },
                { "fundingRate", this.safeNumber(entry, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySinceLimit(sorted, since, limit);
    }

    /**
     * @method
     * @name coincatch#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://coincatch.github.io/github.io/en/spot/#get-account-assets
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch balance for (default 'spot')
     * @param {string} [params.productType] *swap only* 'umcbl' or 'dmcbl' (default 'umcbl')
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object methodName = "fetchBalance";
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams(methodName, null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1725202685986,
            //         "data": [
            //             {
            //                 "coinId": 2,
            //                 "coinName": "USDT",
            //                 "available": "99.20000000",
            //                 "frozen": "0.00000000",
            //                 "lock": "0.00000000",
            //                 "uTime": "1724938746000"
            //             }
            //         ]
            //     }
            //
            response = await this.privateGetApiSpotV1AccountAssets(parameters);
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            object productType = "umcbl";
            var productTypeparametersVariable = this.handleOptionAndParams(parameters, methodName, "productType", productType);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            object request = new Dictionary<string, object>() {
                { "productType", productType },
            };
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1726666298135,
            //         "data": [
            //             {
            //                 "marginCoin": "USDT",
            //                 "locked": "0",
            //                 "available": "60",
            //                 "crossMaxAvailable": "60",
            //                 "fixedMaxAvailable": "60",
            //                 "maxTransferOut": "60",
            //                 "equity": "60",
            //                 "usdtEquity": "60",
            //                 "btcEquity": "0.001002360626",
            //                 "crossRiskRate": "0",
            //                 "unrealizedPL": "0",
            //                 "bonus": "0",
            //                 "crossedUnrealizedPL": null,
            //                 "isolatedUnrealizedPL": null
            //             }
            //         ]
            //     }
            //
            response = await this.privateGetApiMixV1AccountAccounts(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), marketType), " type of markets")) ;
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseBalance(data);
    }

    public override object parseBalance(object balances)
    {
        //
        // spot
        //     [
        //         {
        //             "coinId": 2,
        //             "coinName": "USDT",
        //             "available": "99.20000000",
        //             "frozen": "0.00000000",
        //             "lock": "0.00000000",
        //             "uTime": "1724938746000"
        //         }
        //     ]
        //
        // swap
        //     [
        //         {
        //             "marginCoin": "USDT",
        //             "locked": "0",
        //             "available": "60",
        //             "crossMaxAvailable": "60",
        //             "fixedMaxAvailable": "60",
        //             "maxTransferOut": "60",
        //             "equity": "60",
        //             "usdtEquity": "60",
        //             "btcEquity": "0.001002360626",
        //             "crossRiskRate": "0",
        //             "unrealizedPL": "0",
        //             "bonus": "0",
        //             "crossedUnrealizedPL": null,
        //             "isolatedUnrealizedPL": null
        //         }
        //     ]
        //
        object result = new Dictionary<string, object>() {
            { "info", balances },
        };
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balanceEntry = this.safeDict(balances, i, new Dictionary<string, object>() {});
            object currencyId = this.safeString2(balanceEntry, "coinName", "marginCoin");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(balanceEntry, "available");
            object locked = this.safeString2(balanceEntry, "lock", "locked");
            object frozen = this.safeString(balanceEntry, "frozen", "0");
            ((IDictionary<string,object>)account)["used"] = Precise.stringAdd(locked, frozen);
            ((IDictionary<string,object>)account)["total"] = this.safeString(balanceEntry, "equity");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name coincatch#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://coincatch.github.io/github.io/en/spot/#transfer
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount 'spot' or 'swap' or 'mix_usdt' or 'mix_usd' - account to transfer from
     * @param {string} toAccount 'spot' or 'swap' or 'mix_usdt' or 'mix_usd' - account to transfer to
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] a unique id for the transfer
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        if (isTrue(isEqual(fromAccount, "swap")))
        {
            if (isTrue(isEqual(code, "USDT")))
            {
                fromAccount = "mix_usdt";
            } else
            {
                fromAccount = "mix_usd";
            }
        }
        if (isTrue(isEqual(toAccount, "swap")))
        {
            if (isTrue(isEqual(code, "USDT")))
            {
                toAccount = "mix_usdt";
            } else
            {
                toAccount = "mix_usd";
            }
        }
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
            { "fromType", fromAccount },
            { "toType", toAccount },
        };
        object clientOrderId = null;
        var clientOrderIdparametersVariable = this.handleOptionAndParams(parameters, "transfer", "clientOrderId");
        clientOrderId = ((IList<object>)clientOrderIdparametersVariable)[0];
        parameters = ((IList<object>)clientOrderIdparametersVariable)[1];
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
        }
        object response = await this.privatePostApiSpotV1WalletTransferV2(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1726664727436,
        //         "data": {
        //             "transferId": "1220285801129066496",
        //             "clientOrderId": null
        //         }
        //     }
        //
        return this.parseTransfer(response, currency);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        object msg = this.safeString(transfer, "msg");
        object status = null;
        if (isTrue(isEqual(msg, "success")))
        {
            status = "ok";
        }
        object data = this.safeDict(transfer, "data", new Dictionary<string, object>() {});
        return new Dictionary<string, object>() {
            { "id", this.safeString(data, "transferId") },
            { "timestamp", null },
            { "datetime", null },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", status },
            { "info", transfer },
        };
    }

    /**
     * @method
     * @name coincatch#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://coincatch.github.io/github.io/en/spot/#get-coin-address
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network] network for fetch deposit address
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
        };
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(isEqual(networkCode, null)))
        {
            networkCode = this.defaultNetworkCode(code);
        }
        if (isTrue(isEqual(networkCode, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDepositAddress() requires a network parameter or a default network code")) ;
        }
        ((IDictionary<string,object>)request)["chain"] = this.networkCodeToId(networkCode, code);
        object response = await this.privateGetApiSpotV1WalletDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1725210515143,
        //         "data": {
        //             "coin": "USDT",
        //             "address": "TKTUt7qiTaMgnTwZXjE3ZBkPB6LKhLPJyZ",
        //             "chain": "TRC20",
        //             "tag": null,
        //             "url": "https://tronscan.org/#/transaction/"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object depositAddress = this.parseDepositAddress(data, currency);
        return depositAddress;
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "coin": "USDT",
        //         "address": "TKTUt7qiTaMgnTwZXjE3ZBkPB6LKhLPJyZ",
        //         "chain": "TRC20",
        //         "tag": null,
        //         "url": "https://tronscan.org/#/transaction/"
        //     }
        //
        object address = this.safeString(depositAddress, "address");
        this.checkAddress(address);
        object networkId = this.safeString(depositAddress, "chain");
        object network = this.safeString(getValue(this.options, "networksById"), networkId, networkId);
        object tag = this.safeString(depositAddress, "tag");
        return new Dictionary<string, object>() {
            { "currency", getValue(currency, "code") },
            { "address", address },
            { "tag", tag },
            { "network", network },
            { "info", depositAddress },
        };
    }

    /**
     * @method
     * @name coincatch#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://coincatch.github.io/github.io/en/spot/#get-deposit-list
     * @param {string} code unified currency code of the currency transferred
     * @param {int} [since] the earliest time in ms to fetch transfers for (default 24 hours ago)
     * @param {int} [limit] the maximum number of transfer structures to retrieve (not used by exchange)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch transfers for (default time now)
     * @param {int} [params.pageNo] pageNo default 1
     * @param {int} [params.pageSize] pageSize (default 20, max 100)
     * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchDeposits";
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, methodName, "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.privateGetApiSpotV1WalletDepositList(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1725205525239,
        //         "data": [
        //             {
        //                 "id": "1213046466852196352",
        //                 "txId": "824246b030cd84d56400661303547f43a1d9fef66cf968628dd5112f362053ff",
        //                 "coin": "USDT",
        //                 "type": "deposit",
        //                 "amount": "99.20000000",
        //                 "status": "success",
        //                 "toAddress": "TKTUt7qiTaMgnTwZXjE3ZBkPB6LKhLPJyZ",
        //                 "fee": null,
        //                 "chain": "TRX(TRC20)",
        //                 "confirm": null,
        //                 "clientOid": null,
        //                 "tag": null,
        //                 "fromAddress": null,
        //                 "dest": "on_chain",
        //                 "cTime": "1724938735688",
        //                 "uTime": "1724938746015"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit);
    }

    /**
     * @method
     * @name coincatch#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://coincatch.github.io/github.io/en/spot/#get-withdraw-list-v2
     * @param {string} code unified currency code of the currency transferred
     * @param {int} [since] the earliest time in ms to fetch transfers for (default 24 hours ago)
     * @param {int} [limit] the maximum number of transfer structures to retrieve (default 50, max 200)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch transfers for (default time now)
     * @param {string} [params.clientOid] clientOid
     * @param {string} [params.orderId] The response orderId
     * @param {string} [params.idLessThan] Requests the content on the page before this ID (older data), the value input should be the orderId of the corresponding interface.
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchWithdrawals";
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, methodName, "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.privateGetApiSpotV1WalletWithdrawalListV2(this.extend(request, parameters));
        // todo add after withdrawal
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit);
    }

    /**
     * @method
     * @name coincatch#withdraw
     * @description make a withdrawal
     * @see https://coincatch.github.io/github.io/en/spot/#withdraw
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} [tag]
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} params.network network for withdraw (mandatory)
     * @param {string} [params.remark] remark
     * @param {string} [params.clientOid] custom id
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "address", address },
            { "amount", amount },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["tag"] = tag;
        }
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["chain"] = this.networkCodeToId(networkCode);
        }
        object response = await this.privatePostApiSpotV1WalletWithdrawalV2(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "data": {
        //             "orderId":888291686266343424",
        //             "clientOrderId":"123"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTransaction(data, currency);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //     {
        //         "id": "1213046466852196352",
        //         "txId": "824246b030cd84d56400661303547f43a1d9fef66cf968628dd5112f362053ff",
        //         "coin": "USDT",
        //         "type": "deposit",
        //         "amount": "99.20000000",
        //         "status": "success",
        //         "toAddress": "TKTUt7qiTaMgnTwZXjE3ZBkPB6LKhLPJyZ",
        //         "fee": null,
        //         "chain": "TRX(TRC20)",
        //         "confirm": null,
        //         "clientOid": null,
        //         "tag": null,
        //         "fromAddress": null,
        //         "dest": "on_chain",
        //         "cTime": "1724938735688",
        //         "uTime": "1724938746015"
        //     }
        //
        // withdraw
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "data": {
        //             "orderId":888291686266343424",
        //             "clientOrderId":"123"
        //         }
        //     }
        //
        object status = this.safeString(transaction, "status");
        if (isTrue(isEqual(status, "success")))
        {
            status = "ok";
        }
        object txid = this.safeString(transaction, "txId");
        object coin = this.safeString(transaction, "coin");
        object code = this.safeCurrencyCode(coin, currency);
        object timestamp = this.safeInteger(transaction, "cTime");
        object amount = this.safeNumber(transaction, "amount");
        object networkId = this.safeString(transaction, "chain");
        object network = this.safeString(getValue(this.options, "networksById"), networkId, networkId);
        object addressTo = this.safeString(transaction, "toAddress");
        object addressFrom = this.safeString(transaction, "fromAddress");
        object tag = this.safeString(transaction, "tag");
        object type = this.safeString(transaction, "type");
        object feeCost = this.safeNumber(transaction, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", code },
            };
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString2(transaction, "id", "orderId") },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", network },
            { "address", null },
            { "addressTo", addressTo },
            { "addressFrom", addressFrom },
            { "tag", tag },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", type },
            { "amount", amount },
            { "currency", code },
            { "status", status },
            { "updated", null },
            { "internal", null },
            { "comment", null },
            { "fee", fee },
        };
    }

    /**
     * @method
     * @name coincatch#createMarketBuyOrderWithCost
     * @description create a market buy order by providing the symbol and cost
     * @see https://coincatch.github.io/github.io/en/spot/#place-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object methodName = "createMarketBuyOrderWithCost";
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " "), methodName), "() supports spot orders only")) ;
        }
        ((IDictionary<string,object>)parameters)["methodName"] = methodName;
        ((IDictionary<string,object>)parameters)["createMarketBuyOrderRequiresPrice"] = false;
        return await this.createOrder(symbol, "market", "buy", cost, null, parameters);
    }

    /**
     * @method
     * @name coincatch#createOrder
     * @description create a trade order
     * @see https://coincatch.github.io/github.io/en/spot/#place-order
     * @see https://coincatch.github.io/github.io/en/spot/#place-plan-order
     * @see https://coincatch.github.io/github.io/en/mix/#place-order
     * @see https://coincatch.github.io/github.io/en/mix/#place-plan-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit' or 'LIMIT_MAKER' for spot, 'market' or 'limit' or 'STOP' for swap
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of you want to trade in units of the base currency
     * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
     * @param {float} [params.triggerPrice] the price that the order is to be triggered
     * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
     * @param {string} [params.timeInForce] 'GTC', 'IOC', 'FOK' or 'PO'
     * @param {string} [params.clientOrderId] a unique id for the order - is mandatory for swap
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        ((IDictionary<string,object>)parameters)["methodName"] = this.safeString(parameters, "methodName", "createOrder");
        object market = this.market(symbol);
        if (isTrue(getValue(market, "spot")))
        {
            return await this.createSpotOrder(symbol, type, side, amount, price, parameters);
        } else if (isTrue(getValue(market, "swap")))
        {
            return await this.createSwapOrder(symbol, type, side, amount, price, parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " createOrder() is not supported for "), getValue(market, "type")), " type of markets")) ;
        }
    }

    /**
     * @method
     * @name coincatch#createSpotOrder
     * @description create a trade order on spot market
     * @see https://coincatch.github.io/github.io/en/spot/#place-order
     * @see https://coincatch.github.io/github.io/en/spot/#place-plan-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of you want to trade in units of the base currency
     * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.cost] *market buy only* the quote quantity that can be used as an alternative for the amount
     * @param {float} [params.triggerPrice] the price that the order is to be triggered at
     * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
     * @param {string} [params.timeInForce] 'GTC', 'IOC', 'FOK' or 'PO'
     * @param {string} [params.clientOrderId] a unique id for the order (max length 40)
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> createSpotOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        ((IDictionary<string,object>)parameters)["methodName"] = this.safeString(parameters, "methodName", "createSpotOrder");
        object request = this.createSpotOrderRequest(symbol, type, side, amount, price, parameters);
        object isPlanOrer = !isEqual(this.safeString(request, "triggerPrice"), null);
        object response = null;
        if (isTrue(isPlanOrer))
        {
            response = await this.privatePostApiSpotV1PlanPlacePlan(request);
        } else
        {
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1725915469815,
            //         "data": {
            //             "orderId": "1217143186968068096",
            //             "clientOrderId": "8fa3eb89-2377-4519-a199-35d5db9ed262"
            //         }
            //     }
            //
            response = await this.privatePostApiSpotV1TradeOrders(request);
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object market = this.market(symbol);
        return this.parseOrder(data, market);
    }

    public virtual object createSpotOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @ignore
        * @name coincatch#createSpotOrderRequest
        * @description helper function to build request
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of you want to trade in units of the base currency
        * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.triggerPrice] the price that the order is to be triggered at
        * @param {float} [params.cost] *market buy only* the quote quantity that can be used as an alternative for the amount
        * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
        * @param {string} [params.timeInForce] 'GTC', 'IOC', 'FOK' or 'PO' (default 'GTC')
        * @param {string} [params.clientOrderId] a unique id for the order (max length 40)
        * @returns {object} request to be sent to the exchange
        */
        parameters ??= new Dictionary<string, object>();
        object methodName = "createSpotOrderRequest";
        // spot market info has no presicion so we do not use it
        var methodNameparametersVariable = this.handleParamString(parameters, "methodName", methodName);
        methodName = ((IList<object>)methodNameparametersVariable)[0];
        parameters = ((IList<object>)methodNameparametersVariable)[1];
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", side },
            { "orderType", type },
        };
        object isMarketOrder = (isEqual(type, "market"));
        object timeInForceAndParams = this.handleTimeInForceAndPostOnly(methodName, parameters, isMarketOrder);
        parameters = getValue(timeInForceAndParams, "params");
        object timeInForce = getValue(timeInForceAndParams, "timeInForce");
        object cost = null;
        var costparametersVariable = this.handleParamString(parameters, "cost");
        cost = ((IList<object>)costparametersVariable)[0];
        parameters = ((IList<object>)costparametersVariable)[1];
        object triggerPrice = null;
        var triggerPriceparametersVariable = this.handleParamString(parameters, "triggerPrice");
        triggerPrice = ((IList<object>)triggerPriceparametersVariable)[0];
        parameters = ((IList<object>)triggerPriceparametersVariable)[1];
        object isMarketBuy = isTrue(isMarketOrder) && isTrue((isEqual(side, "buy")));
        if (isTrue(isTrue((!isTrue(isMarketBuy))) && isTrue((!isEqual(cost, null)))))
        {
            throw new NotSupported ((string)add(add(add(this.id, " "), methodName), " supports cost parameter for market buy orders only")) ;
        }
        if (isTrue(isMarketBuy))
        {
            object costAndParams = this.handleRequiresPriceAndCost(methodName, parameters, price, amount, cost);
            cost = getValue(costAndParams, "cost");
            parameters = getValue(costAndParams, "params");
        }
        if (isTrue(isEqual(triggerPrice, null)))
        {
            if (isTrue(isEqual(type, "limit")))
            {
                ((IDictionary<string,object>)request)["price"] = price; // spot markets have no precision
            }
            ((IDictionary<string,object>)request)["quantity"] = ((bool) isTrue(isMarketBuy)) ? cost : this.numberToString(amount); // spot markets have no precision
            ((IDictionary<string,object>)request)["force"] = ((bool) isTrue(timeInForce)) ? timeInForce : "normal"; // the exchange requres force but accepts any value
        } else
        {
            ((IDictionary<string,object>)request)["triggerPrice"] = triggerPrice; // spot markets have no precision
            if (isTrue(!isEqual(timeInForce, null)))
            {
                ((IDictionary<string,object>)request)["timeInForceValue"] = timeInForce;
            }
            object clientOrderId = null;
            var clientOrderIdparametersVariable = this.handleParamString(parameters, "clientOrderId");
            clientOrderId = ((IList<object>)clientOrderIdparametersVariable)[0];
            parameters = ((IList<object>)clientOrderIdparametersVariable)[1];
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
            }
            if (isTrue(isEqual(type, "limit")))
            {
                ((IDictionary<string,object>)request)["executePrice"] = price; // spot markets have no precision
            }
            object triggerType = null;
            if (isTrue(isMarketOrder))
            {
                triggerType = "market_price";
            } else
            {
                triggerType = "fill_price";
            }
            ((IDictionary<string,object>)request)["triggerType"] = triggerType;
            // tood check placeType
            ((IDictionary<string,object>)request)["size"] = ((bool) isTrue(isMarketOrder)) ? cost : this.numberToString(amount); // spot markets have no precision
        }
        return this.extend(request, parameters);
    }

    public virtual object handleRequiresPriceAndCost(object methodName, object parameters = null, object price = null, object amount = null, object cost = null, object side = null)
    {
        parameters ??= new Dictionary<string, object>();
        side ??= "buy";
        object optionName = add(add("createMarket", this.capitalize(side)), "OrderRequiresPrice");
        object requiresPrice = true;
        var requiresPriceparametersVariable = this.handleOptionAndParams(parameters, methodName, optionName, true);
        requiresPrice = ((IList<object>)requiresPriceparametersVariable)[0];
        parameters = ((IList<object>)requiresPriceparametersVariable)[1];
        object amountString = null;
        if (isTrue(!isEqual(amount, null)))
        {
            amountString = this.numberToString(amount);
        }
        object priceString = null;
        if (isTrue(!isEqual(price, null)))
        {
            priceString = this.numberToString(price);
        }
        if (isTrue(requiresPrice))
        {
            if (isTrue(isTrue((isEqual(price, null))) && isTrue((isEqual(cost, null)))))
            {
                throw new InvalidOrder ((string)add(add(add(add(add(add(add(this.id, " "), methodName), "() requires the price argument for market "), side), " orders to calculate the total cost to spend (amount * price), alternatively set the "), optionName), " option or param to false and pass the cost to spend in the amount argument")) ;
            } else if (isTrue(isEqual(cost, null)))
            {
                cost = Precise.stringMul(amountString, priceString);
            }
        } else
        {
            cost = ((bool) isTrue(cost)) ? cost : amountString;
        }
        object result = new Dictionary<string, object>() {
            { "cost", cost },
            { "params", parameters },
        };
        return result;
    }

    public virtual object handleTimeInForceAndPostOnly(object methodName, object parameters = null, object isMarketOrder = null)
    {
        parameters ??= new Dictionary<string, object>();
        isMarketOrder ??= false;
        object timeInForce = null;
        var timeInForceparametersVariable = this.handleOptionAndParams(parameters, methodName, "timeInForce");
        timeInForce = ((IList<object>)timeInForceparametersVariable)[0];
        parameters = ((IList<object>)timeInForceparametersVariable)[1];
        object postOnly = false;
        var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, isEqual(timeInForce, "post_only"), parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        if (isTrue(postOnly))
        {
            timeInForce = "PO";
        }
        timeInForce = this.encodeTimeInForce(timeInForce);
        object result = new Dictionary<string, object>() {
            { "timeInForce", timeInForce },
            { "params", parameters },
        };
        return result;
    }

    /**
     * @method
     * @name coincatch#createSwapOrder
     * @description create a trade order on swap market
     * @see https://coincatch.github.io/github.io/en/mix/#place-order
     * @see https://coincatch.github.io/github.io/en/mix/#place-plan-order
     * @see https://coincatch.github.io/github.io/en/mix/#place-stop-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of you want to trade in units of the base currency
     * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.postOnly] *non-trigger orders only* if true, the order will only be posted to the order book and not executed immediately
     * @param {bool} [params.reduceOnly] true or false whether the order is reduce only
     * @param {string} [params.timeInForce] *non-trigger orders only* 'GTC', 'FOK', 'IOC' or 'PO'
     * @param {string} [params.clientOrderId] a unique id for the order
     * @param {float} [params.triggerPrice] the price that the order is to be triggered at
     * @param {float} [params.stopLossPrice] The price at which a stop loss order is triggered at
     * @param {float} [params.takeProfitPrice] The price at which a take profit order is triggered at
     * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
     * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
     * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
     * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> createSwapOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["methodName"] = this.safeString(parameters, "methodName", "createSwapOrder");
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = this.createSwapOrderRequest(symbol, type, side, amount, price, parameters);
        object endpointType = this.safeString(request, "endpointType");
        request = this.omit(request, "endpointType");
        object response = null;
        if (isTrue(isEqual(endpointType, "trigger")))
        {
            response = await this.privatePostApiMixV1PlanPlacePlan(request);
        } else if (isTrue(isEqual(endpointType, "tpsl")))
        {
            response = await this.privatePostApiMixV1PlanPlaceTPSL(request);
        } else
        {
            response = await this.privatePostApiMixV1OrderPlaceOrder(request);
        }
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1727977301979,
        //         "data":
        //         {
        //             "clientOid": "1225791137701519360",
        //             "orderId": "1225791137697325056"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public virtual object createSwapOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @ignore
        * @name coincatch#createSwapOrderRequest
        * @description helper function to build request
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of you want to trade in units of the base currency
        * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {bool} [params.hedged] default false
        * @param {bool} [params.postOnly] *non-trigger orders only* if true, the order will only be posted to the order book and not executed immediately
        * @param {bool} [params.reduceOnly] true or false whether the order is reduce only
        * @param {string} [params.timeInForce] *non-trigger orders only* 'GTC', 'FOK', 'IOC' or 'PO'
        * @param {string} [params.clientOrderId] a unique id for the order
        * @param {float} [params.triggerPrice] the price that the order is to be triggered at
        * @param {float} [params.stopLossPrice] The price at which a stop loss order is triggered at
        * @param {float} [params.takeProfitPrice] The price at which a take profit order is triggered at
        * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
        * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
        * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
        * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
        * @returns {object} request to be sent to the exchange
        */
        parameters ??= new Dictionary<string, object>();
        object methodName = "createSwapOrderRequest";
        var methodNameparametersVariable = this.handleParamString(parameters, "methodName", methodName);
        methodName = ((IList<object>)methodNameparametersVariable)[0];
        parameters = ((IList<object>)methodNameparametersVariable)[1];
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
            { "size", this.amountToPrecision(symbol, amount) },
        };
        var requestparametersVariable = this.handleOptionParamsAndRequest(parameters, methodName, "clientOrderId", request, "clientOid");
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object isMarketOrder = (isEqual(type, "market"));
        parameters = this.handleTriggerStopLossAndTakeProfit(symbol, side, type, price, methodName, parameters);
        object endpointType = this.safeString(parameters, "endpointType");
        if (isTrue(isTrue((isEqual(endpointType, null))) || isTrue((isEqual(endpointType, "standard")))))
        {
            object timeInForceAndParams = this.handleTimeInForceAndPostOnly(methodName, parameters, isMarketOrder); // only for non-trigger orders
            parameters = getValue(timeInForceAndParams, "params");
            object timeInForce = getValue(timeInForceAndParams, "timeInForce");
            if (isTrue(!isEqual(timeInForce, null)))
            {
                ((IDictionary<string,object>)request)["timeInForceValue"] = timeInForce;
            }
            if (isTrue(!isEqual(price, null)))
            {
                ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            }
        }
        if (isTrue((!isEqual(endpointType, "tpsl"))))
        {
            ((IDictionary<string,object>)request)["orderType"] = type;
            object hedged = false;
            var hedgedparametersVariable = this.handleOptionAndParams(parameters, methodName, "hedged", hedged);
            hedged = ((IList<object>)hedgedparametersVariable)[0];
            parameters = ((IList<object>)hedgedparametersVariable)[1];
            // hedged and non-hedged orders have different side values and reduceOnly handling
            object reduceOnly = false;
            var reduceOnlyparametersVariable = this.handleParamBool(parameters, "reduceOnly", reduceOnly);
            reduceOnly = ((IList<object>)reduceOnlyparametersVariable)[0];
            parameters = ((IList<object>)reduceOnlyparametersVariable)[1];
            if (isTrue(hedged))
            {
                if (isTrue(reduceOnly))
                {
                    if (isTrue(isEqual(side, "buy")))
                    {
                        side = "close_short";
                    } else if (isTrue(isEqual(side, "sell")))
                    {
                        side = "close_long";
                    }
                } else
                {
                    if (isTrue(isEqual(side, "buy")))
                    {
                        side = "open_long";
                    } else if (isTrue(isEqual(side, "sell")))
                    {
                        side = "open_short";
                    }
                }
            } else
            {
                side = add(((string)side).ToLower(), "_single");
            }
            ((IDictionary<string,object>)request)["side"] = side;
        }
        return this.extend(request, parameters);
    }

    public virtual object handleTriggerStopLossAndTakeProfit(object symbol, object side, object type, object price, object methodName = null, object parameters = null)
    {
        methodName ??= "createOrder";
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        object endpointType = "standard"; // standard, trigger, tpsl, trailing - to define the endpoint to use
        object stopLossPrice = this.safeString(parameters, "stopLossPrice");
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        object requestTriggerPrice = null;
        object takeProfitParams = this.safeDict(parameters, "takeProfit");
        object stopLossParams = this.safeDict(parameters, "stopLoss");
        object triggerPrice = this.safeString2(parameters, "triggerPrice", "stopPrice");
        object isTrigger = (!isEqual(triggerPrice, null));
        object trailingPercent = this.safeString(parameters, "trailingPercent");
        object trailingTriggerPrice = this.safeString(parameters, "trailingTriggerPrice");
        object hasTPPrice = (!isEqual(takeProfitPrice, null));
        object hasSLPrice = (!isEqual(stopLossPrice, null));
        object hasTPParams = (!isEqual(takeProfitParams, null));
        if (isTrue(isTrue(hasTPParams) && !isTrue(hasTPPrice)))
        {
            takeProfitPrice = this.safeString(takeProfitParams, "triggerPrice");
            hasTPPrice = (!isEqual(takeProfitPrice, null));
        }
        object hasSLParams = (!isEqual(stopLossParams, null));
        if (isTrue(isTrue(hasSLParams) && !isTrue(hasSLPrice)))
        {
            stopLossPrice = this.safeString(stopLossParams, "triggerPrice");
            hasSLPrice = (!isEqual(stopLossPrice, null));
        }
        object hasBothTPAndSL = isTrue(hasTPPrice) && isTrue(hasSLPrice);
        object isTrailingPercentOrder = (!isEqual(trailingPercent, null));
        object isMarketOrder = (isEqual(type, "market"));
        // handle with triggerPrice stopLossPrice and takeProfitPrice
        if (isTrue(isTrue(isTrue(hasBothTPAndSL) || isTrue(isTrigger)) || isTrue((isEqual(methodName, "createOrderWithTakeProfitAndStopLoss")))))
        {
            if (isTrue(isTrigger))
            {
                if (isTrue(isMarketOrder))
                {
                    ((IDictionary<string,object>)request)["triggerType"] = "market_price";
                } else
                {
                    ((IDictionary<string,object>)request)["triggerType"] = "fill_price";
                    ((IDictionary<string,object>)request)["executePrice"] = this.priceToPrecision(symbol, price);
                }
                ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
                endpointType = "trigger"; // if order also has triggerPrice we use endpoint for trigger orders
            }
            if (isTrue(isEqual(methodName, "createOrders")))
            {
                endpointType = null; // we do not provide endpointType for createOrders
            }
            if (isTrue(hasTPPrice))
            {
                ((IDictionary<string,object>)request)["presetTakeProfitPrice"] = takeProfitPrice;
            }
            if (isTrue(hasSLPrice))
            {
                ((IDictionary<string,object>)request)["presetStopLossPrice"] = stopLossPrice;
            }
        } else if (isTrue(isTrue(isTrue(hasTPPrice) || isTrue(hasSLPrice)) || isTrue(isTrailingPercentOrder)))
        {
            if (!isTrue(isMarketOrder))
            {
                throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() supports does not support "), type), " type of stop loss and take profit orders (only market type is supported for stop loss and take profit orders). To create a market order with stop loss or take profit attached use createOrderWithTakeProfitAndStopLoss()")) ;
            }
            endpointType = "tpsl"; // if order has only one of the two we use endpoint for tpsl orders
            object holdSide = "long";
            if (isTrue(isEqual(side, "buy")))
            {
                holdSide = "short";
            }
            ((IDictionary<string,object>)request)["holdSide"] = holdSide;
            if (isTrue(isTrailingPercentOrder))
            {
                if (isTrue(isEqual(trailingTriggerPrice, null)))
                {
                    throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires the trailingTriggerPrice parameter for trailing stop orders")) ;
                }
                requestTriggerPrice = trailingTriggerPrice;
                ((IDictionary<string,object>)request)["rangeRate"] = trailingPercent;
                ((IDictionary<string,object>)request)["planType"] = "moving_plan";
            } else if (isTrue(hasTPPrice))
            {
                requestTriggerPrice = takeProfitPrice;
                ((IDictionary<string,object>)request)["planType"] = "profit_plan";
            } else
            {
                requestTriggerPrice = stopLossPrice;
                ((IDictionary<string,object>)request)["planType"] = "loss_plan";
            }
            ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, requestTriggerPrice);
        }
        if (isTrue(!isEqual(endpointType, null)))
        {
            ((IDictionary<string,object>)request)["endpointType"] = endpointType;
        }
        parameters = this.omit(parameters, new List<object>() {"stopLoss", "takeProfit", "stopLossPrice", "takeProfitPrice", "triggerPrice", "stopPrice", "trailingPercent", "trailingTriggerPrice"});
        return this.extend(request, parameters);
    }

    /**
     * @method
     * @name coincatch#createOrderWithTakeProfitAndStopLoss
     * @description *swap markets only* create an order with a stop loss or take profit attached (type 3)
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
     * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
     * @param {float} [takeProfit] the take profit price, in units of the quote currency
     * @param {float} [stopLoss] the stop loss price, in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrderWithTakeProfitAndStopLoss(object symbol, object type, object side, object amount, object price = null, object takeProfit = null, object stopLoss = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "createOrderWithTakeProfitAndStopLoss";
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " "), methodName), "() is supported for swap markets only")) ;
        }
        ((IDictionary<string,object>)parameters)["methodName"] = methodName;
        return base.createOrderWithTakeProfitAndStopLoss(symbol, type, side, amount, price, takeProfit, stopLoss, parameters);
    }

    public virtual object encodeTimeInForce(object timeInForce)
    {
        object timeInForceMap = new Dictionary<string, object>() {
            { "GTC", "normal" },
            { "IOC", "iok" },
            { "FOK", "fok" },
            { "PO", "post_only" },
        };
        return this.safeString(timeInForceMap, timeInForce, timeInForce);
    }

    /**
     * @method
     * @name coincatch#createOrders
     * @description create a list of trade orders (all orders should be of the same symbol)
     * @see https://hashkeyglobal-apidoc.readme.io/reference/create-multiple-orders
     * @see https://hashkeyglobal-apidoc.readme.io/reference/batch-create-new-futures-order
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params (max 50 entries)
     * @param {object} [params] extra parameters specific to the api endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        // same symbol for all orders
        object methodName = "createOrders";
        ((IDictionary<string,object>)parameters)["methodName"] = methodName;
        object ordersRequests = new List<object>() {};
        object symbols = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object symbol = this.safeString(rawOrder, "symbol");
            ((IList<object>)symbols).Add(symbol);
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeNumber(rawOrder, "amount");
            object price = this.safeNumber(rawOrder, "price");
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object orderRequest = this.createOrderRequest(symbol, type, side, amount, price, orderParams);
            object triggerPrice = this.safeString(orderParams, "triggerPrice");
            if (isTrue(!isEqual(triggerPrice, null)))
            {
                throw new NotSupported ((string)add(add(add(this.id, " "), methodName), "() does not support trigger orders")) ;
            }
            object clientOrderId = this.safeString(orderRequest, "clientOrderId");
            if (isTrue(isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)orderRequest)["clientOrderId"] = this.uuid(); // both spot and swap endpoints require clientOrderId
            }
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        symbols = this.unique(symbols);
        object symbolsLength = getArrayLength(symbols);
        if (isTrue(!isEqual(symbolsLength, 1)))
        {
            throw new BadRequest ((string)add(this.id, " createOrders() requires all orders to be of the same symbol")) ;
        }
        object ordersSymbol = this.safeString(symbols, 0);
        object market = this.market(ordersSymbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object marketType = getValue(market, "type");
        object response = null;
        object responseOrders = null;
        object propertyName = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            ((IDictionary<string,object>)request)["orderList"] = ordersRequests;
            response = await this.privatePostApiSpotV1TradeBatchOrders(this.extend(request, parameters));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1726160718706,
            //         "data": {
            //             "resultList": [
            //                 {
            //                     "orderId": "1218171835238367232",
            //                     "clientOrderId": "28759338-ca10-42dd-8ac3-5183785ef60b"
            //                 }
            //             ],
            //             "failure": [
            //                 {
            //                     "orderId": "",
            //                     "clientOrderId": "ee2e67c9-47fc-4311-9cc1-737ec408d509",
            //                     "errorMsg": "The order price of eth_usdt cannot be less than 5.00% of the current price",
            //                     "errorCode": "43008"
            //                 },
            //                 {
            //                     "orderId": "",
            //                     "clientOrderId": "1af2defa-0c2d-4bb5-acb7-6feb6a86787a",
            //                     "errorMsg": "less than the minimum amount 1 USDT",
            //                     "errorCode": "45110"
            //                 }
            //             ]
            //         }
            //     }
            //
            propertyName = "resultList";
        } else if (isTrue(getValue(market, "swap")))
        {
            ((IDictionary<string,object>)request)["marginCoin"] = getValue(market, "settleId");
            ((IDictionary<string,object>)request)["orderDataList"] = ordersRequests;
            response = await this.privatePostApiMixV1OrderBatchOrders(this.extend(request, parameters));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1729100084017,
            //         "data": {
            //             "orderInfo": [
            //                 {
            //                     "orderId": "1230500426827522049",
            //                     "clientOid": "1230500426898825216"
            //                 }
            //             ],
            //             "failure": [
            //                 {
            //                     "orderId": "",
            //                     "clientOid": null,
            //                     "errorMsg": "The order price exceeds the maximum price limit: 2,642.53",
            //                     "errorCode": "22047"
            //                 }
            //             ],
            //             "result": true
            //         }
            //     }
            //
            propertyName = "orderInfo";
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), marketType), " type of markets")) ;
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        responseOrders = this.safeList(data, propertyName, new List<object>() {});
        return this.parseOrders(responseOrders);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = this.safeString(parameters, "methodName", "createOrderRequest");
        ((IDictionary<string,object>)parameters)["methodName"] = methodName;
        object market = this.market(symbol);
        if (isTrue(getValue(market, "spot")))
        {
            return this.createSpotOrderRequest(symbol, type, side, amount, price, parameters);
        } else if (isTrue(getValue(market, "swap")))
        {
            return this.createSwapOrderRequest(symbol, type, side, amount, price, parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), getValue(market, "type")), " type of markets")) ;
        }
    }

    /**
     * @method
     * @name coincatch#editOrder
     * @description edit a trade trigger, stop-looss or take-profit order
     * @see https://coincatch.github.io/github.io/en/spot/#modify-plan-order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "editOrder";
        // only trigger, stop-looss or take-profit orders can be edited
        ((IDictionary<string,object>)parameters)["methodName"] = methodName;
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(getValue(market, "spot")))
        {
            return await this.editSpotOrder(id, symbol, type, side, amount, price, parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), getValue(market, "type")), " type of markets")) ;
        }
    }

    /**
     * @method
     * @name coincatch#editSpotOrder
     * @ignore
     * @description edit a trade order
     * @see https://coincatch.github.io/github.io/en/spot/#modify-plan-order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] a unique id for the order that can be used as an alternative for the id
     * @param {string} params.triggerPrice *mandatory* the price that the order is to be triggered at
     * @param {float} [params.cost] *market buy only* the quote quantity that can be used as an alternative for the amount
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> editSpotOrder(object id, object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object methodName = "editSpotOrder";
        var methodNameparametersVariable = this.handleParamString(parameters, "methodName", methodName);
        methodName = ((IList<object>)methodNameparametersVariable)[0];
        parameters = ((IList<object>)methodNameparametersVariable)[1];
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " editSpotOrder() does not support "), getValue(market, "type")), " orders")) ;
        }
        object request = new Dictionary<string, object>() {
            { "orderType", type },
        };
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
        } else if (isTrue(isEqual(id, null)))
        {
            throw new BadRequest ((string)add(add(add(this.id, " "), methodName), "() requires id or clientOrderId")) ;
        } else
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        object cost = null;
        var costparametersVariable = this.handleParamString(parameters, "cost");
        cost = ((IList<object>)costparametersVariable)[0];
        parameters = ((IList<object>)costparametersVariable)[1];
        object isMarketBuy = isTrue((isEqual(type, "market"))) && isTrue((isEqual(side, "buy")));
        if (isTrue(isTrue((!isTrue(isMarketBuy))) && isTrue((!isEqual(cost, null)))))
        {
            throw new NotSupported ((string)add(add(add(this.id, " "), methodName), "() supports cost parameter for market buy orders only")) ;
        }
        if (isTrue(!isEqual(amount, null)))
        {
            if (isTrue(isMarketBuy))
            {
                object costAndParams = this.handleRequiresPriceAndCost(methodName, parameters, price, amount, cost);
                cost = getValue(costAndParams, "cost");
                parameters = getValue(costAndParams, "params");
            } else
            {
                ((IDictionary<string,object>)request)["size"] = this.numberToString(amount); // spot markets have no precision
            }
        }
        if (isTrue(!isEqual(cost, null)))
        {
            ((IDictionary<string,object>)request)["size"] = cost; // spot markets have no precision
        }
        if (isTrue(isTrue((isEqual(type, "limit"))) && isTrue((!isEqual(price, null)))))
        {
            ((IDictionary<string,object>)request)["price"] = price; // spot markets have no precision
        }
        object response = await this.privatePostApiSpotV1PlanModifyPlan(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1668136575920,
        //         "data": {
        //             "orderId": "974792060738441216",
        //             "clientOrderId": "974792554995224576"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    /**
     * @method
     * @name coincatch#fetchOrder
     * @description fetches information on an order made by the user (non-trigger orders only)
     * @see https://coincatch.github.io/github.io/en/spot/#get-order-details
     * @see https://coincatch.github.io/github.io/en/mix/#get-order-details
     * @param {string} id the order id
     * @param {string} symbol unified symbol of the market the order was made in (is mandatory for swap)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch entry for (default 'spot')
     * @param {string} [params.clientOrderId] a unique id for the order that can be used as an alternative for the id
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchOrder";
        // for non-trigger orders only
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = "spot";
        var marketTypeparametersVariable = this.handleMarketTypeAndParams(methodName, market, parameters, marketType);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object response = null;
        object order = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            // user could query cancelled/filled order details within 24 hours, After 24 hours should use fetchOrders
            response = await this.privatePostApiSpotV1TradeOrderInfo(this.extend(request, parameters));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1725918004434,
            //         "data": [
            //             {
            //                 "accountId": "1002820815393",
            //                 "symbol": "ETHUSDT_SPBL",
            //                 "orderId": "1217143186968068096",
            //                 "clientOrderId": "8fa3eb89-2377-4519-a199-35d5db9ed262",
            //                 "price": "0",
            //                 "quantity": "10.0000000000000000",
            //                 "orderType": "market",
            //                 "side": "buy",
            //                 "status": "full_fill",
            //                 "fillPrice": "2340.5500000000000000",
            //                 "fillQuantity": "0.0042000000000000",
            //                 "fillTotalAmount": "9.8303100000000000",
            //                 "enterPointSource": "API",
            //                 "feeDetail": "{
            //                     \"ETH\": {
            //                         \"deduction\": false,
            //                         \"feeCoinCode\": \"ETH\",
            //                         \"totalDeductionFee\": 0,
            //                         \"totalFee\": -0.0000042000000000},
            //                         \"newFees\": {
            //                         \"c\": 0,
            //                         \"d\": 0,
            //                         \"deduction\": false,
            //                         \"r\": -0.0000042,
            //                         \"t\": -0.0000042,
            //                         \"totalDeductionFee\": 0
            //                     }
            //                 }",
            //                 "orderSource": "market",
            //                 "cTime": "1725915469877"
            //             }
            //         ]
            //     }
            //
            object data = this.safeList(response, "data");
            if (isTrue(isEqual(data, null)))
            {
                response = parseJson(response); // the response from closed orders is not a standard JSON
                data = this.safeList(response, "data", new List<object>() {});
            }
            order = this.safeDict(data, 0, new Dictionary<string, object>() {});
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            if (isTrue(isEqual(market, null)))
            {
                throw new ArgumentsRequired ((string)add(add(add(add(add(this.id, " "), methodName), "() requires a symbol argument for "), marketType), " type of markets")) ;
            }
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                parameters = this.omit(parameters, "clientOrderId");
                ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
            }
            response = await this.privateGetApiMixV1OrderDetail(this.extend(request, parameters));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1727981421364,
            //         "data": {
            //             "symbol": "ETHUSDT_UMCBL",
            //             "size": 0.01,
            //             "orderId": "1225791137697325056",
            //             "clientOid": "1225791137701519360",
            //             "filledQty": 0.01,
            //             "fee": -0.01398864,
            //             "price": null,
            //             "priceAvg": 2331.44,
            //             "state": "filled",
            //             "side": "close_long",
            //             "timeInForce": "normal",
            //             "totalProfits": -2.23680000,
            //             "posSide": "long",
            //             "marginCoin": "USDT",
            //             "filledAmount": 23.3144,
            //             "orderType": "market",
            //             "leverage": "5",
            //             "marginMode": "crossed",
            //             "reduceOnly": true,
            //             "enterPointSource": "API",
            //             "tradeSide": "close_long",
            //             "holdMode": "double_hold",
            //             "orderSource": "market",
            //             "cTime": "1727977302003",
            //             "uTime": "1727977303604"
            //         }
            //     }
            //
            order = this.safeDict(response, "data", new Dictionary<string, object>() {});
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), marketType), " type of markets")) ;
        }
        return this.parseOrder(order, market);
    }

    /**
     * @method
     * @name coincatch#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://coincatch.github.io/github.io/en/spot/#get-order-list
     * @see https://coincatch.github.io/github.io/en/spot/#get-current-plan-orders
     * @see https://coincatch.github.io/github.io/en/mix/#get-open-order
     * @see https://coincatch.github.io/github.io/en/mix/#get-all-open-order
     * @see https://coincatch.github.io/github.io/en/mix/#get-plan-order-tpsl-list
     * @param {string} [symbol] unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.trigger] true if fetching trigger orders (default false)
     * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch entries for (default 'spot')
     * @param {string} [params.productType] *swap only* 'umcbl' or 'dmcbl' - the product type of the market to fetch entries for (default 'umcbl')
     * @param {string} [params.marginCoin] *swap only* the margin coin of the market to fetch entries for
     * @param {string} [params.isPlan] *swap trigger only* 'plan' or 'profit_loss' ('plan' (default) for trigger (plan) orders, 'profit_loss' for stop-loss and take-profit orders)
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchOpenOrders";
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = "spot";
        var marketTypeparametersVariable = this.handleMarketTypeAndParams(methodName, market, parameters, marketType);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        ((IDictionary<string,object>)parameters)["methodName"] = methodName;
        if (isTrue(isEqual(marketType, "spot")))
        {
            return await this.fetchOpenSpotOrders(symbol, since, limit, parameters);
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            return await this.fetchOpenSwapOrders(symbol, since, limit, parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), marketType), " type of markets")) ;
        }
    }

    /**
     * @method
     * @ignore
     * @name coincatch#fetchOpenSpotOrders
     * @description fetch all unfilled currently open orders for spot markets
     * @see https://coincatch.github.io/github.io/en/spot/#get-order-list
     * @see https://coincatch.github.io/github.io/en/spot/#get-current-plan-orders
     * @param {string} [symbol] unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.trigger] true if fetching trigger orders (default false)
     * @param {string} [params.lastEndId] *for trigger orders only* the last order id to fetch entries after
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchOpenSpotOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object methodName = "fetchOpenSpotOrders";
        var methodNameparametersVariable = this.handleParamString(parameters, "methodName", methodName);
        methodName = ((IList<object>)methodNameparametersVariable)[0];
        parameters = ((IList<object>)methodNameparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object isTrigger = false;
        var isTriggerparametersVariable = this.handleOptionAndParams2(parameters, methodName, "trigger", "stop", isTrigger);
        isTrigger = ((IList<object>)isTriggerparametersVariable)[0];
        parameters = ((IList<object>)isTriggerparametersVariable)[1];
        object result = null;
        if (isTrue(isTrigger))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a symbol argument for trigger orders")) ;
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["pageSize"] = limit;
            }
            object response = await this.privatePostApiSpotV1PlanCurrentPlan(this.extend(request, parameters));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1728664710749,
            //         "data": {
            //             "nextFlag": false,
            //             "endId": 1228661660806787072,
            //             "orderList": [
            //                 {
            //                     "orderId": "1228669617606991872",
            //                     "clientOid": "1228669617573437440",
            //                     "symbol": "ETHUSDT_SPBL",
            //                     "size": "50",
            //                     "executePrice": "0",
            //                     "triggerPrice": "4000",
            //                     "status": "not_trigger",
            //                     "orderType": "market",
            //                     "side": "sell",
            //                     "triggerType": "fill_price",
            //                     "enterPointSource": "API",
            //                     "placeType": null,
            //                     "cTime": "1728663585092",
            //                     "uTime": null
            //                 },
            //             ]
            //         }
            //     }
            //
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            result = this.safeList(data, "orderList", new List<object>() {});
        } else
        {
            object response = await this.privatePostApiSpotV1TradeOpenOrders(this.extend(request, parameters));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1725965783430,
            //         "data": [
            //             {
            //                 "accountId": "1002820815393",
            //                 "symbol": "ETHUSDT_SPBL",
            //                 "orderId": "1217347655911653376",
            //                 "clientOrderId": "c57c07d1-bd00-4167-95e2-9b22a55fbc28",
            //                 "price": "2000.0000000000000000",
            //                 "quantity": "0.0010000000000000",
            //                 "orderType": "limit",
            //                 "side": "buy",
            //                 "status": "new",
            //                 "fillPrice": "0",
            //                 "fillQuantity": "0.0000000000000000",
            //                 "fillTotalAmount": "0.0000000000000000",
            //                 "enterPointSource": "API",
            //                 "feeDetail": "",
            //                 "orderSource": "normal",
            //                 "cTime": "1725964219072"
            //             },
            //             ...
            //         ]
            //     }
            //
            result = this.safeList(response, "data", new List<object>() {});
        }
        return this.parseOrders(result, market, since, limit);
    }

    /**
     * @method
     * @ignore
     * @name coincatch#fetchOpenSwapOrders
     * @description fetch all unfilled currently open orders for swap markets
     * @see https://coincatch.github.io/github.io/en/mix/#get-open-order
     * @see https://coincatch.github.io/github.io/en/mix/#get-all-open-order
     * @see https://coincatch.github.io/github.io/en/mix/#get-plan-order-tpsl-list
     * @param {string} [symbol] unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.trigger] true if fetching trigger orders (default false)
     * @param {string} [params.isPlan] 'plan' or 'profit_loss' ('plan' (default) for trigger (plan) orders, 'profit_loss' for stop-loss and take-profit orders)
     * @param {string} [params.productType] 'umcbl' or 'dmcbl' - the product type of the market to fetch entries for (default 'umcbl')
     * @param {string} [params.marginCoin] the margin coin of the market to fetch entries for
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchOpenSwapOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object methodName = "fetchOpenSwapOrders";
        var methodNameparametersVariable = this.handleParamString(parameters, "methodName", methodName);
        methodName = ((IList<object>)methodNameparametersVariable)[0];
        parameters = ((IList<object>)methodNameparametersVariable)[1];
        object isTrigger = false;
        var isTriggerparametersVariable = this.handleOptionAndParams2(parameters, methodName, "trigger", "stop", isTrigger);
        isTrigger = ((IList<object>)isTriggerparametersVariable)[0];
        parameters = ((IList<object>)isTriggerparametersVariable)[1];
        object plan = null;
        var planparametersVariable = this.handleOptionAndParams(parameters, methodName, "isPlan", plan);
        plan = ((IList<object>)planparametersVariable)[0];
        parameters = ((IList<object>)planparametersVariable)[1];
        object productType = this.handleOption(methodName, "productType");
        object market = null;
        object response = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            object request = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
            };
            if (isTrue(isTrue((isTrigger)) || isTrue((!isEqual(plan, null)))))
            {
                if (isTrue(!isEqual(productType, null)))
                {
                    ((IDictionary<string,object>)request)["productType"] = productType;
                }
                if (isTrue(!isEqual(plan, null)))
                {
                    ((IDictionary<string,object>)request)["isPlan"] = plan; // current param is used to define the type of the orders to fetch (trigger or stop-loss/take-profit)
                }
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1729168682690,
                //         "data": [
                //             {
                //                 "orderId": "1230779428914049025",
                //                 "clientOid": "1230779428914049024",
                //                 "symbol": "ETHUSDT_UMCBL",
                //                 "marginCoin": "USDT",
                //                 "size": "0.01",
                //                 "executePrice": "1000",
                //                 "triggerPrice": "1200",
                //                 "status": "not_trigger",
                //                 "orderType": "limit",
                //                 "planType": "normal_plan",
                //                 "side": "buy_single",
                //                 "triggerType": "fill_price",
                //                 "presetTakeProfitPrice": "4000",
                //                 "presetTakeLossPrice": "900",
                //                 "rangeRate": "",
                //                 "enterPointSource": "API",
                //                 "tradeSide": "buy_single",
                //                 "holdMode": "single_hold",
                //                 "reduceOnly": false,
                //                 "cTime": "1729166603306",
                //                 "uTime": null
                //             }
                //         ]
                //     }
                //
                response = await this.privateGetApiMixV1PlanCurrentPlan(this.extend(request, parameters));
            } else
            {
                response = await this.privateGetApiMixV1OrderCurrent(this.extend(request, parameters));
            }
        } else if (isTrue(isTrigger))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a symbol argument for swap trigger orders")) ;
        } else
        {
            if (isTrue(isEqual(productType, null)))
            {
                productType = "umcbl";
            }
            object request = new Dictionary<string, object>() {
                { "productType", productType },
            };
            object marginCoin = null;
            marginCoin = this.handleOption(methodName, "marginCoin", marginCoin);
            if (isTrue(!isEqual(marginCoin, null)))
            {
                ((IDictionary<string,object>)request)["marginCoin"] = marginCoin;
            }
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1728127869097,
            //         "data": [
            //             {
            //                 "symbol": "ETHUSDT_UMCBL",
            //                 "size": 0.02,
            //                 "orderId": "1226422495431974913",
            //                 "clientOid": "1226422495457140736",
            //                 "filledQty": 0.00,
            //                 "fee": 0E-8,
            //                 "price": 500.00,
            //                 "state": "new",
            //                 "side": "buy_single",
            //                 "timeInForce": "normal",
            //                 "totalProfits": 0E-8,
            //                 "posSide": "long",
            //                 "marginCoin": "USDT",
            //                 "filledAmount": 0.0000,
            //                 "orderType": "limit",
            //                 "leverage": "5",
            //                 "marginMode": "crossed",
            //                 "reduceOnly": false,
            //                 "enterPointSource": "API",
            //                 "tradeSide": "buy_single",
            //                 "holdMode": "single_hold",
            //                 "orderSource": "normal",
            //                 "cTime": "1728127829422",
            //                 "uTime": "1728127830980"
            //             }
            //         ]
            //     }
            //
            response = await this.privateGetApiMixV1OrderMarginCoinCurrent(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    /**
     * @method
     * @name coincatch#fetchCanceledAndClosedOrders
     * @description fetches information on multiple canceled and closed orders made by the user
     * @see https://coincatch.github.io/github.io/en/spot/#get-order-list
     * @see https://coincatch.github.io/github.io/en/spot/#get-history-plan-orders
     * @see https://coincatch.github.io/github.io/en/mix/#get-history-orders
     * @see https://coincatch.github.io/github.io/en/mix/#get-producttype-history-orders
     * @see https://coincatch.github.io/github.io/en/mix/#get-history-plan-orders-tpsl
     * @param {string} symbol *is mandatory* unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @param {boolean} [params.trigger] true if fetching trigger orders (default false)
     * @param {string} [params.isPlan] *swap only* 'plan' or 'profit_loss' ('plan' (default) for trigger (plan) orders, 'profit_loss' for stop-loss and take-profit orders)
     * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch entries for (default 'spot')
     * @param {string} [params.productType] *swap only* 'umcbl' or 'dmcbl' - the product type of the market to fetch entries for (default 'umcbl')
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchCanceledAndClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchCanceledAndClosedOrders";
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = "spot";
        var marketTypeparametersVariable = this.handleMarketTypeAndParams(methodName, market, parameters, marketType);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        ((IDictionary<string,object>)parameters)["methodName"] = methodName;
        if (isTrue(isEqual(marketType, "spot")))
        {
            return await this.fetchCanceledAndClosedSpotOrders(symbol, since, limit, parameters);
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            return await this.fetchCanceledAndClosedSwapOrders(symbol, since, limit, parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), marketType), " type of markets")) ;
        }
    }

    /**
     * @method
     * @ignore
     * @name coincatch#fetchCanceledAndClosedSpotOrders
     * @description fetches information on multiple canceled and closed orders made by the user on spot markets
     * @see https://coincatch.github.io/github.io/en/spot/#get-order-history
     * @see https://coincatch.github.io/github.io/en/spot/#get-history-plan-orders
     * @param {string} symbol *is mandatory* unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] *for trigger orders only* the latest time in ms to fetch orders for
     * @param {boolean} [params.trigger] true if fetching trigger orders (default false)
     * @param {string} [params.lastEndId] *for trigger orders only* the last order id to fetch entries after
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchCanceledAndClosedSpotOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchCanceledAndClosedSpotOrders";
        var methodNameparametersVariable = this.handleParamString(parameters, "methodName", methodName);
        methodName = ((IList<object>)methodNameparametersVariable)[0];
        parameters = ((IList<object>)methodNameparametersVariable)[1];
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), " () requires a symbol argument for spot markets")) ;
        }
        object maxLimit = 500;
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object requestLimit = limit;
        object isTrigger = false;
        var isTriggerparametersVariable = this.handleOptionAndParams2(parameters, methodName, "trigger", "stop", isTrigger);
        isTrigger = ((IList<object>)isTriggerparametersVariable)[0];
        parameters = ((IList<object>)isTriggerparametersVariable)[1];
        object result = null;
        if (isTrue(isTrigger))
        {
            object until = null;
            var untilparametersVariable = this.handleOptionAndParams(parameters, methodName, "until", until);
            until = ((IList<object>)untilparametersVariable)[0];
            parameters = ((IList<object>)untilparametersVariable)[1];
            // const now = this.milliseconds ();
            object requestSince = since;
            object interval = multiply(multiply(multiply(multiply(90, 24), 60), 60), 1000); // startTime and endTime interval cannot be greater than 90 days
            object now = this.milliseconds();
            // both since and until are required for trigger orders
            if (isTrue(isTrue((isEqual(until, null))) && isTrue((isEqual(requestSince, null)))))
            {
                requestSince = subtract(now, interval);
                until = now;
            } else if (isTrue(!isEqual(until, null)))
            {
                requestSince = subtract(until, interval);
            } else
            {
                until = add(since, interval);
            }
            ((IDictionary<string,object>)request)["startTime"] = requestSince;
            ((IDictionary<string,object>)request)["endTime"] = until;
            if (isTrue(isEqual(requestLimit, null)))
            {
                requestLimit = maxLimit;
            }
            ((IDictionary<string,object>)request)["pageSize"] = requestLimit;
            object response = await this.privatePostApiSpotV1PlanHistoryPlan(this.extend(request, parameters));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1728668998002,
            //         "data": {
            //             "nextFlag": false,
            //             "endId": 1228669617606991872,
            //             "orderList": [
            //                 {
            //                     "orderId": "1228669617606991872",
            //                     "clientOid": "1228669617573437440",
            //                     "symbol": "ETHUSDT_SPBL",
            //                     "size": "50",
            //                     "executePrice": "0",
            //                     "triggerPrice": "4000",
            //                     "status": "cancel",
            //                     "orderType": "market",
            //                     "side": "sell",
            //                     "triggerType": "fill_price",
            //                     "enterPointSource": "API",
            //                     "placeType": null,
            //                     "cTime": "1728663585092",
            //                     "uTime": "1728666719223"
            //                 }
            //             ]
            //         }
            //     }
            //
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            result = this.safeList(data, "orderList", new List<object>() {});
        } else
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["after"] = since;
                requestLimit = maxLimit;
            }
            if (isTrue(!isEqual(requestLimit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = requestLimit;
            }
            object response = await this.privatePostApiSpotV1TradeHistory(this.extend(request, parameters));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1725963777690,
            //         "data": [
            //             {
            //                 "accountId": "1002820815393",
            //                 "symbol": "ETHUSDT_SPBL",
            //                 "orderId": "1217143186968068096",
            //                 "clientOrderId": "8fa3eb89-2377-4519-a199-35d5db9ed262",
            //                 "price": "0",
            //                 "quantity": "10.0000000000000000",
            //                 "orderType": "market",
            //                 "side": "buy",
            //                 "status": "full_fill",
            //                 "fillPrice": "2340.5500000000000000",
            //                 "fillQuantity": "0.0042000000000000",
            //                 "fillTotalAmount": "9.8303100000000000",
            //                 "enterPointSource": "API",
            //                 "feeDetail": "{
            //                     \"ETH\": {
            //                         \"deduction\": false,
            //                         \"feeCoinCode\": \"ETH\",
            //                         \"totalDeductionFee\": 0,
            //                         \"totalFee\": -0.0000042000000000
            //                     },
            //                     \"newFees\": {
            //                         \"c\": 0,
            //                         \"d\": 0,
            //                         \"deduction\": false,
            //                         \"r\": -0.0000042,
            //                         \"t\": -0.0000042,
            //                         \"totalDeductionFee\": 0
            //                     }
            //                 }",
            //                 "orderSource": "market",
            //                 "cTime": "1725915469877"
            //             },
            //             ...
            //         ]
            //     }
            //
            object parsedResponse = parseJson(response); // the response is not a standard JSON
            result = this.safeList(parsedResponse, "data", new List<object>() {});
        }
        return this.parseOrders(result, market, since, limit);
    }

    /**
     * @method
     * @ignore
     * @name coincatch#fetchCanceledAndClosedSwapOrders
     * @description fetches information on multiple canceled and closed orders made by the user on swap markets
     * @see https://coincatch.github.io/github.io/en/mix/#get-history-orders
     * @see https://coincatch.github.io/github.io/en/mix/#get-producttype-history-orders
     * @see https://coincatch.github.io/github.io/en/mix/#get-history-plan-orders-tpsl
     * @param {string} [symbol] unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @param {boolean} [params.trigger] true if fetching trigger orders (default false)
     * @param {string} [params.isPlan] *swap only* 'plan' or 'profit_loss' ('plan' (default) for trigger (plan) orders, 'profit_loss' for stop-loss and take-profit orders)
     * @param {string} [params.productType] *swap only* 'umcbl' or 'dmcbl' - the product type of the market to fetch entries for (default 'umcbl')
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchCanceledAndClosedSwapOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchCanceledAndClosedSwapOrders";
        var methodNameparametersVariable = this.handleParamString(parameters, "methodName", methodName);
        methodName = ((IList<object>)methodNameparametersVariable)[0];
        parameters = ((IList<object>)methodNameparametersVariable)[1];
        object requestSince = since;
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, methodName, "until", until);
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        object now = this.milliseconds();
        // since and until are mandatory
        // they should be within 90 days interval
        object interval = multiply(multiply(multiply(multiply(90, 24), 60), 60), 1000);
        if (isTrue(isTrue((isEqual(until, null))) && isTrue((isEqual(requestSince, null)))))
        {
            requestSince = subtract(now, interval);
            until = now;
        } else if (isTrue(!isEqual(until, null)))
        {
            requestSince = subtract(until, interval);
        } else
        {
            until = add(since, interval);
        }
        object request = new Dictionary<string, object>() {
            { "startTime", requestSince },
            { "endTime", until },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["pageSize"] = limit;
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object productType = this.handleOption(methodName, "productType");
        object isTrigger = false;
        var isTriggerparametersVariable = this.handleOptionAndParams2(parameters, methodName, "trigger", "stop", isTrigger);
        isTrigger = ((IList<object>)isTriggerparametersVariable)[0];
        parameters = ((IList<object>)isTriggerparametersVariable)[1];
        object plan = null;
        var planparametersVariable = this.handleOptionAndParams(parameters, methodName, "isPlan", plan);
        plan = ((IList<object>)planparametersVariable)[0];
        parameters = ((IList<object>)planparametersVariable)[1];
        object response = null;
        object result = null;
        if (isTrue(isTrue((isTrigger)) || isTrue((!isEqual(plan, null)))))
        {
            if (isTrue(!isEqual(plan, null)))
            {
                ((IDictionary<string,object>)request)["isPlan"] = plan;
            }
            if (isTrue(!isEqual(productType, null)))
            {
                ((IDictionary<string,object>)request)["productType"] = productType;
            }
            response = await this.privateGetApiMixV1PlanHistoryPlan(this.extend(request, parameters));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1729174716526,
            //         "data": [
            //             {
            //                 "orderId": "1230763430987104257",
            //                 "clientOid": "1230763431003881472",
            //                 "executeOrderId": "",
            //                 "symbol": "ETHUSDT_UMCBL",
            //                 "marginCoin": "USDT",
            //                 "size": "0.03",
            //                 "executePrice": "0",
            //                 "triggerPrice": "2000",
            //                 "status": "cancel",
            //                 "orderType": "market",
            //                 "planType": "loss_plan",
            //                 "side": "sell_single",
            //                 "triggerType": "fill_price",
            //                 "presetTakeProfitPrice": "0",
            //                 "presetTakeLossPrice": "0",
            //                 "rangeRate": null,
            //                 "enterPointSource": "SYS",
            //                 "tradeSide": "sell_single",
            //                 "holdMode": "single_hold",
            //                 "reduceOnly": true,
            //                 "executeTime": "1729173770776",
            //                 "executeSize": "0",
            //                 "cTime": "1729162789103",
            //                 "uTime": "1729173770776"
            //             }
            //         ]
            //     }
            //
            result = this.safeList(response, "data", new List<object>() {});
        } else
        {
            if (isTrue(!isEqual(symbol, null)))
            {
                market = this.market(symbol);
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
                response = await this.privateGetApiMixV1OrderHistory(this.extend(request, parameters));
            } else
            {
                if (isTrue(isEqual(productType, null)))
                {
                    productType = "umcbl"; // is mandatory for current endpoint
                }
                ((IDictionary<string,object>)request)["productType"] = productType;
                response = await this.privateGetApiMixV1OrderHistoryProductType(this.extend(request, parameters));
            }
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1728129807637,
            //         "data": {
            //             "nextFlag": false,
            //             "endId": "1221413696648339457",
            //             "orderList": [
            //                 {
            //                     "symbol": "ETHUSD_DMCBL",
            //                     "size": 0.1,
            //                     "orderId": "1225467075288719360",
            //                     "clientOid": "1225467075288719361",
            //                     "filledQty": 0.1,
            //                     "fee": -0.00005996,
            //                     "price": null,
            //                     "priceAvg": 2362.03,
            //                     "state": "filled",
            //                     "side": "burst_close_long",
            //                     "timeInForce": "normal",
            //                     "totalProfits": -0.00833590,
            //                     "posSide": "long",
            //                     "marginCoin": "ETH",
            //                     "filledAmount": 236.20300000,
            //                     "orderType": "market",
            //                     "leverage": "12",
            //                     "marginMode": "fixed",
            //                     "reduceOnly": true,
            //                     "enterPointSource": "SYS",
            //                     "tradeSide": "burst_close_long",
            //                     "holdMode": "double_hold",
            //                     "orderSource": "market",
            //                     "cTime": "1727900039503",
            //                     "uTime": "1727900039576"
            //                 }
            //             ]
            //         }
            //     }
            //
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            result = this.safeList(data, "orderList", new List<object>() {});
        }
        return this.parseOrders(result, market);
    }

    /**
     * @method
     * @name coincatch#cancelOrder
     * @description cancels an open order
     * @see https://coincatch.github.io/github.io/en/spot/#cancel-order-v2
     * @see https://coincatch.github.io/github.io/en/spot/#cancel-plan-order
     * @see https://coincatch.github.io/github.io/en/mix/#cancel-order
     * @see https://coincatch.github.io/github.io/en/mix/#cancel-plan-order-tpsl
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] a unique id for the order that can be used as an alternative for the id
     * @param {bool} [params.trigger] true for canceling a trigger order (default false)
     * @param {bool} [params.stop] *swap only* an alternative for trigger param
     * @param {string} [params.planType] *swap trigger only* the type of the plan order to cancel: 'profit_plan' - profit order, 'loss_plan' - loss order, 'normal_plan' - plan order, 'pos_profit' - position profit, 'pos_loss' - position loss, 'moving_plan' - Trailing TP/SL, 'track_plan' - Trailing Stop
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "cancelOrder";
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), " () requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        object clientOrderId = null;
        var clientOrderIdparametersVariable = this.handleParamString(parameters, "clientOrderId");
        clientOrderId = ((IList<object>)clientOrderIdparametersVariable)[0];
        parameters = ((IList<object>)clientOrderIdparametersVariable)[1];
        if (isTrue(isTrue((isEqual(id, null))) && isTrue((isEqual(clientOrderId, null)))))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), " () requires an id argument or clientOrderId parameter")) ;
        }
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        object marketType = getValue(market, "type");
        object trigger = false;
        var triggerparametersVariable = this.handleOptionAndParams2(parameters, methodName, "trigger", "stop", trigger);
        trigger = ((IList<object>)triggerparametersVariable)[0];
        parameters = ((IList<object>)triggerparametersVariable)[1];
        object response = null;
        if (isTrue(!isTrue(trigger) || isTrue((!isEqual(marketType, "spot")))))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(trigger))
            {
                response = await this.privatePostApiSpotV1PlanCancelPlan(this.extend(request, parameters));
            } else
            {
                response = await this.privatePostApiSpotV1TradeCancelOrderV2(this.extend(request, parameters));
            }
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            object planType = null;
            var planTypeparametersVariable = this.handleOptionAndParams(parameters, methodName, "planType", planType);
            planType = ((IList<object>)planTypeparametersVariable)[0];
            parameters = ((IList<object>)planTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["marginCoin"] = getValue(market, "settleId");
            if (isTrue(isTrue((trigger)) || isTrue((!isEqual(planType, null)))))
            {
                if (isTrue(isEqual(planType, null)))
                {
                    throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), " () requires a planType parameter for swap trigger orders (\"profit_plan\" - profit order, \"loss_plan\" - loss order, \"normal_plan\" - plan order, \"pos_profit\" - position profit, \"pos_loss\" - position loss, \"moving_plan\" - Trailing TP/SL, \"track_plan\" - Trailing Stop)")) ;
                }
                ((IDictionary<string,object>)request)["planType"] = planType;
                response = await this.privatePostApiMixV1PlanCancelPlan(this.extend(request, parameters));
            } else
            {
                response = await this.privatePostApiMixV1OrderCancelOrder(this.extend(request, parameters));
            }
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), marketType), " type of markets")) ;
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    /**
     * @method
     * @name coincatch#cancelAllOrders
     * @description cancels all open orders
     * @see https://coincatch.github.io/github.io/en/spot/#cancel-all-orders
     * @see https://coincatch.github.io/github.io/en/spot/#batch-cancel-plan-orders
     * @see https://coincatch.github.io/github.io/en/mix/#batch-cancel-order
     * @see https://coincatch.github.io/github.io/en/mix/#cancel-order-by-symbol
     * @see https://coincatch.github.io/github.io/en/mix/#cancel-plan-order-tpsl-by-symbol
     * @see https://coincatch.github.io/github.io/en/mix/#cancel-all-trigger-order-tpsl
     * @param {string} [symbol] unified symbol of the market the orders were made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] 'spot' or 'swap' - the type of the market to cancel orders for (default 'spot')
     * @param {bool} [params.trigger] true for canceling a trigger orders (default false)
     * @param {string} [params.productType] *swap only (if symbol is not provided* 'umcbl' or 'dmcbl' - the product type of the market to cancel orders for (default 'umcbl')
     * @param {string} [params.marginCoin] *mandatory for swap non-trigger dmcb (if symbol is not provided)* the margin coin of the market to cancel orders for
     * @param {string} [params.planType] *swap trigger only* the type of the plan order to cancel: 'profit_plan' - profit order, 'loss_plan' - loss order, 'normal_plan' - plan order, 'pos_profit' - position profit, 'pos_loss' - position loss, 'moving_plan' - Trailing TP/SL, 'track_plan' - Trailing Stop
     * @returns {object} response from the exchange
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "cancelAllOrders";
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        object marketType = "spot";
        var marketTypeparametersVariable = this.handleMarketTypeAndParams(methodName, market, parameters, marketType);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object trigger = false;
        var triggerparametersVariable = this.handleOptionAndParams2(parameters, methodName, "trigger", "stop", trigger);
        trigger = ((IList<object>)triggerparametersVariable)[0];
        parameters = ((IList<object>)triggerparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(trigger))
            {
                if (isTrue(!isEqual(symbol, null)))
                {
                    ((IDictionary<string,object>)request)["symbols"] = new List<object>() {getValue(market, "id")};
                }
                response = await this.privatePostApiSpotV1PlanBatchCancelPlan(this.extend(request, parameters));
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1728670464735,
                //         "data": [
                //             {
                //                 "orderId": "1228661660806787072",
                //                 "clientOid": "1228661660752261120",
                //                 "result": true
                //             }
                //         ]
                //     }
                //
                object data = this.safeList(response, "data", new List<object>() {});
                return this.parseOrders(data, market);
            } else
            {
                if (isTrue(isEqual(symbol, null)))
                {
                    throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), " () requires a symbol argument for spot non-trigger orders")) ;
                }
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1725989560461,
                //         "data": "ETHUSDT_SPBL"
                //     }
                //
                response = await this.privatePostApiSpotV1TradeCancelSymbolOrder(this.extend(request, parameters));
            }
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            object productType = "umcbl";
            if (isTrue(!isEqual(symbol, null)))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            } else
            {
                productType = this.handleOption(methodName, "productType", productType);
                ((IDictionary<string,object>)request)["productType"] = productType; // we need either symbol or productType
            }
            object planType = null;
            var planTypeparametersVariable = this.handleOptionAndParams(parameters, methodName, "planType", planType);
            planType = ((IList<object>)planTypeparametersVariable)[0];
            parameters = ((IList<object>)planTypeparametersVariable)[1];
            if (isTrue(isTrue((trigger)) || isTrue((!isEqual(planType, null)))))
            {
                if (isTrue(isEqual(planType, null)))
                {
                    throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), " () requires a planType parameter for swap trigger orders (\"profit_plan\" - profit order, \"loss_plan\" - loss order, \"normal_plan\" - plan order, \"pos_profit\" - position profit, \"pos_loss\" - position loss, \"moving_plan\" - Trailing TP/SL, \"track_plan\" - Trailing Stop)")) ;
                }
                ((IDictionary<string,object>)request)["planType"] = planType;
                if (isTrue(!isEqual(symbol, null)))
                {
                    response = await this.privatePostApiMixV1PlanCancelSymbolPlan(this.extend(request, parameters));
                } else
                {
                    response = await this.privatePostApiMixV1PlanCancelAllPlan(this.extend(request, parameters));
                }
            } else if (isTrue(!isEqual(symbol, null)))
            {
                ((IDictionary<string,object>)request)["marginCoin"] = getValue(market, "settleId");
                response = await this.privatePostApiMixV1OrderCancelSymbolOrders(this.extend(request, parameters));
            } else
            {
                object marginCoin = null;
                if (isTrue(isEqual(productType, "umcbl")))
                {
                    marginCoin = "USDT";
                } else
                {
                    var marginCoinparametersVariable = this.handleOptionAndParams(parameters, methodName, "marginCoin", marginCoin);
                    marginCoin = ((IList<object>)marginCoinparametersVariable)[0];
                    parameters = ((IList<object>)marginCoinparametersVariable)[1];
                    if (isTrue(isEqual(marginCoin, null)))
                    {
                        throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), " () requires a marginCoin parameter for dmcbl product type")) ;
                    }
                }
                ((IDictionary<string,object>)request)["marginCoin"] = marginCoin;
                response = await this.privatePostApiMixV1OrderCancelAllOrders(this.extend(request, parameters));
            }
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1729104940774,
            //         "data": {
            //             "result": true,
            //             "order_ids": [ "1230500426827522049" ],
            //             "client_order_ids": [ "1230500426898825216" ],
            //             "fail_infos": []
            //         }
            //     }
            //
            object result = this.getResultFromBatchCancelingSwapOrders(response);
            return this.parseOrders(result, market);
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), marketType), " type of markets")) ;
        }
        object order = this.safeOrder(response);
        ((IDictionary<string,object>)order)["info"] = response;
        return new List<object>() {order};
    }

    /**
     * @method
     * @name coincatch#cancelOrders
     * @description cancel multiple non-trigger orders
     * @see https://coincatch.github.io/github.io/en/spot/#cancel-order-in-batch-v2-single-instruments
     * @param {string[]} ids order ids
     * @param {string} symbol *is mandatory* unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string[]} [params.clientOrderIds] client order ids
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "cancelOrders";
        // only non-trigger and not tp/sl orders can be canceled via cancelOrders
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object marketType = getValue(market, "type");
        object clientOrderIds = this.safeList(parameters, "clientOrderIds");
        if (isTrue(!isEqual(clientOrderIds, null)))
        {
            ((IDictionary<string,object>)request)["clientOids"] = clientOrderIds;
            parameters = this.omit(parameters, "clientOrderIds");
        } else if (isTrue(isEqual(ids, null)))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires either ids argument or clientOrderIds parameter")) ;
        } else
        {
            ((IDictionary<string,object>)request)["orderIds"] = ids;
        }
        object response = null;
        object result = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.privatePostApiSpotV1TradeCancelBatchOrdersV2(this.extend(request));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1726491486352,
            //         "data": {
            //             "resultList": [
            //                 {
            //                     "orderId": "1219555778395160576",
            //                     "clientOrderId": "e229d70a-bb16-4633-a45c-d7f4d3b5d2cf"
            //                 }
            //             ],
            //             "failure": [
            //                 {
            //                     "orderId": "123124124",
            //                     "clientOrderId": null,
            //                     "errorMsg": "The order does not exist",
            //                     "errorCode": "43001"
            //                 }
            //             ]
            //         }
            //     }
            //
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            result = this.safeList(data, "resultList", new List<object>() {});
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            ((IDictionary<string,object>)request)["marginCoin"] = getValue(market, "settleId");
            response = await this.privatePostApiMixV1OrderCancelBatchOrders(this.extend(request, parameters));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1729101962321,
            //         "data": {
            //             "result": true,
            //             "symbol": "ETHUSDT_UMCBL",
            //             "order_ids": [ "1226441551501418496", "1230506854262857729" ],
            //             "client_order_ids": [],
            //             "fail_infos": []
            //         }
            //     }
            //
            result = this.getResultFromBatchCancelingSwapOrders(response);
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), marketType), " type of markets")) ;
        }
        return this.parseOrders(result, market);
    }

    public virtual object getResultFromBatchCancelingSwapOrders(object response)
    {
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object result = new List<object>() {};
        object orderIds = this.safeValue(data, "order_ids", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(orderIds)); postFixIncrement(ref i))
        {
            object orderId = getValue(orderIds, i);
            object resultItem = new Dictionary<string, object>() {
                { "orderId", orderId },
            };
            ((IList<object>)result).Add(resultItem);
        }
        return result;
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder spot
        //     {
        //         "orderId": "1217143186968068096",
        //         "clientOrderId": "8fa3eb89-2377-4519-a199-35d5db9ed262"
        //     }
        //
        // createOrder swap
        //     {
        //         "clientOid": "1225791137701519360",
        //         "orderId": "1225791137697325056"
        //     }
        //
        // privatePostApiSpotV1TradeOrderInfo, privatePostApiSpotV1TradeHistory
        //     {
        //         "accountId": "1002820815393",
        //         "symbol": "ETHUSDT_SPBL",
        //         "orderId": "1217143186968068096",
        //         "clientOrderId": "8fa3eb89-2377-4519-a199-35d5db9ed262",
        //         "price": "0",
        //         "quantity": "10.0000000000000000",
        //         "orderType": "market",
        //         "side": "buy",
        //         "status": "full_fill",
        //         "fillPrice": "2340.5500000000000000",
        //         "fillQuantity": "0.0042000000000000",
        //         "fillTotalAmount": "9.8303100000000000",
        //         "enterPointSource": "API",
        //         "feeDetail": "{
        //             \"ETH\": {
        //                 \"deduction\": false,
        //                 \"feeCoinCode\": \"ETH\",
        //                 \"totalDeductionFee\": 0,
        //                 \"totalFee\": -0.0000042000000000},
        //                 \"newFees\": {
        //                     \"c\": 0,
        //                     \"d\": 0,
        //                     \"deduction\": false,
        //                     \"r\": -0.0000042,
        //                     \"t\": -0.0000042,
        //                     \"totalDeductionFee\": 0
        //             }
        //         }",
        //         "orderSource": "market",
        //         "cTime": "1725915469877"
        //     }
        //
        // privatePostApiMixV1OrderDetail, privateGetApiMixV1OrderMarginCoinCurrent
        //     {
        //         "symbol": "ETHUSDT_UMCBL",
        //         "size": 0.01,
        //         "orderId": "1225791137697325056",
        //         "clientOid": "1225791137701519360",
        //         "filledQty": 0.01,
        //         "fee": -0.01398864,
        //         "price": null,
        //         "priceAvg": 2331.44,
        //         "state": "filled",
        //         "side": "close_long",
        //         "timeInForce": "normal",
        //         "totalProfits": -2.23680000,
        //         "posSide": "long",
        //         "marginCoin": "USDT",
        //         "filledAmount": 23.3144,
        //         "orderType": "market",
        //         "leverage": "5",
        //         "marginMode": "crossed",
        //         "reduceOnly": true,
        //         "enterPointSource": "API",
        //         "tradeSide": "close_long",
        //         "holdMode": "double_hold",
        //         "orderSource": "market",
        //         "cTime": "1727977302003",
        //         "uTime": "1727977303604"
        //     }
        //
        // privatePostApiSpotV1TradeOpenOrders
        //     {
        //         "accountId": "1002820815393",
        //         "symbol": "ETHUSDT_SPBL",
        //         "orderId": "1217347655911653376",
        //         "clientOrderId": "c57c07d1-bd00-4167-95e2-9b22a55fbc28",
        //         "price": "2000.0000000000000000",
        //         "quantity": "0.0010000000000000",
        //         "orderType": "limit",
        //         "side": "buy",
        //         "status": "new",
        //         "fillPrice": "0",
        //         "fillQuantity": "0.0000000000000000",
        //         "fillTotalAmount": "0.0000000000000000",
        //         "enterPointSource": "API",
        //         "feeDetail": "",
        //         "orderSource": "normal",
        //         "cTime": "1725964219072"
        //     }
        //
        // privatePostApiSpotV1PlanCurrentPlan, privatePostApiSpotV1PlanHistoryPlan
        //     {
        //         "orderId": "1228669617606991872",
        //         "clientOid": "1228669617573437440",
        //         "symbol": "ETHUSDT_SPBL",
        //         "size": "50",
        //         "executePrice": "0",
        //         "triggerPrice": "4000",
        //         "status": "not_trigger",
        //         "orderType": "market",
        //         "side": "sell",
        //         "triggerType": "fill_price",
        //         "enterPointSource": "API",
        //         "placeType": null,
        //         "cTime": "1728663585092",
        //         "uTime": null
        //     }
        //
        // privateGetApiMixV1PlanCurrentPlan
        //     {
        //         "orderId": "1230779428914049025",
        //         "clientOid": "1230779428914049024",
        //         "symbol": "ETHUSDT_UMCBL",
        //         "marginCoin": "USDT",
        //         "size": "0.01",
        //         "executePrice": "1000",
        //         "triggerPrice": "1200",
        //         "status": "not_trigger",
        //         "orderType": "limit",
        //         "planType": "normal_plan",
        //         "side": "buy_single",
        //         "triggerType": "fill_price",
        //         "presetTakeProfitPrice": "4000",
        //         "presetTakeLossPrice": "900",
        //         "rangeRate": "",
        //         "enterPointSource": "API",
        //         "tradeSide": "buy_single",
        //         "holdMode": "single_hold",
        //         "reduceOnly": false,
        //         "cTime": "1729166603306",
        //         "uTime": null
        //     }
        //
        object marketId = this.safeString(order, "symbol");
        object marginCoin = this.safeString(order, "marginCoin");
        market = this.safeMarketCustom(marketId, market, marginCoin);
        object timestamp = this.safeInteger(order, "cTime");
        object price = this.omitZero(this.safeString2(order, "price", "executePrice")); // price is zero for market orders
        object priceAvg = this.omitZero(this.safeString(order, "priceAvg"));
        if (isTrue(isEqual(price, null)))
        {
            price = priceAvg;
        }
        object type = this.safeString(order, "orderType");
        object side = this.parseOrderSide(this.safeStringLower(order, "side"));
        object amount = this.safeString2(order, "quantity", "size");
        object isTrigger = !isEqual(this.safeString(order, "triggerType"), null);
        object isMarketBuy = isTrue((isEqual(type, "market"))) && isTrue((isEqual(side, "buy")));
        if (isTrue(isTrue(isTrue((getValue(market, "spot"))) && isTrue((isMarketBuy))) && isTrue((!isTrue(isTrigger)))))
        {
            amount = null; // cost instead of amount is returned for market buy spot non-trigger orders
        }
        object status = this.safeString2(order, "status", "state");
        object feeDetailString = this.safeString(order, "feeDetail");
        object fees = null;
        object feeCurrency = null;
        object feeCost = null;
        if (isTrue(!isEqual(feeDetailString, null)))
        {
            fees = this.parseFeeDetailString(feeDetailString);
        } else
        {
            feeCurrency = ((bool) isTrue(marginCoin)) ? this.safeCurrencyCode(marginCoin) : null;
            feeCost = Precise.stringAbs(this.safeString(order, "fee"));
        }
        object timeInForce = this.parseOrderTimeInForce(this.safeStringLower(order, "timeInForce"));
        object postOnly = null;
        if (isTrue(!isEqual(timeInForce, null)))
        {
            postOnly = isEqual(timeInForce, "PO");
        }
        object triggerPrice = this.omitZero(this.safeString(order, "triggerPrice"));
        object takeProfitPrice = this.omitZero(this.safeString(order, "presetTakeProfitPrice"));
        object stopLossPrice = this.omitZero(this.safeString2(order, "presetTakeProfitPrice", "presetTakeLossPrice"));
        object planType = this.safeString(order, "planType");
        if (isTrue(isEqual(planType, "loss_plan")))
        {
            stopLossPrice = triggerPrice;
        } else if (isTrue(isEqual(planType, "profit_plan")))
        {
            takeProfitPrice = triggerPrice;
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(order, "orderId") },
            { "clientOrderId", this.safeString2(order, "clientOrderId", "clientOid") },
            { "datetime", this.iso8601(timestamp) },
            { "timestamp", timestamp },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", this.safeInteger(order, "uTime") },
            { "status", this.parseOrderStatus(status) },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "timeInForce", timeInForce },
            { "side", side },
            { "price", price },
            { "average", ((bool) isTrue(priceAvg)) ? priceAvg : this.safeString(order, "fillPrice") },
            { "amount", amount },
            { "filled", this.safeString2(order, "fillQuantity", "filledQty") },
            { "remaining", null },
            { "stopPrice", null },
            { "triggerPrice", triggerPrice },
            { "takeProfitPrice", takeProfitPrice },
            { "stopLossPrice", stopLossPrice },
            { "cost", this.safeString2(order, "fillTotalAmount", "filledAmount") },
            { "trades", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", feeCurrency },
                { "cost", feeCost },
            } },
            { "fees", fees },
            { "reduceOnly", this.safeBool(order, "reduceOnly") },
            { "postOnly", postOnly },
            { "info", order },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object satuses = new Dictionary<string, object>() {
            { "not_trigger", "open" },
            { "init", "open" },
            { "new", "open" },
            { "partially_filled", "open" },
            { "full_fill", "closed" },
            { "filled", "closed" },
            { "cancel", "canceled" },
            { "canceled", "canceled" },
            { "cancelled", "canceled" },
        };
        return this.safeString(satuses, status, status);
    }

    public virtual object parseOrderSide(object side)
    {
        object sides = new Dictionary<string, object>() {
            { "buy", "buy" },
            { "sell", "sell" },
            { "open_long", "buy" },
            { "open_short", "sell" },
            { "close_long", "sell" },
            { "close_short", "buy" },
            { "reduce_close_long", "sell" },
            { "reduce_close_short", "buy" },
            { "offset_close_long", "sell" },
            { "offset_close_short", "buy" },
            { "burst_close_long", "sell" },
            { "burst_close_short", "buy" },
            { "delivery_close_long", "sell" },
            { "delivery_close_short", "buy" },
            { "buy_single", "buy" },
            { "sell_single", "sell" },
        };
        return this.safeString(sides, side, side);
    }

    public virtual object parseOrderTimeInForce(object timeInForce)
    {
        object timeInForces = new Dictionary<string, object>() {
            { "normal", "GTC" },
            { "post_only", "PO" },
            { "iok", "IOC" },
            { "fok", "FOK" },
        };
        return this.safeString(timeInForces, timeInForce, timeInForce);
    }

    public virtual object parseFeeDetailString(object feeDetailString)
    {
        object result = new List<object>() {};
        object feeDetail = this.parseJson(feeDetailString);
        if (isTrue(feeDetail))
        {
            object keys = new List<object>(((IDictionary<string,object>)feeDetail).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
            {
                object currencyId = this.safeString(keys, i);
                if (isTrue(inOp(this.currencies_by_id, currencyId)))
                {
                    object currency = this.safeCurrencyCode(currencyId);
                    object feeEntry = this.safeDict(feeDetail, currencyId, new Dictionary<string, object>() {});
                    object amount = Precise.stringAbs(this.safeString(feeEntry, "totalFee"));
                    ((IList<object>)result).Add(new Dictionary<string, object>() {
                        { "currency", currency },
                        { "amount", amount },
                    });
                }
            }
        }
        return result;
    }

    /**
     * @method
     * @name coincatch#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://coincatch.github.io/github.io/en/spot/#get-transaction-details
     * @see https://coincatch.github.io/github.io/en/mix/#get-order-fill-detail
     * @see https://coincatch.github.io/github.io/en/mix/#get-producttype-order-fill-detail
     * @param {string} symbol *is mandatory* unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] *swap markets only* the latest time in ms to fetch trades for, only supports the last 30 days timeframe
     * @param {string} [params.lastEndId] *swap markets only* query the data after this tradeId
     * @returns {Trade[]} a list of [trade structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchMyTrades";
        var methodNameparametersVariable = this.handleParamString(parameters, "methodName", methodName);
        methodName = ((IList<object>)methodNameparametersVariable)[0];
        parameters = ((IList<object>)methodNameparametersVariable)[1];
        await this.loadMarkets();
        object market = null;
        object marketType = "spot";
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            marketType = getValue(market, "type");
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        } else
        {
            var marketTypeparametersVariable = this.handleMarketTypeAndParams(methodName, market, parameters, marketType);
            marketType = ((IList<object>)marketTypeparametersVariable)[0];
            parameters = ((IList<object>)marketTypeparametersVariable)[1];
            if (isTrue(isEqual(marketType, "spot")))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a symbol argument for spot markets")) ;
            }
        }
        object response = null;
        object requestLimit = limit;
        if (isTrue(isEqual(marketType, "spot")))
        {
            object maxSpotLimit = 500;
            if (isTrue(!isEqual(since, null)))
            {
                requestLimit = maxSpotLimit;
            }
            if (isTrue(!isEqual(requestLimit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = requestLimit;
            }
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1725968747299,
            //         "data": [
            //             {
            //                 "accountId": "1002820815393",
            //                 "symbol": "ETHUSDT_SPBL",
            //                 "orderId": "1217143186968068096",
            //                 "fillId": "1217143193356505089",
            //                 "orderType": "market",
            //                 "side": "buy",
            //                 "fillPrice": "2340.55",
            //                 "fillQuantity": "0.0042",
            //                 "fillTotalAmount": "9.83031",
            //                 "feeCcy": "ETH",
            //                 "fees": "-0.0000042",
            //                 "takerMakerFlag": "taker",
            //                 "cTime": "1725915471400"
            //             },
            //             ...
            //         ]
            //     }
            //
            response = await this.privatePostApiSpotV1TradeFills(this.extend(request, parameters));
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)parameters)["startTime"] = since;
            } else
            {
                ((IDictionary<string,object>)parameters)["startTime"] = 0; // mandatory
            }
            object until = null;
            var untilparametersVariable = this.handleOptionAndParams(parameters, methodName, "until");
            until = ((IList<object>)untilparametersVariable)[0];
            parameters = ((IList<object>)untilparametersVariable)[1];
            if (isTrue(!isEqual(until, null)))
            {
                ((IDictionary<string,object>)request)["endTime"] = until;
            } else
            {
                ((IDictionary<string,object>)request)["endTime"] = this.milliseconds(); // mandatory
            }
            if (isTrue(!isEqual(symbol, null)))
            {
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1728306590704,
                //         "data": [
                //             {
                //                 "tradeId": "1221355735285014530",
                //                 "symbol": "ETHUSDT_UMCBL",
                //                 "orderId": "1221355728716259329",
                //                 "price": "2555.12",
                //                 "sizeQty": "0.01",
                //                 "fee": "-0.01533072",
                //                 "side": "open_long",
                //                 "fillAmount": "25.5512",
                //                 "profit": "0",
                //                 "enterPointSource": "API",
                //                 "tradeSide": "open_long",
                //                 "holdMode": "double_hold",
                //                 "takerMakerFlag": "taker",
                //                 "cTime": "1726919819661"
                //             }
                //         ]
                //     }
                //
                response = await this.privateGetApiMixV1OrderFills(this.extend(request, parameters));
            } else
            {
                object productType = "umcbl";
                productType = this.handleOption(methodName, "productType", productType);
                ((IDictionary<string,object>)request)["productType"] = productType;
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1728306372044,
                //         "data": [
                //             {
                //                 "tradeId": "1225467075440189441",
                //                 "symbol": "ETHUSD_DMCBL",
                //                 "orderId": "1225467075288719360",
                //                 "price": "2362.03",
                //                 "sizeQty": "0.1",
                //                 "fee": "-0.00005996",
                //                 "side": "burst_close_long",
                //                 "fillAmount": "236.203",
                //                 "profit": "-0.0083359",
                //                 "enterPointSource": "SYS",
                //                 "tradeSide": "burst_close_long",
                //                 "holdMode": "double_hold",
                //                 "takerMakerFlag": "taker",
                //                 "cTime": "1727900039539"
                //             },
                //             ...
                //         ]
                //     }
                //
                response = await this.privateGetApiMixV1OrderAllFills(this.extend(request, parameters));
            }
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), marketType), " type of markets")) ;
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    /**
     * @method
     * @name coincatch#fetchOrderTrades
     * @description fetch all the trades made from a single order
     * @see https://coincatch.github.io/github.io/en/spot/#get-transaction-details
     * @param {string} id order id
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchOrderTrades";
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), " () requires a symbol argument")) ;
        }
        object request = new Dictionary<string, object>() {
            { "orderId", id },
            { "methodName", methodName },
        };
        return await this.fetchMyTrades(symbol, since, limit, this.extend(request, parameters));
    }

    /**
     * @method
     * @name coincatch#fetchMarginMode
     * @description fetches the margin mode of the trading pair
     * @see https://coincatch.github.io/github.io/en/mix/#get-single-account
     * @param {string} symbol unified symbol of the market to fetch the margin mode for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin mode structure]{@link https://docs.ccxt.com/#/?id=margin-mode-structure}
     */
    public async override Task<object> fetchMarginMode(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
        };
        object response = await this.privateGetApiMixV1AccountAccount(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1726669633799,
        //         "data": {
        //             "marginCoin": "ETH",
        //             "locked": "0",
        //             "available": "0.01",
        //             "crossMaxAvailable": "0.01",
        //             "fixedMaxAvailable": "0.01",
        //             "maxTransferOut": "0.01",
        //             "equity": "0.01",
        //             "usdtEquity": "22.97657025",
        //             "btcEquity": "0.000386195288",
        //             "crossRiskRate": "0",
        //             "crossMarginLeverage": 100,
        //             "fixedLongLeverage": 100,
        //             "fixedShortLeverage": 100,
        //             "marginMode": "crossed",
        //             "holdMode": "double_hold",
        //             "unrealizedPL": "0",
        //             "bonus": "0",
        //             "crossedUnrealizedPL": "0",
        //             "isolatedUnrealizedPL": ""
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginMode(data, market);
    }

    public override object parseMarginMode(object marginMode, object market = null)
    {
        object marginType = this.safeStringLower(marginMode, "marginMode");
        return new Dictionary<string, object>() {
            { "info", marginMode },
            { "symbol", this.safeSymbol(null, market) },
            { "marginMode", this.parseMarginModeType(marginType) },
        };
    }

    public virtual object parseMarginModeType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "crossed", "cross" },
            { "fixed", "isolated" },
        };
        return this.safeString(types, type, type);
    }

    /**
     * @method
     * @name coincatch#setMarginMode
     * @description set margin mode to 'cross' or 'isolated'
     * @see https://coincatch.github.io/github.io/en/mix/#change-margin-mode
     * @param {string} marginMode 'cross' or 'isolated'
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        marginMode = ((string)marginMode).ToLower();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(!isEqual(getValue(market, "type"), "swap")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " setMarginMode() is not supported for "), getValue(market, "type")), " type of markets")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
            { "marginMode", this.encodeMarginModeType(marginMode) },
        };
        object response = await this.privatePostApiMixV1AccountSetMarginMode(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1726670096099,
        //         "data": {
        //             "symbol": "ETHUSD_DMCBL",
        //             "marginCoin": "ETH",
        //             "longLeverage": 10,
        //             "shortLeverage": 10,
        //             "crossMarginLeverage": null,
        //             "marginMode": "fixed"
        //         }
        //     }
        //
        return response;
    }

    public virtual object encodeMarginModeType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "cross", "crossed" },
            { "isolated", "fixed" },
        };
        return this.safeString(types, type, type);
    }

    /**
     * @method
     * @name coincatch#fetchPositionMode
     * @description fetchs the position mode, hedged or one way
     * @see https://coincatch.github.io/github.io/en/mix/#get-single-account
     * @param {string} symbol unified symbol of the market to fetch entry for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an object detailing whether the market is in hedged or one-way mode
     */
    public async virtual Task<object> fetchPositionMode(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchPositionMode() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(!isEqual(getValue(market, "type"), "swap")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchPositionMode() is not supported for "), getValue(market, "type")), " type of markets")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
        };
        object response = await this.privateGetApiMixV1AccountAccount(this.extend(request, parameters)); // same endpoint as fetchMarginMode
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object holdMode = this.safeString(data, "holdMode");
        return new Dictionary<string, object>() {
            { "info", response },
            { "hedged", isEqual(holdMode, "double_hold") },
        };
    }

    /**
     * @method
     * @name coincatch#setPositionMode
     * @description set hedged to true or false for a market
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Set%20Position%20Mode
     * @param {bool} hedged set to true to use dualSidePosition
     * @param {string} symbol unified symbol of the market to fetch entry for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.productType] 'umcbl' or 'dmcbl' (default 'umcbl' if symbol is not provided)
     * @returns {object} response from the exchange
     */
    public async override Task<object> setPositionMode(object hedged, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "setPositionMode";
        object defaultProductType = "umcbl";
        await this.loadMarkets();
        object productType = this.safeString(parameters, "productType");
        if (isTrue(isEqual(productType, null)))
        {
            if (isTrue(!isEqual(symbol, null)))
            {
                object market = this.market(symbol);
                if (isTrue(!isEqual(getValue(market, "type"), "swap")))
                {
                    throw new NotSupported ((string)add(add(add(this.id, " setPositionMode() is not supported for "), getValue(market, "type")), " type of markets")) ;
                }
                object marketId = getValue(market, "id");
                object parts = ((string)marketId).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
                productType = this.safeStringLower(parts, 1, productType);
            } else
            {
                productType = this.handleOption(methodName, "productType", defaultProductType);
            }
        }
        object request = new Dictionary<string, object>() {
            { "productType", productType },
            { "holdMode", ((bool) isTrue(hedged)) ? "double_hold" : "single_hold" },
        };
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1726677135005,
        //         "data": {
        //             "marginCoin": "ETH",
        //             "dualSidePosition": false
        //         }
        //     }
        //
        return await this.privatePostApiMixV1AccountSetPositionMode(this.extend(request, parameters));
    }

    /**
     * @method
     * @name coincatch#fetchLeverage
     * @description fetch the set leverage for a market
     * @see https://coincatch.github.io/github.io/en/mix/#get-single-account
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
     */
    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(!isEqual(getValue(market, "type"), "swap")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchLeverage() is not supported for "), getValue(market, "type")), " type of markets")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
        };
        object response = await this.privateGetApiMixV1AccountAccount(this.extend(request, parameters)); // same endpoint as fetchMarginMode
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseLeverage(data, market);
    }

    /**
     * @method
     * @name coincatch#setLeverage
     * @description set the level of leverage for a market
     * @see https://hashkeyglobal-apidoc.readme.io/reference/change-futures-leverage-trade
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.side] *for isolated margin mode with hedged position mode only* 'long' or 'short'
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "setLeverage";
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(!isEqual(getValue(market, "type"), "swap")))
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), getValue(market, "type")), " type of markets")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
            { "leverage", leverage },
        };
        object side = null;
        var sideparametersVariable = this.handleOptionAndParams(parameters, methodName, "side");
        side = ((IList<object>)sideparametersVariable)[0];
        parameters = ((IList<object>)sideparametersVariable)[1];
        if (isTrue(!isEqual(side, null)))
        {
            ((IDictionary<string,object>)request)["holdSide"] = side;
        }
        object response = await this.privatePostApiMixV1AccountSetLeverage(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1726680486657,
        //         "data": {
        //             "symbol": "ETHUSD_DMCBL",
        //             "marginCoin": "ETH",
        //             "longLeverage": 2,
        //             "shortLeverage": 2,
        //             "crossMarginLeverage": 2,
        //             "marginMode": "crossed"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseLeverage(data, market);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        //
        // fetchLeverage
        //     {
        //         "marginCoin": "ETH",
        //         "locked": "0",
        //         "available": "0.01",
        //         "crossMaxAvailable": "0.01",
        //         "fixedMaxAvailable": "0.01",
        //         "maxTransferOut": "0.01",
        //         "equity": "0.01",
        //         "usdtEquity": "22.97657025",
        //         "btcEquity": "0.000386195288",
        //         "crossRiskRate": "0",
        //         "crossMarginLeverage": 100,
        //         "fixedLongLeverage": 100,
        //         "fixedShortLeverage": 100,
        //         "marginMode": "crossed",
        //         "holdMode": "double_hold",
        //         "unrealizedPL": "0",
        //         "bonus": "0",
        //         "crossedUnrealizedPL": "0",
        //         "isolatedUnrealizedPL": ""
        //     }
        //
        // setLeverage
        //     {
        //         "symbol": "ETHUSD_DMCBL",
        //         "marginCoin": "ETH",
        //         "longLeverage": 2,
        //         "shortLeverage": 2,
        //         "crossMarginLeverage": 2,
        //         "marginMode": "crossed"
        //     }
        //
        object marketId = this.safeString(leverage, "symbol");
        market = this.safeMarketCustom(marketId, market);
        object marginMode = this.parseMarginModeType(this.safeStringLower(leverage, "marginMode"));
        object longLeverage = this.safeInteger2(leverage, "fixedLongLeverage", "longLeverage");
        object shortLeverage = this.safeInteger2(leverage, "fixedShortLeverage", "shortLeverage");
        object crossMarginLeverage = this.safeInteger(leverage, "crossMarginLeverage");
        if (isTrue(isEqual(marginMode, "cross")))
        {
            longLeverage = crossMarginLeverage;
            shortLeverage = crossMarginLeverage;
        }
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", getValue(market, "symbol") },
            { "marginMode", marginMode },
            { "longLeverage", longLeverage },
            { "shortLeverage", shortLeverage },
        };
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "modifyMarginHelper";
        var methodNameparametersVariable = this.handleParamString(parameters, "methodName", methodName);
        methodName = ((IList<object>)methodNameparametersVariable)[0];
        parameters = ((IList<object>)methodNameparametersVariable)[1];
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(!isEqual(getValue(market, "type"), "swap")))
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), getValue(market, "type")), " type of markets")) ;
        }
        amount = this.amountToPrecision(symbol, amount);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
            { "amount", amount },
        };
        object side = null;
        var sideparametersVariable = this.handleOptionAndParams(parameters, methodName, "side");
        side = ((IList<object>)sideparametersVariable)[0];
        parameters = ((IList<object>)sideparametersVariable)[1];
        if (isTrue(!isEqual(side, null)))
        {
            ((IDictionary<string,object>)request)["holdSide"] = side;
        }
        object response = await this.privatePostApiMixV1AccountSetMargin(this.extend(request, parameters));
        // todo check response
        // always returns error
        // addMargin - "code":"45006","msg":"Insufficient position","requestTime":1729162281543,"data":null
        // reduceMargin - "code":"40800","msg":"Insufficient amount of margin","requestTime":1729162362718,"data":null
        if (isTrue(isEqual(type, "reduce")))
        {
            amount = Precise.stringAbs(amount);
        }
        return this.extend(this.parseMarginModification(response, market), new Dictionary<string, object>() {
            { "amount", this.parseNumber(amount) },
            { "type", type },
        });
    }

    public override object parseMarginModification(object data, object market = null)
    {
        //
        //
        object msg = this.safeString(data, "msg");
        object status = ((bool) isTrue((isEqual(msg, "success")))) ? "ok" : "failed";
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", getValue(market, "symbol") },
            { "type", null },
            { "marginMode", null },
            { "amount", null },
            { "total", null },
            { "code", getValue(market, "quote") },
            { "status", status },
            { "timestamp", null },
            { "datetime", null },
        };
    }

    /**
     * @method
     * @name coincatch#reduceMargin
     * @description remove margin from a position
     * @see https://coincatch.github.io/github.io/en/mix/#change-margin
     * @param {string} symbol unified market symbol
     * @param {float} amount the amount of margin to remove
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.side] *for isolated margin mode with hedged position mode only* 'long' or 'short'
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
     */
    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["methodName"] = "reduceMargin";
        return await this.modifyMarginHelper(symbol, prefixUnaryNeg(ref amount), "reduce", parameters);
    }

    /**
     * @method
     * @name coincatch#addMargin
     * @description add margin
     * @see https://coincatch.github.io/github.io/en/mix/#change-margin
     * @param {string} symbol unified market symbol
     * @param {float} amount amount of margin to add
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.side] *for isolated margin mode with hedged position mode only* 'long' or 'short'
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
     */
    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["methodName"] = "addMargin";
        return await this.modifyMarginHelper(symbol, amount, "add", parameters);
    }

    /**
     * @method
     * @name coincatch#fetchPosition
     * @description fetch data on a single open contract trade position
     * @see https://coincatch.github.io/github.io/en/mix/#get-symbol-position
     * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string}  [params.side] 'long' or 'short' *for non-hedged position mode only* (default 'long')
     * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchPosition";
        object side = "long";
        var sideparametersVariable = this.handleOptionAndParams(parameters, methodName, "side");
        side = ((IList<object>)sideparametersVariable)[0];
        parameters = ((IList<object>)sideparametersVariable)[1];
        object positions = await this.fetchPositionsForSymbol(symbol, parameters);
        object arrayLength = getArrayLength(positions);
        if (isTrue(isGreaterThan(arrayLength, 1)))
        {
            for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
            {
                object position = getValue(positions, i);
                if (isTrue(isEqual(getValue(position, "side"), side)))
                {
                    return position;
                }
            }
        }
        return getValue(positions, 0);
    }

    /**
     * @method
     * @description fetch open positions for a single market
     * @name coincatch#fetchPositionsForSymbol
     * @see https://coincatch.github.io/github.io/en/mix/#get-symbol-position
     * @description fetch all open positions for specific symbol
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositionsForSymbol(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
        };
        object response = await this.privateGetApiMixV1PositionSinglePositionV2(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1726926959041,
        //         "data": [
        //             {
        //                 "marginCoin": "USDT",
        //                 "symbol": "ETHUSDT_UMCBL",
        //                 "holdSide": "long",
        //                 "openDelegateCount": "0",
        //                 "margin": "2.55512",
        //                 "available": "0.01",
        //                 "locked": "0",
        //                 "total": "0.01",
        //                 "leverage": 10,
        //                 "achievedProfits": "0",
        //                 "averageOpenPrice": "2555.12",
        //                 "marginMode": "crossed",
        //                 "holdMode": "double_hold",
        //                 "unrealizedPL": "0.1371",
        //                 "liquidationPrice": "-3433.328491",
        //                 "keepMarginRate": "0.0033",
        //                 "marketPrice": "2568.83",
        //                 "marginRatio": "0.001666357648",
        //                 "autoMargin": "off",
        //                 "cTime": "1726919819686"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parsePositions(data, new List<object>() {symbol});
    }

    /**
     * @method
     * @name coincatch#fetchPositions
     * @description fetch all open positions
     * @see https://coincatch.github.io/github.io/en/mix/#get-all-position
     * @param {string[]} [symbols] list of unified market symbols (all symbols must belong to the same product type)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.productType] 'umcbl' or 'dmcbl' (default 'umcbl' if symbols are not provided)
     * @param {string} [params.marginCoin] the settle currency of the positions, needs to match the productType
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchPositions";
        await this.loadMarkets();
        object productType = "umcbl";
        if (isTrue(!isEqual(symbols, null)))
        {
            object marketIds = this.marketIds(symbols);
            object productTypes = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
            {
                object marketId = getValue(marketIds, i);
                object parts = ((string)marketId).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
                object marketProductType = this.safeString(parts, 1);
                ((IList<object>)productTypes).Add(marketProductType);
            }
            productTypes = this.unique(productTypes);
            object arrayLength = getArrayLength(productTypes);
            if (isTrue(isGreaterThan(arrayLength, 1)))
            {
                throw new BadSymbol ((string)add(add(add(this.id, " "), methodName), "() requires all symbols to belong to the same product type (umcbl or dmcbl)")) ;
            } else
            {
                productType = getValue(productTypes, 0);
            }
        } else
        {
            var productTypeparametersVariable = this.handleOptionAndParams(parameters, methodName, "productType", productType);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
        }
        object request = new Dictionary<string, object>() {
            { "productType", productType },
        };
        if (isTrue(isEqual(productType, "dmcbl")))
        {
            object marginCoin = null;
            var marginCoinparametersVariable = this.handleOptionAndParams(parameters, methodName, "marginCoin");
            marginCoin = ((IList<object>)marginCoinparametersVariable)[0];
            parameters = ((IList<object>)marginCoinparametersVariable)[1];
            if (isTrue(!isEqual(marginCoin, null)))
            {
                object currency = this.currency(marginCoin);
                ((IDictionary<string,object>)request)["marginCoin"] = getValue(currency, "id");
            }
        }
        object response = await this.privateGetApiMixV1PositionAllPositionV2(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1726933132054,
        //         "data": [
        //             {
        //                 "marginCoin": "USDT",
        //                 "symbol": "ETHUSDT_UMCBL",
        //                 "holdSide": "long",
        //                 "openDelegateCount": "0",
        //                 "margin": "2.55512",
        //                 "available": "0.01",
        //                 "locked": "0",
        //                 "total": "0.01",
        //                 "leverage": 10,
        //                 "achievedProfits": "0",
        //                 "averageOpenPrice": "2555.12",
        //                 "marginMode": "crossed",
        //                 "holdMode": "double_hold",
        //                 "unrealizedPL": "0.0093",
        //                 "liquidationPrice": "-3433.378333",
        //                 "keepMarginRate": "0.0033",
        //                 "marketPrice": "2556.05",
        //                 "marginRatio": "0.001661599511",
        //                 "autoMargin": "off",
        //                 "cTime": "1726919819686",
        //                 "uTime": "1726919819686"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parsePositions(data, symbols);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         "marginCoin": "USDT",
        //         "symbol": "ETHUSDT_UMCBL",
        //         "holdSide": "long",
        //         "openDelegateCount": "0",
        //         "margin": "2.55512",
        //         "available": "0.01",
        //         "locked": "0",
        //         "total": "0.01",
        //         "leverage": 10,
        //         "achievedProfits": "0",
        //         "averageOpenPrice": "2555.12",
        //         "marginMode": "crossed",
        //         "holdMode": "double_hold",
        //         "unrealizedPL": "0.0093",
        //         "liquidationPrice": "-3433.378333",
        //         "keepMarginRate": "0.0033",
        //         "marketPrice": "2556.05",
        //         "marginRatio": "0.001661599511",
        //         "autoMargin": "off",
        //         "cTime": "1726919819686",
        //         "uTime": "1726919819686"
        //     }
        //
        object marketId = this.safeString(position, "symbol");
        object settleId = this.safeString(position, "marginCoin");
        market = this.safeMarketCustom(marketId, market, settleId);
        object timestamp = this.safeInteger(position, "cTime");
        object marginMode = this.safeString(position, "marginMode");
        object isHedged = null;
        object holdMode = this.safeString(position, "holdMode");
        if (isTrue(isEqual(holdMode, "double_hold")))
        {
            isHedged = true;
        } else if (isTrue(isEqual(holdMode, "single_hold")))
        {
            isHedged = false;
        }
        object margin = this.safeNumber(position, "margin");
        object keepMarginRate = this.safeString(position, "keepMarginRate");
        return this.safePosition(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "id", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "contracts", this.safeNumber(position, "total") },
            { "contractSize", null },
            { "side", this.safeStringLower(position, "holdSide") },
            { "notional", margin },
            { "leverage", this.safeInteger(position, "leverage") },
            { "unrealizedPnl", this.safeNumber(position, "unrealizedPL") },
            { "realizedPnl", this.safeNumber(position, "achievedProfits") },
            { "collateral", null },
            { "entryPrice", this.safeNumber(position, "averageOpenPrice") },
            { "markPrice", this.safeNumber(position, "marketPrice") },
            { "liquidationPrice", this.safeNumber(position, "liquidationPrice") },
            { "marginMode", this.parseMarginModeType(marginMode) },
            { "hedged", isHedged },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", this.parseNumber(Precise.stringMul(keepMarginRate, "100")) },
            { "initialMargin", margin },
            { "initialMarginPercentage", null },
            { "marginRatio", this.safeNumber(position, "marginRatio") },
            { "lastUpdateTimestamp", this.safeInteger(position, "uTime") },
            { "lastPrice", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
            { "percentage", null },
            { "info", position },
        });
    }

    public virtual object safeMarketCustom(object marketId, object market = null, object settleId = null)
    {
        try
        {
            market = this.safeMarket(marketId, market);
        } catch(Exception e)
        {
            // dmcbl markets have the same id and market type but different settleId
            // so we need to resolve the market by settleId
            object marketsWithCurrentId = this.safeList(this.markets_by_id, marketId, new List<object>() {});
            if (isTrue(isEqual(settleId, null)))
            {
                market = getValue(marketsWithCurrentId, 0); // if settleId is not provided, return the first market with the current id
            } else
            {
                for (object i = 0; isLessThan(i, getArrayLength(marketsWithCurrentId)); postFixIncrement(ref i))
                {
                    object marketWithCurrentId = getValue(marketsWithCurrentId, i);
                    if (isTrue(isEqual(getValue(marketWithCurrentId, "settleId"), settleId)))
                    {
                        market = marketWithCurrentId;
                        break;
                    }
                }
            }
        }
        return market;
    }

    /**
     * @method
     * @name coincatch#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
     * @see https://coincatch.github.io/github.io/en/spot/#get-bills
     * @see https://coincatch.github.io/github.io/en/mix/#get-business-account-bill
     * @param {string} [code] unified currency code
     * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
     * @param {int} [limit] max number of ledger entrys to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] *swap only* the latest time in ms to fetch entries for
     * @param {string} [params.type] 'spot' or 'swap' (default 'spot')
     * @param {string} [params.after] *spot only* billId, return the data less than this billId
     * @param {string} [params.before] *spot only* billId, return the data greater than or equals to this billId
     * @param {string} [params.groupType] *spot only*
     * @param {string} [params.bizType] *spot only*
     * @param {string} [params.productType] *swap only* 'umcbl' or 'dmcbl' (default 'umcbl' or 'dmcbl' if code is provided and code is not equal to 'USDT')
     * @param {string} [params.business] *swap only*
     * @param {string} [params.lastEndId] *swap only*
     * @param {bool} [params.next] *swap only*
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchLedger";
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object marketType = "spot";
        var marketTypeparametersVariable = this.handleMarketTypeAndParams(methodName, null, parameters, marketType);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object result = null;
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(!isEqual(currency, null)))
            {
                object numericId = this.safeString(currency, "numericId");
                ((IDictionary<string,object>)request)["coinId"] = numericId;
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            object response = await this.privatePostApiSpotV1AccountBills(this.extend(request, parameters));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1727964749515,
            //         "data": [
            //             {
            //                 "billId": "1220289012519190529",
            //                 "coinId": 2,
            //                 "coinName": "USDT",
            //                 "groupType": "transfer",
            //                 "bizType": "Transfer out",
            //                 "quantity": "-40.00000000",
            //                 "balance": "4.43878673",
            //                 "fees": "0.00000000",
            //                 "cTime": "1726665493092"
            //             },
            //             ...
            //         ]
            //     }
            //
            result = this.safeList(response, "data", new List<object>() {});
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["startTime"] = since;
            } else
            {
                ((IDictionary<string,object>)request)["startTime"] = 0; // is mandatory
            }
            object until = null;
            var untilparametersVariable = this.handleOptionAndParams(parameters, methodName, "until");
            until = ((IList<object>)untilparametersVariable)[0];
            parameters = ((IList<object>)untilparametersVariable)[1];
            if (isTrue(!isEqual(until, null)))
            {
                ((IDictionary<string,object>)request)["endTime"] = until;
            } else
            {
                ((IDictionary<string,object>)request)["endTime"] = this.milliseconds(); // is mandatory
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["pageSize"] = limit;
            }
            object productType = "umcbl";
            if (isTrue(isEqual(code, null)))
            {
                productType = this.handleOption(methodName, "productType", productType);
            } else if (isTrue(isEqual(code, "USDT")))
            {
                productType = "umcbl";
            } else
            {
                productType = "dmcbl";
            }
            var productTypeparametersVariable = this.handleParamString(parameters, "productType", productType);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            object response = await this.privateGetApiMixV1AccountAccountBusinessBill(this.extend(request, parameters));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1727971607663,
            //         "data": {
            //             "result": [
            //                 {
            //                     "id": "1225766556446064640",
            //                     "symbol": null,
            //                     "marginCoin": "ETH",
            //                     "amount": "-0.0016",
            //                     "fee": "0",
            //                     "feeByCoupon": "",
            //                     "feeCoin": "ETH",
            //                     "business": "trans_to_exchange",
            //                     "cTime": "1727971441425"
            //                 },
            //                 {
            //                     "id": "1225467081664061441",
            //                     "symbol": "ETHUSD_DMCBL",
            //                     "marginCoin": "ETH",
            //                     "amount": "-0.00052885",
            //                     "fee": "0",
            //                     "feeByCoupon": "",
            //                     "feeCoin": "ETH",
            //                     "business": "risk_captital_user_transfer",
            //                     "cTime": "1727900041024"
            //                 },
            //                 {
            //                     "id": "1225467075440189441",
            //                     "symbol": "ETHUSD_DMCBL",
            //                     "marginCoin": "ETH",
            //                     "amount": "-0.0083359",
            //                     "fee": "-0.00005996",
            //                     "feeByCoupon": "",
            //                     "feeCoin": "ETH",
            //                     "business": "burst_long_loss_query",
            //                     "cTime": "1727900039576"
            //                 },
            //                 {
            //                     "id": "1221416895715303426",
            //                     "symbol": "ETHUSD_DMCBL",
            //                     "marginCoin": "ETH",
            //                     "amount": "0.00004756",
            //                     "fee": "0",
            //                     "feeByCoupon": "",
            //                     "feeCoin": "ETH",
            //                     "business": "contract_settle_fee",
            //                     "cTime": "1726934401444"
            //                 },
            //                 {
            //                     "id": "1221413703233871873",
            //                     "symbol": "ETHUSD_DMCBL",
            //                     "marginCoin": "ETH",
            //                     "amount": "0",
            //                     "fee": "-0.00005996",
            //                     "feeByCoupon": "",
            //                     "feeCoin": "ETH",
            //                     "business": "open_long",
            //                     "cTime": "1726933640336"
            //                 },
            //                 {
            //                     "id": "1220288640761122816",
            //                     "symbol": null,
            //                     "marginCoin": "ETH",
            //                     "amount": "0.01",
            //                     "fee": "0",
            //                     "feeByCoupon": "",
            //                     "feeCoin": "ETH",
            //                     "business": "trans_from_exchange",
            //                     "cTime": "1726665404563"
            //                 }
            //             ],
            //             "lastEndId": "1220288641021337600",
            //             "nextFlag": false,
            //             "preFlag": false
            //         }
            //     }
            //
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            result = this.safeList(data, "result", new List<object>() {});
        } else
        {
            throw new NotSupported ((string)add(add(add(add(this.id, " "), methodName), "() does not support market type "), marketType)) ;
        }
        return this.parseLedger(result, currency, since, limit);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        // spot
        //     {
        //         "billId": "1220289012519190529",
        //         "coinId": 2,
        //         "coinName": "USDT",
        //         "groupType": "transfer",
        //         "bizType": "Transfer out",
        //         "quantity": "-40.00000000",
        //         "balance": "4.43878673",
        //         "fees": "0.00000000",
        //         "cTime": "1726665493092"
        //     }
        //
        // swap
        //     {
        //         "id": "1220288640761122816",
        //         "symbol": null,
        //         "marginCoin": "ETH",
        //         "amount": "0.01",
        //         "fee": "0",
        //         "feeByCoupon": "",
        //         "feeCoin": "ETH",
        //         "business": "trans_from_exchange",
        //         "cTime": "1726665404563"
        //     }
        //
        object timestamp = this.safeInteger(item, "cTime");
        object settleId = this.safeString2(item, "coinName", "marginCoin");
        object market = null;
        object marketId = this.safeString(item, "symbol");
        market = this.safeMarketCustom(marketId, market, settleId);
        object amountString = this.safeString2(item, "quantity", "amount");
        object direction = "in";
        if (isTrue(Precise.stringLt(amountString, "0")))
        {
            direction = "out";
            amountString = Precise.stringMul(amountString, "-1");
        }
        object fee = new Dictionary<string, object>() {
            { "cost", Precise.stringAbs(this.safeString2(item, "fee", "fees")) },
            { "currency", this.safeString(item, "feeCoin") },
        };
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "id", this.safeString2(item, "billId", "id") },
            { "info", item },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "account", null },
            { "direction", direction },
            { "referenceId", null },
            { "referenceAccount", null },
            { "type", this.parseLedgerEntryType(this.safeStringLower2(item, "bizType", "business")) },
            { "currency", this.safeCurrencyCode(settleId, currency) },
            { "symbol", getValue(market, "symbol") },
            { "amount", amountString },
            { "before", null },
            { "after", this.safeString(item, "balance") },
            { "status", "ok" },
            { "fee", fee },
        }, currency);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "deposit", "deposit" },
            { "withdraw", "withdrawal" },
            { "buy", "trade" },
            { "sell", "trade" },
            { "deduction of handling fee", "fee" },
            { "transfer-in", "transfer" },
            { "transfer in", "transfer" },
            { "transfer out", "transfer" },
            { "rebate rewards", "rebate" },
            { "airdrop rewards", "rebate" },
            { "usdt contract rewards", "rebate" },
            { "mix contract rewards", "rebate" },
            { "system lock", "system lock" },
            { "user lock", "user lock" },
            { "open_long", "trade" },
            { "open_short", "trade" },
            { "close_long", "trade" },
            { "close_short", "trade" },
            { "trans_from_exchange", "transfer" },
            { "trans_to_exchange", "transfer" },
            { "contract_settle_fee", "fee" },
            { "burst_long_loss_query", "trade" },
            { "burst_short_loss_query", "trade" },
        };
        return this.safeString(types, type, type);
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        object message = this.safeString(response, "msg");
        object feedback = add(add(this.id, " "), body);
        object messageCode = this.safeString(response, "code");
        object success = isTrue((isEqual(message, "success"))) || isTrue((isEqual(message, null)));
        if (isTrue(isGreaterThanOrEqual(getIndexOf(url, "batch"), 0)))
        {
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            object failure = this.safeList2(data, "failure", "fail_infos", new List<object>() {});
            if (!isTrue(this.isEmpty(failure)))
            {
                success = false;
                object firstEntry = this.safeDict(failure, 0, new Dictionary<string, object>() {});
                messageCode = this.safeString(firstEntry, "errorCode");
                message = this.safeString(firstEntry, "errorMsg");
            }
        }
        if (!isTrue(success))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), messageCode, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object endpoint = add("/", path);
        if (isTrue(isEqual(method, "GET")))
        {
            object query = this.urlencode(parameters);
            if (isTrue(!isEqual(getArrayLength(query), 0)))
            {
                endpoint = add(endpoint, add("?", query));
            }
        }
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object timestamp = this.numberToString(this.milliseconds());
            object suffix = "";
            if (isTrue(!isEqual(method, "GET")))
            {
                body = this.json(parameters);
                suffix = body;
            }
            object payload = add(add(add(timestamp, method), endpoint), suffix);
            object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha256, "base64");
            headers = new Dictionary<string, object>() {
                { "ACCESS-KEY", this.apiKey },
                { "ACCESS-SIGN", signature },
                { "ACCESS-TIMESTAMP", timestamp },
                { "ACCESS-PASSPHRASE", this.password },
                { "Content-Type", "application/json" },
                { "X-CHANNEL-API-CODE", this.safeString(this.options, "brokerId", "47cfy") },
            };
        }
        object url = add(getValue(getValue(this.urls, "api"), api), endpoint);
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }
}
