namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class hollaex : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "hollaex" },
            { "name", "HollaEx" },
            { "countries", new List<object>() {"KR"} },
            { "rateLimit", 250 },
            { "version", "v2" },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", null },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createLimitBuyOrder", true },
                { "createLimitSellOrder", true },
                { "createMarketBuyOrder", true },
                { "createMarketSellOrder", true },
                { "createOrder", true },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", "emulated" },
                { "fetchDepositAddresses", true },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLeverage", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", true },
                { "fetchOrders", true },
                { "fetchPosition", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", true },
                { "fetchTransactions", false },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "fetchWithdrawal", true },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "sandbox", true },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "1h", "1h" },
                { "4h", "4h" },
                { "1d", "1d" },
                { "1w", "1w" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/75841031-ca375180-5ddd-11ea-8417-b975674c23cb.jpg" },
                { "test", new Dictionary<string, object>() {
                    { "rest", "https://api.sandbox.hollaex.com" },
                } },
                { "api", new Dictionary<string, object>() {
                    { "rest", "https://api.hollaex.com" },
                } },
                { "www", "https://hollaex.com" },
                { "doc", "https://apidocs.hollaex.com" },
                { "referral", "https://pro.hollaex.com/signup?affiliation_code=QSWA6G" },
            } },
            { "precisionMode", TICK_SIZE },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "health", 1 },
                        { "constants", 1 },
                        { "kit", 1 },
                        { "tiers", 1 },
                        { "ticker", 1 },
                        { "tickers", 1 },
                        { "orderbook", 1 },
                        { "orderbooks", 1 },
                        { "trades", 1 },
                        { "chart", 1 },
                        { "charts", 1 },
                        { "minicharts", 1 },
                        { "oracle/prices", 1 },
                        { "quick-trade", 1 },
                        { "udf/config", 1 },
                        { "udf/history", 1 },
                        { "udf/symbols", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "user", 1 },
                        { "user/balance", 1 },
                        { "user/deposits", 1 },
                        { "user/withdrawals", 1 },
                        { "user/withdrawal/fee", 1 },
                        { "user/trades", 1 },
                        { "orders", 1 },
                        { "order", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "user/withdrawal", 1 },
                        { "order", 1 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "order/all", 1 },
                        { "order", 1 },
                    } },
                } },
            } },
            { "features", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "sandbox", true },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", true },
                        { "triggerPriceType", null },
                        { "triggerDirection", false },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", false },
                            { "FOK", false },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "selfTradePrevention", false },
                        { "trailing", false },
                        { "leverage", false },
                        { "marketBuyByCost", false },
                        { "marketBuyRequiresPrice", false },
                        { "iceberg", false },
                    } },
                    { "createOrders", null },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "daysBack", 100000 },
                        { "untilDays", 100000 },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "daysBack", 100000 },
                        { "untilDays", 100000 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "daysBack", 100000 },
                        { "daysBackCanceled", 1 },
                        { "untilDays", 100000 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 1000 },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", 0.001 },
                    { "maker", 0.001 },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "broad", new Dictionary<string, object>() {
                    { "Invalid token", typeof(AuthenticationError) },
                    { "Order not found", typeof(OrderNotFound) },
                    { "Insufficient balance", typeof(InsufficientFunds) },
                    { "Error 1001 - Order rejected. Order could not be submitted as this order was set to a post only order.", typeof(OrderImmediatelyFillable) },
                } },
                { "exact", new Dictionary<string, object>() {
                    { "400", typeof(BadRequest) },
                    { "403", typeof(AuthenticationError) },
                    { "404", typeof(BadRequest) },
                    { "405", typeof(BadRequest) },
                    { "410", typeof(BadRequest) },
                    { "429", typeof(BadRequest) },
                    { "500", typeof(NetworkError) },
                    { "503", typeof(NetworkError) },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "api-expires", this.parseToInt(divide(this.timeout, 1000)) },
                { "networks", new Dictionary<string, object>() {
                    { "BTC", "btc" },
                    { "ETH", "eth" },
                    { "ERC20", "eth" },
                    { "TRX", "trx" },
                    { "TRC20", "trx" },
                    { "XRP", "xrp" },
                    { "XLM", "xlm" },
                    { "BNB", "bnb" },
                    { "MATIC", "matic" },
                } },
            } },
        });
    }

    /**
     * @method
     * @name hollaex#fetchMarkets
     * @description retrieves data on all markets for hollaex
     * @see https://apidocs.hollaex.com/#constants
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetConstants(parameters);
        //
        //     {
        //         "coins": {
        //             "xmr": {
        //                 "id": 7,
        //                 "fullname": "Monero",
        //                 "symbol": "xmr",
        //                 "active": true,
        //                 "allow_deposit": true,
        //                 "allow_withdrawal": true,
        //                 "withdrawal_fee": 0.02,
        //                 "min": 0.001,
        //                 "max": 100000,
        //                 "increment_unit": 0.001,
        //                 "deposit_limits": { '1': 0, '2': 0, '3': 0, '4': 0, "5": 0, "6": 0 },
        //                 "withdrawal_limits": { '1': 10, '2': 15, '3': 100, '4': 100, '5': 200, '6': 300, '7': 350, '8': 400, "9": 500, "10": -1 },
        //                 "created_at": "2019-12-09T07:14:02.720Z",
        //                 "updated_at": "2020-01-16T12:12:53.162Z"
        //             },
        //             // ...
        //         },
        //         "pairs": {
        //             "btc-usdt": {
        //                 "id": 2,
        //                 "name": "btc-usdt",
        //                 "pair_base": "btc",
        //                 "pair_2": "usdt",
        //                 "taker_fees": { '1': 0.3, '2': 0.25, '3': 0.2, '4': 0.18, '5': 0.1, '6': 0.09, '7': 0.08, '8': 0.06, "9": 0.04, "10": 0 },
        //                 "maker_fees": { '1': 0.1, '2': 0.08, '3': 0.05, '4': 0.03, '5': 0, '6': 0, '7': 0, '8': 0, "9": 0, "10": 0 },
        //                 "min_size": 0.0001,
        //                 "max_size": 1000,
        //                 "min_price": 100,
        //                 "max_price": 100000,
        //                 "increment_size": 0.0001,
        //                 "increment_price": 0.05,
        //                 "active": true,
        //                 "created_at": "2019-12-09T07:15:54.537Z",
        //                 "updated_at": "2019-12-09T07:15:54.537Z"
        //             },
        //         },
        //         "config": { tiers: 10 },
        //         "status": true
        //     }
        //
        object pairs = this.safeValue(response, "pairs", new Dictionary<string, object>() {});
        object keys = new List<object>(((IDictionary<string,object>)pairs).Keys);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object market = getValue(pairs, key);
            object baseId = this.safeString(market, "pair_base");
            object quoteId = this.safeString(market, "pair_2");
            object bs = this.commonCurrencyCode(((string)baseId).ToUpper());
            object quote = this.commonCurrencyCode(((string)quoteId).ToUpper());
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", this.safeString(market, "name") },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", this.safeValue(market, "active") },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.safeNumber(market, "increment_size") },
                    { "price", this.safeNumber(market, "increment_price") },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_size") },
                        { "max", this.safeNumber(market, "max_size") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_price") },
                        { "max", this.safeNumber(market, "max_price") },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", this.parse8601(this.safeString(market, "created_at")) },
                { "info", market },
            });
        }
        return result;
    }

    /**
     * @method
     * @name hollaex#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://apidocs.hollaex.com/#constants
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetConstants(parameters);
        //
        //     {
        //         "coins":{
        //             "bch":{
        //                 "id":4,
        //                 "fullname":"Bitcoin Cash",
        //                 "symbol":"bch",
        //                 "active":true,
        //                 "verified":true,
        //                 "allow_deposit":true,
        //                 "allow_withdrawal":true,
        //                 "withdrawal_fee":0.0002,
        //                 "min":0.001,
        //                 "max":100000,
        //                 "increment_unit":0.001,
        //                 "logo":"https://bitholla.s3.ap-northeast-2.amazonaws.com/icon/BCH-hollaex-asset-01.svg",
        //                 "code":"bch",
        //                 "is_public":true,
        //                 "meta":{},
        //                 "estimated_price":null,
        //                 "description":null,
        //                 "type":"blockchain",
        //                 "network":null,
        //                 "standard":null,
        //                 "issuer":"HollaEx",
        //                 "withdrawal_fees":null,
        //                 "created_at":"2019-08-09T10:45:43.367Z",
        //                 "updated_at":"2021-12-13T03:08:32.372Z",
        //                 "created_by":1,
        //                 "owner_id":1
        //             },
        //         },
        //         "network":"https://api.hollaex.network"
        //     }
        //
        object coins = this.safeValue(response, "coins", new Dictionary<string, object>() {});
        object keys = new List<object>(((IDictionary<string,object>)coins).Keys);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object currency = getValue(coins, key);
            object id = this.safeString(currency, "symbol");
            object numericId = this.safeInteger(currency, "id");
            object code = this.safeCurrencyCode(id);
            object name = this.safeString(currency, "fullname");
            object depositEnabled = this.safeValue(currency, "allow_deposit");
            object withdrawEnabled = this.safeValue(currency, "allow_withdrawal");
            object isActive = this.safeValue(currency, "active");
            object active = isTrue(isTrue(isActive) && isTrue(depositEnabled)) && isTrue(withdrawEnabled);
            object fee = this.safeNumber(currency, "withdrawal_fee");
            object withdrawalLimits = this.safeValue(currency, "withdrawal_limits", new List<object>() {});
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "numericId", numericId },
                { "code", code },
                { "info", currency },
                { "name", name },
                { "active", active },
                { "deposit", depositEnabled },
                { "withdraw", withdrawEnabled },
                { "fee", fee },
                { "precision", this.safeNumber(currency, "increment_unit") },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(currency, "min") },
                        { "max", this.safeNumber(currency, "max") },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", this.safeValue(withdrawalLimits, 0) },
                    } },
                } },
                { "networks", new Dictionary<string, object>() {} },
            };
        }
        return result;
    }

    /**
     * @method
     * @name hollaex#fetchOrderBooks
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data for multiple markets
     * @see https://apidocs.hollaex.com/#orderbooks
     * @param {string[]|undefined} symbols not used by hollaex fetchOrderBooks ()
     * @param {int} [limit] not used by hollaex fetchOrderBooks ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbol
     */
    public async override Task<object> fetchOrderBooks(object symbols = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetOrderbooks(parameters);
        object result = new Dictionary<string, object>() {};
        object marketIds = new List<object>(((IDictionary<string,object>)response).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = getValue(marketIds, i);
            object orderbook = getValue(response, marketId);
            object symbol = this.safeSymbol(marketId, null, "-");
            object timestamp = this.parse8601(this.safeString(orderbook, "timestamp"));
            ((IDictionary<string,object>)result)[(string)symbol] = this.parseOrderBook(getValue(response, marketId), symbol, timestamp);
        }
        return result;
    }

    /**
     * @method
     * @name hollaex#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://apidocs.hollaex.com/#orderbook
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetOrderbook(this.extend(request, parameters));
        //
        //     {
        //         "btc-usdt": {
        //             "bids": [
        //                 [ 8836.4, 1.022 ],
        //                 [ 8800, 0.0668 ],
        //                 [ 8797.75, 0.2398 ],
        //             ],
        //             "asks": [
        //                 [ 8839.35, 1.5334 ],
        //                 [ 8852.6, 0.0579 ],
        //                 [ 8860.45, 0.1815 ],
        //             ],
        //             "timestamp": "2020-03-03T02:27:25.147Z"
        //         },
        //         "eth-usdt": {},
        //         // ...
        //     }
        //
        object orderbook = this.safeValue(response, getValue(market, "id"));
        object timestamp = this.parse8601(this.safeString(orderbook, "timestamp"));
        return this.parseOrderBook(orderbook, getValue(market, "symbol"), timestamp);
    }

    /**
     * @method
     * @name hollaex#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://apidocs.hollaex.com/#ticker
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetTicker(this.extend(request, parameters));
        //
        //     {
        //         "open": 8615.55,
        //         "close": 8841.05,
        //         "high": 8921.1,
        //         "low": 8607,
        //         "last": 8841.05,
        //         "volume": 20.2802,
        //         "timestamp": "2020-03-03T03:11:18.964Z"
        //     }
        //
        return this.parseTicker(response, market);
    }

    /**
     * @method
     * @name hollaex#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://apidocs.hollaex.com/#tickers
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.publicGetTickers(parameters);
        //
        //     {
        //         "bch-usdt": {
        //             "time": "2020-03-02T04:29:45.011Z",
        //             "open": 341.65,
        //             "close":337.9,
        //             "high":341.65,
        //             "low":337.3,
        //             "last":337.9,
        //             "volume":0.054,
        //             "symbol":"bch-usdt"
        //         },
        //         // ...
        //     }
        //
        return this.parseTickers(response, symbols);
    }

    public override object parseTickers(object tickers, object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object result = new Dictionary<string, object>() {};
        object keys = new List<object>(((IDictionary<string,object>)tickers).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object ticker = getValue(tickers, key);
            object marketId = this.safeString(ticker, "symbol", key);
            object market = this.safeMarket(marketId, null, "-");
            object symbol = getValue(market, "symbol");
            ((IDictionary<string,object>)result)[(string)symbol] = this.extend(this.parseTicker(ticker, market), parameters);
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // fetchTicker
        //
        //     {
        //         "open": 8615.55,
        //         "close": 8841.05,
        //         "high": 8921.1,
        //         "low": 8607,
        //         "last": 8841.05,
        //         "volume": 20.2802,
        //         "timestamp": "2020-03-03T03:11:18.964Z",
        //     }
        //
        // fetchTickers
        //
        //     {
        //         "time": "2020-03-02T04:29:45.011Z",
        //         "open": 341.65,
        //         "close": 337.9,
        //         "high": 341.65,
        //         "low": 337.3,
        //         "last": 337.9,
        //         "volume": 0.054,
        //         "symbol": "bch-usdt"
        //     }
        //
        object marketId = this.safeString(ticker, "symbol");
        market = this.safeMarket(marketId, market, "-");
        object symbol = getValue(market, "symbol");
        object timestamp = this.parse8601(this.safeString2(ticker, "time", "timestamp"));
        object close = this.safeString(ticker, "close");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "info", ticker },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", null },
            { "bidVolume", null },
            { "ask", null },
            { "askVolume", null },
            { "vwap", null },
            { "open", this.safeString(ticker, "open") },
            { "close", close },
            { "last", this.safeString(ticker, "last", close) },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "volume") },
            { "quoteVolume", null },
        }, market);
    }

    /**
     * @method
     * @name hollaex#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://apidocs.hollaex.com/#trades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetTrades(this.extend(request, parameters));
        //
        //     {
        //         "btc-usdt": [
        //             {
        //                 "size": 0.5,
        //                 "price": 8830,
        //                 "side": "buy",
        //                 "timestamp": "2020-03-03T04:44:33.034Z"
        //             },
        //             // ...
        //         ]
        //     }
        //
        object trades = this.safeList(response, getValue(market, "id"), new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //     {
        //         "size": 0.5,
        //         "price": 8830,
        //         "side": "buy",
        //         "timestamp": "2020-03-03T04:44:33.034Z"
        //     }
        //
        // fetchMyTrades (private)
        //  {
        //      "side":"sell",
        //      "symbol":"doge-usdt",
        //      "size":70,
        //      "price":0.147411,
        //      "timestamp":"2022-01-26T17:53:34.650Z",
        //      "order_id":"cba78ecb-4187-4da2-9d2f-c259aa693b5a",
        //      "fee":0.01031877,"fee_coin":"usdt"
        //  }
        //
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market, "-");
        object symbol = getValue(market, "symbol");
        object datetime = this.safeString(trade, "timestamp");
        object timestamp = this.parse8601(datetime);
        object side = this.safeString(trade, "side");
        object orderId = this.safeString(trade, "order_id");
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString(trade, "size");
        object feeCostString = this.safeString(trade, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", getValue(market, "quote") },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", null },
            { "timestamp", timestamp },
            { "datetime", datetime },
            { "symbol", symbol },
            { "order", orderId },
            { "type", null },
            { "side", side },
            { "takerOrMaker", null },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    /**
     * @method
     * @name hollaex#fetchTradingFees
     * @description fetch the trading fees for multiple markets
     * @see https://apidocs.hollaex.com/#tiers
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
     */
    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetTiers(parameters);
        //
        //     {
        //         "1": {
        //             "id": "1",
        //             "name": "Silver",
        //             "icon": '',
        //             "description": "Your crypto journey starts here! Make your first deposit to start trading, and verify your account to level up!",
        //             "deposit_limit": "0",
        //             "withdrawal_limit": "1000",
        //             "fees": {
        //                 "maker": {
        //                     'eth-btc': "0.1",
        //                     'ada-usdt': "0.1",
        //                     ...
        //                 },
        //                 "taker": {
        //                     'eth-btc': "0.1",
        //                     'ada-usdt': "0.1",
        //                     ...
        //                 }
        //             },
        //             "note": "<ul>\n<li>Login and verify email</li>\n</ul>\n",
        //             "created_at": "2021-03-22T03:51:39.129Z",
        //             "updated_at": "2021-11-01T02:51:56.214Z"
        //         },
        //         ...
        //     }
        //
        object firstTier = this.safeValue(response, "1", new Dictionary<string, object>() {});
        object fees = this.safeValue(firstTier, "fees", new Dictionary<string, object>() {});
        object makerFees = this.safeValue(fees, "maker", new Dictionary<string, object>() {});
        object takerFees = this.safeValue(fees, "taker", new Dictionary<string, object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(this.symbols, i);
            object market = this.market(symbol);
            object makerString = this.safeString(makerFees, getValue(market, "id"));
            object takerString = this.safeString(takerFees, getValue(market, "id"));
            ((IDictionary<string,object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "info", fees },
                { "symbol", symbol },
                { "maker", this.parseNumber(Precise.stringDiv(makerString, "100")) },
                { "taker", this.parseNumber(Precise.stringDiv(takerString, "100")) },
                { "percentage", true },
                { "tierBased", true },
            };
        }
        return result;
    }

    /**
     * @method
     * @name hollaex#fetchOHLCV
     * @description hollaex has large gaps between candles, so it's recommended to specify since
     * @see https://apidocs.hollaex.com/#chart
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "resolution", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        object until = this.safeInteger(parameters, "until");
        object end = this.seconds();
        if (isTrue(!isEqual(until, null)))
        {
            end = this.parseToInt(divide(until, 1000));
        }
        object defaultSpan = 2592000; // 30 days
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = this.parseToInt(divide(since, 1000));
        } else
        {
            ((IDictionary<string,object>)request)["from"] = subtract(end, defaultSpan);
        }
        ((IDictionary<string,object>)request)["to"] = end;
        parameters = this.omit(parameters, "until");
        object response = await this.publicGetChart(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "time":"2020-03-02T20:00:00.000Z",
        //             "close":8872.1,
        //             "high":8872.1,
        //             "low":8858.6,
        //             "open":8858.6,
        //             "symbol":"btc-usdt",
        //             "volume":1.2922
        //         },
        //     ]
        //
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "time":"2020-03-02T20:00:00.000Z",
        //         "close":8872.1,
        //         "high":8872.1,
        //         "low":8858.6,
        //         "open":8858.6,
        //         "symbol":"btc-usdt",
        //         "volume":1.2922
        //     }
        //
        return new List<object> {this.parse8601(this.safeString(ohlcv, "time")), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    public override object parseBalance(object response)
    {
        object timestamp = this.parse8601(this.safeString(response, "updated_at"));
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
        object currencyIds = new List<object>(((IDictionary<string,object>)this.currencies_by_id).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencyIds, i);
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(response, add(currencyId, "_available"));
            ((IDictionary<string,object>)account)["total"] = this.safeString(response, add(currencyId, "_balance"));
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name hollaex#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://apidocs.hollaex.com/#get-balance
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetUserBalance(parameters);
        //
        //     {
        //         "updated_at": "2020-03-02T22:27:38.428Z",
        //         "btc_balance": 0,
        //         "btc_pending": 0,
        //         "btc_available": 0,
        //         "eth_balance": 0,
        //         "eth_pending": 0,
        //         "eth_available": 0,
        //         // ...
        //     }
        //
        return this.parseBalance(response);
    }

    /**
     * @method
     * @name hollaex#fetchOpenOrder
     * @description fetch an open order by it's id
     * @see https://apidocs.hollaex.com/#get-order
     * @param {string} id order id
     * @param {string} symbol not used by hollaex fetchOpenOrder ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchOpenOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        object response = await this.privateGetOrder(this.extend(request, parameters));
        //
        //     {
        //         "id": "string",
        //         "side": "sell",
        //         "symbol": "xht-usdt",
        //         "size": 0.1,
        //         "filled": 0,
        //         "stop": null,
        //         "fee": 0,
        //         "fee_coin": "usdt",
        //         "type": "limit",
        //         "price": 1.09,
        //         "status": "new",
        //         "created_by": 116,
        //         "created_at": "2021-02-17T02:32:38.910Z",
        //         "updated_at": "2021-02-17T02:32:38.910Z",
        //         "User": {
        //             "id": 116,
        //             "email": "fight@club.com",
        //             "username": "narrator",
        //             "exchange_id": 176
        //         }
        //     }
        //
        return this.parseOrder(response);
    }

    /**
     * @method
     * @name hollaex#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://apidocs.hollaex.com/#get-all-orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of  open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "open", true },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    /**
     * @method
     * @name hollaex#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://apidocs.hollaex.com/#get-all-orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "open", false },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    /**
     * @method
     * @name hollaex#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://apidocs.hollaex.com/#get-order
     * @param {string} id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        object response = await this.privateGetOrder(this.extend(request, parameters));
        //             {
        //                 "id": "string",
        //                 "side": "sell",
        //                 "symbol": "xht-usdt",
        //                 "size": 0.1,
        //                 "filled": 0,
        //                 "stop": null,
        //                 "fee": 0,
        //                 "fee_coin": "usdt",
        //                 "type": "limit",
        //                 "price": 1.09,
        //                 "status": "new",
        //                 "created_by": 116,
        //                 "created_at": "2021-02-17T02:32:38.910Z",
        //                 "updated_at": "2021-02-17T02:32:38.910Z",
        //                 "User": {
        //                     "id": 116,
        //                     "email": "fight@club.com",
        //                     "username": "narrator",
        //                     "exchange_id": 176
        //                 }
        //             }
        object order = response;
        if (isTrue(isEqual(order, null)))
        {
            throw new OrderNotFound ((string)add(add(this.id, " fetchOrder() could not find order id "), id)) ;
        }
        return this.parseOrder(order);
    }

    /**
     * @method
     * @name hollaex#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @see https://apidocs.hollaex.com/#get-all-orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_date"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 50, max 100
        }
        object response = await this.privateGetOrders(this.extend(request, parameters));
        //
        //     {
        //         "count": 1,
        //         "data": [
        //             {
        //                 "id": "string",
        //                 "side": "sell",
        //                 "symbol": "xht-usdt",
        //                 "size": 0.1,
        //                 "filled": 0,
        //                 "stop": null,
        //                 "fee": 0,
        //                 "fee_coin": "usdt",
        //                 "type": "limit",
        //                 "price": 1.09,
        //                 "status": "new",
        //                 "created_by": 116,
        //                 "created_at": "2021-02-17T02:32:38.910Z",
        //                 "updated_at": "2021-02-17T02:32:38.910Z",
        //                 "User": {
        //                     "id": 116,
        //                     "email": "fight@club.com",
        //                     "username": "narrator",
        //                     "exchange_id": 176
        //                 }
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "new", "open" },
            { "pfilled", "open" },
            { "filled", "closed" },
            { "canceled", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder, fetchOpenOrder, fetchOpenOrders
        //
        //     {
        //          "id":"10644b7e-3c90-4ba9-bc3b-188f3a4e9cfd",
        //          "created_by":140093,
        //          "exchange_id":22,
        //          "side":"buy",
        //          "symbol":"doge-usdt",
        //          "type":"limit",
        //          "price":0.05,
        //          "size":10,
        //          "stop":null,
        //          "filled":0,
        //          "status":"canceled",
        //          "fee":0,
        //          "fee_coin":"doge",
        //          "meta": {                 // optional field only returned for postOnly orders
        //              "post_only":true
        //          },
        //          "fee_structure": {
        //              "maker":0.1,
        //              "taker":0.1
        //          },
        //          "created_at":"2022-05-31T08:14:14.747Z",
        //          "updated_at":"2022-05-31T08:14:23.727Z"
        //      }
        //
        object marketId = this.safeString(order, "symbol");
        object symbol = this.safeSymbol(marketId, market, "-");
        object id = this.safeString(order, "id");
        object timestamp = this.parse8601(this.safeString(order, "created_at"));
        object type = this.safeString(order, "type");
        object side = this.safeString(order, "side");
        object price = this.safeString(order, "price");
        object amount = this.safeString(order, "size");
        object filled = this.safeString(order, "filled");
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object meta = this.safeValue(order, "meta", new Dictionary<string, object>() {});
        object postOnly = this.safeBool(meta, "post_only", false);
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "status", status },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", postOnly },
            { "side", side },
            { "price", price },
            { "triggerPrice", this.safeString(order, "stop") },
            { "amount", amount },
            { "filled", filled },
            { "remaining", null },
            { "cost", null },
            { "trades", null },
            { "fee", null },
            { "info", order },
            { "average", null },
        }, market);
    }

    /**
     * @method
     * @name hollaex#createOrder
     * @description create a trade order
     * @see https://apidocs.hollaex.com/#create-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.triggerPrice] the price at which a trigger order is triggered at
     * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object convertedAmount = parseFloat(this.amountToPrecision(symbol, amount));
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", side },
            { "size", this.normalizeNumberIfNeeded(convertedAmount) },
            { "type", type },
        };
        object triggerPrice = this.safeNumberN(parameters, new List<object>() {"triggerPrice", "stopPrice", "stop"});
        object meta = this.safeValue(parameters, "meta", new Dictionary<string, object>() {});
        object exchangeSpecificParam = this.safeBool(meta, "post_only", false);
        object isMarketOrder = isEqual(type, "market");
        object postOnly = this.isPostOnly(isMarketOrder, exchangeSpecificParam, parameters);
        if (!isTrue(isMarketOrder))
        {
            object convertedPrice = parseFloat(this.priceToPrecision(symbol, price));
            ((IDictionary<string,object>)request)["price"] = this.normalizeNumberIfNeeded(convertedPrice);
        }
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((IDictionary<string,object>)request)["stop"] = this.normalizeNumberIfNeeded(parseFloat(this.priceToPrecision(symbol, triggerPrice)));
        }
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["meta"] = new Dictionary<string, object>() {
                { "post_only", true },
            };
        }
        parameters = this.omit(parameters, new List<object>() {"postOnly", "timeInForce", "stopPrice", "triggerPrice", "stop"});
        object response = await this.privatePostOrder(this.extend(request, parameters));
        //
        //     {
        //         "fee": 0,
        //         "meta": {},
        //         "symbol": "xht-usdt",
        //         "side": "sell",
        //         "size": 0.1,
        //         "type": "limit",
        //         "price": 1,
        //         "fee_structure": {
        //             "maker": 0.2,
        //             "taker": 0.2
        //         },
        //         "fee_coin": "usdt",
        //         "id": "string",
        //         "created_by": 116,
        //         "filled": 0,
        //         "status": "new",
        //         "updated_at": "2021-02-17T03:03:19.231Z",
        //         "created_at": "2021-02-17T03:03:19.231Z",
        //         "stop": null
        //     }
        //
        return this.parseOrder(response, market);
    }

    /**
     * @method
     * @name hollaex#cancelOrder
     * @description cancels an open order
     * @see https://apidocs.hollaex.com/#cancel-order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        object response = await this.privateDeleteOrder(this.extend(request, parameters));
        //
        //     {
        //         "title": "string",
        //         "symbol": "xht-usdt",
        //         "side": "sell",
        //         "size": 1,
        //         "type": "limit",
        //         "price": 0.1,
        //         "id": "string",
        //         "created_by": 34,
        //         "filled": 0
        //     }
        //
        return this.parseOrder(response);
    }

    /**
     * @method
     * @name hollaex#cancelAllOrders
     * @description cancel all open orders in a market
     * @see https://apidocs.hollaex.com/#cancel-all-orders
     * @param {string} symbol unified market symbol of the market to cancel orders in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        market = this.market(symbol);
        ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        object response = await this.privateDeleteOrderAll(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "title": "string",
        //             "symbol": "xht-usdt",
        //             "side": "sell",
        //             "size": 1,
        //             "type": "limit",
        //             "price": 0.1,
        //             "id": "string",
        //             "created_by": 34,
        //             "filled": 0
        //         }
        //     ]
        //
        return this.parseOrders(response, market);
    }

    /**
     * @method
     * @name hollaex#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://apidocs.hollaex.com/#get-trades
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 50, max 100
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_date"] = this.iso8601(since);
        }
        object response = await this.privateGetUserTrades(this.extend(request, parameters));
        //
        //     {
        //         "count": 1,
        //         "data": [
        //             {
        //                 "side": "buy",
        //                 "symbol": "eth-usdt",
        //                 "size": 0.086,
        //                 "price": 226.19,
        //                 "timestamp": "2020-03-03T08:03:55.459Z",
        //                 "fee": 0.1
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "currency":"usdt",
        //         "address":"TECLD9XBH31XpyykdHU3uEAeUK7E6Lrmik",
        //         "network":"trx",
        //         "standard":null,
        //         "is_valid":true,
        //         "created_at":"2021-05-12T02:43:05.446Z"
        //     }
        //
        object address = this.safeString(depositAddress, "address");
        object tag = null;
        if (isTrue(!isEqual(address, null)))
        {
            object parts = ((string)address).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
            address = this.safeString(parts, 0);
            tag = this.safeString(parts, 1);
        }
        this.checkAddress(address);
        object currencyId = this.safeString(depositAddress, "currency");
        currency = this.safeCurrency(currencyId, currency);
        object network = this.safeString(depositAddress, "network");
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", getValue(currency, "code") },
            { "network", network },
            { "address", address },
            { "tag", tag },
        };
    }

    /**
     * @method
     * @name hollaex#fetchDepositAddresses
     * @description fetch deposit addresses for multiple currencies and chain types
     * @see https://apidocs.hollaex.com/#get-user
     * @param {string[]|undefined} codes list of unified currency codes, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddresses(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object network = this.safeString(parameters, "network");
        parameters = this.omit(parameters, "network");
        object response = await this.privateGetUser(parameters);
        //
        //     {
        //         "id":620,
        //         "email":"igor.kroitor@gmail.com",
        //         "full_name":"",
        //         "gender":false,
        //         "nationality":"",
        //         "dob":null,
        //         "phone_number":"",
        //         "address":{"city":"","address":"","country":"","postal_code":""},
        //         "id_data":{"note":"","type":"","number":"","status":0,"issued_date":"","expiration_date":""},
        //         "bank_account":[],
        //         "crypto_wallet":{},
        //         "verification_level":1,
        //         "email_verified":true,
        //         "otp_enabled":true,
        //         "activated":true,
        //         "username":"igor.kroitor",
        //         "affiliation_code":"QSWA6G",
        //         "settings":{
        //             "chat":{"set_username":false},
        //             "risk":{"popup_warning":false,"order_portfolio_percentage":20},
        //             "audio":{"public_trade":false,"order_completed":true,"order_partially_completed":true},
        //             "language":"en",
        //             "interface":{"theme":"white","order_book_levels":10},
        //             "notification":{"popup_order_completed":true,"popup_order_confirmation":true,"popup_order_partially_filled":true}
        //         },
        //         "affiliation_rate":0,
        //         "network_id":10620,
        //         "discount":0,
        //         "created_at":"2021-03-24T02:37:57.379Z",
        //         "updated_at":"2021-03-24T02:37:57.379Z",
        //         "balance":{
        //             "btc_balance":0,
        //             "btc_available":0,
        //             "eth_balance":0.000914,
        //             "eth_available":0.000914,
        //             "updated_at":"2020-03-04T04:03:27.174Z
        //         "},
        //         "wallet":[
        //             {"currency":"usdt","address":"TECLD9XBH31XpyykdHU3uEAeUK7E6Lrmik","network":"trx","standard":null,"is_valid":true,"created_at":"2021-05-12T02:43:05.446Z"},
        //             {"currency":"xrp","address":"rGcSzmuRx8qngPRnrvpCKkP9V4njeCPGCv:286741597","network":"xrp","standard":null,"is_valid":true,"created_at":"2021-05-12T02:49:01.273Z"}
        //         ]
        //     }
        //
        object wallet = this.safeValue(response, "wallet", new List<object>() {});
        object addresses = ((bool) isTrue((isEqual(network, null)))) ? wallet : this.filterBy(wallet, "network", network);
        return this.parseDepositAddresses(addresses, codes);
    }

    /**
     * @method
     * @name hollaex#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://apidocs.hollaex.com/#get-deposits
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 50, max 100
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_date"] = this.iso8601(since);
        }
        object response = await this.privateGetUserDeposits(this.extend(request, parameters));
        //
        //     {
        //         "count": 1,
        //         "data": [
        //             {
        //                 "id": 539,
        //                 "amount": 20,
        //                 "fee": 0,
        //                 "address": "0x5c0cc98270d7089408fcbcc8e2131287f5be2306",
        //                 "transaction_id": "0xd4006327a5ec2c41adbdcf566eaaba6597c3d45906abe78ea1a4a022647c2e28",
        //                 "status": true,
        //                 "dismissed": false,
        //                 "rejected": false,
        //                 "description": "",
        //                 "type": "deposit",
        //                 "currency": "usdt",
        //                 "created_at": "2020-03-03T07:56:36.198Z",
        //                 "updated_at": "2020-03-03T08:00:05.674Z",
        //                 "user_id": 620
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit);
    }

    /**
     * @method
     * @name hollaex#fetchWithdrawal
     * @description fetch data on a currency withdrawal via the withdrawal id
     * @see https://apidocs.hollaex.com/#get-withdrawals
     * @param {string} id withdrawal id
     * @param {string} code unified currency code of the currency withdrawn, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async virtual Task<object> fetchWithdrawal(object id, object code = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "transaction_id", id },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        object response = await this.privateGetUserWithdrawals(this.extend(request, parameters));
        //
        //     {
        //         "count": 1,
        //         "data": [
        //             {
        //                 "id": 539,
        //                 "amount": 20,
        //                 "fee": 0,
        //                 "address": "0x5c0cc98270d7089408fcbcc8e2131287f5be2306",
        //                 "transaction_id": "0xd4006327a5ec2c41adbdcf566eaaba6597c3d45906abe78ea1a4a022647c2e28",
        //                 "status": true,
        //                 "dismissed": false,
        //                 "rejected": false,
        //                 "description": "",
        //                 "type": "withdrawal",
        //                 "currency": "usdt",
        //                 "created_at": "2020-03-03T07:56:36.198Z",
        //                 "updated_at": "2020-03-03T08:00:05.674Z",
        //                 "user_id": 620
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object transaction = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseTransaction(transaction, currency);
    }

    /**
     * @method
     * @name hollaex#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://apidocs.hollaex.com/#get-withdrawals
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 50, max 100
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_date"] = this.iso8601(since);
        }
        object response = await this.privateGetUserWithdrawals(this.extend(request, parameters));
        //
        //     {
        //         "count": 1,
        //         "data": [
        //             {
        //                 "id": 539,
        //                 "amount": 20,
        //                 "fee": 0,
        //                 "address": "0x5c0cc98270d7089408fcbcc8e2131287f5be2306",
        //                 "transaction_id": "0xd4006327a5ec2c41adbdcf566eaaba6597c3d45906abe78ea1a4a022647c2e28",
        //                 "status": true,
        //                 "dismissed": false,
        //                 "rejected": false,
        //                 "description": "",
        //                 "type": "withdrawal",
        //                 "currency": "usdt",
        //                 "created_at": "2020-03-03T07:56:36.198Z",
        //                 "updated_at": "2020-03-03T08:00:05.674Z",
        //                 "user_id": 620
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchWithdrawals, fetchDeposits
        //
        //     {
        //         "id": 539,
        //         "amount": 20,
        //         "fee": 0,
        //         "address": "0x5c0cc98270d7089408fcbcc8e2131287f5be2306",
        //         "transaction_id": "0xd4006327a5ec2c41adbdcf566eaaba6597c3d45906abe78ea1a4a022647c2e28",
        //         "status": true,
        //         "dismissed": false,
        //         "rejected": false,
        //         "description": "",
        //         "type": "withdrawal",
        //         "currency": "usdt",
        //         "created_at": "2020-03-03T07:56:36.198Z",
        //         "updated_at": "2020-03-03T08:00:05.674Z",
        //         "user_id": 620
        //     }
        //
        // withdraw
        //
        //     {
        //         "message": "Withdrawal request is in the queue and will be processed.",
        //         "transaction_id": "1d1683c3-576a-4d53-8ff5-27c93fd9758a",
        //         "amount": 1,
        //         "currency": "xht",
        //         "fee": 0,
        //         "fee_coin": "xht"
        //     }
        //
        object id = this.safeString(transaction, "id");
        object txid = this.safeString(transaction, "transaction_id");
        object timestamp = this.parse8601(this.safeString(transaction, "created_at"));
        object updated = this.parse8601(this.safeString(transaction, "updated_at"));
        object type = this.safeString(transaction, "type");
        object amount = this.safeNumber(transaction, "amount");
        object address = this.safeString(transaction, "address");
        object addressTo = null;
        object addressFrom = null;
        object tag = null;
        object tagTo = null;
        object tagFrom = null;
        if (isTrue(!isEqual(address, null)))
        {
            object parts = ((string)address).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
            address = this.safeString(parts, 0);
            tag = this.safeString(parts, 1);
            addressTo = address;
            tagTo = tag;
        }
        object currencyId = this.safeString(transaction, "currency");
        currency = this.safeCurrency(currencyId, currency);
        object status = this.safeValue(transaction, "status");
        object dismissed = this.safeValue(transaction, "dismissed");
        object rejected = this.safeValue(transaction, "rejected");
        if (isTrue(status))
        {
            status = "ok";
        } else if (isTrue(dismissed))
        {
            status = "canceled";
        } else if (isTrue(rejected))
        {
            status = "failed";
        } else
        {
            status = "pending";
        }
        object feeCurrencyId = this.safeString(transaction, "fee_coin");
        object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId, currency);
        object feeCost = this.safeNumber(transaction, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "currency", feeCurrencyCode },
                { "cost", feeCost },
            };
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", null },
            { "addressFrom", addressFrom },
            { "address", address },
            { "addressTo", addressTo },
            { "tagFrom", tagFrom },
            { "tag", tag },
            { "tagTo", tagTo },
            { "type", type },
            { "amount", amount },
            { "currency", getValue(currency, "code") },
            { "status", status },
            { "updated", updated },
            { "comment", this.safeString(transaction, "message") },
            { "internal", null },
            { "fee", fee },
        };
    }

    /**
     * @method
     * @name hollaex#withdraw
     * @description make a withdrawal
     * @see https://apidocs.hollaex.com/#withdrawal
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        if (isTrue(!isEqual(tag, null)))
        {
            address = add(address, add(":", tag));
        }
        object network = this.safeString(parameters, "network");
        if (isTrue(isEqual(network, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " withdraw() requires a network parameter")) ;
        }
        parameters = this.omit(parameters, "network");
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", amount },
            { "address", address },
            { "network", this.networkCodeToId(network, code) },
        };
        object response = await this.privatePostUserWithdrawal(this.extend(request, parameters));
        //
        //     {
        //         "message": "Withdrawal request is in the queue and will be processed.",
        //         "transaction_id": "1d1683c3-576a-4d53-8ff5-27c93fd9758a",
        //         "amount": 1,
        //         "currency": "xht",
        //         "fee": 0,
        //         "fee_coin": "xht"
        //     }
        //
        return this.parseTransaction(response, currency);
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //    "bch":{
        //        "id":4,
        //        "fullname":"Bitcoin Cash",
        //        "symbol":"bch",
        //        "active":true,
        //        "verified":true,
        //        "allow_deposit":true,
        //        "allow_withdrawal":true,
        //        "withdrawal_fee":0.0001,
        //        "min":0.001,
        //        "max":100000,
        //        "increment_unit":0.001,
        //        "logo":"https://bitholla.s3.ap-northeast-2.amazonaws.com/icon/BCH-hollaex-asset-01.svg",
        //        "code":"bch",
        //        "is_public":true,
        //        "meta":{},
        //        "estimated_price":null,
        //        "description":null,
        //        "type":"blockchain",
        //        "network":null,
        //        "standard":null,
        //        "issuer":"HollaEx",
        //        "withdrawal_fees":null,
        //        "created_at":"2019-08-09T10:45:43.367Z",
        //        "updated_at":"2021-12-13T03:08:32.372Z",
        //        "created_by":1,
        //        "owner_id":1
        //    }
        //
        object result = new Dictionary<string, object>() {
            { "info", fee },
            { "withdraw", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
        object allowWithdrawal = this.safeValue(fee, "allow_withdrawal");
        if (isTrue(allowWithdrawal))
        {
            ((IDictionary<string,object>)result)["withdraw"] = new Dictionary<string, object>() {
                { "fee", this.safeNumber(fee, "withdrawal_fee") },
                { "percentage", false },
            };
        }
        object withdrawalFees = this.safeValue(fee, "withdrawal_fees");
        if (isTrue(!isEqual(withdrawalFees, null)))
        {
            object keys = new List<object>(((IDictionary<string,object>)withdrawalFees).Keys);
            object keysLength = getArrayLength(keys);
            for (object i = 0; isLessThan(i, keysLength); postFixIncrement(ref i))
            {
                object key = getValue(keys, i);
                object value = getValue(withdrawalFees, key);
                object currencyId = this.safeString(value, "symbol");
                object currencyCode = this.safeCurrencyCode(currencyId);
                object networkCode = this.networkIdToCode(key, currencyCode);
                object networkCodeUpper = ((string)networkCode).ToUpper(); // default to the upper case network code
                object withdrawalFee = this.safeNumber(value, "value");
                ((IDictionary<string,object>)getValue(result, "networks"))[(string)networkCodeUpper] = new Dictionary<string, object>() {
                    { "deposit", null },
                    { "withdraw", withdrawalFee },
                };
            }
        }
        return result;
    }

    /**
     * @method
     * @name hollaex#fetchDepositWithdrawFees
     * @description fetch deposit and withdraw fees
     * @see https://apidocs.hollaex.com/#constants
     * @param {string[]|undefined} codes list of unified currency codes
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetConstants(parameters);
        //
        //     {
        //         "coins":{
        //             "bch":{
        //                 "id":4,
        //                 "fullname":"Bitcoin Cash",
        //                 "symbol":"bch",
        //                 "active":true,
        //                 "verified":true,
        //                 "allow_deposit":true,
        //                 "allow_withdrawal":true,
        //                 "withdrawal_fee":0.0001,
        //                 "min":0.001,
        //                 "max":100000,
        //                 "increment_unit":0.001,
        //                 "logo":"https://bitholla.s3.ap-northeast-2.amazonaws.com/icon/BCH-hollaex-asset-01.svg",
        //                 "code":"bch",
        //                 "is_public":true,
        //                 "meta":{},
        //                 "estimated_price":null,
        //                 "description":null,
        //                 "type":"blockchain",
        //                 "network":null,
        //                 "standard":null,
        //                 "issuer":"HollaEx",
        //                 "withdrawal_fees":null,
        //                 "created_at":"2019-08-09T10:45:43.367Z",
        //                 "updated_at":"2021-12-13T03:08:32.372Z",
        //                 "created_by":1,
        //                 "owner_id":1
        //             },
        //         },
        //         "network":"https://api.hollaex.network"
        //     }
        //
        object coins = this.safeDict(response, "coins", new Dictionary<string, object>() {});
        return this.parseDepositWithdrawFees(coins, codes, "symbol");
    }

    public virtual object normalizeNumberIfNeeded(object number)
    {
        if (isTrue(this.isRoundNumber(number)))
        {
            number = parseInt(number);
        }
        return number;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object query = this.omit(parameters, this.extractParams(path));
        path = add(add(add("/", this.version), "/"), this.implodeParams(path, parameters));
        if (isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE")))))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                path = add(path, add("?", this.urlencode(query)));
            }
        }
        object url = add(getValue(getValue(this.urls, "api"), "rest"), path);
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object defaultExpires = this.safeInteger2(this.options, "api-expires", "expires", this.parseToInt(divide(this.timeout, 1000)));
            object expires = this.sum(this.seconds(), defaultExpires);
            object expiresString = ((object)expires).ToString();
            object auth = add(add(method, path), expiresString);
            headers = new Dictionary<string, object>() {
                { "api-key", this.apiKey },
                { "api-expires", expiresString },
            };
            if (isTrue(isEqual(method, "POST")))
            {
                ((IDictionary<string,object>)headers)["Content-type"] = "application/json";
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    body = this.json(query);
                    auth = add(auth, body);
                }
            }
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
            ((IDictionary<string,object>)headers)["api-signature"] = signature;
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        // { "message": "Invalid token" }
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        if (isTrue(isTrue((isGreaterThanOrEqual(code, 400))) && isTrue((isLessThanOrEqual(code, 503)))))
        {
            //
            //  { "message": "Invalid token" }
            //
            // different errors return the same code eg
            //
            //  { "message":"Error 1001 - Order rejected. Order could not be submitted as this order was set to a post only order." }
            //
            //  { "message":"Error 1001 - POST ONLY order can not be of type market" }
            //
            object feedback = add(add(this.id, " "), body);
            object message = this.safeString(response, "message");
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            object status = ((object)code).ToString();
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), status, feedback);
        }
        return null;
    }
}
