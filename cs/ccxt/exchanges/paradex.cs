namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class paradex : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "paradex" },
            { "name", "Paradex" },
            { "countries", new List<object>() {} },
            { "version", "v1" },
            { "rateLimit", 50 },
            { "certified", false },
            { "pro", true },
            { "dex", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", false },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "borrowCrossMargin", false },
                { "borrowIsolatedMargin", false },
                { "cancelAllOrders", true },
                { "cancelAllOrdersAfter", false },
                { "cancelOrder", false },
                { "cancelOrders", false },
                { "cancelOrdersForSymbols", false },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createMarketBuyOrderWithCost", false },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", false },
                { "createReduceOnlyOrder", false },
                { "editOrder", false },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrders", false },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", false },
                { "fetchDepositAddress", false },
                { "fetchDepositAddresses", false },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", false },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLedger", false },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchLiquidations", true },
                { "fetchMarginMode", null },
                { "fetchMarketLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyLiquidations", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchOrderTrades", false },
                { "fetchPosition", true },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", false },
                { "sandbox", true },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "transfer", false },
                { "withdraw", false },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", 1 },
                { "3m", 3 },
                { "5m", 5 },
                { "15m", 15 },
                { "30m", 30 },
                { "1h", 60 },
            } },
            { "hostname", "paradex.trade" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/84628770-784e-4ec4-a759-ec2fbb2244ea" },
                { "api", new Dictionary<string, object>() {
                    { "v1", "https://api.prod.{hostname}/v1" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "v1", "https://api.testnet.{hostname}/v1" },
                } },
                { "www", "https://www.paradex.trade/" },
                { "doc", "https://docs.api.testnet.paradex.trade/" },
                { "fees", "https://docs.paradex.trade/getting-started/trading-fees" },
                { "referral", "https://app.paradex.trade/r/ccxt24" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "bbo/{market}", 1 },
                        { "funding/data", 1 },
                        { "markets", 1 },
                        { "markets/klines", 1 },
                        { "markets/summary", 1 },
                        { "orderbook/{market}", 1 },
                        { "insurance", 1 },
                        { "referrals/config", 1 },
                        { "system/config", 1 },
                        { "system/state", 1 },
                        { "system/time", 1 },
                        { "trades", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "account", 1 },
                        { "account/profile", 1 },
                        { "balance", 1 },
                        { "fills", 1 },
                        { "funding/payments", 1 },
                        { "positions", 1 },
                        { "tradebusts", 1 },
                        { "transactions", 1 },
                        { "liquidations", 1 },
                        { "orders", 1 },
                        { "orders-history", 1 },
                        { "orders/by_client_id/{client_id}", 1 },
                        { "orders/{order_id}", 1 },
                        { "points_data/{market}/{program}", 1 },
                        { "referrals/summary", 1 },
                        { "transfers", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "account/profile/referral_code", 1 },
                        { "account/profile/username", 1 },
                        { "auth", 1 },
                        { "onboarding", 1 },
                        { "orders", 1 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "orders", 1 },
                        { "orders/by_client_id/{client_id}", 1 },
                        { "orders/{order_id}", 1 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "swap", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.0002") },
                    { "maker", this.parseNumber("0.0002") },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.0002") },
                    { "maker", this.parseNumber("0.0002") },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", false },
                { "secret", false },
                { "walletAddress", true },
                { "privateKey", true },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "VALIDATION_ERROR", typeof(AuthenticationError) },
                    { "BINDING_ERROR", typeof(OperationRejected) },
                    { "INTERNAL_ERROR", typeof(ExchangeError) },
                    { "NOT_FOUND", typeof(BadRequest) },
                    { "SERVICE_UNAVAILABLE", typeof(ExchangeError) },
                    { "INVALID_REQUEST_PARAMETER", typeof(BadRequest) },
                    { "ORDER_ID_NOT_FOUND", typeof(InvalidOrder) },
                    { "ORDER_IS_CLOSED", typeof(InvalidOrder) },
                    { "ORDER_IS_NOT_OPEN_YET", typeof(InvalidOrder) },
                    { "CLIENT_ORDER_ID_NOT_FOUND", typeof(InvalidOrder) },
                    { "DUPLICATED_CLIENT_ID", typeof(InvalidOrder) },
                    { "INVALID_PRICE_PRECISION", typeof(OperationRejected) },
                    { "INVALID_SYMBOL", typeof(OperationRejected) },
                    { "INVALID_TOKEN", typeof(OperationRejected) },
                    { "INVALID_ETHEREUM_ADDRESS", typeof(OperationRejected) },
                    { "INVALID_ETHEREUM_SIGNATURE", typeof(OperationRejected) },
                    { "INVALID_STARKNET_ADDRESS", typeof(OperationRejected) },
                    { "INVALID_STARKNET_SIGNATURE", typeof(OperationRejected) },
                    { "STARKNET_SIGNATURE_VERIFICATION_FAILED", typeof(AuthenticationError) },
                    { "BAD_STARKNET_REQUEST", typeof(BadRequest) },
                    { "ETHEREUM_SIGNER_MISMATCH", typeof(BadRequest) },
                    { "ETHEREUM_HASH_MISMATCH", typeof(BadRequest) },
                    { "NOT_ONBOARDED", typeof(BadRequest) },
                    { "INVALID_TIMESTAMP", typeof(BadRequest) },
                    { "INVALID_SIGNATURE_EXPIRATION", typeof(AuthenticationError) },
                    { "ACCOUNT_NOT_FOUND", typeof(AuthenticationError) },
                    { "INVALID_ORDER_SIGNATURE", typeof(AuthenticationError) },
                    { "PUBLIC_KEY_INVALID", typeof(BadRequest) },
                    { "UNAUTHORIZED_ETHEREUM_ADDRESS", typeof(BadRequest) },
                    { "ETHEREUM_ADDRESS_ALREADY_ONBOARDED", typeof(BadRequest) },
                    { "MARKET_NOT_FOUND", typeof(BadRequest) },
                    { "ALLOWLIST_ENTRY_NOT_FOUND", typeof(BadRequest) },
                    { "USERNAME_IN_USE", typeof(AuthenticationError) },
                    { "GEO_IP_BLOCK", typeof(PermissionDenied) },
                    { "ETHEREUM_ADDRESS_BLOCKED", typeof(PermissionDenied) },
                    { "PROGRAM_NOT_FOUND", typeof(BadRequest) },
                    { "INVALID_DASHBOARD", typeof(OperationRejected) },
                    { "MARKET_NOT_OPEN", typeof(BadRequest) },
                    { "INVALID_REFERRAL_CODE", typeof(OperationRejected) },
                    { "PARENT_ADDRESS_ALREADY_ONBOARDED", typeof(BadRequest) },
                    { "INVALID_PARENT_ACCOUNT", typeof(OperationRejected) },
                    { "INVALID_VAULT_OPERATOR_CHAIN", typeof(OperationRejected) },
                    { "VAULT_OPERATOR_ALREADY_ONBOARDED", typeof(OperationRejected) },
                    { "VAULT_NAME_IN_USE", typeof(OperationRejected) },
                    { "BATCH_SIZE_OUT_OF_RANGE", typeof(OperationRejected) },
                    { "ISOLATED_MARKET_ACCOUNT_MISMATCH", typeof(OperationRejected) },
                    { "POINTS_SUMMARY_NOT_FOUND", typeof(OperationRejected) },
                    { "-32700", typeof(BadRequest) },
                    { "-32600", typeof(BadRequest) },
                    { "-32601", typeof(BadRequest) },
                    { "-32602", typeof(BadRequest) },
                    { "-32603", typeof(ExchangeError) },
                    { "100", typeof(BadRequest) },
                    { "40110", typeof(AuthenticationError) },
                    { "40111", typeof(AuthenticationError) },
                    { "40112", typeof(PermissionDenied) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "precisionMode", TICK_SIZE },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "options", new Dictionary<string, object>() {
                { "broker", "CCXT" },
            } },
        });
    }

    /**
     * @method
     * @name paradex#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://docs.api.testnet.paradex.trade/#get-system-time-unix-milliseconds
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetSystemTime(parameters);
        //
        //     {
        //         "server_time": "1681493415023"
        //     }
        //
        return this.safeInteger(response, "server_time");
    }

    /**
     * @method
     * @name paradex#fetchStatus
     * @description the latest known information on the availability of the exchange API
     * @see https://docs.api.testnet.paradex.trade/#get-system-state
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
     */
    public async override Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetSystemState(parameters);
        //
        //     {
        //         "status": "ok"
        //     }
        //
        object status = this.safeString(response, "status");
        return new Dictionary<string, object>() {
            { "status", ((bool) isTrue((isEqual(status, "ok")))) ? "ok" : "maintenance" },
            { "updated", null },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    /**
     * @method
     * @name paradex#fetchMarkets
     * @description retrieves data on all markets for bitget
     * @see https://docs.api.testnet.paradex.trade/#list-available-markets
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetMarkets(parameters);
        //
        //     {
        //         "results": [
        //             {
        //                 "symbol": "BODEN-USD-PERP",
        //                 "base_currency": "BODEN",
        //                 "quote_currency": "USD",
        //                 "settlement_currency": "USDC",
        //                 "order_size_increment": "1",
        //                 "price_tick_size": "0.00001",
        //                 "min_notional": "200",
        //                 "open_at": 1717065600000,
        //                 "expiry_at": 0,
        //                 "asset_kind": "PERP",
        //                 "position_limit": "2000000",
        //                 "price_bands_width": "0.2",
        //                 "max_open_orders": 50,
        //                 "max_funding_rate": "0.05",
        //                 "delta1_cross_margin_params": {
        //                     "imf_base": "0.2",
        //                     "imf_shift": "180000",
        //                     "imf_factor": "0.00071",
        //                     "mmf_factor": "0.5"
        //                 },
        //                 "price_feed_id": "9LScEHse1ioZt2rUuhwiN6bmYnqpMqvZkQJDNUpxVHN5",
        //                 "oracle_ewma_factor": "0.14999987905913592",
        //                 "max_order_size": "520000",
        //                 "max_funding_rate_change": "0.0005",
        //                 "max_tob_spread": "0.2"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "results");
        return this.parseMarkets(data);
    }

    public override object parseMarket(object market)
    {
        //
        //     {
        //         "symbol": "BODEN-USD-PERP",
        //         "base_currency": "BODEN",
        //         "quote_currency": "USD",
        //         "settlement_currency": "USDC",
        //         "order_size_increment": "1",
        //         "price_tick_size": "0.00001",
        //         "min_notional": "200",
        //         "open_at": 1717065600000,
        //         "expiry_at": 0,
        //         "asset_kind": "PERP",
        //         "position_limit": "2000000",
        //         "price_bands_width": "0.2",
        //         "max_open_orders": 50,
        //         "max_funding_rate": "0.05",
        //         "delta1_cross_margin_params": {
        //             "imf_base": "0.2",
        //             "imf_shift": "180000",
        //             "imf_factor": "0.00071",
        //             "mmf_factor": "0.5"
        //         },
        //         "price_feed_id": "9LScEHse1ioZt2rUuhwiN6bmYnqpMqvZkQJDNUpxVHN5",
        //         "oracle_ewma_factor": "0.14999987905913592",
        //         "max_order_size": "520000",
        //         "max_funding_rate_change": "0.0005",
        //         "max_tob_spread": "0.2"
        //     }
        //
        object marketId = this.safeString(market, "symbol");
        object quoteId = this.safeString(market, "quote_currency");
        object baseId = this.safeString(market, "base_currency");
        object quote = this.safeCurrencyCode(quoteId);
        object bs = this.safeCurrencyCode(baseId);
        object settleId = this.safeString(market, "settlement_currency");
        object settle = this.safeCurrencyCode(settleId);
        object symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
        object expiry = this.safeInteger(market, "expiry_at");
        object takerFee = this.parseNumber("0.0003");
        object makerFee = this.parseNumber("-0.00005");
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", marketId },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", "swap" },
            { "spot", false },
            { "margin", null },
            { "swap", true },
            { "future", false },
            { "option", false },
            { "active", this.safeBool(market, "enableTrading") },
            { "contract", true },
            { "linear", true },
            { "inverse", null },
            { "taker", takerFee },
            { "maker", makerFee },
            { "contractSize", this.parseNumber("1") },
            { "expiry", ((bool) isTrue((isEqual(expiry, 0)))) ? null : expiry },
            { "expiryDatetime", ((bool) isTrue((isEqual(expiry, 0)))) ? null : this.iso8601(expiry) },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber(market, "order_size_increment") },
                { "price", this.safeNumber(market, "price_tick_size") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", this.safeNumber(market, "max_order_size") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "min_notional") },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        });
    }

    /**
     * @method
     * @name paradex#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://docs.api.testnet.paradex.trade/#ohlcv-for-a-symbol
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "resolution", this.safeString(this.timeframes, timeframe, timeframe) },
            { "symbol", getValue(market, "id") },
        };
        object now = this.milliseconds();
        object duration = this.parseTimeframe(timeframe);
        object until = this.safeInteger2(parameters, "until", "till", now);
        parameters = this.omit(parameters, new List<object>() {"until", "till"});
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_at"] = since;
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["end_at"] = subtract(this.sum(since, multiply(multiply(duration, (add(limit, 1))), 1000)), 1);
            } else
            {
                ((IDictionary<string,object>)request)["end_at"] = until;
            }
        } else
        {
            ((IDictionary<string,object>)request)["end_at"] = until;
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["start_at"] = add(subtract(until, multiply(multiply(duration, (add(limit, 1))), 1000)), 1);
            } else
            {
                ((IDictionary<string,object>)request)["start_at"] = add(subtract(until, multiply(multiply(duration, 101), 1000)), 1);
            }
        }
        object response = await this.publicGetMarketsKlines(this.extend(request, parameters));
        //
        //     {
        //         "results": [
        //             [
        //                 1720071900000,
        //                 58961.3,
        //                 58961.3,
        //                 58961.3,
        //                 58961.3,
        //                 1591
        //             ]
        //         ]
        //     }
        //
        object data = this.safeList(response, "results", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         1720071900000,
        //         58961.3,
        //         58961.3,
        //         58961.3,
        //         58961.3,
        //         1591
        //     ]
        //
        return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
    }

    /**
     * @method
     * @name paradex#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://docs.api.testnet.paradex.trade/#list-available-markets-summary
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            if (isTrue(((symbols is IList<object>) || (symbols.GetType().IsGenericType && symbols.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                ((IDictionary<string,object>)request)["market"] = this.marketId(getValue(symbols, 0));
            } else
            {
                ((IDictionary<string,object>)request)["market"] = this.marketId(symbols);
            }
        } else
        {
            ((IDictionary<string,object>)request)["market"] = "ALL";
        }
        object response = await this.publicGetMarketsSummary(this.extend(request, parameters));
        //
        //     {
        //         "results": [
        //             {
        //                 "symbol": "BTC-USD-PERP",
        //                 "oracle_price": "68465.17449906",
        //                 "mark_price": "68465.17449906",
        //                 "last_traded_price": "68495.1",
        //                 "bid": "68477.6",
        //                 "ask": "69578.2",
        //                 "volume_24h": "5815541.397939004",
        //                 "total_volume": "584031465.525259686",
        //                 "created_at": 1718170156580,
        //                 "underlying_price": "67367.37268422",
        //                 "open_interest": "162.272",
        //                 "funding_rate": "0.01629574927887",
        //                 "price_change_rate_24h": "0.009032"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "results", new List<object>() {});
        return this.parseTickers(data, symbols);
    }

    /**
     * @method
     * @name paradex#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://docs.api.testnet.paradex.trade/#list-available-markets-summary
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = await this.publicGetMarketsSummary(this.extend(request, parameters));
        //
        //     {
        //         "results": [
        //             {
        //                 "symbol": "BTC-USD-PERP",
        //                 "oracle_price": "68465.17449906",
        //                 "mark_price": "68465.17449906",
        //                 "last_traded_price": "68495.1",
        //                 "bid": "68477.6",
        //                 "ask": "69578.2",
        //                 "volume_24h": "5815541.397939004",
        //                 "total_volume": "584031465.525259686",
        //                 "created_at": 1718170156580,
        //                 "underlying_price": "67367.37268422",
        //                 "open_interest": "162.272",
        //                 "funding_rate": "0.01629574927887",
        //                 "price_change_rate_24h": "0.009032"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "results", new List<object>() {});
        object ticker = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseTicker(ticker, market);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "symbol": "BTC-USD-PERP",
        //         "oracle_price": "68465.17449906",
        //         "mark_price": "68465.17449906",
        //         "last_traded_price": "68495.1",
        //         "bid": "68477.6",
        //         "ask": "69578.2",
        //         "volume_24h": "5815541.397939004",
        //         "total_volume": "584031465.525259686",
        //         "created_at": 1718170156580,
        //         "underlying_price": "67367.37268422",
        //         "open_interest": "162.272",
        //         "funding_rate": "0.01629574927887",
        //         "price_change_rate_24h": "0.009032"
        //     }
        //
        object percentage = this.safeString(ticker, "price_change_rate_24h");
        if (isTrue(!isEqual(percentage, null)))
        {
            percentage = Precise.stringMul(percentage, "100");
        }
        object last = this.safeString(ticker, "last_traded_price");
        object marketId = this.safeString(ticker, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger(ticker, "created_at");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", null },
            { "low", null },
            { "bid", this.safeString(ticker, "bid") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "ask") },
            { "askVolume", null },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", null },
            { "quoteVolume", this.safeString(ticker, "volume_24h") },
            { "markPrice", this.safeString(ticker, "mark_price") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name paradex#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://docs.api.testnet.paradex.trade/#get-market-orderbook
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = await this.publicGetOrderbookMarket(this.extend(request, parameters));
        //
        //     {
        //         "market": "BTC-USD-PERP",
        //         "seq_no": 14115975,
        //         "last_updated_at": 1718172538340,
        //         "asks": [
        //             [
        //                 "69578.2",
        //                 "3.019"
        //             ]
        //         ],
        //         "bids": [
        //             [
        //                 "68477.6",
        //                 "0.1"
        //             ]
        //         ]
        //     }
        //
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["depth"] = limit;
        }
        object timestamp = this.safeInteger(response, "last_updated_at");
        object orderbook = this.parseOrderBook(response, getValue(market, "symbol"), timestamp);
        ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger(response, "seq_no");
        return orderbook;
    }

    /**
     * @method
     * @name paradex#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://docs.api.testnet.paradex.trade/#trade-tape
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch trades for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchTrades", symbol, since, limit, parameters, "next", "cursor", null, 100);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_at"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("end_at", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.publicGetTrades(this.extend(request, parameters));
        //
        //     {
        //         "next": "...",
        //         "prev": "...",
        //         "results": [
        //             {
        //                 "id": "1718154353750201703989430001",
        //                 "market": "BTC-USD-PERP",
        //                 "side": "BUY",
        //                 "size": "0.026",
        //                 "price": "69578.2",
        //                 "created_at": 1718154353750,
        //                 "trade_type": "FILL"
        //             }
        //         ]
        //     }
        //
        object trades = this.safeList(response, "results", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
        {
            ((IDictionary<string,object>)getValue(trades, i))["next"] = this.safeString(response, "next");
        }
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //     {
        //         "id": "1718154353750201703989430001",
        //         "market": "BTC-USD-PERP",
        //         "side": "BUY",
        //         "size": "0.026",
        //         "price": "69578.2",
        //         "created_at": 1718154353750,
        //         "trade_type": "FILL"
        //     }
        //
        // fetchMyTrades (private)
        //
        //     {
        //         "id": "1718947571560201703986670001",
        //         "side": "BUY",
        //         "liquidity": "TAKER",
        //         "market": "BTC-USD-PERP",
        //         "order_id": "1718947571540201703992340000",
        //         "price": "64852.9",
        //         "size": "0.01",
        //         "fee": "0.1945587",
        //         "fee_currency": "USDC",
        //         "created_at": 1718947571569,
        //         "remaining_size": "0",
        //         "client_id": "",
        //         "fill_type": "FILL"
        //     }
        //
        object marketId = this.safeString(trade, "market");
        market = this.safeMarket(marketId, market);
        object id = this.safeString(trade, "id");
        object timestamp = this.safeInteger(trade, "created_at");
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString(trade, "size");
        object side = this.safeStringLower(trade, "side");
        object liability = this.safeStringLower(trade, "liquidity", "taker");
        object isTaker = isEqual(liability, "taker");
        object takerOrMaker = ((bool) isTrue((isTaker))) ? "taker" : "maker";
        object currencyId = this.safeString(trade, "fee_currency");
        object code = this.safeCurrencyCode(currencyId);
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "order", this.safeString(trade, "order_id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "type", null },
            { "takerOrMaker", takerOrMaker },
            { "side", side },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "fee", new Dictionary<string, object>() {
                { "cost", this.safeString(trade, "fee") },
                { "currency", code },
                { "rate", null },
            } },
        }, market);
    }

    /**
     * @method
     * @name paradex#fetchOpenInterest
     * @description retrieves the open interest of a contract trading pair
     * @see https://docs.api.testnet.paradex.trade/#list-available-markets-summary
     * @param {string} symbol unified CCXT market symbol
     * @param {object} [params] exchange specific parameters
     * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
     */
    public async override Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "contract")))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterest() supports contract markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = await this.publicGetMarketsSummary(this.extend(request, parameters));
        //
        //     {
        //         "results": [
        //             {
        //                 "symbol": "BTC-USD-PERP",
        //                 "oracle_price": "68465.17449906",
        //                 "mark_price": "68465.17449906",
        //                 "last_traded_price": "68495.1",
        //                 "bid": "68477.6",
        //                 "ask": "69578.2",
        //                 "volume_24h": "5815541.397939004",
        //                 "total_volume": "584031465.525259686",
        //                 "created_at": 1718170156580,
        //                 "underlying_price": "67367.37268422",
        //                 "open_interest": "162.272",
        //                 "funding_rate": "0.01629574927887",
        //                 "price_change_rate_24h": "0.009032"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "results", new List<object>() {});
        object interest = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseOpenInterest(interest, market);
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        //     {
        //         "symbol": "BTC-USD-PERP",
        //         "oracle_price": "68465.17449906",
        //         "mark_price": "68465.17449906",
        //         "last_traded_price": "68495.1",
        //         "bid": "68477.6",
        //         "ask": "69578.2",
        //         "volume_24h": "5815541.397939004",
        //         "total_volume": "584031465.525259686",
        //         "created_at": 1718170156580,
        //         "underlying_price": "67367.37268422",
        //         "open_interest": "162.272",
        //         "funding_rate": "0.01629574927887",
        //         "price_change_rate_24h": "0.009032"
        //     }
        //
        object timestamp = this.safeInteger(interest, "created_at");
        object marketId = this.safeString(interest, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        return this.safeOpenInterest(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "openInterestAmount", this.safeString(interest, "open_interest") },
            { "openInterestValue", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", interest },
        }, market);
    }

    public virtual object hashMessage(object message)
    {
        return add("0x", this.hash(message, keccak, "hex"));
    }

    public virtual object signHash(object hash, object privateKey)
    {
        object signature = ecdsa(slice(hash, -64, null), slice(privateKey, -64, null), secp256k1, null);
        object r = getValue(signature, "r");
        object s = getValue(signature, "s");
        object v = this.intToBase16(this.sum(27, getValue(signature, "v")));
        return add(add(add("0x", (r as String).PadLeft(Convert.ToInt32(64), Convert.ToChar("0"))), (s as String).PadLeft(Convert.ToInt32(64), Convert.ToChar("0"))), v);
    }

    public virtual object signMessage(object message, object privateKey)
    {
        return this.signHash(this.hashMessage(message), slice(privateKey, -64, null));
    }

    public async virtual Task<object> getSystemConfig()
    {
        object cachedConfig = this.safeDict(this.options, "systemConfig");
        if (isTrue(!isEqual(cachedConfig, null)))
        {
            return cachedConfig;
        }
        object response = await this.publicGetSystemConfig();
        //
        // {
        //     "starknet_gateway_url": "https://potc-testnet-sepolia.starknet.io",
        //     "starknet_fullnode_rpc_url": "https://pathfinder.api.testnet.paradex.trade/rpc/v0_7",
        //     "starknet_chain_id": "PRIVATE_SN_POTC_SEPOLIA",
        //     "block_explorer_url": "https://voyager.testnet.paradex.trade/",
        //     "paraclear_address": "0x286003f7c7bfc3f94e8f0af48b48302e7aee2fb13c23b141479ba00832ef2c6",
        //     "paraclear_decimals": 8,
        //     "paraclear_account_proxy_hash": "0x3530cc4759d78042f1b543bf797f5f3d647cde0388c33734cf91b7f7b9314a9",
        //     "paraclear_account_hash": "0x41cb0280ebadaa75f996d8d92c6f265f6d040bb3ba442e5f86a554f1765244e",
        //     "oracle_address": "0x2c6a867917ef858d6b193a0ff9e62b46d0dc760366920d631715d58baeaca1f",
        //     "bridged_tokens": [
        //         {
        //             "name": "TEST USDC",
        //             "symbol": "USDC",
        //             "decimals": 6,
        //             "l1_token_address": "0x29A873159D5e14AcBd63913D4A7E2df04570c666",
        //             "l1_bridge_address": "0x8586e05adc0C35aa11609023d4Ae6075Cb813b4C",
        //             "l2_token_address": "0x6f373b346561036d98ea10fb3e60d2f459c872b1933b50b21fe6ef4fda3b75e",
        //             "l2_bridge_address": "0x46e9237f5408b5f899e72125dd69bd55485a287aaf24663d3ebe00d237fc7ef"
        //         }
        //     ],
        //     "l1_core_contract_address": "0x582CC5d9b509391232cd544cDF9da036e55833Af",
        //     "l1_operator_address": "0x11bACdFbBcd3Febe5e8CEAa75E0Ef6444d9B45FB",
        //     "l1_chain_id": "11155111",
        //     "liquidation_fee": "0.2"
        // }
        //
        ((IDictionary<string,object>)this.options)["systemConfig"] = response;
        return response;
    }

    public async virtual Task<object> prepareParadexDomain(object l1 = null)
    {
        l1 ??= false;
        object systemConfig = await this.getSystemConfig();
        if (isTrue(isEqual(l1, true)))
        {
            return new Dictionary<string, object>() {
                { "name", "Paradex" },
                { "chainId", getValue(systemConfig, "l1_chain_id") },
                { "version", "1" },
            };
        }
        return new Dictionary<string, object>() {
            { "name", "Paradex" },
            { "chainId", getValue(systemConfig, "starknet_chain_id") },
            { "version", 1 },
        };
    }

    public async virtual Task<object> retrieveAccount()
    {
        this.checkRequiredCredentials();
        object cachedAccount = this.safeDict(this.options, "paradexAccount");
        if (isTrue(!isEqual(cachedAccount, null)))
        {
            return cachedAccount;
        }
        object systemConfig = await this.getSystemConfig();
        object domain = await this.prepareParadexDomain(true);
        object messageTypes = new Dictionary<string, object>() {
            { "Constant", new List<object>() {new Dictionary<string, object>() {
    { "name", "action" },
    { "type", "string" },
}} },
        };
        object message = new Dictionary<string, object>() {
            { "action", "STARK Key" },
        };
        object msg = this.ethEncodeStructuredData(domain, messageTypes, message);
        object signature = this.signMessage(msg, this.privateKey);
        object account = this.retrieveStarkAccount(signature, getValue(systemConfig, "paraclear_account_hash"), getValue(systemConfig, "paraclear_account_proxy_hash"));
        ((IDictionary<string,object>)this.options)["paradexAccount"] = account;
        return account;
    }

    public async virtual Task<object> onboarding(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object account = await this.retrieveAccount();
        object req = new Dictionary<string, object>() {
            { "action", "Onboarding" },
        };
        object domain = await this.prepareParadexDomain();
        object messageTypes = new Dictionary<string, object>() {
            { "Constant", new List<object>() {new Dictionary<string, object>() {
    { "name", "action" },
    { "type", "felt" },
}} },
        };
        object msg = this.starknetEncodeStructuredData(domain, messageTypes, req, getValue(account, "address"));
        object signature = this.starknetSign(msg, getValue(account, "privateKey"));
        ((IDictionary<string,object>)parameters)["signature"] = signature;
        ((IDictionary<string,object>)parameters)["account"] = getValue(account, "address");
        ((IDictionary<string,object>)parameters)["public_key"] = getValue(account, "publicKey");
        object response = await this.privatePostOnboarding(parameters);
        return response;
    }

    public async virtual Task<object> authenticateRest(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object cachedToken = this.safeString(this.options, "authToken");
        object now = this.nonce();
        if (isTrue(!isEqual(cachedToken, null)))
        {
            object cachedExpires = this.safeInteger(this.options, "expires");
            if (isTrue(isLessThan(now, cachedExpires)))
            {
                return cachedToken;
            }
        }
        object account = await this.retrieveAccount();
        object expires = add(now, multiply(86400, 7));
        object req = new Dictionary<string, object>() {
            { "method", "POST" },
            { "path", "/v1/auth" },
            { "body", "" },
            { "timestamp", now },
            { "expiration", expires },
        };
        object domain = await this.prepareParadexDomain();
        object messageTypes = new Dictionary<string, object>() {
            { "Request", new List<object>() {new Dictionary<string, object>() {
    { "name", "method" },
    { "type", "felt" },
}, new Dictionary<string, object>() {
    { "name", "path" },
    { "type", "felt" },
}, new Dictionary<string, object>() {
    { "name", "body" },
    { "type", "felt" },
}, new Dictionary<string, object>() {
    { "name", "timestamp" },
    { "type", "felt" },
}, new Dictionary<string, object>() {
    { "name", "expiration" },
    { "type", "felt" },
}} },
        };
        object msg = this.starknetEncodeStructuredData(domain, messageTypes, req, getValue(account, "address"));
        object signature = this.starknetSign(msg, getValue(account, "privateKey"));
        ((IDictionary<string,object>)parameters)["signature"] = signature;
        ((IDictionary<string,object>)parameters)["account"] = getValue(account, "address");
        ((IDictionary<string,object>)parameters)["timestamp"] = getValue(req, "timestamp");
        ((IDictionary<string,object>)parameters)["expiration"] = getValue(req, "expiration");
        object response = await this.privatePostAuth(parameters);
        //
        // {
        //     jwt_token: "ooooccxtooootoooootheoooomoonooooo"
        // }
        //
        object token = this.safeString(response, "jwt_token");
        ((IDictionary<string,object>)this.options)["authToken"] = token;
        ((IDictionary<string,object>)this.options)["expires"] = expires;
        return token;
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // {
        //     "account": "0x4638e3041366aa71720be63e32e53e1223316c7f0d56f7aa617542ed1e7512x",
        //     "avg_fill_price": "26000",
        //     "client_id": "x1234",
        //     "cancel_reason": "NOT_ENOUGH_MARGIN",
        //     "created_at": 1681493746016,
        //     "flags": [
        //         "REDUCE_ONLY"
        //     ],
        //     "id": "123456",
        //     "instruction": "GTC",
        //     "last_updated_at": 1681493746016,
        //     "market": "BTC-USD-PERP",
        //     "price": "26000",
        //     "published_at": 1681493746016,
        //     "received_at": 1681493746016,
        //     "remaining_size": "0",
        //     "seq_no": 1681471234972000000,
        //     "side": "BUY",
        //     "size": "0.05",
        //     "status": "NEW",
        //     "stp": "EXPIRE_MAKER",
        //     "timestamp": 1681493746016,
        //     "trigger_price": "26000",
        //     "type": "MARKET"
        // }
        //
        object timestamp = this.safeInteger(order, "created_at");
        object orderId = this.safeString(order, "id");
        object clientOrderId = this.omitZero(this.safeString(order, "client_id"));
        object marketId = this.safeString(order, "market");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object price = this.safeString(order, "price");
        object amount = this.safeString(order, "size");
        object orderType = this.safeString(order, "type");
        object status = this.safeString(order, "status");
        object side = this.safeStringLower(order, "side");
        object average = this.omitZero(this.safeString(order, "avg_fill_price"));
        object remaining = this.omitZero(this.safeString(order, "remaining_size"));
        object stopPrice = this.safeString(order, "trigger_price");
        object lastUpdateTimestamp = this.safeInteger(order, "last_updated_at");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", orderId },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", lastUpdateTimestamp },
            { "status", this.parseOrderStatus(status) },
            { "symbol", symbol },
            { "type", this.parseOrderType(orderType) },
            { "timeInForce", this.parseTimeInForce(this.safeString(order, "instrunction")) },
            { "postOnly", null },
            { "reduceOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "takeProfitPrice", null },
            { "stopLossPrice", null },
            { "average", average },
            { "amount", amount },
            { "filled", null },
            { "remaining", remaining },
            { "cost", null },
            { "trades", null },
            { "fee", new Dictionary<string, object>() {
                { "cost", null },
                { "currency", null },
            } },
            { "info", order },
        }, market);
    }

    public virtual object parseTimeInForce(object timeInForce)
    {
        object timeInForces = new Dictionary<string, object>() {
            { "IOC", "IOC" },
            { "GTC", "GTC" },
            { "POST_ONLY", "PO" },
        };
        return this.safeString(timeInForces, timeInForce, null);
    }

    public virtual object parseOrderStatus(object status)
    {
        if (isTrue(!isEqual(status, null)))
        {
            object statuses = new Dictionary<string, object>() {
                { "NEW", "open" },
                { "UNTRIGGERED", "open" },
                { "OPEN", "open" },
                { "CLOSED", "closed" },
            };
            return this.safeString(statuses, status, status);
        }
        return status;
    }

    public virtual object parseOrderType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "LIMIT", "limit" },
            { "MARKET", "market" },
            { "STOP_LIMIT", "limit" },
            { "STOP_MARKET", "market" },
        };
        return this.safeStringLower(types, type, type);
    }

    public virtual object convertShortString(object str)
    {
        // TODO: add stringToBase16 in exchange
        return add("0x", this.binaryToBase16(this.base64ToBinary(this.stringToBase64(str))));
    }

    public virtual object scaleNumber(object num)
    {
        return Precise.stringMul(num, "100000000");
    }

    /**
     * @method
     * @name paradex#createOrder
     * @description create a trade order
     * @see https://docs.api.prod.paradex.trade/#create-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.stopPrice] The price a trigger order is triggered at
     * @param {float} [params.triggerPrice] The price a trigger order is triggered at
     * @param {string} [params.timeInForce] "GTC", "IOC", or "POST_ONLY"
     * @param {bool} [params.postOnly] true or false
     * @param {bool} [params.reduceOnly] Ensures that the executed order does not flip the opened position.
     * @param {string} [params.clientOrderId] a unique id for the order
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticateRest();
        await this.loadMarkets();
        object market = this.market(symbol);
        object reduceOnly = this.safeBool2(parameters, "reduceOnly", "reduce_only");
        object orderType = ((string)type).ToUpper();
        object orderSide = ((string)side).ToUpper();
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "side", orderSide },
            { "type", orderType },
            { "size", this.amountToPrecision(symbol, amount) },
        };
        object stopPrice = this.safeString2(parameters, "triggerPrice", "stopPrice");
        object isMarket = isEqual(orderType, "MARKET");
        object timeInForce = this.safeStringUpper(parameters, "timeInForce");
        object postOnly = this.isPostOnly(isMarket, null, parameters);
        if (!isTrue(isMarket))
        {
            if (isTrue(postOnly))
            {
                ((IDictionary<string,object>)request)["instruction"] = "POST_ONLY";
            } else if (isTrue(isEqual(timeInForce, "ioc")))
            {
                ((IDictionary<string,object>)request)["instruction"] = "IOC";
            }
        }
        if (isTrue(reduceOnly))
        {
            ((IDictionary<string,object>)request)["flags"] = new List<object>() {"REDUCE_ONLY"};
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object clientOrderId = this.safeStringN(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id"});
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["client_id"] = clientOrderId;
        }
        if (isTrue(!isEqual(stopPrice, null)))
        {
            if (isTrue(isMarket))
            {
                ((IDictionary<string,object>)request)["type"] = "STOP_MARKET";
            } else
            {
                ((IDictionary<string,object>)request)["type"] = "STOP_LIMIT";
            }
            ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, stopPrice);
        }
        parameters = this.omit(parameters, new List<object>() {"reduceOnly", "reduce_only", "clOrdID", "clientOrderId", "client_order_id", "postOnly", "timeInForce", "stopPrice", "triggerPrice"});
        object account = await this.retrieveAccount();
        object now = this.nonce();
        object orderReq = new Dictionary<string, object>() {
            { "timestamp", multiply(now, 1000) },
            { "market", this.convertShortString(getValue(request, "market")) },
            { "side", ((bool) isTrue((isEqual(orderSide, "BUY")))) ? "1" : "2" },
            { "orderType", this.convertShortString(getValue(request, "type")) },
            { "size", this.scaleNumber(getValue(request, "size")) },
            { "price", ((bool) isTrue((isMarket))) ? "0" : this.scaleNumber(getValue(request, "price")) },
        };
        object domain = await this.prepareParadexDomain();
        object messageTypes = new Dictionary<string, object>() {
            { "Order", new List<object>() {new Dictionary<string, object>() {
    { "name", "timestamp" },
    { "type", "felt" },
}, new Dictionary<string, object>() {
    { "name", "market" },
    { "type", "felt" },
}, new Dictionary<string, object>() {
    { "name", "side" },
    { "type", "felt" },
}, new Dictionary<string, object>() {
    { "name", "orderType" },
    { "type", "felt" },
}, new Dictionary<string, object>() {
    { "name", "size" },
    { "type", "felt" },
}, new Dictionary<string, object>() {
    { "name", "price" },
    { "type", "felt" },
}} },
        };
        object msg = this.starknetEncodeStructuredData(domain, messageTypes, orderReq, getValue(account, "address"));
        object signature = this.starknetSign(msg, getValue(account, "privateKey"));
        ((IDictionary<string,object>)request)["signature"] = signature;
        ((IDictionary<string,object>)request)["signature_timestamp"] = getValue(orderReq, "timestamp");
        object response = await this.privatePostOrders(this.extend(request, parameters));
        //
        // {
        //     "account": "0x4638e3041366aa71720be63e32e53e1223316c7f0d56f7aa617542ed1e7512x",
        //     "avg_fill_price": "26000",
        //     "cancel_reason": "NOT_ENOUGH_MARGIN",
        //     "client_id": "x1234",
        //     "created_at": 1681493746016,
        //     "flags": [
        //       "REDUCE_ONLY"
        //     ],
        //     "id": "123456",
        //     "instruction": "GTC",
        //     "last_updated_at": 1681493746016,
        //     "market": "BTC-USD-PERP",
        //     "price": "26000",
        //     "published_at": 1681493746016,
        //     "received_at": 1681493746016,
        //     "remaining_size": "0",
        //     "seq_no": 1681471234972000000,
        //     "side": "BUY",
        //     "size": "0.05",
        //     "status": "NEW",
        //     "stp": "EXPIRE_MAKER",
        //     "timestamp": 1681493746016,
        //     "trigger_price": "26000",
        //     "type": "MARKET"
        // }
        //
        object order = this.parseOrder(response, market);
        return order;
    }

    /**
     * @method
     * @name paradex#cancelOrder
     * @description cancels an open order
     * @see https://docs.api.prod.paradex.trade/#cancel-order
     * @see https://docs.api.prod.paradex.trade/#cancel-open-order-by-client-order-id
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] a unique id for the order
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticateRest();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeStringN(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id"});
        object response = null;
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["client_id"] = clientOrderId;
            response = await this.privateDeleteOrdersByClientIdClientId(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["order_id"] = id;
            response = await this.privateDeleteOrdersOrderId(this.extend(request, parameters));
        }
        //
        // if success, no response...
        //
        return this.parseOrder(response);
    }

    /**
     * @method
     * @name paradex#cancelAllOrders
     * @description cancel all open orders in a market
     * @see https://docs.api.prod.paradex.trade/#cancel-all-open-orders
     * @param {string} symbol unified market symbol of the market to cancel orders in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
        }
        await this.authenticateRest();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = await this.privateDeleteOrders(this.extend(request, parameters));
        //
        // if success, no response...
        //
        return response;
    }

    /**
     * @method
     * @name paradex#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://docs.api.prod.paradex.trade/#get-order
     * @see https://docs.api.prod.paradex.trade/#get-order-by-client-id
     * @param {string} id the order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] a unique id for the order
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticateRest();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeStringN(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id"});
        parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id"});
        object response = null;
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["client_id"] = clientOrderId;
            response = await this.privateGetOrdersByClientIdClientId(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["order_id"] = id;
            response = await this.privateGetOrdersOrderId(this.extend(request, parameters));
        }
        //
        //     {
        //         "id": "1718941725080201704028870000",
        //         "account": "0x49ddd7a564c978f6e4089ff8355b56a42b7e2d48ba282cb5aad60f04bea0ec3",
        //         "market": "BTC-USD-PERP",
        //         "side": "SELL",
        //         "type": "LIMIT",
        //         "size": "10.153",
        //         "remaining_size": "10.153",
        //         "price": "70784.5",
        //         "status": "CLOSED",
        //         "created_at": 1718941725082,
        //         "last_updated_at": 1718958002991,
        //         "timestamp": 1718941724678,
        //         "cancel_reason": "USER_CANCELED",
        //         "client_id": "",
        //         "seq_no": 1718958002991595738,
        //         "instruction": "GTC",
        //         "avg_fill_price": "",
        //         "stp": "EXPIRE_TAKER",
        //         "received_at": 1718958510959,
        //         "published_at": 1718958510960,
        //         "flags": [],
        //         "trigger_price": "0"
        //     }
        //
        return this.parseOrder(response);
    }

    /**
     * @method
     * @name paradex#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @see https://docs.api.prod.paradex.trade/#get-orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.side] 'buy' or 'sell'
     * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
     * @param {int} params.until timestamp in ms of the latest order to fetch
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticateRest();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchOrders", symbol, since, limit, parameters, "next", "cursor", null, 50);
        }
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_at"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("end_at", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateGetOrdersHistory(this.extend(request, parameters));
        //
        // {
        //     "next": "eyJmaWx0ZXIiMsIm1hcmtlciI6eyJtYXJrZXIiOiIxNjc1NjUwMDE3NDMxMTAxNjk5N=",
        //     "prev": "eyJmaWx0ZXIiOnsiTGltaXQiOjkwfSwidGltZSI6MTY4MTY3OTgzNzk3MTMwOTk1MywibWFya2VyIjp7Im1zMjExMD==",
        //     "results": [
        //       {
        //         "account": "0x4638e3041366aa71720be63e32e53e1223316c7f0d56f7aa617542ed1e7512x",
        //         "avg_fill_price": "26000",
        //         "cancel_reason": "NOT_ENOUGH_MARGIN",
        //         "client_id": "x1234",
        //         "created_at": 1681493746016,
        //         "flags": [
        //           "REDUCE_ONLY"
        //         ],
        //         "id": "123456",
        //         "instruction": "GTC",
        //         "last_updated_at": 1681493746016,
        //         "market": "BTC-USD-PERP",
        //         "price": "26000",
        //         "published_at": 1681493746016,
        //         "received_at": 1681493746016,
        //         "remaining_size": "0",
        //         "seq_no": 1681471234972000000,
        //         "side": "BUY",
        //         "size": "0.05",
        //         "status": "NEW",
        //         "stp": "EXPIRE_MAKER",
        //         "timestamp": 1681493746016,
        //         "trigger_price": "26000",
        //         "type": "MARKET"
        //       }
        //     ]
        //   }
        //
        object orders = this.safeList(response, "results", new List<object>() {});
        object paginationCursor = this.safeString(response, "next");
        object ordersLength = getArrayLength(orders);
        if (isTrue(isTrue((!isEqual(paginationCursor, null))) && isTrue((isGreaterThan(ordersLength, 0)))))
        {
            object first = getValue(orders, 0);
            ((IDictionary<string,object>)first)["next"] = paginationCursor;
            ((List<object>)orders)[Convert.ToInt32(0)] = first;
        }
        return this.parseOrders(orders, market, since, limit);
    }

    /**
     * @method
     * @name paradex#fetchOpenOrders
     * @description fetches information on multiple orders made by the user
     * @see https://docs.api.prod.paradex.trade/#paradex-rest-api-orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticateRest();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
        }
        object response = await this.privateGetOrders(this.extend(request, parameters));
        //
        //  {
        //     "results": [
        //       {
        //         "account": "0x4638e3041366aa71720be63e32e53e1223316c7f0d56f7aa617542ed1e7512x",
        //         "avg_fill_price": "26000",
        //         "client_id": "x1234",
        //         "cancel_reason": "NOT_ENOUGH_MARGIN",
        //         "created_at": 1681493746016,
        //         "flags": [
        //           "REDUCE_ONLY"
        //         ],
        //         "id": "123456",
        //         "instruction": "GTC",
        //         "last_updated_at": 1681493746016,
        //         "market": "BTC-USD-PERP",
        //         "price": "26000",
        //         "published_at": 1681493746016,
        //         "received_at": 1681493746016,
        //         "remaining_size": "0",
        //         "seq_no": 1681471234972000000,
        //         "side": "BUY",
        //         "size": "0.05",
        //         "status": "NEW",
        //         "stp": "EXPIRE_MAKER",
        //         "timestamp": 1681493746016,
        //         "trigger_price": "26000",
        //         "type": "MARKET"
        //       }
        //     ]
        //   }
        //
        object orders = this.safeList(response, "results", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    /**
     * @method
     * @name paradex#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://docs.api.prod.paradex.trade/#list-balances
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticateRest();
        await this.loadMarkets();
        object response = await this.privateGetBalance();
        //
        //     {
        //         "results": [
        //             {
        //                 "token": "USDC",
        //                 "size": "99980.2382266290601",
        //                 "last_updated_at": 1718529757240
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "results", new List<object>() {});
        return this.parseBalance(data);
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object balance = this.safeDict(response, i, new Dictionary<string, object>() {});
            object currencyId = this.safeString(balance, "token");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "size");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name paradex#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://docs.api.prod.paradex.trade/#list-fills
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticateRest();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchMyTrades", symbol, since, limit, parameters, "next", "cursor", null, 100);
        }
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_at"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("end_at", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateGetFills(this.extend(request, parameters));
        //
        //     {
        //         "next": null,
        //         "prev": null,
        //         "results": [
        //             {
        //                 "id": "1718947571560201703986670001",
        //                 "side": "BUY",
        //                 "liquidity": "TAKER",
        //                 "market": "BTC-USD-PERP",
        //                 "order_id": "1718947571540201703992340000",
        //                 "price": "64852.9",
        //                 "size": "0.01",
        //                 "fee": "0.1945587",
        //                 "fee_currency": "USDC",
        //                 "created_at": 1718947571569,
        //                 "remaining_size": "0",
        //                 "client_id": "",
        //                 "fill_type": "FILL"
        //             }
        //         ]
        //     }
        //
        object trades = this.safeList(response, "results", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
        {
            ((IDictionary<string,object>)getValue(trades, i))["next"] = this.safeString(response, "next");
        }
        return this.parseTrades(trades, market, since, limit);
    }

    /**
     * @method
     * @name paradex#fetchPositions
     * @description fetch data on an open position
     * @see https://docs.api.prod.paradex.trade/#list-open-positions
     * @param {string} symbol unified market symbol of the market the position is held in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticateRest();
        await this.loadMarkets();
        object market = this.market(symbol);
        object positions = await this.fetchPositions(new List<object>() {getValue(market, "symbol")}, parameters);
        return this.safeDict(positions, 0, new Dictionary<string, object>() {});
    }

    /**
     * @method
     * @name paradex#fetchPositions
     * @description fetch all open positions
     * @see https://docs.api.prod.paradex.trade/#list-open-positions
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticateRest();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.privateGetPositions();
        //
        //     {
        //         "results": [
        //             {
        //                 "id": "0x49ddd7a564c978f6e4089ff8355b56a42b7e2d48ba282cb5aad60f04bea0ec3-BTC-USD-PERP",
        //                 "market": "BTC-USD-PERP",
        //                 "status": "OPEN",
        //                 "side": "LONG",
        //                 "size": "0.01",
        //                 "average_entry_price": "64839.96053748",
        //                 "average_entry_price_usd": "64852.9",
        //                 "realized_pnl": "0",
        //                 "unrealized_pnl": "-2.39677214",
        //                 "unrealized_funding_pnl": "-0.11214013",
        //                 "cost": "648.39960537",
        //                 "cost_usd": "648.529",
        //                 "cached_funding_index": "35202.1002351",
        //                 "last_updated_at": 1718950074249,
        //                 "last_fill_id": "1718947571560201703986670001",
        //                 "seq_no": 1718950074249176253,
        //                 "liquidation_price": ""
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "results", new List<object>() {});
        return this.parsePositions(data, symbols);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         "id": "0x49ddd7a564c978f6e4089ff8355b56a42b7e2d48ba282cb5aad60f04bea0ec3-BTC-USD-PERP",
        //         "market": "BTC-USD-PERP",
        //         "status": "OPEN",
        //         "side": "LONG",
        //         "size": "0.01",
        //         "average_entry_price": "64839.96053748",
        //         "average_entry_price_usd": "64852.9",
        //         "realized_pnl": "0",
        //         "unrealized_pnl": "-2.39677214",
        //         "unrealized_funding_pnl": "-0.11214013",
        //         "cost": "648.39960537",
        //         "cost_usd": "648.529",
        //         "cached_funding_index": "35202.1002351",
        //         "last_updated_at": 1718950074249,
        //         "last_fill_id": "1718947571560201703986670001",
        //         "seq_no": 1718950074249176253,
        //         "liquidation_price": ""
        //     }
        //
        object marketId = this.safeString(position, "market");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object side = this.safeStringLower(position, "side");
        object quantity = this.safeString(position, "size");
        if (isTrue(!isEqual(side, "long")))
        {
            quantity = Precise.stringMul("-1", quantity);
        }
        object timestamp = this.safeInteger(position, "time");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", this.safeString(position, "id") },
            { "symbol", symbol },
            { "entryPrice", this.safeString(position, "average_entry_price") },
            { "markPrice", null },
            { "notional", null },
            { "collateral", this.safeString(position, "cost") },
            { "unrealizedPnl", this.safeString(position, "unrealized_pnl") },
            { "side", side },
            { "contracts", this.parseNumber(quantity) },
            { "contractSize", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "hedged", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "leverage", null },
            { "liquidationPrice", null },
            { "marginRatio", null },
            { "marginMode", null },
            { "percentage", null },
        });
    }

    /**
     * @method
     * @name paradex#fetchLiquidations
     * @description retrieves the public liquidations of a trading pair
     * @see https://docs.api.prod.paradex.trade/#list-liquidations
     * @param {string} symbol unified CCXT market symbol
     * @param {int} [since] the earliest time in ms to fetch liquidations for
     * @param {int} [limit] the maximum number of liquidation structures to retrieve
     * @param {object} [params] exchange specific parameters for the huobi api endpoint
     * @param {int} [params.until] timestamp in ms of the latest liquidation
     * @returns {object} an array of [liquidation structures]{@link https://docs.ccxt.com/#/?id=liquidation-structure}
     */
    public async override Task<object> fetchLiquidations(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticateRest();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = since;
        } else
        {
            ((IDictionary<string,object>)request)["from"] = 1;
        }
        object market = this.market(symbol);
        var requestparametersVariable = this.handleUntilOption("to", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateGetLiquidations(this.extend(request, parameters));
        //
        //     {
        //         "results": [
        //             {
        //                 "created_at": 1697213130097,
        //                 "id": "0x123456789"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "results", new List<object>() {});
        return this.parseLiquidations(data, market, since, limit);
    }

    public override object parseLiquidation(object liquidation, object market = null)
    {
        //
        //     {
        //         "created_at": 1697213130097,
        //         "id": "0x123456789"
        //     }
        //
        object timestamp = this.safeInteger(liquidation, "created_at");
        return this.safeLiquidation(new Dictionary<string, object>() {
            { "info", liquidation },
            { "symbol", null },
            { "contracts", null },
            { "contractSize", null },
            { "price", null },
            { "baseValue", null },
            { "quoteValue", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        });
    }

    /**
     * @method
     * @name paradex#fetchTransfers
     * @description fetch all deposits made to an account
     * @see https://docs.api.prod.paradex.trade/#paradex-rest-api-transfers
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticateRest();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchDeposits", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchDeposits", code, since, limit, parameters, "next", "cursor", null, 100);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_at"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("end_at", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateGetTransfers(this.extend(request, parameters));
        //
        //     {
        //         "next": null,
        //         "prev": null,
        //         "results": [
        //             {
        //                 "id": "1718940471200201703989430000",
        //                 "account": "0x49ddd7a564c978f6e4089ff8355b56a42b7e2d48ba282cb5aad60f04bea0ec3",
        //                 "kind": "DEPOSIT",
        //                 "status": "COMPLETED",
        //                 "amount": "100000",
        //                 "token": "USDC",
        //                 "created_at": 1718940471208,
        //                 "last_updated_at": 1718941455546,
        //                 "txn_hash": "0x73a415ca558a97bbdcd1c43e52b45f1e0486a0a84b3bb4958035ad6c59cb866",
        //                 "external_txn_hash": "",
        //                 "socialized_loss_factor": ""
        //             }
        //         ]
        //     }
        //
        object rows = this.safeList(response, "results", new List<object>() {});
        object deposits = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rows)); postFixIncrement(ref i))
        {
            object row = getValue(rows, i);
            if (isTrue(isEqual(getValue(row, "kind"), "DEPOSIT")))
            {
                ((IList<object>)deposits).Add(row);
            }
        }
        return this.parseTransactions(deposits, null, since, limit);
    }

    /**
     * @method
     * @name paradex#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://docs.api.prod.paradex.trade/#paradex-rest-api-transfers
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch withdrawals for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticateRest();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchWithdrawals", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchWithdrawals", code, since, limit, parameters, "next", "cursor", null, 100);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_at"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("end_at", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateGetTransfers(this.extend(request, parameters));
        //
        //     {
        //         "next": null,
        //         "prev": null,
        //         "results": [
        //             {
        //                 "id": "1718940471200201703989430000",
        //                 "account": "0x49ddd7a564c978f6e4089ff8355b56a42b7e2d48ba282cb5aad60f04bea0ec3",
        //                 "kind": "DEPOSIT",
        //                 "status": "COMPLETED",
        //                 "amount": "100000",
        //                 "token": "USDC",
        //                 "created_at": 1718940471208,
        //                 "last_updated_at": 1718941455546,
        //                 "txn_hash": "0x73a415ca558a97bbdcd1c43e52b45f1e0486a0a84b3bb4958035ad6c59cb866",
        //                 "external_txn_hash": "",
        //                 "socialized_loss_factor": ""
        //             }
        //         ]
        //     }
        //
        object rows = this.safeList(response, "results", new List<object>() {});
        object deposits = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rows)); postFixIncrement(ref i))
        {
            object row = getValue(rows, i);
            if (isTrue(isEqual(getValue(row, "kind"), "WITHDRAWAL")))
            {
                ((IList<object>)deposits).Add(row);
            }
        }
        return this.parseTransactions(deposits, null, since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits & fetchWithdrawals
        //
        //     {
        //         "id": "1718940471200201703989430000",
        //         "account": "0x49ddd7a564c978f6e4089ff8355b56a42b7e2d48ba282cb5aad60f04bea0ec3",
        //         "kind": "DEPOSIT",
        //         "status": "COMPLETED",
        //         "amount": "100000",
        //         "token": "USDC",
        //         "created_at": 1718940471208,
        //         "last_updated_at": 1718941455546,
        //         "txn_hash": "0x73a415ca558a97bbdcd1c43e52b45f1e0486a0a84b3bb4958035ad6c59cb866",
        //         "external_txn_hash": "",
        //         "socialized_loss_factor": ""
        //     }
        //
        object id = this.safeString(transaction, "id");
        object address = this.safeString(transaction, "account");
        object txid = this.safeString(transaction, "txn_hash");
        object currencyId = this.safeString(transaction, "token");
        object code = this.safeCurrencyCode(currencyId, currency);
        object timestamp = this.safeInteger(transaction, "created_at");
        object updated = this.safeInteger(transaction, "last_updated_at");
        object type = this.safeString(transaction, "kind");
        type = ((bool) isTrue((isEqual(type, "DEPOSIT")))) ? "deposit" : "withdrawal";
        object status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        object amount = this.safeNumber(transaction, "amount");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", null },
            { "address", address },
            { "addressTo", address },
            { "addressFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", type },
            { "amount", amount },
            { "currency", code },
            { "status", status },
            { "updated", updated },
            { "internal", null },
            { "comment", null },
            { "fee", null },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "PENDING", "pending" },
            { "AVAILABLE", "pending" },
            { "COMPLETED", "ok" },
            { "FAILED", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(this.implodeHostname(getValue(getValue(this.urls, "api"), this.version)), "/"), this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(isEqual(api, "public")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            headers = new Dictionary<string, object>() {
                { "Accept", "application/json" },
                { "PARADEX-PARTNER", this.safeString(this.options, "broker", "CCXT") },
            };
            // TODO: optimize
            if (isTrue(isEqual(path, "auth")))
            {
                ((IDictionary<string,object>)headers)["PARADEX-STARKNET-ACCOUNT"] = getValue(query, "account");
                ((IDictionary<string,object>)headers)["PARADEX-STARKNET-SIGNATURE"] = getValue(query, "signature");
                ((IDictionary<string,object>)headers)["PARADEX-TIMESTAMP"] = ((object)getValue(query, "timestamp")).ToString();
                ((IDictionary<string,object>)headers)["PARADEX-SIGNATURE-EXPIRATION"] = ((object)getValue(query, "expiration")).ToString();
            } else if (isTrue(isEqual(path, "onboarding")))
            {
                ((IDictionary<string,object>)headers)["PARADEX-ETHEREUM-ACCOUNT"] = this.walletAddress;
                ((IDictionary<string,object>)headers)["PARADEX-STARKNET-ACCOUNT"] = getValue(query, "account");
                ((IDictionary<string,object>)headers)["PARADEX-STARKNET-SIGNATURE"] = getValue(query, "signature");
                ((IDictionary<string,object>)headers)["PARADEX-TIMESTAMP"] = ((object)this.nonce()).ToString();
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
                body = this.json(new Dictionary<string, object>() {
                    { "public_key", getValue(query, "public_key") },
                });
            } else
            {
                object token = getValue(this.options, "authToken");
                ((IDictionary<string,object>)headers)["Authorization"] = add("Bearer ", token);
                if (isTrue(isEqual(method, "POST")))
                {
                    ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
                    body = this.json(query);
                } else
                {
                    url = add(add(url, "?"), this.urlencode(query));
                }
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        //
        //     {
        //         "data": null,
        //         "error": "NOT_ONBOARDED",
        //         "message": "User has never called /onboarding endpoint"
        //     }
        //
        object errorCode = this.safeString(response, "error");
        if (isTrue(!isEqual(errorCode, null)))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
