namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class kucoin : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "kucoin" },
            { "name", "KuCoin" },
            { "countries", new List<object>() {"SC"} },
            { "rateLimit", 10 },
            { "version", "v2" },
            { "certified", true },
            { "pro", true },
            { "comment", "Platform 2.0" },
            { "quoteJsonNumbers", false },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "borrowCrossMargin", true },
                { "borrowIsolatedMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createDepositAddress", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", true },
                { "createMarketSellOrderWithCost", true },
                { "createOrder", true },
                { "createOrders", true },
                { "createPostOnlyOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "createTriggerOrder", true },
                { "editOrder", true },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchBorrowInterest", true },
                { "fetchBorrowRateHistories", true },
                { "fetchBorrowRateHistory", true },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddressesByNetwork", true },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", true },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchL3OrderBook", true },
                { "fetchLedger", true },
                { "fetchLeverageTiers", false },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", false },
                { "fetchMarketLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", false },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", false },
                { "fetchOrdersByStatus", true },
                { "fetchOrderTrades", true },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositionsHistory", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchTransactionFee", true },
                { "fetchTransfers", false },
                { "fetchWithdrawals", true },
                { "repayCrossMargin", true },
                { "repayIsolatedMargin", true },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "signIn", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/51840849/87295558-132aaf80-c50e-11ea-9801-a2fb0c57c799.jpg" },
                { "referral", "https://www.kucoin.com/ucenter/signup?rcode=E5wkqe" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.kucoin.com" },
                    { "private", "https://api.kucoin.com" },
                    { "futuresPrivate", "https://api-futures.kucoin.com" },
                    { "futuresPublic", "https://api-futures.kucoin.com" },
                    { "webExchange", "https://kucoin.com/_api" },
                    { "broker", "https://api-broker.kucoin.com" },
                } },
                { "www", "https://www.kucoin.com" },
                { "doc", new List<object>() {"https://docs.kucoin.com"} },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "password", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "currencies", 4.5 },
                        { "currencies/{currency}", 4.5 },
                        { "symbols", 6 },
                        { "market/orderbook/level1", 3 },
                        { "market/allTickers", 22.5 },
                        { "market/stats", 22.5 },
                        { "markets", 4.5 },
                        { "market/orderbook/level{level}_{limit}", 6 },
                        { "market/orderbook/level2_20", 3 },
                        { "market/orderbook/level2_100", 6 },
                        { "market/histories", 4.5 },
                        { "market/candles", 4.5 },
                        { "prices", 4.5 },
                        { "timestamp", 4.5 },
                        { "status", 4.5 },
                        { "mark-price/{symbol}/current", 3 },
                        { "margin/config", 25 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "bullet-public", 15 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "user-info", 30 },
                        { "accounts", 7.5 },
                        { "accounts/{accountId}", 7.5 },
                        { "accounts/ledgers", 3 },
                        { "hf/accounts/ledgers", 2 },
                        { "hf/margin/account/ledgers", 2 },
                        { "transaction-history", 3 },
                        { "sub/user", 30 },
                        { "sub-accounts/{subUserId}", 22.5 },
                        { "sub-accounts", 30 },
                        { "sub/api-key", 30 },
                        { "margin/account", 40 },
                        { "margin/accounts", 15 },
                        { "isolated/accounts", 15 },
                        { "deposit-addresses", 7.5 },
                        { "deposits", 7.5 },
                        { "hist-deposits", 7.5 },
                        { "withdrawals", 30 },
                        { "hist-withdrawals", 30 },
                        { "withdrawals/quotas", 30 },
                        { "accounts/transferable", 30 },
                        { "transfer-list", 30 },
                        { "base-fee", 3 },
                        { "trade-fees", 3 },
                        { "market/orderbook/level{level}", 3 },
                        { "market/orderbook/level2", 3 },
                        { "market/orderbook/level3", 3 },
                        { "hf/orders/active", 2 },
                        { "hf/orders/active/symbols", 2 },
                        { "hf/orders/done", 2 },
                        { "hf/orders/{orderId}", 2 },
                        { "hf/orders/client-order/{clientOid}", 2 },
                        { "hf/orders/dead-cancel-all/query", 2 },
                        { "hf/fills", 2 },
                        { "orders", 2 },
                        { "limit/orders", 3 },
                        { "orders/{orderId}", 2 },
                        { "order/client-order/{clientOid}", 3 },
                        { "fills", 10 },
                        { "limit/fills", 20 },
                        { "stop-order", 8 },
                        { "stop-order/{orderId}", 3 },
                        { "stop-order/queryOrderByClientOid", 3 },
                        { "oco/order/{orderId}", 2 },
                        { "oco/order/details/{orderId}", 2 },
                        { "oco/client-order/{clientOid}", 2 },
                        { "oco/orders", 2 },
                        { "hf/margin/orders/active", 4 },
                        { "hf/margin/orders/done", 10 },
                        { "hf/margin/orders/{orderId}", 4 },
                        { "hf/margin/orders/client-order/{clientOid}", 5 },
                        { "hf/margin/fills", 5 },
                        { "etf/info", 25 },
                        { "margin/currencies", 20 },
                        { "risk/limit/strategy", 20 },
                        { "isolated/symbols", 20 },
                        { "isolated/account/{symbol}", 50 },
                        { "margin/borrow", 15 },
                        { "margin/repay", 15 },
                        { "margin/interest", 20 },
                        { "project/list", 10 },
                        { "project/marketInterestRate", 7.5 },
                        { "redeem/orders", 10 },
                        { "purchase/orders", 10 },
                        { "broker/api/rebase/download", 3 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "sub/user/created", 22.5 },
                        { "sub/api-key", 30 },
                        { "sub/api-key/update", 45 },
                        { "deposit-addresses", 30 },
                        { "withdrawals", 7.5 },
                        { "accounts/universal-transfer", 6 },
                        { "accounts/sub-transfer", 45 },
                        { "accounts/inner-transfer", 15 },
                        { "transfer-out", 30 },
                        { "transfer-in", 30 },
                        { "hf/orders", 1 },
                        { "hf/orders/test", 1 },
                        { "hf/orders/sync", 1 },
                        { "hf/orders/multi", 1 },
                        { "hf/orders/multi/sync", 1 },
                        { "hf/orders/alter", 3 },
                        { "hf/orders/dead-cancel-all", 2 },
                        { "orders", 2 },
                        { "orders/test", 2 },
                        { "orders/multi", 3 },
                        { "stop-order", 2 },
                        { "oco/order", 2 },
                        { "hf/margin/order", 5 },
                        { "hf/margin/order/test", 5 },
                        { "margin/order", 5 },
                        { "margin/order/test", 5 },
                        { "margin/borrow", 15 },
                        { "margin/repay", 10 },
                        { "purchase", 15 },
                        { "redeem", 15 },
                        { "lend/purchase/update", 10 },
                        { "bullet-private", 10 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "sub/api-key", 45 },
                        { "withdrawals/{withdrawalId}", 30 },
                        { "hf/orders/{orderId}", 1 },
                        { "hf/orders/sync/{orderId}", 1 },
                        { "hf/orders/client-order/{clientOid}", 1 },
                        { "hf/orders/sync/client-order/{clientOid}", 1 },
                        { "hf/orders/cancel/{orderId}", 2 },
                        { "hf/orders", 2 },
                        { "hf/orders/cancelAll", 30 },
                        { "orders/{orderId}", 3 },
                        { "order/client-order/{clientOid}", 5 },
                        { "orders", 20 },
                        { "stop-order/{orderId}", 3 },
                        { "stop-order/cancelOrderByClientOid", 5 },
                        { "stop-order/cancel", 3 },
                        { "oco/order/{orderId}", 3 },
                        { "oco/client-order/{clientOid}", 3 },
                        { "oco/orders", 3 },
                        { "hf/margin/orders/{orderId}", 5 },
                        { "hf/margin/orders/client-order/{clientOid}", 5 },
                        { "hf/margin/orders", 10 },
                    } },
                } },
                { "futuresPublic", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "contracts/active", 4.5 },
                        { "contracts/{symbol}", 4.5 },
                        { "ticker", 3 },
                        { "level2/snapshot", 4.5 },
                        { "level2/depth20", 7.5 },
                        { "level2/depth100", 15 },
                        { "trade/history", 7.5 },
                        { "kline/query", 4.5 },
                        { "interest/query", 7.5 },
                        { "index/query", 3 },
                        { "mark-price/{symbol}/current", 4.5 },
                        { "premium/query", 4.5 },
                        { "trade-statistics", 4.5 },
                        { "funding-rate/{symbol}/current", 3 },
                        { "contract/funding-rates", 7.5 },
                        { "timestamp", 3 },
                        { "status", 6 },
                        { "level2/message/query", 1.3953 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "bullet-public", 15 },
                    } },
                } },
                { "futuresPrivate", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "transaction-history", 3 },
                        { "account-overview", 7.5 },
                        { "account-overview-all", 9 },
                        { "transfer-list", 30 },
                        { "orders", 3 },
                        { "stopOrders", 9 },
                        { "recentDoneOrders", 7.5 },
                        { "orders/{orderId}", 7.5 },
                        { "orders/byClientOid", 7.5 },
                        { "fills", 7.5 },
                        { "recentFills", 4.5 },
                        { "openOrderStatistics", 15 },
                        { "position", 3 },
                        { "positions", 3 },
                        { "margin/maxWithdrawMargin", 15 },
                        { "contracts/risk-limit/{symbol}", 7.5 },
                        { "funding-history", 7.5 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "transfer-out", 30 },
                        { "transfer-in", 30 },
                        { "orders", 3 },
                        { "orders/test", 3 },
                        { "orders/multi", 4.5 },
                        { "position/margin/auto-deposit-status", 6 },
                        { "margin/withdrawMargin", 15 },
                        { "position/margin/deposit-margin", 6 },
                        { "position/risk-limit-level/change", 6 },
                        { "bullet-private", 15 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "orders/{orderId}", 1.5 },
                        { "orders/client-order/{clientOid}", 1.5 },
                        { "orders", 45 },
                        { "stopOrders", 22.5 },
                    } },
                } },
                { "webExchange", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "currency/currency/chain-info", 1 },
                    } },
                } },
                { "broker", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "broker/nd/info", 2 },
                        { "broker/nd/account", 2 },
                        { "broker/nd/account/apikey", 2 },
                        { "broker/nd/rebase/download", 3 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "broker/nd/transfer", 1 },
                        { "broker/nd/account", 3 },
                        { "broker/nd/account/apikey", 3 },
                        { "broker/nd/account/update-apikey", 3 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "broker/nd/account/apikey", 3 },
                    } },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1min" },
                { "3m", "3min" },
                { "5m", "5min" },
                { "15m", "15min" },
                { "30m", "30min" },
                { "1h", "1hour" },
                { "2h", "2hour" },
                { "4h", "4hour" },
                { "6h", "6hour" },
                { "8h", "8hour" },
                { "12h", "12hour" },
                { "1d", "1day" },
                { "1w", "1week" },
                { "1M", "1month" },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "order not exist", typeof(OrderNotFound) },
                    { "order not exist.", typeof(OrderNotFound) },
                    { "order_not_exist", typeof(OrderNotFound) },
                    { "order_not_exist_or_not_allow_to_cancel", typeof(InvalidOrder) },
                    { "Order size below the minimum requirement.", typeof(InvalidOrder) },
                    { "The withdrawal amount is below the minimum requirement.", typeof(ExchangeError) },
                    { "Unsuccessful! Exceeded the max. funds out-transfer limit", typeof(InsufficientFunds) },
                    { "The amount increment is invalid.", typeof(BadRequest) },
                    { "400", typeof(BadRequest) },
                    { "401", typeof(AuthenticationError) },
                    { "403", typeof(NotSupported) },
                    { "404", typeof(NotSupported) },
                    { "405", typeof(NotSupported) },
                    { "415", typeof(NotSupported) },
                    { "429", typeof(RateLimitExceeded) },
                    { "500", typeof(ExchangeNotAvailable) },
                    { "503", typeof(ExchangeNotAvailable) },
                    { "101030", typeof(PermissionDenied) },
                    { "103000", typeof(InvalidOrder) },
                    { "130101", typeof(BadRequest) },
                    { "130102", typeof(ExchangeError) },
                    { "130103", typeof(OrderNotFound) },
                    { "130104", typeof(ExchangeError) },
                    { "130105", typeof(InsufficientFunds) },
                    { "130106", typeof(NotSupported) },
                    { "130107", typeof(ExchangeError) },
                    { "130108", typeof(OrderNotFound) },
                    { "130201", typeof(PermissionDenied) },
                    { "130202", typeof(ExchangeError) },
                    { "130203", typeof(InsufficientFunds) },
                    { "130204", typeof(BadRequest) },
                    { "130301", typeof(InsufficientFunds) },
                    { "130302", typeof(PermissionDenied) },
                    { "130303", typeof(NotSupported) },
                    { "130304", typeof(NotSupported) },
                    { "130305", typeof(NotSupported) },
                    { "130306", typeof(NotSupported) },
                    { "130307", typeof(NotSupported) },
                    { "130308", typeof(InvalidOrder) },
                    { "130309", typeof(InvalidOrder) },
                    { "130310", typeof(ExchangeError) },
                    { "130311", typeof(InvalidOrder) },
                    { "130312", typeof(InvalidOrder) },
                    { "130313", typeof(InvalidOrder) },
                    { "130314", typeof(InvalidOrder) },
                    { "130315", typeof(NotSupported) },
                    { "126000", typeof(ExchangeError) },
                    { "126001", typeof(NotSupported) },
                    { "126002", typeof(ExchangeError) },
                    { "126003", typeof(InvalidOrder) },
                    { "126004", typeof(ExchangeError) },
                    { "126005", typeof(PermissionDenied) },
                    { "126006", typeof(ExchangeError) },
                    { "126007", typeof(ExchangeError) },
                    { "126009", typeof(ExchangeError) },
                    { "126010", typeof(ExchangeError) },
                    { "126011", typeof(ExchangeError) },
                    { "126013", typeof(InsufficientFunds) },
                    { "126015", typeof(ExchangeError) },
                    { "126021", typeof(NotSupported) },
                    { "126022", typeof(InvalidOrder) },
                    { "126027", typeof(InvalidOrder) },
                    { "126028", typeof(InvalidOrder) },
                    { "126029", typeof(InvalidOrder) },
                    { "126030", typeof(InvalidOrder) },
                    { "126033", typeof(InvalidOrder) },
                    { "126034", typeof(InvalidOrder) },
                    { "126036", typeof(InvalidOrder) },
                    { "126037", typeof(ExchangeError) },
                    { "126038", typeof(ExchangeError) },
                    { "126039", typeof(ExchangeError) },
                    { "126041", typeof(ExchangeError) },
                    { "126042", typeof(ExchangeError) },
                    { "126043", typeof(OrderNotFound) },
                    { "126044", typeof(InvalidOrder) },
                    { "126045", typeof(NotSupported) },
                    { "126046", typeof(NotSupported) },
                    { "126047", typeof(PermissionDenied) },
                    { "126048", typeof(PermissionDenied) },
                    { "135005", typeof(ExchangeError) },
                    { "135018", typeof(ExchangeError) },
                    { "200004", typeof(InsufficientFunds) },
                    { "210014", typeof(InvalidOrder) },
                    { "210021", typeof(InsufficientFunds) },
                    { "230003", typeof(InsufficientFunds) },
                    { "260000", typeof(InvalidAddress) },
                    { "260100", typeof(InsufficientFunds) },
                    { "300000", typeof(InvalidOrder) },
                    { "400000", typeof(BadSymbol) },
                    { "400001", typeof(AuthenticationError) },
                    { "400002", typeof(InvalidNonce) },
                    { "400003", typeof(AuthenticationError) },
                    { "400004", typeof(AuthenticationError) },
                    { "400005", typeof(AuthenticationError) },
                    { "400006", typeof(AuthenticationError) },
                    { "400007", typeof(AuthenticationError) },
                    { "400008", typeof(NotSupported) },
                    { "400100", typeof(InsufficientFunds) },
                    { "400200", typeof(InvalidOrder) },
                    { "400350", typeof(InvalidOrder) },
                    { "400370", typeof(InvalidOrder) },
                    { "400400", typeof(BadRequest) },
                    { "400401", typeof(AuthenticationError) },
                    { "400500", typeof(InvalidOrder) },
                    { "400600", typeof(BadSymbol) },
                    { "400760", typeof(InvalidOrder) },
                    { "401000", typeof(BadRequest) },
                    { "408000", typeof(BadRequest) },
                    { "411100", typeof(AccountSuspended) },
                    { "415000", typeof(BadRequest) },
                    { "400303", typeof(PermissionDenied) },
                    { "500000", typeof(ExchangeNotAvailable) },
                    { "260220", typeof(InvalidAddress) },
                    { "900014", typeof(BadRequest) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Exceeded the access frequency", typeof(RateLimitExceeded) },
                    { "require more permission", typeof(PermissionDenied) },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.001") },
                    { "maker", this.parseNumber("0.001") },
                    { "tiers", new Dictionary<string, object>() {
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("50"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("200"), this.parseNumber("0.0009")}, new List<object> {this.parseNumber("500"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("1000"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("2000"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("4000"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("8000"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("15000"), this.parseNumber("0.00045")}, new List<object> {this.parseNumber("25000"), this.parseNumber("0.0004")}, new List<object> {this.parseNumber("40000"), this.parseNumber("0.00035")}, new List<object> {this.parseNumber("60000"), this.parseNumber("0.0003")}, new List<object> {this.parseNumber("80000"), this.parseNumber("0.00025")}} },
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("50"), this.parseNumber("0.0009")}, new List<object> {this.parseNumber("200"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("500"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("1000"), this.parseNumber("0.0003")}, new List<object> {this.parseNumber("2000"), this.parseNumber("0")}, new List<object> {this.parseNumber("4000"), this.parseNumber("0")}, new List<object> {this.parseNumber("8000"), this.parseNumber("0")}, new List<object> {this.parseNumber("15000"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("25000"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("40000"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("60000"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("80000"), this.parseNumber("-0.00005")}} },
                    } },
                } },
                { "funding", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", false },
                    { "withdraw", new Dictionary<string, object>() {} },
                    { "deposit", new Dictionary<string, object>() {} },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "BIFI", "BIFIF" },
                { "VAI", "VAIOT" },
                { "WAX", "WAXP" },
                { "ALT", "APTOSLAUNCHTOKEN" },
                { "KALT", "ALT" },
            } },
            { "options", new Dictionary<string, object>() {
                { "version", "v1" },
                { "symbolSeparator", "-" },
                { "fetchMyTradesMethod", "private_get_fills" },
                { "fetchCurrencies", new Dictionary<string, object>() {
                    { "webApiEnable", true },
                    { "webApiRetries", 1 },
                    { "webApiMuteFailure", true },
                } },
                { "fetchMarkets", new Dictionary<string, object>() {
                    { "fetchTickersFees", true },
                } },
                { "withdraw", new Dictionary<string, object>() {
                    { "includeFee", false },
                } },
                { "versions", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "GET", new Dictionary<string, object>() {
                            { "currencies", "v3" },
                            { "currencies/{currency}", "v3" },
                            { "symbols", "v2" },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "GET", new Dictionary<string, object>() {
                            { "user-info", "v2" },
                            { "hf/margin/account/ledgers", "v3" },
                            { "sub/user", "v2" },
                            { "sub-accounts", "v2" },
                            { "margin/accounts", "v3" },
                            { "isolated/accounts", "v3" },
                            { "deposit-addresses", "v1" },
                            { "market/orderbook/level2", "v3" },
                            { "market/orderbook/level3", "v3" },
                            { "market/orderbook/level{level}", "v3" },
                            { "oco/order/{orderId}", "v3" },
                            { "oco/order/details/{orderId}", "v3" },
                            { "oco/client-order/{clientOid}", "v3" },
                            { "oco/orders", "v3" },
                            { "hf/margin/orders/active", "v3" },
                            { "hf/margin/orders/done", "v3" },
                            { "hf/margin/orders/{orderId}", "v3" },
                            { "hf/margin/orders/client-order/{clientOid}", "v3" },
                            { "hf/margin/fills", "v3" },
                            { "etf/info", "v3" },
                            { "margin/currencies", "v3" },
                            { "margin/borrow", "v3" },
                            { "margin/repay", "v3" },
                            { "margin/interest", "v3" },
                            { "project/list", "v3" },
                            { "project/marketInterestRate", "v3" },
                            { "redeem/orders", "v3" },
                            { "purchase/orders", "v3" },
                        } },
                        { "POST", new Dictionary<string, object>() {
                            { "sub/user/created", "v2" },
                            { "accounts/universal-transfer", "v3" },
                            { "accounts/sub-transfer", "v2" },
                            { "accounts/inner-transfer", "v2" },
                            { "transfer-out", "v3" },
                            { "oco/order", "v3" },
                            { "hf/margin/order", "v3" },
                            { "hf/margin/order/test", "v3" },
                            { "margin/borrow", "v3" },
                            { "margin/repay", "v3" },
                            { "purchase", "v3" },
                            { "redeem", "v3" },
                            { "lend/purchase/update", "v3" },
                        } },
                        { "DELETE", new Dictionary<string, object>() {
                            { "hf/margin/orders/{orderId}", "v3" },
                            { "hf/margin/orders/client-order/{clientOid}", "v3" },
                            { "hf/margin/orders", "v3" },
                            { "oco/order/{orderId}", "v3" },
                            { "oco/client-order/{clientOid}", "v3" },
                            { "oco/orders", "v3" },
                        } },
                    } },
                    { "futuresPrivate", new Dictionary<string, object>() {
                        { "POST", new Dictionary<string, object>() {
                            { "transfer-out", "v3" },
                        } },
                    } },
                } },
                { "partner", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "id", "ccxt" },
                        { "key", "9e58cc35-5b5e-4133-92ec-166e3f077cb8" },
                    } },
                    { "future", new Dictionary<string, object>() {
                        { "id", "ccxtfutures" },
                        { "key", "1b327198-f30c-4f14-a0ac-918871282f15" },
                    } },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "trade" },
                    { "margin", "margin" },
                    { "cross", "margin" },
                    { "isolated", "isolated" },
                    { "main", "main" },
                    { "funding", "main" },
                    { "future", "contract" },
                    { "swap", "contract" },
                    { "mining", "pool" },
                    { "hf", "trade_hf" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "BTC", "btc" },
                    { "BTCNATIVESEGWIT", "bech32" },
                    { "ERC20", "eth" },
                    { "TRC20", "trx" },
                    { "HRC20", "heco" },
                    { "MATIC", "matic" },
                    { "KCC", "kcc" },
                    { "SOL", "sol" },
                    { "ALGO", "algo" },
                    { "EOS", "eos" },
                    { "BEP20", "bsc" },
                    { "BEP2", "bnb" },
                    { "ARBONE", "arbitrum" },
                    { "AVAXX", "avax" },
                    { "AVAXC", "avaxc" },
                    { "TLOS", "tlos" },
                    { "CFX", "cfx" },
                    { "ACA", "aca" },
                    { "OPTIMISM", "optimism" },
                    { "ONT", "ont" },
                    { "GLMR", "glmr" },
                    { "CSPR", "cspr" },
                    { "KLAY", "klay" },
                    { "XRD", "xrd" },
                    { "RVN", "rvn" },
                    { "NEAR", "near" },
                    { "APT", "aptos" },
                    { "ETHW", "ethw" },
                    { "TON", "ton" },
                    { "BCH", "bch" },
                    { "BSV", "bchsv" },
                    { "BCHA", "bchabc" },
                    { "OSMO", "osmo" },
                    { "NANO", "nano" },
                    { "XLM", "xlm" },
                    { "VET", "vet" },
                    { "IOST", "iost" },
                    { "ZIL", "zil" },
                    { "XRP", "xrp" },
                    { "TOMO", "tomo" },
                    { "XMR", "xmr" },
                    { "COTI", "coti" },
                    { "XTZ", "xtz" },
                    { "ADA", "ada" },
                    { "WAX", "waxp" },
                    { "THETA", "theta" },
                    { "ONE", "one" },
                    { "IOTEX", "iotx" },
                    { "NULS", "nuls" },
                    { "KSM", "ksm" },
                    { "LTC", "ltc" },
                    { "WAVES", "waves" },
                    { "DOT", "dot" },
                    { "STEEM", "steem" },
                    { "QTUM", "qtum" },
                    { "DOGE", "doge" },
                    { "FIL", "fil" },
                    { "XYM", "xym" },
                    { "FLUX", "flux" },
                    { "ATOM", "atom" },
                    { "XDC", "xdc" },
                    { "KDA", "kda" },
                    { "ICP", "icp" },
                    { "CELO", "celo" },
                    { "LSK", "lsk" },
                    { "VSYS", "vsys" },
                    { "KAR", "kar" },
                    { "XCH", "xch" },
                    { "FLOW", "flow" },
                    { "BAND", "band" },
                    { "EGLD", "egld" },
                    { "HBAR", "hbar" },
                    { "XPR", "xpr" },
                    { "AR", "ar" },
                    { "FTM", "ftm" },
                    { "KAVA", "kava" },
                    { "KMA", "kma" },
                    { "XEC", "xec" },
                    { "IOTA", "iota" },
                    { "HNT", "hnt" },
                    { "ASTR", "astr" },
                    { "PDEX", "pdex" },
                    { "METIS", "metis" },
                    { "ZEC", "zec" },
                    { "POKT", "pokt" },
                    { "OASYS", "oas" },
                    { "OASIS", "oasis" },
                    { "ETC", "etc" },
                    { "AKT", "akt" },
                    { "FSN", "fsn" },
                    { "SCRT", "scrt" },
                    { "CFG", "cfg" },
                    { "ICX", "icx" },
                    { "KMD", "kmd" },
                    { "NEM", "NEM" },
                    { "STX", "stx" },
                    { "DGB", "dgb" },
                    { "DCR", "dcr" },
                    { "CKB", "ckb" },
                    { "ELA", "ela" },
                    { "HYDRA", "hydra" },
                    { "BTM", "btm" },
                    { "KARDIA", "kai" },
                    { "SXP", "sxp" },
                    { "NEBL", "nebl" },
                    { "ZEN", "zen" },
                    { "SDN", "sdn" },
                    { "LTO", "lto" },
                    { "WEMIX", "wemix" },
                    { "EVER", "ever" },
                    { "BNC", "bnc" },
                    { "BNCDOT", "bncdot" },
                    { "AION", "aion" },
                    { "GRIN", "grin" },
                    { "LOKI", "loki" },
                    { "QKC", "qkc" },
                    { "TT", "TT" },
                    { "PIVX", "pivx" },
                    { "SERO", "sero" },
                    { "METER", "meter" },
                    { "STATEMINE", "statemine" },
                    { "DVPN", "dvpn" },
                    { "XPRT", "xprt" },
                    { "MOVR", "movr" },
                    { "ERGO", "ergo" },
                    { "ABBC", "abbc" },
                    { "DIVI", "divi" },
                    { "PURA", "pura" },
                    { "DFI", "dfi" },
                    { "NEON3", "neon3" },
                    { "DOCK", "dock" },
                    { "TRUE", "true" },
                    { "CS", "cs" },
                    { "ORAI", "orai" },
                } },
                { "marginModes", new Dictionary<string, object>() {
                    { "cross", "MARGIN_TRADE" },
                    { "isolated", "MARGIN_ISOLATED_TRADE" },
                    { "spot", "TRADE" },
                } },
            } },
        });
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @see https://docs.kucoin.com/#server-time
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetTimestamp(parameters);
        //
        //     {
        //         "code":"200000",
        //         "msg":"success",
        //         "data":1546837113087
        //     }
        //
        return this.safeInteger(response, "data");
    }

    public async override Task<object> fetchStatus(object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchStatus
        * @description the latest known information on the availability of the exchange API
        * @see https://docs.kucoin.com/#service-status
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetStatus(parameters);
        //
        //     {
        //         "code":"200000",
        //         "data":{
        //             "status":"open", //open, close, cancelonly
        //             "msg":"upgrade match engine" //remark for operation
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object status = this.safeString(data, "status");
        return new Dictionary<string, object>() {
            { "status", ((bool) isTrue((isEqual(status, "open")))) ? "ok" : "maintenance" },
            { "updated", null },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchMarkets
        * @description retrieves data on all markets for kucoin
        * @see https://docs.kucoin.com/#get-symbols-list-deprecated
        * @see https://docs.kucoin.com/#get-all-tickers
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetSymbols(parameters);
        //
        //     {
        //         "code": "200000",
        //         "data": [
        //             {
        //                 "symbol": "XLM-USDT",
        //                 "name": "XLM-USDT",
        //                 "baseCurrency": "XLM",
        //                 "quoteCurrency": "USDT",
        //                 "feeCurrency": "USDT",
        //                 "market": "USDS",
        //                 "baseMinSize": "0.1",
        //                 "quoteMinSize": "0.01",
        //                 "baseMaxSize": "10000000000",
        //                 "quoteMaxSize": "99999999",
        //                 "baseIncrement": "0.0001",
        //                 "quoteIncrement": "0.000001",
        //                 "priceIncrement": "0.000001",
        //                 "priceLimitRate": "0.1",
        //                 "isMarginEnabled": true,
        //                 "enableTrading": true
        //             },
        //         ]
        //     }
        //
        object data = this.safeList(response, "data");
        object options = this.safeDict(this.options, "fetchMarkets", new Dictionary<string, object>() {});
        object fetchTickersFees = this.safeBool(options, "fetchTickersFees", true);
        object tickersResponse = new Dictionary<string, object>() {};
        if (isTrue(fetchTickersFees))
        {
            tickersResponse = await this.publicGetMarketAllTickers(parameters);
        }
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "time":1602832092060,
        //             "ticker":[
        //                 {
        //                     "symbol": "BTC-USDT",   // symbol
        //                     "symbolName":"BTC-USDT", // Name of trading pairs, it would change after renaming
        //                     "buy": "11328.9",   // bestAsk
        //                     "sell": "11329",    // bestBid
        //                     "changeRate": "-0.0055",    // 24h change rate
        //                     "changePrice": "-63.6", // 24h change price
        //                     "high": "11610",    // 24h highest price
        //                     "low": "11200", // 24h lowest price
        //                     "vol": "2282.70993217", // 24h volume，the aggregated trading volume in BTC
        //                     "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
        //                     "last": "11328.9",  // last price
        //                     "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
        //                     "takerFeeRate": "0.001",    // Basic Taker Fee
        //                     "makerFeeRate": "0.001",    // Basic Maker Fee
        //                     "takerCoefficient": "1",    // Taker Fee Coefficient
        //                     "makerCoefficient": "1" // Maker Fee Coefficient
        //                 }
        //             ]
        //         }
        //     }
        //
        object tickersData = this.safeDict(tickersResponse, "data", new Dictionary<string, object>() {});
        object tickers = this.safeList(tickersData, "ticker", new List<object>() {});
        object tickersByMarketId = this.indexBy(tickers, "symbol");
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object market = getValue(data, i);
            object id = this.safeString(market, "symbol");
            var baseIdquoteIdVariable = ((string)id).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            var baseId = ((IList<object>) baseIdquoteIdVariable)[0];
            var quoteId = ((IList<object>) baseIdquoteIdVariable)[1];
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            // const quoteIncrement = this.safeNumber (market, 'quoteIncrement');
            object ticker = this.safeDict(tickersByMarketId, id, new Dictionary<string, object>() {});
            object makerFeeRate = this.safeString(ticker, "makerFeeRate");
            object takerFeeRate = this.safeString(ticker, "takerFeeRate");
            object makerCoefficient = this.safeString(ticker, "makerCoefficient");
            object takerCoefficient = this.safeString(ticker, "takerCoefficient");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", this.safeBool(market, "isMarginEnabled") },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", this.safeBool(market, "enableTrading") },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", this.parseNumber(Precise.stringMul(takerFeeRate, takerCoefficient)) },
                { "maker", this.parseNumber(Precise.stringMul(makerFeeRate, makerCoefficient)) },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.safeNumber(market, "baseIncrement") },
                    { "price", this.safeNumber(market, "priceIncrement") },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "baseMinSize") },
                        { "max", this.safeNumber(market, "baseMaxSize") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "quoteMinSize") },
                        { "max", this.safeNumber(market, "quoteMaxSize") },
                    } },
                } },
                { "created", null },
                { "info", market },
            });
        }
        return result;
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://docs.kucoin.com/#get-currencies
        * @param {object} params extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object promises = new List<object>() {};
        ((IList<object>)promises).Add(this.publicGetCurrencies(parameters));
        //
        //    {
        //        "code":"200000",
        //        "data":[
        //           {
        //              "currency":"CSP",
        //              "name":"CSP",
        //              "fullName":"Caspian",
        //              "precision":8,
        //              "confirms":null,
        //              "contractAddress":null,
        //              "isMarginEnabled":false,
        //              "isDebitEnabled":false,
        //              "chains":[
        //                 {
        //                    "chainName":"ERC20",
        //                    "chainId": "eth"
        //                    "withdrawalMinSize":"2999",
        //                    "depositMinSize":null,
        //                    "withdrawFeeRate":"0",
        //                    "withdrawalMinFee":"2999",
        //                    "isWithdrawEnabled":false,
        //                    "isDepositEnabled":false,
        //                    "confirms":12,
        //                    "preConfirms":12,
        //                    "contractAddress":"0xa6446d655a0c34bc4f05042ee88170d056cbaf45",
        //                    "depositFeeRate": "0.001", // present for some currencies/networks
        //                 }
        //              ]
        //           },
        //    }
        //
        ((IList<object>)promises).Add(this.fetchWebEndpoint("fetchCurrencies", "webExchangeGetCurrencyCurrencyChainInfo", true));
        //
        //    {
        //        "success": true,
        //        "code": "200",
        //        "msg": "success",
        //        "retry": false,
        //        "data": [
        //            {
        //                "status": "enabled",
        //                "currency": "BTC",
        //                "isChainEnabled": "true",
        //                "chain": "btc",
        //                "chainName": "BTC",
        //                "chainFullName": "Bitcoin",
        //                "walletPrecision": "8",
        //                "isDepositEnabled": "true",
        //                "depositMinSize": "0.00005",
        //                "confirmationCount": "2",
        //                "isWithdrawEnabled": "true",
        //                "withdrawMinSize": "0.001",
        //                "withdrawMinFee": "0.0005",
        //                "withdrawFeeRate": "0",
        //                "depositDisabledTip": "Wallet Maintenance",
        //                "preDepositTipEnabled": "true",
        //                "preDepositTip": "Do not transfer from ETH network directly",
        //                "withdrawDisabledTip": "",
        //                "preWithdrawTipEnabled": "false",
        //                "preWithdrawTip": "",
        //                "orgAddress": "",
        //                "userAddressName": "Memo",
        //            },
        //        ]
        //    }
        //
        object responses = await promiseAll(promises);
        object currenciesResponse = this.safeDict(responses, 0, new Dictionary<string, object>() {});
        object currenciesData = this.safeList(currenciesResponse, "data", new List<object>() {});
        object additionalResponse = this.safeDict(responses, 1, new Dictionary<string, object>() {});
        object additionalData = this.safeList(additionalResponse, "data", new List<object>() {});
        object additionalDataGrouped = this.groupBy(additionalData, "currency");
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currenciesData)); postFixIncrement(ref i))
        {
            object entry = getValue(currenciesData, i);
            object id = this.safeString(entry, "currency");
            object name = this.safeString(entry, "fullName");
            object code = this.safeCurrencyCode(id);
            object isWithdrawEnabled = null;
            object isDepositEnabled = null;
            object networks = new Dictionary<string, object>() {};
            object chains = this.safeList(entry, "chains", new List<object>() {});
            object extraChainsData = this.indexBy(this.safeList(additionalDataGrouped, id, new List<object>() {}), "chain");
            object rawPrecision = this.safeString(entry, "precision");
            object precision = this.parseNumber(this.parsePrecision(rawPrecision));
            object chainsLength = getArrayLength(chains);
            if (!isTrue(chainsLength))
            {
                // https://t.me/KuCoin_API/173118
                isWithdrawEnabled = false;
                isDepositEnabled = false;
            }
            for (object j = 0; isLessThan(j, chainsLength); postFixIncrement(ref j))
            {
                object chain = getValue(chains, j);
                object chainId = this.safeString(chain, "chainId");
                object networkCode = this.networkIdToCode(chainId);
                object chainWithdrawEnabled = this.safeBool(chain, "isWithdrawEnabled", false);
                if (isTrue(isEqual(isWithdrawEnabled, null)))
                {
                    isWithdrawEnabled = chainWithdrawEnabled;
                } else
                {
                    isWithdrawEnabled = isTrue(isWithdrawEnabled) || isTrue(chainWithdrawEnabled);
                }
                object chainDepositEnabled = this.safeBool(chain, "isDepositEnabled", false);
                if (isTrue(isEqual(isDepositEnabled, null)))
                {
                    isDepositEnabled = chainDepositEnabled;
                } else
                {
                    isDepositEnabled = isTrue(isDepositEnabled) || isTrue(chainDepositEnabled);
                }
                object chainExtraData = this.safeDict(extraChainsData, chainId, new Dictionary<string, object>() {});
                ((IDictionary<string,object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                    { "info", chain },
                    { "id", chainId },
                    { "name", this.safeString(chain, "chainName") },
                    { "code", networkCode },
                    { "active", isTrue(chainWithdrawEnabled) && isTrue(chainDepositEnabled) },
                    { "fee", this.safeNumber(chain, "withdrawalMinFee") },
                    { "deposit", chainDepositEnabled },
                    { "withdraw", chainWithdrawEnabled },
                    { "precision", this.parseNumber(this.parsePrecision(this.safeString(chainExtraData, "walletPrecision"))) },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", this.safeNumber(chain, "withdrawalMinSize") },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", this.safeNumber(chain, "depositMinSize") },
                            { "max", null },
                        } },
                    } },
                };
            }
            // kucoin has determined 'fiat' currencies with below logic
            object isFiat = isTrue((isEqual(rawPrecision, "2"))) && isTrue((isEqual(chainsLength, 0)));
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "name", name },
                { "code", code },
                { "type", ((bool) isTrue(isFiat)) ? "fiat" : "crypto" },
                { "precision", precision },
                { "info", entry },
                { "active", (isTrue(isDepositEnabled) || isTrue(isWithdrawEnabled)) },
                { "deposit", isDepositEnabled },
                { "withdraw", isWithdrawEnabled },
                { "fee", null },
                { "limits", this.limits },
                { "networks", networks },
            };
        }
        return result;
    }

    public async override Task<object> fetchAccounts(object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchAccounts
        * @description fetch all the accounts associated with a profile
        * @see https://docs.kucoin.com/#list-accounts
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.privateGetAccounts(parameters);
        //
        //     {
        //         "code": "200000",
        //         "data": [
        //             {
        //                 "balance": "0.00009788",
        //                 "available": "0.00009788",
        //                 "holds": "0",
        //                 "currency": "BTC",
        //                 "id": "5c6a4fd399a1d81c4f9cc4d0",
        //                 "type": "trade"
        //             },
        //             {
        //                 "balance": "0.00000001",
        //                 "available": "0.00000001",
        //                 "holds": "0",
        //                 "currency": "ETH",
        //                 "id": "5c6a49ec99a1d819392e8e9f",
        //                 "type": "trade"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object account = getValue(data, i);
            object accountId = this.safeString(account, "id");
            object currencyId = this.safeString(account, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object type = this.safeString(account, "type"); // main or trade
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", accountId },
                { "type", type },
                { "currency", code },
                { "code", code },
                { "info", account },
            });
        }
        return result;
    }

    public async override Task<object> fetchTransactionFee(object code, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchTransactionFee
        * @description *DEPRECATED* please use fetchDepositWithdrawFee instead
        * @see https://docs.kucoin.com/#get-withdrawal-quotas
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the exchange API endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["chain"] = ((string)this.networkCodeToId(networkCode)).ToLower();
        }
        object response = await this.privateGetWithdrawalsQuotas(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object withdrawFees = new Dictionary<string, object>() {};
        ((IDictionary<string,object>)withdrawFees)[(string)code] = this.safeNumber(data, "withdrawMinFee");
        return new Dictionary<string, object>() {
            { "info", response },
            { "withdraw", withdrawFees },
            { "deposit", new Dictionary<string, object>() {} },
        };
    }

    public async override Task<object> fetchDepositWithdrawFee(object code, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchDepositWithdrawFee
        * @description fetch the fee for deposits and withdrawals
        * @see https://docs.kucoin.com/#get-withdrawal-quotas
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.network] The chain of currency. This only apply for multi-chain currency, and there is no need for single chain currency; you can query the chain through the response of the GET /api/v2/currencies/{currency} interface
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["chain"] = ((string)this.networkCodeToId(networkCode)).ToLower();
        }
        object response = await this.privateGetWithdrawalsQuotas(this.extend(request, parameters));
        //
        //    {
        //        "code": "200000",
        //        "data": {
        //            "currency": "USDT",
        //            "limitBTCAmount": "1.00000000",
        //            "usedBTCAmount": "0.00000000",
        //            "remainAmount": "16548.072149",
        //            "availableAmount": "0",
        //            "withdrawMinFee": "25",
        //            "innerWithdrawMinFee": "0",
        //            "withdrawMinSize": "50",
        //            "isWithdrawEnabled": true,
        //            "precision": 6,
        //            "chain": "ERC20"
        //        }
        //    }
        //
        object data = this.safeDict(response, "data");
        return ((object)this.parseDepositWithdrawFee(data, currency));
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //    {
        //        "currency": "USDT",
        //        "limitBTCAmount": "1.00000000",
        //        "usedBTCAmount": "0.00000000",
        //        "remainAmount": "16548.072149",
        //        "availableAmount": "0",
        //        "withdrawMinFee": "25",
        //        "innerWithdrawMinFee": "0",
        //        "withdrawMinSize": "50",
        //        "isWithdrawEnabled": true,
        //        "precision": 6,
        //        "chain": "ERC20"
        //    }
        //
        object result = new Dictionary<string, object>() {
            { "info", fee },
            { "withdraw", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
        object isWithdrawEnabled = this.safeBool(fee, "isWithdrawEnabled");
        if (isTrue(isWithdrawEnabled))
        {
            ((IDictionary<string,object>)getValue(result, "withdraw"))["fee"] = this.safeNumber2(fee, "withdrawalMinFee", "withdrawMinFee");
            ((IDictionary<string,object>)getValue(result, "withdraw"))["percentage"] = false;
            object networkId = this.safeString(fee, "chain");
            if (isTrue(networkId))
            {
                object networkCode = this.networkIdToCode(networkId, this.safeString(currency, "code"));
                ((IDictionary<string,object>)getValue(result, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                    { "withdraw", getValue(result, "withdraw") },
                    { "deposit", new Dictionary<string, object>() {
                        { "fee", null },
                        { "percentage", null },
                    } },
                };
            }
        }
        return result;
    }

    public virtual object isFuturesMethod(object methodName, object parameters)
    {
        //
        // Helper
        // @methodName (string): The name of the method
        // @params (dict): The parameters passed into {methodName}
        // @return: true if the method used is meant for futures trading, false otherwise
        //
        object defaultType = this.safeString2(this.options, methodName, "defaultType", "trade");
        object requestedType = this.safeString(parameters, "type", defaultType);
        object accountsByType = this.safeDict(this.options, "accountsByType");
        object type = this.safeString(accountsByType, requestedType);
        if (isTrue(isEqual(type, null)))
        {
            object keys = new List<object>(((IDictionary<string,object>)accountsByType).Keys);
            throw new ExchangeError ((string)add(add(this.id, " isFuturesMethod() type must be one of "), String.Join(", ", ((IList<object>)keys).ToArray()))) ;
        }
        parameters = this.omit(parameters, "type");
        return isTrue(isTrue((isEqual(type, "contract"))) || isTrue((isEqual(type, "future")))) || isTrue((isEqual(type, "futures")));  // * (type === 'futures') deprecated, use (type === 'future')
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "symbol": "BTC-USDT",   // symbol
        //         "symbolName":"BTC-USDT", // Name of trading pairs, it would change after renaming
        //         "buy": "11328.9",   // bestAsk
        //         "sell": "11329",    // bestBid
        //         "changeRate": "-0.0055",    // 24h change rate
        //         "changePrice": "-63.6", // 24h change price
        //         "high": "11610",    // 24h highest price
        //         "low": "11200", // 24h lowest price
        //         "vol": "2282.70993217", // 24h volume，the aggregated trading volume in BTC
        //         "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
        //         "last": "11328.9",  // last price
        //         "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
        //         "takerFeeRate": "0.001",    // Basic Taker Fee
        //         "makerFeeRate": "0.001",    // Basic Maker Fee
        //         "takerCoefficient": "1",    // Taker Fee Coefficient
        //         "makerCoefficient": "1" // Maker Fee Coefficient
        //     }
        //
        //     {
        //         "trading": true,
        //         "symbol": "KCS-BTC",
        //         "buy": 0.00011,
        //         "sell": 0.00012,
        //         "sort": 100,
        //         "volValue": 3.13851792584,   //total
        //         "baseCurrency": "KCS",
        //         "market": "BTC",
        //         "quoteCurrency": "BTC",
        //         "symbolCode": "KCS-BTC",
        //         "datetime": 1548388122031,
        //         "high": 0.00013,
        //         "vol": 27514.34842,
        //         "low": 0.0001,
        //         "changePrice": -1.0e-5,
        //         "changeRate": -0.0769,
        //         "lastTradedPrice": 0.00012,
        //         "board": 0,
        //         "mark": 0
        //     }
        //
        // market/ticker ws subscription
        //
        //     {
        //         "bestAsk": "62258.9",
        //         "bestAskSize": "0.38579986",
        //         "bestBid": "62258.8",
        //         "bestBidSize": "0.0078381",
        //         "price": "62260.7",
        //         "sequence": "1621383297064",
        //         "size": "0.00002841",
        //         "time": 1634641777363
        //     }
        //
        object percentage = this.safeString(ticker, "changeRate");
        if (isTrue(!isEqual(percentage, null)))
        {
            percentage = Precise.stringMul(percentage, "100");
        }
        object last = this.safeString2(ticker, "last", "lastTradedPrice");
        last = this.safeString(ticker, "price", last);
        object marketId = this.safeString(ticker, "symbol");
        market = this.safeMarket(marketId, market, "-");
        object symbol = getValue(market, "symbol");
        object baseVolume = this.safeString(ticker, "vol");
        object quoteVolume = this.safeString(ticker, "volValue");
        object timestamp = this.safeInteger2(ticker, "time", "datetime");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString2(ticker, "buy", "bestBid") },
            { "bidVolume", this.safeString(ticker, "bestBidSize") },
            { "ask", this.safeString2(ticker, "sell", "bestAsk") },
            { "askVolume", this.safeString(ticker, "bestAskSize") },
            { "vwap", null },
            { "open", this.safeString(ticker, "open") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", this.safeString(ticker, "changePrice") },
            { "percentage", percentage },
            { "average", this.safeString(ticker, "averagePrice") },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://docs.kucoin.com/#get-all-tickers
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.publicGetMarketAllTickers(parameters);
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "time":1602832092060,
        //             "ticker":[
        //                 {
        //                     "symbol": "BTC-USDT",   // symbol
        //                     "symbolName":"BTC-USDT", // Name of trading pairs, it would change after renaming
        //                     "buy": "11328.9",   // bestAsk
        //                     "sell": "11329",    // bestBid
        //                     "changeRate": "-0.0055",    // 24h change rate
        //                     "changePrice": "-63.6", // 24h change price
        //                     "high": "11610",    // 24h highest price
        //                     "low": "11200", // 24h lowest price
        //                     "vol": "2282.70993217", // 24h volume，the aggregated trading volume in BTC
        //                     "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
        //                     "last": "11328.9",  // last price
        //                     "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
        //                     "takerFeeRate": "0.001",    // Basic Taker Fee
        //                     "makerFeeRate": "0.001",    // Basic Maker Fee
        //                     "takerCoefficient": "1",    // Taker Fee Coefficient
        //                     "makerCoefficient": "1" // Maker Fee Coefficient
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object tickers = this.safeList(data, "ticker", new List<object>() {});
        object time = this.safeInteger(data, "time");
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(tickers)); postFixIncrement(ref i))
        {
            ((IDictionary<string,object>)getValue(tickers, i))["time"] = time;
            object ticker = this.parseTicker(getValue(tickers, i));
            object symbol = this.safeString(ticker, "symbol");
            if (isTrue(!isEqual(symbol, null)))
            {
                ((IDictionary<string,object>)result)[(string)symbol] = ticker;
            }
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://docs.kucoin.com/#get-24hr-stats
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetMarketStats(this.extend(request, parameters));
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "time": 1602832092060,  // time
        //             "symbol": "BTC-USDT",   // symbol
        //             "buy": "11328.9",   // bestAsk
        //             "sell": "11329",    // bestBid
        //             "changeRate": "-0.0055",    // 24h change rate
        //             "changePrice": "-63.6", // 24h change price
        //             "high": "11610",    // 24h highest price
        //             "low": "11200", // 24h lowest price
        //             "vol": "2282.70993217", // 24h volume，the aggregated trading volume in BTC
        //             "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
        //             "last": "11328.9",  // last price
        //             "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
        //             "takerFeeRate": "0.001",    // Basic Taker Fee
        //             "makerFeeRate": "0.001",    // Basic Maker Fee
        //             "takerCoefficient": "1",    // Taker Fee Coefficient
        //             "makerCoefficient": "1" // Maker Fee Coefficient
        //         }
        //     }
        //
        return this.parseTicker(getValue(response, "data"), market);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         "1545904980",             // Start time of the candle cycle
        //         "0.058",                  // opening price
        //         "0.049",                  // closing price
        //         "0.058",                  // highest price
        //         "0.049",                  // lowest price
        //         "0.018",                  // base volume
        //         "0.000945",               // quote volume
        //     ]
        //
        return new List<object> {this.safeTimestamp(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 5)};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://docs.kucoin.com/#get-klines
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, 1500);
        }
        object market = this.market(symbol);
        object marketId = getValue(market, "id");
        object request = new Dictionary<string, object>() {
            { "symbol", marketId },
            { "type", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        object duration = multiply(this.parseTimeframe(timeframe), 1000);
        object endAt = this.milliseconds(); // required param
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startAt"] = this.parseToInt((Math.Floor(Double.Parse((divide(since, 1000)).ToString()))));
            if (isTrue(isEqual(limit, null)))
            {
                // https://docs.kucoin.com/#get-klines
                // https://docs.kucoin.com/#details
                // For each query, the system would return at most 1500 pieces of data.
                // To obtain more data, please page the data by time.
                limit = this.safeInteger(this.options, "fetchOHLCVLimit", 1500);
            }
            endAt = this.sum(since, multiply(limit, duration));
        } else if (isTrue(!isEqual(limit, null)))
        {
            since = subtract(endAt, multiply(limit, duration));
            ((IDictionary<string,object>)request)["startAt"] = this.parseToInt((Math.Floor(Double.Parse((divide(since, 1000)).ToString()))));
        }
        ((IDictionary<string,object>)request)["endAt"] = this.parseToInt((Math.Floor(Double.Parse((divide(endAt, 1000)).ToString()))));
        object response = await this.publicGetMarketCandles(this.extend(request, parameters));
        //
        //     {
        //         "code":"200000",
        //         "data":[
        //             ["1591517700","0.025078","0.025069","0.025084","0.025064","18.9883256","0.4761861079404"],
        //             ["1591516800","0.025089","0.025079","0.025089","0.02506","99.4716622","2.494143499081"],
        //             ["1591515900","0.025079","0.02509","0.025091","0.025068","59.83701271","1.50060885172798"],
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#createDepositAddress
        * @see https://docs.kucoin.com/#create-deposit-address
        * @description create a currency deposit address
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.network] the blockchain network name
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["chain"] = ((string)this.networkCodeToId(networkCode)).ToLower();
        }
        object response = await this.privatePostDepositAddresses(this.extend(request, parameters));
        // {"code":"260000","msg":"Deposit address already exists."}
        // BCH {"code":"200000","data":{"address":"bitcoincash:qza3m4nj9rx7l9r0cdadfqxts6f92shvhvr5ls4q7z","memo":""}}
        // BTC {"code":"200000","data":{"address":"36SjucKqQpQSvsak9A7h6qzFjrVXpRNZhE","memo":""}}
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseDepositAddress(data, currency);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://docs.kucoin.com/#get-deposit-addresses-v2
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.network] the blockchain network name
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["chain"] = ((string)this.networkCodeToId(networkCode)).ToLower();
        }
        object version = getValue(getValue(getValue(getValue(this.options, "versions"), "private"), "GET"), "deposit-addresses");
        ((IDictionary<string,object>)getValue(getValue(getValue(this.options, "versions"), "private"), "GET"))["deposit-addresses"] = "v1";
        object response = await this.privateGetDepositAddresses(this.extend(request, parameters));
        // BCH {"code":"200000","data":{"address":"bitcoincash:qza3m4nj9rx7l9r0cdadfqxts6f92shvhvr5ls4q7z","memo":""}}
        // BTC {"code":"200000","data":{"address":"36SjucKqQpQSvsak9A7h6qzFjrVXpRNZhE","memo":""}}
        ((IDictionary<string,object>)getValue(getValue(getValue(this.options, "versions"), "private"), "GET"))["deposit-addresses"] = version;
        object data = this.safeValue(response, "data");
        if (isTrue(isEqual(data, null)))
        {
            throw new ExchangeError ((string)add(this.id, " fetchDepositAddress() returned an empty response, you might try to run createDepositAddress() first and try again")) ;
        }
        return this.parseDepositAddress(data, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        object address = this.safeString(depositAddress, "address");
        // BCH/BSV is returned with a "bitcoincash:" prefix, which we cut off here and only keep the address
        if (isTrue(!isEqual(address, null)))
        {
            address = ((string)address).Replace((string)"bitcoincash:", (string)"");
        }
        object code = null;
        if (isTrue(!isEqual(currency, null)))
        {
            code = this.safeCurrencyCode(getValue(currency, "id"));
            if (isTrue(!isEqual(code, "NIM")))
            {
                // contains spaces
                this.checkAddress(address);
            }
        }
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", code },
            { "address", address },
            { "tag", this.safeString(depositAddress, "memo") },
            { "network", this.networkIdToCode(this.safeString(depositAddress, "chain")) },
        };
    }

    public async override Task<object> fetchDepositAddressesByNetwork(object code, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchDepositAddressesByNetwork
        * @see https://docs.kucoin.com/#get-deposit-addresses-v2
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an array of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object version = getValue(getValue(getValue(getValue(this.options, "versions"), "private"), "GET"), "deposit-addresses");
        ((IDictionary<string,object>)getValue(getValue(getValue(this.options, "versions"), "private"), "GET"))["deposit-addresses"] = "v2";
        object response = await this.privateGetDepositAddresses(this.extend(request, parameters));
        //
        //     {
        //         "code": "200000",
        //         "data": [
        //             {
        //                 "address": "fr1qvus7d4d5fgxj5e7zvqe6yhxd7txm95h2and69r",
        //                 "memo": "",
        //                 "chain": "BTC-Segwit",
        //                 "contractAddress": ""
        //             },
        //             {"address":"37icNMEWbiF8ZkwUMxmfzMxi2A1MQ44bMn","memo":"","chain":"BTC","contractAddress":""},
        //             {"address":"Deposit temporarily blocked","memo":"","chain":"TRC20","contractAddress":""}
        //         ]
        //     }
        //
        ((IDictionary<string,object>)getValue(getValue(getValue(this.options, "versions"), "private"), "GET"))["deposit-addresses"] = version;
        object chains = this.safeList(response, "data", new List<object>() {});
        object parsed = this.parseDepositAddresses(chains, new List<object>() {getValue(currency, "code")}, false, new Dictionary<string, object>() {
            { "currency", getValue(currency, "code") },
        });
        return this.indexBy(parsed, "network");
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://www.kucoin.com/docs/rest/spot-trading/market-data/get-part-order-book-aggregated-
        * @see https://www.kucoin.com/docs/rest/spot-trading/market-data/get-full-order-book-aggregated-
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object level = this.safeInteger(parameters, "level", 2);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object isAuthenticated = this.checkRequiredCredentials(false);
        object response = null;
        if (isTrue(!isTrue(isAuthenticated) || isTrue(!isEqual(limit, null))))
        {
            if (isTrue(isEqual(level, 2)))
            {
                ((IDictionary<string,object>)request)["level"] = level;
                if (isTrue(!isEqual(limit, null)))
                {
                    if (isTrue(isTrue((isEqual(limit, 20))) || isTrue((isEqual(limit, 100)))))
                    {
                        ((IDictionary<string,object>)request)["limit"] = limit;
                    } else
                    {
                        throw new ExchangeError ((string)add(this.id, " fetchOrderBook() limit argument must be 20 or 100")) ;
                    }
                }
                ((IDictionary<string,object>)request)["limit"] = ((bool) isTrue(limit)) ? limit : 100;
            }
            response = await this.publicGetMarketOrderbookLevelLevelLimit(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetMarketOrderbookLevel2(this.extend(request, parameters));
        }
        //
        // public (v1) market/orderbook/level2_20 and market/orderbook/level2_100
        //
        //     {
        //         "sequence": "3262786978",
        //         "time": 1550653727731,
        //         "bids": [
        //             ["6500.12", "0.45054140"],
        //             ["6500.11", "0.45054140"],
        //         ],
        //         "asks": [
        //             ["6500.16", "0.57753524"],
        //             ["6500.15", "0.57753524"],
        //         ]
        //     }
        //
        // private (v3) market/orderbook/level2
        //
        //     {
        //         "sequence": "3262786978",
        //         "time": 1550653727731,
        //         "bids": [
        //             ["6500.12", "0.45054140"],
        //             ["6500.11", "0.45054140"],
        //         ],
        //         "asks": [
        //             ["6500.16", "0.57753524"],
        //             ["6500.15", "0.57753524"],
        //         ]
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(data, "time");
        object orderbook = this.parseOrderBook(data, getValue(market, "symbol"), timestamp, "bids", "asks", subtract(level, 2), subtract(level, 1));
        ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger(data, "sequence");
        return orderbook;
    }

    public virtual object handleTriggerPrices(object parameters)
    {
        object triggerPrice = this.safeValue2(parameters, "triggerPrice", "stopPrice");
        object stopLossPrice = this.safeValue(parameters, "stopLossPrice");
        object takeProfitPrice = this.safeValue(parameters, "takeProfitPrice");
        object isStopLoss = !isEqual(stopLossPrice, null);
        object isTakeProfit = !isEqual(takeProfitPrice, null);
        if (isTrue(isTrue(isTrue((isTrue(isStopLoss) && isTrue(isTakeProfit))) || isTrue((isTrue(triggerPrice) && isTrue(stopLossPrice)))) || isTrue((isTrue(triggerPrice) && isTrue(isTakeProfit)))))
        {
            throw new ExchangeError ((string)add(this.id, " createOrder() - you should use either triggerPrice or stopLossPrice or takeProfitPrice")) ;
        }
        return new List<object>() {triggerPrice, stopLossPrice, takeProfitPrice};
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#createOrder
        * @description Create an order on the exchange
        * @see https://docs.kucoin.com/spot#place-a-new-order
        * @see https://docs.kucoin.com/spot#place-a-new-order-2
        * @see https://docs.kucoin.com/spot#place-a-margin-order
        * @see https://docs.kucoin.com/spot-hf/#place-hf-order
        * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-order-test
        * @see https://www.kucoin.com/docs/rest/margin-trading/orders/place-margin-order-test
        * @param {string} symbol Unified CCXT market symbol
        * @param {string} type 'limit' or 'market'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount the amount of currency to trade
        * @param {float} [price] *ignored in "market" orders* the price at which the order is to be fullfilled at in units of the quote currency
        * @param {object} [params]  extra parameters specific to the exchange API endpoint
        * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
        * @param {string} [params.marginMode] 'cross', // cross (cross mode) and isolated (isolated mode), set to cross by default, the isolated mode will be released soon, stay tuned
        * @param {string} [params.timeInForce] GTC, GTT, IOC, or FOK, default is GTC, limit orders only
        * @param {string} [params.postOnly] Post only flag, invalid when timeInForce is IOC or FOK
        *
        * EXCHANGE SPECIFIC PARAMETERS
        * @param {string} [params.clientOid] client order id, defaults to uuid if not passed
        * @param {string} [params.remark] remark for the order, length cannot exceed 100 utf8 characters
        * @param {string} [params.tradeType] 'TRADE', // TRADE, MARGIN_TRADE // not used with margin orders
        * limit orders ---------------------------------------------------
        * @param {float} [params.cancelAfter] long, // cancel after n seconds, requires timeInForce to be GTT
        * @param {bool} [params.hidden] false, // Order will not be displayed in the order book
        * @param {bool} [params.iceberg] false, // Only a portion of the order is displayed in the order book
        * @param {string} [params.visibleSize] this.amountToPrecision (symbol, visibleSize), // The maximum visible size of an iceberg order
        * market orders --------------------------------------------------
        * @param {string} [params.funds] // Amount of quote currency to use
        * stop orders ----------------------------------------------------
        * @param {string} [params.stop]  Either loss or entry, the default is loss. Requires stopPrice to be defined
        * margin orders --------------------------------------------------
        * @param {float} [params.leverage] Leverage size of the order
        * @param {string} [params.stp] '', // self trade prevention, CN, CO, CB or DC
        * @param {bool} [params.autoBorrow] false, // The system will first borrow you funds at the optimal interest rate and then place an order for you
        * @param {bool} [params.hf] false, // true for hf order
        * @param {bool} [params.test] set to true to test an order, no order will be created but the request will be validated
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object testOrder = this.safeBool(parameters, "test", false);
        parameters = this.omit(parameters, "test");
        object isHf = this.safeBool(parameters, "hf", false);
        var triggerPricestopLossPricetakeProfitPriceVariable = this.handleTriggerPrices(parameters);
        var triggerPrice = ((IList<object>) triggerPricestopLossPricetakeProfitPriceVariable)[0];
        var stopLossPrice = ((IList<object>) triggerPricestopLossPricetakeProfitPriceVariable)[1];
        var takeProfitPrice = ((IList<object>) triggerPricestopLossPricetakeProfitPriceVariable)[2];
        object tradeType = this.safeString(parameters, "tradeType"); // keep it for backward compatibility
        object isTriggerOrder = (isTrue(isTrue(triggerPrice) || isTrue(stopLossPrice)) || isTrue(takeProfitPrice));
        object marginResult = this.handleMarginModeAndParams("createOrder", parameters);
        object marginMode = this.safeString(marginResult, 0);
        object isMarginOrder = isTrue(isEqual(tradeType, "MARGIN_TRADE")) || isTrue(!isEqual(marginMode, null));
        // don't omit anything before calling createOrderRequest
        object orderRequest = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object response = null;
        if (isTrue(testOrder))
        {
            if (isTrue(isMarginOrder))
            {
                response = await this.privatePostMarginOrderTest(orderRequest);
            } else
            {
                response = await this.privatePostOrdersTest(orderRequest);
            }
        } else if (isTrue(isHf))
        {
            response = await this.privatePostHfOrders(orderRequest);
        } else if (isTrue(isTriggerOrder))
        {
            response = await this.privatePostStopOrder(orderRequest);
        } else if (isTrue(isMarginOrder))
        {
            response = await this.privatePostMarginOrder(orderRequest);
        } else
        {
            response = await this.privatePostOrders(orderRequest);
        }
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "orderId": "5bd6e9286d99522a52e458de"
        //         }
        //    }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> createMarketOrderWithCost(object symbol, object side, object cost, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#createMarketOrderWithCost
        * @description create a market order by providing the symbol, side and cost
        * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} side 'buy' or 'sell'
        * @param {float} cost how much you want to trade in units of the quote currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        ((IDictionary<string,object>)parameters)["cost"] = cost;
        return await this.createOrder(symbol, "market", side, cost, null, parameters);
    }

    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#createMarketBuyOrderWithCost
        * @description create a market buy order by providing the symbol and cost
        * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {float} cost how much you want to trade in units of the quote currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        return await this.createMarketOrderWithCost(symbol, "buy", cost, parameters);
    }

    public async override Task<object> createMarketSellOrderWithCost(object symbol, object cost, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#createMarketSellOrderWithCost
        * @description create a market sell order by providing the symbol and cost
        * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {float} cost how much you want to trade in units of the quote currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        return await this.createMarketOrderWithCost(symbol, "sell", cost, parameters);
    }

    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#createOrders
        * @description create a list of trade orders
        * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-multiple-orders
        * @see https://www.kucoin.com/docs/rest/spot-trading/spot-hf-trade-pro-account/place-multiple-hf-orders
        * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
        * @param {object} [params]  extra parameters specific to the exchange API endpoint
        * @param {bool} [params.hf] false, // true for hf orders
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        object symbol = null;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            if (isTrue(isEqual(symbol, null)))
            {
                symbol = marketId;
            } else
            {
                if (isTrue(!isEqual(symbol, marketId)))
                {
                    throw new BadRequest ((string)add(this.id, " createOrders() requires all orders to have the same symbol")) ;
                }
            }
            object type = this.safeString(rawOrder, "type");
            if (isTrue(!isEqual(type, "limit")))
            {
                throw new BadRequest ((string)add(this.id, " createOrders() only supports limit orders")) ;
            }
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeValue(rawOrder, "params", new Dictionary<string, object>() {});
            object orderRequest = this.createOrderRequest(marketId, type, side, amount, price, orderParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "orderList", ordersRequests },
        };
        object hf = this.safeBool(parameters, "hf", false);
        parameters = this.omit(parameters, "hf");
        object response = null;
        if (isTrue(hf))
        {
            response = await this.privatePostHfOrdersMulti(this.extend(request, parameters));
        } else
        {
            response = await this.privatePostOrdersMulti(this.extend(request, parameters));
        }
        //
        // {
        //     "code": "200000",
        //     "data": {
        //        "data": [
        //           {
        //              "symbol": "LTC-USDT",
        //              "type": "limit",
        //              "side": "sell",
        //              "price": "90",
        //              "size": "0.1",
        //              "funds": null,
        //              "stp": "",
        //              "stop": "",
        //              "stopPrice": null,
        //              "timeInForce": "GTC",
        //              "cancelAfter": 0,
        //              "postOnly": false,
        //              "hidden": false,
        //              "iceberge": false,
        //              "iceberg": false,
        //              "visibleSize": null,
        //              "channel": "API",
        //              "id": "6539148443fcf500079d15e5",
        //              "status": "success",
        //              "failMsg": null,
        //              "clientOid": "5c4c5398-8ab2-4b4e-af8a-e2d90ad2488f"
        //           },
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        data = this.safeList(data, "data", new List<object>() {});
        return this.parseOrders(data);
    }

    public virtual object marketOrderAmountToPrecision(object symbol, object amount)
    {
        object market = this.market(symbol);
        object result = this.decimalToPrecision(amount, TRUNCATE, getValue(getValue(market, "info"), "quoteIncrement"), this.precisionMode, this.paddingMode);
        if (isTrue(isEqual(result, "0")))
        {
            throw new InvalidOrder ((string)add(add(add(add(this.id, " amount of "), getValue(market, "symbol")), " must be greater than minimum amount precision of "), this.numberToString(getValue(getValue(market, "precision"), "amount")))) ;
        }
        return result;
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        // required param, cannot be used twice
        object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId", this.uuid());
        parameters = this.omit(parameters, new List<object>() {"clientOid", "clientOrderId"});
        object request = new Dictionary<string, object>() {
            { "clientOid", clientOrderId },
            { "side", side },
            { "symbol", getValue(market, "id") },
            { "type", type },
        };
        object quoteAmount = this.safeNumber2(parameters, "cost", "funds");
        object amountString = null;
        object costString = null;
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(type, "market")))
        {
            if (isTrue(!isEqual(quoteAmount, null)))
            {
                parameters = this.omit(parameters, new List<object>() {"cost", "funds"});
                // kucoin uses base precision even for quote values
                costString = this.marketOrderAmountToPrecision(symbol, quoteAmount);
                ((IDictionary<string,object>)request)["funds"] = costString;
            } else
            {
                amountString = this.amountToPrecision(symbol, amount);
                ((IDictionary<string,object>)request)["size"] = this.amountToPrecision(symbol, amount);
            }
        } else
        {
            amountString = this.amountToPrecision(symbol, amount);
            ((IDictionary<string,object>)request)["size"] = amountString;
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object tradeType = this.safeString(parameters, "tradeType"); // keep it for backward compatibility
        var triggerPricestopLossPricetakeProfitPriceVariable = this.handleTriggerPrices(parameters);
        var triggerPrice = ((IList<object>) triggerPricestopLossPricetakeProfitPriceVariable)[0];
        var stopLossPrice = ((IList<object>) triggerPricestopLossPricetakeProfitPriceVariable)[1];
        var takeProfitPrice = ((IList<object>) triggerPricestopLossPricetakeProfitPriceVariable)[2];
        object isTriggerOrder = (isTrue(isTrue(triggerPrice) || isTrue(stopLossPrice)) || isTrue(takeProfitPrice));
        object isMarginOrder = isTrue(isEqual(tradeType, "MARGIN_TRADE")) || isTrue(!isEqual(marginMode, null));
        parameters = this.omit(parameters, new List<object>() {"stopLossPrice", "takeProfitPrice", "triggerPrice", "stopPrice"});
        if (isTrue(isTriggerOrder))
        {
            if (isTrue(triggerPrice))
            {
                ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, triggerPrice);
            } else if (isTrue(isTrue(stopLossPrice) || isTrue(takeProfitPrice)))
            {
                if (isTrue(stopLossPrice))
                {
                    ((IDictionary<string,object>)request)["stop"] = ((bool) isTrue((isEqual(side, "buy")))) ? "entry" : "loss";
                    ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, stopLossPrice);
                } else
                {
                    ((IDictionary<string,object>)request)["stop"] = ((bool) isTrue((isEqual(side, "buy")))) ? "loss" : "entry";
                    ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, takeProfitPrice);
                }
            }
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                throw new BadRequest ((string)add(this.id, " createOrder does not support isolated margin for stop orders")) ;
            } else if (isTrue(isEqual(marginMode, "cross")))
            {
                ((IDictionary<string,object>)request)["tradeType"] = getValue(getValue(this.options, "marginModes"), marginMode);
            }
        } else if (isTrue(isMarginOrder))
        {
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                ((IDictionary<string,object>)request)["marginModel"] = "isolated";
            }
        }
        object postOnly = null;
        var postOnlyparametersVariable = this.handlePostOnly(isEqual(type, "market"), false, parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["postOnly"] = true;
        }
        return this.extend(request, parameters);
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#editOrder
        * @description edit an order, kucoin currently only supports the modification of HF orders
        * @see https://docs.kucoin.com/spot-hf/#modify-order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type not used
        * @param {string} side not used
        * @param {float} amount how much of the currency you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the base currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.clientOrderId] client order id, defaults to id if not passed
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["newSize"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["newPrice"] = this.priceToPrecision(symbol, price);
        }
        object response = await this.privatePostHfOrdersAlter(this.extend(request, parameters));
        //
        // {
        //     "code":"200000",
        //     "data":{
        //        "newOrderId":"6478d7a6c883280001e92d8b"
        //     }
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#cancelOrder
        * @description cancels an open order
        * @see https://docs.kucoin.com/spot#cancel-an-order
        * @see https://docs.kucoin.com/spot#cancel-an-order-2
        * @see https://docs.kucoin.com/spot#cancel-single-order-by-clientoid
        * @see https://docs.kucoin.com/spot#cancel-single-order-by-clientoid-2
        * @see https://docs.kucoin.com/spot-hf/#cancel-orders-by-orderid
        * @see https://docs.kucoin.com/spot-hf/#cancel-order-by-clientoid
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {bool} [params.stop] True if cancelling a stop order
        * @param {bool} [params.hf] false, // true for hf order
        * @returns Response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId");
        object stop = this.safeBool2(parameters, "stop", "trigger", false);
        object hf = this.safeBool(parameters, "hf", false);
        if (isTrue(hf))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol parameter for hf orders")) ;
            }
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object response = null;
        parameters = this.omit(parameters, new List<object>() {"clientOid", "clientOrderId", "stop", "hf", "trigger"});
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
            if (isTrue(stop))
            {
                response = await this.privateDeleteStopOrderCancelOrderByClientOid(this.extend(request, parameters));
            } else if (isTrue(hf))
            {
                response = await this.privateDeleteHfOrdersClientOrderClientOid(this.extend(request, parameters));
            } else
            {
                response = await this.privateDeleteOrderClientOrderClientOid(this.extend(request, parameters));
            }
        } else
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
            if (isTrue(stop))
            {
                response = await this.privateDeleteStopOrderOrderId(this.extend(request, parameters));
            } else if (isTrue(hf))
            {
                response = await this.privateDeleteHfOrdersOrderId(this.extend(request, parameters));
            } else
            {
                response = await this.privateDeleteOrdersOrderId(this.extend(request, parameters));
            }
        }
        return response;
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#cancelAllOrders
        * @description cancel all open orders
        * @see https://docs.kucoin.com/spot#cancel-all-orders
        * @see https://docs.kucoin.com/spot#cancel-orders
        * @see https://docs.kucoin.com/spot-hf/#cancel-all-hf-orders-by-symbol
        * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {bool} [params.stop] *invalid for isolated margin* true if cancelling all stop orders
        * @param {string} [params.marginMode] 'cross' or 'isolated'
        * @param {string} [params.orderIds] *stop orders only* Comma seperated order IDs
        * @param {bool} [params.stop] True if cancelling a stop order
        * @param {bool} [params.hf] false, // true for hf order
        * @returns Response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object stop = this.safeBool(parameters, "stop", false);
        object hf = this.safeBool(parameters, "hf", false);
        parameters = this.omit(parameters, new List<object>() {"stop", "hf"});
        var marginModequeryVariable = this.handleMarginModeAndParams("cancelAllOrders", parameters);
        var marginMode = ((IList<object>) marginModequeryVariable)[0];
        var query = ((IList<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(symbol, null)))
        {
            ((IDictionary<string,object>)request)["symbol"] = this.marketId(symbol);
        }
        if (isTrue(!isEqual(marginMode, null)))
        {
            ((IDictionary<string,object>)request)["tradeType"] = getValue(getValue(this.options, "marginModes"), marginMode);
            if (isTrue(isTrue(isEqual(marginMode, "isolated")) && isTrue(stop)))
            {
                throw new BadRequest ((string)add(this.id, " cancelAllOrders does not support isolated margin for stop orders")) ;
            }
        }
        object response = null;
        if (isTrue(stop))
        {
            response = await this.privateDeleteStopOrderCancel(this.extend(request, query));
        } else if (isTrue(hf))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                response = await this.privateDeleteHfOrdersCancelAll(this.extend(request, query));
            } else
            {
                response = await this.privateDeleteHfOrders(this.extend(request, query));
            }
        } else
        {
            response = await this.privateDeleteOrders(this.extend(request, query));
        }
        return response;
    }

    public async virtual Task<object> fetchOrdersByStatus(object status, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchOrdersByStatus
        * @description fetch a list of orders
        * @see https://docs.kucoin.com/spot#list-orders
        * @see https://docs.kucoin.com/spot#list-stop-orders
        * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-active-hf-orders
        * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-filled-hf-orders
        * @param {string} status *not used for stop orders* 'open' or 'closed'
        * @param {string} symbol unified market symbol
        * @param {int} [since] timestamp in ms of the earliest order
        * @param {int} [limit] max number of orders to return
        * @param {object} [params] exchange specific params
        * @param {int} [params.until] end time in ms
        * @param {bool} [params.stop] true if fetching stop orders
        * @param {string} [params.side] buy or sell
        * @param {string} [params.type] limit, market, limit_stop or market_stop
        * @param {string} [params.tradeType] TRADE for spot trading, MARGIN_TRADE for Margin Trading
        * @param {int} [params.currentPage] *stop orders only* current page
        * @param {string} [params.orderIds] *stop orders only* comma seperated order ID list
        * @param {bool} [params.stop] True if fetching a stop order
        * @param {bool} [params.hf] false, // true for hf order
        * @returns An [array of order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object lowercaseStatus = ((string)status).ToLower();
        object until = this.safeInteger(parameters, "until");
        object stop = this.safeBool(parameters, "stop", false);
        object hf = this.safeBool(parameters, "hf", false);
        parameters = this.omit(parameters, new List<object>() {"stop", "hf", "until"});
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchOrdersByStatus", parameters);
        var marginMode = ((IList<object>) marginModequeryVariable)[0];
        var query = ((IList<object>) marginModequeryVariable)[1];
        if (isTrue(isEqual(lowercaseStatus, "open")))
        {
            lowercaseStatus = "active";
        } else if (isTrue(isEqual(lowercaseStatus, "closed")))
        {
            lowercaseStatus = "done";
        }
        object request = new Dictionary<string, object>() {
            { "status", lowercaseStatus },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startAt"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["pageSize"] = limit;
        }
        if (isTrue(until))
        {
            ((IDictionary<string,object>)request)["endAt"] = until;
        }
        ((IDictionary<string,object>)request)["tradeType"] = this.safeString(getValue(this.options, "marginModes"), marginMode, "TRADE");
        object response = null;
        if (isTrue(stop))
        {
            response = await this.privateGetStopOrder(this.extend(request, query));
        } else if (isTrue(hf))
        {
            if (isTrue(isEqual(lowercaseStatus, "active")))
            {
                response = await this.privateGetHfOrdersActive(this.extend(request, query));
            } else if (isTrue(isEqual(lowercaseStatus, "done")))
            {
                response = await this.privateGetHfOrdersDone(this.extend(request, query));
            }
        } else
        {
            response = await this.privateGetOrders(this.extend(request, query));
        }
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "currentPage": 1,
        //             "pageSize": 1,
        //             "totalNum": 153408,
        //             "totalPage": 153408,
        //             "items": [
        //                 {
        //                     "id": "5c35c02703aa673ceec2a168",   //orderid
        //                     "symbol": "BTC-USDT",   //symbol
        //                     "opType": "DEAL",      // operation type,deal is pending order,cancel is cancel order
        //                     "type": "limit",       // order type,e.g. limit,markrt,stop_limit.
        //                     "side": "buy",         // transaction direction,include buy and sell
        //                     "price": "10",         // order price
        //                     "size": "2",           // order quantity
        //                     "funds": "0",          // order funds
        //                     "dealFunds": "0.166",  // deal funds
        //                     "dealSize": "2",       // deal quantity
        //                     "fee": "0",            // fee
        //                     "feeCurrency": "USDT", // charge fee currency
        //                     "stp": "",             // self trade prevention,include CN,CO,DC,CB
        //                     "stop": "",            // stop type
        //                     "stopTriggered": false,  // stop order is triggered
        //                     "stopPrice": "0",      // stop price
        //                     "timeInForce": "GTC",  // time InForce,include GTC,GTT,IOC,FOK
        //                     "postOnly": false,     // postOnly
        //                     "hidden": false,       // hidden order
        //                     "iceberg": false,      // iceberg order
        //                     "visibleSize": "0",    // display quantity for iceberg order
        //                     "cancelAfter": 0,      // cancel orders time，requires timeInForce to be GTT
        //                     "channel": "IOS",      // order source
        //                     "clientOid": "",       // user-entered order unique mark
        //                     "remark": "",          // remark
        //                     "tags": "",            // tag order source
        //                     "isActive": false,     // status before unfilled or uncancelled
        //                     "cancelExist": false,   // order cancellation transaction record
        //                     "createdAt": 1547026471000  // time
        //                 },
        //             ]
        //         }
        //    }
        object listData = this.safeList(response, "data");
        if (isTrue(!isEqual(listData, null)))
        {
            return this.parseOrders(listData, market, since, limit);
        }
        object responseData = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeList(responseData, "items", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://docs.kucoin.com/spot#list-orders
        * @see https://docs.kucoin.com/spot#list-stop-orders
        * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-active-hf-orders
        * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-filled-hf-orders
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] end time in ms
        * @param {string} [params.side] buy or sell
        * @param {string} [params.type] limit, market, limit_stop or market_stop
        * @param {string} [params.tradeType] TRADE for spot trading, MARGIN_TRADE for Margin Trading
        * @param {bool} [params.stop] True if fetching a stop order
        * @param {bool} [params.hf] false, // true for hf order
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchClosedOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchClosedOrders", symbol, since, limit, parameters);
        }
        return await this.fetchOrdersByStatus("done", symbol, since, limit, parameters);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://docs.kucoin.com/spot#list-orders
        * @see https://docs.kucoin.com/spot#list-stop-orders
        * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-active-hf-orders
        * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-filled-hf-orders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] end time in ms
        * @param {bool} [params.stop] true if fetching stop orders
        * @param {string} [params.side] buy or sell
        * @param {string} [params.type] limit, market, limit_stop or market_stop
        * @param {string} [params.tradeType] TRADE for spot trading, MARGIN_TRADE for Margin Trading
        * @param {int} [params.currentPage] *stop orders only* current page
        * @param {string} [params.orderIds] *stop orders only* comma seperated order ID list
        * @param {bool} [params.stop] True if fetching a stop order
        * @param {bool} [params.hf] false, // true for hf order
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchOpenOrders", symbol, since, limit, parameters);
        }
        return await this.fetchOrdersByStatus("active", symbol, since, limit, parameters);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchOrder
        * @description fetch an order
        * @see https://docs.kucoin.com/spot#get-an-order
        * @see https://docs.kucoin.com/spot#get-single-active-order-by-clientoid
        * @see https://docs.kucoin.com/spot#get-single-order-info
        * @see https://docs.kucoin.com/spot#get-single-order-by-clientoid
        * @see https://docs.kucoin.com/spot-hf/#details-of-a-single-hf-order
        * @see https://docs.kucoin.com/spot-hf/#obtain-details-of-a-single-hf-order-using-clientoid
        * @param {string} id Order id
        * @param {string} symbol not sent to exchange except for stop orders with clientOid, but used internally by CCXT to filter
        * @param {object} [params] exchange specific parameters
        * @param {bool} [params.stop] true if fetching a stop order
        * @param {bool} [params.hf] false, // true for hf order
        * @param {bool} [params.clientOid] unique order id created by users to identify their orders
        * @returns An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId");
        object stop = this.safeBool(parameters, "stop", false);
        object hf = this.safeBool(parameters, "hf", false);
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        if (isTrue(hf))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol parameter for hf orders")) ;
            }
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        parameters = this.omit(parameters, new List<object>() {"stop", "hf", "clientOid", "clientOrderId"});
        object response = null;
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
            if (isTrue(stop))
            {
                if (isTrue(!isEqual(symbol, null)))
                {
                    ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
                }
                response = await this.privateGetStopOrderQueryOrderByClientOid(this.extend(request, parameters));
            } else if (isTrue(hf))
            {
                response = await this.privateGetHfOrdersClientOrderClientOid(this.extend(request, parameters));
            } else
            {
                response = await this.privateGetOrderClientOrderClientOid(this.extend(request, parameters));
            }
        } else
        {
            // a special case for undefined ids
            // otherwise a wrong endpoint for all orders will be triggered
            // https://github.com/ccxt/ccxt/issues/7234
            if (isTrue(isEqual(id, null)))
            {
                throw new InvalidOrder ((string)add(this.id, " fetchOrder() requires an order id")) ;
            }
            ((IDictionary<string,object>)request)["orderId"] = id;
            if (isTrue(stop))
            {
                response = await this.privateGetStopOrderOrderId(this.extend(request, parameters));
            } else if (isTrue(hf))
            {
                response = await this.privateGetHfOrdersOrderId(this.extend(request, parameters));
            } else
            {
                response = await this.privateGetOrdersOrderId(this.extend(request, parameters));
            }
        }
        object responseData = this.safeDict(response, "data", new Dictionary<string, object>() {});
        if (isTrue(((responseData is IList<object>) || (responseData.GetType().IsGenericType && responseData.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            responseData = this.safeValue(responseData, 0);
        }
        return this.parseOrder(responseData, market);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //
        //    {
        //        "orderId": "63c97e47d686c5000159a656"
        //    }
        //
        // cancelOrder
        //
        //    {
        //        "cancelledOrderIds": [ "63c97e47d686c5000159a656" ]
        //    }
        //
        // fetchOpenOrders, fetchClosedOrders
        //
        //    {
        //        "id": "63c97ce8d686c500015793bb",
        //        "symbol": "USDC-USDT",
        //        "opType": "DEAL",
        //        "type": "limit",
        //        "side": "sell",
        //        "price": "1.05",
        //        "size": "1",
        //        "funds": "0",
        //        "dealFunds": "0",
        //        "dealSize": "0",
        //        "fee": "0",
        //        "feeCurrency": "USDT",
        //        "stp": "",
        //        "stop": "",
        //        "stopTriggered": false,
        //        "stopPrice": "0",
        //        "timeInForce": "GTC",
        //        "postOnly": false,
        //        "hidden": false,
        //        "iceberg": false,
        //        "visibleSize": "0",
        //        "cancelAfter": 0,
        //        "channel": "API",
        //        "clientOid": "d602d73f-5424-4751-bef0-8debce8f0a82",
        //        "remark": null,
        //        "tags": "partner:ccxt",
        //        "isActive": true,
        //        "cancelExist": false,
        //        "createdAt": 1674149096927,
        //        "tradeType": "TRADE"
        //    }
        //
        // stop orders (fetchOpenOrders, fetchClosedOrders)
        //
        //    {
        //        "id": "vs9f6ou9e864rgq8000t4qnm",
        //        "symbol": "USDC-USDT",
        //        "userId": "613a896885d8660006151f01",
        //        "status": "NEW",
        //        "type": "market",
        //        "side": "sell",
        //        "price": null,
        //        "size": "1.00000000000000000000",
        //        "funds": null,
        //        "stp": null,
        //        "timeInForce": "GTC",
        //        "cancelAfter": -1,
        //        "postOnly": false,
        //        "hidden": false,
        //        "iceberg": false,
        //        "visibleSize": null,
        //        "channel": "API",
        //        "clientOid": "5d3fd727-6456-438d-9550-40d9d85eee0b",
        //        "remark": null,
        //        "tags": "partner:ccxt",
        //        "relatedNo": null,
        //        "orderTime": 1674146316994000028,
        //        "domainId": "kucoin",
        //        "tradeSource": "USER",
        //        "tradeType": "MARGIN_TRADE",
        //        "feeCurrency": "USDT",
        //        "takerFeeRate": "0.00100000000000000000",
        //        "makerFeeRate": "0.00100000000000000000",
        //        "createdAt": 1674146316994,
        //        "stop": "loss",
        //        "stopTriggerTime": null,
        //        "stopPrice": "0.97000000000000000000"
        //    }
        // hf order
        //    {
        //        "id":"6478cf1439bdfc0001528a1d",
        //        "symbol":"LTC-USDT",
        //        "opType":"DEAL",
        //        "type":"limit",
        //        "side":"buy",
        //        "price":"50",
        //        "size":"0.1",
        //        "funds":"5",
        //        "dealSize":"0",
        //        "dealFunds":"0",
        //        "fee":"0",
        //        "feeCurrency":"USDT",
        //        "stp":null,
        //        "timeInForce":"GTC",
        //        "postOnly":false,
        //        "hidden":false,
        //        "iceberg":false,
        //        "visibleSize":"0",
        //        "cancelAfter":0,
        //        "channel":"API",
        //        "clientOid":"d4d2016b-8e3a-445c-aa5d-dc6df5d1678d",
        //        "remark":null,
        //        "tags":"partner:ccxt",
        //        "cancelExist":false,
        //        "createdAt":1685638932074,
        //        "lastUpdatedAt":1685639013735,
        //        "tradeType":"TRADE",
        //        "inOrderBook":true,
        //        "cancelledSize":"0",
        //        "cancelledFunds":"0",
        //        "remainSize":"0.1",
        //        "remainFunds":"5",
        //        "active":true
        //    }
        //
        object marketId = this.safeString(order, "symbol");
        object timestamp = this.safeInteger(order, "createdAt");
        object feeCurrencyId = this.safeString(order, "feeCurrency");
        object cancelExist = this.safeBool(order, "cancelExist", false);
        object responseStop = this.safeString(order, "stop");
        object stop = !isEqual(responseStop, null);
        object stopTriggered = this.safeBool(order, "stopTriggered", false);
        object isActive = this.safeBool2(order, "isActive", "active");
        object responseStatus = this.safeString(order, "status");
        object status = null;
        if (isTrue(!isEqual(isActive, null)))
        {
            if (isTrue(isEqual(isActive, true)))
            {
                status = "open";
            } else
            {
                status = "closed";
            }
        }
        if (isTrue(stop))
        {
            if (isTrue(isEqual(responseStatus, "NEW")))
            {
                status = "open";
            } else if (isTrue(!isTrue(isActive) && !isTrue(stopTriggered)))
            {
                status = "cancelled";
            }
        }
        if (isTrue(cancelExist))
        {
            status = "canceled";
        }
        if (isTrue(isEqual(responseStatus, "fail")))
        {
            status = "rejected";
        }
        object stopPrice = this.safeNumber(order, "stopPrice");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeStringN(order, new List<object>() {"id", "orderId", "newOrderId"}) },
            { "clientOrderId", this.safeString(order, "clientOid") },
            { "symbol", this.safeSymbol(marketId, market, "-") },
            { "type", this.safeString(order, "type") },
            { "timeInForce", this.safeString(order, "timeInForce") },
            { "postOnly", this.safeBool(order, "postOnly") },
            { "side", this.safeString(order, "side") },
            { "amount", this.safeString(order, "size") },
            { "price", this.safeString(order, "price") },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "cost", this.safeString(order, "dealFunds") },
            { "filled", this.safeString(order, "dealSize") },
            { "remaining", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fee", new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(feeCurrencyId) },
                { "cost", this.safeNumber(order, "fee") },
            } },
            { "status", status },
            { "lastTradeTimestamp", null },
            { "average", null },
            { "trades", null },
        }, market);
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @see https://docs.kucoin.com/#list-fills
        * @see https://docs.kucoin.com/spot-hf/#transaction-details
        * @param {string} id order id
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        return await this.fetchMyTrades(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchMyTrades
        * @see https://docs.kucoin.com/#list-fills
        * @see https://docs.kucoin.com/spot-hf/#transaction-details
        * @description fetch all trades made by the user
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch entries for
        * @param {bool} [params.hf] false, // true for hf order
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        object hf = this.safeBool(parameters, "hf", false);
        if (isTrue(isTrue(hf) && isTrue(isEqual(symbol, null))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol parameter for hf orders")) ;
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["pageSize"] = limit;
        }
        object method = getValue(this.options, "fetchMyTradesMethod");
        object parseResponseData = false;
        object response = null;
        var requestparametersVariable = this.handleUntilOption("endAt", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(hf))
        {
            response = await this.privateGetHfFills(this.extend(request, parameters));
        } else if (isTrue(isEqual(method, "private_get_fills")))
        {
            // does not return trades earlier than 2019-02-18T00:00:00Z
            if (isTrue(!isEqual(since, null)))
            {
                // only returns trades up to one week after the since param
                ((IDictionary<string,object>)request)["startAt"] = since;
            }
            response = await this.privateGetFills(this.extend(request, parameters));
        } else if (isTrue(isEqual(method, "private_get_limit_fills")))
        {
            // does not return trades earlier than 2019-02-18T00:00:00Z
            // takes no params
            // only returns first 1000 trades (not only "in the last 24 hours" as stated in the docs)
            parseResponseData = true;
            response = await this.privateGetLimitFills(this.extend(request, parameters));
        } else
        {
            throw new ExchangeError ((string)add(this.id, " fetchMyTradesMethod() invalid method")) ;
        }
        //
        //     {
        //         "currentPage": 1,
        //         "pageSize": 50,
        //         "totalNum": 1,
        //         "totalPage": 1,
        //         "items": [
        //             {
        //                 "symbol":"BTC-USDT",       // symbol
        //                 "tradeId":"5c35c02709e4f67d5266954e",        // trade id
        //                 "orderId":"5c35c02703aa673ceec2a168",        // order id
        //                 "counterOrderId":"5c1ab46003aa676e487fa8e3", // counter order id
        //                 "side":"buy",              // transaction direction,include buy and sell
        //                 "liquidity":"taker",       // include taker and maker
        //                 "forceTaker":true,         // forced to become taker
        //                 "price":"0.083",           // order price
        //                 "size":"0.8424304",        // order quantity
        //                 "funds":"0.0699217232",    // order funds
        //                 "fee":"0",                 // fee
        //                 "feeRate":"0",             // fee rate
        //                 "feeCurrency":"USDT",      // charge fee currency
        //                 "stop":"",                 // stop type
        //                 "type":"limit",            // order type, e.g. limit, market, stop_limit.
        //                 "createdAt":1547026472000  // time
        //             },
        //             //------------------------------------------------------
        //             // v1 (historical) trade response structure
        //             {
        //                 "symbol": "SNOV-ETH",
        //                 "dealPrice": "0.0000246",
        //                 "dealValue": "0.018942",
        //                 "amount": "770",
        //                 "fee": "0.00001137",
        //                 "side": "sell",
        //                 "createdAt": 1540080199
        //                 "id":"5c4d389e4c8c60413f78e2e5",
        //             }
        //         ]
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object trades = null;
        if (isTrue(parseResponseData))
        {
            trades = data;
        } else
        {
            trades = this.safeList(data, "items", new List<object>() {});
        }
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://www.kucoin.com/docs/rest/spot-trading/market-data/get-trade-histories
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        // pagination is not supported on the exchange side anymore
        // if (since !== undefined) {
        //     request['startAt'] = Math.floor (since / 1000);
        // }
        // if (limit !== undefined) {
        //     request['pageSize'] = limit;
        // }
        object response = await this.publicGetMarketHistories(this.extend(request, parameters));
        //
        //     {
        //         "code": "200000",
        //         "data": [
        //             {
        //                 "sequence": "1548764654235",
        //                 "side": "sell",
        //                 "size":"0.6841354",
        //                 "price":"0.03202",
        //                 "time":1548848575203567174
        //             }
        //         ]
        //     }
        //
        object trades = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //     {
        //         "sequence": "1548764654235",
        //         "side": "sell",
        //         "size":"0.6841354",
        //         "price":"0.03202",
        //         "time":1548848575203567174
        //     }
        //
        //     {
        //         "sequence": "1568787654360",
        //         "symbol": "BTC-USDT",
        //         "side": "buy",
        //         "size": "0.00536577",
        //         "price": "9345",
        //         "takerOrderId": "5e356c4a9f1a790008f8d921",
        //         "time": "1580559434436443257",
        //         "type": "match",
        //         "makerOrderId": "5e356bffedf0010008fa5d7f",
        //         "tradeId": "5e356c4aeefabd62c62a1ece"
        //     }
        //
        // fetchMyTrades (private) v2
        //
        //     {
        //         "symbol":"BTC-USDT",
        //         "tradeId":"5c35c02709e4f67d5266954e",
        //         "orderId":"5c35c02703aa673ceec2a168",
        //         "counterOrderId":"5c1ab46003aa676e487fa8e3",
        //         "side":"buy",
        //         "liquidity":"taker",
        //         "forceTaker":true,
        //         "price":"0.083",
        //         "size":"0.8424304",
        //         "funds":"0.0699217232",
        //         "fee":"0",
        //         "feeRate":"0",
        //         "feeCurrency":"USDT",
        //         "stop":"",
        //         "type":"limit",
        //         "createdAt":1547026472000
        //     }
        //
        // fetchMyTrades v2 alternative format since 2019-05-21 https://github.com/ccxt/ccxt/pull/5162
        //
        //     {
        //         "symbol": "OPEN-BTC",
        //         "forceTaker":  false,
        //         "orderId": "5ce36420054b4663b1fff2c9",
        //         "fee": "0",
        //         "feeCurrency": "",
        //         "type": "",
        //         "feeRate": "0",
        //         "createdAt": 1558417615000,
        //         "size": "12.8206",
        //         "stop": "",
        //         "price": "0",
        //         "funds": "0",
        //         "tradeId": "5ce390cf6e0db23b861c6e80"
        //     }
        //
        // fetchMyTrades (private) v1 (historical)
        //
        //     {
        //         "symbol": "SNOV-ETH",
        //         "dealPrice": "0.0000246",
        //         "dealValue": "0.018942",
        //         "amount": "770",
        //         "fee": "0.00001137",
        //         "side": "sell",
        //         "createdAt": 1540080199
        //         "id":"5c4d389e4c8c60413f78e2e5",
        //     }
        //
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market, "-");
        object id = this.safeString2(trade, "tradeId", "id");
        object orderId = this.safeString(trade, "orderId");
        object takerOrMaker = this.safeString(trade, "liquidity");
        object timestamp = this.safeInteger(trade, "time");
        if (isTrue(!isEqual(timestamp, null)))
        {
            timestamp = this.parseToInt(divide(timestamp, 1000000));
        } else
        {
            timestamp = this.safeInteger(trade, "createdAt");
            // if it's a historical v1 trade, the exchange returns timestamp in seconds
            if (isTrue(isTrue((inOp(trade, "dealValue"))) && isTrue((!isEqual(timestamp, null)))))
            {
                timestamp = multiply(timestamp, 1000);
            }
        }
        object priceString = this.safeString2(trade, "price", "dealPrice");
        object amountString = this.safeString2(trade, "size", "amount");
        object side = this.safeString(trade, "side");
        object fee = null;
        object feeCostString = this.safeString(trade, "fee");
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCurrencyId = this.safeString(trade, "feeCurrency");
            object feeCurrency = this.safeCurrencyCode(feeCurrencyId);
            if (isTrue(isEqual(feeCurrency, null)))
            {
                feeCurrency = ((bool) isTrue((isEqual(side, "sell")))) ? getValue(market, "quote") : getValue(market, "base");
            }
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", feeCurrency },
                { "rate", this.safeString(trade, "feeRate") },
            };
        }
        object type = this.safeString(trade, "type");
        if (isTrue(isEqual(type, "match")))
        {
            type = null;
        }
        object costString = this.safeString2(trade, "funds", "dealValue");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "order", orderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "takerOrMaker", takerOrMaker },
            { "side", side },
            { "price", priceString },
            { "amount", amountString },
            { "cost", costString },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchTradingFee
        * @description fetch the trading fees for a market
        * @see https://www.kucoin.com/docs/rest/funding/trade-fee/trading-pair-actual-fee-spot-margin-trade_hf
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbols", getValue(market, "id") },
        };
        object response = await this.privateGetTradeFees(this.extend(request, parameters));
        //
        //     {
        //         "code": "200000",
        //         "data": [
        //           {
        //             "symbol": "BTC-USDT",
        //             "takerFeeRate": "0.001",
        //             "makerFeeRate": "0.001"
        //           }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0);
        object marketId = this.safeString(first, "symbol");
        return new Dictionary<string, object>() {
            { "info", response },
            { "symbol", this.safeSymbol(marketId, market) },
            { "maker", this.safeNumber(first, "makerFeeRate") },
            { "taker", this.safeNumber(first, "takerFeeRate") },
            { "percentage", true },
            { "tierBased", true },
        };
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#withdraw
        * @description make a withdrawal
        * @see https://www.kucoin.com/docs/rest/funding/withdrawals/apply-withdraw
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        this.checkAddress(address);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "address", address },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["memo"] = tag;
        }
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["chain"] = ((string)this.networkCodeToId(networkCode)).ToLower();
        }
        await this.loadCurrencyPrecision(currency, networkCode);
        ((IDictionary<string,object>)request)["amount"] = this.currencyToPrecision(code, amount, networkCode);
        object includeFee = null;
        var includeFeeparametersVariable = this.handleOptionAndParams(parameters, "withdraw", "includeFee", false);
        includeFee = ((IList<object>)includeFeeparametersVariable)[0];
        parameters = ((IList<object>)includeFeeparametersVariable)[1];
        if (isTrue(includeFee))
        {
            ((IDictionary<string,object>)request)["feeDeductType"] = "INTERNAL";
        }
        object response = await this.privatePostWithdrawals(this.extend(request, parameters));
        //
        // https://github.com/ccxt/ccxt/issues/5558
        //
        //     {
        //         "code":  200000,
        //         "data": {
        //             "withdrawalId":  "5bffb63303aa675e8bbe18f9"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTransaction(data, currency);
    }

    public async virtual Task loadCurrencyPrecision(object currency, object networkCode = null)
    {
        // as kucoin might not have network specific precisions defined in fetchCurrencies (because of webapi failure)
        // we should check and refetch precision once-per-instance for that specific currency & network
        // so avoids thorwing exceptions and burden to users
        // Note: this needs to be executed only if networkCode was provided
        if (isTrue(!isEqual(networkCode, null)))
        {
            object networks = getValue(currency, "networks");
            object network = this.safeDict(networks, networkCode);
            if (isTrue(!isEqual(this.safeNumber(network, "precision"), null)))
            {
                // if precision exists, no need to refetch
                return;
            }
            // otherwise try to fetch and store in instance
            object request = new Dictionary<string, object>() {
                { "currency", getValue(currency, "id") },
                { "chain", ((string)this.networkCodeToId(networkCode)).ToLower() },
            };
            object response = await this.privateGetWithdrawalsQuotas(request);
            //
            //    {
            //        "code": "200000",
            //        "data": {
            //            "currency": "USDT",
            //            "limitBTCAmount": "14.24094850",
            //            "usedBTCAmount": "0.00000000",
            //            "quotaCurrency": "USDT",
            //            "limitQuotaCurrencyAmount": "999999.00000000",
            //            "usedQuotaCurrencyAmount": "0",
            //            "remainAmount": "999999.0000",
            //            "availableAmount": "10.77545071",
            //            "withdrawMinFee": "1",
            //            "innerWithdrawMinFee": "0",
            //            "withdrawMinSize": "10",
            //            "isWithdrawEnabled": true,
            //            "precision": 4,
            //            "chain": "EOS",
            //            "reason": null,
            //            "lockedAmount": "0"
            //        }
            //    }
            //
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            object precision = this.parseNumber(this.parsePrecision(this.safeString(data, "precision")));
            object code = getValue(currency, "code");
            ((IDictionary<string,object>)getValue(getValue(getValue(this.currencies, code), "networks"), networkCode))["precision"] = precision;
        }
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "SUCCESS", "ok" },
            { "PROCESSING", "pending" },
            { "WALLET_PROCESSING", "pending" },
            { "FAILURE", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //     {
        //         "address": "0x5f047b29041bcfdbf0e4478cdfa753a336ba6989",
        //         "memo": "5c247c8a03aa677cea2a251d",
        //         "amount": 1,
        //         "fee": 0.0001,
        //         "currency": "KCS",
        //         "chain": "",
        //         "isInner": false,
        //         "walletTxId": "5bbb57386d99522d9f954c5a@test004",
        //         "status": "SUCCESS",
        //         "createdAt": 1544178843000,
        //         "updatedAt": 1544178891000
        //         "remark":"foobar"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "id": "5c2dc64e03aa675aa263f1ac",
        //         "address": "0x5bedb060b8eb8d823e2414d82acce78d38be7fe9",
        //         "memo": "",
        //         "currency": "ETH",
        //         "chain": "",
        //         "amount": 1.0000000,
        //         "fee": 0.0100000,
        //         "walletTxId": "3e2414d82acce78d38be7fe9",
        //         "isInner": false,
        //         "status": "FAILURE",
        //         "createdAt": 1546503758000,
        //         "updatedAt": 1546504603000
        //         "remark":"foobar"
        //     }
        //
        // withdraw
        //
        //     {
        //         "withdrawalId":  "5bffb63303aa675e8bbe18f9"
        //     }
        //
        object currencyId = this.safeString(transaction, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object address = this.safeString(transaction, "address");
        object amount = this.safeString(transaction, "amount");
        object txid = this.safeString(transaction, "walletTxId");
        if (isTrue(!isEqual(txid, null)))
        {
            object txidParts = ((string)txid).Split(new [] {((string)"@")}, StringSplitOptions.None).ToList<object>();
            object numTxidParts = getArrayLength(txidParts);
            if (isTrue(isGreaterThan(numTxidParts, 1)))
            {
                if (isTrue(isEqual(address, null)))
                {
                    if (isTrue(isGreaterThan(((string)getValue(txidParts, 1)).Length, 1)))
                    {
                        address = getValue(txidParts, 1);
                    }
                }
            }
            txid = getValue(txidParts, 0);
        }
        object type = ((bool) isTrue((isEqual(txid, null)))) ? "withdrawal" : "deposit";
        object rawStatus = this.safeString(transaction, "status");
        object fee = null;
        object feeCost = this.safeString(transaction, "fee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            object rate = null;
            if (isTrue(!isEqual(amount, null)))
            {
                rate = Precise.stringDiv(feeCost, amount);
            }
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(feeCost) },
                { "rate", this.parseNumber(rate) },
                { "currency", code },
            };
        }
        object timestamp = this.safeInteger2(transaction, "createdAt", "createAt");
        object updated = this.safeInteger(transaction, "updatedAt");
        object isV1 = !isTrue((inOp(transaction, "createdAt")));
        // if it's a v1 structure
        if (isTrue(isV1))
        {
            type = ((bool) isTrue((inOp(transaction, "address")))) ? "withdrawal" : "deposit";
            if (isTrue(!isEqual(timestamp, null)))
            {
                timestamp = multiply(timestamp, 1000);
            }
            if (isTrue(!isEqual(updated, null)))
            {
                updated = multiply(updated, 1000);
            }
        }
        object intern = this.safeBool(transaction, "isInner");
        object tag = this.safeString(transaction, "memo");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString2(transaction, "id", "withdrawalId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", this.networkIdToCode(this.safeString(transaction, "chain")) },
            { "address", address },
            { "addressTo", address },
            { "addressFrom", null },
            { "tag", tag },
            { "tagTo", tag },
            { "tagFrom", null },
            { "currency", code },
            { "amount", this.parseNumber(amount) },
            { "txid", txid },
            { "type", type },
            { "status", this.parseTransactionStatus(rawStatus) },
            { "comment", this.safeString(transaction, "remark") },
            { "internal", intern },
            { "fee", fee },
            { "updated", updated },
        };
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://www.kucoin.com/docs/rest/funding/deposit/get-deposit-list
        * @see https://www.kucoin.com/docs/rest/funding/deposit/get-v1-historical-deposits-list
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch entries for
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchDeposits", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchDeposits", code, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["pageSize"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("endAt", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = null;
        if (isTrue(isTrue(!isEqual(since, null)) && isTrue(isLessThan(since, 1550448000000))))
        {
            // if since is earlier than 2019-02-18T00:00:00Z
            ((IDictionary<string,object>)request)["startAt"] = this.parseToInt(divide(since, 1000));
            response = await this.privateGetHistDeposits(this.extend(request, parameters));
        } else
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["startAt"] = since;
            }
            response = await this.privateGetDeposits(this.extend(request, parameters));
        }
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "currentPage": 1,
        //             "pageSize": 5,
        //             "totalNum": 2,
        //             "totalPage": 1,
        //             "items": [
        //                 //--------------------------------------------------
        //                 // version 2 deposit response structure
        //                 {
        //                     "address": "0x5f047b29041bcfdbf0e4478cdfa753a336ba6989",
        //                     "memo": "5c247c8a03aa677cea2a251d",
        //                     "amount": 1,
        //                     "fee": 0.0001,
        //                     "currency": "KCS",
        //                     "isInner": false,
        //                     "walletTxId": "5bbb57386d99522d9f954c5a@test004",
        //                     "status": "SUCCESS",
        //                     "createdAt": 1544178843000,
        //                     "updatedAt": 1544178891000
        //                     "remark":"foobar"
        //                 },
        //                 //--------------------------------------------------
        //                 // version 1 (historical) deposit response structure
        //                 {
        //                     "currency": "BTC",
        //                     "createAt": 1528536998,
        //                     "amount": "0.03266638",
        //                     "walletTxId": "55c643bc2c68d6f17266383ac1be9e454038864b929ae7cee0bc408cc5c869e8@12ffGWmMMD1zA1WbFm7Ho3JZ1w6NYXjpFk@234",
        //                     "isInner": false,
        //                     "status": "SUCCESS",
        //                 }
        //             ]
        //         }
        //     }
        //
        object responseData = getValue(getValue(response, "data"), "items");
        return this.parseTransactions(responseData, currency, since, limit, new Dictionary<string, object>() {
            { "type", "deposit" },
        });
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://www.kucoin.com/docs/rest/funding/withdrawals/get-withdrawals-list
        * @see https://www.kucoin.com/docs/rest/funding/withdrawals/get-v1-historical-withdrawals-list
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch entries for
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchWithdrawals", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchWithdrawals", code, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["pageSize"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("endAt", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = null;
        if (isTrue(isTrue(!isEqual(since, null)) && isTrue(isLessThan(since, 1550448000000))))
        {
            // if since is earlier than 2019-02-18T00:00:00Z
            ((IDictionary<string,object>)request)["startAt"] = this.parseToInt(divide(since, 1000));
            response = await this.privateGetHistWithdrawals(this.extend(request, parameters));
        } else
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["startAt"] = since;
            }
            response = await this.privateGetWithdrawals(this.extend(request, parameters));
        }
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "currentPage": 1,
        //             "pageSize": 5,
        //             "totalNum": 2,
        //             "totalPage": 1,
        //             "items": [
        //                 //--------------------------------------------------
        //                 // version 2 withdrawal response structure
        //                 {
        //                     "id": "5c2dc64e03aa675aa263f1ac",
        //                     "address": "0x5bedb060b8eb8d823e2414d82acce78d38be7fe9",
        //                     "memo": "",
        //                     "currency": "ETH",
        //                     "amount": 1.0000000,
        //                     "fee": 0.0100000,
        //                     "walletTxId": "3e2414d82acce78d38be7fe9",
        //                     "isInner": false,
        //                     "status": "FAILURE",
        //                     "createdAt": 1546503758000,
        //                     "updatedAt": 1546504603000
        //                 },
        //                 //--------------------------------------------------
        //                 // version 1 (historical) withdrawal response structure
        //                 {
        //                     "currency": "BTC",
        //                     "createAt": 1526723468,
        //                     "amount": "0.534",
        //                     "address": "33xW37ZSW4tQvg443Pc7NLCAs167Yc2XUV",
        //                     "walletTxId": "aeacea864c020acf58e51606169240e96774838dcd4f7ce48acf38e3651323f4",
        //                     "isInner": false,
        //                     "status": "SUCCESS"
        //                 }
        //             ]
        //         }
        //     }
        //
        object responseData = getValue(getValue(response, "data"), "items");
        return this.parseTransactions(responseData, currency, since, limit, new Dictionary<string, object>() {
            { "type", "withdrawal" },
        });
    }

    public virtual object parseBalanceHelper(object entry)
    {
        object account = this.account();
        ((IDictionary<string,object>)account)["used"] = this.safeString2(entry, "holdBalance", "hold");
        ((IDictionary<string,object>)account)["free"] = this.safeString2(entry, "availableBalance", "available");
        ((IDictionary<string,object>)account)["total"] = this.safeString2(entry, "totalBalance", "total");
        object debt = this.safeString(entry, "liability");
        object interest = this.safeString(entry, "interest");
        ((IDictionary<string,object>)account)["debt"] = Precise.stringAdd(debt, interest);
        return account;
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://www.kucoin.com/docs/rest/account/basic-info/get-account-list-spot-margin-trade_hf
        * @see https://www.kucoin.com/docs/rest/funding/funding-overview/get-account-detail-margin
        * @see https://www.kucoin.com/docs/rest/funding/funding-overview/get-account-detail-isolated-margin
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {object} [params.marginMode] 'cross' or 'isolated', margin type for fetching margin balance
        * @param {object} [params.type] extra parameters specific to the exchange API endpoint
        * @param {object} [params.hf] *default if false* if true, the result includes the balance of the high frequency account
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object code = this.safeString(parameters, "code");
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object defaultType = this.safeString2(this.options, "fetchBalance", "defaultType", "spot");
        object requestedType = this.safeString(parameters, "type", defaultType);
        object accountsByType = this.safeDict(this.options, "accountsByType");
        object type = this.safeString(accountsByType, requestedType, requestedType);
        parameters = this.omit(parameters, "type");
        object isHf = this.safeBool(parameters, "hf", false);
        if (isTrue(isHf))
        {
            type = "trade_hf";
        }
        parameters = this.omit(parameters, "hf");
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchBalance", parameters);
        var marginMode = ((IList<object>) marginModequeryVariable)[0];
        var query = ((IList<object>) marginModequeryVariable)[1];
        object response = null;
        object request = new Dictionary<string, object>() {};
        object isolated = isTrue((isEqual(marginMode, "isolated"))) || isTrue((isEqual(type, "isolated")));
        object cross = isTrue((isEqual(marginMode, "cross"))) || isTrue((isEqual(type, "margin")));
        if (isTrue(isolated))
        {
            if (isTrue(!isEqual(currency, null)))
            {
                ((IDictionary<string,object>)request)["balanceCurrency"] = getValue(currency, "id");
            }
            response = await this.privateGetIsolatedAccounts(this.extend(request, query));
        } else if (isTrue(cross))
        {
            response = await this.privateGetMarginAccount(this.extend(request, query));
        } else
        {
            if (isTrue(!isEqual(currency, null)))
            {
                ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
            }
            ((IDictionary<string,object>)request)["type"] = type;
            response = await this.privateGetAccounts(this.extend(request, query));
        }
        //
        // Spot
        //
        //    {
        //        "code": "200000",
        //        "data": [
        //            {
        //                "balance": "0.00009788",
        //                "available": "0.00009788",
        //                "holds": "0",
        //                "currency": "BTC",
        //                "id": "5c6a4fd399a1d81c4f9cc4d0",
        //                "type": "trade",
        //            },
        //        ]
        //    }
        //
        // Cross
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "debtRatio": "0",
        //             "accounts": [
        //                 {
        //                     "currency": "USDT",
        //                     "totalBalance": "5",
        //                     "availableBalance": "5",
        //                     "holdBalance": "0",
        //                     "liability": "0",
        //                     "maxBorrowSize": "20"
        //                 },
        //             ]
        //         }
        //     }
        //
        // Isolated
        //
        //    {
        //        "code": "200000",
        //        "data": {
        //            "totalAssetOfQuoteCurrency": "0",
        //            "totalLiabilityOfQuoteCurrency": "0",
        //            "timestamp": 1712085661155,
        //            "assets": [
        //                {
        //                    "symbol": "MANA-USDT",
        //                    "status": "EFFECTIVE",
        //                    "debtRatio": "0",
        //                    "baseAsset": {
        //                        "currency": "MANA",
        //                        "borrowEnabled": true,
        //                        "transferInEnabled": true,
        //                        "total": "0",
        //                        "hold": "0",
        //                        "available": "0",
        //                        "liability": "0",
        //                        "interest": "0",
        //                        "maxBorrowSize": "0"
        //                    },
        //                    "quoteAsset": {
        //                        "currency": "USDT",
        //                        "borrowEnabled": true,
        //                        "transferInEnabled": true,
        //                        "total": "0",
        //                        "hold": "0",
        //                        "available": "0",
        //                        "liability": "0",
        //                        "interest": "0",
        //                        "maxBorrowSize": "0"
        //                    }
        //                },
        //                ...
        //            ]
        //        }
        //    }
        //
        object data = null;
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        if (isTrue(isolated))
        {
            data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            object assets = this.safeValue(data, "assets", data);
            for (object i = 0; isLessThan(i, getArrayLength(assets)); postFixIncrement(ref i))
            {
                object entry = getValue(assets, i);
                object marketId = this.safeString(entry, "symbol");
                object symbol = this.safeSymbol(marketId, null, "_");
                object bs = this.safeDict(entry, "baseAsset", new Dictionary<string, object>() {});
                object quote = this.safeDict(entry, "quoteAsset", new Dictionary<string, object>() {});
                object baseCode = this.safeCurrencyCode(this.safeString(bs, "currency"));
                object quoteCode = this.safeCurrencyCode(this.safeString(quote, "currency"));
                object subResult = new Dictionary<string, object>() {};
                ((IDictionary<string,object>)subResult)[(string)baseCode] = this.parseBalanceHelper(bs);
                ((IDictionary<string,object>)subResult)[(string)quoteCode] = this.parseBalanceHelper(quote);
                ((IDictionary<string,object>)result)[(string)symbol] = this.safeBalance(subResult);
            }
        } else if (isTrue(cross))
        {
            data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            object accounts = this.safeList(data, "accounts", new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(accounts)); postFixIncrement(ref i))
            {
                object balance = getValue(accounts, i);
                object currencyId = this.safeString(balance, "currency");
                object codeInner = this.safeCurrencyCode(currencyId);
                ((IDictionary<string,object>)result)[(string)codeInner] = this.parseBalanceHelper(balance);
            }
        } else
        {
            data = this.safeList(response, "data", new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object balance = getValue(data, i);
                object balanceType = this.safeString(balance, "type");
                if (isTrue(isEqual(balanceType, type)))
                {
                    object currencyId = this.safeString(balance, "currency");
                    object codeInner2 = this.safeCurrencyCode(currencyId);
                    object account = this.account();
                    ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "balance");
                    ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "available");
                    ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "holds");
                    ((IDictionary<string,object>)result)[(string)codeInner2] = account;
                }
            }
        }
        object returnType = ((bool) isTrue(isolated)) ? result : this.safeBalance(result);
        return returnType;
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#transfer
        * @description transfer currency internally between wallets on the same account
        * @see https://www.kucoin.com/docs/rest/funding/transfer/inner-transfer
        * @see https://docs.kucoin.com/futures/#transfer-funds-to-kucoin-main-account-2
        * @see https://docs.kucoin.com/spot-hf/#internal-funds-transfers-in-high-frequency-trading-accounts
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object requestedAmount = this.currencyToPrecision(code, amount);
        object fromId = this.convertTypeToAccount(fromAccount);
        object toId = this.convertTypeToAccount(toAccount);
        object fromIsolated = this.inArray(fromId, this.ids);
        object toIsolated = this.inArray(toId, this.ids);
        if (isTrue(isEqual(fromId, "contract")))
        {
            if (isTrue(!isEqual(toId, "main")))
            {
                throw new ExchangeError ((string)add(this.id, " transfer() only supports transferring from futures account to main account")) ;
            }
            object request = new Dictionary<string, object>() {
                { "currency", getValue(currency, "id") },
                { "amount", requestedAmount },
            };
            if (!isTrue((inOp(parameters, "bizNo"))))
            {
                // it doesn't like more than 24 characters
                ((IDictionary<string,object>)request)["bizNo"] = this.uuid22();
            }
            object response = await this.futuresPrivatePostTransferOut(this.extend(request, parameters));
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //             "applyId": "605a87217dff1500063d485d",
            //             "bizNo": "bcd6e5e1291f4905af84dc",
            //             "payAccountType": "CONTRACT",
            //             "payTag": "DEFAULT",
            //             "remark": '',
            //             "recAccountType": "MAIN",
            //             "recTag": "DEFAULT",
            //             "recRemark": '',
            //             "recSystem": "KUCOIN",
            //             "status": "PROCESSING",
            //             "currency": "XBT",
            //             "amount": "0.00001",
            //             "fee": "0",
            //             "sn": "573688685663948",
            //             "reason": '',
            //             "createdAt": 1616545569000,
            //             "updatedAt": 1616545569000
            //         }
            //     }
            //
            object data = this.safeDict(response, "data");
            return this.parseTransfer(data, currency);
        } else
        {
            object request = new Dictionary<string, object>() {
                { "currency", getValue(currency, "id") },
                { "amount", requestedAmount },
            };
            if (isTrue(isTrue(fromIsolated) || isTrue(toIsolated)))
            {
                if (isTrue(this.inArray(fromId, this.ids)))
                {
                    ((IDictionary<string,object>)request)["fromTag"] = fromId;
                    fromId = "isolated";
                }
                if (isTrue(this.inArray(toId, this.ids)))
                {
                    ((IDictionary<string,object>)request)["toTag"] = toId;
                    toId = "isolated";
                }
            }
            ((IDictionary<string,object>)request)["from"] = fromId;
            ((IDictionary<string,object>)request)["to"] = toId;
            if (!isTrue((inOp(parameters, "clientOid"))))
            {
                ((IDictionary<string,object>)request)["clientOid"] = this.uuid();
            }
            object response = await this.privatePostAccountsInnerTransfer(this.extend(request, parameters));
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //              "orderId": "605a6211e657f00006ad0ad6"
            //         }
            //     }
            //
            object data = this.safeDict(response, "data");
            return this.parseTransfer(data, currency);
        }
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer (spot)
        //
        //    {
        //        "orderId": "605a6211e657f00006ad0ad6"
        //    }
        //
        //    {
        //        "code": "200000",
        //        "msg": "Failed to transfer out. The amount exceeds the upper limit"
        //    }
        //
        // transfer (futures)
        //
        //     {
        //         "applyId": "605a87217dff1500063d485d",
        //         "bizNo": "bcd6e5e1291f4905af84dc",
        //         "payAccountType": "CONTRACT",
        //         "payTag": "DEFAULT",
        //         "remark": '',
        //         "recAccountType": "MAIN",
        //         "recTag": "DEFAULT",
        //         "recRemark": '',
        //         "recSystem": "KUCOIN",
        //         "status": "PROCESSING",
        //         "currency": "XBT",
        //         "amount": "0.00001",
        //         "fee": "0",
        //         "sn": "573688685663948",
        //         "reason": '',
        //         "createdAt": 1616545569000,
        //         "updatedAt": 1616545569000
        //     }
        //
        object timestamp = this.safeInteger(transfer, "createdAt");
        object currencyId = this.safeString(transfer, "currency");
        object rawStatus = this.safeString(transfer, "status");
        object accountFromRaw = this.safeStringLower(transfer, "payAccountType");
        object accountToRaw = this.safeStringLower(transfer, "recAccountType");
        object accountsByType = this.safeDict(this.options, "accountsByType");
        object accountFrom = this.safeString(accountsByType, accountFromRaw, accountFromRaw);
        object accountTo = this.safeString(accountsByType, accountToRaw, accountToRaw);
        return new Dictionary<string, object>() {
            { "id", this.safeString2(transfer, "applyId", "orderId") },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "amount", this.safeNumber(transfer, "amount") },
            { "fromAccount", accountFrom },
            { "toAccount", accountTo },
            { "status", this.parseTransferStatus(rawStatus) },
            { "info", transfer },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "PROCESSING", "pending" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "Assets Transferred in After Upgrading", "transfer" },
            { "Deposit", "transaction" },
            { "Withdrawal", "transaction" },
            { "Transfer", "transfer" },
            { "Trade_Exchange", "trade" },
            { "KuCoin Bonus", "bonus" },
            { "Referral Bonus", "referral" },
            { "Rewards", "bonus" },
            { "Airdrop/Fork", "airdrop" },
            { "Other rewards", "bonus" },
            { "Fee Rebate", "rebate" },
            { "Buy Crypto", "trade" },
            { "Sell Crypto", "sell" },
            { "Public Offering Purchase", "trade" },
            { "Refunded Fees", "fee" },
            { "KCS Pay Fees", "fee" },
            { "Margin Trade", "trade" },
            { "Loans", "Loans" },
            { "Instant Exchange", "trade" },
            { "Sub-account transfer", "transfer" },
            { "Liquidation Fees", "fee" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //         "id": "611a1e7c6a053300067a88d9", //unique key for each ledger entry
        //         "currency": "USDT", //Currency
        //         "amount": "10.00059547", //The total amount of assets (fees included) involved in assets changes such as transaction, withdrawal and bonus distribution.
        //         "fee": "0", //Deposit or withdrawal fee
        //         "balance": "0", //Total assets of a currency remaining funds after transaction
        //         "accountType": "MAIN", //Account Type
        //         "bizType": "Loans Repaid", //business type
        //         "direction": "in", //side, in or out
        //         "createdAt": 1629101692950, //Creation time
        //         "context": "{\"borrowerUserId\":\"601ad03e50dc810006d242ea\",\"loanRepayDetailNo\":\"611a1e7cc913d000066cf7ec\"}" //Business core parameters
        //     }
        //
        object id = this.safeString(item, "id");
        object currencyId = this.safeString(item, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object amount = this.safeNumber(item, "amount");
        object balanceAfter = null;
        // const balanceAfter = this.safeNumber (item, 'balance'); only returns zero string
        object bizType = this.safeString(item, "bizType");
        object type = this.parseLedgerEntryType(bizType);
        object direction = this.safeString(item, "direction");
        object timestamp = this.safeInteger(item, "createdAt");
        object datetime = this.iso8601(timestamp);
        object account = this.safeString(item, "accountType"); // MAIN, TRADE, MARGIN, or CONTRACT
        object context = this.safeString(item, "context"); // contains other information about the ledger entry
        //
        // withdrawal transaction
        //
        //     "{\"orderId\":\"617bb2d09e7b3b000196dac8\",\"txId\":\"0x79bb9855f86b351a45cab4dc69d78ca09586a94c45dde49475722b98f401b054\"}"
        //
        // deposit to MAIN, trade via MAIN
        //
        //     "{\"orderId\":\"617ab9949e7b3b0001948081\",\"txId\":\"0x7a06b16bbd6b03dbc3d96df5683b15229fc35e7184fd7179a5f3a310bd67d1fa@default@0\"}"
        //
        // sell trade
        //
        //     "{\"symbol\":\"ETH-USDT\",\"orderId\":\"617adcd1eb3fa20001dd29a1\",\"tradeId\":\"617adcd12e113d2b91222ff9\"}"
        //
        object referenceId = null;
        if (isTrue(isTrue(!isEqual(context, null)) && isTrue(!isEqual(context, ""))))
        {
            try
            {
                object parsed = parseJson(context);
                object orderId = this.safeString(parsed, "orderId");
                object tradeId = this.safeString(parsed, "tradeId");
                // transactions only have an orderId but for trades we wish to use tradeId
                if (isTrue(!isEqual(tradeId, null)))
                {
                    referenceId = tradeId;
                } else
                {
                    referenceId = orderId;
                }
            } catch(Exception exc)
            {
                referenceId = context;
            }
        }
        object fee = null;
        object feeCost = this.safeString(item, "fee");
        object feeCurrency = null;
        if (isTrue(!isEqual(feeCost, "0")))
        {
            feeCurrency = code;
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(feeCost) },
                { "currency", feeCurrency },
            };
        }
        return new Dictionary<string, object>() {
            { "id", id },
            { "direction", direction },
            { "account", account },
            { "referenceId", referenceId },
            { "referenceAccount", account },
            { "type", type },
            { "currency", code },
            { "amount", amount },
            { "timestamp", timestamp },
            { "datetime", datetime },
            { "before", null },
            { "after", balanceAfter },
            { "status", null },
            { "fee", fee },
            { "info", item },
        };
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchLedger
        * @see https://www.kucoin.com/docs/rest/account/basic-info/get-account-ledgers-spot-margin
        * @see https://www.kucoin.com/docs/rest/account/basic-info/get-account-ledgers-trade_hf
        * @see https://www.kucoin.com/docs/rest/account/basic-info/get-account-ledgers-margin_hf
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @param {string} code unified currency code, default is undefined
        * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int} [limit] max number of ledger entrys to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.hf] default false, when true will fetch ledger entries for the high frequency trading account
        * @param {int} [params.until] the latest time in ms to fetch entries for
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchLedger", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        object isHf = this.safeBool(parameters, "hf");
        parameters = this.omit(parameters, "hf");
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchLedger", code, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startAt"] = since;
        }
        // atm only single currency retrieval is supported
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        var requestparametersVariable = this.handleUntilOption("endAt", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchLedger", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object response = null;
        if (isTrue(isHf))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                response = await this.privateGetHfMarginAccountLedgers(this.extend(request, parameters));
            } else
            {
                response = await this.privateGetHfAccountsLedgers(this.extend(request, parameters));
            }
        } else
        {
            response = await this.privateGetAccountsLedgers(this.extend(request, parameters));
        }
        //
        //     {
        //         "code":"200000",
        //         "data":{
        //             "currentPage":1,
        //             "pageSize":50,
        //             "totalNum":1,
        //             "totalPage":1,
        //             "items":[
        //                 {
        //                     "id":"617cc528729f5f0001c03ceb",
        //                     "currency":"GAS",
        //                     "amount":"0.00000339",
        //                     "fee":"0",
        //                     "balance":"0",
        //                     "accountType":"MAIN",
        //                     "bizType":"Distribution",
        //                     "direction":"in",
        //                     "createdAt":1635566888183,
        //                     "context":"{\"orderId\":\"617cc47a1c47ed0001ce3606\",\"description\":\"Holding NEO,distribute GAS(2021/10/30)\"}"
        //                 }
        //                 {
        //                     "id": "611a1e7c6a053300067a88d9",//unique key
        //                     "currency": "USDT", //Currency
        //                     "amount": "10.00059547", //Change amount of the funds
        //                     "fee": "0", //Deposit or withdrawal fee
        //                     "balance": "0", //Total assets of a currency
        //                     "accountType": "MAIN", //Account Type
        //                     "bizType": "Loans Repaid", //business type
        //                     "direction": "in", //side, in or out
        //                     "createdAt": 1629101692950, //Creation time
        //                     "context": "{\"borrowerUserId\":\"601ad03e50dc810006d242ea\",\"loanRepayDetailNo\":\"611a1e7cc913d000066cf7ec\"}"
        //                 },
        //             ]
        //         }
        //     }
        //
        object dataList = this.safeList(response, "data");
        if (isTrue(!isEqual(dataList, null)))
        {
            return this.parseLedger(dataList, currency, since, limit);
        }
        object data = this.safeDict(response, "data");
        object items = this.safeList(data, "items", new List<object>() {});
        return this.parseLedger(items, currency, since, limit);
    }

    public override object calculateRateLimiterCost(object api, object method, object path, object parameters, object config = null)
    {
        config ??= new Dictionary<string, object>();
        object versions = this.safeDict(this.options, "versions", new Dictionary<string, object>() {});
        object apiVersions = this.safeDict(versions, api, new Dictionary<string, object>() {});
        object methodVersions = this.safeDict(apiVersions, method, new Dictionary<string, object>() {});
        object defaultVersion = this.safeString(methodVersions, path, getValue(this.options, "version"));
        object version = this.safeString(parameters, "version", defaultVersion);
        if (isTrue(isTrue(isEqual(version, "v3")) && isTrue((inOp(config, "v3")))))
        {
            return getValue(config, "v3");
        } else if (isTrue(isTrue(isEqual(version, "v2")) && isTrue((inOp(config, "v2")))))
        {
            return getValue(config, "v2");
        } else if (isTrue(isTrue(isEqual(version, "v1")) && isTrue((inOp(config, "v1")))))
        {
            return getValue(config, "v1");
        }
        return this.safeValue(config, "cost", 1);
    }

    public virtual object parseBorrowRateHistory(object response, object code, object since, object limit)
    {
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object item = getValue(response, i);
            object borrowRate = this.parseBorrowRate(item);
            ((IList<object>)result).Add(borrowRate);
        }
        object sorted = this.sortBy(result, "timestamp");
        return this.filterByCurrencySinceLimit(sorted, code, since, limit);
    }

    public virtual object parseBorrowRate(object info, object currency = null)
    {
        //
        //     {
        //         "tradeId": "62db2dcaff219600012b56cd",
        //         "currency": "USDT",
        //         "size": "10",
        //         "dailyIntRate": "0.00003",
        //         "term": 7,
        //         "timestamp": 1658531274508488480
        //     },
        //
        //     {
        //         "createdAt": 1697783812257,
        //         "currency": "XMR",
        //         "interestAmount": "0.1",
        //         "dayRatio": "0.001"
        //     }
        //
        object timestampId = this.safeString2(info, "createdAt", "timestamp");
        object timestamp = this.parseToInt(slice(timestampId, 0, 13));
        object currencyId = this.safeString(info, "currency");
        return new Dictionary<string, object>() {
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "rate", this.safeNumber2(info, "dailyIntRate", "dayRatio") },
            { "period", 86400000 },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async override Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchBorrowInterest
        * @description fetch the interest owed by the user for borrowing currency for margin trading
        * @see https://docs.kucoin.com/#get-repay-record
        * @see https://docs.kucoin.com/#query-isolated-margin-account-info
        * @param {string} code unified currency code
        * @param {string} symbol unified market symbol, required for isolated margin
        * @param {int} [since] the earliest time in ms to fetch borrrow interest for
        * @param {int} [limit] the maximum number of structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'cross' or 'isolated' default is 'cross'
        * @returns {object[]} a list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBorrowInterest", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, null)))
        {
            marginMode = "cross"; // cross as default marginMode
        }
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(!isEqual(code, null)))
        {
            object currency = this.currency(code);
            ((IDictionary<string,object>)request)["quoteCurrency"] = getValue(currency, "id");
        }
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            response = await this.privateGetIsolatedAccounts(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetMarginAccounts(this.extend(request, parameters));
        }
        //
        // Cross
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "totalAssetOfQuoteCurrency": "0",
        //             "totalLiabilityOfQuoteCurrency": "0",
        //             "debtRatio": "0",
        //             "status": "EFFECTIVE",
        //             "accounts": [
        //                 {
        //                     "currency": "1INCH",
        //                     "total": "0",
        //                     "available": "0",
        //                     "hold": "0",
        //                     "liability": "0",
        //                     "maxBorrowSize": "0",
        //                     "borrowEnabled": true,
        //                     "transferInEnabled": true
        //                 }
        //             ]
        //         }
        //     }
        //
        // Isolated
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "totalConversionBalance": "0.02138647",
        //             "liabilityConversionBalance": "0.01480001",
        //             "assets": [
        //                 {
        //                     "symbol": "MANA-USDT",
        //                     "debtRatio": "0",
        //                     "status": "BORROW",
        //                     "baseAsset": {
        //                         "currency": "MANA",
        //                         "borrowEnabled": true,
        //                         "repayEnabled": true,
        //                         "transferEnabled": true,
        //                         "borrowed": "0",
        //                         "totalAsset": "0",
        //                         "available": "0",
        //                         "hold": "0",
        //                         "maxBorrowSize": "1000"
        //                     },
        //                     "quoteAsset": {
        //                         "currency": "USDT",
        //                         "borrowEnabled": true,
        //                         "repayEnabled": true,
        //                         "transferEnabled": true,
        //                         "borrowed": "0",
        //                         "totalAsset": "0",
        //                         "available": "0",
        //                         "hold": "0",
        //                         "maxBorrowSize": "50000"
        //                     }
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object assets = ((bool) isTrue((isEqual(marginMode, "isolated")))) ? this.safeList(data, "assets", new List<object>() {}) : this.safeList(data, "accounts", new List<object>() {});
        return this.parseBorrowInterests(assets, null);
    }

    public override object parseBorrowInterest(object info, object market = null)
    {
        //
        // Cross
        //
        //     {
        //         "currency": "1INCH",
        //         "total": "0",
        //         "available": "0",
        //         "hold": "0",
        //         "liability": "0",
        //         "maxBorrowSize": "0",
        //         "borrowEnabled": true,
        //         "transferInEnabled": true
        //     }
        //
        // Isolated
        //
        //     {
        //         "symbol": "MANA-USDT",
        //         "debtRatio": "0",
        //         "status": "BORROW",
        //         "baseAsset": {
        //             "currency": "MANA",
        //             "borrowEnabled": true,
        //             "repayEnabled": true,
        //             "transferEnabled": true,
        //             "borrowed": "0",
        //             "totalAsset": "0",
        //             "available": "0",
        //             "hold": "0",
        //             "maxBorrowSize": "1000"
        //         },
        //         "quoteAsset": {
        //             "currency": "USDT",
        //             "borrowEnabled": true,
        //             "repayEnabled": true,
        //             "transferEnabled": true,
        //             "borrowed": "0",
        //             "totalAsset": "0",
        //             "available": "0",
        //             "hold": "0",
        //             "maxBorrowSize": "50000"
        //         }
        //     }
        //
        object marketId = this.safeString(info, "symbol");
        object marginMode = ((bool) isTrue((isEqual(marketId, null)))) ? "cross" : "isolated";
        market = this.safeMarket(marketId, market);
        object symbol = this.safeString(market, "symbol");
        object timestamp = this.safeInteger(info, "createdAt");
        object isolatedBase = this.safeDict(info, "baseAsset", new Dictionary<string, object>() {});
        object amountBorrowed = null;
        object interest = null;
        object currencyId = null;
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            amountBorrowed = this.safeNumber(isolatedBase, "liability");
            interest = this.safeNumber(isolatedBase, "interest");
            currencyId = this.safeString(isolatedBase, "currency");
        } else
        {
            amountBorrowed = this.safeNumber(info, "liability");
            interest = this.safeNumber(info, "accruedInterest");
            currencyId = this.safeString(info, "currency");
        }
        return new Dictionary<string, object>() {
            { "symbol", symbol },
            { "marginMode", marginMode },
            { "currency", this.safeCurrencyCode(currencyId) },
            { "interest", interest },
            { "interestRate", this.safeNumber(info, "dailyIntRate") },
            { "amountBorrowed", amountBorrowed },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async virtual Task<object> fetchBorrowRateHistories(object codes = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchBorrowRateHistories
        * @description retrieves a history of a multiple currencies borrow interest rate at specific time slots, returns all currencies if no symbols passed, default is undefined
        * @see https://www.kucoin.com/docs/rest/margin-trading/margin-trading-v3-/get-cross-isolated-margin-interest-records
        * @param {string[]|undefined} codes list of unified currency codes, default is undefined
        * @param {int} [since] timestamp in ms of the earliest borrowRate, default is undefined
        * @param {int} [limit] max number of borrow rate prices to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'cross' or 'isolated' default is 'cross'
        * @param {int} [params.until] the latest time in ms to fetch entries for
        * @returns {object} a dictionary of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure} indexed by the market symbol
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marginResult = this.handleMarginModeAndParams("fetchBorrowRateHistories", parameters);
        object marginMode = this.safeString(marginResult, 0, "cross");
        object isIsolated = (isEqual(marginMode, "isolated")); // true-isolated, false-cross
        object request = new Dictionary<string, object>() {
            { "isIsolated", isIsolated },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["pageSize"] = limit; // default:50, min:10, max:500
        }
        object response = await this.privateGetMarginInterest(this.extend(request, parameters));
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "timestamp": 1710829939673,
        //             "currentPage": 1,
        //             "pageSize": 50,
        //             "totalNum": 0,
        //             "totalPage": 0,
        //             "items": [
        //                 {
        //                     "createdAt": 1697783812257,
        //                     "currency": "XMR",
        //                     "interestAmount": "0.1",
        //                     "dayRatio": "0.001"
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data");
        object rows = this.safeList(data, "items");
        return this.parseBorrowRateHistories(rows, codes, since, limit);
    }

    public async virtual Task<object> fetchBorrowRateHistory(object code, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchBorrowRateHistory
        * @description retrieves a history of a currencies borrow interest rate at specific time slots
        * @see https://www.kucoin.com/docs/rest/margin-trading/margin-trading-v3-/get-cross-isolated-margin-interest-records
        * @param {string} code unified currency code
        * @param {int} [since] timestamp for the earliest borrow rate
        * @param {int} [limit] the maximum number of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure} to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'cross' or 'isolated' default is 'cross'
        * @param {int} [params.until] the latest time in ms to fetch entries for
        * @returns {object[]} an array of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marginResult = this.handleMarginModeAndParams("fetchBorrowRateHistories", parameters);
        object marginMode = this.safeString(marginResult, 0, "cross");
        object isIsolated = (isEqual(marginMode, "isolated")); // true-isolated, false-cross
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "isIsolated", isIsolated },
            { "currency", getValue(currency, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["pageSize"] = limit; // default:50, min:10, max:500
        }
        object response = await this.privateGetMarginInterest(this.extend(request, parameters));
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "timestamp": 1710829939673,
        //             "currentPage": 1,
        //             "pageSize": 50,
        //             "totalNum": 0,
        //             "totalPage": 0,
        //             "items": [
        //                 {
        //                     "createdAt": 1697783812257,
        //                     "currency": "XMR",
        //                     "interestAmount": "0.1",
        //                     "dayRatio": "0.001"
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data");
        object rows = this.safeList(data, "items");
        return this.parseBorrowRateHistory(rows, code, since, limit);
    }

    public virtual object parseBorrowRateHistories(object response, object codes, object since, object limit)
    {
        //
        //     [
        //         {
        //             "createdAt": 1697783812257,
        //             "currency": "XMR",
        //             "interestAmount": "0.1",
        //             "dayRatio": "0.001"
        //         }
        //     ]
        //
        object borrowRateHistories = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object item = getValue(response, i);
            object code = this.safeCurrencyCode(this.safeString(item, "currency"));
            if (isTrue(isTrue(isEqual(codes, null)) || isTrue(this.inArray(code, codes))))
            {
                if (!isTrue((inOp(borrowRateHistories, code))))
                {
                    ((IDictionary<string,object>)borrowRateHistories)[(string)code] = new List<object>() {};
                }
                object borrowRateStructure = this.parseBorrowRate(item);
                ((IList<object>)getValue(borrowRateHistories, code)).Add(borrowRateStructure);
            }
        }
        object keys = new List<object>(((IDictionary<string,object>)borrowRateHistories).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object code = getValue(keys, i);
            ((IDictionary<string,object>)borrowRateHistories)[(string)code] = this.filterByCurrencySinceLimit(getValue(borrowRateHistories, code), code, since, limit);
        }
        return borrowRateHistories;
    }

    public async override Task<object> borrowCrossMargin(object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#borrowCrossMargin
        * @description create a loan to borrow margin
        * @see https://docs.kucoin.com/#1-margin-borrowing
        * @param {string} code unified currency code of the currency to borrow
        * @param {float} amount the amount to borrow
        * @param {object} [params] extra parameters specific to the exchange API endpoints
        * @param {string} [params.timeInForce] either IOC or FOK
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "size", this.currencyToPrecision(code, amount) },
            { "timeInForce", "FOK" },
        };
        object response = await this.privatePostMarginBorrow(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "code": "200",
        //         "msg": "success",
        //         "retry": false,
        //         "data": {
        //             "orderNo": "5da6dba0f943c0c81f5d5db5",
        //             "actualSize": 10
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginLoan(data, currency);
    }

    public async override Task<object> borrowIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#borrowIsolatedMargin
        * @description create a loan to borrow margin
        * @see https://docs.kucoin.com/#1-margin-borrowing
        * @param {string} symbol unified market symbol, required for isolated margin
        * @param {string} code unified currency code of the currency to borrow
        * @param {float} amount the amount to borrow
        * @param {object} [params] extra parameters specific to the exchange API endpoints
        * @param {string} [params.timeInForce] either IOC or FOK
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "size", this.currencyToPrecision(code, amount) },
            { "symbol", getValue(market, "id") },
            { "timeInForce", "FOK" },
            { "isIsolated", true },
        };
        object response = await this.privatePostMarginBorrow(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "code": "200",
        //         "msg": "success",
        //         "retry": false,
        //         "data": {
        //             "orderNo": "5da6dba0f943c0c81f5d5db5",
        //             "actualSize": 10
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginLoan(data, currency);
    }

    public async override Task<object> repayCrossMargin(object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#repayCrossMargin
        * @description repay borrowed margin and interest
        * @see https://docs.kucoin.com/#2-repayment
        * @param {string} code unified currency code of the currency to repay
        * @param {float} amount the amount to repay
        * @param {object} [params] extra parameters specific to the exchange API endpoints
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "size", this.currencyToPrecision(code, amount) },
        };
        object response = await this.privatePostMarginRepay(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "code": "200",
        //         "msg": "success",
        //         "retry": false,
        //         "data": {
        //             "orderNo": "5da6dba0f943c0c81f5d5db5",
        //             "actualSize": 10
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginLoan(data, currency);
    }

    public async override Task<object> repayIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#repayIsolatedMargin
        * @description repay borrowed margin and interest
        * @see https://docs.kucoin.com/#2-repayment
        * @param {string} symbol unified market symbol
        * @param {string} code unified currency code of the currency to repay
        * @param {float} amount the amount to repay
        * @param {object} [params] extra parameters specific to the exchange API endpoints
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "size", this.currencyToPrecision(code, amount) },
            { "symbol", getValue(market, "id") },
            { "isIsolated", true },
        };
        object response = await this.privatePostMarginRepay(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "code": "200",
        //         "msg": "success",
        //         "retry": false,
        //         "data": {
        //             "orderNo": "5da6dba0f943c0c81f5d5db5",
        //             "actualSize": 10
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginLoan(data, currency);
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        //     {
        //         "orderNo": "5da6dba0f943c0c81f5d5db5",
        //         "actualSize": 10
        //     }
        //
        object timestamp = this.milliseconds();
        object currencyId = this.safeString(info, "currency");
        return new Dictionary<string, object>() {
            { "id", this.safeString(info, "orderNo") },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber(info, "actualSize") },
            { "symbol", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name kucoin#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees - *IMPORTANT* use fetchDepositWithdrawFee to get more in-depth info
        * @see https://docs.kucoin.com/#get-currencies
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetCurrencies(parameters);
        //
        //  [
        //      {
        //        "currency": "CSP",
        //        "name": "CSP",
        //        "fullName": "Caspian",
        //        "precision": 8,
        //        "confirms": 12,
        //        "contractAddress": "0xa6446d655a0c34bc4f05042ee88170d056cbaf45",
        //        "withdrawalMinSize": "2000",
        //        "withdrawalMinFee": "1000",
        //        "isWithdrawEnabled": true,
        //        "isDepositEnabled": true,
        //        "isMarginEnabled": false,
        //        "isDebitEnabled": false
        //      },
        //  ]
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseDepositWithdrawFees(data, codes, "currency");
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        //
        // the v2 URL is https://openapi-v2.kucoin.com/api/v1/endpoint
        //                                ↑                 ↑
        //                                ↑                 ↑
        //
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object versions = this.safeDict(this.options, "versions", new Dictionary<string, object>() {});
        object apiVersions = this.safeDict(versions, api, new Dictionary<string, object>() {});
        object methodVersions = this.safeDict(apiVersions, method, new Dictionary<string, object>() {});
        object defaultVersion = this.safeString(methodVersions, path, getValue(this.options, "version"));
        object version = this.safeString(parameters, "version", defaultVersion);
        parameters = this.omit(parameters, "version");
        object endpoint = add(add(add("/api/", version), "/"), this.implodeParams(path, parameters));
        if (isTrue(isEqual(api, "webExchange")))
        {
            endpoint = add("/", this.implodeParams(path, parameters));
        }
        object query = this.omit(parameters, this.extractParams(path));
        object endpart = "";
        headers = ((bool) isTrue((!isEqual(headers, null)))) ? headers : new Dictionary<string, object>() {};
        object url = getValue(getValue(this.urls, "api"), api);
        if (!isTrue(this.isEmpty(query)))
        {
            if (isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE")))))
            {
                endpoint = add(endpoint, add("?", this.rawencode(query)));
            } else
            {
                body = this.json(query);
                endpart = body;
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
            }
        }
        url = add(url, endpoint);
        object isFuturePrivate = (isEqual(api, "futuresPrivate"));
        object isPrivate = (isEqual(api, "private"));
        object isBroker = (isEqual(api, "broker"));
        if (isTrue(isTrue(isTrue(isPrivate) || isTrue(isFuturePrivate)) || isTrue(isBroker)))
        {
            this.checkRequiredCredentials();
            object timestamp = ((object)this.nonce()).ToString();
            headers = this.extend(new Dictionary<string, object>() {
                { "KC-API-KEY-VERSION", "2" },
                { "KC-API-KEY", this.apiKey },
                { "KC-API-TIMESTAMP", timestamp },
            }, headers);
            object apiKeyVersion = this.safeString(headers, "KC-API-KEY-VERSION");
            if (isTrue(isEqual(apiKeyVersion, "2")))
            {
                object passphrase = this.hmac(this.encode(this.password), this.encode(this.secret), sha256, "base64");
                ((IDictionary<string,object>)headers)["KC-API-PASSPHRASE"] = passphrase;
            } else
            {
                ((IDictionary<string,object>)headers)["KC-API-PASSPHRASE"] = this.password;
            }
            object payload = add(add(add(timestamp, method), endpoint), endpart);
            object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha256, "base64");
            ((IDictionary<string,object>)headers)["KC-API-SIGN"] = signature;
            object partner = this.safeDict(this.options, "partner", new Dictionary<string, object>() {});
            partner = ((bool) isTrue(isFuturePrivate)) ? this.safeValue(partner, "future", partner) : this.safeValue(partner, "spot", partner);
            object partnerId = this.safeString(partner, "id");
            object partnerSecret = this.safeString2(partner, "secret", "key");
            if (isTrue(isTrue((!isEqual(partnerId, null))) && isTrue((!isEqual(partnerSecret, null)))))
            {
                object partnerPayload = add(add(timestamp, partnerId), this.apiKey);
                object partnerSignature = this.hmac(this.encode(partnerPayload), this.encode(partnerSecret), sha256, "base64");
                ((IDictionary<string,object>)headers)["KC-API-PARTNER-SIGN"] = partnerSignature;
                ((IDictionary<string,object>)headers)["KC-API-PARTNER"] = partnerId;
            }
            if (isTrue(isBroker))
            {
                object brokerName = this.safeString(partner, "name");
                if (isTrue(!isEqual(brokerName, null)))
                {
                    ((IDictionary<string,object>)headers)["KC-BROKER-NAME"] = brokerName;
                }
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, body);
            return null;
        }
        //
        // bad
        //     { "code": "400100", "msg": "validation.createOrder.clientOidIsRequired" }
        // good
        //     { code: '200000', data: { ... }}
        //
        object errorCode = this.safeString(response, "code");
        object message = this.safeString2(response, "msg", "data", "");
        object feedback = add(add(this.id, " "), message);
        this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
        this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
        this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
        if (isTrue(isTrue(!isEqual(errorCode, "200000")) && isTrue(!isEqual(errorCode, "200"))))
        {
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
