namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class kucoin : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "kucoin" },
            { "name", "KuCoin" },
            { "countries", new List<object>() {"SC"} },
            { "rateLimit", 10 },
            { "version", "v2" },
            { "certified", true },
            { "pro", true },
            { "comment", "Platform 2.0" },
            { "quoteJsonNumbers", false },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "borrowCrossMargin", true },
                { "borrowIsolatedMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createDepositAddress", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", true },
                { "createMarketSellOrderWithCost", true },
                { "createOrder", true },
                { "createOrders", true },
                { "createPostOnlyOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "createTriggerOrder", true },
                { "editOrder", true },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchBorrowInterest", true },
                { "fetchBorrowRateHistories", true },
                { "fetchBorrowRateHistory", true },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", true },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", true },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchL3OrderBook", true },
                { "fetchLedger", true },
                { "fetchLeverageTiers", false },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", false },
                { "fetchMarketLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMarkPrice", true },
                { "fetchMarkPrices", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", false },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", false },
                { "fetchOrdersByStatus", true },
                { "fetchOrderTrades", true },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositionsHistory", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchTransactionFee", true },
                { "fetchTransfers", true },
                { "fetchWithdrawals", true },
                { "repayCrossMargin", true },
                { "repayIsolatedMargin", true },
                { "setLeverage", true },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "signIn", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/51840849/87295558-132aaf80-c50e-11ea-9801-a2fb0c57c799.jpg" },
                { "referral", "https://www.kucoin.com/ucenter/signup?rcode=E5wkqe" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.kucoin.com" },
                    { "private", "https://api.kucoin.com" },
                    { "futuresPrivate", "https://api-futures.kucoin.com" },
                    { "futuresPublic", "https://api-futures.kucoin.com" },
                    { "webExchange", "https://kucoin.com/_api" },
                    { "broker", "https://api-broker.kucoin.com" },
                    { "earn", "https://api.kucoin.com" },
                    { "uta", "https://api.kucoin.com" },
                } },
                { "www", "https://www.kucoin.com" },
                { "doc", new List<object>() {"https://docs.kucoin.com"} },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "password", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "currencies", 4.5 },
                        { "currencies/{currency}", 4.5 },
                        { "symbols", 6 },
                        { "market/orderbook/level1", 3 },
                        { "market/allTickers", 22.5 },
                        { "market/stats", 22.5 },
                        { "markets", 4.5 },
                        { "market/orderbook/level{level}_{limit}", 6 },
                        { "market/orderbook/level2_20", 3 },
                        { "market/orderbook/level2_100", 6 },
                        { "market/histories", 4.5 },
                        { "market/candles", 4.5 },
                        { "prices", 4.5 },
                        { "timestamp", 4.5 },
                        { "status", 4.5 },
                        { "mark-price/{symbol}/current", 3 },
                        { "mark-price/all-symbols", 3 },
                        { "margin/config", 25 },
                        { "announcements", 20 },
                        { "margin/collateralRatio", 10 },
                        { "convert/symbol", 5 },
                        { "convert/currencies", 5 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "bullet-public", 15 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "user-info", 30 },
                        { "user/api-key", 30 },
                        { "accounts", 7.5 },
                        { "accounts/{accountId}", 7.5 },
                        { "accounts/ledgers", 3 },
                        { "hf/accounts/ledgers", 2 },
                        { "hf/margin/account/ledgers", 2 },
                        { "transaction-history", 3 },
                        { "sub/user", 30 },
                        { "sub-accounts/{subUserId}", 22.5 },
                        { "sub-accounts", 30 },
                        { "sub/api-key", 30 },
                        { "margin/account", 40 },
                        { "margin/accounts", 15 },
                        { "isolated/accounts", 15 },
                        { "deposit-addresses", 7.5 },
                        { "deposits", 7.5 },
                        { "hist-deposits", 7.5 },
                        { "withdrawals", 30 },
                        { "hist-withdrawals", 30 },
                        { "withdrawals/quotas", 30 },
                        { "accounts/transferable", 30 },
                        { "transfer-list", 30 },
                        { "base-fee", 3 },
                        { "trade-fees", 3 },
                        { "market/orderbook/level{level}", 3 },
                        { "market/orderbook/level2", 3 },
                        { "market/orderbook/level3", 3 },
                        { "hf/accounts/opened", 2 },
                        { "hf/orders/active", 2 },
                        { "hf/orders/active/symbols", 2 },
                        { "hf/margin/order/active/symbols", 2 },
                        { "hf/orders/done", 2 },
                        { "hf/orders/{orderId}", 2 },
                        { "hf/orders/client-order/{clientOid}", 2 },
                        { "hf/orders/dead-cancel-all/query", 2 },
                        { "hf/fills", 2 },
                        { "orders", 2 },
                        { "limit/orders", 3 },
                        { "orders/{orderId}", 2 },
                        { "order/client-order/{clientOid}", 3 },
                        { "fills", 10 },
                        { "limit/fills", 20 },
                        { "stop-order", 8 },
                        { "stop-order/{orderId}", 3 },
                        { "stop-order/queryOrderByClientOid", 3 },
                        { "oco/order/{orderId}", 2 },
                        { "oco/order/details/{orderId}", 2 },
                        { "oco/client-order/{clientOid}", 2 },
                        { "oco/orders", 2 },
                        { "hf/margin/orders/active", 4 },
                        { "hf/margin/orders/done", 10 },
                        { "hf/margin/orders/{orderId}", 4 },
                        { "hf/margin/orders/client-order/{clientOid}", 5 },
                        { "hf/margin/fills", 5 },
                        { "etf/info", 25 },
                        { "margin/currencies", 20 },
                        { "risk/limit/strategy", 20 },
                        { "isolated/symbols", 20 },
                        { "margin/symbols", 5 },
                        { "isolated/account/{symbol}", 50 },
                        { "margin/borrow", 15 },
                        { "margin/repay", 15 },
                        { "margin/interest", 20 },
                        { "project/list", 10 },
                        { "project/marketInterestRate", 7.5 },
                        { "redeem/orders", 10 },
                        { "purchase/orders", 10 },
                        { "broker/api/rebase/download", 3 },
                        { "broker/queryMyCommission", 3 },
                        { "broker/queryUser", 3 },
                        { "broker/queryDetailByUid", 3 },
                        { "migrate/user/account/status", 3 },
                        { "convert/quote", 20 },
                        { "convert/order/detail", 5 },
                        { "convert/order/history", 5 },
                        { "convert/limit/quote", 20 },
                        { "convert/limit/order/detail", 5 },
                        { "convert/limit/orders", 5 },
                        { "affiliate/inviter/statistics", 30 },
                        { "earn/redeem-preview", 5 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "sub/user/created", 22.5 },
                        { "sub/api-key", 30 },
                        { "sub/api-key/update", 45 },
                        { "deposit-addresses", 30 },
                        { "withdrawals", 7.5 },
                        { "accounts/universal-transfer", 6 },
                        { "accounts/sub-transfer", 45 },
                        { "accounts/inner-transfer", 15 },
                        { "transfer-out", 30 },
                        { "transfer-in", 30 },
                        { "hf/orders", 1 },
                        { "hf/orders/test", 1 },
                        { "hf/orders/sync", 1 },
                        { "hf/orders/multi", 1 },
                        { "hf/orders/multi/sync", 1 },
                        { "hf/orders/alter", 3 },
                        { "hf/orders/dead-cancel-all", 2 },
                        { "orders", 2 },
                        { "orders/test", 2 },
                        { "orders/multi", 3 },
                        { "stop-order", 2 },
                        { "oco/order", 2 },
                        { "hf/margin/order", 5 },
                        { "hf/margin/order/test", 5 },
                        { "margin/order", 5 },
                        { "margin/order/test", 5 },
                        { "margin/borrow", 15 },
                        { "margin/repay", 10 },
                        { "purchase", 15 },
                        { "redeem", 15 },
                        { "lend/purchase/update", 10 },
                        { "convert/order", 20 },
                        { "convert/limit/order", 20 },
                        { "bullet-private", 10 },
                        { "position/update-user-leverage", 5 },
                        { "deposit-address/create", 20 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "sub/api-key", 45 },
                        { "withdrawals/{withdrawalId}", 30 },
                        { "hf/orders/{orderId}", 1 },
                        { "hf/orders/sync/{orderId}", 1 },
                        { "hf/orders/client-order/{clientOid}", 1 },
                        { "hf/orders/sync/client-order/{clientOid}", 1 },
                        { "hf/orders/cancel/{orderId}", 2 },
                        { "hf/orders", 2 },
                        { "hf/orders/cancelAll", 30 },
                        { "orders/{orderId}", 3 },
                        { "order/client-order/{clientOid}", 5 },
                        { "orders", 20 },
                        { "stop-order/{orderId}", 3 },
                        { "stop-order/cancelOrderByClientOid", 5 },
                        { "stop-order/cancel", 3 },
                        { "oco/order/{orderId}", 3 },
                        { "oco/client-order/{clientOid}", 3 },
                        { "oco/orders", 3 },
                        { "hf/margin/orders/{orderId}", 5 },
                        { "hf/margin/orders/client-order/{clientOid}", 5 },
                        { "hf/margin/orders", 10 },
                        { "convert/limit/order/cancel", 5 },
                    } },
                } },
                { "futuresPublic", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "contracts/active", 4.5 },
                        { "contracts/{symbol}", 4.5 },
                        { "ticker", 3 },
                        { "level2/snapshot", 4.5 },
                        { "level2/depth20", 7.5 },
                        { "level2/depth100", 15 },
                        { "trade/history", 7.5 },
                        { "kline/query", 4.5 },
                        { "interest/query", 7.5 },
                        { "index/query", 3 },
                        { "mark-price/{symbol}/current", 4.5 },
                        { "premium/query", 4.5 },
                        { "trade-statistics", 4.5 },
                        { "funding-rate/{symbol}/current", 3 },
                        { "contract/funding-rates", 7.5 },
                        { "timestamp", 3 },
                        { "status", 6 },
                        { "level2/message/query", 1.3953 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "bullet-public", 15 },
                    } },
                } },
                { "futuresPrivate", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "transaction-history", 3 },
                        { "account-overview", 7.5 },
                        { "account-overview-all", 9 },
                        { "transfer-list", 30 },
                        { "orders", 3 },
                        { "stopOrders", 9 },
                        { "recentDoneOrders", 7.5 },
                        { "orders/{orderId}", 7.5 },
                        { "orders/byClientOid", 7.5 },
                        { "fills", 7.5 },
                        { "recentFills", 4.5 },
                        { "openOrderStatistics", 15 },
                        { "position", 3 },
                        { "positions", 3 },
                        { "margin/maxWithdrawMargin", 15 },
                        { "contracts/risk-limit/{symbol}", 7.5 },
                        { "funding-history", 7.5 },
                        { "copy-trade/futures/get-max-open-size", 6 },
                        { "copy-trade/futures/position/margin/max-withdraw-margin", 15 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "transfer-out", 30 },
                        { "transfer-in", 30 },
                        { "orders", 3 },
                        { "orders/test", 3 },
                        { "orders/multi", 4.5 },
                        { "position/margin/auto-deposit-status", 6 },
                        { "margin/withdrawMargin", 15 },
                        { "position/margin/deposit-margin", 6 },
                        { "position/risk-limit-level/change", 6 },
                        { "copy-trade/futures/orders", 3 },
                        { "copy-trade/futures/orders/test", 3 },
                        { "copy-trade/futures/st-orders", 3 },
                        { "copy-trade/futures/position/margin/deposit-margin", 6 },
                        { "copy-trade/futures/position/margin/withdraw-margin", 15 },
                        { "copy-trade/futures/position/risk-limit-level/change", 3 },
                        { "copy-trade/futures/position/margin/auto-deposit-status", 6 },
                        { "copy-trade/futures/position/changeMarginMode", 3 },
                        { "copy-trade/futures/position/changeCrossUserLeverage", 3 },
                        { "copy-trade/getCrossModeMarginRequirement", 4.5 },
                        { "copy-trade/position/switchPositionMode", 3 },
                        { "bullet-private", 15 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "orders/{orderId}", 1.5 },
                        { "orders/client-order/{clientOid}", 1.5 },
                        { "orders", 45 },
                        { "stopOrders", 22.5 },
                        { "copy-trade/futures/orders", 1.5 },
                        { "copy-trade/futures/orders/client-order", 1.5 },
                    } },
                } },
                { "webExchange", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "currency/currency/chain-info", 1 },
                    } },
                } },
                { "broker", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "broker/nd/info", 2 },
                        { "broker/nd/account", 2 },
                        { "broker/nd/account/apikey", 2 },
                        { "broker/nd/rebase/download", 3 },
                        { "asset/ndbroker/deposit/list", 1 },
                        { "broker/nd/transfer/detail", 1 },
                        { "broker/nd/deposit/detail", 1 },
                        { "broker/nd/withdraw/detail", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "broker/nd/transfer", 1 },
                        { "broker/nd/account", 3 },
                        { "broker/nd/account/apikey", 3 },
                        { "broker/nd/account/update-apikey", 3 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "broker/nd/account/apikey", 3 },
                    } },
                } },
                { "earn", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "otc-loan/discount-rate-configs", 10 },
                        { "otc-loan/loan", 1 },
                        { "otc-loan/accounts", 1 },
                        { "earn/redeem-preview", 7.5 },
                        { "earn/saving/products", 7.5 },
                        { "earn/hold-assets", 7.5 },
                        { "earn/promotion/products", 7.5 },
                        { "earn/kcs-staking/products", 7.5 },
                        { "earn/staking/products", 7.5 },
                        { "earn/eth-staking/products", 7.5 },
                        { "struct-earn/dual/products", 4.5 },
                        { "struct-earn/orders", 7.5 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "earn/orders", 7.5 },
                        { "struct-earn/orders", 7.5 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "earn/orders", 7.5 },
                    } },
                } },
                { "uta", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "market/announcement", 20 },
                        { "market/currency", 3 },
                        { "market/instrument", 4 },
                        { "market/ticker", 15 },
                        { "market/orderbook", 3 },
                        { "market/trade", 3 },
                        { "market/kline", 3 },
                        { "market/funding-rate", 2 },
                        { "market/funding-rate-history", 5 },
                        { "market/cross-config", 25 },
                        { "server/status", 3 },
                    } },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1min" },
                { "3m", "3min" },
                { "5m", "5min" },
                { "15m", "15min" },
                { "30m", "30min" },
                { "1h", "1hour" },
                { "2h", "2hour" },
                { "4h", "4hour" },
                { "6h", "6hour" },
                { "8h", "8hour" },
                { "12h", "12hour" },
                { "1d", "1day" },
                { "1w", "1week" },
                { "1M", "1month" },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "Order not exist or not allow to be cancelled", typeof(OrderNotFound) },
                    { "The order does not exist.", typeof(OrderNotFound) },
                    { "order not exist", typeof(OrderNotFound) },
                    { "order not exist.", typeof(OrderNotFound) },
                    { "order_not_exist", typeof(OrderNotFound) },
                    { "order_not_exist_or_not_allow_to_cancel", typeof(InvalidOrder) },
                    { "Order size below the minimum requirement.", typeof(InvalidOrder) },
                    { "Order size increment invalid.", typeof(InvalidOrder) },
                    { "The withdrawal amount is below the minimum requirement.", typeof(ExchangeError) },
                    { "Unsuccessful! Exceeded the max. funds out-transfer limit", typeof(InsufficientFunds) },
                    { "The amount increment is invalid.", typeof(BadRequest) },
                    { "The quantity is below the minimum requirement.", typeof(InvalidOrder) },
                    { "not in the given range!", typeof(BadRequest) },
                    { "recAccountType not in the given range", typeof(BadRequest) },
                    { "400", typeof(BadRequest) },
                    { "401", typeof(AuthenticationError) },
                    { "403", typeof(NotSupported) },
                    { "404", typeof(NotSupported) },
                    { "405", typeof(NotSupported) },
                    { "415", typeof(NotSupported) },
                    { "429", typeof(RateLimitExceeded) },
                    { "500", typeof(ExchangeNotAvailable) },
                    { "503", typeof(ExchangeNotAvailable) },
                    { "101030", typeof(PermissionDenied) },
                    { "103000", typeof(InvalidOrder) },
                    { "130101", typeof(BadRequest) },
                    { "130102", typeof(ExchangeError) },
                    { "130103", typeof(OrderNotFound) },
                    { "130104", typeof(ExchangeError) },
                    { "130105", typeof(InsufficientFunds) },
                    { "130106", typeof(NotSupported) },
                    { "130107", typeof(ExchangeError) },
                    { "130108", typeof(OrderNotFound) },
                    { "130201", typeof(PermissionDenied) },
                    { "130202", typeof(ExchangeError) },
                    { "130203", typeof(InsufficientFunds) },
                    { "130204", typeof(BadRequest) },
                    { "130301", typeof(InsufficientFunds) },
                    { "130302", typeof(PermissionDenied) },
                    { "130303", typeof(NotSupported) },
                    { "130304", typeof(NotSupported) },
                    { "130305", typeof(NotSupported) },
                    { "130306", typeof(NotSupported) },
                    { "130307", typeof(NotSupported) },
                    { "130308", typeof(InvalidOrder) },
                    { "130309", typeof(InvalidOrder) },
                    { "130310", typeof(ExchangeError) },
                    { "130311", typeof(InvalidOrder) },
                    { "130312", typeof(InvalidOrder) },
                    { "130313", typeof(InvalidOrder) },
                    { "130314", typeof(InvalidOrder) },
                    { "130315", typeof(NotSupported) },
                    { "126000", typeof(ExchangeError) },
                    { "126001", typeof(NotSupported) },
                    { "126002", typeof(ExchangeError) },
                    { "126003", typeof(InvalidOrder) },
                    { "126004", typeof(ExchangeError) },
                    { "126005", typeof(PermissionDenied) },
                    { "126006", typeof(ExchangeError) },
                    { "126007", typeof(ExchangeError) },
                    { "126009", typeof(ExchangeError) },
                    { "126010", typeof(ExchangeError) },
                    { "126011", typeof(ExchangeError) },
                    { "126013", typeof(InsufficientFunds) },
                    { "126015", typeof(ExchangeError) },
                    { "126021", typeof(NotSupported) },
                    { "126022", typeof(InvalidOrder) },
                    { "126027", typeof(InvalidOrder) },
                    { "126028", typeof(InvalidOrder) },
                    { "126029", typeof(InvalidOrder) },
                    { "126030", typeof(InvalidOrder) },
                    { "126033", typeof(InvalidOrder) },
                    { "126034", typeof(InvalidOrder) },
                    { "126036", typeof(InvalidOrder) },
                    { "126037", typeof(ExchangeError) },
                    { "126038", typeof(ExchangeError) },
                    { "126039", typeof(ExchangeError) },
                    { "126041", typeof(ExchangeError) },
                    { "126042", typeof(ExchangeError) },
                    { "126043", typeof(OrderNotFound) },
                    { "126044", typeof(InvalidOrder) },
                    { "126045", typeof(NotSupported) },
                    { "126046", typeof(NotSupported) },
                    { "126047", typeof(PermissionDenied) },
                    { "126048", typeof(PermissionDenied) },
                    { "135005", typeof(ExchangeError) },
                    { "135018", typeof(ExchangeError) },
                    { "200004", typeof(InsufficientFunds) },
                    { "210014", typeof(InvalidOrder) },
                    { "210021", typeof(InsufficientFunds) },
                    { "230003", typeof(InsufficientFunds) },
                    { "260000", typeof(InvalidAddress) },
                    { "260100", typeof(InsufficientFunds) },
                    { "300000", typeof(InvalidOrder) },
                    { "400000", typeof(BadSymbol) },
                    { "400001", typeof(AuthenticationError) },
                    { "400002", typeof(InvalidNonce) },
                    { "400003", typeof(AuthenticationError) },
                    { "400004", typeof(AuthenticationError) },
                    { "400005", typeof(AuthenticationError) },
                    { "400006", typeof(AuthenticationError) },
                    { "400007", typeof(AuthenticationError) },
                    { "400008", typeof(NotSupported) },
                    { "400100", typeof(InsufficientFunds) },
                    { "400200", typeof(InvalidOrder) },
                    { "400330", typeof(InvalidOrder) },
                    { "400350", typeof(InvalidOrder) },
                    { "400370", typeof(InvalidOrder) },
                    { "400400", typeof(BadRequest) },
                    { "400401", typeof(AuthenticationError) },
                    { "400500", typeof(RestrictedLocation) },
                    { "400600", typeof(BadSymbol) },
                    { "400760", typeof(InvalidOrder) },
                    { "401000", typeof(BadRequest) },
                    { "408000", typeof(BadRequest) },
                    { "411100", typeof(AccountSuspended) },
                    { "415000", typeof(BadRequest) },
                    { "400303", typeof(PermissionDenied) },
                    { "500000", typeof(ExchangeNotAvailable) },
                    { "260220", typeof(InvalidAddress) },
                    { "600100", typeof(InsufficientFunds) },
                    { "600101", typeof(InvalidOrder) },
                    { "900014", typeof(BadRequest) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Exceeded the access frequency", typeof(RateLimitExceeded) },
                    { "require more permission", typeof(PermissionDenied) },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.001") },
                    { "maker", this.parseNumber("0.001") },
                    { "tiers", new Dictionary<string, object>() {
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("50"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("200"), this.parseNumber("0.0009")}, new List<object> {this.parseNumber("500"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("1000"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("2000"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("4000"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("8000"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("15000"), this.parseNumber("0.00045")}, new List<object> {this.parseNumber("25000"), this.parseNumber("0.0004")}, new List<object> {this.parseNumber("40000"), this.parseNumber("0.00035")}, new List<object> {this.parseNumber("60000"), this.parseNumber("0.0003")}, new List<object> {this.parseNumber("80000"), this.parseNumber("0.00025")}} },
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("50"), this.parseNumber("0.0009")}, new List<object> {this.parseNumber("200"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("500"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("1000"), this.parseNumber("0.0003")}, new List<object> {this.parseNumber("2000"), this.parseNumber("0")}, new List<object> {this.parseNumber("4000"), this.parseNumber("0")}, new List<object> {this.parseNumber("8000"), this.parseNumber("0")}, new List<object> {this.parseNumber("15000"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("25000"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("40000"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("60000"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("80000"), this.parseNumber("-0.00005")}} },
                    } },
                } },
                { "funding", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", false },
                    { "withdraw", new Dictionary<string, object>() {} },
                    { "deposit", new Dictionary<string, object>() {} },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "BIFI", "BIFIF" },
                { "VAI", "VAIOT" },
                { "WAX", "WAXP" },
                { "ALT", "APTOSLAUNCHTOKEN" },
                { "KALT", "ALT" },
                { "FUD", "FTX Users' Debt" },
            } },
            { "options", new Dictionary<string, object>() {
                { "hf", null },
                { "version", "v1" },
                { "symbolSeparator", "-" },
                { "fetchMyTradesMethod", "private_get_fills" },
                { "timeDifference", 0 },
                { "adjustForTimeDifference", false },
                { "fetchCurrencies", new Dictionary<string, object>() {
                    { "webApiEnable", true },
                    { "webApiRetries", 1 },
                    { "webApiMuteFailure", true },
                } },
                { "fetchMarkets", new Dictionary<string, object>() {
                    { "fetchTickersFees", true },
                } },
                { "withdraw", new Dictionary<string, object>() {
                    { "includeFee", false },
                } },
                { "transfer", new Dictionary<string, object>() {
                    { "fillResponseFromRequest", true },
                } },
                { "versions", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "GET", new Dictionary<string, object>() {
                            { "currencies", "v3" },
                            { "currencies/{currency}", "v3" },
                            { "symbols", "v2" },
                            { "mark-price/all-symbols", "v3" },
                            { "announcements", "v3" },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "GET", new Dictionary<string, object>() {
                            { "user-info", "v2" },
                            { "hf/margin/account/ledgers", "v3" },
                            { "sub/user", "v2" },
                            { "sub-accounts", "v2" },
                            { "margin/accounts", "v3" },
                            { "isolated/accounts", "v3" },
                            { "deposit-addresses", "v1" },
                            { "market/orderbook/level2", "v3" },
                            { "market/orderbook/level3", "v3" },
                            { "market/orderbook/level{level}", "v3" },
                            { "oco/order/{orderId}", "v3" },
                            { "oco/order/details/{orderId}", "v3" },
                            { "oco/client-order/{clientOid}", "v3" },
                            { "oco/orders", "v3" },
                            { "hf/margin/orders/active", "v3" },
                            { "hf/margin/order/active/symbols", "v3" },
                            { "hf/margin/orders/done", "v3" },
                            { "hf/margin/orders/{orderId}", "v3" },
                            { "hf/margin/orders/client-order/{clientOid}", "v3" },
                            { "hf/margin/fills", "v3" },
                            { "etf/info", "v3" },
                            { "margin/currencies", "v3" },
                            { "margin/borrow", "v3" },
                            { "margin/repay", "v3" },
                            { "margin/interest", "v3" },
                            { "project/list", "v3" },
                            { "project/marketInterestRate", "v3" },
                            { "redeem/orders", "v3" },
                            { "purchase/orders", "v3" },
                            { "migrate/user/account/status", "v3" },
                            { "margin/symbols", "v3" },
                            { "affiliate/inviter/statistics", "v2" },
                            { "asset/ndbroker/deposit/list", "v1" },
                        } },
                        { "POST", new Dictionary<string, object>() {
                            { "sub/user/created", "v2" },
                            { "accounts/universal-transfer", "v3" },
                            { "accounts/sub-transfer", "v2" },
                            { "accounts/inner-transfer", "v2" },
                            { "transfer-out", "v3" },
                            { "deposit-address/create", "v3" },
                            { "oco/order", "v3" },
                            { "hf/margin/order", "v3" },
                            { "hf/margin/order/test", "v3" },
                            { "margin/borrow", "v3" },
                            { "margin/repay", "v3" },
                            { "purchase", "v3" },
                            { "redeem", "v3" },
                            { "lend/purchase/update", "v3" },
                            { "position/update-user-leverage", "v3" },
                            { "withdrawals", "v3" },
                        } },
                        { "DELETE", new Dictionary<string, object>() {
                            { "hf/margin/orders/{orderId}", "v3" },
                            { "hf/margin/orders/client-order/{clientOid}", "v3" },
                            { "hf/margin/orders", "v3" },
                            { "oco/order/{orderId}", "v3" },
                            { "oco/client-order/{clientOid}", "v3" },
                            { "oco/orders", "v3" },
                        } },
                    } },
                    { "futuresPrivate", new Dictionary<string, object>() {
                        { "POST", new Dictionary<string, object>() {
                            { "transfer-out", "v3" },
                        } },
                    } },
                } },
                { "partner", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "id", "ccxt" },
                        { "key", "9e58cc35-5b5e-4133-92ec-166e3f077cb8" },
                    } },
                    { "future", new Dictionary<string, object>() {
                        { "id", "ccxtfutures" },
                        { "key", "1b327198-f30c-4f14-a0ac-918871282f15" },
                    } },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "trade" },
                    { "margin", "margin" },
                    { "cross", "margin" },
                    { "isolated", "isolated" },
                    { "main", "main" },
                    { "funding", "main" },
                    { "future", "contract" },
                    { "swap", "contract" },
                    { "mining", "pool" },
                    { "hf", "trade_hf" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "BRC20", "btc" },
                    { "BTCNATIVESEGWIT", "bech32" },
                    { "ERC20", "eth" },
                    { "TRC20", "trx" },
                    { "HRC20", "heco" },
                    { "MATIC", "matic" },
                    { "KCC", "kcc" },
                    { "SOL", "sol" },
                    { "ALGO", "algo" },
                    { "EOS", "eos" },
                    { "BEP20", "bsc" },
                    { "BEP2", "bnb" },
                    { "ARBONE", "arbitrum" },
                    { "AVAXX", "avax" },
                    { "AVAXC", "avaxc" },
                    { "TLOS", "tlos" },
                    { "CFX", "cfx" },
                    { "ACA", "aca" },
                    { "OPTIMISM", "optimism" },
                    { "ONT", "ont" },
                    { "GLMR", "glmr" },
                    { "CSPR", "cspr" },
                    { "KLAY", "klay" },
                    { "XRD", "xrd" },
                    { "RVN", "rvn" },
                    { "NEAR", "near" },
                    { "APT", "aptos" },
                    { "ETHW", "ethw" },
                    { "TON", "ton" },
                    { "BCH", "bch" },
                    { "BSV", "bchsv" },
                    { "BCHA", "bchabc" },
                    { "OSMO", "osmo" },
                    { "NANO", "nano" },
                    { "XLM", "xlm" },
                    { "VET", "vet" },
                    { "IOST", "iost" },
                    { "ZIL", "zil" },
                    { "XRP", "xrp" },
                    { "TOMO", "tomo" },
                    { "XMR", "xmr" },
                    { "COTI", "coti" },
                    { "XTZ", "xtz" },
                    { "ADA", "ada" },
                    { "WAX", "waxp" },
                    { "THETA", "theta" },
                    { "ONE", "one" },
                    { "IOTEX", "iotx" },
                    { "NULS", "nuls" },
                    { "KSM", "ksm" },
                    { "LTC", "ltc" },
                    { "WAVES", "waves" },
                    { "DOT", "dot" },
                    { "STEEM", "steem" },
                    { "QTUM", "qtum" },
                    { "DOGE", "doge" },
                    { "FIL", "fil" },
                    { "XYM", "xym" },
                    { "FLUX", "flux" },
                    { "ATOM", "atom" },
                    { "XDC", "xdc" },
                    { "KDA", "kda" },
                    { "ICP", "icp" },
                    { "CELO", "celo" },
                    { "LSK", "lsk" },
                    { "VSYS", "vsys" },
                    { "KAR", "kar" },
                    { "XCH", "xch" },
                    { "FLOW", "flow" },
                    { "BAND", "band" },
                    { "EGLD", "egld" },
                    { "HBAR", "hbar" },
                    { "XPR", "xpr" },
                    { "AR", "ar" },
                    { "FTM", "ftm" },
                    { "KAVA", "kava" },
                    { "KMA", "kma" },
                    { "XEC", "xec" },
                    { "IOTA", "iota" },
                    { "HNT", "hnt" },
                    { "ASTR", "astr" },
                    { "PDEX", "pdex" },
                    { "METIS", "metis" },
                    { "ZEC", "zec" },
                    { "POKT", "pokt" },
                    { "OASYS", "oas" },
                    { "OASIS", "oasis" },
                    { "ETC", "etc" },
                    { "AKT", "akt" },
                    { "FSN", "fsn" },
                    { "SCRT", "scrt" },
                    { "CFG", "cfg" },
                    { "ICX", "icx" },
                    { "KMD", "kmd" },
                    { "NEM", "NEM" },
                    { "STX", "stx" },
                    { "DGB", "dgb" },
                    { "DCR", "dcr" },
                    { "CKB", "ckb" },
                    { "ELA", "ela" },
                    { "HYDRA", "hydra" },
                    { "BTM", "btm" },
                    { "KARDIA", "kai" },
                    { "SXP", "sxp" },
                    { "NEBL", "nebl" },
                    { "ZEN", "zen" },
                    { "SDN", "sdn" },
                    { "LTO", "lto" },
                    { "WEMIX", "wemix" },
                    { "EVER", "ever" },
                    { "BNC", "bnc" },
                    { "BNCDOT", "bncdot" },
                    { "AION", "aion" },
                    { "GRIN", "grin" },
                    { "LOKI", "loki" },
                    { "QKC", "qkc" },
                    { "TT", "TT" },
                    { "PIVX", "pivx" },
                    { "SERO", "sero" },
                    { "METER", "meter" },
                    { "STATEMINE", "statemine" },
                    { "DVPN", "dvpn" },
                    { "XPRT", "xprt" },
                    { "MOVR", "movr" },
                    { "ERGO", "ergo" },
                    { "ABBC", "abbc" },
                    { "DIVI", "divi" },
                    { "PURA", "pura" },
                    { "DFI", "dfi" },
                    { "NEON3", "neon3" },
                    { "DOCK", "dock" },
                    { "TRUE", "true" },
                    { "CS", "cs" },
                    { "ORAI", "orai" },
                    { "BASE", "base" },
                    { "TARA", "tara" },
                } },
                { "marginModes", new Dictionary<string, object>() {
                    { "cross", "MARGIN_TRADE" },
                    { "isolated", "MARGIN_ISOLATED_TRADE" },
                    { "spot", "TRADE" },
                } },
            } },
            { "features", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "sandbox", false },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "triggerPrice", true },
                        { "triggerPriceType", null },
                        { "triggerDirection", false },
                        { "stopLossPrice", true },
                        { "takeProfitPrice", true },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", true },
                        } },
                        { "hedged", false },
                        { "trailing", false },
                        { "leverage", false },
                        { "marketBuyByCost", true },
                        { "marketBuyRequiresPrice", false },
                        { "selfTradePrevention", true },
                        { "iceberg", true },
                    } },
                    { "createOrders", new Dictionary<string, object>() {
                        { "max", 5 },
                    } },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", null },
                        { "daysBack", null },
                        { "untilDays", 7 },
                        { "symbolRequired", true },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", true },
                        { "trailing", false },
                        { "symbolRequired", true },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", 500 },
                        { "trigger", true },
                        { "trailing", false },
                        { "symbolRequired", true },
                    } },
                    { "fetchOrders", null },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", 500 },
                        { "daysBack", null },
                        { "daysBackCanceled", null },
                        { "untilDays", 7 },
                        { "trigger", true },
                        { "trailing", false },
                        { "symbolRequired", true },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 1500 },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
            } },
        });
    }

    public override object nonce()
    {
        return subtract(this.milliseconds(), getValue(this.options, "timeDifference"));
    }

    /**
     * @method
     * @name kucoin#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://docs.kucoin.com/#server-time
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetTimestamp(parameters);
        //
        //     {
        //         "code":"200000",
        //         "msg":"success",
        //         "data":1546837113087
        //     }
        //
        return this.safeInteger(response, "data");
    }

    /**
     * @method
     * @name kucoin#fetchStatus
     * @description the latest known information on the availability of the exchange API
     * @see https://docs.kucoin.com/#service-status
     * @see https://www.kucoin.com/docs-new/rest/ua/get-service-status
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @param {string} [params.tradeType] *uta only* set to SPOT or FUTURES
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/?id=exchange-status-structure}
     */
    public async override Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchStatus", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        object response = null;
        if (isTrue(uta))
        {
            object defaultType = this.safeString(this.options, "defaultType", "spot");
            object defaultTradeType = ((bool) isTrue((isEqual(defaultType, "spot")))) ? "SPOT" : "FUTURES";
            object tradeType = this.safeStringUpper(parameters, "tradeType", defaultTradeType);
            object request = new Dictionary<string, object>() {
                { "tradeType", tradeType },
            };
            response = await this.utaGetServerStatus(this.extend(request, parameters));
        } else
        {
            response = await this.publicGetStatus(parameters);
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object status = this.safeString2(data, "status", "serverStatus");
        return new Dictionary<string, object>() {
            { "status", ((bool) isTrue((isEqual(status, "open")))) ? "ok" : "maintenance" },
            { "updated", null },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    /**
     * @method
     * @name kucoin#fetchMarkets
     * @description retrieves data on all markets for kucoin
     * @see https://docs.kucoin.com/#get-symbols-list-deprecated
     * @see https://docs.kucoin.com/#get-all-tickers
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object fetchTickersFees = null;
        var fetchTickersFeesparametersVariable = this.handleOptionAndParams(parameters, "fetchMarkets", "fetchTickersFees", true);
        fetchTickersFees = ((IList<object>)fetchTickersFeesparametersVariable)[0];
        parameters = ((IList<object>)fetchTickersFeesparametersVariable)[1];
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchMarkets", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            return await this.fetchUtaMarkets(parameters);
        }
        object promises = new List<object>() {};
        ((IList<object>)promises).Add(this.publicGetSymbols(parameters));
        //
        //     {
        //         "code": "200000",
        //         "data": [
        //             {
        //                 "symbol": "XLM-USDT",
        //                 "name": "XLM-USDT",
        //                 "baseCurrency": "XLM",
        //                 "quoteCurrency": "USDT",
        //                 "feeCurrency": "USDT",
        //                 "market": "USDS",
        //                 "baseMinSize": "0.1",
        //                 "quoteMinSize": "0.01",
        //                 "baseMaxSize": "10000000000",
        //                 "quoteMaxSize": "99999999",
        //                 "baseIncrement": "0.0001",
        //                 "quoteIncrement": "0.000001",
        //                 "priceIncrement": "0.000001",
        //                 "priceLimitRate": "0.1",
        //                 "isMarginEnabled": true,
        //                 "enableTrading": true
        //             },
        //
        object credentialsSet = this.checkRequiredCredentials(false);
        object requestMarginables = isTrue(credentialsSet) && isTrue(this.safeBool(parameters, "marginables", true));
        if (isTrue(requestMarginables))
        {
            ((IList<object>)promises).Add(this.privateGetMarginSymbols(parameters)); // cross margin symbols
            //
            //    {
            //        "code": "200000",
            //        "data": {
            //            "timestamp": 1719393213421,
            //            "items": [
            //                {
            //                    // same object as in market, with one additional field:
            //                    "minFunds": "0.1"
            //                },
            //
            ((IList<object>)promises).Add(this.privateGetIsolatedSymbols(parameters)); // isolated margin symbols
        }
        if (isTrue(fetchTickersFees))
        {
            ((IList<object>)promises).Add(this.publicGetMarketAllTickers(parameters));
        }
        if (isTrue(credentialsSet))
        {
            // load migration status for account
            ((IList<object>)promises).Add(this.loadMigrationStatus());
        }
        object responses = await promiseAll(promises);
        object symbolsData = this.safeList(getValue(responses, 0), "data");
        object crossData = ((bool) isTrue(requestMarginables)) ? this.safeDict(getValue(responses, 1), "data", new Dictionary<string, object>() {}) : new Dictionary<string, object>() {};
        object crossItems = this.safeList(crossData, "items", new List<object>() {});
        object crossById = this.indexBy(crossItems, "symbol");
        object isolatedData = ((bool) isTrue(requestMarginables)) ? getValue(responses, 2) : new Dictionary<string, object>() {};
        object isolatedItems = this.safeList(isolatedData, "data", new List<object>() {});
        object isolatedById = this.indexBy(isolatedItems, "symbol");
        object tickersIdx = ((bool) isTrue(requestMarginables)) ? 3 : 1;
        object tickersResponse = this.safeDict(responses, tickersIdx, new Dictionary<string, object>() {});
        object tickerItems = this.safeList(this.safeDict(tickersResponse, "data", new Dictionary<string, object>() {}), "ticker", new List<object>() {});
        object tickersById = this.indexBy(tickerItems, "symbol");
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbolsData)); postFixIncrement(ref i))
        {
            object market = getValue(symbolsData, i);
            object id = this.safeString(market, "symbol");
            var baseIdquoteIdVariable = ((string)id).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            var baseId = ((IList<object>) baseIdquoteIdVariable)[0];
            var quoteId = ((IList<object>) baseIdquoteIdVariable)[1];
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            // const quoteIncrement = this.safeNumber (market, 'quoteIncrement');
            object ticker = this.safeDict(tickersById, id, new Dictionary<string, object>() {});
            object makerFeeRate = this.safeString(ticker, "makerFeeRate");
            object takerFeeRate = this.safeString(ticker, "takerFeeRate");
            object makerCoefficient = this.safeString(ticker, "makerCoefficient");
            object takerCoefficient = this.safeString(ticker, "takerCoefficient");
            object hasCrossMargin = (inOp(crossById, id));
            object hasIsolatedMargin = (inOp(isolatedById, id));
            object isMarginable = isTrue(isTrue(this.safeBool(market, "isMarginEnabled", false)) || isTrue(hasCrossMargin)) || isTrue(hasIsolatedMargin);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", isMarginable },
                { "marginModes", new Dictionary<string, object>() {
                    { "cross", hasCrossMargin },
                    { "isolated", hasIsolatedMargin },
                } },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", this.safeBool(market, "enableTrading") },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", this.parseNumber(Precise.stringMul(takerFeeRate, takerCoefficient)) },
                { "maker", this.parseNumber(Precise.stringMul(makerFeeRate, makerCoefficient)) },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.safeNumber(market, "baseIncrement") },
                    { "price", this.safeNumber(market, "priceIncrement") },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "baseMinSize") },
                        { "max", this.safeNumber(market, "baseMaxSize") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "quoteMinSize") },
                        { "max", this.safeNumber(market, "quoteMaxSize") },
                    } },
                } },
                { "created", null },
                { "info", market },
            });
        }
        if (isTrue(getValue(this.options, "adjustForTimeDifference")))
        {
            await this.loadTimeDifference();
        }
        return result;
    }

    public async virtual Task<object> fetchUtaMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object promises = new List<object>() {};
        ((IList<object>)promises).Add(this.utaGetMarketInstrument(this.extend(parameters, new Dictionary<string, object>() {
            { "tradeType", "SPOT" },
        })));
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "tradeType": "SPOT",
        //             "list": [
        //                 {
        //                     "symbol": "AVA-USDT",
        //                     "name": "AVA-USDT",
        //                     "baseCurrency": "AVA",
        //                     "quoteCurrency": "USDT",
        //                     "market": "USDS",
        //                     "minBaseOrderSize": "0.1",
        //                     "minQuoteOrderSize": "0.1",
        //                     "maxBaseOrderSize": "10000000000",
        //                     "maxQuoteOrderSize": "99999999",
        //                     "baseOrderStep": "0.01",
        //                     "quoteOrderStep": "0.0001",
        //                     "tickSize": "0.0001",
        //                     "feeCurrency": "USDT",
        //                     "tradingStatus": "1",
        //                     "marginMode": "2",
        //                     "priceLimitRatio": "0.05",
        //                     "feeCategory": 1,
        //                     "makerFeeCoefficient": "1.00",
        //                     "takerFeeCoefficient": "1.00",
        //                     "st": false
        //                 },
        //             ]
        //         }
        //     }
        //
        ((IList<object>)promises).Add(this.utaGetMarketInstrument(this.extend(parameters, new Dictionary<string, object>() {
            { "tradeType", "FUTURES" },
        })));
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "tradeType": "FUTURES",
        //             "list": [
        //                 {
        //                     "symbol": "XBTUSDTM",
        //                     "baseCurrency": "XBT",
        //                     "quoteCurrency": "USDT",
        //                     "maxBaseOrderSize": "1000000",
        //                     "tickSize": "0.1",
        //                     "tradingStatus": "1",
        //                     "settlementCurrency": "USDT",
        //                     "contractType": "0",
        //                     "isInverse": false,
        //                     "launchTime": 1585555200000,
        //                     "expiryTime": null,
        //                     "settlementTime": null,
        //                     "maxPrice": "1000000.0",
        //                     "lotSize": "1",
        //                     "unitSize": "0.001",
        //                     "makerFeeRate": "0.00020",
        //                     "takerFeeRate": "0.00060",
        //                     "settlementFeeRate": null,
        //                     "maxLeverage": 125,
        //                     "indexSourceExchanges": ["okex","binance","kucoin","bybit","bitmart","gateio"],
        //                     "k": "490.0",
        //                     "m": "300.0",
        //                     "f": "1.3",
        //                     "mmrLimit": "0.3",
        //                     "mmrLevConstant": "125.0"
        //                 },
        //             ]
        //         }
        //     }
        //
        object responses = await promiseAll(promises);
        object data = this.safeDict(getValue(responses, 0), "data", new Dictionary<string, object>() {});
        object contractData = this.safeDict(getValue(responses, 1), "data", new Dictionary<string, object>() {});
        object spotData = this.safeList(data, "list", new List<object>() {});
        object contractSymbolsData = this.safeList(contractData, "list", new List<object>() {});
        object symbolsData = this.arrayConcat(spotData, contractSymbolsData);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbolsData)); postFixIncrement(ref i))
        {
            object market = getValue(symbolsData, i);
            object id = this.safeString(market, "symbol");
            object baseId = this.safeString(market, "baseCurrency");
            object quoteId = this.safeString(market, "quoteCurrency");
            object settleId = this.safeString(market, "settlementCurrency");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object settle = this.safeCurrencyCode(settleId);
            object hasMargin = this.safeString(market, "marginMode");
            object isMarginable = ((bool) isTrue((isEqual(hasMargin, "1")))) ? true : false;
            object symbol = add(add(bs, "/"), quote);
            if (isTrue(!isEqual(settle, null)))
            {
                symbol = add(symbol, add(":", settle));
            }
            object contractType = this.safeString(market, "contractType");
            object expiry = this.safeInteger(market, "expiryTime");
            object active = this.safeString(market, "tradingStatus");
            object type = null;
            object spot = false;
            object swap = false;
            object future = false;
            object contract = false;
            object linear = false;
            object inverse = false;
            if (isTrue(!isEqual(contractType, null)))
            {
                contract = true;
                if (isTrue(isEqual(quote, settle)))
                {
                    linear = true;
                } else
                {
                    inverse = true;
                }
                if (isTrue(isEqual(contractType, "0")))
                {
                    type = "swap";
                    swap = true;
                } else
                {
                    type = "future";
                    future = true;
                }
            } else
            {
                type = "spot";
                spot = true;
            }
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", type },
                { "spot", spot },
                { "margin", isMarginable },
                { "swap", swap },
                { "future", future },
                { "option", false },
                { "active", (isEqual(active, "1")) },
                { "contract", contract },
                { "linear", linear },
                { "inverse", inverse },
                { "taker", this.safeNumber(market, "makerFeeRate") },
                { "maker", this.safeNumber(market, "takerFeeRate") },
                { "contractSize", this.safeNumber(market, "unitSize") },
                { "expiry", expiry },
                { "expiryDatetime", this.iso8601(expiry) },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.safeNumber(market, "lotSize") },
                    { "price", this.safeNumber(market, "tickSize") },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", this.safeInteger(market, "maxLeverage") },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minBaseOrderSize") },
                        { "max", this.safeNumber(market, "maxBaseOrderSize") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", this.safeNumber(market, "maxPrice") },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minQuoteOrderSize") },
                        { "max", this.safeNumber(market, "maxQuoteOrderSize") },
                    } },
                } },
                { "created", this.safeInteger(market, "launchTime") },
                { "info", market },
            });
        }
        if (isTrue(getValue(this.options, "adjustForTimeDifference")))
        {
            await this.loadTimeDifference();
        }
        return result;
    }

    /**
     * @method
     * @name kucoin#loadMigrationStatus
     * @param {boolean} force load account state for non hf
     * @description loads the migration status for the account (hf or not)
     * @see https://www.kucoin.com/docs/rest/spot-trading/spot-hf-trade-pro-account/get-user-type
     * @returns {any} ignore
     */
    public async virtual Task<object> loadMigrationStatus(object force = null)
    {
        force ??= false;
        if (isTrue(isTrue(!isTrue((inOp(this.options, "hf"))) || isTrue((isEqual(getValue(this.options, "hf"), null)))) || isTrue(force)))
        {
            object result = await this.privateGetHfAccountsOpened();
            ((IDictionary<string,object>)this.options)["hf"] = this.safeBool(result, "data");
        }
        return true;
    }

    public virtual object handleHfAndParams(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object migrated = this.safeBool(this.options, "hf", false);
        object loadedHf = null;
        if (isTrue(!isEqual(migrated, null)))
        {
            if (isTrue(migrated))
            {
                loadedHf = true;
            } else
            {
                loadedHf = false;
            }
        }
        object hf = this.safeBool(parameters, "hf", loadedHf);
        parameters = this.omit(parameters, "hf");
        return new List<object>() {hf, parameters};
    }

    /**
     * @method
     * @name kucoin#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://docs.kucoin.com/#get-currencies
     * @param {object} params extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetCurrencies(parameters);
        //
        //    {
        //        "code":"200000",
        //        "data":[
        //           {
        //              "currency":"CSP",
        //              "name":"CSP",
        //              "fullName":"Caspian",
        //              "precision":8,
        //              "confirms":null,
        //              "contractAddress":null,
        //              "isMarginEnabled":false,
        //              "isDebitEnabled":false,
        //              "chains":[
        //                 {
        //                    "chainName":"ERC20",
        //                    "chainId": "eth"
        //                    "withdrawalMinSize":"2999",
        //                    "depositMinSize":null,
        //                    "withdrawFeeRate":"0",
        //                    "withdrawalMinFee":"2999",
        //                    "isWithdrawEnabled":false,
        //                    "isDepositEnabled":false,
        //                    "confirms":12,
        //                    "preConfirms":12,
        //                    "withdrawPrecision": 8,
        //                    "maxWithdraw": null,
        //                    "maxDeposit": null,
        //                    "needTag": false,
        //                    "contractAddress":"0xa6446d655a0c34bc4f05042ee88170d056cbaf45",
        //                    "depositFeeRate": "0.001", // present for some currencies/networks
        //                 }
        //              ]
        //           },
        //        ]
        //    }
        //
        object currenciesData = this.safeList(response, "data", new List<object>() {});
        object brokenCurrencies = this.safeList(this.options, "brokenCurrencies", new List<object>() {"00", "OPEN_ERROR", "HUF", "BDT"});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currenciesData)); postFixIncrement(ref i))
        {
            object entry = getValue(currenciesData, i);
            object id = this.safeString(entry, "currency");
            if (isTrue(this.inArray(id, brokenCurrencies)))
            {
                continue;
            }
            object code = this.safeCurrencyCode(id);
            object networks = new Dictionary<string, object>() {};
            object chains = this.safeList(entry, "chains", new List<object>() {});
            object chainsLength = getArrayLength(chains);
            for (object j = 0; isLessThan(j, chainsLength); postFixIncrement(ref j))
            {
                object chain = getValue(chains, j);
                object chainId = this.safeString(chain, "chainId");
                object networkCode = this.networkIdToCode(chainId, code);
                ((IDictionary<string,object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                    { "info", chain },
                    { "id", chainId },
                    { "name", this.safeString(chain, "chainName") },
                    { "code", networkCode },
                    { "active", null },
                    { "fee", this.safeNumber(chain, "withdrawalMinFee") },
                    { "deposit", this.safeBool(chain, "isDepositEnabled") },
                    { "withdraw", this.safeBool(chain, "isWithdrawEnabled") },
                    { "precision", this.parseNumber(this.parsePrecision(this.safeString(chain, "withdrawPrecision"))) },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", this.safeNumber(chain, "withdrawalMinSize") },
                            { "max", this.safeNumber(chain, "maxWithdraw") },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", this.safeNumber(chain, "depositMinSize") },
                            { "max", this.safeNumber(chain, "maxDeposit") },
                        } },
                    } },
                };
            }
            // kucoin has determined 'fiat' currencies with below logic
            object rawPrecision = this.safeString(entry, "precision");
            object precision = this.parseNumber(this.parsePrecision(rawPrecision));
            object isFiat = isEqual(chainsLength, 0);
            ((IDictionary<string,object>)result)[(string)code] = this.safeCurrencyStructure(new Dictionary<string, object>() {
                { "id", id },
                { "name", this.safeString(entry, "fullName") },
                { "code", code },
                { "type", ((bool) isTrue(isFiat)) ? "fiat" : "crypto" },
                { "precision", precision },
                { "info", entry },
                { "networks", networks },
                { "deposit", null },
                { "withdraw", null },
                { "active", null },
                { "fee", null },
                { "limits", null },
            });
        }
        return result;
    }

    /**
     * @method
     * @name kucoin#fetchAccounts
     * @description fetch all the accounts associated with a profile
     * @see https://docs.kucoin.com/#list-accounts
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/?id=account-structure} indexed by the account type
     */
    public async override Task<object> fetchAccounts(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.privateGetAccounts(parameters);
        //
        //     {
        //         "code": "200000",
        //         "data": [
        //             {
        //                 "balance": "0.00009788",
        //                 "available": "0.00009788",
        //                 "holds": "0",
        //                 "currency": "BTC",
        //                 "id": "5c6a4fd399a1d81c4f9cc4d0",
        //                 "type": "trade"
        //             },
        //             {
        //                 "balance": "0.00000001",
        //                 "available": "0.00000001",
        //                 "holds": "0",
        //                 "currency": "ETH",
        //                 "id": "5c6a49ec99a1d819392e8e9f",
        //                 "type": "trade"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object account = getValue(data, i);
            object accountId = this.safeString(account, "id");
            object currencyId = this.safeString(account, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object type = this.safeString(account, "type"); // main or trade
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", accountId },
                { "type", type },
                { "currency", code },
                { "code", code },
                { "info", account },
            });
        }
        return result;
    }

    /**
     * @method
     * @name kucoin#fetchTransactionFee
     * @description *DEPRECATED* please use fetchDepositWithdrawFee instead
     * @see https://docs.kucoin.com/#get-withdrawal-quotas
     * @param {string} code unified currency code
     * @param {object} params extra parameters specific to the exchange API endpoint
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/?id=fee-structure}
     */
    public async override Task<object> fetchTransactionFee(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["chain"] = ((string)this.networkCodeToId(networkCode)).ToLower();
        }
        object response = await this.privateGetWithdrawalsQuotas(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object withdrawFees = new Dictionary<string, object>() {};
        ((IDictionary<string,object>)withdrawFees)[(string)code] = this.safeNumber(data, "withdrawMinFee");
        return new Dictionary<string, object>() {
            { "info", response },
            { "withdraw", withdrawFees },
            { "deposit", new Dictionary<string, object>() {} },
        };
    }

    /**
     * @method
     * @name kucoin#fetchDepositWithdrawFee
     * @description fetch the fee for deposits and withdrawals
     * @see https://docs.kucoin.com/#get-withdrawal-quotas
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network] The chain of currency. This only apply for multi-chain currency, and there is no need for single chain currency; you can query the chain through the response of the GET /api/v2/currencies/{currency} interface
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/?id=fee-structure}
     */
    public async override Task<object> fetchDepositWithdrawFee(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["chain"] = ((string)this.networkCodeToId(networkCode)).ToLower();
        }
        object response = await this.privateGetWithdrawalsQuotas(this.extend(request, parameters));
        //
        //    {
        //        "code": "200000",
        //        "data": {
        //            "currency": "USDT",
        //            "limitBTCAmount": "1.00000000",
        //            "usedBTCAmount": "0.00000000",
        //            "remainAmount": "16548.072149",
        //            "availableAmount": "0",
        //            "withdrawMinFee": "25",
        //            "innerWithdrawMinFee": "0",
        //            "withdrawMinSize": "50",
        //            "isWithdrawEnabled": true,
        //            "precision": 6,
        //            "chain": "ERC20"
        //        }
        //    }
        //
        object data = this.safeDict(response, "data");
        return ((object)this.parseDepositWithdrawFee(data, currency));
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //    {
        //        "currency": "USDT",
        //        "limitBTCAmount": "1.00000000",
        //        "usedBTCAmount": "0.00000000",
        //        "remainAmount": "16548.072149",
        //        "availableAmount": "0",
        //        "withdrawMinFee": "25",
        //        "innerWithdrawMinFee": "0",
        //        "withdrawMinSize": "50",
        //        "isWithdrawEnabled": true,
        //        "precision": 6,
        //        "chain": "ERC20"
        //    }
        //
        if (isTrue(inOp(fee, "chains")))
        {
            // if data obtained through `currencies` endpoint
            object resultNew = new Dictionary<string, object>() {
                { "info", fee },
                { "withdraw", new Dictionary<string, object>() {
                    { "fee", null },
                    { "percentage", false },
                } },
                { "deposit", new Dictionary<string, object>() {
                    { "fee", null },
                    { "percentage", null },
                } },
                { "networks", new Dictionary<string, object>() {} },
            };
            object chains = this.safeList(fee, "chains", new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(chains)); postFixIncrement(ref i))
            {
                object chain = getValue(chains, i);
                object networkCodeNew = this.networkIdToCode(this.safeString(chain, "chainId"), this.safeString(currency, "code"));
                ((IDictionary<string,object>)getValue(resultNew, "networks"))[(string)networkCodeNew] = new Dictionary<string, object>() {
                    { "withdraw", new Dictionary<string, object>() {
                        { "fee", this.safeNumber2(chain, "withdrawalMinFee", "withdrawMinFee") },
                        { "percentage", false },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "fee", null },
                        { "percentage", null },
                    } },
                };
            }
            return resultNew;
        }
        object minWithdrawFee = this.safeNumber(fee, "withdrawMinFee");
        object result = new Dictionary<string, object>() {
            { "info", fee },
            { "withdraw", new Dictionary<string, object>() {
                { "fee", minWithdrawFee },
                { "percentage", false },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
        object networkId = this.safeString(fee, "chain");
        object networkCode = this.networkIdToCode(networkId, this.safeString(currency, "code"));
        ((IDictionary<string,object>)getValue(result, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
            { "withdraw", minWithdrawFee },
            { "deposit", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
        };
        return result;
    }

    public virtual object isFuturesMethod(object methodName, object parameters)
    {
        //
        // Helper
        // @methodName (string): The name of the method
        // @params (dict): The parameters passed into {methodName}
        // @return: true if the method used is meant for futures trading, false otherwise
        //
        object defaultType = this.safeString2(this.options, methodName, "defaultType", "trade");
        object requestedType = this.safeString(parameters, "type", defaultType);
        object accountsByType = this.safeDict(this.options, "accountsByType");
        object type = this.safeString(accountsByType, requestedType);
        if (isTrue(isEqual(type, null)))
        {
            object keys = new List<object>(((IDictionary<string,object>)accountsByType).Keys);
            throw new ExchangeError ((string)add(add(this.id, " isFuturesMethod() type must be one of "), String.Join(", ", ((IList<object>)keys).ToArray()))) ;
        }
        parameters = this.omit(parameters, "type");
        return isTrue(isTrue((isEqual(type, "contract"))) || isTrue((isEqual(type, "future")))) || isTrue((isEqual(type, "futures")));  // * (type === 'futures') deprecated, use (type === 'future')
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "symbol": "BTC-USDT",   // symbol
        //         "symbolName":"BTC-USDT", // Name of trading pairs, it would change after renaming
        //         "buy": "11328.9",   // bestAsk
        //         "sell": "11329",    // bestBid
        //         "changeRate": "-0.0055",    // 24h change rate
        //         "changePrice": "-63.6", // 24h change price
        //         "high": "11610",    // 24h highest price
        //         "low": "11200", // 24h lowest price
        //         "vol": "2282.70993217", // 24h volumethe aggregated trading volume in BTC
        //         "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
        //         "last": "11328.9",  // last price
        //         "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
        //         "takerFeeRate": "0.001",    // Basic Taker Fee
        //         "makerFeeRate": "0.001",    // Basic Maker Fee
        //         "takerCoefficient": "1",    // Taker Fee Coefficient
        //         "makerCoefficient": "1" // Maker Fee Coefficient
        //     }
        //
        //     {
        //         "trading": true,
        //         "symbol": "KCS-BTC",
        //         "buy": 0.00011,
        //         "sell": 0.00012,
        //         "sort": 100,
        //         "volValue": 3.13851792584,   //total
        //         "baseCurrency": "KCS",
        //         "market": "BTC",
        //         "quoteCurrency": "BTC",
        //         "symbolCode": "KCS-BTC",
        //         "datetime": 1548388122031,
        //         "high": 0.00013,
        //         "vol": 27514.34842,
        //         "low": 0.0001,
        //         "changePrice": -1.0e-5,
        //         "changeRate": -0.0769,
        //         "lastTradedPrice": 0.00012,
        //         "board": 0,
        //         "mark": 0
        //     }
        //
        // market/ticker ws subscription
        //
        //     {
        //         "bestAsk": "62258.9",
        //         "bestAskSize": "0.38579986",
        //         "bestBid": "62258.8",
        //         "bestBidSize": "0.0078381",
        //         "price": "62260.7",
        //         "sequence": "1621383297064",
        //         "size": "0.00002841",
        //         "time": 1634641777363
        //     }
        //
        // uta
        //
        //     {
        //         "symbol": "BTC-USDT",
        //         "name": "BTC-USDT",
        //         "bestBidSize": "0.69207954",
        //         "bestBidPrice": "110417.5",
        //         "bestAskSize": "0.08836606",
        //         "bestAskPrice": "110417.6",
        //         "lastPrice": "110417.5",
        //         "size": "0.00016",
        //         "open": "110105.1",
        //         "high": "110838.9",
        //         "low": "109705.5",
        //         "baseVolume": "1882.10069442",
        //         "quoteVolume": "207325626.822922498"
        //     }
        //
        object percentage = this.safeString(ticker, "changeRate");
        if (isTrue(!isEqual(percentage, null)))
        {
            percentage = Precise.stringMul(percentage, "100");
        }
        object last = this.safeStringN(ticker, new List<object>() {"last", "lastTradedPrice", "lastPrice"});
        last = this.safeString(ticker, "price", last);
        object marketId = this.safeString(ticker, "symbol");
        market = this.safeMarket(marketId, market, "-");
        object symbol = getValue(market, "symbol");
        object baseVolume = this.safeString2(ticker, "vol", "baseVolume");
        object quoteVolume = this.safeString2(ticker, "volValue", "quoteVolume");
        object timestamp = this.safeIntegerN(ticker, new List<object>() {"time", "datetime", "timePoint"});
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeStringN(ticker, new List<object>() {"buy", "bestBid", "bestBidPrice"}) },
            { "bidVolume", this.safeString(ticker, "bestBidSize") },
            { "ask", this.safeStringN(ticker, new List<object>() {"sell", "bestAsk", "bestAskPrice"}) },
            { "askVolume", this.safeString(ticker, "bestAskSize") },
            { "vwap", null },
            { "open", this.safeString(ticker, "open") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", this.safeString(ticker, "changePrice") },
            { "percentage", percentage },
            { "average", this.safeString(ticker, "averagePrice") },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "markPrice", this.safeString(ticker, "value") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name kucoin#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://docs.kucoin.com/#get-all-tickers
     * @see https://www.kucoin.com/docs-new/rest/ua/get-ticker
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @param {string} [params.tradeType] *uta only* set to SPOT or FUTURES
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        symbols = this.marketSymbols(symbols);
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchTickers", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        object response = null;
        if (isTrue(uta))
        {
            if (isTrue(!isEqual(symbols, null)))
            {
                object symbol = this.safeString(symbols, 0);
                object market = this.market(symbol);
                object type = null;
                var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
                type = ((IList<object>)typeparametersVariable)[0];
                parameters = ((IList<object>)typeparametersVariable)[1];
                if (isTrue(isEqual(type, "spot")))
                {
                    ((IDictionary<string,object>)request)["tradeType"] = "SPOT";
                } else
                {
                    ((IDictionary<string,object>)request)["tradeType"] = "FUTURES";
                }
            } else
            {
                object tradeType = this.safeStringUpper(parameters, "tradeType");
                if (isTrue(isEqual(tradeType, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " fetchTickers() requires a tradeType parameter for uta, either SPOT or FUTURES")) ;
                }
                ((IDictionary<string,object>)request)["tradeType"] = tradeType;
                parameters = this.omit(parameters, "tradeType");
            }
            response = await this.utaGetMarketTicker(this.extend(request, parameters));
        } else
        {
            response = await this.publicGetMarketAllTickers(parameters);
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object tickers = this.safeList2(data, "ticker", "list", new List<object>() {});
        object time = this.safeInteger2(data, "time", "ts");
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(tickers)); postFixIncrement(ref i))
        {
            ((IDictionary<string,object>)getValue(tickers, i))["time"] = time;
            object ticker = this.parseTicker(getValue(tickers, i));
            object symbol = this.safeString(ticker, "symbol");
            if (isTrue(!isEqual(symbol, null)))
            {
                ((IDictionary<string,object>)result)[(string)symbol] = ticker;
            }
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    /**
     * @method
     * @name kucoin#fetchMarkPrices
     * @description fetches the mark price for multiple markets
     * @see https://www.kucoin.com/docs/rest/margin-trading/margin-info/get-all-margin-trading-pairs-mark-prices
     * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
     */
    public async override Task<object> fetchMarkPrices(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.publicGetMarkPriceAllSymbols(parameters);
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTickers(data);
    }

    /**
     * @method
     * @name kucoin#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://docs.kucoin.com/#get-24hr-stats
     * @see https://www.kucoin.com/docs-new/rest/ua/get-ticker
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchTicker", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        object response = null;
        object result = null;
        if (isTrue(uta))
        {
            object type = null;
            var typeparametersVariable = this.handleMarketTypeAndParams("fetchTicker", market, parameters);
            type = ((IList<object>)typeparametersVariable)[0];
            parameters = ((IList<object>)typeparametersVariable)[1];
            if (isTrue(isEqual(type, "spot")))
            {
                ((IDictionary<string,object>)request)["tradeType"] = "SPOT";
            } else
            {
                ((IDictionary<string,object>)request)["tradeType"] = "FUTURES";
            }
            response = await this.utaGetMarketTicker(this.extend(request, parameters));
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //             "tradeType": "SPOT",
            //             "ts": 1762061290067,
            //             "list": [
            //                 {
            //                     "symbol": "BTC-USDT",
            //                     "name": "BTC-USDT",
            //                     "bestBidSize": "0.69207954",
            //                     "bestBidPrice": "110417.5",
            //                     "bestAskSize": "0.08836606",
            //                     "bestAskPrice": "110417.6",
            //                     "lastPrice": "110417.5",
            //                     "size": "0.00016",
            //                     "open": "110105.1",
            //                     "high": "110838.9",
            //                     "low": "109705.5",
            //                     "baseVolume": "1882.10069442",
            //                     "quoteVolume": "207325626.822922498"
            //                 }
            //             ]
            //         }
            //     }
            //
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            object resultList = this.safeList(data, "list", new List<object>() {});
            result = this.safeDict(resultList, 0, new Dictionary<string, object>() {});
        } else
        {
            response = await this.publicGetMarketStats(this.extend(request, parameters));
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //             "time": 1602832092060,  // time
            //             "symbol": "BTC-USDT",   // symbol
            //             "buy": "11328.9",   // bestAsk
            //             "sell": "11329",    // bestBid
            //             "changeRate": "-0.0055",    // 24h change rate
            //             "changePrice": "-63.6", // 24h change price
            //             "high": "11610",    // 24h highest price
            //             "low": "11200", // 24h lowest price
            //             "vol": "2282.70993217", // 24h volumethe aggregated trading volume in BTC
            //             "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
            //             "last": "11328.9",  // last price
            //             "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
            //             "takerFeeRate": "0.001",    // Basic Taker Fee
            //             "makerFeeRate": "0.001",    // Basic Maker Fee
            //             "takerCoefficient": "1",    // Taker Fee Coefficient
            //             "makerCoefficient": "1" // Maker Fee Coefficient
            //         }
            //     }
            //
            result = this.safeDict(response, "data", new Dictionary<string, object>() {});
        }
        return this.parseTicker(result, market);
    }

    /**
     * @method
     * @name kucoin#fetchMarkPrice
     * @description fetches the mark price for a specific market
     * @see https://www.kucoin.com/docs/rest/margin-trading/margin-info/get-mark-price
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
     */
    public async override Task<object> fetchMarkPrice(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetMarkPriceSymbolCurrent(this.extend(request, parameters));
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTicker(data, market);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         "1545904980",             // Start time of the candle cycle
        //         "0.058",                  // opening price
        //         "0.049",                  // closing price
        //         "0.058",                  // highest price
        //         "0.049",                  // lowest price
        //         "0.018",                  // base volume
        //         "0.000945",               // quote volume
        //     ]
        //
        return new List<object> {this.safeTimestamp(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 5)};
    }

    /**
     * @method
     * @name kucoin#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://docs.kucoin.com/#get-klines
     * @see https://www.kucoin.com/docs-new/rest/ua/get-klines
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, 1500);
        }
        object market = this.market(symbol);
        object marketId = getValue(market, "id");
        object request = new Dictionary<string, object>() {
            { "symbol", marketId },
        };
        object duration = multiply(this.parseTimeframe(timeframe), 1000);
        object endAt = this.milliseconds(); // required param
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startAt"] = this.parseToInt((Math.Floor(Double.Parse((divide(since, 1000)).ToString()))));
            if (isTrue(isEqual(limit, null)))
            {
                // https://docs.kucoin.com/#get-klines
                // https://docs.kucoin.com/#details
                // For each query, the system would return at most 1500 pieces of data.
                // To obtain more data, please page the data by time.
                limit = this.safeInteger(this.options, "fetchOHLCVLimit", 1500);
            }
            endAt = this.sum(since, multiply(limit, duration));
        } else if (isTrue(!isEqual(limit, null)))
        {
            since = subtract(endAt, multiply(limit, duration));
            ((IDictionary<string,object>)request)["startAt"] = this.parseToInt((Math.Floor(Double.Parse((divide(since, 1000)).ToString()))));
        }
        ((IDictionary<string,object>)request)["endAt"] = this.parseToInt((Math.Floor(Double.Parse((divide(endAt, 1000)).ToString()))));
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        object response = null;
        object result = null;
        if (isTrue(uta))
        {
            object type = null;
            var typeparametersVariable = this.handleMarketTypeAndParams("fetchOHLCV", market, parameters);
            type = ((IList<object>)typeparametersVariable)[0];
            parameters = ((IList<object>)typeparametersVariable)[1];
            if (isTrue(isEqual(type, "spot")))
            {
                ((IDictionary<string,object>)request)["tradeType"] = "SPOT";
            } else
            {
                ((IDictionary<string,object>)request)["tradeType"] = "FUTURES";
            }
            ((IDictionary<string,object>)request)["interval"] = this.safeString(this.timeframes, timeframe, timeframe);
            response = await this.utaGetMarketKline(this.extend(request, parameters));
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //             "tradeType": "SPOT",
            //             "symbol": "BTC-USDT",
            //             "list": [
            //                 ["1762240200","104581.4","104527.1","104620.1","104526.4","5.57665554","583263.661804122"],
            //                 ["1762240140","104565.6","104581.3","104601.7","104511.3","6.48505114","677973.775916968"],
            //                 ["1762240080","104621.5","104571.3","104704.7","104571.3","14.51713618","1519468.954060838"]
            //             ]
            //         }
            //     }
            //
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            result = this.safeList(data, "list", new List<object>() {});
        } else
        {
            ((IDictionary<string,object>)request)["type"] = this.safeString(this.timeframes, timeframe, timeframe);
            response = await this.publicGetMarketCandles(this.extend(request, parameters));
            //
            //     {
            //         "code":"200000",
            //         "data":[
            //             ["1591517700","0.025078","0.025069","0.025084","0.025064","18.9883256","0.4761861079404"],
            //             ["1591516800","0.025089","0.025079","0.025089","0.02506","99.4716622","2.494143499081"],
            //             ["1591515900","0.025079","0.02509","0.025091","0.025068","59.83701271","1.50060885172798"],
            //         ]
            //     }
            //
            result = this.safeList(response, "data", new List<object>() {});
        }
        return this.parseOHLCVs(result, market, timeframe, since, limit);
    }

    /**
     * @method
     * @name kucoin#createDepositAddress
     * @see https://www.kucoin.com/docs/rest/funding/deposit/create-deposit-address-v3-
     * @description create a currency deposit address
     * @param {string} code unified currency code of the currency for the deposit address
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network] the blockchain network name
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/?id=address-structure}
     */
    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["chain"] = this.networkCodeToId(networkCode); // docs mention "chain-name", but seems "chain-id" is used, like in "fetchDepositAddress"
        }
        object response = await this.privatePostDepositAddressCreate(this.extend(request, parameters));
        // {"code":"260000","msg":"Deposit address already exists."}
        //
        //   {
        //     "code": "200000",
        //     "data": {
        //       "address": "0x2336d1834faab10b2dac44e468f2627138417431",
        //       "memo": null,
        //       "chainId": "bsc",
        //       "to": "MAIN",
        //       "expirationDate": 0,
        //       "currency": "BNB",
        //       "chainName": "BEP20"
        //     }
        //   }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseDepositAddress(data, currency);
    }

    /**
     * @method
     * @name kucoin#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://docs.kucoin.com/#get-deposit-addresses-v2
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network] the blockchain network name
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["chain"] = ((string)this.networkCodeToId(networkCode)).ToLower();
        }
        object version = getValue(getValue(getValue(getValue(this.options, "versions"), "private"), "GET"), "deposit-addresses");
        ((IDictionary<string,object>)getValue(getValue(getValue(this.options, "versions"), "private"), "GET"))["deposit-addresses"] = "v1";
        object response = await this.privateGetDepositAddresses(this.extend(request, parameters));
        // BCH {"code":"200000","data":{"address":"bitcoincash:qza3m4nj9rx7l9r0cdadfqxts6f92shvhvr5ls4q7z","memo":""}}
        // BTC {"code":"200000","data":{"address":"36SjucKqQpQSvsak9A7h6qzFjrVXpRNZhE","memo":""}}
        ((IDictionary<string,object>)getValue(getValue(getValue(this.options, "versions"), "private"), "GET"))["deposit-addresses"] = version;
        object data = this.safeValue(response, "data");
        if (isTrue(isEqual(data, null)))
        {
            throw new ExchangeError ((string)add(this.id, " fetchDepositAddress() returned an empty response, you might try to run createDepositAddress() first and try again")) ;
        }
        return this.parseDepositAddress(data, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        object address = this.safeString(depositAddress, "address");
        // BCH/BSV is returned with a "bitcoincash:" prefix, which we cut off here and only keep the address
        if (isTrue(!isEqual(address, null)))
        {
            address = ((string)address).Replace((string)"bitcoincash:", (string)"");
        }
        object code = null;
        if (isTrue(!isEqual(currency, null)))
        {
            code = this.safeCurrencyCode(getValue(currency, "id"));
            if (isTrue(!isEqual(code, "NIM")))
            {
                // contains spaces
                this.checkAddress(address);
            }
        }
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", code },
            { "network", this.networkIdToCode(this.safeString(depositAddress, "chainId")) },
            { "address", address },
            { "tag", this.safeString(depositAddress, "memo") },
        };
    }

    /**
     * @method
     * @name kucoin#fetchDepositAddressesByNetwork
     * @see https://docs.kucoin.com/#get-deposit-addresses-v2
     * @description fetch the deposit address for a currency associated with this account
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an array of [address structures]{@link https://docs.ccxt.com/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddressesByNetwork(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object version = getValue(getValue(getValue(getValue(this.options, "versions"), "private"), "GET"), "deposit-addresses");
        ((IDictionary<string,object>)getValue(getValue(getValue(this.options, "versions"), "private"), "GET"))["deposit-addresses"] = "v2";
        object response = await this.privateGetDepositAddresses(this.extend(request, parameters));
        //
        //     {
        //         "code": "200000",
        //         "data": [
        //             {
        //                 "address": "fr1qvus7d4d5fgxj5e7zvqe6yhxd7txm95h2and69r",
        //                 "memo": "",
        //                 "chain": "BTC-Segwit",
        //                 "contractAddress": ""
        //             },
        //             {"address":"37icNMEWbiF8ZkwUMxmfzMxi2A1MQ44bMn","memo":"","chain":"BTC","contractAddress":""},
        //             {"address":"Deposit temporarily blocked","memo":"","chain":"TRC20","contractAddress":""}
        //         ]
        //     }
        //
        ((IDictionary<string,object>)getValue(getValue(getValue(this.options, "versions"), "private"), "GET"))["deposit-addresses"] = version;
        object chains = this.safeList(response, "data", new List<object>() {});
        object parsed = this.parseDepositAddresses(chains, new List<object>() {getValue(currency, "code")}, false, new Dictionary<string, object>() {
            { "currency", getValue(currency, "code") },
        });
        return this.indexBy(parsed, "network");
    }

    /**
     * @method
     * @name kucoin#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://www.kucoin.com/docs/rest/spot-trading/market-data/get-part-order-book-aggregated-
     * @see https://www.kucoin.com/docs/rest/spot-trading/market-data/get-full-order-book-aggregated-
     * @see https://www.kucoin.com/docs-new/rest/ua/get-orderbook
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object level = this.safeInteger(parameters, "level", 2);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object isAuthenticated = this.checkRequiredCredentials(false);
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchOrderBook", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        object response = null;
        if (isTrue(uta))
        {
            if (isTrue(isEqual(limit, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchOrderBook() requires a limit argument for uta, either 20, 50, 100 or FULL")) ;
            }
            ((IDictionary<string,object>)request)["limit"] = limit;
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            object type = null;
            var typeparametersVariable = this.handleMarketTypeAndParams("fetchOrderBook", market, parameters);
            type = ((IList<object>)typeparametersVariable)[0];
            parameters = ((IList<object>)typeparametersVariable)[1];
            if (isTrue(isEqual(type, "spot")))
            {
                ((IDictionary<string,object>)request)["tradeType"] = "SPOT";
            } else
            {
                ((IDictionary<string,object>)request)["tradeType"] = "FUTURES";
            }
            response = await this.utaGetMarketOrderbook(this.extend(request, parameters));
        } else if (isTrue(!isTrue(isAuthenticated) || isTrue(!isEqual(limit, null))))
        {
            if (isTrue(isEqual(level, 2)))
            {
                ((IDictionary<string,object>)request)["level"] = level;
                if (isTrue(!isEqual(limit, null)))
                {
                    if (isTrue(isTrue((isEqual(limit, 20))) || isTrue((isEqual(limit, 100)))))
                    {
                        ((IDictionary<string,object>)request)["limit"] = limit;
                    } else
                    {
                        throw new ExchangeError ((string)add(this.id, " fetchOrderBook() limit argument must be 20 or 100")) ;
                    }
                }
                ((IDictionary<string,object>)request)["limit"] = ((bool) isTrue(limit)) ? limit : 100;
            }
            response = await this.publicGetMarketOrderbookLevelLevelLimit(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetMarketOrderbookLevel2(this.extend(request, parameters));
        }
        //
        // public (v1) market/orderbook/level2_20 and market/orderbook/level2_100
        //
        //     {
        //         "sequence": "3262786978",
        //         "time": 1550653727731,
        //         "bids": [
        //             ["6500.12", "0.45054140"],
        //             ["6500.11", "0.45054140"],
        //         ],
        //         "asks": [
        //             ["6500.16", "0.57753524"],
        //             ["6500.15", "0.57753524"],
        //         ]
        //     }
        //
        // private (v3) market/orderbook/level2
        //
        //     {
        //         "sequence": "3262786978",
        //         "time": 1550653727731,
        //         "bids": [
        //             ["6500.12", "0.45054140"],
        //             ["6500.11", "0.45054140"],
        //         ],
        //         "asks": [
        //             ["6500.16", "0.57753524"],
        //             ["6500.15", "0.57753524"],
        //         ]
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(data, "time");
        object orderbook = this.parseOrderBook(data, getValue(market, "symbol"), timestamp, "bids", "asks", subtract(level, 2), subtract(level, 1));
        ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger(data, "sequence");
        return orderbook;
    }

    public virtual object handleTriggerPrices(object parameters)
    {
        object triggerPrice = this.safeValue2(parameters, "triggerPrice", "stopPrice");
        object stopLossPrice = this.safeValue(parameters, "stopLossPrice");
        object takeProfitPrice = this.safeValue(parameters, "takeProfitPrice");
        object isStopLoss = !isEqual(stopLossPrice, null);
        object isTakeProfit = !isEqual(takeProfitPrice, null);
        if (isTrue(isTrue(isTrue((isTrue(isStopLoss) && isTrue(isTakeProfit))) || isTrue((isTrue(triggerPrice) && isTrue(stopLossPrice)))) || isTrue((isTrue(triggerPrice) && isTrue(isTakeProfit)))))
        {
            throw new ExchangeError ((string)add(this.id, " createOrder() - you should use either triggerPrice or stopLossPrice or takeProfitPrice")) ;
        }
        return new List<object>() {triggerPrice, stopLossPrice, takeProfitPrice};
    }

    /**
     * @method
     * @name kucoin#createOrder
     * @description Create an order on the exchange
     * @see https://docs.kucoin.com/spot#place-a-new-order
     * @see https://docs.kucoin.com/spot#place-a-new-order-2
     * @see https://docs.kucoin.com/spot#place-a-margin-order
     * @see https://docs.kucoin.com/spot-hf/#place-hf-order
     * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-order-test
     * @see https://www.kucoin.com/docs/rest/margin-trading/orders/place-margin-order-test
     * @see https://www.kucoin.com/docs/rest/spot-trading/spot-hf-trade-pro-account/sync-place-hf-order
     * @param {string} symbol Unified CCXT market symbol
     * @param {string} type 'limit' or 'market'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount the amount of currency to trade
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params]  extra parameters specific to the exchange API endpoint
     * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
     * @param {string} [params.marginMode] 'cross', // cross (cross mode) and isolated (isolated mode), set to cross by default, the isolated mode will be released soon, stay tuned
     * @param {string} [params.timeInForce] GTC, GTT, IOC, or FOK, default is GTC, limit orders only
     * @param {string} [params.postOnly] Post only flag, invalid when timeInForce is IOC or FOK
     *
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {string} [params.clientOid] client order id, defaults to uuid if not passed
     * @param {string} [params.remark] remark for the order, length cannot exceed 100 utf8 characters
     * @param {string} [params.tradeType] 'TRADE', // TRADE, MARGIN_TRADE // not used with margin orders
     * limit orders ---------------------------------------------------
     * @param {float} [params.cancelAfter] long, // cancel after n seconds, requires timeInForce to be GTT
     * @param {bool} [params.hidden] false, // Order will not be displayed in the order book
     * @param {bool} [params.iceberg] false, // Only a portion of the order is displayed in the order book
     * @param {string} [params.visibleSize] this.amountToPrecision (symbol, visibleSize), // The maximum visible size of an iceberg order
     * market orders --------------------------------------------------
     * @param {string} [params.funds] // Amount of quote currency to use
     * stop orders ----------------------------------------------------
     * @param {string} [params.stop]  Either loss or entry, the default is loss. Requires triggerPrice to be defined
     * margin orders --------------------------------------------------
     * @param {float} [params.leverage] Leverage size of the order
     * @param {string} [params.stp] '', // self trade prevention, CN, CO, CB or DC
     * @param {bool} [params.autoBorrow] false, // The system will first borrow you funds at the optimal interest rate and then place an order for you
     * @param {bool} [params.hf] false, // true for hf order
     * @param {bool} [params.test] set to true to test an order, no order will be created but the request will be validated
     * @param {bool} [params.sync] set to true to use the hf sync call
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object testOrder = this.safeBool(parameters, "test", false);
        parameters = this.omit(parameters, "test");
        object hf = null;
        var hfparametersVariable = this.handleHfAndParams(parameters);
        hf = ((IList<object>)hfparametersVariable)[0];
        parameters = ((IList<object>)hfparametersVariable)[1];
        object useSync = false;
        var useSyncparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "sync", false);
        useSync = ((IList<object>)useSyncparametersVariable)[0];
        parameters = ((IList<object>)useSyncparametersVariable)[1];
        var triggerPricestopLossPricetakeProfitPriceVariable = this.handleTriggerPrices(parameters);
        var triggerPrice = ((IList<object>) triggerPricestopLossPricetakeProfitPriceVariable)[0];
        var stopLossPrice = ((IList<object>) triggerPricestopLossPricetakeProfitPriceVariable)[1];
        var takeProfitPrice = ((IList<object>) triggerPricestopLossPricetakeProfitPriceVariable)[2];
        object tradeType = this.safeString(parameters, "tradeType"); // keep it for backward compatibility
        object isTriggerOrder = (isTrue(isTrue(triggerPrice) || isTrue(stopLossPrice)) || isTrue(takeProfitPrice));
        object marginResult = this.handleMarginModeAndParams("createOrder", parameters);
        object marginMode = this.safeString(marginResult, 0);
        object isMarginOrder = isTrue(isEqual(tradeType, "MARGIN_TRADE")) || isTrue(!isEqual(marginMode, null));
        // don't omit anything before calling createOrderRequest
        object orderRequest = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object response = null;
        if (isTrue(testOrder))
        {
            if (isTrue(isMarginOrder))
            {
                response = await this.privatePostMarginOrderTest(orderRequest);
            } else if (isTrue(hf))
            {
                response = await this.privatePostHfOrdersTest(orderRequest);
            } else
            {
                response = await this.privatePostOrdersTest(orderRequest);
            }
        } else if (isTrue(isTriggerOrder))
        {
            response = await this.privatePostStopOrder(orderRequest);
        } else if (isTrue(isMarginOrder))
        {
            response = await this.privatePostMarginOrder(orderRequest);
        } else if (isTrue(useSync))
        {
            response = await this.privatePostHfOrdersSync(orderRequest);
        } else if (isTrue(hf))
        {
            response = await this.privatePostHfOrders(orderRequest);
        } else
        {
            response = await this.privatePostOrders(orderRequest);
        }
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "orderId": "5bd6e9286d99522a52e458de"
        //         }
        //    }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    /**
     * @method
     * @name kucoin#createMarketOrderWithCost
     * @description create a market order by providing the symbol, side and cost
     * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} side 'buy' or 'sell'
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createMarketOrderWithCost(object symbol, object side, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object req = new Dictionary<string, object>() {
            { "cost", cost },
        };
        return await this.createOrder(symbol, "market", side, cost, null, this.extend(req, parameters));
    }

    /**
     * @method
     * @name kucoin#createMarketBuyOrderWithCost
     * @description create a market buy order by providing the symbol and cost
     * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        return await this.createMarketOrderWithCost(symbol, "buy", cost, parameters);
    }

    /**
     * @method
     * @name kucoin#createMarketSellOrderWithCost
     * @description create a market sell order by providing the symbol and cost
     * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createMarketSellOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        return await this.createMarketOrderWithCost(symbol, "sell", cost, parameters);
    }

    /**
     * @method
     * @name kucoin#createOrders
     * @description create a list of trade orders
     * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-multiple-orders
     * @see https://www.kucoin.com/docs/rest/spot-trading/spot-hf-trade-pro-account/place-multiple-hf-orders
     * @see https://www.kucoin.com/docs/rest/spot-trading/spot-hf-trade-pro-account/sync-place-multiple-hf-orders
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params]  extra parameters specific to the exchange API endpoint
     * @param {bool} [params.hf] false, // true for hf orders
     * @param {bool} [params.sync] false, // true to use the hf sync call
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        object symbol = null;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            if (isTrue(isEqual(symbol, null)))
            {
                symbol = marketId;
            } else
            {
                if (isTrue(!isEqual(symbol, marketId)))
                {
                    throw new BadRequest ((string)add(this.id, " createOrders() requires all orders to have the same symbol")) ;
                }
            }
            object type = this.safeString(rawOrder, "type");
            if (isTrue(!isEqual(type, "limit")))
            {
                throw new BadRequest ((string)add(this.id, " createOrders() only supports limit orders")) ;
            }
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeValue(rawOrder, "params", new Dictionary<string, object>() {});
            object orderRequest = this.createOrderRequest(marketId, type, side, amount, price, orderParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "orderList", ordersRequests },
        };
        object hf = null;
        var hfparametersVariable = this.handleHfAndParams(parameters);
        hf = ((IList<object>)hfparametersVariable)[0];
        parameters = ((IList<object>)hfparametersVariable)[1];
        object useSync = false;
        var useSyncparametersVariable = this.handleOptionAndParams(parameters, "createOrders", "sync", false);
        useSync = ((IList<object>)useSyncparametersVariable)[0];
        parameters = ((IList<object>)useSyncparametersVariable)[1];
        object response = null;
        if (isTrue(useSync))
        {
            response = await this.privatePostHfOrdersMultiSync(this.extend(request, parameters));
        } else if (isTrue(hf))
        {
            response = await this.privatePostHfOrdersMulti(this.extend(request, parameters));
        } else
        {
            response = await this.privatePostOrdersMulti(this.extend(request, parameters));
        }
        //
        // {
        //     "code": "200000",
        //     "data": {
        //        "data": [
        //           {
        //              "symbol": "LTC-USDT",
        //              "type": "limit",
        //              "side": "sell",
        //              "price": "90",
        //              "size": "0.1",
        //              "funds": null,
        //              "stp": "",
        //              "stop": "",
        //              "stopPrice": null,
        //              "timeInForce": "GTC",
        //              "cancelAfter": 0,
        //              "postOnly": false,
        //              "hidden": false,
        //              "iceberge": false,
        //              "iceberg": false,
        //              "visibleSize": null,
        //              "channel": "API",
        //              "id": "6539148443fcf500079d15e5",
        //              "status": "success",
        //              "failMsg": null,
        //              "clientOid": "5c4c5398-8ab2-4b4e-af8a-e2d90ad2488f"
        //           },
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        data = this.safeList(data, "data", new List<object>() {});
        return this.parseOrders(data);
    }

    public virtual object marketOrderAmountToPrecision(object symbol, object amount)
    {
        object market = this.market(symbol);
        object result = this.decimalToPrecision(amount, TRUNCATE, getValue(getValue(market, "info"), "quoteIncrement"), this.precisionMode, this.paddingMode);
        if (isTrue(isEqual(result, "0")))
        {
            throw new InvalidOrder ((string)add(add(add(add(this.id, " amount of "), getValue(market, "symbol")), " must be greater than minimum amount precision of "), this.numberToString(getValue(getValue(market, "precision"), "amount")))) ;
        }
        return result;
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        // required param, cannot be used twice
        object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId", this.uuid());
        parameters = this.omit(parameters, new List<object>() {"clientOid", "clientOrderId"});
        object request = new Dictionary<string, object>() {
            { "clientOid", clientOrderId },
            { "side", side },
            { "symbol", getValue(market, "id") },
            { "type", type },
        };
        object quoteAmount = this.safeNumber2(parameters, "cost", "funds");
        object amountString = null;
        object costString = null;
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(type, "market")))
        {
            if (isTrue(!isEqual(quoteAmount, null)))
            {
                parameters = this.omit(parameters, new List<object>() {"cost", "funds"});
                // kucoin uses base precision even for quote values
                costString = this.marketOrderAmountToPrecision(symbol, quoteAmount);
                ((IDictionary<string,object>)request)["funds"] = costString;
            } else
            {
                amountString = this.amountToPrecision(symbol, amount);
                ((IDictionary<string,object>)request)["size"] = this.amountToPrecision(symbol, amount);
            }
        } else
        {
            amountString = this.amountToPrecision(symbol, amount);
            ((IDictionary<string,object>)request)["size"] = amountString;
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object tradeType = this.safeString(parameters, "tradeType"); // keep it for backward compatibility
        var triggerPricestopLossPricetakeProfitPriceVariable = this.handleTriggerPrices(parameters);
        var triggerPrice = ((IList<object>) triggerPricestopLossPricetakeProfitPriceVariable)[0];
        var stopLossPrice = ((IList<object>) triggerPricestopLossPricetakeProfitPriceVariable)[1];
        var takeProfitPrice = ((IList<object>) triggerPricestopLossPricetakeProfitPriceVariable)[2];
        object isTriggerOrder = (isTrue(isTrue(triggerPrice) || isTrue(stopLossPrice)) || isTrue(takeProfitPrice));
        object isMarginOrder = isTrue(isEqual(tradeType, "MARGIN_TRADE")) || isTrue(!isEqual(marginMode, null));
        parameters = this.omit(parameters, new List<object>() {"stopLossPrice", "takeProfitPrice", "triggerPrice", "stopPrice"});
        if (isTrue(isTriggerOrder))
        {
            if (isTrue(triggerPrice))
            {
                ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, triggerPrice);
            } else if (isTrue(isTrue(stopLossPrice) || isTrue(takeProfitPrice)))
            {
                if (isTrue(stopLossPrice))
                {
                    ((IDictionary<string,object>)request)["stop"] = ((bool) isTrue((isEqual(side, "buy")))) ? "entry" : "loss";
                    ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, stopLossPrice);
                } else
                {
                    ((IDictionary<string,object>)request)["stop"] = ((bool) isTrue((isEqual(side, "buy")))) ? "loss" : "entry";
                    ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, takeProfitPrice);
                }
            }
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                throw new BadRequest ((string)add(this.id, " createOrder does not support isolated margin for stop orders")) ;
            } else if (isTrue(isEqual(marginMode, "cross")))
            {
                ((IDictionary<string,object>)request)["tradeType"] = getValue(getValue(this.options, "marginModes"), marginMode);
            }
        } else if (isTrue(isMarginOrder))
        {
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                ((IDictionary<string,object>)request)["marginModel"] = "isolated";
            }
        }
        object postOnly = null;
        var postOnlyparametersVariable = this.handlePostOnly(isEqual(type, "market"), false, parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["postOnly"] = true;
        }
        return this.extend(request, parameters);
    }

    /**
     * @method
     * @name kucoin#editOrder
     * @description edit an order, kucoin currently only supports the modification of HF orders
     * @see https://docs.kucoin.com/spot-hf/#modify-order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type not used
     * @param {string} side not used
     * @param {float} amount how much of the currency you want to trade in units of the base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] client order id, defaults to id if not passed
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["newSize"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["newPrice"] = this.priceToPrecision(symbol, price);
        }
        object response = await this.privatePostHfOrdersAlter(this.extend(request, parameters));
        //
        // {
        //     "code":"200000",
        //     "data":{
        //        "newOrderId":"6478d7a6c883280001e92d8b"
        //     }
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    /**
     * @method
     * @name kucoin#cancelOrder
     * @description cancels an open order
     * @see https://docs.kucoin.com/spot#cancel-an-order
     * @see https://docs.kucoin.com/spot#cancel-an-order-2
     * @see https://docs.kucoin.com/spot#cancel-single-order-by-clientoid
     * @see https://docs.kucoin.com/spot#cancel-single-order-by-clientoid-2
     * @see https://docs.kucoin.com/spot-hf/#cancel-orders-by-orderid
     * @see https://docs.kucoin.com/spot-hf/#cancel-order-by-clientoid
     * @see https://www.kucoin.com/docs/rest/spot-trading/spot-hf-trade-pro-account/sync-cancel-hf-order-by-orderid
     * @see https://www.kucoin.com/docs/rest/spot-trading/spot-hf-trade-pro-account/sync-cancel-hf-order-by-clientoid
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.trigger] True if cancelling a stop order
     * @param {bool} [params.hf] false, // true for hf order
     * @param {bool} [params.sync] false, // true to use the hf sync call
     * @returns Response from the exchange
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId");
        object trigger = this.safeBool2(parameters, "stop", "trigger", false);
        object hf = null;
        var hfparametersVariable = this.handleHfAndParams(parameters);
        hf = ((IList<object>)hfparametersVariable)[0];
        parameters = ((IList<object>)hfparametersVariable)[1];
        object useSync = false;
        var useSyncparametersVariable = this.handleOptionAndParams(parameters, "cancelOrder", "sync", false);
        useSync = ((IList<object>)useSyncparametersVariable)[0];
        parameters = ((IList<object>)useSyncparametersVariable)[1];
        if (isTrue(isTrue(hf) || isTrue(useSync)))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol parameter for hf orders")) ;
            }
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object response = null;
        parameters = this.omit(parameters, new List<object>() {"clientOid", "clientOrderId", "stop", "trigger"});
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
            if (isTrue(trigger))
            {
                response = await this.privateDeleteStopOrderCancelOrderByClientOid(this.extend(request, parameters));
            } else if (isTrue(useSync))
            {
                response = await this.privateDeleteHfOrdersSyncClientOrderClientOid(this.extend(request, parameters));
            } else if (isTrue(hf))
            {
                response = await this.privateDeleteHfOrdersClientOrderClientOid(this.extend(request, parameters));
            } else
            {
                response = await this.privateDeleteOrderClientOrderClientOid(this.extend(request, parameters));
            }
            response = this.safeDict(response, "data");
            return this.parseOrder(response);
        } else
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
            if (isTrue(trigger))
            {
                response = await this.privateDeleteStopOrderOrderId(this.extend(request, parameters));
            } else if (isTrue(useSync))
            {
                response = await this.privateDeleteHfOrdersSyncOrderId(this.extend(request, parameters));
            } else if (isTrue(hf))
            {
                response = await this.privateDeleteHfOrdersOrderId(this.extend(request, parameters));
                //
                //    {
                //        "code": "200000",
                //        "data": {
                //          "orderId": "630625dbd9180300014c8d52"
                //        }
                //    }
                //
                response = this.safeDict(response, "data");
                return this.parseOrder(response);
            } else
            {
                response = await this.privateDeleteOrdersOrderId(this.extend(request, parameters));
            }
            object data = this.safeDict(response, "data");
            object orderIds = this.safeList(data, "cancelledOrderIds", new List<object>() {});
            object orderId = this.safeString(orderIds, 0);
            return this.safeOrder(new Dictionary<string, object>() {
                { "info", data },
                { "id", orderId },
            });
        }
    }

    /**
     * @method
     * @name kucoin#cancelAllOrders
     * @description cancel all open orders
     * @see https://docs.kucoin.com/spot#cancel-all-orders
     * @see https://docs.kucoin.com/spot#cancel-orders
     * @see https://docs.kucoin.com/spot-hf/#cancel-all-hf-orders-by-symbol
     * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.trigger] *invalid for isolated margin* true if cancelling all stop orders
     * @param {string} [params.marginMode] 'cross' or 'isolated'
     * @param {string} [params.orderIds] *stop orders only* Comma seperated order IDs
     * @param {bool} [params.hf] false, // true for hf order
     * @returns Response from the exchange
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object trigger = this.safeBool2(parameters, "trigger", "stop", false);
        object hf = null;
        var hfparametersVariable = this.handleHfAndParams(parameters);
        hf = ((IList<object>)hfparametersVariable)[0];
        parameters = ((IList<object>)hfparametersVariable)[1];
        parameters = this.omit(parameters, "stop");
        var marginModequeryVariable = this.handleMarginModeAndParams("cancelAllOrders", parameters);
        var marginMode = ((IList<object>) marginModequeryVariable)[0];
        var query = ((IList<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(symbol, null)))
        {
            ((IDictionary<string,object>)request)["symbol"] = this.marketId(symbol);
        }
        if (isTrue(!isEqual(marginMode, null)))
        {
            ((IDictionary<string,object>)request)["tradeType"] = getValue(getValue(this.options, "marginModes"), marginMode);
            if (isTrue(isTrue(isEqual(marginMode, "isolated")) && isTrue(trigger)))
            {
                throw new BadRequest ((string)add(this.id, " cancelAllOrders does not support isolated margin for stop orders")) ;
            }
        }
        object response = null;
        if (isTrue(trigger))
        {
            response = await this.privateDeleteStopOrderCancel(this.extend(request, query));
        } else if (isTrue(hf))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                response = await this.privateDeleteHfOrdersCancelAll(this.extend(request, query));
            } else
            {
                response = await this.privateDeleteHfOrders(this.extend(request, query));
            }
        } else
        {
            response = await this.privateDeleteOrders(this.extend(request, query));
        }
        return new List<object> {this.safeOrder(new Dictionary<string, object>() {
    { "info", response },
})};
    }

    /**
     * @method
     * @name kucoin#fetchOrdersByStatus
     * @description fetch a list of orders
     * @see https://docs.kucoin.com/spot#list-orders
     * @see https://docs.kucoin.com/spot#list-stop-orders
     * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-active-hf-orders
     * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-filled-hf-orders
     * @param {string} status *not used for stop orders* 'open' or 'closed'
     * @param {string} symbol unified market symbol
     * @param {int} [since] timestamp in ms of the earliest order
     * @param {int} [limit] max number of orders to return
     * @param {object} [params] exchange specific params
     * @param {int} [params.until] end time in ms
     * @param {string} [params.side] buy or sell
     * @param {string} [params.type] limit, market, limit_stop or market_stop
     * @param {string} [params.tradeType] TRADE for spot trading, MARGIN_TRADE for Margin Trading
     * @param {int} [params.currentPage] *trigger orders only* current page
     * @param {string} [params.orderIds] *trigger orders only* comma seperated order ID list
     * @param {bool} [params.trigger] True if fetching a trigger order
     * @param {bool} [params.hf] false, // true for hf order
     * @returns An [array of order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async virtual Task<object> fetchOrdersByStatus(object status, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object lowercaseStatus = ((string)status).ToLower();
        object until = this.safeInteger(parameters, "until");
        object trigger = this.safeBool2(parameters, "stop", "trigger", false);
        object hf = null;
        var hfparametersVariable = this.handleHfAndParams(parameters);
        hf = ((IList<object>)hfparametersVariable)[0];
        parameters = ((IList<object>)hfparametersVariable)[1];
        if (isTrue(isTrue(hf) && isTrue((isEqual(symbol, null)))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrdersByStatus() requires a symbol parameter for hf orders")) ;
        }
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger", "till", "until"});
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchOrdersByStatus", parameters);
        var marginMode = ((IList<object>) marginModequeryVariable)[0];
        var query = ((IList<object>) marginModequeryVariable)[1];
        if (isTrue(isEqual(lowercaseStatus, "open")))
        {
            lowercaseStatus = "active";
        } else if (isTrue(isEqual(lowercaseStatus, "closed")))
        {
            lowercaseStatus = "done";
        }
        object request = new Dictionary<string, object>() {
            { "status", lowercaseStatus },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startAt"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["pageSize"] = limit;
        }
        if (isTrue(until))
        {
            ((IDictionary<string,object>)request)["endAt"] = until;
        }
        ((IDictionary<string,object>)request)["tradeType"] = this.safeString(getValue(this.options, "marginModes"), marginMode, "TRADE");
        object response = null;
        if (isTrue(trigger))
        {
            response = await this.privateGetStopOrder(this.extend(request, query));
        } else if (isTrue(hf))
        {
            if (isTrue(isEqual(lowercaseStatus, "active")))
            {
                response = await this.privateGetHfOrdersActive(this.extend(request, query));
            } else if (isTrue(isEqual(lowercaseStatus, "done")))
            {
                response = await this.privateGetHfOrdersDone(this.extend(request, query));
            }
        } else
        {
            response = await this.privateGetOrders(this.extend(request, query));
        }
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "currentPage": 1,
        //             "pageSize": 1,
        //             "totalNum": 153408,
        //             "totalPage": 153408,
        //             "items": [
        //                 {
        //                     "id": "5c35c02703aa673ceec2a168",   //orderid
        //                     "symbol": "BTC-USDT",   //symbol
        //                     "opType": "DEAL",      // operation type,deal is pending order,cancel is cancel order
        //                     "type": "limit",       // order type,e.g. limit,markrt,stop_limit.
        //                     "side": "buy",         // transaction direction,include buy and sell
        //                     "price": "10",         // order price
        //                     "size": "2",           // order quantity
        //                     "funds": "0",          // order funds
        //                     "dealFunds": "0.166",  // deal funds
        //                     "dealSize": "2",       // deal quantity
        //                     "fee": "0",            // fee
        //                     "feeCurrency": "USDT", // charge fee currency
        //                     "stp": "",             // self trade prevention,include CN,CO,DC,CB
        //                     "stop": "",            // stop type
        //                     "stopTriggered": false,  // stop order is triggered
        //                     "stopPrice": "0",      // stop price
        //                     "timeInForce": "GTC",  // time InForce,include GTC,GTT,IOC,FOK
        //                     "postOnly": false,     // postOnly
        //                     "hidden": false,       // hidden order
        //                     "iceberg": false,      // iceberg order
        //                     "visibleSize": "0",    // display quantity for iceberg order
        //                     "cancelAfter": 0,      // cancel orders timerequires timeInForce to be GTT
        //                     "channel": "IOS",      // order source
        //                     "clientOid": "",       // user-entered order unique mark
        //                     "remark": "",          // remark
        //                     "tags": "",            // tag order source
        //                     "isActive": false,     // status before unfilled or uncancelled
        //                     "cancelExist": false,   // order cancellation transaction record
        //                     "createdAt": 1547026471000  // time
        //                 },
        //             ]
        //         }
        //    }
        object listData = this.safeList(response, "data");
        if (isTrue(!isEqual(listData, null)))
        {
            return this.parseOrders(listData, market, since, limit);
        }
        object responseData = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeList(responseData, "items", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    /**
     * @method
     * @name kucoin#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://docs.kucoin.com/spot#list-orders
     * @see https://docs.kucoin.com/spot#list-stop-orders
     * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-active-hf-orders
     * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-filled-hf-orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] end time in ms
     * @param {string} [params.side] buy or sell
     * @param {string} [params.type] limit, market, limit_stop or market_stop
     * @param {string} [params.tradeType] TRADE for spot trading, MARGIN_TRADE for Margin Trading
     * @param {bool} [params.trigger] True if fetching a trigger order
     * @param {bool} [params.hf] false, // true for hf order
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchClosedOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchClosedOrders", symbol, since, limit, parameters);
        }
        return await this.fetchOrdersByStatus("done", symbol, since, limit, parameters);
    }

    /**
     * @method
     * @name kucoin#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://docs.kucoin.com/spot#list-orders
     * @see https://docs.kucoin.com/spot#list-stop-orders
     * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-active-hf-orders
     * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-filled-hf-orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of  open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] end time in ms
     * @param {bool} [params.trigger] true if fetching trigger orders
     * @param {string} [params.side] buy or sell
     * @param {string} [params.type] limit, market, limit_stop or market_stop
     * @param {string} [params.tradeType] TRADE for spot trading, MARGIN_TRADE for Margin Trading
     * @param {int} [params.currentPage] *trigger orders only* current page
     * @param {string} [params.orderIds] *trigger orders only* comma seperated order ID list
     * @param {bool} [params.hf] false, // true for hf order
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchOpenOrders", symbol, since, limit, parameters);
        }
        return await this.fetchOrdersByStatus("active", symbol, since, limit, parameters);
    }

    /**
     * @method
     * @name kucoin#fetchOrder
     * @description fetch an order
     * @see https://docs.kucoin.com/spot#get-an-order
     * @see https://docs.kucoin.com/spot#get-single-active-order-by-clientoid
     * @see https://docs.kucoin.com/spot#get-single-order-info
     * @see https://docs.kucoin.com/spot#get-single-order-by-clientoid
     * @see https://docs.kucoin.com/spot-hf/#details-of-a-single-hf-order
     * @see https://docs.kucoin.com/spot-hf/#obtain-details-of-a-single-hf-order-using-clientoid
     * @param {string} id Order id
     * @param {string} symbol not sent to exchange except for trigger orders with clientOid, but used internally by CCXT to filter
     * @param {object} [params] exchange specific parameters
     * @param {bool} [params.trigger] true if fetching a trigger order
     * @param {bool} [params.hf] false, // true for hf order
     * @param {bool} [params.clientOid] unique order id created by users to identify their orders
     * @returns An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId");
        object trigger = this.safeBool2(parameters, "stop", "trigger", false);
        object hf = null;
        var hfparametersVariable = this.handleHfAndParams(parameters);
        hf = ((IList<object>)hfparametersVariable)[0];
        parameters = ((IList<object>)hfparametersVariable)[1];
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        if (isTrue(hf))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol parameter for hf orders")) ;
            }
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        parameters = this.omit(parameters, new List<object>() {"stop", "clientOid", "clientOrderId", "trigger"});
        object response = null;
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
            if (isTrue(trigger))
            {
                if (isTrue(!isEqual(symbol, null)))
                {
                    ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
                }
                response = await this.privateGetStopOrderQueryOrderByClientOid(this.extend(request, parameters));
            } else if (isTrue(hf))
            {
                response = await this.privateGetHfOrdersClientOrderClientOid(this.extend(request, parameters));
            } else
            {
                response = await this.privateGetOrderClientOrderClientOid(this.extend(request, parameters));
            }
        } else
        {
            // a special case for undefined ids
            // otherwise a wrong endpoint for all orders will be triggered
            // https://github.com/ccxt/ccxt/issues/7234
            if (isTrue(isEqual(id, null)))
            {
                throw new InvalidOrder ((string)add(this.id, " fetchOrder() requires an order id")) ;
            }
            ((IDictionary<string,object>)request)["orderId"] = id;
            if (isTrue(trigger))
            {
                response = await this.privateGetStopOrderOrderId(this.extend(request, parameters));
            } else if (isTrue(hf))
            {
                response = await this.privateGetHfOrdersOrderId(this.extend(request, parameters));
            } else
            {
                response = await this.privateGetOrdersOrderId(this.extend(request, parameters));
            }
        }
        object responseData = this.safeDict(response, "data", new Dictionary<string, object>() {});
        if (isTrue(((responseData is IList<object>) || (responseData.GetType().IsGenericType && responseData.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            responseData = this.safeValue(responseData, 0);
        }
        return this.parseOrder(responseData, market);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //
        //    {
        //        "orderId": "63c97e47d686c5000159a656"
        //    }
        //
        // cancelOrder
        //
        //    {
        //        "cancelledOrderIds": [ "63c97e47d686c5000159a656" ]
        //    }
        //
        // fetchOpenOrders, fetchClosedOrders
        //
        //    {
        //        "id": "63c97ce8d686c500015793bb",
        //        "symbol": "USDC-USDT",
        //        "opType": "DEAL",
        //        "type": "limit",
        //        "side": "sell",
        //        "price": "1.05",
        //        "size": "1",
        //        "funds": "0",
        //        "dealFunds": "0",
        //        "dealSize": "0",
        //        "fee": "0",
        //        "feeCurrency": "USDT",
        //        "stp": "",
        //        "stop": "",
        //        "stopTriggered": false,
        //        "stopPrice": "0",
        //        "timeInForce": "GTC",
        //        "postOnly": false,
        //        "hidden": false,
        //        "iceberg": false,
        //        "visibleSize": "0",
        //        "cancelAfter": 0,
        //        "channel": "API",
        //        "clientOid": "d602d73f-5424-4751-bef0-8debce8f0a82",
        //        "remark": null,
        //        "tags": "partner:ccxt",
        //        "isActive": true,
        //        "cancelExist": false,
        //        "createdAt": 1674149096927,
        //        "tradeType": "TRADE"
        //    }
        //
        // stop orders (fetchOpenOrders, fetchClosedOrders)
        //
        //    {
        //        "id": "vs9f6ou9e864rgq8000t4qnm",
        //        "symbol": "USDC-USDT",
        //        "userId": "613a896885d8660006151f01",
        //        "status": "NEW",
        //        "type": "market",
        //        "side": "sell",
        //        "price": null,
        //        "size": "1.00000000000000000000",
        //        "funds": null,
        //        "stp": null,
        //        "timeInForce": "GTC",
        //        "cancelAfter": -1,
        //        "postOnly": false,
        //        "hidden": false,
        //        "iceberg": false,
        //        "visibleSize": null,
        //        "channel": "API",
        //        "clientOid": "5d3fd727-6456-438d-9550-40d9d85eee0b",
        //        "remark": null,
        //        "tags": "partner:ccxt",
        //        "relatedNo": null,
        //        "orderTime": 1674146316994000028,
        //        "domainId": "kucoin",
        //        "tradeSource": "USER",
        //        "tradeType": "MARGIN_TRADE",
        //        "feeCurrency": "USDT",
        //        "takerFeeRate": "0.00100000000000000000",
        //        "makerFeeRate": "0.00100000000000000000",
        //        "createdAt": 1674146316994,
        //        "stop": "loss",
        //        "stopTriggerTime": null,
        //        "stopPrice": "0.97000000000000000000"
        //    }
        // hf order
        //    {
        //        "id":"6478cf1439bdfc0001528a1d",
        //        "symbol":"LTC-USDT",
        //        "opType":"DEAL",
        //        "type":"limit",
        //        "side":"buy",
        //        "price":"50",
        //        "size":"0.1",
        //        "funds":"5",
        //        "dealSize":"0",
        //        "dealFunds":"0",
        //        "fee":"0",
        //        "feeCurrency":"USDT",
        //        "stp":null,
        //        "timeInForce":"GTC",
        //        "postOnly":false,
        //        "hidden":false,
        //        "iceberg":false,
        //        "visibleSize":"0",
        //        "cancelAfter":0,
        //        "channel":"API",
        //        "clientOid":"d4d2016b-8e3a-445c-aa5d-dc6df5d1678d",
        //        "remark":null,
        //        "tags":"partner:ccxt",
        //        "cancelExist":false,
        //        "createdAt":1685638932074,
        //        "lastUpdatedAt":1685639013735,
        //        "tradeType":"TRADE",
        //        "inOrderBook":true,
        //        "cancelledSize":"0",
        //        "cancelledFunds":"0",
        //        "remainSize":"0.1",
        //        "remainFunds":"5",
        //        "active":true
        //    }
        //
        object marketId = this.safeString(order, "symbol");
        object timestamp = this.safeInteger(order, "createdAt");
        object feeCurrencyId = this.safeString(order, "feeCurrency");
        object cancelExist = this.safeBool(order, "cancelExist", false);
        object responseStop = this.safeString(order, "stop");
        object trigger = !isEqual(responseStop, null);
        object stopTriggered = this.safeBool(order, "stopTriggered", false);
        object isActive = this.safeBool2(order, "isActive", "active");
        object responseStatus = this.safeString(order, "status");
        object status = null;
        if (isTrue(!isEqual(isActive, null)))
        {
            if (isTrue(isEqual(isActive, true)))
            {
                status = "open";
            } else
            {
                status = "closed";
            }
        }
        if (isTrue(trigger))
        {
            if (isTrue(isEqual(responseStatus, "NEW")))
            {
                status = "open";
            } else if (isTrue(!isTrue(isActive) && !isTrue(stopTriggered)))
            {
                status = "cancelled";
            }
        }
        if (isTrue(cancelExist))
        {
            status = "canceled";
        }
        if (isTrue(isEqual(responseStatus, "fail")))
        {
            status = "rejected";
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeStringN(order, new List<object>() {"id", "orderId", "newOrderId", "cancelledOrderId"}) },
            { "clientOrderId", this.safeString(order, "clientOid") },
            { "symbol", this.safeSymbol(marketId, market, "-") },
            { "type", this.safeString(order, "type") },
            { "timeInForce", this.safeString(order, "timeInForce") },
            { "postOnly", this.safeBool(order, "postOnly") },
            { "side", this.safeString(order, "side") },
            { "amount", this.safeString(order, "size") },
            { "price", this.safeString(order, "price") },
            { "triggerPrice", this.safeNumber(order, "stopPrice") },
            { "cost", this.safeString(order, "dealFunds") },
            { "filled", this.safeString(order, "dealSize") },
            { "remaining", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fee", new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(feeCurrencyId) },
                { "cost", this.safeNumber(order, "fee") },
            } },
            { "status", status },
            { "lastTradeTimestamp", null },
            { "average", this.safeString(order, "avgDealPrice") },
            { "trades", null },
        }, market);
    }

    /**
     * @method
     * @name kucoin#fetchOrderTrades
     * @description fetch all the trades made from a single order
     * @see https://docs.kucoin.com/#list-fills
     * @see https://docs.kucoin.com/spot-hf/#transaction-details
     * @param {string} id order id
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
     */
    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        return await this.fetchMyTrades(symbol, since, limit, this.extend(request, parameters));
    }

    /**
     * @method
     * @name kucoin#fetchMyTrades
     * @see https://docs.kucoin.com/#list-fills
     * @see https://docs.kucoin.com/spot-hf/#transaction-details
     * @description fetch all trades made by the user
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {bool} [params.hf] false, // true for hf order
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        object hf = null;
        var hfparametersVariable = this.handleHfAndParams(parameters);
        hf = ((IList<object>)hfparametersVariable)[0];
        parameters = ((IList<object>)hfparametersVariable)[1];
        if (isTrue(isTrue(hf) && isTrue(isEqual(symbol, null))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol parameter for hf orders")) ;
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object method = getValue(this.options, "fetchMyTradesMethod");
        object parseResponseData = false;
        object response = null;
        var requestparametersVariable = this.handleUntilOption("endAt", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(hf))
        {
            // does not return trades earlier than 2019-02-18T00:00:00Z
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            if (isTrue(!isEqual(since, null)))
            {
                // only returns trades up to one week after the since param
                ((IDictionary<string,object>)request)["startAt"] = since;
            }
            response = await this.privateGetHfFills(this.extend(request, parameters));
        } else if (isTrue(isEqual(method, "private_get_fills")))
        {
            // does not return trades earlier than 2019-02-18T00:00:00Z
            if (isTrue(!isEqual(since, null)))
            {
                // only returns trades up to one week after the since param
                ((IDictionary<string,object>)request)["startAt"] = since;
            }
            response = await this.privateGetFills(this.extend(request, parameters));
        } else if (isTrue(isEqual(method, "private_get_limit_fills")))
        {
            // does not return trades earlier than 2019-02-18T00:00:00Z
            // takes no params
            // only returns first 1000 trades (not only "in the last 24 hours" as stated in the docs)
            parseResponseData = true;
            response = await this.privateGetLimitFills(this.extend(request, parameters));
        } else
        {
            throw new ExchangeError ((string)add(this.id, " fetchMyTradesMethod() invalid method")) ;
        }
        //
        //     {
        //         "currentPage": 1,
        //         "pageSize": 50,
        //         "totalNum": 1,
        //         "totalPage": 1,
        //         "items": [
        //             {
        //                 "symbol":"BTC-USDT",       // symbol
        //                 "tradeId":"5c35c02709e4f67d5266954e",        // trade id
        //                 "orderId":"5c35c02703aa673ceec2a168",        // order id
        //                 "counterOrderId":"5c1ab46003aa676e487fa8e3", // counter order id
        //                 "side":"buy",              // transaction direction,include buy and sell
        //                 "liquidity":"taker",       // include taker and maker
        //                 "forceTaker":true,         // forced to become taker
        //                 "price":"0.083",           // order price
        //                 "size":"0.8424304",        // order quantity
        //                 "funds":"0.0699217232",    // order funds
        //                 "fee":"0",                 // fee
        //                 "feeRate":"0",             // fee rate
        //                 "feeCurrency":"USDT",      // charge fee currency
        //                 "stop":"",                 // stop type
        //                 "type":"limit",            // order type, e.g. limit, market, stop_limit.
        //                 "createdAt":1547026472000  // time
        //             },
        //             //------------------------------------------------------
        //             // v1 (historical) trade response structure
        //             {
        //                 "symbol": "SNOV-ETH",
        //                 "dealPrice": "0.0000246",
        //                 "dealValue": "0.018942",
        //                 "amount": "770",
        //                 "fee": "0.00001137",
        //                 "side": "sell",
        //                 "createdAt": 1540080199
        //                 "id":"5c4d389e4c8c60413f78e2e5",
        //             }
        //         ]
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object trades = null;
        if (isTrue(parseResponseData))
        {
            trades = data;
        } else
        {
            trades = this.safeList(data, "items", new List<object>() {});
        }
        return this.parseTrades(trades, market, since, limit);
    }

    /**
     * @method
     * @name kucoin#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://www.kucoin.com/docs/rest/spot-trading/market-data/get-trade-histories
     * @see https://www.kucoin.com/docs-new/rest/ua/get-trades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        // pagination is not supported on the exchange side anymore
        // if (since !== undefined) {
        //     request['startAt'] = Math.floor (since / 1000);
        // }
        // if (limit !== undefined) {
        //     request['pageSize'] = limit;
        // }
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchTrades", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        object response = null;
        object trades = null;
        if (isTrue(uta))
        {
            object type = null;
            var typeparametersVariable = this.handleMarketTypeAndParams("fetchTrades", market, parameters);
            type = ((IList<object>)typeparametersVariable)[0];
            parameters = ((IList<object>)typeparametersVariable)[1];
            if (isTrue(isEqual(type, "spot")))
            {
                ((IDictionary<string,object>)request)["tradeType"] = "SPOT";
            } else
            {
                ((IDictionary<string,object>)request)["tradeType"] = "FUTURES";
            }
            response = await this.utaGetMarketTrade(this.extend(request, parameters));
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //             "tradeType": "SPOT",
            //             "list": [
            //                 {
            //                     "sequence": "18746044393340932",
            //                     "tradeId": "18746044393340932",
            //                     "price": "104355.6",
            //                     "size": "0.00011886",
            //                     "side": "sell",
            //                     "ts": 1762242540829000000
            //                 },
            //             ]
            //         }
            //     }
            //
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            trades = this.safeList(data, "list", new List<object>() {});
        } else
        {
            response = await this.publicGetMarketHistories(this.extend(request, parameters));
            //
            //     {
            //         "code": "200000",
            //         "data": [
            //             {
            //                 "sequence": "1548764654235",
            //                 "side": "sell",
            //                 "size":"0.6841354",
            //                 "price":"0.03202",
            //                 "time":1548848575203567174
            //             }
            //         ]
            //     }
            //
            trades = this.safeList(response, "data", new List<object>() {});
        }
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //     {
        //         "sequence": "1548764654235",
        //         "side": "sell",
        //         "size":"0.6841354",
        //         "price":"0.03202",
        //         "time":1548848575203567174
        //     }
        //
        //     {
        //         "sequence": "1568787654360",
        //         "symbol": "BTC-USDT",
        //         "side": "buy",
        //         "size": "0.00536577",
        //         "price": "9345",
        //         "takerOrderId": "5e356c4a9f1a790008f8d921",
        //         "time": "1580559434436443257",
        //         "type": "match",
        //         "makerOrderId": "5e356bffedf0010008fa5d7f",
        //         "tradeId": "5e356c4aeefabd62c62a1ece"
        //     }
        //
        // fetchMyTrades (private) v2
        //
        //     {
        //         "symbol":"BTC-USDT",
        //         "tradeId":"5c35c02709e4f67d5266954e",
        //         "orderId":"5c35c02703aa673ceec2a168",
        //         "counterOrderId":"5c1ab46003aa676e487fa8e3",
        //         "side":"buy",
        //         "liquidity":"taker",
        //         "forceTaker":true,
        //         "price":"0.083",
        //         "size":"0.8424304",
        //         "funds":"0.0699217232",
        //         "fee":"0",
        //         "feeRate":"0",
        //         "feeCurrency":"USDT",
        //         "stop":"",
        //         "type":"limit",
        //         "createdAt":1547026472000
        //     }
        //
        // fetchMyTrades v2 alternative format since 2019-05-21 https://github.com/ccxt/ccxt/pull/5162
        //
        //     {
        //         "symbol": "OPEN-BTC",
        //         "forceTaker":  false,
        //         "orderId": "5ce36420054b4663b1fff2c9",
        //         "fee": "0",
        //         "feeCurrency": "",
        //         "type": "",
        //         "feeRate": "0",
        //         "createdAt": 1558417615000,
        //         "size": "12.8206",
        //         "stop": "",
        //         "price": "0",
        //         "funds": "0",
        //         "tradeId": "5ce390cf6e0db23b861c6e80"
        //     }
        //
        // fetchMyTrades (private) v1 (historical)
        //
        //     {
        //         "symbol": "SNOV-ETH",
        //         "dealPrice": "0.0000246",
        //         "dealValue": "0.018942",
        //         "amount": "770",
        //         "fee": "0.00001137",
        //         "side": "sell",
        //         "createdAt": 1540080199
        //         "id":"5c4d389e4c8c60413f78e2e5",
        //     }
        //
        // uta fetchTrades
        //
        //     {
        //         "sequence": "18746044393340932",
        //         "tradeId": "18746044393340932",
        //         "price": "104355.6",
        //         "size": "0.00011886",
        //         "side": "sell",
        //         "ts": 1762242540829000000
        //     }
        //
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market, "-");
        object id = this.safeString2(trade, "tradeId", "id");
        object orderId = this.safeString(trade, "orderId");
        object takerOrMaker = this.safeString(trade, "liquidity");
        object timestamp = this.safeInteger2(trade, "time", "ts");
        if (isTrue(!isEqual(timestamp, null)))
        {
            timestamp = this.parseToInt(divide(timestamp, 1000000));
        } else
        {
            timestamp = this.safeInteger(trade, "createdAt");
            // if it's a historical v1 trade, the exchange returns timestamp in seconds
            if (isTrue(isTrue((inOp(trade, "dealValue"))) && isTrue((!isEqual(timestamp, null)))))
            {
                timestamp = multiply(timestamp, 1000);
            }
        }
        object priceString = this.safeString2(trade, "price", "dealPrice");
        object amountString = this.safeString2(trade, "size", "amount");
        object side = this.safeString(trade, "side");
        object fee = null;
        object feeCostString = this.safeString(trade, "fee");
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCurrencyId = this.safeString(trade, "feeCurrency");
            object feeCurrency = this.safeCurrencyCode(feeCurrencyId);
            if (isTrue(isEqual(feeCurrency, null)))
            {
                feeCurrency = ((bool) isTrue((isEqual(side, "sell")))) ? getValue(market, "quote") : getValue(market, "base");
            }
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", feeCurrency },
                { "rate", this.safeString(trade, "feeRate") },
            };
        }
        object type = this.safeString(trade, "type");
        if (isTrue(isEqual(type, "match")))
        {
            type = null;
        }
        object costString = this.safeString2(trade, "funds", "dealValue");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "order", orderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "takerOrMaker", takerOrMaker },
            { "side", side },
            { "price", priceString },
            { "amount", amountString },
            { "cost", costString },
            { "fee", fee },
        }, market);
    }

    /**
     * @method
     * @name kucoin#fetchTradingFee
     * @description fetch the trading fees for a market
     * @see https://www.kucoin.com/docs/rest/funding/trade-fee/trading-pair-actual-fee-spot-margin-trade_hf
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/?id=fee-structure}
     */
    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbols", getValue(market, "id") },
        };
        object response = await this.privateGetTradeFees(this.extend(request, parameters));
        //
        //     {
        //         "code": "200000",
        //         "data": [
        //           {
        //             "symbol": "BTC-USDT",
        //             "takerFeeRate": "0.001",
        //             "makerFeeRate": "0.001"
        //           }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0);
        object marketId = this.safeString(first, "symbol");
        return new Dictionary<string, object>() {
            { "info", response },
            { "symbol", this.safeSymbol(marketId, market) },
            { "maker", this.safeNumber(first, "makerFeeRate") },
            { "taker", this.safeNumber(first, "takerFeeRate") },
            { "percentage", true },
            { "tierBased", true },
        };
    }

    /**
     * @method
     * @name kucoin#withdraw
     * @description make a withdrawal
     * @see https://www.kucoin.com/docs/rest/funding/withdrawals/apply-withdraw-v3-
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        this.checkAddress(address);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "toAddress", address },
            { "withdrawType", "ADDRESS" },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["memo"] = tag;
        }
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["chain"] = ((string)this.networkCodeToId(networkCode)).ToLower();
        }
        ((IDictionary<string,object>)request)["amount"] = parseFloat(this.currencyToPrecision(code, amount, networkCode));
        object includeFee = null;
        var includeFeeparametersVariable = this.handleOptionAndParams(parameters, "withdraw", "includeFee", false);
        includeFee = ((IList<object>)includeFeeparametersVariable)[0];
        parameters = ((IList<object>)includeFeeparametersVariable)[1];
        if (isTrue(includeFee))
        {
            ((IDictionary<string,object>)request)["feeDeductType"] = "INTERNAL";
        }
        object response = await this.privatePostWithdrawals(this.extend(request, parameters));
        //
        // the id is inside "data"
        //
        //     {
        //         "code":  200000,
        //         "data": {
        //             "withdrawalId":  "5bffb63303aa675e8bbe18f9"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTransaction(data, currency);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "SUCCESS", "ok" },
            { "PROCESSING", "pending" },
            { "WALLET_PROCESSING", "pending" },
            { "FAILURE", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //     {
        //         "address": "0x5f047b29041bcfdbf0e4478cdfa753a336ba6989",
        //         "memo": "5c247c8a03aa677cea2a251d",
        //         "amount": 1,
        //         "fee": 0.0001,
        //         "currency": "KCS",
        //         "chain": "",
        //         "isInner": false,
        //         "walletTxId": "5bbb57386d99522d9f954c5a@test004",
        //         "status": "SUCCESS",
        //         "createdAt": 1544178843000,
        //         "updatedAt": 1544178891000
        //         "remark":"foobar"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "id": "5c2dc64e03aa675aa263f1ac",
        //         "address": "0x5bedb060b8eb8d823e2414d82acce78d38be7fe9",
        //         "memo": "",
        //         "currency": "ETH",
        //         "chain": "",
        //         "amount": 1.0000000,
        //         "fee": 0.0100000,
        //         "walletTxId": "3e2414d82acce78d38be7fe9",
        //         "isInner": false,
        //         "status": "FAILURE",
        //         "createdAt": 1546503758000,
        //         "updatedAt": 1546504603000
        //         "remark":"foobar"
        //     }
        //
        // withdraw
        //
        //     {
        //         "withdrawalId":  "5bffb63303aa675e8bbe18f9"
        //     }
        //
        object currencyId = this.safeString(transaction, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object address = this.safeString(transaction, "address");
        object amount = this.safeString(transaction, "amount");
        object txid = this.safeString(transaction, "walletTxId");
        if (isTrue(!isEqual(txid, null)))
        {
            object txidParts = ((string)txid).Split(new [] {((string)"@")}, StringSplitOptions.None).ToList<object>();
            object numTxidParts = getArrayLength(txidParts);
            if (isTrue(isGreaterThan(numTxidParts, 1)))
            {
                if (isTrue(isEqual(address, null)))
                {
                    if (isTrue(isGreaterThan(((string)getValue(txidParts, 1)).Length, 1)))
                    {
                        address = getValue(txidParts, 1);
                    }
                }
            }
            txid = getValue(txidParts, 0);
        }
        object type = ((bool) isTrue((isEqual(txid, null)))) ? "withdrawal" : "deposit";
        object rawStatus = this.safeString(transaction, "status");
        object fee = null;
        object feeCost = this.safeString(transaction, "fee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            object rate = null;
            if (isTrue(!isEqual(amount, null)))
            {
                rate = Precise.stringDiv(feeCost, amount);
            }
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(feeCost) },
                { "rate", this.parseNumber(rate) },
                { "currency", code },
            };
        }
        object timestamp = this.safeInteger2(transaction, "createdAt", "createAt");
        object updated = this.safeInteger(transaction, "updatedAt");
        object isV1 = !isTrue((inOp(transaction, "createdAt")));
        // if it's a v1 structure
        if (isTrue(isV1))
        {
            type = ((bool) isTrue((inOp(transaction, "address")))) ? "withdrawal" : "deposit";
            if (isTrue(!isEqual(timestamp, null)))
            {
                timestamp = multiply(timestamp, 1000);
            }
            if (isTrue(!isEqual(updated, null)))
            {
                updated = multiply(updated, 1000);
            }
        }
        object intern = this.safeBool(transaction, "isInner");
        object tag = this.safeString(transaction, "memo");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString2(transaction, "id", "withdrawalId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", this.networkIdToCode(this.safeString(transaction, "chain")) },
            { "address", address },
            { "addressTo", address },
            { "addressFrom", null },
            { "tag", tag },
            { "tagTo", tag },
            { "tagFrom", null },
            { "currency", code },
            { "amount", this.parseNumber(amount) },
            { "txid", txid },
            { "type", type },
            { "status", this.parseTransactionStatus(rawStatus) },
            { "comment", this.safeString(transaction, "remark") },
            { "internal", intern },
            { "fee", fee },
            { "updated", updated },
        };
    }

    /**
     * @method
     * @name kucoin#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://www.kucoin.com/docs/rest/funding/deposit/get-deposit-list
     * @see https://www.kucoin.com/docs/rest/funding/deposit/get-v1-historical-deposits-list
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchDeposits", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchDeposits", code, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["pageSize"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("endAt", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = null;
        if (isTrue(isTrue(!isEqual(since, null)) && isTrue(isLessThan(since, 1550448000000))))
        {
            // if since is earlier than 2019-02-18T00:00:00Z
            ((IDictionary<string,object>)request)["startAt"] = this.parseToInt(divide(since, 1000));
            response = await this.privateGetHistDeposits(this.extend(request, parameters));
        } else
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["startAt"] = since;
            }
            response = await this.privateGetDeposits(this.extend(request, parameters));
        }
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "currentPage": 1,
        //             "pageSize": 5,
        //             "totalNum": 2,
        //             "totalPage": 1,
        //             "items": [
        //                 //--------------------------------------------------
        //                 // version 2 deposit response structure
        //                 {
        //                     "address": "0x5f047b29041bcfdbf0e4478cdfa753a336ba6989",
        //                     "memo": "5c247c8a03aa677cea2a251d",
        //                     "amount": 1,
        //                     "fee": 0.0001,
        //                     "currency": "KCS",
        //                     "isInner": false,
        //                     "walletTxId": "5bbb57386d99522d9f954c5a@test004",
        //                     "status": "SUCCESS",
        //                     "createdAt": 1544178843000,
        //                     "updatedAt": 1544178891000
        //                     "remark":"foobar"
        //                 },
        //                 //--------------------------------------------------
        //                 // version 1 (historical) deposit response structure
        //                 {
        //                     "currency": "BTC",
        //                     "createAt": 1528536998,
        //                     "amount": "0.03266638",
        //                     "walletTxId": "55c643bc2c68d6f17266383ac1be9e454038864b929ae7cee0bc408cc5c869e8@12ffGWmMMD1zA1WbFm7Ho3JZ1w6NYXjpFk@234",
        //                     "isInner": false,
        //                     "status": "SUCCESS",
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object items = this.safeList(data, "items", new List<object>() {});
        return this.parseTransactions(items, currency, since, limit, new Dictionary<string, object>() {
            { "type", "deposit" },
        });
    }

    /**
     * @method
     * @name kucoin#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://www.kucoin.com/docs/rest/funding/withdrawals/get-withdrawals-list
     * @see https://www.kucoin.com/docs/rest/funding/withdrawals/get-v1-historical-withdrawals-list
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchWithdrawals", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchWithdrawals", code, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["pageSize"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("endAt", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = null;
        if (isTrue(isTrue(!isEqual(since, null)) && isTrue(isLessThan(since, 1550448000000))))
        {
            // if since is earlier than 2019-02-18T00:00:00Z
            ((IDictionary<string,object>)request)["startAt"] = this.parseToInt(divide(since, 1000));
            response = await this.privateGetHistWithdrawals(this.extend(request, parameters));
        } else
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["startAt"] = since;
            }
            response = await this.privateGetWithdrawals(this.extend(request, parameters));
        }
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "currentPage": 1,
        //             "pageSize": 5,
        //             "totalNum": 2,
        //             "totalPage": 1,
        //             "items": [
        //                 //--------------------------------------------------
        //                 // version 2 withdrawal response structure
        //                 {
        //                     "id": "5c2dc64e03aa675aa263f1ac",
        //                     "address": "0x5bedb060b8eb8d823e2414d82acce78d38be7fe9",
        //                     "memo": "",
        //                     "currency": "ETH",
        //                     "amount": 1.0000000,
        //                     "fee": 0.0100000,
        //                     "walletTxId": "3e2414d82acce78d38be7fe9",
        //                     "isInner": false,
        //                     "status": "FAILURE",
        //                     "createdAt": 1546503758000,
        //                     "updatedAt": 1546504603000
        //                 },
        //                 //--------------------------------------------------
        //                 // version 1 (historical) withdrawal response structure
        //                 {
        //                     "currency": "BTC",
        //                     "createAt": 1526723468,
        //                     "amount": "0.534",
        //                     "address": "33xW37ZSW4tQvg443Pc7NLCAs167Yc2XUV",
        //                     "walletTxId": "aeacea864c020acf58e51606169240e96774838dcd4f7ce48acf38e3651323f4",
        //                     "isInner": false,
        //                     "status": "SUCCESS"
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object items = this.safeList(data, "items", new List<object>() {});
        return this.parseTransactions(items, currency, since, limit, new Dictionary<string, object>() {
            { "type", "withdrawal" },
        });
    }

    public virtual object parseBalanceHelper(object entry)
    {
        object account = this.account();
        ((IDictionary<string,object>)account)["used"] = this.safeString2(entry, "holdBalance", "hold");
        ((IDictionary<string,object>)account)["free"] = this.safeString2(entry, "availableBalance", "available");
        ((IDictionary<string,object>)account)["total"] = this.safeString2(entry, "totalBalance", "total");
        object debt = this.safeString(entry, "liability");
        object interest = this.safeString(entry, "interest");
        ((IDictionary<string,object>)account)["debt"] = Precise.stringAdd(debt, interest);
        return account;
    }

    /**
     * @method
     * @name kucoin#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://www.kucoin.com/docs/rest/account/basic-info/get-account-list-spot-margin-trade_hf
     * @see https://www.kucoin.com/docs/rest/funding/funding-overview/get-account-detail-margin
     * @see https://www.kucoin.com/docs/rest/funding/funding-overview/get-account-detail-isolated-margin
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {object} [params.marginMode] 'cross' or 'isolated', margin type for fetching margin balance
     * @param {object} [params.type] extra parameters specific to the exchange API endpoint
     * @param {object} [params.hf] *default if false* if true, the result includes the balance of the high frequency account
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object code = this.safeString(parameters, "code");
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object defaultType = this.safeString2(this.options, "fetchBalance", "defaultType", "spot");
        object requestedType = this.safeString(parameters, "type", defaultType);
        object accountsByType = this.safeDict(this.options, "accountsByType");
        object type = this.safeString(accountsByType, requestedType, requestedType);
        parameters = this.omit(parameters, "type");
        object hf = null;
        var hfparametersVariable = this.handleHfAndParams(parameters);
        hf = ((IList<object>)hfparametersVariable)[0];
        parameters = ((IList<object>)hfparametersVariable)[1];
        if (isTrue(isTrue(hf) && isTrue((!isEqual(type, "main")))))
        {
            type = "trade_hf";
        }
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchBalance", parameters);
        var marginMode = ((IList<object>) marginModequeryVariable)[0];
        var query = ((IList<object>) marginModequeryVariable)[1];
        object response = null;
        object request = new Dictionary<string, object>() {};
        object isolated = isTrue((isEqual(marginMode, "isolated"))) || isTrue((isEqual(type, "isolated")));
        object cross = isTrue((isEqual(marginMode, "cross"))) || isTrue((isEqual(type, "margin")));
        if (isTrue(isolated))
        {
            if (isTrue(!isEqual(currency, null)))
            {
                ((IDictionary<string,object>)request)["balanceCurrency"] = getValue(currency, "id");
            }
            response = await this.privateGetIsolatedAccounts(this.extend(request, query));
        } else if (isTrue(cross))
        {
            response = await this.privateGetMarginAccount(this.extend(request, query));
        } else
        {
            if (isTrue(!isEqual(currency, null)))
            {
                ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
            }
            ((IDictionary<string,object>)request)["type"] = type;
            response = await this.privateGetAccounts(this.extend(request, query));
        }
        //
        // Spot
        //
        //    {
        //        "code": "200000",
        //        "data": [
        //            {
        //                "balance": "0.00009788",
        //                "available": "0.00009788",
        //                "holds": "0",
        //                "currency": "BTC",
        //                "id": "5c6a4fd399a1d81c4f9cc4d0",
        //                "type": "trade",
        //            },
        //        ]
        //    }
        //
        // Cross
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "debtRatio": "0",
        //             "accounts": [
        //                 {
        //                     "currency": "USDT",
        //                     "totalBalance": "5",
        //                     "availableBalance": "5",
        //                     "holdBalance": "0",
        //                     "liability": "0",
        //                     "maxBorrowSize": "20"
        //                 },
        //             ]
        //         }
        //     }
        //
        // Isolated
        //
        //    {
        //        "code": "200000",
        //        "data": {
        //            "totalAssetOfQuoteCurrency": "0",
        //            "totalLiabilityOfQuoteCurrency": "0",
        //            "timestamp": 1712085661155,
        //            "assets": [
        //                {
        //                    "symbol": "MANA-USDT",
        //                    "status": "EFFECTIVE",
        //                    "debtRatio": "0",
        //                    "baseAsset": {
        //                        "currency": "MANA",
        //                        "borrowEnabled": true,
        //                        "transferInEnabled": true,
        //                        "total": "0",
        //                        "hold": "0",
        //                        "available": "0",
        //                        "liability": "0",
        //                        "interest": "0",
        //                        "maxBorrowSize": "0"
        //                    },
        //                    "quoteAsset": {
        //                        "currency": "USDT",
        //                        "borrowEnabled": true,
        //                        "transferInEnabled": true,
        //                        "total": "0",
        //                        "hold": "0",
        //                        "available": "0",
        //                        "liability": "0",
        //                        "interest": "0",
        //                        "maxBorrowSize": "0"
        //                    }
        //                },
        //                ...
        //            ]
        //        }
        //    }
        //
        object data = null;
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        if (isTrue(isolated))
        {
            data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            object assets = this.safeValue(data, "assets", data);
            for (object i = 0; isLessThan(i, getArrayLength(assets)); postFixIncrement(ref i))
            {
                object entry = getValue(assets, i);
                object marketId = this.safeString(entry, "symbol");
                object symbol = this.safeSymbol(marketId, null, "_");
                object bs = this.safeDict(entry, "baseAsset", new Dictionary<string, object>() {});
                object quote = this.safeDict(entry, "quoteAsset", new Dictionary<string, object>() {});
                object baseCode = this.safeCurrencyCode(this.safeString(bs, "currency"));
                object quoteCode = this.safeCurrencyCode(this.safeString(quote, "currency"));
                object subResult = new Dictionary<string, object>() {};
                ((IDictionary<string,object>)subResult)[(string)baseCode] = this.parseBalanceHelper(bs);
                ((IDictionary<string,object>)subResult)[(string)quoteCode] = this.parseBalanceHelper(quote);
                ((IDictionary<string,object>)result)[(string)symbol] = this.safeBalance(subResult);
            }
        } else if (isTrue(cross))
        {
            data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            object accounts = this.safeList(data, "accounts", new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(accounts)); postFixIncrement(ref i))
            {
                object balance = getValue(accounts, i);
                object currencyId = this.safeString(balance, "currency");
                object codeInner = this.safeCurrencyCode(currencyId);
                ((IDictionary<string,object>)result)[(string)codeInner] = this.parseBalanceHelper(balance);
            }
        } else
        {
            data = this.safeList(response, "data", new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object balance = getValue(data, i);
                object balanceType = this.safeString(balance, "type");
                if (isTrue(isEqual(balanceType, type)))
                {
                    object currencyId = this.safeString(balance, "currency");
                    object codeInner2 = this.safeCurrencyCode(currencyId);
                    object account = this.account();
                    ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "balance");
                    ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "available");
                    ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "holds");
                    ((IDictionary<string,object>)result)[(string)codeInner2] = account;
                }
            }
        }
        object returnType = result;
        if (!isTrue(isolated))
        {
            returnType = this.safeBalance(result);
        }
        return returnType;
    }

    /**
     * @method
     * @name kucoin#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://www.kucoin.com/docs-new/rest/account-info/transfer/flex-transfer?lang=en_US&
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account to transfer from
     * @param {string} toAccount account to transfer to
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.transferType] INTERNAL, PARENT_TO_SUB, SUB_TO_PARENT (default is INTERNAL)
     * @param {string} [params.fromUserId] required if transferType is SUB_TO_PARENT
     * @param {string} [params.toUserId] required if transferType is PARENT_TO_SUB
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object requestedAmount = this.currencyToPrecision(code, amount);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", requestedAmount },
        };
        object transferType = "INTERNAL";
        var transferTypeparametersVariable = this.handleParamString2(parameters, "transferType", "type", transferType);
        transferType = ((IList<object>)transferTypeparametersVariable)[0];
        parameters = ((IList<object>)transferTypeparametersVariable)[1];
        if (isTrue(isEqual(transferType, "PARENT_TO_SUB")))
        {
            if (!isTrue((inOp(parameters, "toUserId"))))
            {
                throw new ExchangeError ((string)add(this.id, " transfer() requires a toUserId param for PARENT_TO_SUB transfers")) ;
            }
        } else if (isTrue(isEqual(transferType, "SUB_TO_PARENT")))
        {
            if (!isTrue((inOp(parameters, "fromUserId"))))
            {
                throw new ExchangeError ((string)add(this.id, " transfer() requires a fromUserId param for SUB_TO_PARENT transfers")) ;
            }
        }
        if (!isTrue((inOp(parameters, "clientOid"))))
        {
            ((IDictionary<string,object>)request)["clientOid"] = this.uuid();
        }
        object fromId = this.convertTypeToAccount(fromAccount);
        object toId = this.convertTypeToAccount(toAccount);
        object fromIsolated = this.inArray(fromId, this.ids);
        object toIsolated = this.inArray(toId, this.ids);
        if (isTrue(fromIsolated))
        {
            ((IDictionary<string,object>)request)["fromAccountTag"] = fromId;
            fromId = "isolated";
        }
        if (isTrue(toIsolated))
        {
            ((IDictionary<string,object>)request)["toAccountTag"] = toId;
            toId = "isolated";
        }
        object hfOrMining = this.isHfOrMining(fromId, toId);
        object response = null;
        if (isTrue(hfOrMining))
        {
            // new endpoint does not support hf and mining transfers
            // use old endpoint for hf and mining transfers
            ((IDictionary<string,object>)request)["from"] = fromId;
            ((IDictionary<string,object>)request)["to"] = toId;
            response = await this.privatePostAccountsInnerTransfer(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["type"] = transferType;
            ((IDictionary<string,object>)request)["fromAccountType"] = ((string)fromId).ToUpper();
            ((IDictionary<string,object>)request)["toAccountType"] = ((string)toId).ToUpper();
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //             "orderId": "694fcb5b08bb1600015cda75"
            //         }
            //     }
            //
            response = await this.privatePostAccountsUniversalTransfer(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data");
        object transfer = this.parseTransfer(data, currency);
        object transferOptions = this.safeDict(this.options, "transfer", new Dictionary<string, object>() {});
        object fillResponseFromRequest = this.safeBool(transferOptions, "fillResponseFromRequest", true);
        if (isTrue(fillResponseFromRequest))
        {
            ((IDictionary<string,object>)transfer)["amount"] = amount;
            ((IDictionary<string,object>)transfer)["fromAccount"] = fromAccount;
            ((IDictionary<string,object>)transfer)["toAccount"] = toAccount;
            ((IDictionary<string,object>)transfer)["status"] = "ok";
        }
        return transfer;
    }

    public virtual object isHfOrMining(object fromId, object toId)
    {
        return (isTrue(isTrue(isTrue(isEqual(fromId, "trade_hf")) || isTrue(isEqual(toId, "trade_hf"))) || isTrue(isEqual(fromId, "pool"))) || isTrue(isEqual(toId, "pool")));
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer (spot)
        //
        //    {
        //        "orderId": "605a6211e657f00006ad0ad6"
        //    }
        //
        //    {
        //        "code": "200000",
        //        "msg": "Failed to transfer out. The amount exceeds the upper limit"
        //    }
        //
        // transfer (futures)
        //
        //     {
        //         "applyId": "605a87217dff1500063d485d",
        //         "bizNo": "bcd6e5e1291f4905af84dc",
        //         "payAccountType": "CONTRACT",
        //         "payTag": "DEFAULT",
        //         "remark": '',
        //         "recAccountType": "MAIN",
        //         "recTag": "DEFAULT",
        //         "recRemark": '',
        //         "recSystem": "KUCOIN",
        //         "status": "PROCESSING",
        //         "currency": "XBT",
        //         "amount": "0.00001",
        //         "fee": "0",
        //         "sn": "573688685663948",
        //         "reason": '',
        //         "createdAt": 1616545569000,
        //         "updatedAt": 1616545569000
        //     }
        //
        // ledger entry - from account ledgers API (for fetchTransfers)
        //
        // {
        //     "id": "611a1e7c6a053300067a88d9",
        //     "currency": "USDT",
        //     "amount": "10.00059547",
        //     "fee": "0",
        //     "balance": "0",
        //     "accountType": "MAIN",
        //     "bizType": "Transfer",
        //     "direction": "in",
        //     "createdAt": 1629101692950,
        //     "context": "{\"orderId\":\"611a1e7c6a053300067a88d9\"}"
        // }
        //
        object timestamp = this.safeInteger(transfer, "createdAt");
        object currencyId = this.safeString(transfer, "currency");
        object rawStatus = this.safeString(transfer, "status");
        object bizType = this.safeString(transfer, "bizType");
        object isLedgerEntry = (!isEqual(bizType, null));
        object accountFromRaw = null;
        object accountToRaw = null;
        if (isTrue(isLedgerEntry))
        {
            // Ledger entry format: uses accountType + direction
            object accountType = this.safeStringLower(transfer, "accountType");
            object direction = this.safeString(transfer, "direction");
            if (isTrue(isEqual(direction, "out")))
            {
                accountFromRaw = accountType;
            } else if (isTrue(isEqual(direction, "in")))
            {
                accountToRaw = accountType;
            }
        } else
        {
            // Transfer API format: uses payAccountType/recAccountType
            accountFromRaw = this.safeStringLower(transfer, "payAccountType");
            accountToRaw = this.safeStringLower(transfer, "recAccountType");
        }
        object accountsByType = this.safeDict(this.options, "accountsByType");
        object accountFrom = this.safeString(accountsByType, accountFromRaw, accountFromRaw);
        object accountTo = this.safeString(accountsByType, accountToRaw, accountToRaw);
        return new Dictionary<string, object>() {
            { "id", this.safeStringN(transfer, new List<object>() {"id", "applyId", "orderId"}) },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "amount", this.safeNumber(transfer, "amount") },
            { "fromAccount", accountFrom },
            { "toAccount", accountTo },
            { "status", this.parseTransferStatus(rawStatus) },
            { "info", transfer },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "PROCESSING", "pending" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "Assets Transferred in After Upgrading", "transfer" },
            { "Deposit", "transaction" },
            { "Withdrawal", "transaction" },
            { "Transfer", "transfer" },
            { "Trade_Exchange", "trade" },
            { "KuCoin Bonus", "bonus" },
            { "Referral Bonus", "referral" },
            { "Rewards", "bonus" },
            { "Airdrop/Fork", "airdrop" },
            { "Other rewards", "bonus" },
            { "Fee Rebate", "rebate" },
            { "Buy Crypto", "trade" },
            { "Sell Crypto", "sell" },
            { "Public Offering Purchase", "trade" },
            { "Refunded Fees", "fee" },
            { "KCS Pay Fees", "fee" },
            { "Margin Trade", "trade" },
            { "Loans", "Loans" },
            { "Instant Exchange", "trade" },
            { "Sub-account transfer", "transfer" },
            { "Liquidation Fees", "fee" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //         "id": "611a1e7c6a053300067a88d9", //unique key for each ledger entry
        //         "currency": "USDT", //Currency
        //         "amount": "10.00059547", //The total amount of assets (fees included) involved in assets changes such as transaction, withdrawal and bonus distribution.
        //         "fee": "0", //Deposit or withdrawal fee
        //         "balance": "0", //Total assets of a currency remaining funds after transaction
        //         "accountType": "MAIN", //Account Type
        //         "bizType": "Loans Repaid", //business type
        //         "direction": "in", //side, in or out
        //         "createdAt": 1629101692950, //Creation time
        //         "context": "{\"borrowerUserId\":\"601ad03e50dc810006d242ea\",\"loanRepayDetailNo\":\"611a1e7cc913d000066cf7ec\"}" //Business core parameters
        //     }
        //
        object id = this.safeString(item, "id");
        object currencyId = this.safeString(item, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        currency = this.safeCurrency(currencyId, currency);
        object amount = this.safeNumber(item, "amount");
        object balanceAfter = null;
        // const balanceAfter = this.safeNumber (item, 'balance'); only returns zero string
        object bizType = this.safeString(item, "bizType");
        object type = this.parseLedgerEntryType(bizType);
        object direction = this.safeString(item, "direction");
        object timestamp = this.safeInteger(item, "createdAt");
        object datetime = this.iso8601(timestamp);
        object account = this.safeString(item, "accountType"); // MAIN, TRADE, MARGIN, or CONTRACT
        object context = this.safeString(item, "context"); // contains other information about the ledger entry
        //
        // withdrawal transaction
        //
        //     "{\"orderId\":\"617bb2d09e7b3b000196dac8\",\"txId\":\"0x79bb9855f86b351a45cab4dc69d78ca09586a94c45dde49475722b98f401b054\"}"
        //
        // deposit to MAIN, trade via MAIN
        //
        //     "{\"orderId\":\"617ab9949e7b3b0001948081\",\"txId\":\"0x7a06b16bbd6b03dbc3d96df5683b15229fc35e7184fd7179a5f3a310bd67d1fa@default@0\"}"
        //
        // sell trade
        //
        //     "{\"symbol\":\"ETH-USDT\",\"orderId\":\"617adcd1eb3fa20001dd29a1\",\"tradeId\":\"617adcd12e113d2b91222ff9\"}"
        //
        object referenceId = null;
        if (isTrue(isTrue(!isEqual(context, null)) && isTrue(!isEqual(context, ""))))
        {
            try
            {
                object parsed = parseJson(context);
                object orderId = this.safeString(parsed, "orderId");
                object tradeId = this.safeString(parsed, "tradeId");
                // transactions only have an orderId but for trades we wish to use tradeId
                if (isTrue(!isEqual(tradeId, null)))
                {
                    referenceId = tradeId;
                } else
                {
                    referenceId = orderId;
                }
            } catch(Exception exc)
            {
                referenceId = context;
            }
        }
        object fee = null;
        object feeCost = this.safeString(item, "fee");
        object feeCurrency = null;
        if (isTrue(!isEqual(feeCost, "0")))
        {
            feeCurrency = code;
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(feeCost) },
                { "currency", feeCurrency },
            };
        }
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", id },
            { "direction", direction },
            { "account", account },
            { "referenceId", referenceId },
            { "referenceAccount", account },
            { "type", type },
            { "currency", code },
            { "amount", amount },
            { "timestamp", timestamp },
            { "datetime", datetime },
            { "before", null },
            { "after", balanceAfter },
            { "status", null },
            { "fee", fee },
        }, currency);
    }

    /**
     * @method
     * @name kucoin#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
     * @see https://www.kucoin.com/docs/rest/account/basic-info/get-account-ledgers-spot-margin
     * @see https://www.kucoin.com/docs/rest/account/basic-info/get-account-ledgers-trade_hf
     * @see https://www.kucoin.com/docs/rest/account/basic-info/get-account-ledgers-margin_hf
     * @param {string} [code] unified currency code, default is undefined
     * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
     * @param {int} [limit] max number of ledger entries to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.hf] default false, when true will fetch ledger entries for the high frequency trading account
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/?id=ledger-entry-structure}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchLedger", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        object hf = null;
        var hfparametersVariable = this.handleHfAndParams(parameters);
        hf = ((IList<object>)hfparametersVariable)[0];
        parameters = ((IList<object>)hfparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchLedger", code, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startAt"] = since;
        }
        // atm only single currency retrieval is supported
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        var requestparametersVariable = this.handleUntilOption("endAt", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchLedger", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object response = null;
        if (isTrue(hf))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                response = await this.privateGetHfMarginAccountLedgers(this.extend(request, parameters));
            } else
            {
                response = await this.privateGetHfAccountsLedgers(this.extend(request, parameters));
            }
        } else
        {
            response = await this.privateGetAccountsLedgers(this.extend(request, parameters));
        }
        //
        //     {
        //         "code":"200000",
        //         "data":{
        //             "currentPage":1,
        //             "pageSize":50,
        //             "totalNum":1,
        //             "totalPage":1,
        //             "items":[
        //                 {
        //                     "id":"617cc528729f5f0001c03ceb",
        //                     "currency":"GAS",
        //                     "amount":"0.00000339",
        //                     "fee":"0",
        //                     "balance":"0",
        //                     "accountType":"MAIN",
        //                     "bizType":"Distribution",
        //                     "direction":"in",
        //                     "createdAt":1635566888183,
        //                     "context":"{\"orderId\":\"617cc47a1c47ed0001ce3606\",\"description\":\"Holding NEO,distribute GAS(2021/10/30)\"}"
        //                 }
        //                 {
        //                     "id": "611a1e7c6a053300067a88d9",//unique key
        //                     "currency": "USDT", //Currency
        //                     "amount": "10.00059547", //Change amount of the funds
        //                     "fee": "0", //Deposit or withdrawal fee
        //                     "balance": "0", //Total assets of a currency
        //                     "accountType": "MAIN", //Account Type
        //                     "bizType": "Loans Repaid", //business type
        //                     "direction": "in", //side, in or out
        //                     "createdAt": 1629101692950, //Creation time
        //                     "context": "{\"borrowerUserId\":\"601ad03e50dc810006d242ea\",\"loanRepayDetailNo\":\"611a1e7cc913d000066cf7ec\"}"
        //                 },
        //             ]
        //         }
        //     }
        //
        object dataList = this.safeList(response, "data");
        if (isTrue(!isEqual(dataList, null)))
        {
            return this.parseLedger(dataList, currency, since, limit);
        }
        object data = this.safeDict(response, "data");
        object items = this.safeList(data, "items", new List<object>() {});
        return this.parseLedger(items, currency, since, limit);
    }

    public override object calculateRateLimiterCost(object api, object method, object path, object parameters, object config = null)
    {
        config ??= new Dictionary<string, object>();
        object versions = this.safeDict(this.options, "versions", new Dictionary<string, object>() {});
        object apiVersions = this.safeDict(versions, api, new Dictionary<string, object>() {});
        object methodVersions = this.safeDict(apiVersions, method, new Dictionary<string, object>() {});
        object defaultVersion = this.safeString(methodVersions, path, getValue(this.options, "version"));
        object version = this.safeString(parameters, "version", defaultVersion);
        if (isTrue(isTrue(isEqual(version, "v3")) && isTrue((inOp(config, "v3")))))
        {
            return getValue(config, "v3");
        } else if (isTrue(isTrue(isEqual(version, "v2")) && isTrue((inOp(config, "v2")))))
        {
            return getValue(config, "v2");
        } else if (isTrue(isTrue(isEqual(version, "v1")) && isTrue((inOp(config, "v1")))))
        {
            return getValue(config, "v1");
        }
        return this.safeValue(config, "cost", 1);
    }

    public override object parseBorrowRate(object info, object currency = null)
    {
        //
        //     {
        //         "tradeId": "62db2dcaff219600012b56cd",
        //         "currency": "USDT",
        //         "size": "10",
        //         "dailyIntRate": "0.00003",
        //         "term": 7,
        //         "timestamp": 1658531274508488480
        //     },
        //
        //     {
        //         "createdAt": 1697783812257,
        //         "currency": "XMR",
        //         "interestAmount": "0.1",
        //         "dayRatio": "0.001"
        //     }
        //
        object timestampId = this.safeString2(info, "createdAt", "timestamp");
        object timestamp = this.parseToInt(slice(timestampId, 0, 13));
        object currencyId = this.safeString(info, "currency");
        return new Dictionary<string, object>() {
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "rate", this.safeNumber2(info, "dailyIntRate", "dayRatio") },
            { "period", 86400000 },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    /**
     * @method
     * @name kucoin#fetchBorrowInterest
     * @description fetch the interest owed by the user for borrowing currency for margin trading
     * @see https://docs.kucoin.com/#get-repay-record
     * @see https://docs.kucoin.com/#query-isolated-margin-account-info
     * @param {string} [code] unified currency code
     * @param {string} [symbol] unified market symbol, required for isolated margin
     * @param {int} [since] the earliest time in ms to fetch borrrow interest for
     * @param {int} [limit] the maximum number of structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated' default is 'cross'
     * @returns {object[]} a list of [borrow interest structures]{@link https://docs.ccxt.com/?id=borrow-interest-structure}
     */
    public async override Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBorrowInterest", parameters, "cross");
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                ((IDictionary<string,object>)request)["balanceCurrency"] = getValue(currency, "id");
            } else
            {
                ((IDictionary<string,object>)request)["quoteCurrency"] = getValue(currency, "id");
            }
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object response = null;
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            response = await this.privateGetIsolatedAccounts(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetMarginAccounts(this.extend(request, parameters));
        }
        //
        // Cross
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "totalAssetOfQuoteCurrency": "0",
        //             "totalLiabilityOfQuoteCurrency": "0",
        //             "debtRatio": "0",
        //             "status": "EFFECTIVE",
        //             "accounts": [
        //                 {
        //                     "currency": "1INCH",
        //                     "total": "0",
        //                     "available": "0",
        //                     "hold": "0",
        //                     "liability": "0",
        //                     "maxBorrowSize": "0",
        //                     "borrowEnabled": true,
        //                     "transferInEnabled": true
        //                 }
        //             ]
        //         }
        //     }
        //
        // Isolated
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "totalConversionBalance": "0.02138647",
        //             "liabilityConversionBalance": "0.01480001",
        //             "assets": [
        //                 {
        //                     "symbol": "MANA-USDT",
        //                     "debtRatio": "0",
        //                     "status": "BORROW",
        //                     "baseAsset": {
        //                         "currency": "MANA",
        //                         "borrowEnabled": true,
        //                         "repayEnabled": true,
        //                         "transferEnabled": true,
        //                         "borrowed": "0",
        //                         "totalAsset": "0",
        //                         "available": "0",
        //                         "hold": "0",
        //                         "maxBorrowSize": "1000"
        //                     },
        //                     "quoteAsset": {
        //                         "currency": "USDT",
        //                         "borrowEnabled": true,
        //                         "repayEnabled": true,
        //                         "transferEnabled": true,
        //                         "borrowed": "0",
        //                         "totalAsset": "0",
        //                         "available": "0",
        //                         "hold": "0",
        //                         "maxBorrowSize": "50000"
        //                     }
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object assets = ((bool) isTrue((isEqual(marginMode, "isolated")))) ? this.safeList(data, "assets", new List<object>() {}) : this.safeList(data, "accounts", new List<object>() {});
        object interest = this.parseBorrowInterests(assets, market);
        object filteredByCurrency = this.filterByCurrencySinceLimit(interest, code, since, limit);
        return this.filterBySymbolSinceLimit(filteredByCurrency, symbol, since, limit);
    }

    public override object parseBorrowInterest(object info, object market = null)
    {
        //
        // Cross
        //
        //     {
        //         "currency": "1INCH",
        //         "total": "0",
        //         "available": "0",
        //         "hold": "0",
        //         "liability": "0",
        //         "maxBorrowSize": "0",
        //         "borrowEnabled": true,
        //         "transferInEnabled": true
        //     }
        //
        // Isolated
        //
        //     {
        //         "symbol": "MANA-USDT",
        //         "debtRatio": "0",
        //         "status": "BORROW",
        //         "baseAsset": {
        //             "currency": "MANA",
        //             "borrowEnabled": true,
        //             "repayEnabled": true,
        //             "transferEnabled": true,
        //             "borrowed": "0",
        //             "totalAsset": "0",
        //             "available": "0",
        //             "hold": "0",
        //             "maxBorrowSize": "1000"
        //         },
        //         "quoteAsset": {
        //             "currency": "USDT",
        //             "borrowEnabled": true,
        //             "repayEnabled": true,
        //             "transferEnabled": true,
        //             "borrowed": "0",
        //             "totalAsset": "0",
        //             "available": "0",
        //             "hold": "0",
        //             "maxBorrowSize": "50000"
        //         }
        //     }
        //
        object marketId = this.safeString(info, "symbol");
        object marginMode = ((bool) isTrue((isEqual(marketId, null)))) ? "cross" : "isolated";
        market = this.safeMarket(marketId, market);
        object symbol = this.safeString(market, "symbol");
        object timestamp = this.safeInteger(info, "createdAt");
        object isolatedBase = this.safeDict(info, "baseAsset", new Dictionary<string, object>() {});
        object amountBorrowed = null;
        object interest = null;
        object currencyId = null;
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            amountBorrowed = this.safeNumber(isolatedBase, "liability");
            interest = this.safeNumber(isolatedBase, "interest");
            currencyId = this.safeString(isolatedBase, "currency");
        } else
        {
            amountBorrowed = this.safeNumber(info, "liability");
            interest = this.safeNumber(info, "accruedInterest");
            currencyId = this.safeString(info, "currency");
        }
        return new Dictionary<string, object>() {
            { "info", info },
            { "symbol", symbol },
            { "currency", this.safeCurrencyCode(currencyId) },
            { "interest", interest },
            { "interestRate", this.safeNumber(info, "dailyIntRate") },
            { "amountBorrowed", amountBorrowed },
            { "marginMode", marginMode },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }

    /**
     * @method
     * @name kucoin#fetchBorrowRateHistories
     * @description retrieves a history of a multiple currencies borrow interest rate at specific time slots, returns all currencies if no symbols passed, default is undefined
     * @see https://www.kucoin.com/docs/rest/margin-trading/margin-trading-v3-/get-cross-isolated-margin-interest-records
     * @param {string[]|undefined} codes list of unified currency codes, default is undefined
     * @param {int} [since] timestamp in ms of the earliest borrowRate, default is undefined
     * @param {int} [limit] max number of borrow rate prices to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated' default is 'cross'
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @returns {object} a dictionary of [borrow rate structures]{@link https://docs.ccxt.com/?id=borrow-rate-structure} indexed by the market symbol
     */
    public async virtual Task<object> fetchBorrowRateHistories(object codes = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marginResult = this.handleMarginModeAndParams("fetchBorrowRateHistories", parameters);
        object marginMode = this.safeString(marginResult, 0, "cross");
        object isIsolated = (isEqual(marginMode, "isolated")); // true-isolated, false-cross
        object request = new Dictionary<string, object>() {
            { "isIsolated", isIsolated },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["pageSize"] = limit; // default:50, min:10, max:500
        }
        object response = await this.privateGetMarginInterest(this.extend(request, parameters));
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "timestamp": 1710829939673,
        //             "currentPage": 1,
        //             "pageSize": 50,
        //             "totalNum": 0,
        //             "totalPage": 0,
        //             "items": [
        //                 {
        //                     "createdAt": 1697783812257,
        //                     "currency": "XMR",
        //                     "interestAmount": "0.1",
        //                     "dayRatio": "0.001"
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data");
        object rows = this.safeList(data, "items", new List<object>() {});
        return this.parseBorrowRateHistories(rows, codes, since, limit);
    }

    /**
     * @method
     * @name kucoin#fetchBorrowRateHistory
     * @description retrieves a history of a currencies borrow interest rate at specific time slots
     * @see https://www.kucoin.com/docs/rest/margin-trading/margin-trading-v3-/get-cross-isolated-margin-interest-records
     * @param {string} code unified currency code
     * @param {int} [since] timestamp for the earliest borrow rate
     * @param {int} [limit] the maximum number of [borrow rate structures]{@link https://docs.ccxt.com/?id=borrow-rate-structure} to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated' default is 'cross'
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @returns {object[]} an array of [borrow rate structures]{@link https://docs.ccxt.com/?id=borrow-rate-structure}
     */
    public async virtual Task<object> fetchBorrowRateHistory(object code, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marginResult = this.handleMarginModeAndParams("fetchBorrowRateHistories", parameters);
        object marginMode = this.safeString(marginResult, 0, "cross");
        object isIsolated = (isEqual(marginMode, "isolated")); // true-isolated, false-cross
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "isIsolated", isIsolated },
            { "currency", getValue(currency, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["pageSize"] = limit; // default:50, min:10, max:500
        }
        object response = await this.privateGetMarginInterest(this.extend(request, parameters));
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "timestamp": 1710829939673,
        //             "currentPage": 1,
        //             "pageSize": 50,
        //             "totalNum": 0,
        //             "totalPage": 0,
        //             "items": [
        //                 {
        //                     "createdAt": 1697783812257,
        //                     "currency": "XMR",
        //                     "interestAmount": "0.1",
        //                     "dayRatio": "0.001"
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data");
        object rows = this.safeList(data, "items", new List<object>() {});
        return this.parseBorrowRateHistory(rows, code, since, limit);
    }

    public virtual object parseBorrowRateHistories(object response, object codes, object since, object limit)
    {
        //
        //     [
        //         {
        //             "createdAt": 1697783812257,
        //             "currency": "XMR",
        //             "interestAmount": "0.1",
        //             "dayRatio": "0.001"
        //         }
        //     ]
        //
        object borrowRateHistories = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object item = getValue(response, i);
            object code = this.safeCurrencyCode(this.safeString(item, "currency"));
            if (isTrue(isTrue(isEqual(codes, null)) || isTrue(this.inArray(code, codes))))
            {
                if (!isTrue((inOp(borrowRateHistories, code))))
                {
                    ((IDictionary<string,object>)borrowRateHistories)[(string)code] = new List<object>() {};
                }
                object borrowRateStructure = this.parseBorrowRate(item);
                object borrowRateHistoriesCode = getValue(borrowRateHistories, code);
                ((IList<object>)borrowRateHistoriesCode).Add(borrowRateStructure);
            }
        }
        object keys = new List<object>(((IDictionary<string,object>)borrowRateHistories).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object code = getValue(keys, i);
            ((IDictionary<string,object>)borrowRateHistories)[(string)code] = this.filterByCurrencySinceLimit(getValue(borrowRateHistories, code), code, since, limit);
        }
        return borrowRateHistories;
    }

    /**
     * @method
     * @name kucoin#borrowCrossMargin
     * @description create a loan to borrow margin
     * @see https://docs.kucoin.com/#1-margin-borrowing
     * @param {string} code unified currency code of the currency to borrow
     * @param {float} amount the amount to borrow
     * @param {object} [params] extra parameters specific to the exchange API endpoints
     * @param {string} [params.timeInForce] either IOC or FOK
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/?id=margin-loan-structure}
     */
    public async override Task<object> borrowCrossMargin(object code, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "size", this.currencyToPrecision(code, amount) },
            { "timeInForce", "FOK" },
        };
        object response = await this.privatePostMarginBorrow(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "code": "200",
        //         "msg": "success",
        //         "retry": false,
        //         "data": {
        //             "orderNo": "5da6dba0f943c0c81f5d5db5",
        //             "actualSize": 10
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginLoan(data, currency);
    }

    /**
     * @method
     * @name kucoin#borrowIsolatedMargin
     * @description create a loan to borrow margin
     * @see https://docs.kucoin.com/#1-margin-borrowing
     * @param {string} symbol unified market symbol, required for isolated margin
     * @param {string} code unified currency code of the currency to borrow
     * @param {float} amount the amount to borrow
     * @param {object} [params] extra parameters specific to the exchange API endpoints
     * @param {string} [params.timeInForce] either IOC or FOK
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/?id=margin-loan-structure}
     */
    public async override Task<object> borrowIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "size", this.currencyToPrecision(code, amount) },
            { "symbol", getValue(market, "id") },
            { "timeInForce", "FOK" },
            { "isIsolated", true },
        };
        object response = await this.privatePostMarginBorrow(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "code": "200",
        //         "msg": "success",
        //         "retry": false,
        //         "data": {
        //             "orderNo": "5da6dba0f943c0c81f5d5db5",
        //             "actualSize": 10
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginLoan(data, currency);
    }

    /**
     * @method
     * @name kucoin#repayCrossMargin
     * @description repay borrowed margin and interest
     * @see https://docs.kucoin.com/#2-repayment
     * @param {string} code unified currency code of the currency to repay
     * @param {float} amount the amount to repay
     * @param {object} [params] extra parameters specific to the exchange API endpoints
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/?id=margin-loan-structure}
     */
    public async override Task<object> repayCrossMargin(object code, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "size", this.currencyToPrecision(code, amount) },
        };
        object response = await this.privatePostMarginRepay(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "code": "200",
        //         "msg": "success",
        //         "retry": false,
        //         "data": {
        //             "orderNo": "5da6dba0f943c0c81f5d5db5",
        //             "actualSize": 10
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginLoan(data, currency);
    }

    /**
     * @method
     * @name kucoin#repayIsolatedMargin
     * @description repay borrowed margin and interest
     * @see https://docs.kucoin.com/#2-repayment
     * @param {string} symbol unified market symbol
     * @param {string} code unified currency code of the currency to repay
     * @param {float} amount the amount to repay
     * @param {object} [params] extra parameters specific to the exchange API endpoints
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/?id=margin-loan-structure}
     */
    public async override Task<object> repayIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "size", this.currencyToPrecision(code, amount) },
            { "symbol", getValue(market, "id") },
            { "isIsolated", true },
        };
        object response = await this.privatePostMarginRepay(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "code": "200",
        //         "msg": "success",
        //         "retry": false,
        //         "data": {
        //             "orderNo": "5da6dba0f943c0c81f5d5db5",
        //             "actualSize": 10
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginLoan(data, currency);
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        //     {
        //         "orderNo": "5da6dba0f943c0c81f5d5db5",
        //         "actualSize": 10
        //     }
        //
        object timestamp = this.milliseconds();
        object currencyId = this.safeString(info, "currency");
        return new Dictionary<string, object>() {
            { "id", this.safeString(info, "orderNo") },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber(info, "actualSize") },
            { "symbol", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    /**
     * @method
     * @name kucoin#fetchDepositWithdrawFees
     * @description fetch deposit and withdraw fees - *IMPORTANT* use fetchDepositWithdrawFee to get more in-depth info
     * @see https://docs.kucoin.com/#get-currencies
     * @param {string[]|undefined} codes list of unified currency codes
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/?id=fee-structure}
     */
    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetCurrencies(parameters);
        //
        //  [
        //      {
        //        "currency": "CSP",
        //        "name": "CSP",
        //        "fullName": "Caspian",
        //        "precision": 8,
        //        "confirms": 12,
        //        "contractAddress": "0xa6446d655a0c34bc4f05042ee88170d056cbaf45",
        //        "withdrawalMinSize": "2000",
        //        "withdrawalMinFee": "1000",
        //        "isWithdrawEnabled": true,
        //        "isDepositEnabled": true,
        //        "isMarginEnabled": false,
        //        "isDebitEnabled": false
        //      },
        //  ]
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseDepositWithdrawFees(data, codes, "currency");
    }

    /**
     * @method
     * @name kucoin#setLeverage
     * @description set the level of leverage for a market
     * @see https://www.kucoin.com/docs/rest/margin-trading/margin-trading-v3-/modify-leverage-multiplier
     * @param {int } [leverage] New leverage multiplier. Must be greater than 1 and up to two decimal places, and cannot be less than the user's current debt leverage or greater than the system's maximum leverage
     * @param {string} [symbol] unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("setLeverage", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(isTrue((!isEqual(symbol, null))) || isTrue(!isEqual(marketType, "spot"))))
        {
            market = this.market(symbol);
            if (isTrue(getValue(market, "contract")))
            {
                throw new NotSupported ((string)add(this.id, " setLeverage currently supports only spot margin")) ;
            }
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("setLeverage", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage requires a marginMode parameter")) ;
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(isTrue(isEqual(marginMode, "isolated")) && isTrue(isEqual(symbol, null))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage requires a symbol parameter for isolated margin")) ;
        }
        if (isTrue(!isEqual(symbol, null)))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        ((IDictionary<string,object>)request)["leverage"] = ((object)leverage).ToString();
        ((IDictionary<string,object>)request)["isIsolated"] = (isEqual(marginMode, "isolated"));
        return await this.privatePostPositionUpdateUserLeverage(this.extend(request, parameters));
    }

    /**
     * @method
     * @name kucoin#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://www.kucoin.com/docs-new/rest/ua/get-current-funding-rate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.utaGetMarketFundingRate(this.extend(request, parameters));
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "symbol": ".XBTUSDTMFPI8H",
        //             "nextFundingRate": 7.4E-5,
        //             "fundingTime": 1762444800000,
        //             "fundingRateCap": 0.003,
        //             "fundingRateFloor": -0.003
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseFundingRate(data, market);
    }

    public override object parseFundingRate(object data, object market = null)
    {
        //
        //     {
        //         "symbol": ".XBTUSDTMFPI8H",
        //         "nextFundingRate": 7.4E-5,
        //         "fundingTime": 1762444800000,
        //         "fundingRateCap": 0.003,
        //         "fundingRateFloor": -0.003
        //     }
        //
        object fundingTimestamp = this.safeInteger(data, "fundingTime");
        object marketId = this.safeString(data, "symbol");
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", this.safeSymbol(marketId, market, null, "contract") },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", this.safeNumber(data, "nextFundingRate") },
            { "fundingTimestamp", fundingTimestamp },
            { "fundingDatetime", this.iso8601(fundingTimestamp) },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", null },
        };
    }

    /**
     * @method
     * @name kucoin#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://www.kucoin.com/docs-new/rest/ua/get-history-funding-rate
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] not used by kucuoinfutures
     * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure} to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] end time in ms
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        if (isTrue(isEqual(since, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a since argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startAt"] = since;
            if (isTrue(isEqual(until, null)))
            {
                ((IDictionary<string,object>)request)["endAt"] = this.milliseconds();
            }
        }
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endAt"] = until;
        }
        object response = await this.utaGetMarketFundingRateHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "symbol": "XBTUSDTM",
        //             "list": [
        //                 {
        //                     "fundingRate": 7.6E-5,
        //                     "ts": 1706097600000
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object result = this.safeList(data, "list", new List<object>() {});
        return this.parseFundingRateHistories(result, market, since, limit);
    }

    public override object parseFundingRateHistory(object info, object market = null)
    {
        //
        //     {
        //         "fundingRate": 7.6E-5,
        //         "ts": 1706097600000
        //     }
        //
        object timestamp = this.safeInteger(info, "ts");
        return new Dictionary<string, object>() {
            { "info", info },
            { "symbol", this.safeSymbol(null, market) },
            { "fundingRate", this.safeNumber(info, "fundingRate") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        //
        // the v2 URL is https://openapi-v2.kucoin.com/api/v1/endpoint
        //                                                 
        //                                                 
        //
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object versions = this.safeDict(this.options, "versions", new Dictionary<string, object>() {});
        object apiVersions = this.safeDict(versions, api, new Dictionary<string, object>() {});
        object methodVersions = this.safeDict(apiVersions, method, new Dictionary<string, object>() {});
        object defaultVersion = this.safeString(methodVersions, path, getValue(this.options, "version"));
        object version = this.safeString(parameters, "version", defaultVersion);
        parameters = this.omit(parameters, "version");
        object endpoint = add(add(add("/api/", version), "/"), this.implodeParams(path, parameters));
        if (isTrue(isEqual(api, "webExchange")))
        {
            endpoint = add("/", this.implodeParams(path, parameters));
        }
        if (isTrue(isEqual(api, "earn")))
        {
            endpoint = add("/api/v1/", this.implodeParams(path, parameters));
        }
        object isUtaPrivate = false;
        if (isTrue(isEqual(api, "uta")))
        {
            endpoint = add("/api/ua/v1/", this.implodeParams(path, parameters));
            if (isTrue(isEqual(path, "market/orderbook")))
            {
                isUtaPrivate = true;
            }
        }
        object query = this.omit(parameters, this.extractParams(path));
        object endpart = "";
        headers = ((bool) isTrue((!isEqual(headers, null)))) ? headers : new Dictionary<string, object>() {};
        object url = getValue(getValue(this.urls, "api"), api);
        if (!isTrue(this.isEmpty(query)))
        {
            if (isTrue(isTrue((isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE"))))) && isTrue((!isEqual(path, "orders/multi-cancel")))))
            {
                endpoint = add(endpoint, add("?", this.rawencode(query)));
            } else
            {
                body = this.json(query);
                endpart = body;
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
            }
        }
        url = add(url, endpoint);
        object isFuturePrivate = (isEqual(api, "futuresPrivate"));
        object isPrivate = (isEqual(api, "private"));
        object isBroker = (isEqual(api, "broker"));
        object isEarn = (isEqual(api, "earn"));
        if (isTrue(isTrue(isTrue(isTrue(isTrue(isPrivate) || isTrue(isFuturePrivate)) || isTrue(isBroker)) || isTrue(isEarn)) || isTrue(isUtaPrivate)))
        {
            this.checkRequiredCredentials();
            object timestamp = ((object)this.nonce()).ToString();
            headers = this.extend(new Dictionary<string, object>() {
                { "KC-API-KEY-VERSION", "2" },
                { "KC-API-KEY", this.apiKey },
                { "KC-API-TIMESTAMP", timestamp },
            }, headers);
            object apiKeyVersion = this.safeString(headers, "KC-API-KEY-VERSION");
            if (isTrue(isEqual(apiKeyVersion, "2")))
            {
                object passphrase = this.hmac(this.encode(this.password), this.encode(this.secret), sha256, "base64");
                ((IDictionary<string,object>)headers)["KC-API-PASSPHRASE"] = passphrase;
            } else
            {
                ((IDictionary<string,object>)headers)["KC-API-PASSPHRASE"] = this.password;
            }
            object payload = add(add(add(timestamp, method), endpoint), endpart);
            object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha256, "base64");
            ((IDictionary<string,object>)headers)["KC-API-SIGN"] = signature;
            object partner = this.safeDict(this.options, "partner", new Dictionary<string, object>() {});
            partner = ((bool) isTrue(isFuturePrivate)) ? this.safeValue(partner, "future", partner) : this.safeValue(partner, "spot", partner);
            object partnerId = this.safeString(partner, "id");
            object partnerSecret = this.safeString2(partner, "secret", "key");
            if (isTrue(isTrue((!isEqual(partnerId, null))) && isTrue((!isEqual(partnerSecret, null)))))
            {
                object partnerPayload = add(add(timestamp, partnerId), this.apiKey);
                object partnerSignature = this.hmac(this.encode(partnerPayload), this.encode(partnerSecret), sha256, "base64");
                ((IDictionary<string,object>)headers)["KC-API-PARTNER-SIGN"] = partnerSignature;
                ((IDictionary<string,object>)headers)["KC-API-PARTNER"] = partnerId;
                ((IDictionary<string,object>)headers)["KC-API-PARTNER-VERIFY"] = "true";
            }
            if (isTrue(isBroker))
            {
                object brokerName = this.safeString(partner, "name");
                if (isTrue(!isEqual(brokerName, null)))
                {
                    ((IDictionary<string,object>)headers)["KC-BROKER-NAME"] = brokerName;
                }
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, body);
            return null;
        }
        //
        // bad
        //     { "code": "400100", "msg": "validation.createOrder.clientOidIsRequired" }
        // good
        //     { code: '200000', data: { ... }}
        //
        object errorCode = this.safeString(response, "code");
        object message = this.safeString2(response, "msg", "data", "");
        object feedback = add(add(this.id, " "), body);
        this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
        this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
        this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
        if (isTrue(isTrue(!isEqual(errorCode, "200000")) && isTrue(!isEqual(errorCode, "200"))))
        {
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }

    /**
     * @method
     * @name kucoin#fetchTransfers
     * @description fetch a history of internal transfers made on an account
     * @see https://www.kucoin.com/docs-new/rest/account-info/account-funding/get-account-ledgers-spot-margin
     * @param {string} [code] unified currency code of the currency transferred
     * @param {int} [since] the earliest time in ms to fetch transfers for
     * @param {int} [limit] the maximum number of transfer structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch transfers for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/?id=transfer-structure}
     */
    public async override Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchTransfers", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchTransfers", code, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {
            { "bizType", "TRANSFER" },
        };
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, "until");
            ((IDictionary<string,object>)request)["endAt"] = until;
        }
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startAt"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["pageSize"] = limit;
        } else
        {
            ((IDictionary<string,object>)request)["pageSize"] = 500;
        }
        var requestparametersVariable = this.handleUntilOption("endAt", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateGetAccountsLedgers(this.extend(request, parameters));
        //
        // {
        //     "code": "200000",
        //     "data": {
        //         "currentPage": 1,
        //         "pageSize": 50,
        //         "totalNum": 1,
        //         "totalPage": 1,
        //         "items": [
        //             {
        //                 "id": "611a1e7c6a053300067a88d9",
        //                 "currency": "USDT",
        //                 "amount": "10.00059547",
        //                 "fee": "0",
        //                 "balance": "0",
        //                 "accountType": "MAIN",
        //                 "bizType": "Transfer",
        //                 "direction": "in",
        //                 "createdAt": 1629101692950,
        //                 "context": "{\"orderId\":\"611a1e7c6a053300067a88d9\"}"
        //             }
        //         ]
        //     }
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object items = this.safeList(data, "items", new List<object>() {});
        return this.parseTransfers(items, currency, since, limit);
    }
}
