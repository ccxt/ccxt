namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class gate : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "gate" },
            { "name", "Gate.io" },
            { "countries", new List<object>() {"KR"} },
            { "rateLimit", 50 },
            { "version", "v4" },
            { "certified", true },
            { "pro", true },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/31784029-0313c702-b509-11e7-9ccc-bc0da6a0e435.jpg" },
                { "doc", "https://www.gate.io/docs/developers/apiv4/en/" },
                { "www", "https://gate.io/" },
                { "api", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "wallet", "https://api.gateio.ws/api/v4" },
                        { "futures", "https://api.gateio.ws/api/v4" },
                        { "margin", "https://api.gateio.ws/api/v4" },
                        { "delivery", "https://api.gateio.ws/api/v4" },
                        { "spot", "https://api.gateio.ws/api/v4" },
                        { "options", "https://api.gateio.ws/api/v4" },
                        { "sub_accounts", "https://api.gateio.ws/api/v4" },
                        { "earn", "https://api.gateio.ws/api/v4" },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "withdrawals", "https://api.gateio.ws/api/v4" },
                        { "wallet", "https://api.gateio.ws/api/v4" },
                        { "futures", "https://api.gateio.ws/api/v4" },
                        { "margin", "https://api.gateio.ws/api/v4" },
                        { "delivery", "https://api.gateio.ws/api/v4" },
                        { "spot", "https://api.gateio.ws/api/v4" },
                        { "options", "https://api.gateio.ws/api/v4" },
                        { "subAccounts", "https://api.gateio.ws/api/v4" },
                        { "unified", "https://api.gateio.ws/api/v4" },
                        { "rebate", "https://api.gateio.ws/api/v4" },
                        { "earn", "https://api.gateio.ws/api/v4" },
                        { "account", "https://api.gateio.ws/api/v4" },
                        { "loan", "https://api.gateio.ws/api/v4" },
                    } },
                } },
                { "test", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "futures", "https://fx-api-testnet.gateio.ws/api/v4" },
                        { "delivery", "https://fx-api-testnet.gateio.ws/api/v4" },
                        { "options", "https://fx-api-testnet.gateio.ws/api/v4" },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "futures", "https://fx-api-testnet.gateio.ws/api/v4" },
                        { "delivery", "https://fx-api-testnet.gateio.ws/api/v4" },
                        { "options", "https://fx-api-testnet.gateio.ws/api/v4" },
                    } },
                } },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://www.gate.io/signup/2436035" },
                    { "discount", 0.2 },
                } },
            } },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", true },
                { "option", true },
                { "addMargin", true },
                { "borrowCrossMargin", true },
                { "borrowIsolatedMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrder", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", true },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", true },
                { "createStopLossOrder", true },
                { "createStopMarketOrder", false },
                { "createStopOrder", true },
                { "createTakeProfitOrder", true },
                { "createTriggerOrder", true },
                { "editOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchGreeks", true },
                { "fetchIndexOHLCV", true },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLedger", true },
                { "fetchLeverage", true },
                { "fetchLeverages", true },
                { "fetchLeverageTiers", true },
                { "fetchLiquidations", true },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", false },
                { "fetchMarketLeverageTiers", true },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMyLiquidations", true },
                { "fetchMySettlementHistory", true },
                { "fetchMyTrades", true },
                { "fetchNetworkDepositAddress", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", false },
                { "fetchOpenInterestHistory", true },
                { "fetchOpenOrders", true },
                { "fetchOption", true },
                { "fetchOptionChain", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchPosition", true },
                { "fetchPositionHistory", "emulated" },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsHistory", true },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchSettlementHistory", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", false },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", true },
                { "fetchTransactionFees", true },
                { "fetchUnderlyingAssets", true },
                { "fetchVolatilityHistory", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", true },
                { "repayCrossMargin", true },
                { "repayIsolatedMargin", true },
                { "sandbox", true },
                { "setLeverage", true },
                { "setMarginMode", false },
                { "setPositionMode", true },
                { "signIn", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "wallet", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "currency_chains", 1 },
                        } },
                    } },
                    { "spot", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "currencies", 1 },
                            { "currencies/{currency}", 1 },
                            { "currency_pairs", 1 },
                            { "currency_pairs/{currency_pair}", 1 },
                            { "tickers", 1 },
                            { "order_book", 1 },
                            { "trades", 1 },
                            { "candlesticks", 1 },
                            { "time", 1 },
                        } },
                    } },
                    { "margin", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "currency_pairs", 1 },
                            { "currency_pairs/{currency_pair}", 1 },
                            { "funding_book", 1 },
                            { "cross/currencies", 1 },
                            { "cross/currencies/{currency}", 1 },
                            { "uni/currency_pairs", 1 },
                            { "uni/currency_pairs/{currency_pair}", 1 },
                        } },
                    } },
                    { "flash_swap", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "currencies", 1 },
                        } },
                    } },
                    { "futures", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "{settle}/contracts", 1 },
                            { "{settle}/contracts/{contract}", 1 },
                            { "{settle}/order_book", 1 },
                            { "{settle}/trades", 1 },
                            { "{settle}/candlesticks", 1 },
                            { "{settle}/premium_index", 1 },
                            { "{settle}/tickers", 1 },
                            { "{settle}/funding_rate", 1 },
                            { "{settle}/insurance", 1 },
                            { "{settle}/contract_stats", 1 },
                            { "{settle}/index_constituents/{index}", 1 },
                            { "{settle}/liq_orders", 1 },
                        } },
                    } },
                    { "delivery", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "{settle}/contracts", 1 },
                            { "{settle}/contracts/{contract}", 1 },
                            { "{settle}/order_book", 1 },
                            { "{settle}/trades", 1 },
                            { "{settle}/candlesticks", 1 },
                            { "{settle}/tickers", 1 },
                            { "{settle}/insurance", 1 },
                        } },
                    } },
                    { "options", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "underlyings", 1 },
                            { "expirations", 1 },
                            { "contracts", 1 },
                            { "contracts/{contract}", 1 },
                            { "settlements", 1 },
                            { "settlements/{contract}", 1 },
                            { "order_book", 1 },
                            { "tickers", 1 },
                            { "underlying/tickers/{underlying}", 1 },
                            { "candlesticks", 1 },
                            { "underlying/candlesticks", 1 },
                            { "trades", 1 },
                        } },
                    } },
                    { "earn", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "uni/currencies", 1 },
                            { "uni/currencies/{currency}", 1 },
                        } },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "withdrawals", new Dictionary<string, object>() {
                        { "post", new Dictionary<string, object>() {
                            { "withdrawals", 20 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "withdrawals/{withdrawal_id}", 1 },
                        } },
                    } },
                    { "wallet", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "deposit_address", 1 },
                            { "withdrawals", 1 },
                            { "deposits", 1 },
                            { "sub_account_transfers", 1 },
                            { "withdraw_status", 1 },
                            { "sub_account_balances", 2.5 },
                            { "sub_account_margin_balances", 2.5 },
                            { "sub_account_futures_balances", 2.5 },
                            { "sub_account_cross_margin_balances", 2.5 },
                            { "saved_address", 1 },
                            { "fee", 1 },
                            { "total_balance", 2.5 },
                            { "small_balance", 1 },
                            { "small_balance_history", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "transfers", 2.5 },
                            { "sub_account_transfers", 2.5 },
                            { "sub_account_to_sub_account", 2.5 },
                            { "small_balance", 1 },
                        } },
                    } },
                    { "subAccounts", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "sub_accounts", 2.5 },
                            { "sub_accounts/{user_id}", 2.5 },
                            { "sub_accounts/{user_id}/keys", 2.5 },
                            { "sub_accounts/{user_id}/keys/{key}", 2.5 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "sub_accounts", 2.5 },
                            { "sub_accounts/{user_id}/keys", 2.5 },
                            { "sub_accounts/{user_id}/lock", 2.5 },
                            { "sub_accounts/{user_id}/unlock", 2.5 },
                        } },
                        { "put", new Dictionary<string, object>() {
                            { "sub_accounts/{user_id}/keys/{key}", 2.5 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "sub_accounts/{user_id}/keys/{key}", 2.5 },
                        } },
                    } },
                    { "unified", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "accounts", divide(20, 15) },
                            { "account_mode", divide(20, 15) },
                            { "borrowable", divide(20, 15) },
                            { "transferable", divide(20, 15) },
                            { "loans", divide(20, 15) },
                            { "loan_records", divide(20, 15) },
                            { "interest_records", divide(20, 15) },
                            { "estimate_rate", divide(20, 15) },
                            { "currency_discount_tiers", divide(20, 15) },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "account_mode", divide(20, 15) },
                            { "loans", divide(200, 15) },
                        } },
                    } },
                    { "spot", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "fee", 1 },
                            { "batch_fee", 1 },
                            { "accounts", 1 },
                            { "account_book", 1 },
                            { "open_orders", 1 },
                            { "orders", 1 },
                            { "orders/{order_id}", 1 },
                            { "my_trades", 1 },
                            { "price_orders", 1 },
                            { "price_orders/{order_id}", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "batch_orders", 0.4 },
                            { "cross_liquidate_orders", 1 },
                            { "orders", 0.4 },
                            { "cancel_batch_orders", divide(20, 75) },
                            { "countdown_cancel_all", divide(20, 75) },
                            { "amend_batch_orders", 0.4 },
                            { "price_orders", 0.4 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "orders", divide(20, 75) },
                            { "orders/{order_id}", divide(20, 75) },
                            { "price_orders", divide(20, 75) },
                            { "price_orders/{order_id}", divide(20, 75) },
                        } },
                        { "patch", new Dictionary<string, object>() {
                            { "orders/{order_id}", 0.4 },
                        } },
                    } },
                    { "margin", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "accounts", divide(20, 15) },
                            { "account_book", divide(20, 15) },
                            { "funding_accounts", divide(20, 15) },
                            { "auto_repay", divide(20, 15) },
                            { "transferable", divide(20, 15) },
                            { "loans", divide(20, 15) },
                            { "loans/{loan_id}", divide(20, 15) },
                            { "loans/{loan_id}/repayment", divide(20, 15) },
                            { "loan_records", divide(20, 15) },
                            { "loan_records/{loan_record_id}", divide(20, 15) },
                            { "borrowable", divide(20, 15) },
                            { "cross/accounts", divide(20, 15) },
                            { "cross/account_book", divide(20, 15) },
                            { "cross/loans", divide(20, 15) },
                            { "cross/loans/{loan_id}", divide(20, 15) },
                            { "cross/repayments", divide(20, 15) },
                            { "cross/interest_records", divide(20, 15) },
                            { "cross/transferable", divide(20, 15) },
                            { "cross/estimate_rate", divide(20, 15) },
                            { "cross/borrowable", divide(20, 15) },
                            { "uni/estimate_rate", divide(20, 15) },
                            { "uni/loans", divide(20, 15) },
                            { "uni/loan_records", divide(20, 15) },
                            { "uni/interest_records", divide(20, 15) },
                            { "uni/borrowable", divide(20, 15) },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "auto_repay", divide(20, 15) },
                            { "loans", divide(20, 15) },
                            { "merged_loans", divide(20, 15) },
                            { "loans/{loan_id}/repayment", divide(20, 15) },
                            { "cross/loans", divide(20, 15) },
                            { "cross/repayments", divide(20, 15) },
                            { "uni/loans", divide(20, 15) },
                        } },
                        { "patch", new Dictionary<string, object>() {
                            { "loans/{loan_id}", divide(20, 15) },
                            { "loan_records/{loan_record_id}", divide(20, 15) },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "loans/{loan_id}", divide(20, 15) },
                        } },
                    } },
                    { "flash_swap", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "currencies", 1 },
                            { "currency_pairs", 1 },
                            { "orders", 1 },
                            { "orders/{order_id}", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "orders", 1 },
                            { "orders/preview", 1 },
                        } },
                    } },
                    { "futures", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "{settle}/accounts", 1 },
                            { "{settle}/account_book", 1 },
                            { "{settle}/positions", 1 },
                            { "{settle}/positions/{contract}", 1 },
                            { "{settle}/dual_comp/positions/{contract}", 1 },
                            { "{settle}/orders", 1 },
                            { "{settle}/orders_timerange", 1 },
                            { "{settle}/orders/{order_id}", 1 },
                            { "{settle}/my_trades", 1 },
                            { "{settle}/my_trades_timerange", 1 },
                            { "{settle}/position_close", 1 },
                            { "{settle}/liquidates", 1 },
                            { "{settle}/auto_deleverages", 1 },
                            { "{settle}/fee", 1 },
                            { "{settle}/risk_limit_tiers", 1 },
                            { "{settle}/price_orders", 1 },
                            { "{settle}/price_orders/{order_id}", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "{settle}/positions/{contract}/margin", 1 },
                            { "{settle}/positions/{contract}/leverage", 1 },
                            { "{settle}/positions/{contract}/risk_limit", 1 },
                            { "{settle}/dual_mode", 1 },
                            { "{settle}/dual_comp/positions/{contract}/margin", 1 },
                            { "{settle}/dual_comp/positions/{contract}/leverage", 1 },
                            { "{settle}/dual_comp/positions/{contract}/risk_limit", 1 },
                            { "{settle}/orders", 0.4 },
                            { "{settle}/batch_orders", 0.4 },
                            { "{settle}/countdown_cancel_all", 0.4 },
                            { "{settle}/batch_cancel_orders", 0.4 },
                            { "{settle}/price_orders", 0.4 },
                        } },
                        { "put", new Dictionary<string, object>() {
                            { "{settle}/orders/{order_id}", 1 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "{settle}/orders", divide(20, 75) },
                            { "{settle}/orders/{order_id}", divide(20, 75) },
                            { "{settle}/price_orders", divide(20, 75) },
                            { "{settle}/price_orders/{order_id}", divide(20, 75) },
                        } },
                    } },
                    { "delivery", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "{settle}/accounts", divide(20, 15) },
                            { "{settle}/account_book", divide(20, 15) },
                            { "{settle}/positions", divide(20, 15) },
                            { "{settle}/positions/{contract}", divide(20, 15) },
                            { "{settle}/orders", divide(20, 15) },
                            { "{settle}/orders/{order_id}", divide(20, 15) },
                            { "{settle}/my_trades", divide(20, 15) },
                            { "{settle}/position_close", divide(20, 15) },
                            { "{settle}/liquidates", divide(20, 15) },
                            { "{settle}/settlements", divide(20, 15) },
                            { "{settle}/price_orders", divide(20, 15) },
                            { "{settle}/price_orders/{order_id}", divide(20, 15) },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "{settle}/positions/{contract}/margin", divide(20, 15) },
                            { "{settle}/positions/{contract}/leverage", divide(20, 15) },
                            { "{settle}/positions/{contract}/risk_limit", divide(20, 15) },
                            { "{settle}/orders", divide(20, 15) },
                            { "{settle}/price_orders", divide(20, 15) },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "{settle}/orders", divide(20, 15) },
                            { "{settle}/orders/{order_id}", divide(20, 15) },
                            { "{settle}/price_orders", divide(20, 15) },
                            { "{settle}/price_orders/{order_id}", divide(20, 15) },
                        } },
                    } },
                    { "options", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "my_settlements", divide(20, 15) },
                            { "accounts", divide(20, 15) },
                            { "account_book", divide(20, 15) },
                            { "positions", divide(20, 15) },
                            { "positions/{contract}", divide(20, 15) },
                            { "position_close", divide(20, 15) },
                            { "orders", divide(20, 15) },
                            { "orders/{order_id}", divide(20, 15) },
                            { "my_trades", divide(20, 15) },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "orders", divide(20, 15) },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "orders", divide(20, 15) },
                            { "orders/{order_id}", divide(20, 15) },
                        } },
                    } },
                    { "earn", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "uni/currencies", divide(20, 15) },
                            { "uni/currencies/{currency}", divide(20, 15) },
                            { "uni/lends", divide(20, 15) },
                            { "uni/lend_records", divide(20, 15) },
                            { "uni/interests/{currency}", divide(20, 15) },
                            { "uni/interest_records", divide(20, 15) },
                            { "uni/interest_status/{currency}", divide(20, 15) },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "uni/lends", divide(20, 15) },
                        } },
                        { "put", new Dictionary<string, object>() {
                            { "uni/interest_reinvest", divide(20, 15) },
                        } },
                        { "patch", new Dictionary<string, object>() {
                            { "uni/lends", divide(20, 15) },
                        } },
                    } },
                    { "loan", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "collateral/orders", divide(20, 15) },
                            { "collateral/orders/{order_id}", divide(20, 15) },
                            { "collateral/repay_records", divide(20, 15) },
                            { "collateral/collaterals", divide(20, 15) },
                            { "collateral/total_amount", divide(20, 15) },
                            { "collateral/ltv", divide(20, 15) },
                            { "collateral/currencies", divide(20, 15) },
                            { "multi_collateral/orders", divide(20, 15) },
                            { "multi_collateral/orders/{order_id}", divide(20, 15) },
                            { "multi_collateral/repay", divide(20, 15) },
                            { "multi_collateral/mortgage", divide(20, 15) },
                            { "multi_collateral/currency_quota", divide(20, 15) },
                            { "multi_collateral/currencies", divide(20, 15) },
                            { "multi_collateral/ltv", divide(20, 15) },
                            { "multi_collateral/fixed_rate", divide(20, 15) },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "collateral/orders", divide(20, 15) },
                            { "collateral/repay", divide(20, 15) },
                            { "collateral/collaterals", divide(20, 15) },
                            { "multi_collateral/orders", divide(20, 15) },
                            { "multi_collateral/repay", divide(20, 15) },
                            { "multi_collateral/mortgage", divide(20, 15) },
                        } },
                    } },
                    { "account", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "detail", divide(20, 15) },
                            { "stp_groups", divide(20, 15) },
                            { "stp_groups/{stp_id}/users", divide(20, 15) },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "stp_groups", divide(20, 15) },
                            { "stp_groups/{stp_id}/users", divide(20, 15) },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "stp_groups/{stp_id}/users", divide(20, 15) },
                        } },
                    } },
                    { "rebate", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "agency/transaction_history", divide(20, 15) },
                            { "agency/commission_history", divide(20, 15) },
                        } },
                    } },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "10s", "10s" },
                { "1m", "1m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "8h", "8h" },
                { "1d", "1d" },
                { "7d", "7d" },
                { "1w", "7d" },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "88MPH", "MPH" },
                { "AXIS", "Axis DeFi" },
                { "BIFI", "Bitcoin File" },
                { "BOX", "DefiBox" },
                { "BYN", "BeyondFi" },
                { "EGG", "Goose Finance" },
                { "GTC", "Game.com" },
                { "GTC_HT", "Game.com HT" },
                { "GTC_BSC", "Game.com BSC" },
                { "HIT", "HitChain" },
                { "MM", "Million" },
                { "MPH", "Morpher" },
                { "POINT", "GatePoint" },
                { "RAI", "Rai Reflex Index" },
                { "SBTC", "Super Bitcoin" },
                { "TNC", "Trinity Network Credit" },
                { "VAI", "VAIOT" },
                { "TRAC", "TRACO" },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
            } },
            { "headers", new Dictionary<string, object>() {
                { "X-Gate-Channel-Id", "ccxt" },
            } },
            { "options", new Dictionary<string, object>() {
                { "sandboxMode", false },
                { "createOrder", new Dictionary<string, object>() {
                    { "expiration", 86400 },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "AVAXC", "AVAX_C" },
                    { "BEP20", "BSC" },
                    { "EOS", "EOS" },
                    { "ERC20", "ETH" },
                    { "GATECHAIN", "GTEVM" },
                    { "HRC20", "HT" },
                    { "KUSAMA", "KSMSM" },
                    { "NEAR", "NEAR" },
                    { "OKC", "OKT" },
                    { "OPTIMISM", "OPETH" },
                    { "POLKADOT", "DOTSM" },
                    { "TRC20", "TRX" },
                } },
                { "timeInForce", new Dictionary<string, object>() {
                    { "GTC", "gtc" },
                    { "IOC", "ioc" },
                    { "PO", "poc" },
                    { "POC", "poc" },
                    { "FOK", "fok" },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "funding", "spot" },
                    { "spot", "spot" },
                    { "margin", "margin" },
                    { "cross_margin", "cross_margin" },
                    { "cross", "cross_margin" },
                    { "isolated", "margin" },
                    { "swap", "futures" },
                    { "future", "delivery" },
                    { "futures", "futures" },
                    { "delivery", "delivery" },
                    { "option", "options" },
                    { "options", "options" },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "fetchMarkets", new Dictionary<string, object>() {
                        { "settlementCurrencies", new List<object>() {"usdt", "btc"} },
                    } },
                } },
                { "future", new Dictionary<string, object>() {
                    { "fetchMarkets", new Dictionary<string, object>() {
                        { "settlementCurrencies", new List<object>() {"usdt"} },
                    } },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "feeSide", "get" },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.002") },
                    { "taker", this.parseNumber("0.002") },
                    { "tiers", new Dictionary<string, object>() {
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.002")}, new List<object> {this.parseNumber("1.5"), this.parseNumber("0.00185")}, new List<object> {this.parseNumber("3"), this.parseNumber("0.00175")}, new List<object> {this.parseNumber("6"), this.parseNumber("0.00165")}, new List<object> {this.parseNumber("12.5"), this.parseNumber("0.00155")}, new List<object> {this.parseNumber("25"), this.parseNumber("0.00145")}, new List<object> {this.parseNumber("75"), this.parseNumber("0.00135")}, new List<object> {this.parseNumber("200"), this.parseNumber("0.00125")}, new List<object> {this.parseNumber("500"), this.parseNumber("0.00115")}, new List<object> {this.parseNumber("1250"), this.parseNumber("0.00105")}, new List<object> {this.parseNumber("2500"), this.parseNumber("0.00095")}, new List<object> {this.parseNumber("3000"), this.parseNumber("0.00085")}, new List<object> {this.parseNumber("6000"), this.parseNumber("0.00075")}, new List<object> {this.parseNumber("11000"), this.parseNumber("0.00065")}, new List<object> {this.parseNumber("20000"), this.parseNumber("0.00055")}, new List<object> {this.parseNumber("40000"), this.parseNumber("0.00055")}, new List<object> {this.parseNumber("75000"), this.parseNumber("0.00055")}} },
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.002")}, new List<object> {this.parseNumber("1.5"), this.parseNumber("0.00195")}, new List<object> {this.parseNumber("3"), this.parseNumber("0.00185")}, new List<object> {this.parseNumber("6"), this.parseNumber("0.00175")}, new List<object> {this.parseNumber("12.5"), this.parseNumber("0.00165")}, new List<object> {this.parseNumber("25"), this.parseNumber("0.00155")}, new List<object> {this.parseNumber("75"), this.parseNumber("0.00145")}, new List<object> {this.parseNumber("200"), this.parseNumber("0.00135")}, new List<object> {this.parseNumber("500"), this.parseNumber("0.00125")}, new List<object> {this.parseNumber("1250"), this.parseNumber("0.00115")}, new List<object> {this.parseNumber("2500"), this.parseNumber("0.00105")}, new List<object> {this.parseNumber("3000"), this.parseNumber("0.00095")}, new List<object> {this.parseNumber("6000"), this.parseNumber("0.00085")}, new List<object> {this.parseNumber("11000"), this.parseNumber("0.00075")}, new List<object> {this.parseNumber("20000"), this.parseNumber("0.00065")}, new List<object> {this.parseNumber("40000"), this.parseNumber("0.00065")}, new List<object> {this.parseNumber("75000"), this.parseNumber("0.00065")}} },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "feeSide", "base" },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.0") },
                    { "taker", this.parseNumber("0.0005") },
                    { "tiers", new Dictionary<string, object>() {
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0000")}, new List<object> {this.parseNumber("1.5"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("3"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("6"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("12.5"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("25"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("75"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("200"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("500"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("1250"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("2500"), this.parseNumber("-0.00005")}, new List<object> {this.parseNumber("3000"), this.parseNumber("-0.00008")}, new List<object> {this.parseNumber("6000"), this.parseNumber("-0.01000")}, new List<object> {this.parseNumber("11000"), this.parseNumber("-0.01002")}, new List<object> {this.parseNumber("20000"), this.parseNumber("-0.01005")}, new List<object> {this.parseNumber("40000"), this.parseNumber("-0.02000")}, new List<object> {this.parseNumber("75000"), this.parseNumber("-0.02005")}} },
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.00050")}, new List<object> {this.parseNumber("1.5"), this.parseNumber("0.00048")}, new List<object> {this.parseNumber("3"), this.parseNumber("0.00046")}, new List<object> {this.parseNumber("6"), this.parseNumber("0.00044")}, new List<object> {this.parseNumber("12.5"), this.parseNumber("0.00042")}, new List<object> {this.parseNumber("25"), this.parseNumber("0.00040")}, new List<object> {this.parseNumber("75"), this.parseNumber("0.00038")}, new List<object> {this.parseNumber("200"), this.parseNumber("0.00036")}, new List<object> {this.parseNumber("500"), this.parseNumber("0.00034")}, new List<object> {this.parseNumber("1250"), this.parseNumber("0.00032")}, new List<object> {this.parseNumber("2500"), this.parseNumber("0.00030")}, new List<object> {this.parseNumber("3000"), this.parseNumber("0.00030")}, new List<object> {this.parseNumber("6000"), this.parseNumber("0.00030")}, new List<object> {this.parseNumber("11000"), this.parseNumber("0.00030")}, new List<object> {this.parseNumber("20000"), this.parseNumber("0.00030")}, new List<object> {this.parseNumber("40000"), this.parseNumber("0.00030")}, new List<object> {this.parseNumber("75000"), this.parseNumber("0.00030")}} },
                    } },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "INVALID_PARAM_VALUE", typeof(BadRequest) },
                    { "INVALID_PROTOCOL", typeof(BadRequest) },
                    { "INVALID_ARGUMENT", typeof(BadRequest) },
                    { "INVALID_REQUEST_BODY", typeof(BadRequest) },
                    { "MISSING_REQUIRED_PARAM", typeof(ArgumentsRequired) },
                    { "BAD_REQUEST", typeof(BadRequest) },
                    { "INVALID_CONTENT_TYPE", typeof(BadRequest) },
                    { "NOT_ACCEPTABLE", typeof(BadRequest) },
                    { "METHOD_NOT_ALLOWED", typeof(BadRequest) },
                    { "NOT_FOUND", typeof(ExchangeError) },
                    { "INVALID_CREDENTIALS", typeof(AuthenticationError) },
                    { "INVALID_KEY", typeof(AuthenticationError) },
                    { "IP_FORBIDDEN", typeof(AuthenticationError) },
                    { "READ_ONLY", typeof(PermissionDenied) },
                    { "INVALID_SIGNATURE", typeof(AuthenticationError) },
                    { "MISSING_REQUIRED_HEADER", typeof(AuthenticationError) },
                    { "REQUEST_EXPIRED", typeof(AuthenticationError) },
                    { "ACCOUNT_LOCKED", typeof(AccountSuspended) },
                    { "FORBIDDEN", typeof(PermissionDenied) },
                    { "SUB_ACCOUNT_NOT_FOUND", typeof(ExchangeError) },
                    { "SUB_ACCOUNT_LOCKED", typeof(AccountSuspended) },
                    { "MARGIN_BALANCE_EXCEPTION", typeof(ExchangeError) },
                    { "MARGIN_TRANSFER_FAILED", typeof(ExchangeError) },
                    { "TOO_MUCH_FUTURES_AVAILABLE", typeof(ExchangeError) },
                    { "FUTURES_BALANCE_NOT_ENOUGH", typeof(InsufficientFunds) },
                    { "ACCOUNT_EXCEPTION", typeof(ExchangeError) },
                    { "SUB_ACCOUNT_TRANSFER_FAILED", typeof(ExchangeError) },
                    { "ADDRESS_NOT_USED", typeof(ExchangeError) },
                    { "TOO_FAST", typeof(RateLimitExceeded) },
                    { "WITHDRAWAL_OVER_LIMIT", typeof(ExchangeError) },
                    { "API_WITHDRAW_DISABLED", typeof(ExchangeNotAvailable) },
                    { "INVALID_WITHDRAW_ID", typeof(ExchangeError) },
                    { "INVALID_WITHDRAW_CANCEL_STATUS", typeof(ExchangeError) },
                    { "INVALID_PRECISION", typeof(InvalidOrder) },
                    { "INVALID_CURRENCY", typeof(BadSymbol) },
                    { "INVALID_CURRENCY_PAIR", typeof(BadSymbol) },
                    { "POC_FILL_IMMEDIATELY", typeof(OrderImmediatelyFillable) },
                    { "ORDER_NOT_FOUND", typeof(OrderNotFound) },
                    { "CLIENT_ID_NOT_FOUND", typeof(OrderNotFound) },
                    { "ORDER_CLOSED", typeof(InvalidOrder) },
                    { "ORDER_CANCELLED", typeof(InvalidOrder) },
                    { "QUANTITY_NOT_ENOUGH", typeof(InvalidOrder) },
                    { "BALANCE_NOT_ENOUGH", typeof(InsufficientFunds) },
                    { "MARGIN_NOT_SUPPORTED", typeof(InvalidOrder) },
                    { "MARGIN_BALANCE_NOT_ENOUGH", typeof(InsufficientFunds) },
                    { "AMOUNT_TOO_LITTLE", typeof(InvalidOrder) },
                    { "AMOUNT_TOO_MUCH", typeof(InvalidOrder) },
                    { "REPEATED_CREATION", typeof(InvalidOrder) },
                    { "LOAN_NOT_FOUND", typeof(OrderNotFound) },
                    { "LOAN_RECORD_NOT_FOUND", typeof(OrderNotFound) },
                    { "NO_MATCHED_LOAN", typeof(ExchangeError) },
                    { "NOT_MERGEABLE", typeof(ExchangeError) },
                    { "NO_CHANGE", typeof(ExchangeError) },
                    { "REPAY_TOO_MUCH", typeof(ExchangeError) },
                    { "TOO_MANY_CURRENCY_PAIRS", typeof(InvalidOrder) },
                    { "TOO_MANY_ORDERS", typeof(InvalidOrder) },
                    { "TOO_MANY_REQUESTS", typeof(RateLimitExceeded) },
                    { "MIXED_ACCOUNT_TYPE", typeof(InvalidOrder) },
                    { "AUTO_BORROW_TOO_MUCH", typeof(ExchangeError) },
                    { "TRADE_RESTRICTED", typeof(InsufficientFunds) },
                    { "USER_NOT_FOUND", typeof(AccountNotEnabled) },
                    { "CONTRACT_NO_COUNTER", typeof(ExchangeError) },
                    { "CONTRACT_NOT_FOUND", typeof(BadSymbol) },
                    { "RISK_LIMIT_EXCEEDED", typeof(ExchangeError) },
                    { "INSUFFICIENT_AVAILABLE", typeof(InsufficientFunds) },
                    { "LIQUIDATE_IMMEDIATELY", typeof(InvalidOrder) },
                    { "LEVERAGE_TOO_HIGH", typeof(InvalidOrder) },
                    { "LEVERAGE_TOO_LOW", typeof(InvalidOrder) },
                    { "ORDER_NOT_OWNED", typeof(ExchangeError) },
                    { "ORDER_FINISHED", typeof(ExchangeError) },
                    { "POSITION_CROSS_MARGIN", typeof(ExchangeError) },
                    { "POSITION_IN_LIQUIDATION", typeof(ExchangeError) },
                    { "POSITION_IN_CLOSE", typeof(ExchangeError) },
                    { "POSITION_EMPTY", typeof(InvalidOrder) },
                    { "REMOVE_TOO_MUCH", typeof(ExchangeError) },
                    { "RISK_LIMIT_NOT_MULTIPLE", typeof(ExchangeError) },
                    { "RISK_LIMIT_TOO_HIGH", typeof(ExchangeError) },
                    { "RISK_LIMIT_TOO_lOW", typeof(ExchangeError) },
                    { "PRICE_TOO_DEVIATED", typeof(InvalidOrder) },
                    { "SIZE_TOO_LARGE", typeof(InvalidOrder) },
                    { "SIZE_TOO_SMALL", typeof(InvalidOrder) },
                    { "PRICE_OVER_LIQUIDATION", typeof(InvalidOrder) },
                    { "PRICE_OVER_BANKRUPT", typeof(InvalidOrder) },
                    { "ORDER_POC_IMMEDIATE", typeof(OrderImmediatelyFillable) },
                    { "INCREASE_POSITION", typeof(InvalidOrder) },
                    { "CONTRACT_IN_DELISTING", typeof(ExchangeError) },
                    { "INTERNAL", typeof(ExchangeNotAvailable) },
                    { "SERVER_ERROR", typeof(ExchangeNotAvailable) },
                    { "TOO_BUSY", typeof(ExchangeNotAvailable) },
                    { "CROSS_ACCOUNT_NOT_FOUND", typeof(ExchangeError) },
                    { "RISK_LIMIT_TOO_LOW", typeof(BadRequest) },
                    { "AUTO_TRIGGER_PRICE_LESS_LAST", typeof(InvalidOrder) },
                    { "AUTO_TRIGGER_PRICE_GREATE_LAST", typeof(InvalidOrder) },
                    { "POSITION_HOLDING", typeof(BadRequest) },
                    { "USER_LOAN_EXCEEDED", typeof(BadRequest) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
        });
    }

    public override void setSandboxMode(object enable)
    {
        base.setSandboxMode(enable);
        ((IDictionary<string,object>)this.options)["sandboxMode"] = enable;
    }

    public override object createExpiredOptionMarket(object symbol)
    {
        // support expired option contracts
        object quote = "USDT";
        object settle = quote;
        object optionParts = ((string)symbol).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
        object symbolBase = ((string)symbol).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
        object marketIdBase = ((string)symbol).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
        object bs = null;
        object expiry = this.safeString(optionParts, 1);
        if (isTrue(isGreaterThan(getIndexOf(symbol, "/"), -1)))
        {
            bs = this.safeString(symbolBase, 0);
        } else
        {
            bs = this.safeString(marketIdBase, 0);
            expiry = slice(expiry, 2, 8); // convert 20230728 to 230728
        }
        object strike = this.safeString(optionParts, 2);
        object optionType = this.safeString(optionParts, 3);
        object datetime = this.convertExpireDate(expiry);
        object timestamp = this.parse8601(datetime);
        return new Dictionary<string, object>() {
            { "id", add(add(add(add(add(add(add(add(add(bs, "_"), quote), "-"), "20"), expiry), "-"), strike), "-"), optionType) },
            { "symbol", add(add(add(add(add(add(add(add(add(add(bs, "/"), quote), ":"), settle), "-"), expiry), "-"), strike), "-"), optionType) },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", bs },
            { "quoteId", quote },
            { "settleId", settle },
            { "active", false },
            { "type", "option" },
            { "linear", null },
            { "inverse", null },
            { "spot", false },
            { "swap", false },
            { "future", false },
            { "option", true },
            { "margin", false },
            { "contract", true },
            { "contractSize", this.parseNumber("1") },
            { "expiry", timestamp },
            { "expiryDatetime", datetime },
            { "optionType", ((bool) isTrue((isEqual(optionType, "C")))) ? "call" : "put" },
            { "strike", this.parseNumber(strike) },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.parseNumber("1") },
                { "price", null },
            } },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "info", null },
        };
    }

    public override object safeMarket(object marketId = null, object market = null, object delimiter = null, object marketType = null)
    {
        object isOption = isTrue((!isEqual(marketId, null))) && isTrue((isTrue((isGreaterThan(getIndexOf(marketId, "-C"), -1))) || isTrue((isGreaterThan(getIndexOf(marketId, "-P"), -1)))));
        if (isTrue(isTrue(isOption) && !isTrue((inOp(this.markets_by_id, marketId)))))
        {
            // handle expired option contracts
            return this.createExpiredOptionMarket(marketId);
        }
        return base.safeMarket(marketId, market, delimiter, marketType);
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchMarkets
        * @description retrieves data on all markets for gate
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-currency-pairs-supported                                     // spot
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-supported-currency-pairs-supported-in-margin-trading         // margin
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-futures-contracts                                            // swap
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-futures-contracts-2                                          // future
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-the-contracts-with-specified-underlying-and-expiration-time  // option
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object rawPromises = new List<object> {this.fetchContractMarkets(parameters), this.fetchOptionMarkets(parameters)};
        if (!isTrue(sandboxMode))
        {
            // gate does not have a sandbox for spot markets
            object mainnetOnly = new List<object> {this.fetchSpotMarkets(parameters)};
            rawPromises = this.arrayConcat(rawPromises, mainnetOnly);
        }
        object promises = await promiseAll(rawPromises);
        object spotMarkets = this.safeValue(promises, 0, new List<object>() {});
        object contractMarkets = this.safeValue(promises, 1, new List<object>() {});
        object optionMarkets = this.safeValue(promises, 2, new List<object>() {});
        object markets = this.arrayConcat(spotMarkets, contractMarkets);
        return this.arrayConcat(markets, optionMarkets);
    }

    public async virtual Task<object> fetchSpotMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object marginResponse = await this.publicMarginGetCurrencyPairs(parameters);
        object spotMarketsResponse = await this.publicSpotGetCurrencyPairs(parameters);
        object marginMarkets = this.indexBy(marginResponse, "id");
        //
        //  Spot
        //
        //     [
        //         {
        //             "id": "QTUM_ETH",
        //             "base": "QTUM",
        //             "quote": "ETH",
        //             "fee": "0.2",
        //             "min_base_amount": "0.01",
        //             "min_quote_amount": "0.001",
        //             "amount_precision": 3,
        //             "precision": 6,
        //             "trade_status": "tradable",
        //             "sell_start": 0,
        //             "buy_start": 0
        //         }
        //     ]
        //
        //  Margin
        //
        //     [
        //         {
        //             "id": "ETH_USDT",
        //             "base": "ETH",
        //             "quote": "USDT",
        //             "leverage": 3,
        //             "min_base_amount": "0.01",
        //             "min_quote_amount": "100",
        //             "max_quote_amount": "1000000"
        //         }
        //     ]
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(spotMarketsResponse)); postFixIncrement(ref i))
        {
            object spotMarket = getValue(spotMarketsResponse, i);
            object id = this.safeString(spotMarket, "id");
            object marginMarket = this.safeValue(marginMarkets, id);
            object market = this.deepExtend(marginMarket, spotMarket);
            var baseIdquoteIdVariable = ((string)id).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
            var baseId = ((IList<object>) baseIdquoteIdVariable)[0];
            var quoteId = ((IList<object>) baseIdquoteIdVariable)[1];
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object takerPercent = this.safeString(market, "fee");
            object makerPercent = this.safeString(market, "maker_fee_rate", takerPercent);
            object amountPrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "amount_precision")));
            object tradeStatus = this.safeString(market, "trade_status");
            object leverage = this.safeNumber(market, "leverage");
            object margin = !isEqual(leverage, null);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", margin },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", (isEqual(tradeStatus, "tradable")) },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", this.parseNumber(Precise.stringDiv(takerPercent, "100")) },
                { "maker", this.parseNumber(Precise.stringDiv(makerPercent, "100")) },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", amountPrecision },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "precision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.parseNumber("1") },
                        { "max", this.safeNumber(market, "leverage", 1) },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(spotMarket, "min_base_amount", amountPrecision) },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_quote_amount") },
                        { "max", ((bool) isTrue(margin)) ? this.safeNumber(market, "max_quote_amount") : null },
                    } },
                } },
                { "created", null },
                { "info", market },
            });
        }
        return result;
    }

    public async virtual Task<object> fetchContractMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object result = new List<object>() {};
        object swapSettlementCurrencies = this.getSettlementCurrencies("swap", "fetchMarkets");
        object futureSettlementCurrencies = this.getSettlementCurrencies("future", "fetchMarkets");
        for (object c = 0; isLessThan(c, getArrayLength(swapSettlementCurrencies)); postFixIncrement(ref c))
        {
            object settleId = getValue(swapSettlementCurrencies, c);
            object request = new Dictionary<string, object>() {
                { "settle", settleId },
            };
            object response = await this.publicFuturesGetSettleContracts(this.extend(request, parameters));
            for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
            {
                object parsedMarket = this.parseContractMarket(getValue(response, i), settleId);
                ((IList<object>)result).Add(parsedMarket);
            }
        }
        for (object c = 0; isLessThan(c, getArrayLength(futureSettlementCurrencies)); postFixIncrement(ref c))
        {
            object settleId = getValue(futureSettlementCurrencies, c);
            object request = new Dictionary<string, object>() {
                { "settle", settleId },
            };
            object response = await this.publicDeliveryGetSettleContracts(this.extend(request, parameters));
            for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
            {
                object parsedMarket = this.parseContractMarket(getValue(response, i), settleId);
                ((IList<object>)result).Add(parsedMarket);
            }
        }
        return result;
    }

    public virtual object parseContractMarket(object market, object settleId)
    {
        //
        //  Perpetual swap
        //
        //    {
        //        "name": "BTC_USDT",
        //        "type": "direct",
        //        "quanto_multiplier": "0.0001",
        //        "ref_discount_rate": "0",
        //        "order_price_deviate": "0.5",
        //        "maintenance_rate": "0.005",
        //        "mark_type": "index",
        //        "last_price": "38026",
        //        "mark_price": "37985.6",
        //        "index_price": "37954.92",
        //        "funding_rate_indicative": "0.000219",
        //        "mark_price_round": "0.01",
        //        "funding_offset": 0,
        //        "in_delisting": false,
        //        "risk_limit_base": "1000000",
        //        "interest_rate": "0.0003",
        //        "order_price_round": "0.1",
        //        "order_size_min": 1,
        //        "ref_rebate_rate": "0.2",
        //        "funding_interval": 28800,
        //        "risk_limit_step": "1000000",
        //        "leverage_min": "1",
        //        "leverage_max": "100",
        //        "risk_limit_max": "8000000",
        //        "maker_fee_rate": "-0.00025",
        //        "taker_fee_rate": "0.00075",
        //        "funding_rate": "0.002053",
        //        "order_size_max": 1000000,
        //        "funding_next_apply": 1610035200,
        //        "short_users": 977,
        //        "config_change_time": 1609899548,
        //        "trade_size": 28530850594,
        //        "position_size": 5223816,
        //        "long_users": 455,
        //        "funding_impact_value": "60000",
        //        "orders_limit": 50,
        //        "trade_id": 10851092,
        //        "orderbook_id": 2129638396
        //    }
        //
        //  Delivery Futures
        //
        //    {
        //        "name": "BTC_USDT_20200814",
        //        "underlying": "BTC_USDT",
        //        "cycle": "WEEKLY",
        //        "type": "direct",
        //        "quanto_multiplier": "0.0001",
        //        "mark_type": "index",
        //        "last_price": "9017",
        //        "mark_price": "9019",
        //        "index_price": "9005.3",
        //        "basis_rate": "0.185095",
        //        "basis_value": "13.7",
        //        "basis_impact_value": "100000",
        //        "settle_price": "0",
        //        "settle_price_interval": 60,
        //        "settle_price_duration": 1800,
        //        "settle_fee_rate": "0.0015",
        //        "expire_time": 1593763200,
        //        "order_price_round": "0.1",
        //        "mark_price_round": "0.1",
        //        "leverage_min": "1",
        //        "leverage_max": "100",
        //        "maintenance_rate": "1000000",
        //        "risk_limit_base": "140.726652109199",
        //        "risk_limit_step": "1000000",
        //        "risk_limit_max": "8000000",
        //        "maker_fee_rate": "-0.00025",
        //        "taker_fee_rate": "0.00075",
        //        "ref_discount_rate": "0",
        //        "ref_rebate_rate": "0.2",
        //        "order_price_deviate": "0.5",
        //        "order_size_min": 1,
        //        "order_size_max": 1000000,
        //        "orders_limit": 50,
        //        "orderbook_id": 63,
        //        "trade_id": 26,
        //        "trade_size": 435,
        //        "position_size": 130,
        //        "config_change_time": 1593158867,
        //        "in_delisting": false
        //    }
        //
        object id = this.safeString(market, "name");
        object parts = ((string)id).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
        object baseId = this.safeString(parts, 0);
        object quoteId = this.safeString(parts, 1);
        object date = this.safeString(parts, 2);
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object settle = this.safeCurrencyCode(settleId);
        object expiry = this.safeTimestamp(market, "expire_time");
        object symbol = "";
        object marketType = "swap";
        if (isTrue(!isEqual(date, null)))
        {
            symbol = add(add(add(add(add(add(bs, "/"), quote), ":"), settle), "-"), this.yymmdd(expiry, ""));
            marketType = "future";
        } else
        {
            symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
        }
        object priceDeviate = this.safeString(market, "order_price_deviate");
        object markPrice = this.safeString(market, "mark_price");
        object minMultiplier = Precise.stringSub("1", priceDeviate);
        object maxMultiplier = Precise.stringAdd("1", priceDeviate);
        object minPrice = Precise.stringMul(minMultiplier, markPrice);
        object maxPrice = Precise.stringMul(maxMultiplier, markPrice);
        object takerPercent = this.safeString(market, "taker_fee_rate");
        object makerPercent = this.safeString(market, "maker_fee_rate", takerPercent);
        object isLinear = isEqual(quote, settle);
        return new Dictionary<string, object>() {
            { "id", id },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", marketType },
            { "spot", false },
            { "margin", false },
            { "swap", isEqual(marketType, "swap") },
            { "future", isEqual(marketType, "future") },
            { "option", isEqual(marketType, "option") },
            { "active", true },
            { "contract", true },
            { "linear", isLinear },
            { "inverse", !isTrue(isLinear) },
            { "taker", this.parseNumber(Precise.stringDiv(takerPercent, "100")) },
            { "maker", this.parseNumber(Precise.stringDiv(makerPercent, "100")) },
            { "contractSize", this.safeNumber(market, "quanto_multiplier") },
            { "expiry", expiry },
            { "expiryDatetime", this.iso8601(expiry) },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.parseNumber("1") },
                { "price", this.safeNumber(market, "order_price_round") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "leverage_min") },
                    { "max", this.safeNumber(market, "leverage_max") },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "order_size_min") },
                    { "max", this.safeNumber(market, "order_size_max") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", this.parseNumber(minPrice) },
                    { "max", this.parseNumber(maxPrice) },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        };
    }

    public async virtual Task<object> fetchOptionMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object result = new List<object>() {};
        object underlyings = await this.fetchOptionUnderlyings();
        for (object i = 0; isLessThan(i, getArrayLength(underlyings)); postFixIncrement(ref i))
        {
            object underlying = getValue(underlyings, i);
            object query = this.extend(new Dictionary<string, object>() {}, parameters);
            ((IDictionary<string,object>)query)["underlying"] = underlying;
            object response = await this.publicOptionsGetContracts(query);
            //
            //    [
            //        {
            //            "orders_limit": "50",
            //            "order_size_max": "100000",
            //            "mark_price_round": "0.1",
            //            "order_size_min": "1",
            //            "position_limit": "1000000",
            //            "orderbook_id": "575967",
            //            "order_price_deviate": "0.9",
            //            "is_call": true, // true means Call false means Put
            //            "last_price": "93.9",
            //            "bid1_size": "0",
            //            "bid1_price": "0",
            //            "taker_fee_rate": "0.0004",
            //            "underlying": "BTC_USDT",
            //            "create_time": "1646381188",
            //            "price_limit_fee_rate": "0.1",
            //            "maker_fee_rate": "0.0004",
            //            "trade_id": "727",
            //            "order_price_round": "0.1",
            //            "settle_fee_rate": "0.0001",
            //            "trade_size": "1982",
            //            "ref_rebate_rate": "0",
            //            "name": "BTC_USDT-20220311-44000-C",
            //            "underlying_price": "39194.26",
            //            "strike_price": "44000",
            //            "multiplier": "0.0001",
            //            "ask1_price": "0",
            //            "ref_discount_rate": "0",
            //            "expiration_time": "1646985600",
            //            "mark_price": "12.15",
            //            "position_size": "4",
            //            "ask1_size": "0",
            //            "tag": "WEEK"
            //        }
            //    ]
            //
            for (object j = 0; isLessThan(j, getArrayLength(response)); postFixIncrement(ref j))
            {
                object market = getValue(response, j);
                object id = this.safeString(market, "name");
                object parts = ((string)underlying).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
                object baseId = this.safeString(parts, 0);
                object quoteId = this.safeString(parts, 1);
                object bs = this.safeCurrencyCode(baseId);
                object quote = this.safeCurrencyCode(quoteId);
                object symbol = add(add(bs, "/"), quote);
                object expiry = this.safeTimestamp(market, "expiration_time");
                object strike = this.safeString(market, "strike_price");
                object isCall = this.safeValue(market, "is_call");
                object optionLetter = ((bool) isTrue(isCall)) ? "C" : "P";
                object optionType = ((bool) isTrue(isCall)) ? "call" : "put";
                symbol = add(add(add(add(add(add(add(add(symbol, ":"), quote), "-"), this.yymmdd(expiry)), "-"), strike), "-"), optionLetter);
                object priceDeviate = this.safeString(market, "order_price_deviate");
                object markPrice = this.safeString(market, "mark_price");
                object minMultiplier = Precise.stringSub("1", priceDeviate);
                object maxMultiplier = Precise.stringAdd("1", priceDeviate);
                object minPrice = Precise.stringMul(minMultiplier, markPrice);
                object maxPrice = Precise.stringMul(maxMultiplier, markPrice);
                object takerPercent = this.safeString(market, "taker_fee_rate");
                object makerPercent = this.safeString(market, "maker_fee_rate", takerPercent);
                ((IList<object>)result).Add(new Dictionary<string, object>() {
                    { "id", id },
                    { "symbol", symbol },
                    { "base", bs },
                    { "quote", quote },
                    { "settle", quote },
                    { "baseId", baseId },
                    { "quoteId", quoteId },
                    { "settleId", quoteId },
                    { "type", "option" },
                    { "spot", false },
                    { "margin", false },
                    { "swap", false },
                    { "future", false },
                    { "option", true },
                    { "active", true },
                    { "contract", true },
                    { "linear", true },
                    { "inverse", false },
                    { "taker", this.parseNumber(Precise.stringDiv(takerPercent, "100")) },
                    { "maker", this.parseNumber(Precise.stringDiv(makerPercent, "100")) },
                    { "contractSize", this.parseNumber("1") },
                    { "expiry", expiry },
                    { "expiryDatetime", this.iso8601(expiry) },
                    { "strike", strike },
                    { "optionType", optionType },
                    { "precision", new Dictionary<string, object>() {
                        { "amount", this.parseNumber("1") },
                        { "price", this.safeNumber(market, "order_price_round") },
                    } },
                    { "limits", new Dictionary<string, object>() {
                        { "leverage", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "amount", new Dictionary<string, object>() {
                            { "min", this.safeNumber(market, "order_size_min") },
                            { "max", this.safeNumber(market, "order_size_max") },
                        } },
                        { "price", new Dictionary<string, object>() {
                            { "min", this.parseNumber(minPrice) },
                            { "max", this.parseNumber(maxPrice) },
                        } },
                        { "cost", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                    } },
                    { "created", this.safeTimestamp(market, "create_time") },
                    { "info", market },
                });
            }
        }
        return result;
    }

    public async virtual Task<object> fetchOptionUnderlyings()
    {
        object underlyingsResponse = await this.publicOptionsGetUnderlyings();
        //
        //    [
        //        {
        //            "index_time": "1646915796",
        //            "name": "BTC_USDT",
        //            "index_price": "39142.73"
        //        }
        //    ]
        //
        object underlyings = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(underlyingsResponse)); postFixIncrement(ref i))
        {
            object underlying = getValue(underlyingsResponse, i);
            object name = this.safeString(underlying, "name");
            if (isTrue(!isEqual(name, null)))
            {
                ((IList<object>)underlyings).Add(name);
            }
        }
        return underlyings;
    }

    public virtual object prepareRequest(object market = null, object type = null, object parameters = null)
    {
        /**
        * @ignore
        * @method
        * @name gate#prepareRequest
        * @description Fills request params contract, settle, currency_pair, market and account where applicable
        * @param {object} market CCXT market, required when type is undefined
        * @param {string} type 'spot', 'swap', or 'future', required when market is undefined
        * @param {object} [params] request parameters
        * @returns the api request object, and the new params object with non-needed parameters removed
        */
        // * Do not call for multi spot order methods like cancelAllOrders and fetchOpenOrders. Use multiOrderSpotPrepareRequest instead
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(market, null)))
        {
            if (isTrue(getValue(market, "contract")))
            {
                ((IDictionary<string,object>)request)["contract"] = getValue(market, "id");
                if (!isTrue(getValue(market, "option")))
                {
                    ((IDictionary<string,object>)request)["settle"] = getValue(market, "settleId");
                }
            } else
            {
                ((IDictionary<string,object>)request)["currency_pair"] = getValue(market, "id");
            }
        } else
        {
            object swap = isEqual(type, "swap");
            object future = isEqual(type, "future");
            if (isTrue(isTrue(swap) || isTrue(future)))
            {
                object defaultSettle = ((bool) isTrue(swap)) ? "usdt" : "btc";
                object settle = this.safeStringLower(parameters, "settle", defaultSettle);
                parameters = this.omit(parameters, "settle");
                ((IDictionary<string,object>)request)["settle"] = settle;
            }
        }
        return new List<object>() {request, parameters};
    }

    public virtual object spotOrderPrepareRequest(object market = null, object stop = null, object parameters = null)
    {
        /**
        * @ignore
        * @method
        * @name gate#multiOrderSpotPrepareRequest
        * @description Fills request params currency_pair, market and account where applicable for spot order methods like fetchOpenOrders, cancelAllOrders
        * @param {object} market CCXT market
        * @param {bool} stop true if for a stop order
        * @param {object} [params] request parameters
        * @returns the api request object, and the new params object with non-needed parameters removed
        */
        stop ??= false;
        parameters ??= new Dictionary<string, object>();
        var marginModequeryVariable = this.getMarginMode(stop, parameters);
        var marginMode = ((IList<object>) marginModequeryVariable)[0];
        var query = ((IList<object>) marginModequeryVariable)[1];
        object request = new Dictionary<string, object>() {};
        if (!isTrue(stop))
        {
            if (isTrue(isEqual(market, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " spotOrderPrepareRequest() requires a market argument for non-stop orders")) ;
            }
            ((IDictionary<string,object>)request)["account"] = marginMode;
            ((IDictionary<string,object>)request)["currency_pair"] = getValue(market, "id"); // Should always be set for non-stop
        }
        return new List<object>() {request, query};
    }

    public virtual object multiOrderSpotPrepareRequest(object market = null, object stop = null, object parameters = null)
    {
        /**
        * @ignore
        * @method
        * @name gate#multiOrderSpotPrepareRequest
        * @description Fills request params currency_pair, market and account where applicable for spot order methods like fetchOpenOrders, cancelAllOrders
        * @param {object} market CCXT market
        * @param {bool} stop true if for a stop order
        * @param {object} [params] request parameters
        * @returns the api request object, and the new params object with non-needed parameters removed
        */
        stop ??= false;
        parameters ??= new Dictionary<string, object>();
        var marginModequeryVariable = this.getMarginMode(stop, parameters);
        var marginMode = ((IList<object>) marginModequeryVariable)[0];
        var query = ((IList<object>) marginModequeryVariable)[1];
        object request = new Dictionary<string, object>() {
            { "account", marginMode },
        };
        if (isTrue(!isEqual(market, null)))
        {
            if (isTrue(stop))
            {
                // gate spot and margin stop orders use the term market instead of currency_pair, and normal instead of spot. Neither parameter is used when fetching/cancelling a single order. They are used for creating a single stop order, but createOrder does not call this method
                ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
            } else
            {
                ((IDictionary<string,object>)request)["currency_pair"] = getValue(market, "id");
            }
        }
        return new List<object>() {request, query};
    }

    public virtual object getMarginMode(object stop, object parameters)
    {
        /**
         * @ignore
         * @method
         * @name gate#getMarginMode
         * @description Gets the margin type for this api call
         * @param {bool} stop True if for a stop order
         * @param {object} [params] Request params
         * @returns The marginMode and the updated request params with marginMode removed, marginMode value is the value that can be read by the "account" property specified in gates api docs
         */
        object defaultMarginMode = this.safeStringLower2(this.options, "defaultMarginMode", "marginMode", "spot"); // 'margin' is isolated margin on gate's api
        object marginMode = this.safeStringLower2(parameters, "marginMode", "account", defaultMarginMode);
        parameters = this.omit(parameters, new List<object>() {"marginMode", "account"});
        if (isTrue(isEqual(marginMode, "cross")))
        {
            marginMode = "cross_margin";
        } else if (isTrue(isEqual(marginMode, "isolated")))
        {
            marginMode = "margin";
        } else if (isTrue(isEqual(marginMode, "")))
        {
            marginMode = "spot";
        }
        if (isTrue(stop))
        {
            if (isTrue(isEqual(marginMode, "spot")))
            {
                // gate spot stop orders use the term normal instead of spot
                marginMode = "normal";
            }
            if (isTrue(isEqual(marginMode, "cross_margin")))
            {
                throw new BadRequest ((string)add(this.id, " getMarginMode() does not support stop orders for cross margin")) ;
            }
        }
        return new List<object>() {marginMode, parameters};
    }

    public virtual object getSettlementCurrencies(object type, object method)
    {
        object options = this.safeValue(this.options, type, new Dictionary<string, object>() {}); // [ 'BTC', 'USDT' ] unified codes
        object fetchMarketsContractOptions = this.safeValue(options, method, new Dictionary<string, object>() {});
        object defaultSettle = ((bool) isTrue((isEqual(type, "swap")))) ? new List<object>() {"usdt"} : new List<object>() {"btc"};
        return this.safeValue(fetchMarketsContractOptions, "settlementCurrencies", defaultSettle);
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-currencies-details
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        // sandbox/testnet only supports future markets
        parameters ??= new Dictionary<string, object>();
        object apiBackup = this.safeValue(this.urls, "apiBackup");
        if (isTrue(!isEqual(apiBackup, null)))
        {
            return null;
        }
        object response = await this.publicSpotGetCurrencies(parameters);
        //
        //    {
        //        "currency": "BCN",
        //        "delisted": false,
        //        "withdraw_disabled": true,
        //        "withdraw_delayed": false,
        //        "deposit_disabled": true,
        //        "trade_disabled": false
        //    }
        //
        //    {
        //        "currency":"USDT_ETH",
        //        "delisted":false,
        //        "withdraw_disabled":false,
        //        "withdraw_delayed":false,
        //        "deposit_disabled":false,
        //        "trade_disabled":false,
        //        "chain":"ETH"
        //    }
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object currencyId = this.safeString(entry, "currency");
            object currencyIdLower = this.safeStringLower(entry, "currency");
            object parts = ((string)currencyId).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
            object currency = getValue(parts, 0);
            object code = this.safeCurrencyCode(currency);
            object networkId = this.safeString(entry, "chain");
            object networkCode = null;
            if (isTrue(!isEqual(networkId, null)))
            {
                networkCode = this.networkIdToCode(networkId, code);
            }
            object delisted = this.safeValue(entry, "delisted");
            object withdrawDisabled = this.safeBool(entry, "withdraw_disabled", false);
            object depositDisabled = this.safeBool(entry, "deposit_disabled", false);
            object tradeDisabled = this.safeBool(entry, "trade_disabled", false);
            object withdrawEnabled = !isTrue(withdrawDisabled);
            object depositEnabled = !isTrue(depositDisabled);
            object tradeEnabled = !isTrue(tradeDisabled);
            object listed = !isTrue(delisted);
            object active = isTrue(isTrue(isTrue(listed) && isTrue(tradeEnabled)) && isTrue(withdrawEnabled)) && isTrue(depositEnabled);
            if (isTrue(isEqual(this.safeValue(result, code), null)))
            {
                ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                    { "id", ((string)code).ToLower() },
                    { "code", code },
                    { "info", null },
                    { "name", null },
                    { "active", active },
                    { "deposit", depositEnabled },
                    { "withdraw", withdrawEnabled },
                    { "fee", null },
                    { "fees", new List<object>() {} },
                    { "precision", this.parseNumber("1e-4") },
                    { "limits", this.limits },
                    { "networks", new Dictionary<string, object>() {} },
                };
            }
            object depositAvailable = this.safeValue(getValue(result, code), "deposit");
            depositAvailable = ((bool) isTrue((depositEnabled))) ? depositEnabled : depositAvailable;
            object withdrawAvailable = this.safeValue(getValue(result, code), "withdraw");
            withdrawAvailable = ((bool) isTrue((withdrawEnabled))) ? withdrawEnabled : withdrawAvailable;
            object networks = this.safeValue(getValue(result, code), "networks", new Dictionary<string, object>() {});
            if (isTrue(!isEqual(networkCode, null)))
            {
                ((IDictionary<string,object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                    { "info", entry },
                    { "id", networkId },
                    { "network", networkCode },
                    { "currencyId", currencyId },
                    { "lowerCaseCurrencyId", currencyIdLower },
                    { "deposit", depositEnabled },
                    { "withdraw", withdrawEnabled },
                    { "active", active },
                    { "fee", null },
                    { "precision", this.parseNumber("1e-4") },
                    { "limits", new Dictionary<string, object>() {
                        { "amount", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                    } },
                };
            }
            ((IDictionary<string,object>)getValue(result, code))["networks"] = networks;
            object info = this.safeValue(getValue(result, code), "info", new List<object>() {});
            ((IList<object>)info).Add(entry);
            ((IDictionary<string,object>)getValue(result, code))["info"] = info;
            ((IDictionary<string,object>)getValue(result, code))["active"] = isTrue(depositAvailable) && isTrue(withdrawAvailable);
            ((IDictionary<string,object>)getValue(result, code))["deposit"] = depositAvailable;
            ((IDictionary<string,object>)getValue(result, code))["withdraw"] = withdrawAvailable;
        }
        return result;
    }

    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchFundingRate
        * @description fetch the current funding rate
        * @see https://www.gate.io/docs/developers/apiv4/en/#get-a-single-contract
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRate() supports swap contracts only")) ;
        }
        var requestqueryVariable = this.prepareRequest(market, null, parameters);
        var request = ((IList<object>) requestqueryVariable)[0];
        var query = ((IList<object>) requestqueryVariable)[1];
        object response = await this.publicFuturesGetSettleContractsContract(this.extend(request, query));
        //
        //    [
        //        {
        //            "name": "BTC_USDT",
        //            "type": "direct",
        //            "quanto_multiplier": "0.0001",
        //            "ref_discount_rate": "0",
        //            "order_price_deviate": "0.5",
        //            "maintenance_rate": "0.005",
        //            "mark_type": "index",
        //            "last_price": "38026",
        //            "mark_price": "37985.6",
        //            "index_price": "37954.92",
        //            "funding_rate_indicative": "0.000219",
        //            "mark_price_round": "0.01",
        //            "funding_offset": 0,
        //            "in_delisting": false,
        //            "risk_limit_base": "1000000",
        //            "interest_rate": "0.0003",
        //            "order_price_round": "0.1",
        //            "order_size_min": 1,
        //            "ref_rebate_rate": "0.2",
        //            "funding_interval": 28800,
        //            "risk_limit_step": "1000000",
        //            "leverage_min": "1",
        //            "leverage_max": "100",
        //            "risk_limit_max": "8000000",
        //            "maker_fee_rate": "-0.00025",
        //            "taker_fee_rate": "0.00075",
        //            "funding_rate": "0.002053",
        //            "order_size_max": 1000000,
        //            "funding_next_apply": 1610035200,
        //            "short_users": 977,
        //            "config_change_time": 1609899548,
        //            "trade_size": 28530850594,
        //            "position_size": 5223816,
        //            "long_users": 455,
        //            "funding_impact_value": "60000",
        //            "orders_limit": 50,
        //            "trade_id": 10851092,
        //            "orderbook_id": 2129638396
        //        }
        //    ]
        //
        return this.parseFundingRate(response);
    }

    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchFundingRates
        * @description fetch the funding rate for multiple markets
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-futures-contracts
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [funding rates structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexe by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        var requestqueryVariable = this.prepareRequest(null, "swap", parameters);
        var request = ((IList<object>) requestqueryVariable)[0];
        var query = ((IList<object>) requestqueryVariable)[1];
        object response = await this.publicFuturesGetSettleContracts(this.extend(request, query));
        //
        //    [
        //        {
        //            "name": "BTC_USDT",
        //            "type": "direct",
        //            "quanto_multiplier": "0.0001",
        //            "ref_discount_rate": "0",
        //            "order_price_deviate": "0.5",
        //            "maintenance_rate": "0.005",
        //            "mark_type": "index",
        //            "last_price": "38026",
        //            "mark_price": "37985.6",
        //            "index_price": "37954.92",
        //            "funding_rate_indicative": "0.000219",
        //            "mark_price_round": "0.01",
        //            "funding_offset": 0,
        //            "in_delisting": false,
        //            "risk_limit_base": "1000000",
        //            "interest_rate": "0.0003",
        //            "order_price_round": "0.1",
        //            "order_size_min": 1,
        //            "ref_rebate_rate": "0.2",
        //            "funding_interval": 28800,
        //            "risk_limit_step": "1000000",
        //            "leverage_min": "1",
        //            "leverage_max": "100",
        //            "risk_limit_max": "8000000",
        //            "maker_fee_rate": "-0.00025",
        //            "taker_fee_rate": "0.00075",
        //            "funding_rate": "0.002053",
        //            "order_size_max": 1000000,
        //            "funding_next_apply": 1610035200,
        //            "short_users": 977,
        //            "config_change_time": 1609899548,
        //            "trade_size": 28530850594,
        //            "position_size": 5223816,
        //            "long_users": 455,
        //            "funding_impact_value": "60000",
        //            "orders_limit": 50,
        //            "trade_id": 10851092,
        //            "orderbook_id": 2129638396
        //        }
        //    ]
        //
        object result = this.parseFundingRates(response);
        return this.filterByArray(result, "symbol", symbols);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //    {
        //        "name": "BTC_USDT",
        //        "type": "direct",
        //        "quanto_multiplier": "0.0001",
        //        "ref_discount_rate": "0",
        //        "order_price_deviate": "0.5",
        //        "maintenance_rate": "0.005",
        //        "mark_type": "index",
        //        "last_price": "38026",
        //        "mark_price": "37985.6",
        //        "index_price": "37954.92",
        //        "funding_rate_indicative": "0.000219",
        //        "mark_price_round": "0.01",
        //        "funding_offset": 0,
        //        "in_delisting": false,
        //        "risk_limit_base": "1000000",
        //        "interest_rate": "0.0003",
        //        "order_price_round": "0.1",
        //        "order_size_min": 1,
        //        "ref_rebate_rate": "0.2",
        //        "funding_interval": 28800,
        //        "risk_limit_step": "1000000",
        //        "leverage_min": "1",
        //        "leverage_max": "100",
        //        "risk_limit_max": "8000000",
        //        "maker_fee_rate": "-0.00025",
        //        "taker_fee_rate": "0.00075",
        //        "funding_rate": "0.002053",
        //        "order_size_max": 1000000,
        //        "funding_next_apply": 1610035200,
        //        "short_users": 977,
        //        "config_change_time": 1609899548,
        //        "trade_size": 28530850594,
        //        "position_size": 5223816,
        //        "long_users": 455,
        //        "funding_impact_value": "60000",
        //        "orders_limit": 50,
        //        "trade_id": 10851092,
        //        "orderbook_id": 2129638396
        //    }
        //
        object marketId = this.safeString(contract, "name");
        object symbol = this.safeSymbol(marketId, market, "_", "swap");
        object markPrice = this.safeNumber(contract, "mark_price");
        object indexPrice = this.safeNumber(contract, "index_price");
        object interestRate = this.safeNumber(contract, "interest_rate");
        object fundingRate = this.safeNumber(contract, "funding_rate");
        object fundingTime = this.safeTimestamp(contract, "funding_next_apply");
        object fundingRateIndicative = this.safeNumber(contract, "funding_rate_indicative");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", markPrice },
            { "indexPrice", indexPrice },
            { "interestRate", interestRate },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", fundingRate },
            { "fundingTimestamp", fundingTime },
            { "fundingDatetime", this.iso8601(fundingTime) },
            { "nextFundingRate", fundingRateIndicative },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public async virtual Task<object> fetchNetworkDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.privateWalletGetDepositAddress(this.extend(request, parameters));
        object addresses = this.safeValue(response, "multichain_addresses");
        object currencyId = this.safeString(response, "currency");
        code = this.safeCurrencyCode(currencyId);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(addresses)); postFixIncrement(ref i))
        {
            object entry = getValue(addresses, i);
            //
            //    {
            //        "chain": "ETH",
            //        "address": "0x359a697945E79C7e17b634675BD73B33324E9408",
            //        "payment_id": "",
            //        "payment_name": "",
            //        "obtain_failed": "0"
            //    }
            //
            object obtainFailed = this.safeInteger(entry, "obtain_failed");
            if (isTrue(obtainFailed))
            {
                continue;
            }
            object network = this.safeString(entry, "chain");
            object address = this.safeString(entry, "address");
            object tag = this.safeString(entry, "payment_id");
            ((IDictionary<string,object>)result)[(string)network] = new Dictionary<string, object>() {
                { "info", entry },
                { "code", code },
                { "currency", code },
                { "address", address },
                { "tag", tag },
            };
        }
        return result;
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://www.gate.io/docs/developers/apiv4/en/#generate-currency-deposit-address
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.network] unified network code (not used directly by gate.io but used by ccxt to filter the response)
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object rawNetwork = this.safeStringUpper(parameters, "network");
        parameters = this.omit(parameters, "network");
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.privateWalletGetDepositAddress(this.extend(request, parameters));
        //
        //    {
        //        "currency": "XRP",
        //        "address": "rHcFoo6a9qT5NHiVn1THQRhsEGcxtYCV4d 391331007",
        //        "multichain_addresses": [
        //            {
        //                "chain": "XRP",
        //                "address": "rHcFoo6a9qT5NHiVn1THQRhsEGcxtYCV4d",
        //                "payment_id": "391331007",
        //                "payment_name": "Tag",
        //                "obtain_failed": 0
        //            }
        //        ]
        //    }
        //
        object currencyId = this.safeString(response, "currency");
        code = this.safeCurrencyCode(currencyId);
        object networkId = this.networkCodeToId(rawNetwork, code);
        object network = null;
        object tag = null;
        object address = null;
        if (isTrue(!isEqual(networkId, null)))
        {
            object addresses = this.safeValue(response, "multichain_addresses");
            for (object i = 0; isLessThan(i, getArrayLength(addresses)); postFixIncrement(ref i))
            {
                object entry = getValue(addresses, i);
                object entryNetwork = this.safeString(entry, "chain");
                if (isTrue(isEqual(networkId, entryNetwork)))
                {
                    object obtainFailed = this.safeInteger(entry, "obtain_failed");
                    if (isTrue(obtainFailed))
                    {
                        break;
                    }
                    address = this.safeString(entry, "address");
                    tag = this.safeString(entry, "payment_id");
                    network = this.networkIdToCode(networkId, code);
                    break;
                }
            }
        } else
        {
            object addressField = this.safeString(response, "address");
            if (isTrue(!isEqual(addressField, null)))
            {
                if (isTrue(isGreaterThanOrEqual(getIndexOf(addressField, "New address is being generated for you, please wait"), 0)))
                {
                    throw new BadResponse ((string)add(add(this.id, " "), "New address is being generated for you, please wait a few seconds and try again to get the address.")) ;
                }
                if (isTrue(isGreaterThanOrEqual(getIndexOf(addressField, " "), 0)))
                {
                    object splitted = ((string)addressField).Split(new [] {((string)" ")}, StringSplitOptions.None).ToList<object>();
                    address = getValue(splitted, 0);
                    tag = getValue(splitted, 1);
                } else
                {
                    address = addressField;
                }
            }
        }
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "info", response },
            { "code", code },
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", network },
        };
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchTradingFee
        * @description fetch the trading fees for a market
        * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-personal-trading-fee
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "currency_pair", getValue(market, "id") },
        };
        object response = await this.privateWalletGetFee(this.extend(request, parameters));
        //
        //    {
        //        "user_id": 1486602,
        //        "taker_fee": "0.002",
        //        "maker_fee": "0.002",
        //        "gt_discount": true,
        //        "gt_taker_fee": "0.0015",
        //        "gt_maker_fee": "0.0015",
        //        "loan_fee": "0.18",
        //        "point_type": "0",
        //        "futures_taker_fee": "0.0005",
        //        "futures_maker_fee": "0"
        //    }
        //
        return this.parseTradingFee(response, market);
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-personal-trading-fee
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateWalletGetFee(parameters);
        //
        //    {
        //        "user_id": 1486602,
        //        "taker_fee": "0.002",
        //        "maker_fee": "0.002",
        //        "gt_discount": true,
        //        "gt_taker_fee": "0.0015",
        //        "gt_maker_fee": "0.0015",
        //        "loan_fee": "0.18",
        //        "point_type": "0",
        //        "futures_taker_fee": "0.0005",
        //        "futures_maker_fee": "0"
        //    }
        //
        return this.parseTradingFees(response);
    }

    public virtual object parseTradingFees(object response)
    {
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(this.symbols, i);
            object market = this.market(symbol);
            ((IDictionary<string,object>)result)[(string)symbol] = this.parseTradingFee(response, market);
        }
        return result;
    }

    public virtual object parseTradingFee(object info, object market = null)
    {
        //
        //    {
        //        "user_id": 1486602,
        //        "taker_fee": "0.002",
        //        "maker_fee": "0.002",
        //        "gt_discount": true,
        //        "gt_taker_fee": "0.0015",
        //        "gt_maker_fee": "0.0015",
        //        "loan_fee": "0.18",
        //        "point_type": "0",
        //        "futures_taker_fee": "0.0005",
        //        "futures_maker_fee": "0"
        //    }
        //
        object gtDiscount = this.safeValue(info, "gt_discount");
        object taker = ((bool) isTrue(gtDiscount)) ? "gt_taker_fee" : "taker_fee";
        object maker = ((bool) isTrue(gtDiscount)) ? "gt_maker_fee" : "maker_fee";
        object contract = this.safeValue(market, "contract");
        object takerKey = ((bool) isTrue(contract)) ? "futures_taker_fee" : taker;
        object makerKey = ((bool) isTrue(contract)) ? "futures_maker_fee" : maker;
        return new Dictionary<string, object>() {
            { "info", info },
            { "symbol", this.safeString(market, "symbol") },
            { "maker", this.safeNumber(info, makerKey) },
            { "taker", this.safeNumber(info, takerKey) },
            { "percentage", null },
            { "tierBased", null },
        };
    }

    public async override Task<object> fetchTransactionFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchTransactionFees
        * @deprecated
        * @description please use fetchDepositWithdrawFees instead
        * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-withdrawal-status
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateWalletGetWithdrawStatus(parameters);
        //
        //    {
        //        "currency": "MTN",
        //        "name": "Medicalchain",
        //        "name_cn": "Medicalchain",
        //        "deposit": "0",
        //        "withdraw_percent": "0%",
        //        "withdraw_fix": "900",
        //        "withdraw_day_limit": "500000",
        //        "withdraw_day_limit_remain": "500000",
        //        "withdraw_amount_mini": "900.1",
        //        "withdraw_eachtime_limit": "90000000000",
        //        "withdraw_fix_on_chains": {
        //            "ETH": "900"
        //        }
        //    }
        //
        object result = new Dictionary<string, object>() {};
        object withdrawFees = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            withdrawFees = new Dictionary<string, object>() {};
            object entry = getValue(response, i);
            object currencyId = this.safeString(entry, "currency");
            object code = this.safeCurrencyCode(currencyId);
            if (isTrue(isTrue((!isEqual(codes, null))) && !isTrue(this.inArray(code, codes))))
            {
                continue;
            }
            object withdrawFixOnChains = this.safeValue(entry, "withdraw_fix_on_chains");
            if (isTrue(isEqual(withdrawFixOnChains, null)))
            {
                withdrawFees = this.safeNumber(entry, "withdraw_fix");
            } else
            {
                object chainKeys = new List<object>(((IDictionary<string,object>)withdrawFixOnChains).Keys);
                for (object j = 0; isLessThan(j, getArrayLength(chainKeys)); postFixIncrement(ref j))
                {
                    object chainKey = getValue(chainKeys, j);
                    ((IDictionary<string,object>)withdrawFees)[(string)chainKey] = this.parseNumber(getValue(withdrawFixOnChains, chainKey));
                }
            }
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "withdraw", withdrawFees },
                { "deposit", null },
                { "info", entry },
            };
        }
        return result;
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-withdrawal-status
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateWalletGetWithdrawStatus(parameters);
        //
        //    [
        //        {
        //            "currency": "MTN",
        //            "name": "Medicalchain",
        //            "name_cn": "Medicalchain",
        //            "deposit": "0",
        //            "withdraw_percent": "0%",
        //            "withdraw_fix": "900",
        //            "withdraw_day_limit": "500000",
        //            "withdraw_day_limit_remain": "500000",
        //            "withdraw_amount_mini": "900.1",
        //            "withdraw_eachtime_limit": "90000000000",
        //            "withdraw_fix_on_chains": {
        //                "ETH": "900"
        //            }
        //        }
        //    ]
        //
        return this.parseDepositWithdrawFees(response, codes, "currency");
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //    {
        //        "currency": "MTN",
        //        "name": "Medicalchain",
        //        "name_cn": "Medicalchain",
        //        "deposit": "0",
        //        "withdraw_percent": "0%",
        //        "withdraw_fix": "900",
        //        "withdraw_day_limit": "500000",
        //        "withdraw_day_limit_remain": "500000",
        //        "withdraw_amount_mini": "900.1",
        //        "withdraw_eachtime_limit": "90000000000",
        //        "withdraw_fix_on_chains": {
        //            "ETH": "900"
        //        }
        //    }
        //
        object withdrawFixOnChains = this.safeValue(fee, "withdraw_fix_on_chains");
        object result = new Dictionary<string, object>() {
            { "info", fee },
            { "withdraw", new Dictionary<string, object>() {
                { "fee", this.safeNumber(fee, "withdraw_fix") },
                { "percentage", false },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", this.safeNumber(fee, "deposit") },
                { "percentage", false },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
        if (isTrue(!isEqual(withdrawFixOnChains, null)))
        {
            object chainKeys = new List<object>(((IDictionary<string,object>)withdrawFixOnChains).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(chainKeys)); postFixIncrement(ref i))
            {
                object chainKey = getValue(chainKeys, i);
                ((IDictionary<string,object>)getValue(result, "networks"))[(string)chainKey] = new Dictionary<string, object>() {
                    { "withdraw", new Dictionary<string, object>() {
                        { "fee", this.parseNumber(getValue(withdrawFixOnChains, chainKey)) },
                        { "percentage", false },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "fee", null },
                        { "percentage", null },
                    } },
                };
            }
        }
        return result;
    }

    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchFundingHistory
        * @description fetch the history of funding payments paid and received on this account
        * @see https://www.gate.io/docs/developers/apiv4/en/#query-account-book-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#query-account-book-3
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch funding history for
        * @param {int} [limit] the maximum number of funding history structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        // let defaultType = 'future';
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        var typequeryVariable = this.handleMarketTypeAndParams("fetchFundingHistory", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        var requestrequestParamsVariable = this.prepareRequest(market, type, query);
        var request = ((IList<object>) requestrequestParamsVariable)[0];
        var requestParams = ((IList<object>) requestrequestParamsVariable)[1];
        ((IDictionary<string,object>)request)["type"] = "fund"; // 'dnw' 'pnl' 'fee' 'refr' 'fund' 'point_dnw' 'point_fee' 'point_refr'
        if (isTrue(!isEqual(since, null)))
        {
            // from should be integer
            ((IDictionary<string,object>)request)["from"] = this.parseToInt(divide(since, 1000));
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(isEqual(type, "swap")))
        {
            response = await this.privateFuturesGetSettleAccountBook(this.extend(request, requestParams));
        } else if (isTrue(isEqual(type, "future")))
        {
            response = await this.privateDeliveryGetSettleAccountBook(this.extend(request, requestParams));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchFundingHistory() only support swap & future market type")) ;
        }
        //
        //    [
        //        {
        //            "time": 1646899200,
        //            "change": "-0.027722",
        //            "balance": "11.653120591841",
        //            "text": "XRP_USDT",
        //            "type": "fund"
        //        },
        //        ...
        //    ]
        //
        return this.parseFundingHistories(response, symbol, since, limit);
    }

    public virtual object parseFundingHistories(object response, object symbol, object since, object limit)
    {
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object funding = this.parseFundingHistory(entry);
            ((IList<object>)result).Add(funding);
        }
        object sorted = this.sortBy(result, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public virtual object parseFundingHistory(object info, object market = null)
    {
        //
        //    {
        //        "time": 1646899200,
        //        "change": "-0.027722",
        //        "balance": "11.653120591841",
        //        "text": "XRP_USDT",
        //        "type": "fund"
        //    }
        //
        object timestamp = this.safeTimestamp(info, "time");
        object marketId = this.safeString(info, "text");
        market = this.safeMarket(marketId, market, "_", "swap");
        return new Dictionary<string, object>() {
            { "info", info },
            { "symbol", this.safeString(market, "symbol") },
            { "code", this.safeString(market, "settle") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", null },
            { "amount", this.safeNumber(info, "change") },
        };
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-order-book
        * @see https://www.gate.io/docs/developers/apiv4/en/#futures-order-book
        * @see https://www.gate.io/docs/developers/apiv4/en/#futures-order-book-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#options-order-book
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        //
        //     const request = {
        //         'currency_pair': market['id'],
        //         'interval': '0', // depth, 0 means no aggregation is applied, default to 0
        //         'limit': limit, // maximum number of order depth data in asks or bids
        //         'with_id': true, // return order book ID
        //     };
        //
        var requestqueryVariable = this.prepareRequest(market, getValue(market, "type"), parameters);
        var request = ((IList<object>) requestqueryVariable)[0];
        var query = ((IList<object>) requestqueryVariable)[1];
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 10, max 100
        }
        ((IDictionary<string,object>)request)["with_id"] = true;
        object response = null;
        if (isTrue(isTrue(getValue(market, "spot")) || isTrue(getValue(market, "margin"))))
        {
            response = await this.publicSpotGetOrderBook(this.extend(request, query));
        } else if (isTrue(getValue(market, "swap")))
        {
            response = await this.publicFuturesGetSettleOrderBook(this.extend(request, query));
        } else if (isTrue(getValue(market, "future")))
        {
            response = await this.publicDeliveryGetSettleOrderBook(this.extend(request, query));
        } else if (isTrue(getValue(market, "option")))
        {
            response = await this.publicOptionsGetOrderBook(this.extend(request, query));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchOrderBook() not support this market type")) ;
        }
        //
        // spot
        //
        //     {
        //         "id": 6358770031
        //         "current": 1634345973275,
        //         "update": 1634345973271,
        //         "asks": [
        //             ["2.2241","12449.827"],
        //             ["2.2242","200"],
        //             ["2.2244","826.931"],
        //             ["2.2248","3876.107"],
        //             ["2.225","2377.252"],
        //             ["2.22509","439.484"],
        //             ["2.2251","1489.313"],
        //             ["2.2253","714.582"],
        //             ["2.2254","1349.784"],
        //             ["2.2256","234.701"]],
        //          "bids": [
        //             ["2.2236","32.465"],
        //             ["2.2232","243.983"],
        //             ["2.2231","32.207"],
        //             ["2.223","449.827"],
        //             ["2.2228","7.918"],
        //             ["2.2227","12703.482"],
        //             ["2.2226","143.033"],
        //             ["2.2225","143.027"],
        //             ["2.2224","1369.352"],
        //             ["2.2223","756.063"]
        //         ]
        //     }
        //
        // swap, future and option
        //
        //     {
        //         "id": 6358770031
        //         "current": 1634350208.745,
        //         "asks": [
        //             {"s": 24909, "p": "61264.8"},
        //             {"s": 81, "p": "61266.6"},
        //             {"s": 2000, "p": "61267.6"},
        //             {"s": 490, "p": "61270.2"},
        //             {"s": 12, "p": "61270.4"},
        //             {"s": 11782, "p": "61273.2"},
        //             {"s": 14666, "p": "61273.3"},
        //             {"s": 22541, "p": "61273.4"},
        //             {"s": 33, "p": "61273.6"},
        //             {"s": 11980, "p": "61274.5"}
        //         ],
        //         "bids": [
        //             {"s": 41844, "p": "61264.7"},
        //             {"s": 13783, "p": "61263.3"},
        //             {"s": 1143, "p": "61259.8"},
        //             {"s": 81, "p": "61258.7"},
        //             {"s": 2471, "p": "61257.8"},
        //             {"s": 2471, "p": "61257.7"},
        //             {"s": 2471, "p": "61256.5"},
        //             {"s": 3, "p": "61254.2"},
        //             {"s": 114, "p": "61252.4"},
        //             {"s": 14372, "p": "61248.6"}
        //         ],
        //         "update": 1634350208.724
        //     }
        //
        object timestamp = this.safeInteger(response, "current");
        if (!isTrue(getValue(market, "spot")))
        {
            timestamp = multiply(timestamp, 1000);
        }
        object priceKey = ((bool) isTrue(getValue(market, "spot"))) ? 0 : "p";
        object amountKey = ((bool) isTrue(getValue(market, "spot"))) ? 1 : "s";
        object nonce = this.safeInteger(response, "id");
        object result = this.parseOrderBook(response, symbol, timestamp, "bids", "asks", priceKey, amountKey);
        ((IDictionary<string,object>)result)["nonce"] = nonce;
        return result;
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://www.gate.io/docs/developers/apiv4/en/#get-details-of-a-specifc-order
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-futures-tickers
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-futures-tickers-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-tickers-of-options-contracts
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var requestqueryVariable = this.prepareRequest(market, null, parameters);
        var request = ((IList<object>) requestqueryVariable)[0];
        var query = ((IList<object>) requestqueryVariable)[1];
        object response = null;
        if (isTrue(isTrue(getValue(market, "spot")) || isTrue(getValue(market, "margin"))))
        {
            response = await this.publicSpotGetTickers(this.extend(request, query));
        } else if (isTrue(getValue(market, "swap")))
        {
            response = await this.publicFuturesGetSettleTickers(this.extend(request, query));
        } else if (isTrue(getValue(market, "future")))
        {
            response = await this.publicDeliveryGetSettleTickers(this.extend(request, query));
        } else if (isTrue(getValue(market, "option")))
        {
            object marketId = getValue(market, "id");
            object optionParts = ((string)marketId).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            ((IDictionary<string,object>)request)["underlying"] = this.safeString(optionParts, 0);
            response = await this.publicOptionsGetTickers(this.extend(request, query));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchTicker() not support this market type")) ;
        }
        object ticker = null;
        if (isTrue(getValue(market, "option")))
        {
            for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
            {
                object entry = getValue(response, i);
                if (isTrue(isEqual(getValue(entry, "name"), getValue(market, "id"))))
                {
                    ticker = entry;
                    break;
                }
            }
        } else
        {
            ticker = this.safeValue(response, 0);
        }
        return this.parseTicker(ticker, market);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // SPOT
        //
        //     {
        //         "currency_pair": "KFC_USDT",
        //         "last": "7.255",
        //         "lowest_ask": "7.298",
        //         "highest_bid": "7.218",
        //         "change_percentage": "-1.18",
        //         "base_volume": "1219.053687865",
        //         "quote_volume": "8807.40299875455",
        //         "high_24h": "7.262",
        //         "low_24h": "7.095"
        //     }
        //
        // LINEAR/DELIVERY
        //
        //     {
        //         "contract": "BTC_USDT",
        //         "last": "6432",
        //         "low_24h": "6278",
        //         "high_24h": "6790",
        //         "change_percentage": "4.43",
        //         "total_size": "32323904",
        //         "volume_24h": "184040233284",
        //         "volume_24h_btc": "28613220",
        //         "volume_24h_usd": "184040233284",
        //         "volume_24h_base": "28613220",
        //         "volume_24h_quote": "184040233284",
        //         "volume_24h_settle": "28613220",
        //         "mark_price": "6534",
        //         "funding_rate": "0.0001",
        //         "funding_rate_indicative": "0.0001",
        //         "index_price": "6531"
        //     }
        //
        // bookTicker
        //    {
        //        "t": 1671363004228,
        //        "u": 9793320464,
        //        "s": "BTC_USDT",
        //        "b": "16716.8", // best bid price
        //        "B": "0.0134", // best bid size
        //        "a": "16716.9", // best ask price
        //        "A": "0.0353" // best ask size
        //     }
        //
        // option
        //
        //     {
        //         "vega": "0.00002",
        //         "leverage": "12.277188268663",
        //         "ask_iv": "0",
        //         "delta": "-0.99999",
        //         "last_price": "0",
        //         "theta": "-0.00661",
        //         "bid1_price": "1096",
        //         "mark_iv": "0.7799",
        //         "name": "BTC_USDT-20230608-28500-P",
        //         "bid_iv": "0",
        //         "ask1_price": "2935",
        //         "mark_price": "2147.3",
        //         "position_size": 0,
        //         "bid1_size": 12,
        //         "ask1_size": -14,
        //         "gamma": "0"
        //     }
        //
        object marketId = this.safeStringN(ticker, new List<object>() {"currency_pair", "contract", "name"});
        object marketType = ((bool) isTrue((inOp(ticker, "mark_price")))) ? "contract" : "spot";
        object symbol = this.safeSymbol(marketId, market, "_", marketType);
        object last = this.safeString2(ticker, "last", "last_price");
        object ask = this.safeStringN(ticker, new List<object>() {"lowest_ask", "a", "ask1_price"});
        object bid = this.safeStringN(ticker, new List<object>() {"highest_bid", "b", "bid1_price"});
        object high = this.safeString(ticker, "high_24h");
        object low = this.safeString(ticker, "low_24h");
        object bidVolume = this.safeString2(ticker, "B", "bid1_size");
        object askVolume = this.safeString2(ticker, "A", "ask1_size");
        object timestamp = this.safeInteger(ticker, "t");
        object baseVolume = this.safeString2(ticker, "base_volume", "volume_24h_base");
        if (isTrue(isEqual(baseVolume, "nan")))
        {
            baseVolume = "0";
        }
        object quoteVolume = this.safeString2(ticker, "quote_volume", "volume_24h_quote");
        if (isTrue(isEqual(quoteVolume, "nan")))
        {
            quoteVolume = "0";
        }
        object percentage = this.safeString(ticker, "change_percentage");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", high },
            { "low", low },
            { "bid", bid },
            { "bidVolume", bidVolume },
            { "ask", ask },
            { "askVolume", askVolume },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://www.gate.io/docs/developers/apiv4/en/#get-details-of-a-specifc-order
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-futures-tickers
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-futures-tickers-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-tickers-of-options-contracts
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object first = this.safeString(symbols, 0);
        object market = null;
        if (isTrue(!isEqual(first, null)))
        {
            market = this.market(first);
        }
        var typequeryVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        var requestrequestParamsVariable = this.prepareRequest(null, type, query);
        var request = ((IList<object>) requestrequestParamsVariable)[0];
        var requestParams = ((IList<object>) requestrequestParamsVariable)[1];
        object response = null;
        ((IDictionary<string,object>)request)["timezone"] = "utc0"; // default to utc
        if (isTrue(isTrue(isEqual(type, "spot")) || isTrue(isEqual(type, "margin"))))
        {
            response = await this.publicSpotGetTickers(this.extend(request, requestParams));
        } else if (isTrue(isEqual(type, "swap")))
        {
            response = await this.publicFuturesGetSettleTickers(this.extend(request, requestParams));
        } else if (isTrue(isEqual(type, "future")))
        {
            response = await this.publicDeliveryGetSettleTickers(this.extend(request, requestParams));
        } else if (isTrue(isEqual(type, "option")))
        {
            this.checkRequiredArgument("fetchTickers", symbols, "symbols");
            object marketId = getValue(market, "id");
            object optionParts = ((string)marketId).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            ((IDictionary<string,object>)request)["underlying"] = this.safeString(optionParts, 0);
            response = await this.publicOptionsGetTickers(this.extend(request, requestParams));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchTickers() not support this market type, provide symbols or set params[\"defaultType\"] to one from spot/margin/swap/future/option")) ;
        }
        return this.parseTickers(response, symbols);
    }

    public virtual object parseBalanceHelper(object entry)
    {
        object account = this.account();
        ((IDictionary<string,object>)account)["used"] = this.safeString2(entry, "freeze", "locked");
        ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "available");
        ((IDictionary<string,object>)account)["total"] = this.safeString(entry, "total");
        if (isTrue(inOp(entry, "borrowed")))
        {
            ((IDictionary<string,object>)account)["debt"] = this.safeString(entry, "borrowed");
        }
        return account;
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @param {object} [params] exchange specific parameters
        * @param {string} [params.type] spot, margin, swap or future, if not provided this.options['defaultType'] is used
        * @param {string} [params.settle] 'btc' or 'usdt' - settle currency for perpetual swap and future - default="usdt" for swap and "btc" for future
        * @param {string} [params.marginMode] 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
        * @param {string} [params.symbol] margin only - unified ccxt symbol
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object symbol = this.safeString(parameters, "symbol");
        parameters = this.omit(parameters, "symbol");
        var typequeryVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        var requestrequestParamsVariable = this.prepareRequest(null, type, query);
        var request = ((IList<object>) requestrequestParamsVariable)[0];
        var requestParams = ((IList<object>) requestrequestParamsVariable)[1];
        var marginModerequestQueryVariable = this.getMarginMode(false, requestParams);
        var marginMode = ((IList<object>) marginModerequestQueryVariable)[0];
        var requestQuery = ((IList<object>) marginModerequestQueryVariable)[1];
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["currency_pair"] = getValue(market, "id");
        }
        object response = null;
        if (isTrue(isEqual(type, "spot")))
        {
            if (isTrue(isEqual(marginMode, "spot")))
            {
                response = await this.privateSpotGetAccounts(this.extend(request, requestQuery));
            } else if (isTrue(isEqual(marginMode, "margin")))
            {
                response = await this.privateMarginGetAccounts(this.extend(request, requestQuery));
            } else if (isTrue(isEqual(marginMode, "cross_margin")))
            {
                response = await this.privateMarginGetCrossAccounts(this.extend(request, requestQuery));
            } else
            {
                throw new NotSupported ((string)add(this.id, " fetchBalance() not support this marginMode")) ;
            }
        } else if (isTrue(isEqual(type, "funding")))
        {
            response = await this.privateMarginGetFundingAccounts(this.extend(request, requestQuery));
        } else if (isTrue(isEqual(type, "swap")))
        {
            response = await this.privateFuturesGetSettleAccounts(this.extend(request, requestQuery));
        } else if (isTrue(isEqual(type, "future")))
        {
            response = await this.privateDeliveryGetSettleAccounts(this.extend(request, requestQuery));
        } else if (isTrue(isEqual(type, "option")))
        {
            response = await this.privateOptionsGetAccounts(this.extend(request, requestQuery));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchBalance() not support this market type")) ;
        }
        object contract = (isTrue(isTrue((isEqual(type, "swap"))) || isTrue((isEqual(type, "future")))) || isTrue((isEqual(type, "option"))));
        if (isTrue(contract))
        {
            response = new List<object>() {response};
        }
        //
        // Spot / margin funding
        //
        //     [
        //         {
        //             "currency": "DBC",
        //             "available": "0",
        //             "locked": "0"
        //             "lent": "0", // margin funding only
        //             "total_lent": "0" // margin funding only
        //         },
        //         ...
        //     ]
        //
        //  Margin
        //
        //    [
        //        {
        //            "currency_pair": "DOGE_USDT",
        //            "locked": false,
        //            "risk": "9999.99",
        //            "base": {
        //                "currency": "DOGE",
        //                "available": "0",
        //                "locked": "0",
        //                "borrowed": "0",
        //                "interest": "0"
        //            },
        //            "quote": {
        //                "currency": "USDT",
        //                "available": "0.73402",
        //                "locked": "0",
        //                "borrowed": "0",
        //                "interest": "0"
        //            }
        //        },
        //        ...
        //    ]
        //
        // Cross margin
        //
        //    {
        //        "user_id": 10406147,
        //        "locked": false,
        //        "balances": {
        //            "USDT": {
        //                "available": "1",
        //                "freeze": "0",
        //                "borrowed": "0",
        //                "interest": "0"
        //            }
        //        },
        //        "total": "1",
        //        "borrowed": "0",
        //        "interest": "0",
        //        "risk": "9999.99"
        //    }
        //
        //  Perpetual Swap
        //
        //    {
        //        "order_margin": "0",
        //        "point": "0",
        //        "bonus": "0",
        //        "history": {
        //            "dnw": "2.1321",
        //            "pnl": "11.5351",
        //            "refr": "0",
        //            "point_fee": "0",
        //            "fund": "-0.32340576684",
        //            "bonus_dnw": "0",
        //            "point_refr": "0",
        //            "bonus_offset": "0",
        //            "fee": "-0.20132775",
        //            "point_dnw": "0",
        //        },
        //        "unrealised_pnl": "13.315100000006",
        //        "total": "12.51345151332",
        //        "available": "0",
        //        "in_dual_mode": false,
        //        "currency": "USDT",
        //        "position_margin": "12.51345151332",
        //        "user": "6333333",
        //    }
        //
        // Delivery Future
        //
        //    {
        //        "order_margin": "0",
        //        "point": "0",
        //        "history": {
        //            "dnw": "1",
        //            "pnl": "0",
        //            "refr": "0",
        //            "point_fee": "0",
        //            "point_dnw": "0",
        //            "settle": "0",
        //            "settle_fee": "0",
        //            "point_refr": "0",
        //            "fee": "0",
        //        },
        //        "unrealised_pnl": "0",
        //        "total": "1",
        //        "available": "1",
        //        "currency": "USDT",
        //        "position_margin": "0",
        //        "user": "6333333",
        //    }
        //
        // option
        //
        //     {
        //         "order_margin": "0",
        //         "bid_order_margin": "0",
        //         "init_margin": "0",
        //         "history": {
        //             "dnw": "32",
        //             "set": "0",
        //             "point_fee": "0",
        //             "point_dnw": "0",
        //             "prem": "0",
        //             "point_refr": "0",
        //             "insur": "0",
        //             "fee": "0",
        //             "refr": "0"
        //         },
        //         "total": "32",
        //         "available": "32",
        //         "liq_triggered": false,
        //         "maint_margin": "0",
        //         "ask_order_margin": "0",
        //         "point": "0",
        //         "position_notional_limit": "2000000",
        //         "unrealised_pnl": "0",
        //         "equity": "32",
        //         "user": 5691076,
        //         "currency": "USDT",
        //         "short_enabled": false,
        //         "orders_limit": 10
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object isolated = isEqual(marginMode, "margin");
        object data = response;
        if (isTrue(inOp(data, "balances")))
        {
            object flatBalances = new List<object>() {};
            object balances = this.safeValue(data, "balances", new List<object>() {});
            // inject currency and create an artificial balance object
            // so it can follow the existent flow
            object keys = new List<object>(((IDictionary<string,object>)balances).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
            {
                object currencyId = getValue(keys, i);
                object content = getValue(balances, currencyId);
                ((IDictionary<string,object>)content)["currency"] = currencyId;
                ((IList<object>)flatBalances).Add(content);
            }
            data = flatBalances;
        }
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            if (isTrue(isolated))
            {
                object marketId = this.safeString(entry, "currency_pair");
                object symbolInner = this.safeSymbol(marketId, null, "_", "margin");
                object bs = this.safeValue(entry, "base", new Dictionary<string, object>() {});
                object quote = this.safeValue(entry, "quote", new Dictionary<string, object>() {});
                object baseCode = this.safeCurrencyCode(this.safeString(bs, "currency"));
                object quoteCode = this.safeCurrencyCode(this.safeString(quote, "currency"));
                object subResult = new Dictionary<string, object>() {};
                ((IDictionary<string,object>)subResult)[(string)baseCode] = this.parseBalanceHelper(bs);
                ((IDictionary<string,object>)subResult)[(string)quoteCode] = this.parseBalanceHelper(quote);
                ((IDictionary<string,object>)result)[(string)symbolInner] = this.safeBalance(subResult);
            } else
            {
                object code = this.safeCurrencyCode(this.safeString(entry, "currency"));
                ((IDictionary<string,object>)result)[(string)code] = this.parseBalanceHelper(entry);
            }
        }
        object returnResult = ((bool) isTrue(isolated)) ? result : this.safeBalance(result);
        return returnResult;
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gateio#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://www.gate.io/docs/developers/apiv4/en/#market-candlesticks       // spot
        * @see https://www.gate.io/docs/developers/apiv4/en/#get-futures-candlesticks  // swap
        * @see https://www.gate.io/docs/developers/apiv4/en/#market-candlesticks       // future
        * @see https://www.gate.io/docs/developers/apiv4/en/#get-options-candlesticks  // option
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch, limit is conflicted with since and params["until"], If either since and params["until"] is specified, request will be rejected
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.price] "mark" or "index" for mark price and index price candles
        * @param {int} [params.until] timestamp in ms of the latest candle to fetch
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume (units in quote currency)
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, 1000);
        }
        if (isTrue(getValue(market, "option")))
        {
            return await this.fetchOptionOHLCV(symbol, timeframe, since, limit, parameters);
        }
        object price = this.safeString(parameters, "price");
        object request = new Dictionary<string, object>() {};
        var requestparametersVariable = this.prepareRequest(market, null, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        ((IDictionary<string,object>)request)["interval"] = this.safeString(this.timeframes, timeframe, timeframe);
        object maxLimit = ((bool) isTrue(getValue(market, "contract"))) ? 1999 : 1000;
        limit = ((bool) isTrue((isEqual(limit, null)))) ? maxLimit : mathMin(limit, maxLimit);
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            until = this.parseToInt(divide(until, 1000));
            parameters = this.omit(parameters, "until");
        }
        if (isTrue(!isEqual(since, null)))
        {
            object duration = this.parseTimeframe(timeframe);
            ((IDictionary<string,object>)request)["from"] = this.parseToInt(divide(since, 1000));
            object distance = multiply((subtract(limit, 1)), duration);
            object toTimestamp = this.sum(getValue(request, "from"), distance);
            object currentTimestamp = this.seconds();
            object to = mathMin(toTimestamp, currentTimestamp);
            if (isTrue(!isEqual(until, null)))
            {
                ((IDictionary<string,object>)request)["to"] = mathMin(to, until);
            } else
            {
                ((IDictionary<string,object>)request)["to"] = to;
            }
        } else
        {
            if (isTrue(!isEqual(until, null)))
            {
                ((IDictionary<string,object>)request)["to"] = until;
            }
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(getValue(market, "contract")))
        {
            maxLimit = 1999;
            object isMark = (isEqual(price, "mark"));
            object isIndex = (isEqual(price, "index"));
            if (isTrue(isTrue(isMark) || isTrue(isIndex)))
            {
                ((IDictionary<string,object>)request)["contract"] = add(add(price, "_"), getValue(market, "id"));
                parameters = this.omit(parameters, "price");
            }
            if (isTrue(getValue(market, "future")))
            {
                response = await this.publicDeliveryGetSettleCandlesticks(this.extend(request, parameters));
            } else if (isTrue(getValue(market, "swap")))
            {
                response = await this.publicFuturesGetSettleCandlesticks(this.extend(request, parameters));
            }
        } else
        {
            response = await this.publicSpotGetCandlesticks(this.extend(request, parameters));
        }
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    public async virtual Task<object> fetchOptionOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        // separated option logic because the from, to and limit parameters weren't functioning
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        var requestparametersVariable = this.prepareRequest(market, null, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        ((IDictionary<string,object>)request)["interval"] = this.safeString(this.timeframes, timeframe, timeframe);
        object response = await this.publicOptionsGetCandlesticks(this.extend(request, parameters));
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchFundingRateHistory
        * @description fetches historical funding rate prices
        * @see https://www.gate.io/docs/developers/apiv4/en/#funding-rate-history
        * @param {string} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
        * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRateHistory() supports swap contracts only")) ;
        }
        var requestqueryVariable = this.prepareRequest(market, null, parameters);
        var request = ((IList<object>) requestqueryVariable)[0];
        var query = ((IList<object>) requestqueryVariable)[1];
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.publicFuturesGetSettleFundingRate(this.extend(request, query));
        //
        //     {
        //         "r": "0.00063521",
        //         "t": "1621267200000",
        //     }
        //
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object timestamp = this.safeTimestamp(entry, "t");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbol },
                { "fundingRate", this.safeNumber(entry, "r") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        // Spot market candles
        //
        //    [
        //        "1660957920", // timestamp
        //        "6227.070147198573", // quote volume
        //        "0.0000133485", // close
        //        "0.0000133615", // high
        //        "0.0000133347", // low
        //        "0.0000133468", // open
        //        "466641934.99" // base volume
        //    ]
        //
        //
        // Swap, Future, Option, Mark and Index price candles
        //
        //     {
        //          "t":1632873600,         // Unix timestamp in seconds
        //          "o": "41025",           // Open price
        //          "h": "41882.17",        // Highest price
        //          "c": "41776.92",        // Close price
        //          "l": "40783.94"         // Lowest price
        //     }
        //
        if (isTrue(((ohlcv is IList<object>) || (ohlcv.GetType().IsGenericType && ohlcv.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            return new List<object> {this.safeTimestamp(ohlcv, 0), this.safeNumber(ohlcv, 5), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 6)};
        } else
        {
            // Swap, Future, Option, Mark and Index price candles
            return new List<object> {this.safeTimestamp(ohlcv, "t"), this.safeNumber(ohlcv, "o"), this.safeNumber(ohlcv, "h"), this.safeNumber(ohlcv, "l"), this.safeNumber(ohlcv, "c"), this.safeNumber(ohlcv, "v")};
        }
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-market-trades
        * @see https://www.gate.io/docs/developers/apiv4/en/#futures-trading-history
        * @see https://www.gate.io/docs/developers/apiv4/en/#futures-trading-history-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#options-trade-history
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp in ms of the latest trade to fetch
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchTrades", symbol, since, limit, parameters);
        }
        object market = this.market(symbol);
        //
        // spot
        //
        //     const request = {
        //         'currency_pair': market['id'],
        //         'limit': limit, // maximum number of records to be returned in a single list
        //         'last_id': 'id', // specify list staring point using the id of last record in previous list-query results
        //         'reverse': false, // true to retrieve records where id is smaller than the specified last_id, false to retrieve records where id is larger than the specified last_id
        //     };
        //
        // swap, future
        //
        //     const request = {
        //         'settle': market['settleId'],
        //         'contract': market['id'],
        //         'limit': limit, // maximum number of records to be returned in a single list
        //         'last_id': 'id', // specify list staring point using the id of last record in previous list-query results
        //         'from': since / 1000), // starting time in seconds, if not specified, to and limit will be used to limit response items
        //         'to': this.seconds (), // end time in seconds, default to current time
        //     };
        //
        var requestqueryVariable = this.prepareRequest(market, null, parameters);
        var request = ((IList<object>) requestqueryVariable)[0];
        var query = ((IList<object>) requestqueryVariable)[1];
        object until = this.safeInteger2(parameters, "to", "until");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)["to"] = this.parseToInt(divide(until, 1000));
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 1000); // default 100, max 1000
        }
        if (isTrue(isTrue(!isEqual(since, null)) && isTrue((getValue(market, "contract")))))
        {
            ((IDictionary<string,object>)request)["from"] = this.parseToInt(divide(since, 1000));
        }
        object response = null;
        if (isTrue(isTrue(isEqual(getValue(market, "type"), "spot")) || isTrue(isEqual(getValue(market, "type"), "margin"))))
        {
            response = await this.publicSpotGetTrades(this.extend(request, query));
        } else if (isTrue(getValue(market, "swap")))
        {
            response = await this.publicFuturesGetSettleTrades(this.extend(request, query));
        } else if (isTrue(getValue(market, "future")))
        {
            response = await this.publicDeliveryGetSettleTrades(this.extend(request, query));
        } else if (isTrue(isEqual(getValue(market, "type"), "option")))
        {
            response = await this.publicOptionsGetTrades(this.extend(request, query));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchTrades() not support this market type.")) ;
        }
        //
        // spot
        //
        //     [
        //         {
        //             "id": "1852958144",
        //             "create_time": "1634673259",
        //             "create_time_ms": "1634673259378.105000",
        //             "currency_pair": "ADA_USDT",
        //             "side": "sell",
        //             "amount": "307.078",
        //             "price": "2.104",
        //         }
        //     ]
        //
        // perpetual swap
        //
        //     [
        //         {
        //              "size": "2",
        //              "id": "2522911",
        //              "create_time_ms": "1634673380.182",
        //              "create_time": "1634673380.182",
        //              "contract": "ADA_USDT",
        //              "price": "2.10486",
        //         }
        //     ]
        //
        // option
        //
        //     [
        //         {
        //             "size": -5,
        //             "id": 25,
        //             "create_time": 1682378573,
        //             "contract": "ETH_USDT-20230526-2000-P",
        //             "price": "209.1"
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-personal-trading-history
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-personal-trading-history-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-personal-trading-history-3
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-personal-trading-history-4
        * @param {string} id order id
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrderTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        //
        //      [
        //          {
        //              "id":"3711449544",
        //              "create_time":"1655486040",
        //              "create_time_ms":"1655486040177.599900",
        //              "currency_pair":"SHIB_USDT",
        //              "side":"buy",
        //              "role":"taker",
        //              "amount":"1360039",
        //              "price":"0.0000081084",
        //              "order_id":"169717399644",
        //              "fee":"2720.078",
        //              "fee_currency":"SHIB",
        //              "point_fee":"0",
        //              "gt_fee":"0"
        //          }
        //      ]
        //
        object response = await this.fetchMyTrades(symbol, since, limit, new Dictionary<string, object>() {
            { "order_id", id },
        });
        return response;
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchMyTrades
        * @description Fetch personal trading history
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-personal-trading-history
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-personal-trading-history-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-personal-trading-history-3
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-personal-trading-history-4
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
        * @param {string} [params.type] 'spot', 'swap', or 'future', if not provided this.options['defaultMarginMode'] is used
        * @param {int} [params.until] The latest timestamp, in ms, that fetched trades were made
        * @param {int} [params.page] *spot only* Page number
        * @param {string} [params.order_id] *spot only* Filter trades with specified order ID. symbol is also required if this field is present
        * @param {string} [params.order] *contract only* Futures order ID, return related data only if specified
        * @param {int} [params.offset] *contract only* list offset, starting from 0
        * @param {string} [params.last_id] *contract only* specify list staring point using the id of last record in previous list-query results
        * @param {int} [params.count_total] *contract only* whether to return total number matched, default to 0(no return)
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, parameters);
        }
        object type = null;
        object marginMode = null;
        object request = new Dictionary<string, object>() {};
        object market = ((bool) isTrue((!isEqual(symbol, null)))) ? this.market(symbol) : null;
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, new List<object>() {"until"});
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object contract = isTrue(isTrue((isEqual(type, "swap"))) || isTrue((isEqual(type, "future")))) || isTrue((isEqual(type, "option")));
        if (isTrue(contract))
        {
            var requestparametersVariable = this.prepareRequest(market, type, parameters);
            request = ((IList<object>)requestparametersVariable)[0];
            parameters = ((IList<object>)requestparametersVariable)[1];
            if (isTrue(isEqual(type, "option")))
            {
                parameters = this.omit(parameters, "order_id");
            }
        } else
        {
            if (isTrue(!isEqual(market, null)))
            {
                ((IDictionary<string,object>)request)["currency_pair"] = getValue(market, "id"); // Should always be set for non-stop
            }
            var marginModeparametersVariable = this.getMarginMode(false, parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            ((IDictionary<string,object>)request)["account"] = marginMode;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 1000
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = this.parseToInt(divide(since, 1000));
        }
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["to"] = this.parseToInt(divide(until, 1000));
        }
        object response = null;
        if (isTrue(isTrue(isEqual(type, "spot")) || isTrue(isEqual(type, "margin"))))
        {
            response = await this.privateSpotGetMyTrades(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "swap")))
        {
            response = await this.privateFuturesGetSettleMyTradesTimerange(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "future")))
        {
            response = await this.privateDeliveryGetSettleMyTrades(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "option")))
        {
            response = await this.privateOptionsGetMyTrades(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchMyTrades() not support this market type.")) ;
        }
        //
        // spot
        //
        //     [
        //         {
        //             "id": "2876130500",
        //             "create_time": "1645464610",
        //             "create_time_ms": "1645464610777.399200",
        //             "currency_pair": "DOGE_USDT",
        //             "side": "sell",
        //             "role": "taker",
        //             "amount": "10.97",
        //             "price": "0.137384",
        //             "order_id": "125924049993",
        //             "fee": "0.00301420496",
        //             "fee_currency": "USDT",
        //             "point_fee": "0",
        //             "gt_fee": "0"
        //         }
        //     ]
        //
        // perpetual swap
        //
        //     [
        //         {
        //             "size": -5,
        //             "order_id": "130264979823",
        //             "id": 26884791,
        //             "role": "taker",
        //             "create_time": 1645465199.5472,
        //             "contract": "DOGE_USDT",
        //             "price": "0.136888"
        //         }
        //     ]
        //
        // future
        //
        //     [
        //         {
        //             "id": 121234231,
        //             "create_time": 1514764800.123,
        //             "contract": "BTC_USDT",
        //             "order_id": "21893289839",
        //             "size": 100,
        //             "price": "100.123",
        //             "role": "taker"
        //         }
        //     ]
        //
        // option
        //
        //     [
        //         {
        //             "underlying_price": "26817.84",
        //             "size": -1,
        //             "contract": "BTC_USDT-20230602-26500-C",
        //             "id": 16,
        //             "role": "taker",
        //             "create_time": 1685594770,
        //             "order_id": 2611026125,
        //             "price": "333"
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public
        //
        //     {
        //         "id": "1334253759",
        //         "create_time": "1626342738",
        //         "create_time_ms": "1626342738331.497000",
        //         "currency_pair": "BTC_USDT",
        //         "side": "sell",
        //         "amount": "0.0022",
        //         "price": "32452.16"
        //     }
        //
        // public ws
        //
        //     {
        //         "id": 221994511,
        //         "time": 1580311438.618647,
        //         "price": "9309",
        //         "amount": "0.0019",
        //         "type": "sell"
        //     }
        //
        // spot rest
        //
        //     {
        //         "id": "2876130500",
        //         "create_time": "1645464610",
        //         "create_time_ms": "1645464610777.399200",
        //         "currency_pair": "DOGE_USDT",
        //         "side": "sell",
        //         "role": "taker",
        //         "amount": "10.97",
        //         "price": "0.137384",
        //         "order_id": "125924049993",
        //         "fee": "0.00301420496",
        //         "fee_currency": "USDT",
        //         "point_fee": "1.1",
        //         "gt_fee":"2.2"
        //     }
        //
        // perpetual swap rest
        //
        //     {
        //         "size": -5,
        //         "order_id": "130264979823",
        //         "id": 26884791,
        //         "role": "taker",
        //         "create_time": 1645465199.5472,
        //         "contract": "DOGE_USDT",
        //         "price": "0.136888"
        //     }
        //
        // future rest
        //
        //     {
        //         "id": 121234231,
        //         "create_time": 1514764800.123,
        //         "contract": "BTC_USDT",
        //         "order_id": "21893289839",
        //         "size": 100,
        //         "price": "100.123",
        //         "role": "taker"
        //     }
        //
        // fetchTrades: option
        //
        //     {
        //         "size": -5,
        //         "id": 25,
        //         "create_time": 1682378573,
        //         "contract": "ETH_USDT-20230526-2000-P",
        //         "price": "209.1"
        //     }
        //
        // fetchMyTrades: option
        //
        //     {
        //         "underlying_price": "26817.84",
        //         "size": -1,
        //         "contract": "BTC_USDT-20230602-26500-C",
        //         "id": 16,
        //         "role": "taker",
        //         "create_time": 1685594770,
        //         "order_id": 2611026125,
        //         "price": "333"
        //     }
        //
        object id = this.safeString2(trade, "id", "trade_id");
        object timestamp = this.safeTimestamp2(trade, "time", "create_time");
        timestamp = this.safeInteger(trade, "create_time_ms", timestamp);
        object marketId = this.safeString2(trade, "currency_pair", "contract");
        object marketType = ((bool) isTrue((inOp(trade, "contract")))) ? "contract" : "spot";
        market = this.safeMarket(marketId, market, "_", marketType);
        object amountString = this.safeString2(trade, "amount", "size");
        object priceString = this.safeString(trade, "price");
        object contractSide = ((bool) isTrue(Precise.stringLt(amountString, "0"))) ? "sell" : "buy";
        amountString = Precise.stringAbs(amountString);
        object side = this.safeString2(trade, "side", "type", contractSide);
        object orderId = this.safeString(trade, "order_id");
        object feeAmount = this.safeString(trade, "fee");
        object gtFee = this.safeString(trade, "gt_fee");
        object pointFee = this.safeString(trade, "point_fee");
        object fees = new List<object>() {};
        if (isTrue(!isEqual(feeAmount, null)))
        {
            object feeCurrencyId = this.safeString(trade, "fee_currency");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            if (isTrue(isEqual(feeCurrencyCode, null)))
            {
                feeCurrencyCode = this.safeString(market, "settle");
            }
            ((IList<object>)fees).Add(new Dictionary<string, object>() {
                { "cost", feeAmount },
                { "currency", feeCurrencyCode },
            });
        }
        if (isTrue(!isEqual(gtFee, null)))
        {
            ((IList<object>)fees).Add(new Dictionary<string, object>() {
                { "cost", gtFee },
                { "currency", "GT" },
            });
        }
        if (isTrue(!isEqual(pointFee, null)))
        {
            ((IList<object>)fees).Add(new Dictionary<string, object>() {
                { "cost", pointFee },
                { "currency", "GatePoint" },
            });
        }
        object takerOrMaker = this.safeString(trade, "role");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "order", orderId },
            { "type", null },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "fee", null },
            { "fees", fees },
        }, market);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-deposit-records
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {int} [params.until] end time in ms
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchDeposits", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchDeposits", code, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id"); // todo: currencies have network-junctions
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            object start = this.parseToInt(divide(since, 1000));
            ((IDictionary<string,object>)request)["from"] = start;
            ((IDictionary<string,object>)request)["to"] = this.sum(start, multiply(multiply(multiply(30, 24), 60), 60));
        }
        var requestparametersVariable = this.handleUntilOption("to", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateWalletGetDeposits(this.extend(request, parameters));
        return this.parseTransactions(response, currency);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-withdrawal-records
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] end time in ms
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchWithdrawals", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchWithdrawals", code, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id"); // todo: currencies have network-junctions
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            object start = this.parseToInt(divide(since, 1000));
            ((IDictionary<string,object>)request)["from"] = start;
            ((IDictionary<string,object>)request)["to"] = this.sum(start, multiply(multiply(multiply(30, 24), 60), 60));
        }
        var requestparametersVariable = this.handleUntilOption("to", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateWalletGetWithdrawals(this.extend(request, parameters));
        return this.parseTransactions(response, currency);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#withdraw
        * @description make a withdrawal
        * @see https://www.gate.io/docs/developers/apiv4/en/#withdraw
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "address", address },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["memo"] = tag;
        }
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object network = this.safeStringUpper(parameters, "network"); // this line allows the user to specify either ERC20 or ETH
        network = this.safeStringLower(networks, network, network); // handle ETH>ERC20 alias
        if (isTrue(!isEqual(network, null)))
        {
            ((IDictionary<string,object>)request)["chain"] = network;
            parameters = this.omit(parameters, "network");
        } else
        {
            ((IDictionary<string,object>)request)["chain"] = getValue(currency, "id"); // todo: currencies have network-junctions
        }
        object response = await this.privateWithdrawalsPostWithdrawals(this.extend(request, parameters));
        //
        //    {
        //        "id": "w13389675",
        //        "currency": "USDT",
        //        "amount": "50",
        //        "address": "TUu2rLFrmzUodiWfYki7QCNtv1akL682p1",
        //        "memo": null
        //    }
        //
        return this.parseTransaction(response, currency);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "PEND", "pending" },
            { "REQUEST", "pending" },
            { "DMOVE", "pending" },
            { "MANUAL", "pending" },
            { "VERIFY", "pending" },
            { "PROCES", "pending" },
            { "EXTPEND", "pending" },
            { "SPLITPEND", "pending" },
            { "CANCEL", "canceled" },
            { "FAIL", "failed" },
            { "INVALID", "failed" },
            { "DONE", "ok" },
            { "BCODE", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseTransactionType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "d", "deposit" },
            { "w", "withdrawal" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // deposits
        //
        //    {
        //        "id": "d33361395",
        //        "currency": "USDT_TRX",
        //        "address": "TErdnxenuLtXfnMafLbfappYdHtnXQ5U4z",
        //        "amount": "100",
        //        "txid": "ae9374de34e558562fe18cbb1bf9ab4d9eb8aa7669d65541c9fa2a532c1474a0",
        //        "timestamp": "1626345819",
        //        "status": "DONE",
        //        "memo": ""
        //    }
        //
        // withdraw
        //
        //    {
        //        "id": "w13389675",
        //        "currency": "USDT",
        //        "amount": "50",
        //        "address": "TUu2rLFrmzUodiWfYki7QCNtv1akL682p1",
        //        "memo": null
        //    }
        //
        //     {
        //         "currency":"usdt",
        //         "address":"0x01b0A9b7b4CdE774AF0f3E47CB4f1c2CCdBa0806",
        //         "amount":"1880",
        //         "chain":"eth"
        //     }
        //
        object id = this.safeString(transaction, "id");
        object type = null;
        object amountString = this.safeString(transaction, "amount");
        if (isTrue(!isEqual(id, null)))
        {
            if (isTrue(isEqual(getValue(id, 0), "b")))
            {
                // GateCode handling
                type = ((bool) isTrue(Precise.stringGt(amountString, "0"))) ? "deposit" : "withdrawal";
                amountString = Precise.stringAbs(amountString);
            } else
            {
                type = this.parseTransactionType(getValue(id, 0));
            }
        }
        object feeCostString = this.safeString(transaction, "fee");
        if (isTrue(isEqual(type, "withdrawal")))
        {
            amountString = Precise.stringSub(amountString, feeCostString);
        }
        object networkId = this.safeStringUpper(transaction, "chain");
        object currencyId = this.safeString(transaction, "currency");
        object code = this.safeCurrencyCode(currencyId);
        object txid = this.safeString(transaction, "txid");
        object rawStatus = this.safeString(transaction, "status");
        object status = this.parseTransactionStatus(rawStatus);
        object address = this.safeString(transaction, "address");
        object tag = this.safeString(transaction, "memo");
        object timestamp = this.safeTimestamp(transaction, "timestamp");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "currency", code },
            { "amount", this.parseNumber(amountString) },
            { "network", this.networkIdToCode(networkId) },
            { "address", address },
            { "addressTo", null },
            { "addressFrom", null },
            { "tag", tag },
            { "tagTo", null },
            { "tagFrom", null },
            { "status", status },
            { "type", type },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "updated", null },
            { "internal", null },
            { "comment", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", this.parseNumber(feeCostString) },
            } },
        };
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#createOrder
        * @description Create an order on the exchange
        * @see https://www.gate.io/docs/developers/apiv4/en/#create-an-order
        * @see https://www.gate.io/docs/developers/apiv4/en/#create-a-price-triggered-order
        * @see https://www.gate.io/docs/developers/apiv4/en/#create-a-futures-order
        * @see https://www.gate.io/docs/developers/apiv4/en/#create-a-price-triggered-order-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#create-a-futures-order-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#create-a-price-triggered-order-3
        * @see https://www.gate.io/docs/developers/apiv4/en/#create-an-options-order
        * @param {string} symbol Unified CCXT market symbol
        * @param {string} type 'limit' or 'market' *"market" is contract only*
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount the amount of currency to trade
        * @param {float} [price] *ignored in "market" orders* the price at which the order is to be fullfilled at in units of the quote currency
        * @param {object} [params]  extra parameters specific to the exchange API endpoint
        * @param {float} [params.stopPrice] The price at which a trigger order is triggered at
        * @param {string} [params.timeInForce] "GTC", "IOC", or "PO"
        * @param {float} [params.stopLossPrice] The price at which a stop loss order is triggered at
        * @param {float} [params.takeProfitPrice] The price at which a take profit order is triggered at
        * @param {string} [params.marginMode] 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
        * @param {int} [params.iceberg] Amount to display for the iceberg order, Null or 0 for normal orders, Set to -1 to hide the order completely
        * @param {string} [params.text] User defined information
        * @param {string} [params.account] *spot and margin only* "spot", "margin" or "cross_margin"
        * @param {bool} [params.auto_borrow] *margin only* Used in margin or cross margin trading to allow automatic loan of insufficient amount if balance is not enough
        * @param {string} [params.settle] *contract only* Unified Currency Code for settle currency
        * @param {bool} [params.reduceOnly] *contract only* Indicates if this order is to reduce the size of a position
        * @param {bool} [params.close] *contract only* Set as true to close the position, with size set to 0
        * @param {bool} [params.auto_size] *contract only* Set side to close dual-mode position, close_long closes the long side, while close_short the short one, size also needs to be set to 0
        * @param {int} [params.price_type] *contract only* 0 latest deal price, 1 mark price, 2 index price
        * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
        * @returns {object|undefined} [An order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object trigger = this.safeValue(parameters, "trigger");
        object triggerPrice = this.safeValue2(parameters, "triggerPrice", "stopPrice");
        object stopLossPrice = this.safeValue(parameters, "stopLossPrice", triggerPrice);
        object takeProfitPrice = this.safeValue(parameters, "takeProfitPrice");
        object isStopLossOrder = !isEqual(stopLossPrice, null);
        object isTakeProfitOrder = !isEqual(takeProfitPrice, null);
        object isStopOrder = isTrue(isStopLossOrder) || isTrue(isTakeProfitOrder);
        object nonTriggerOrder = !isTrue(isStopOrder) && isTrue((isEqual(trigger, null)));
        object orderRequest = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object response = null;
        if (isTrue(isTrue(getValue(market, "spot")) || isTrue(getValue(market, "margin"))))
        {
            if (isTrue(nonTriggerOrder))
            {
                response = await this.privateSpotPostOrders(orderRequest);
            } else
            {
                response = await this.privateSpotPostPriceOrders(orderRequest);
            }
        } else if (isTrue(getValue(market, "swap")))
        {
            if (isTrue(nonTriggerOrder))
            {
                response = await this.privateFuturesPostSettleOrders(orderRequest);
            } else
            {
                response = await this.privateFuturesPostSettlePriceOrders(orderRequest);
            }
        } else if (isTrue(getValue(market, "future")))
        {
            if (isTrue(nonTriggerOrder))
            {
                response = await this.privateDeliveryPostSettleOrders(orderRequest);
            } else
            {
                response = await this.privateDeliveryPostSettlePriceOrders(orderRequest);
            }
        } else
        {
            response = await this.privateOptionsPostOrders(orderRequest);
        }
        // const response = await this[method] (this.deepExtend (request, params));
        //
        // spot
        //
        //     {
        //         "id": "95282841887",
        //         "text": "apiv4",
        //         "create_time": "1637383156",
        //         "update_time": "1637383156",
        //         "create_time_ms": 1637383156017,
        //         "update_time_ms": 1637383156017,
        //         "status": "open",
        //         "currency_pair": "ETH_USDT",
        //         "type": "limit",
        //         "account": "spot",
        //         "side": "buy",
        //         "amount": "0.01",
        //         "price": "3500",
        //         "time_in_force": "gtc",
        //         "iceberg": "0",
        //         "left": "0.01",
        //         "fill_price": "0",
        //         "filled_total": "0",
        //         "fee": "0",
        //         "fee_currency": "ETH",
        //         "point_fee": "0",
        //         "gt_fee": "0",
        //         "gt_discount": false,
        //         "rebated_fee": "0",
        //         "rebated_fee_currency": "USDT"
        //     }
        //
        // spot conditional
        //
        //     {"id": 5891843}
        //
        // futures, perpetual swaps and options
        //
        //     {
        //         "id": 95938572327,
        //         "contract": "ETH_USDT",
        //         "mkfr": "0",
        //         "tkfr": "0.0005",
        //         "tif": "gtc",
        //         "is_reduce_only": false,
        //         "create_time": 1637384600.08,
        //         "price": "3000",
        //         "size": 1,
        //         "refr": "0",
        //         "left": 1,
        //         "text": "api",
        //         "fill_price": "0",
        //         "user": 2436035,
        //         "status": "open",
        //         "is_liq": false,
        //         "refu": 0,
        //         "is_close": false,
        //         "iceberg": 0
        //     }
        //
        // futures and perpetual swaps conditionals
        //
        //     {"id": 7615567}
        //
        return this.parseOrder(response, market);
    }

    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        /**
        * @method
        * @name gate#createOrders
        * @description create a list of trade orders
        * @see https://www.gate.io/docs/developers/apiv4/en/#get-a-single-order-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#create-a-batch-of-orders
        * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        object orderSymbols = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            ((IList<object>)orderSymbols).Add(marketId);
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeValue(rawOrder, "params", new Dictionary<string, object>() {});
            object extendedParams = this.extend(orderParams, parameters); // the request does not accept extra params since it's a list, so we're extending each order with the common params
            object triggerValue = this.safeValueN(orderParams, new List<object>() {"triggerPrice", "stopPrice", "takeProfitPrice", "stopLossPrice"});
            if (isTrue(!isEqual(triggerValue, null)))
            {
                throw new NotSupported ((string)add(this.id, " createOrders() does not support advanced order properties (stopPrice, takeProfitPrice, stopLossPrice)")) ;
            }
            ((IDictionary<string,object>)extendedParams)["textIsRequired"] = true; // Gate.io requires a text parameter for each order here
            object orderRequest = this.createOrderRequest(marketId, type, side, amount, price, extendedParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object symbols = this.marketSymbols(orderSymbols, null, false, true, true);
        object market = this.market(getValue(symbols, 0));
        if (isTrue(isTrue(getValue(market, "future")) || isTrue(getValue(market, "option"))))
        {
            throw new NotSupported ((string)add(this.id, " createOrders() does not support futures or options markets")) ;
        }
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.privateSpotPostBatchOrders(ordersRequests);
        } else if (isTrue(getValue(market, "swap")))
        {
            response = await this.privateFuturesPostSettleBatchOrders(ordersRequests);
        }
        return this.parseOrders(response);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object contract = getValue(market, "contract");
        object trigger = this.safeValue(parameters, "trigger");
        object triggerPrice = this.safeValue2(parameters, "triggerPrice", "stopPrice");
        object stopLossPrice = this.safeValue(parameters, "stopLossPrice", triggerPrice);
        object takeProfitPrice = this.safeValue(parameters, "takeProfitPrice");
        object isStopLossOrder = !isEqual(stopLossPrice, null);
        object isTakeProfitOrder = !isEqual(takeProfitPrice, null);
        object isStopOrder = isTrue(isStopLossOrder) || isTrue(isTakeProfitOrder);
        if (isTrue(isTrue(isStopLossOrder) && isTrue(isTakeProfitOrder)))
        {
            throw new ExchangeError ((string)add(this.id, " createOrder() stopLossPrice and takeProfitPrice cannot both be defined")) ;
        }
        object reduceOnly = this.safeValue(parameters, "reduceOnly");
        object exchangeSpecificTimeInForce = this.safeStringLowerN(parameters, new List<object>() {"timeInForce", "tif", "time_in_force"});
        object postOnly = null;
        var postOnlyparametersVariable = this.handlePostOnly(isEqual(type, "market"), isEqual(exchangeSpecificTimeInForce, "poc"), parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        object timeInForce = this.handleTimeInForce(parameters);
        if (isTrue(postOnly))
        {
            timeInForce = "poc";
        }
        // we only omit the unified params here
        // this is because the other params will get extended into the request
        parameters = this.omit(parameters, new List<object>() {"stopPrice", "triggerPrice", "stopLossPrice", "takeProfitPrice", "reduceOnly", "timeInForce", "postOnly"});
        object isLimitOrder = (isEqual(type, "limit"));
        object isMarketOrder = (isEqual(type, "market"));
        if (isTrue(isTrue(isLimitOrder) && isTrue(isEqual(price, null))))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " createOrder () requires a price argument for "), type), " orders")) ;
        }
        if (isTrue(isMarketOrder))
        {
            if (isTrue(isTrue((isEqual(timeInForce, "poc"))) || isTrue((isEqual(timeInForce, "gtc")))))
            {
                throw new ExchangeError ((string)add(this.id, " createOrder () timeInForce for market order can only be \"FOK\" or \"IOC\"")) ;
            } else
            {
                if (isTrue(isEqual(timeInForce, null)))
                {
                    object defaultTif = this.safeString(this.options, "defaultTimeInForce", "IOC");
                    object exchangeSpecificTif = this.safeString(getValue(this.options, "timeInForce"), defaultTif, "ioc");
                    timeInForce = exchangeSpecificTif;
                }
            }
            if (isTrue(contract))
            {
                price = 0;
            }
        }
        if (isTrue(contract))
        {
            object isClose = this.safeValue(parameters, "close");
            if (isTrue(isClose))
            {
                amount = 0;
            } else
            {
                object amountToPrecision = this.amountToPrecision(symbol, amount);
                object signedAmount = ((bool) isTrue((isEqual(side, "sell")))) ? Precise.stringNeg(amountToPrecision) : amountToPrecision;
                amount = parseInt(signedAmount);
            }
        }
        object request = null;
        object nonTriggerOrder = !isTrue(isStopOrder) && isTrue((isEqual(trigger, null)));
        if (isTrue(nonTriggerOrder))
        {
            if (isTrue(contract))
            {
                // contract order
                request = new Dictionary<string, object>() {
                    { "contract", getValue(market, "id") },
                    { "size", amount },
                };
                if (!isTrue(getValue(market, "option")))
                {
                    ((IDictionary<string,object>)request)["settle"] = getValue(market, "settleId"); // filled in prepareRequest above
                }
                if (isTrue(isMarketOrder))
                {
                    ((IDictionary<string,object>)request)["price"] = price; // set to 0 for market orders
                } else
                {
                    ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
                }
                if (isTrue(!isEqual(reduceOnly, null)))
                {
                    ((IDictionary<string,object>)request)["reduce_only"] = reduceOnly;
                }
                if (isTrue(!isEqual(timeInForce, null)))
                {
                    ((IDictionary<string,object>)request)["tif"] = timeInForce;
                }
            } else
            {
                object marginMode = null;
                var marginModeparametersVariable = this.getMarginMode(false, parameters);
                marginMode = ((IList<object>)marginModeparametersVariable)[0];
                parameters = ((IList<object>)marginModeparametersVariable)[1];
                // spot order
                request = new Dictionary<string, object>() {
                    { "currency_pair", getValue(market, "id") },
                    { "type", type },
                    { "account", marginMode },
                    { "side", side },
                };
                if (isTrue(isTrue(isMarketOrder) && isTrue((isEqual(side, "buy")))))
                {
                    object quoteAmount = null;
                    object createMarketBuyOrderRequiresPrice = true;
                    var createMarketBuyOrderRequiresPriceparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                    createMarketBuyOrderRequiresPrice = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[0];
                    parameters = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[1];
                    object cost = this.safeNumber(parameters, "cost");
                    parameters = this.omit(parameters, "cost");
                    if (isTrue(!isEqual(cost, null)))
                    {
                        quoteAmount = this.costToPrecision(symbol, cost);
                    } else if (isTrue(createMarketBuyOrderRequiresPrice))
                    {
                        if (isTrue(isEqual(price, null)))
                        {
                            throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument")) ;
                        } else
                        {
                            object amountString = this.numberToString(amount);
                            object priceString = this.numberToString(price);
                            object costRequest = Precise.stringMul(amountString, priceString);
                            quoteAmount = this.costToPrecision(symbol, costRequest);
                        }
                    } else
                    {
                        quoteAmount = this.costToPrecision(symbol, amount);
                    }
                    ((IDictionary<string,object>)request)["amount"] = quoteAmount;
                } else
                {
                    ((IDictionary<string,object>)request)["amount"] = this.amountToPrecision(symbol, amount);
                }
                if (isTrue(isLimitOrder))
                {
                    ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
                }
                if (isTrue(!isEqual(timeInForce, null)))
                {
                    ((IDictionary<string,object>)request)["time_in_force"] = timeInForce;
                }
            }
            object clientOrderId = this.safeString2(parameters, "text", "clientOrderId");
            object textIsRequired = this.safeBool(parameters, "textIsRequired", false);
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                // user-defined, must follow the rules if not empty
                //     prefixed with t-
                //     no longer than 28 bytes without t- prefix
                //     can only include 0-9, A-Z, a-z, underscores (_), hyphens (-) or dots (.)
                if (isTrue(isGreaterThan(((string)clientOrderId).Length, 28)))
                {
                    throw new BadRequest ((string)add(this.id, " createOrder () clientOrderId or text param must be up to 28 characters")) ;
                }
                parameters = this.omit(parameters, new List<object>() {"text", "clientOrderId", "textIsRequired"});
                if (isTrue(!isEqual(getValue(clientOrderId, 0), "t")))
                {
                    clientOrderId = add("t-", clientOrderId);
                }
                ((IDictionary<string,object>)request)["text"] = clientOrderId;
            } else
            {
                if (isTrue(textIsRequired))
                {
                    // batchOrders requires text in the request
                    ((IDictionary<string,object>)request)["text"] = add("t-", this.uuid16());
                }
            }
        } else
        {
            if (isTrue(getValue(market, "option")))
            {
                throw new NotSupported ((string)add(this.id, " createOrder() conditional option orders are not supported")) ;
            }
            if (isTrue(contract))
            {
                // contract conditional order
                request = new Dictionary<string, object>() {
                    { "initial", new Dictionary<string, object>() {
                        { "contract", getValue(market, "id") },
                        { "size", amount },
                        { "price", this.priceToPrecision(symbol, price) },
                    } },
                    { "settle", getValue(market, "settleId") },
                };
                if (isTrue(isEqual(trigger, null)))
                {
                    object rule = null;
                    object triggerOrderPrice = null;
                    if (isTrue(isStopLossOrder))
                    {
                        // we let trigger orders be aliases for stopLoss orders because
                        // gateio doesn't accept conventional trigger orders for spot markets
                        rule = ((bool) isTrue((isEqual(side, "buy")))) ? 1 : 2;
                        triggerOrderPrice = this.priceToPrecision(symbol, stopLossPrice);
                    } else if (isTrue(isTakeProfitOrder))
                    {
                        rule = ((bool) isTrue((isEqual(side, "buy")))) ? 2 : 1;
                        triggerOrderPrice = this.priceToPrecision(symbol, takeProfitPrice);
                    }
                    object priceType = this.safeInteger(parameters, "price_type", 0);
                    if (isTrue(isTrue(isLessThan(priceType, 0)) || isTrue(isGreaterThan(priceType, 2))))
                    {
                        throw new BadRequest ((string)add(this.id, " createOrder () price_type should be 0 latest deal price, 1 mark price, 2 index price")) ;
                    }
                    parameters = this.omit(parameters, new List<object>() {"price_type"});
                    ((IDictionary<string,object>)request)["trigger"] = new Dictionary<string, object>() {
                        { "price_type", priceType },
                        { "price", this.priceToPrecision(symbol, triggerOrderPrice) },
                        { "rule", rule },
                    };
                }
                if (isTrue(!isEqual(reduceOnly, null)))
                {
                    ((IDictionary<string,object>)getValue(request, "initial"))["reduce_only"] = reduceOnly;
                }
                if (isTrue(!isEqual(timeInForce, null)))
                {
                    ((IDictionary<string,object>)getValue(request, "initial"))["tif"] = timeInForce;
                }
            } else
            {
                // spot conditional order
                object options = this.safeValue(this.options, "createOrder", new Dictionary<string, object>() {});
                object marginMode = null;
                var marginModeparametersVariable = this.getMarginMode(true, parameters);
                marginMode = ((IList<object>)marginModeparametersVariable)[0];
                parameters = ((IList<object>)marginModeparametersVariable)[1];
                if (isTrue(isEqual(timeInForce, null)))
                {
                    timeInForce = "gtc";
                }
                request = new Dictionary<string, object>() {
                    { "put", new Dictionary<string, object>() {
                        { "type", type },
                        { "side", side },
                        { "price", this.priceToPrecision(symbol, price) },
                        { "amount", this.amountToPrecision(symbol, amount) },
                        { "account", marginMode },
                        { "time_in_force", timeInForce },
                    } },
                    { "market", getValue(market, "id") },
                };
                if (isTrue(isEqual(trigger, null)))
                {
                    object defaultExpiration = this.safeInteger(options, "expiration");
                    object expiration = this.safeInteger(parameters, "expiration", defaultExpiration);
                    object rule = null;
                    object triggerOrderPrice = null;
                    if (isTrue(isStopLossOrder))
                    {
                        // we let trigger orders be aliases for stopLoss orders because
                        // gateio doesn't accept conventional trigger orders for spot markets
                        rule = ((bool) isTrue((isEqual(side, "buy")))) ? ">=" : "<=";
                        triggerOrderPrice = this.priceToPrecision(symbol, stopLossPrice);
                    } else if (isTrue(isTakeProfitOrder))
                    {
                        rule = ((bool) isTrue((isEqual(side, "buy")))) ? "<=" : ">=";
                        triggerOrderPrice = this.priceToPrecision(symbol, takeProfitPrice);
                    }
                    ((IDictionary<string,object>)request)["trigger"] = new Dictionary<string, object>() {
                        { "price", this.priceToPrecision(symbol, triggerOrderPrice) },
                        { "rule", rule },
                        { "expiration", expiration },
                    };
                }
            }
        }
        return this.extend(request, parameters);
    }

    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        /**
        * @method
        * @name gate#createMarketBuyOrderWithCost
        * @description create a market buy order by providing the symbol and cost
        * @see https://www.gate.io/docs/developers/apiv4/en/#create-an-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {float} cost how much you want to trade in units of the quote currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
        }
        ((IDictionary<string,object>)parameters)["createMarketBuyOrderRequiresPrice"] = false;
        return await this.createOrder(symbol, "market", "buy", cost, null, parameters);
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#editOrder
        * @description edit a trade order, gate currently only supports the modification of the price or amount fields
        * @see https://www.gate.io/docs/developers/apiv4/en/#amend-an-order
        * @see https://www.gate.io/docs/developers/apiv4/en/#amend-an-order-2
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of the currency you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the base currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var marketTypequeryVariable = this.handleMarketTypeAndParams("editOrder", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        object account = this.convertTypeToAccount(marketType);
        object isLimitOrder = (isEqual(type, "limit"));
        if (isTrue(isEqual(account, "spot")))
        {
            if (!isTrue(isLimitOrder))
            {
                throw new InvalidOrder ((string)add(add(add(add(add(this.id, " editOrder() does not support "), type), " orders for "), marketType), " markets")) ;
            }
        }
        object request = new Dictionary<string, object>() {
            { "order_id", id },
            { "currency_pair", getValue(market, "id") },
            { "account", account },
        };
        if (isTrue(!isEqual(amount, null)))
        {
            if (isTrue(getValue(market, "spot")))
            {
                ((IDictionary<string,object>)request)["amount"] = this.amountToPrecision(symbol, amount);
            } else
            {
                if (isTrue(isEqual(side, "sell")))
                {
                    ((IDictionary<string,object>)request)["size"] = Precise.stringNeg(this.amountToPrecision(symbol, amount));
                } else
                {
                    ((IDictionary<string,object>)request)["size"] = this.amountToPrecision(symbol, amount);
                }
            }
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.privateSpotPatchOrdersOrderId(this.extend(request, query));
        } else
        {
            ((IDictionary<string,object>)request)["settle"] = getValue(market, "settleId");
            response = await this.privateFuturesPutSettleOrdersOrderId(this.extend(request, query));
        }
        //
        //     {
        //         "id": "243233276443",
        //         "text": "apiv4",
        //         "create_time": "1670908873",
        //         "update_time": "1670914102",
        //         "create_time_ms": 1670908873077,
        //         "update_time_ms": 1670914102241,
        //         "status": "open",
        //         "currency_pair": "ADA_USDT",
        //         "type": "limit",
        //         "account": "spot",
        //         "side": "sell",
        //         "amount": "10",
        //         "price": "0.6",
        //         "time_in_force": "gtc",
        //         "iceberg": "0",
        //         "left": "10",
        //         "fill_price": "0",
        //         "filled_total": "0",
        //         "fee": "0",
        //         "fee_currency": "USDT",
        //         "point_fee": "0",
        //         "gt_fee": "0",
        //         "gt_maker_fee": "0",
        //         "gt_taker_fee": "0",
        //         "gt_discount": false,
        //         "rebated_fee": "0",
        //         "rebated_fee_currency": "ADA"
        //     }
        //
        return this.parseOrder(response, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "open", "open" },
            { "_new", "open" },
            { "filled", "closed" },
            { "cancelled", "canceled" },
            { "liquidated", "closed" },
            { "ioc", "canceled" },
            { "failed", "canceled" },
            { "expired", "canceled" },
            { "finished", "closed" },
            { "finish", "closed" },
            { "succeeded", "closed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // SPOT
        // createOrder/cancelOrder/fetchOrder/editOrder
        //
        //    {
        //        "id": "62364648575",
        //        "text": "apiv4",
        //        "create_time": "1626354834",
        //        "update_time": "1626354834",
        //        "create_time_ms": "1626354833544",
        //        "update_time_ms": "1626354833544",
        //        "status": "open",
        //        "currency_pair": "BTC_USDT",
        //        "type": "limit",
        //        "account": "spot",
        //        "side": "buy",
        //        "amount": "0.0001",
        //        "price": "30000",
        //        "time_in_force": "gtc",
        //        "iceberg": "0",
        //        "left": "0.0001",
        //        "fill_price": "0",
        //        "filled_total": "0",
        //        "fee": "0",
        //        "fee_currency": "BTC",
        //        "point_fee": "0",
        //        "gt_fee": "0",
        //        "gt_discount": true,
        //        "rebated_fee": "0",
        //        "rebated_fee_currency": "USDT"
        //     }
        //
        // SPOT TRIGGER ORDERS
        // createOrder
        //
        //    {
        //        "id": 12604556
        //    }
        //
        // fetchOrder/cancelOrder
        //
        //    {
        //        "market": "ADA_USDT",
        //        "user": 6392049,
        //        "trigger": {
        //            "price": "1.08", // stopPrice
        //            "rule": "\u003e=",
        //            "expiration": 86400
        //        },
        //        "put": {
        //            "type": "limit",
        //            "side": "buy",
        //            "price": "1.08", // order price
        //            "amount": "1.00000000000000000000",
        //            "account": "normal",
        //            "time_in_force": "gtc"
        //        },
        //        "id": 71639298,
        //        "ctime": 1643945985,
        //        "status": "open"
        //    }
        //
        // FUTURE, SWAP AND OPTION
        // createOrder/cancelOrder/fetchOrder
        //
        //    {
        //        "id": 123028481731,
        //        "contract": "ADA_USDT",
        //        "mkfr": "-0.00005",
        //        "tkfr": "0.00048",
        //        "tif": "ioc",
        //        "is_reduce_only": false,
        //        "create_time": 1643950262.68,
        //        "finish_time": 1643950262.68,
        //        "price": "0",
        //        "size": 1,
        //        "refr": "0",
        //        "left":0,
        //        "text": "api",
        //        "fill_price": "1.05273",
        //        "user":6329238,
        //        "finish_as": "filled",
        //        "status": "finished",
        //        "is_liq": false,
        //        "refu":0,
        //        "is_close": false,
        //        "iceberg": 0
        //    }
        //
        // TRIGGER ORDERS (FUTURE AND SWAP)
        // createOrder
        //
        //    {
        //        "id": 12604556
        //    }
        //
        // fetchOrder/cancelOrder
        //
        //    {
        //        "user": 6320300,
        //        "trigger": {
        //            "strategy_type": 0,
        //            "price_type": 0,
        //            "price": "1.03", // stopPrice
        //            "rule": 2,
        //            "expiration": 0
        //        },
        //        "initial": {
        //            "contract": "ADA_USDT",
        //            "size": -1,
        //            "price": "1.02",
        //            "tif": "gtc",
        //            "text": "",
        //            "iceberg": 0,
        //            "is_close": false,
        //            "is_reduce_only": false,
        //            "auto_size": ""
        //        },
        //        "id": 126393906,
        //        "trade_id": 0,
        //        "status": "open",
        //        "reason": "",
        //        "create_time": 1643953482,
        //        "finish_time": 1643953482,
        //        "is_stop_order": false,
        //        "stop_trigger": {
        //            "rule": 0,
        //            "trigger_price": "",
        //            "order_price": ""
        //        },
        //        "me_order_id": 0,
        //        "order_type": ""
        //    }
        //
        //    {
        //        "text": "t-d18baf9ac44d82e2",
        //        "succeeded": false,
        //        "label": "BALANCE_NOT_ENOUGH",
        //        "message": "Not enough balance"
        //    }
        //
        object succeeded = this.safeBool(order, "succeeded", true);
        if (!isTrue(succeeded))
        {
            // cancelOrders response
            return this.safeOrder(new Dictionary<string, object>() {
                { "clientOrderId", this.safeString(order, "text") },
                { "info", order },
                { "status", "rejected" },
            });
        }
        object put = this.safeValue2(order, "put", "initial", new Dictionary<string, object>() {});
        object trigger = this.safeValue(order, "trigger", new Dictionary<string, object>() {});
        object contract = this.safeString(put, "contract");
        object type = this.safeString(put, "type");
        object timeInForce = this.safeStringUpper2(put, "time_in_force", "tif");
        object amount = this.safeString2(put, "amount", "size");
        object side = this.safeString(put, "side");
        object price = this.safeString(put, "price");
        contract = this.safeString(order, "contract", contract);
        type = this.safeString(order, "type", type);
        timeInForce = this.safeStringUpper2(order, "time_in_force", "tif", timeInForce);
        if (isTrue(isEqual(timeInForce, "POC")))
        {
            timeInForce = "PO";
        }
        object postOnly = (isEqual(timeInForce, "PO"));
        amount = this.safeString2(order, "amount", "size", amount);
        side = this.safeString(order, "side", side);
        price = this.safeString(order, "price", price);
        object remainingString = this.safeString(order, "left");
        object cost = this.safeString(order, "filled_total");
        object triggerPrice = this.safeNumber(trigger, "price");
        object average = this.safeNumber2(order, "avg_deal_price", "fill_price");
        if (isTrue(triggerPrice))
        {
            remainingString = amount;
            cost = "0";
        }
        if (isTrue(contract))
        {
            object isMarketOrder = isTrue(Precise.stringEquals(price, "0")) && isTrue((isEqual(timeInForce, "IOC")));
            type = ((bool) isTrue(isMarketOrder)) ? "market" : "limit";
            side = ((bool) isTrue(Precise.stringGt(amount, "0"))) ? "buy" : "sell";
        }
        object rawStatus = this.safeStringN(order, new List<object>() {"finish_as", "status", "open"});
        object timestamp = this.safeInteger(order, "create_time_ms");
        if (isTrue(isEqual(timestamp, null)))
        {
            timestamp = this.safeTimestamp2(order, "create_time", "ctime");
        }
        object lastTradeTimestamp = this.safeInteger(order, "update_time_ms");
        if (isTrue(isEqual(lastTradeTimestamp, null)))
        {
            lastTradeTimestamp = this.safeTimestamp2(order, "update_time", "finish_time");
        }
        object marketType = "contract";
        if (isTrue(isTrue((inOp(order, "currency_pair"))) || isTrue((inOp(order, "market")))))
        {
            marketType = "spot";
        }
        object exchangeSymbol = this.safeString2(order, "currency_pair", "market", contract);
        object symbol = this.safeSymbol(exchangeSymbol, market, "_", marketType);
        // Everything below this(above return) is related to fees
        object fees = new List<object>() {};
        object gtFee = this.safeString(order, "gt_fee");
        if (isTrue(gtFee))
        {
            ((IList<object>)fees).Add(new Dictionary<string, object>() {
                { "currency", "GT" },
                { "cost", gtFee },
            });
        }
        object fee = this.safeString(order, "fee");
        if (isTrue(fee))
        {
            ((IList<object>)fees).Add(new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(this.safeString(order, "fee_currency")) },
                { "cost", fee },
            });
        }
        object rebate = this.safeString(order, "rebated_fee");
        if (isTrue(rebate))
        {
            ((IList<object>)fees).Add(new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(this.safeString(order, "rebated_fee_currency")) },
                { "cost", Precise.stringNeg(rebate) },
            });
        }
        object numFeeCurrencies = getArrayLength(fees);
        object multipleFeeCurrencies = isGreaterThan(numFeeCurrencies, 1);
        object status = this.parseOrderStatus(rawStatus);
        object remaining = Precise.stringAbs(remainingString);
        // handle spot market buy
        object account = this.safeString(order, "account"); // using this instead of market type because of the conflicting ids
        if (isTrue(isEqual(account, "spot")))
        {
            object averageString = this.safeString(order, "avg_deal_price");
            average = this.parseNumber(averageString);
            if (isTrue(isTrue((isEqual(type, "market"))) && isTrue((isEqual(side, "buy")))))
            {
                remaining = Precise.stringDiv(remainingString, averageString);
                price = null; // arrives as 0
                cost = amount;
                amount = Precise.stringDiv(amount, averageString);
            }
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(order, "id") },
            { "clientOrderId", this.safeString(order, "text") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "status", status },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "reduceOnly", this.safeValue(order, "is_reduce_only") },
            { "side", side },
            { "price", price },
            { "stopPrice", triggerPrice },
            { "triggerPrice", triggerPrice },
            { "average", average },
            { "amount", Precise.stringAbs(amount) },
            { "cost", Precise.stringAbs(cost) },
            { "filled", null },
            { "remaining", remaining },
            { "fee", ((bool) isTrue(multipleFeeCurrencies)) ? null : this.safeValue(fees, 0) },
            { "fees", ((bool) isTrue(multipleFeeCurrencies)) ? fees : new List<object>() {} },
            { "trades", null },
            { "info", order },
        }, market);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchOrder
        * @description Retrieves information on an order
        * @see https://www.gate.io/docs/developers/apiv4/en/#get-a-single-order
        * @see https://www.gate.io/docs/developers/apiv4/en/#get-a-single-order-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#get-a-single-order-3
        * @see https://www.gate.io/docs/developers/apiv4/en/#get-a-single-order-4
        * @param {string} id Order id
        * @param {string} symbol Unified market symbol, *required for spot and margin*
        * @param {object} [params] Parameters specified by the exchange api
        * @param {bool} [params.stop] True if the order being fetched is a trigger order
        * @param {string} [params.marginMode] 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
        * @param {string} [params.type] 'spot', 'swap', or 'future', if not provided this.options['defaultMarginMode'] is used
        * @param {string} [params.settle] 'btc' or 'usdt' - settle currency for perpetual swap and future - market settle currency is used if symbol !== undefined, default="usdt" for swap and "btc" for future
        * @returns An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object stop = this.safeValue2(parameters, "is_stop_order", "stop", false);
        parameters = this.omit(parameters, new List<object>() {"is_stop_order", "stop"});
        object clientOrderId = this.safeString2(parameters, "text", "clientOrderId");
        object orderId = id;
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"text", "clientOrderId"});
            if (isTrue(!isEqual(getValue(clientOrderId, 0), "t")))
            {
                clientOrderId = add("t-", clientOrderId);
            }
            orderId = clientOrderId;
        }
        object market = ((bool) isTrue((isEqual(symbol, null)))) ? null : this.market(symbol);
        var typequeryVariable = this.handleMarketTypeAndParams("fetchOrder", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        object contract = isTrue(isTrue((isEqual(type, "swap"))) || isTrue((isEqual(type, "future")))) || isTrue((isEqual(type, "option")));
        var requestrequestParamsVariable = ((bool) isTrue(contract)) ? this.prepareRequest(market, type, query) : this.spotOrderPrepareRequest(market, stop, query);
        var request = ((IList<object>) requestrequestParamsVariable)[0];
        var requestParams = ((IList<object>) requestrequestParamsVariable)[1];
        ((IDictionary<string,object>)request)["order_id"] = orderId;
        object response = null;
        if (isTrue(isTrue(isEqual(type, "spot")) || isTrue(isEqual(type, "margin"))))
        {
            if (isTrue(stop))
            {
                response = await this.privateSpotGetPriceOrdersOrderId(this.extend(request, requestParams));
            } else
            {
                response = await this.privateSpotGetOrdersOrderId(this.extend(request, requestParams));
            }
        } else if (isTrue(isEqual(type, "swap")))
        {
            if (isTrue(stop))
            {
                response = await this.privateFuturesGetSettlePriceOrdersOrderId(this.extend(request, requestParams));
            } else
            {
                response = await this.privateFuturesGetSettleOrdersOrderId(this.extend(request, requestParams));
            }
        } else if (isTrue(isEqual(type, "future")))
        {
            if (isTrue(stop))
            {
                response = await this.privateDeliveryGetSettlePriceOrdersOrderId(this.extend(request, requestParams));
            } else
            {
                response = await this.privateDeliveryGetSettleOrdersOrderId(this.extend(request, requestParams));
            }
        } else if (isTrue(isEqual(type, "option")))
        {
            response = await this.privateOptionsGetOrdersOrderId(this.extend(request, requestParams));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchOrder() not support this market type")) ;
        }
        return this.parseOrder(response, market);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-open-orders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {bool} [params.stop] true for fetching stop orders
        * @param {string} [params.type] spot, margin, swap or future, if not provided this.options['defaultType'] is used
        * @param {string} [params.marginMode] 'cross' or 'isolated' - marginMode for type='margin', if not provided this.options['defaultMarginMode'] is used
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("open", symbol, since, limit, parameters);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-orders
        * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-running-auto-order-list
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-futures-orders
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-auto-orders
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-futures-orders-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-auto-orders-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-options-orders
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {bool} [params.stop] true for fetching stop orders
        * @param {string} [params.type] spot, swap or future, if not provided this.options['defaultType'] is used
        * @param {string} [params.marginMode] 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("finished", symbol, since, limit, parameters);
    }

    public async virtual Task<object> fetchOrdersByStatus(object status, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        object stop = this.safeValue(parameters, "stop");
        parameters = this.omit(parameters, "stop");
        var typequeryVariable = this.handleMarketTypeAndParams("fetchOrdersByStatus", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        object spot = isTrue((isEqual(type, "spot"))) || isTrue((isEqual(type, "margin")));
        var requestrequestParamsVariable = ((bool) isTrue(spot)) ? this.multiOrderSpotPrepareRequest(market, stop, query) : this.prepareRequest(market, type, query);
        var request = ((IList<object>) requestrequestParamsVariable)[0];
        var requestParams = ((IList<object>) requestrequestParamsVariable)[1];
        if (isTrue(isEqual(status, "closed")))
        {
            status = "finished";
        }
        ((IDictionary<string,object>)request)["status"] = status;
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(isTrue(!isEqual(since, null)) && isTrue(spot)))
        {
            ((IDictionary<string,object>)request)["from"] = this.parseToInt(divide(since, 1000));
        }
        object openSpotOrders = isTrue(isTrue(spot) && isTrue((isEqual(status, "open")))) && !isTrue(stop);
        object response = null;
        if (isTrue(isTrue(isEqual(type, "spot")) || isTrue(isEqual(type, "margin"))))
        {
            if (isTrue(openSpotOrders))
            {
                response = await this.privateSpotGetOpenOrders(this.extend(request, requestParams));
            } else if (isTrue(stop))
            {
                response = await this.privateSpotGetPriceOrders(this.extend(request, requestParams));
            } else
            {
                response = await this.privateSpotGetOrders(this.extend(request, requestParams));
            }
        } else if (isTrue(isEqual(type, "swap")))
        {
            if (isTrue(stop))
            {
                response = await this.privateFuturesGetSettlePriceOrders(this.extend(request, requestParams));
            } else
            {
                response = await this.privateFuturesGetSettleOrders(this.extend(request, requestParams));
            }
        } else if (isTrue(isEqual(type, "future")))
        {
            if (isTrue(stop))
            {
                response = await this.privateDeliveryGetSettlePriceOrders(this.extend(request, requestParams));
            } else
            {
                response = await this.privateDeliveryGetSettleOrders(this.extend(request, requestParams));
            }
        } else if (isTrue(isEqual(type, "option")))
        {
            response = await this.privateOptionsGetOrders(this.extend(request, requestParams));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchOrders() not support this market type")) ;
        }
        //
        // spot open orders
        //
        //    [
        //        {
        //            "currency_pair": "ADA_USDT",
        //            "total": 2,
        //            "orders": [
        //                {
        //                    "id": "155498539874",
        //                    "text": "apiv4",
        //                    "create_time": "1652406843",
        //                    "update_time": "1652406843",
        //                    "create_time_ms": 1652406843295,
        //                    "update_time_ms": 1652406843295,
        //                    "status": "open",
        //                    "currency_pair": "ADA_USDT",
        //                    "type": "limit",
        //                    "account": "spot",
        //                    "side": "buy",
        //                    "amount": "3",
        //                    "price": "0.35",
        //                    "time_in_force": "gtc",
        //                    "iceberg": "0",
        //                    "left": "3",
        //                    "fill_price": "0",
        //                    "filled_total": "0",
        //                    "fee": "0",
        //                    "fee_currency": "ADA",
        //                    "point_fee": "0",
        //                    "gt_fee": "0",
        //                    "gt_discount": false,
        //                    "rebated_fee": "0",
        //                    "rebated_fee_currency": "USDT"
        //                },
        //                ...
        //            ]
        //        },
        //        ...
        //    ]
        //
        // spot
        //
        //    [
        //        {
        //           "id": "8834234273",
        //           "text": "3",
        //           "create_time": "1635406193",
        //           "update_time": "1635406193",
        //           "create_time_ms": 1635406193361,
        //           "update_time_ms": 1635406193361,
        //           "status": "closed",
        //           "currency_pair": "BTC_USDT",
        //           "type": "limit",
        //           "account": "spot", // margin for margin orders
        //           "side": "sell",
        //           "amount": "0.0002",
        //           "price": "58904.01",
        //           "time_in_force": "gtc",
        //           "iceberg": "0",
        //           "left": "0.0000",
        //           "fill_price": "11.790516",
        //           "filled_total": "11.790516",
        //           "fee": "0.023581032",
        //           "fee_currency": "USDT",
        //           "point_fee": "0",
        //           "gt_fee": "0",
        //           "gt_discount": false,
        //           "rebated_fee_currency": "BTC"
        //        }
        //    ]
        //
        // spot stop
        //
        //    [
        //        {
        //            "market": "ADA_USDT",
        //            "user": 10406147,
        //            "trigger": {
        //                "price": "0.65",
        //                "rule": "\u003c=",
        //                "expiration": 86400
        //            },
        //            "put": {
        //                "type": "limit",
        //                "side": "sell",
        //                "price": "0.65",
        //                "amount": "2.00000000000000000000",
        //                "account": "normal",  // margin for margin orders
        //                "time_in_force": "gtc"
        //            },
        //            "id": 8449909,
        //            "ctime": 1652188982,
        //            "status": "open"
        //        }
        //    ]
        //
        // swap
        //
        //    [
        //        {
        //           "status": "finished",
        //           "size": -1,
        //           "left": 0,
        //           "id": 82750739203,
        //           "is_liq": false,
        //           "is_close": false,
        //           "contract": "BTC_USDT",
        //           "text": "web",
        //           "fill_price": "60721.3",
        //           "finish_as": "filled",
        //           "iceberg": 0,
        //           "tif": "ioc",
        //           "is_reduce_only": true,
        //           "create_time": 1635403475.412,
        //           "finish_time": 1635403475.4127,
        //           "price": "0"
        //        }
        //    ]
        //
        // option
        //
        //     [
        //         {
        //             "id": 2593450699,
        //             "contract": "BTC_USDT-20230601-27500-C",
        //             "mkfr": "0.0003",
        //             "tkfr": "0.0003",
        //             "tif": "gtc",
        //             "is_reduce_only": false,
        //             "create_time": 1685503873,
        //             "price": "200",
        //             "size": 1,
        //             "refr": "0",
        //             "left": 1,
        //             "text": "api",
        //             "fill_price": "0",
        //             "user": 5691076,
        //             "status": "open",
        //             "is_liq": false,
        //             "refu": 0,
        //             "is_close": false,
        //             "iceberg": 0
        //         }
        //     ]
        //
        object result = response;
        if (isTrue(openSpotOrders))
        {
            result = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
            {
                object ordersInner = this.safeValue(getValue(response, i), "orders");
                result = this.arrayConcat(result, ordersInner);
            }
        }
        object orders = this.parseOrders(result, market, since, limit);
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#cancelOrder
        * @description Cancels an open order
        * @see https://www.gate.io/docs/developers/apiv4/en/#cancel-a-single-order
        * @see https://www.gate.io/docs/developers/apiv4/en/#cancel-a-single-order-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#cancel-a-single-order-3
        * @see https://www.gate.io/docs/developers/apiv4/en/#cancel-a-single-order-4
        * @param {string} id Order id
        * @param {string} symbol Unified market symbol
        * @param {object} [params] Parameters specified by the exchange api
        * @param {bool} [params.stop] True if the order to be cancelled is a trigger order
        * @returns An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = ((bool) isTrue((isEqual(symbol, null)))) ? null : this.market(symbol);
        object stop = this.safeValue2(parameters, "is_stop_order", "stop", false);
        parameters = this.omit(parameters, new List<object>() {"is_stop_order", "stop"});
        var typequeryVariable = this.handleMarketTypeAndParams("cancelOrder", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        var requestrequestParamsVariable = ((bool) isTrue((isTrue(isEqual(type, "spot")) || isTrue(isEqual(type, "margin"))))) ? this.spotOrderPrepareRequest(market, stop, query) : this.prepareRequest(market, type, query);
        var request = ((IList<object>) requestrequestParamsVariable)[0];
        var requestParams = ((IList<object>) requestrequestParamsVariable)[1];
        ((IDictionary<string,object>)request)["order_id"] = id;
        object response = null;
        if (isTrue(isTrue(isEqual(type, "spot")) || isTrue(isEqual(type, "margin"))))
        {
            if (isTrue(stop))
            {
                response = await this.privateSpotDeletePriceOrdersOrderId(this.extend(request, requestParams));
            } else
            {
                response = await this.privateSpotDeleteOrdersOrderId(this.extend(request, requestParams));
            }
        } else if (isTrue(isEqual(type, "swap")))
        {
            if (isTrue(stop))
            {
                response = await this.privateFuturesDeleteSettlePriceOrdersOrderId(this.extend(request, requestParams));
            } else
            {
                response = await this.privateFuturesDeleteSettleOrdersOrderId(this.extend(request, requestParams));
            }
        } else if (isTrue(isEqual(type, "future")))
        {
            if (isTrue(stop))
            {
                response = await this.privateDeliveryDeleteSettlePriceOrdersOrderId(this.extend(request, requestParams));
            } else
            {
                response = await this.privateDeliveryDeleteSettleOrdersOrderId(this.extend(request, requestParams));
            }
        } else if (isTrue(isEqual(type, "option")))
        {
            response = await this.privateOptionsDeleteOrdersOrderId(this.extend(request, requestParams));
        } else
        {
            throw new NotSupported ((string)add(this.id, " cancelOrder() not support this market type")) ;
        }
        //
        // spot
        //
        //     {
        //         "id": "95282841887",
        //         "text": "apiv4",
        //         "create_time": "1637383156",
        //         "update_time": "1637383235",
        //         "create_time_ms": 1637383156017,
        //         "update_time_ms": 1637383235085,
        //         "status": "cancelled",
        //         "currency_pair": "ETH_USDT",
        //         "type": "limit",
        //         "account": "spot",
        //         "side": "buy",
        //         "amount": "0.01",
        //         "price": "3500",
        //         "time_in_force": "gtc",
        //         "iceberg": "0",
        //         "left": "0.01",
        //         "fill_price": "0",
        //         "filled_total": "0",
        //         "fee": "0",
        //         "fee_currency": "ETH",
        //         "point_fee": "0",
        //         "gt_fee": "0",
        //         "gt_discount": false,
        //         "rebated_fee": "0",
        //         "rebated_fee_currency": "USDT"
        //     }
        //
        // spot conditional
        //
        //     {
        //         "market": "ETH_USDT",
        //         "user": 2436035,
        //         "trigger": {
        //             "price": "3500",
        //             "rule": "\u003c=",
        //             "expiration": 86400
        //         },
        //         "put": {
        //             "type": "limit",
        //             "side": "buy",
        //             "price": "3500",
        //             "amount": "0.01000000000000000000",
        //             "account": "normal",
        //             "time_in_force": "gtc"
        //         },
        //         "id": 5891843,
        //         "ctime": 1637382379,
        //         "ftime": 1637382673,
        //         "status": "canceled"
        //     }
        //
        // swap, future and option
        //
        //     {
        //         "id": "82241928192",
        //         "contract": "BTC_USDT",
        //         "mkfr": "0",
        //         "tkfr": "0.0005",
        //         "tif": "gtc",
        //         "is_reduce_only": false,
        //         "create_time": "1635196145.06",
        //         "finish_time": "1635196233.396",
        //         "price": "61000",
        //         "size": "4",
        //         "refr": "0",
        //         "left": "4",
        //         "text": "web",
        //         "fill_price": "0",
        //         "user": "6693577",
        //         "finish_as": "cancelled",
        //         "status": "finished",
        //         "is_liq": false,
        //         "refu": "0",
        //         "is_close": false,
        //         "iceberg": "0",
        //     }
        //
        return this.parseOrder(response, market);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#cancelAllOrders
        * @description cancel all open orders
        * @see https://www.gate.io/docs/developers/apiv4/en/#cancel-all-open-orders-in-specified-currency-pair
        * @see https://www.gate.io/docs/developers/apiv4/en/#cancel-all-open-orders-matched
        * @see https://www.gate.io/docs/developers/apiv4/en/#cancel-all-open-orders-matched-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#cancel-all-open-orders-matched-3
        * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = ((bool) isTrue((isEqual(symbol, null)))) ? null : this.market(symbol);
        object stop = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        var typequeryVariable = this.handleMarketTypeAndParams("cancelAllOrders", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        var requestrequestParamsVariable = ((bool) isTrue((isEqual(type, "spot")))) ? this.multiOrderSpotPrepareRequest(market, stop, query) : this.prepareRequest(market, type, query);
        var request = ((IList<object>) requestrequestParamsVariable)[0];
        var requestParams = ((IList<object>) requestrequestParamsVariable)[1];
        object response = null;
        if (isTrue(isTrue(isEqual(type, "spot")) || isTrue(isEqual(type, "margin"))))
        {
            if (isTrue(stop))
            {
                response = await this.privateSpotDeletePriceOrders(this.extend(request, requestParams));
            } else
            {
                response = await this.privateSpotDeleteOrders(this.extend(request, requestParams));
            }
        } else if (isTrue(isEqual(type, "swap")))
        {
            if (isTrue(stop))
            {
                response = await this.privateFuturesDeleteSettlePriceOrders(this.extend(request, requestParams));
            } else
            {
                response = await this.privateFuturesDeleteSettleOrders(this.extend(request, requestParams));
            }
        } else if (isTrue(isEqual(type, "future")))
        {
            if (isTrue(stop))
            {
                response = await this.privateDeliveryDeleteSettlePriceOrders(this.extend(request, requestParams));
            } else
            {
                response = await this.privateDeliveryDeleteSettleOrders(this.extend(request, requestParams));
            }
        } else if (isTrue(isEqual(type, "option")))
        {
            response = await this.privateOptionsDeleteOrders(this.extend(request, requestParams));
        } else
        {
            throw new NotSupported ((string)add(this.id, " cancelAllOrders() not support this market type")) ;
        }
        //
        //    [
        //        {
        //            "id": 139797004085,
        //            "contract": "ADA_USDT",
        //            "mkfr": "0",
        //            "tkfr": "0.0005",
        //            "tif": "gtc",
        //            "is_reduce_only": false,
        //            "create_time": 1647911169.343,
        //            "finish_time": 1647911226.849,
        //            "price": "0.8",
        //            "size": 1,
        //            "refr": "0.3",
        //            "left": 1,
        //            "text": "api",
        //            "fill_price": "0",
        //            "user": 6693577,
        //            "finish_as": "cancelled",
        //            "status": "finished",
        //            "is_liq": false,
        //            "refu": 2436035,
        //            "is_close": false,
        //            "iceberg": 0
        //        }
        //        ...
        //    ]
        //
        return this.parseOrders(response, market);
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name gate#transfer
        * @description transfer currency internally between wallets on the same account
        * @see https://www.gate.io/docs/developers/apiv4/en/#transfer-between-trading-accounts
        * @param {string} code unified currency code for currency being transferred
        * @param {float} amount the amount of currency to transfer
        * @param {string} fromAccount the account to transfer currency from
        * @param {string} toAccount the account to transfer currency to
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.symbol] Unified market symbol *required for type == margin*
        * @returns A [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object fromId = this.convertTypeToAccount(fromAccount);
        object toId = this.convertTypeToAccount(toAccount);
        object truncated = this.currencyToPrecision(code, amount);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", truncated },
        };
        if (!isTrue((inOp(getValue(this.options, "accountsByType"), fromId))))
        {
            ((IDictionary<string,object>)request)["from"] = "margin";
            ((IDictionary<string,object>)request)["currency_pair"] = fromId;
        } else
        {
            ((IDictionary<string,object>)request)["from"] = fromId;
        }
        if (!isTrue((inOp(getValue(this.options, "accountsByType"), toId))))
        {
            ((IDictionary<string,object>)request)["to"] = "margin";
            ((IDictionary<string,object>)request)["currency_pair"] = toId;
        } else
        {
            ((IDictionary<string,object>)request)["to"] = toId;
        }
        if (isTrue(isTrue(isEqual(fromId, "margin")) || isTrue(isEqual(toId, "margin"))))
        {
            object symbol = this.safeString2(parameters, "symbol", "currency_pair");
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " transfer requires params[\"symbol\"] for isolated margin transfers")) ;
            }
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["currency_pair"] = getValue(market, "id");
            parameters = this.omit(parameters, "symbol");
        }
        if (isTrue(isTrue(isTrue(isTrue((isEqual(toId, "futures"))) || isTrue((isEqual(toId, "delivery")))) || isTrue((isEqual(fromId, "futures")))) || isTrue((isEqual(fromId, "delivery")))))
        {
            ((IDictionary<string,object>)request)["settle"] = getValue(currency, "id"); // todo: currencies have network-junctions
        }
        object response = await this.privateWalletPostTransfers(this.extend(request, parameters));
        //
        // according to the docs (however actual response seems to be an empty string '')
        //
        //    {
        //        "currency": "BTC",
        //        "from": "spot",
        //        "to": "margin",
        //        "amount": "1",
        //        "currency_pair": "BTC_USDT"
        //    }
        //
        return this.parseTransfer(response, currency);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        //    {
        //        "currency": "BTC",
        //        "from": "spot",
        //        "to": "margin",
        //        "amount": "1",
        //        "currency_pair": "BTC_USDT"
        //    }
        //
        return new Dictionary<string, object>() {
            { "id", this.safeString(transfer, "tx_id") },
            { "timestamp", null },
            { "datetime", null },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", null },
            { "info", transfer },
        };
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#setLeverage
        * @description set the level of leverage for a market
        * @see https://www.gate.io/docs/developers/apiv4/en/#update-position-leverage
        * @see https://www.gate.io/docs/developers/apiv4/en/#update-position-leverage-2
        * @param {float} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        if (isTrue(isTrue((isLessThan(leverage, 0))) || isTrue((isGreaterThan(leverage, 100)))))
        {
            throw new BadRequest ((string)add(this.id, " setLeverage() leverage should be between 1 and 100")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        var requestqueryVariable = this.prepareRequest(market, null, parameters);
        var request = ((IList<object>) requestqueryVariable)[0];
        var query = ((IList<object>) requestqueryVariable)[1];
        object defaultMarginMode = this.safeString2(this.options, "marginMode", "defaultMarginMode");
        object crossLeverageLimit = this.safeString(query, "cross_leverage_limit");
        object marginMode = this.safeString(query, "marginMode", defaultMarginMode);
        object stringifiedMargin = this.numberToString(leverage);
        if (isTrue(!isEqual(crossLeverageLimit, null)))
        {
            marginMode = "cross";
            stringifiedMargin = crossLeverageLimit;
        }
        if (isTrue(isTrue(isEqual(marginMode, "cross")) || isTrue(isEqual(marginMode, "cross_margin"))))
        {
            ((IDictionary<string,object>)request)["cross_leverage_limit"] = stringifiedMargin;
            ((IDictionary<string,object>)request)["leverage"] = "0";
        } else
        {
            ((IDictionary<string,object>)request)["leverage"] = stringifiedMargin;
        }
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.privateFuturesPostSettlePositionsContractLeverage(this.extend(request, query));
        } else if (isTrue(getValue(market, "future")))
        {
            response = await this.privateDeliveryPostSettlePositionsContractLeverage(this.extend(request, query));
        } else
        {
            throw new NotSupported ((string)add(this.id, " setLeverage() not support this market type")) ;
        }
        //
        //     {
        //         "value": "0",
        //         "leverage": "5",
        //         "mode": "single",
        //         "realised_point": "0",
        //         "contract": "BTC_USDT",
        //         "entry_price": "0",
        //         "mark_price": "62035.86",
        //         "history_point": "0",
        //         "realised_pnl": "0",
        //         "close_order": null,
        //         "size": 0,
        //         "cross_leverage_limit": "0",
        //         "pending_orders": 0,
        //         "adl_ranking": 6,
        //         "maintenance_rate": "0.005",
        //         "unrealised_pnl": "0",
        //         "user": 2436035,
        //         "leverage_max": "100",
        //         "history_pnl": "0",
        //         "risk_limit": "1000000",
        //         "margin": "0",
        //         "last_close_pnl": "0",
        //         "liq_price": "0"
        //     }
        //
        return response;
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // swap and future
        //
        //     {
        //         "value": "4.60516",
        //         "leverage": "0",
        //         "mode": "single",
        //         "realised_point": "0",
        //         "contract": "BTC_USDT",
        //         "entry_price": "46030.3",
        //         "mark_price": "46051.6",
        //         "history_point": "0",
        //         "realised_pnl": "-0.002301515",
        //         "close_order": null,
        //         "size": 1,
        //         "cross_leverage_limit": "0",
        //         "pending_orders": 0,
        //         "adl_ranking": 5,
        //         "maintenance_rate": "0.004",
        //         "unrealised_pnl": "0.00213",
        //         "user": 5691076,
        //         "leverage_max": "125",
        //         "history_pnl": "0",
        //         "risk_limit": "1000000",
        //         "margin": "8.997698485",
        //         "last_close_pnl": "0",
        //         "liq_price": "0",
        //         "update_time": 1705034246,
        //         "update_id": 1,
        //         "initial_margin": "0",
        //         "maintenance_margin": "0",
        //         "open_time": 1705034246,
        //         "trade_max_size": "0"
        //     }
        //
        // option
        //
        //     {
        //         "close_order": null,
        //         "size": 1,
        //         "vega": "5.29756",
        //         "theta": "-98.98917",
        //         "gamma": "0.00056",
        //         "delta": "0.68691",
        //         "contract": "BTC_USDT-20230602-26500-C",
        //         "entry_price": "529",
        //         "unrealised_pnl": "-1.0131",
        //         "user": 5691076,
        //         "mark_price": "427.69",
        //         "underlying_price": "26810.2",
        //         "underlying": "BTC_USDT",
        //         "realised_pnl": "-0.08042877",
        //         "mark_iv": "0.4224",
        //         "pending_orders": 0
        //     }
        //
        // fetchPositionsHistory (swap and future)
        //
        //    {
        //        "contract": "SLERF_USDT",         // Futures contract
        //        "text": "web",                    // Text of close order
        //        "long_price": "0.766306",         // When 'side' is 'long,' it indicates the opening average price; when 'side' is 'short,' it indicates the closing average price.
        //        "pnl": "-23.41702352",            // PNL
        //        "pnl_pnl": "-22.7187",            // Position P/L
        //        "pnl_fee": "-0.06527125",         // Transaction Fees
        //        "pnl_fund": "-0.63305227",        // Funding Fees
        //        "accum_size": "100",
        //        "time": 1711279263,               // Position close time
        //        "short_price": "0.539119",        // When 'side' is 'long,' it indicates the opening average price; when 'side' is 'short,' it indicates the closing average price
        //        "side": "long",                   // Position side, long or short
        //        "max_size": "100",                // Max Trade Size
        //        "first_open_time": 1711037985     // First Open Time
        //    }
        //
        object contract = this.safeString(position, "contract");
        market = this.safeMarket(contract, market, "_", "contract");
        object size = this.safeString2(position, "size", "accum_size");
        object side = this.safeString(position, "side");
        if (isTrue(isEqual(side, null)))
        {
            if (isTrue(Precise.stringGt(size, "0")))
            {
                side = "long";
            } else if (isTrue(Precise.stringLt(size, "0")))
            {
                side = "short";
            }
        }
        object maintenanceRate = this.safeString(position, "maintenance_rate");
        object notional = this.safeString(position, "value");
        object leverage = this.safeString(position, "leverage");
        object marginMode = null;
        if (isTrue(!isEqual(leverage, null)))
        {
            if (isTrue(isEqual(leverage, "0")))
            {
                marginMode = "cross";
            } else
            {
                marginMode = "isolated";
            }
        }
        // Initial Position Margin = ( Position Value / Leverage ) + Close Position Fee
        // *The default leverage under the full position is the highest leverage in the market.
        // *Trading fee is charged as Taker Fee Rate (0.075%).
        object feePaid = this.safeString(position, "pnl_fee");
        object initialMarginString = null;
        if (isTrue(isEqual(feePaid, null)))
        {
            object takerFee = "0.00075";
            feePaid = Precise.stringMul(takerFee, notional);
            initialMarginString = Precise.stringAdd(Precise.stringDiv(notional, leverage), feePaid);
        }
        object timestamp = this.safeTimestamp2(position, "open_time", "first_open_time");
        if (isTrue(isEqual(timestamp, 0)))
        {
            timestamp = null;
        }
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", this.safeString(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", this.safeTimestamp2(position, "update_time", "time") },
            { "initialMargin", this.parseNumber(initialMarginString) },
            { "initialMarginPercentage", this.parseNumber(Precise.stringDiv(initialMarginString, notional)) },
            { "maintenanceMargin", this.parseNumber(Precise.stringMul(maintenanceRate, notional)) },
            { "maintenanceMarginPercentage", this.parseNumber(maintenanceRate) },
            { "entryPrice", this.safeNumber(position, "entry_price") },
            { "notional", this.parseNumber(notional) },
            { "leverage", this.safeNumber(position, "leverage") },
            { "unrealizedPnl", this.safeNumber(position, "unrealised_pnl") },
            { "realizedPnl", this.safeNumber2(position, "realised_pnl", "pnl") },
            { "contracts", this.parseNumber(Precise.stringAbs(size)) },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "marginRatio", null },
            { "liquidationPrice", this.safeNumber(position, "liq_price") },
            { "markPrice", this.safeNumber(position, "mark_price") },
            { "lastPrice", null },
            { "collateral", this.safeNumber(position, "margin") },
            { "marginMode", marginMode },
            { "side", side },
            { "percentage", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchPosition
        * @description fetch data on an open contract position
        * @see https://www.gate.io/docs/developers/apiv4/en/#get-single-position
        * @see https://www.gate.io/docs/developers/apiv4/en/#get-single-position-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#get-specified-contract-position
        * @param {string} symbol unified market symbol of the market the position is held in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "contract")))
        {
            throw new BadRequest ((string)add(this.id, " fetchPosition() supports contract markets only")) ;
        }
        object request = new Dictionary<string, object>() {};
        var requestparametersVariable = this.prepareRequest(market, getValue(market, "type"), parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object extendedRequest = this.extend(request, parameters);
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.privateFuturesGetSettlePositionsContract(extendedRequest);
        } else if (isTrue(getValue(market, "future")))
        {
            response = await this.privateDeliveryGetSettlePositionsContract(extendedRequest);
        } else if (isTrue(isEqual(getValue(market, "type"), "option")))
        {
            response = await this.privateOptionsGetPositionsContract(extendedRequest);
        }
        //
        // swap and future
        //
        //     {
        //         "value": "4.60516",
        //         "leverage": "0",
        //         "mode": "single",
        //         "realised_point": "0",
        //         "contract": "BTC_USDT",
        //         "entry_price": "46030.3",
        //         "mark_price": "46051.6",
        //         "history_point": "0",
        //         "realised_pnl": "-0.002301515",
        //         "close_order": null,
        //         "size": 1,
        //         "cross_leverage_limit": "0",
        //         "pending_orders": 0,
        //         "adl_ranking": 5,
        //         "maintenance_rate": "0.004",
        //         "unrealised_pnl": "0.00213",
        //         "user": 5691076,
        //         "leverage_max": "125",
        //         "history_pnl": "0",
        //         "risk_limit": "1000000",
        //         "margin": "8.997698485",
        //         "last_close_pnl": "0",
        //         "liq_price": "0",
        //         "update_time": 1705034246,
        //         "update_id": 1,
        //         "initial_margin": "0",
        //         "maintenance_margin": "0",
        //         "open_time": 1705034246,
        //         "trade_max_size": "0"
        //     }
        //
        // option
        //
        //     {
        //         "close_order": null,
        //         "size": 1,
        //         "vega": "5.29756",
        //         "theta": "-98.98917",
        //         "gamma": "0.00056",
        //         "delta": "0.68691",
        //         "contract": "BTC_USDT-20230602-26500-C",
        //         "entry_price": "529",
        //         "unrealised_pnl": "-1.0131",
        //         "user": 5691076,
        //         "mark_price": "427.69",
        //         "underlying_price": "26810.2",
        //         "underlying": "BTC_USDT",
        //         "realised_pnl": "-0.08042877",
        //         "mark_iv": "0.4224",
        //         "pending_orders": 0
        //     }
        //
        return this.parsePosition(response, market);
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchPositions
        * @description fetch all open positions
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-positions-of-a-user
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-positions-of-a-user-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-user-s-positions-of-specified-underlying
        * @param {string[]|undefined} symbols Not used by gate, but parsed internally by CCXT
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.settle] 'btc' or 'usdt' - settle currency for perpetual swap and future - default="usdt" for swap and "btc" for future
        * @param {string} [params.type] swap, future or option, if not provided this.options['defaultType'] is used
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        symbols = this.marketSymbols(symbols, null, true, true, true);
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(isGreaterThan(symbolsLength, 0)))
            {
                market = this.market(getValue(symbols, 0));
            }
        }
        object type = null;
        object request = new Dictionary<string, object>() {};
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchPositions", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(isTrue((isEqual(type, null))) || isTrue((isEqual(type, "spot")))))
        {
            type = "swap"; // default to swap
        }
        if (isTrue(isEqual(type, "option")))
        {
            if (isTrue(!isEqual(symbols, null)))
            {
                object marketId = getValue(market, "id");
                object optionParts = ((string)marketId).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
                ((IDictionary<string,object>)request)["underlying"] = this.safeString(optionParts, 0);
            }
        } else
        {
            var requestparametersVariable = this.prepareRequest(null, type, parameters);
            request = ((IList<object>)requestparametersVariable)[0];
            parameters = ((IList<object>)requestparametersVariable)[1];
        }
        object response = null;
        if (isTrue(isEqual(type, "swap")))
        {
            response = await this.privateFuturesGetSettlePositions(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "future")))
        {
            response = await this.privateDeliveryGetSettlePositions(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "option")))
        {
            response = await this.privateOptionsGetPositions(this.extend(request, parameters));
        }
        //
        // swap and future
        //
        //     [
        //         {
        //             "value": "4.602828",
        //             "leverage": "0",
        //             "mode": "single",
        //             "realised_point": "0",
        //             "contract": "BTC_USDT",
        //             "entry_price": "46030.3",
        //             "mark_price": "46028.28",
        //             "history_point": "0",
        //             "realised_pnl": "-0.002301515",
        //             "close_order": null,
        //             "size": 1,
        //             "cross_leverage_limit": "0",
        //             "pending_orders": 0,
        //             "adl_ranking": 5,
        //             "maintenance_rate": "0.004",
        //             "unrealised_pnl": "-0.000202",
        //             "user": 5691076,
        //             "leverage_max": "125",
        //             "history_pnl": "0",
        //             "risk_limit": "1000000",
        //             "margin": "8.997698485",
        //             "last_close_pnl": "0",
        //             "liq_price": "0",
        //             "update_time": 1705034246,
        //             "update_id": 1,
        //             "initial_margin": "0",
        //             "maintenance_margin": "0",
        //             "open_time": 1705034246,
        //             "trade_max_size": "0"
        //         }
        //     ]
        //
        // option
        //
        //     [
        //         {
        //             "close_order": null,
        //             "size": 0,
        //             "vega": "0.01907",
        //             "theta": "-3.04888",
        //             "gamma": "0.00001",
        //             "delta": "0.0011",
        //             "contract": "BTC_USDT-20230601-27500-C",
        //             "entry_price": "0",
        //             "unrealised_pnl": "0",
        //             "user": 5691076,
        //             "mark_price": "0.07",
        //             "underlying_price": "26817.27",
        //             "underlying": "BTC_USDT",
        //             "realised_pnl": "0",
        //             "mark_iv": "0.4339",
        //             "pending_orders": 0
        //         }
        //     ]
        //
        return this.parsePositions(response, symbols);
    }

    public async override Task<object> fetchLeverageTiers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchLeverageTiers
        * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-futures-contracts
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-futures-contracts-2
        * @param {string[]} [symbols] list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        var typequeryVariable = this.handleMarketTypeAndParams("fetchLeverageTiers", null, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        var requestrequestParamsVariable = this.prepareRequest(null, type, query);
        var request = ((IList<object>) requestrequestParamsVariable)[0];
        var requestParams = ((IList<object>) requestrequestParamsVariable)[1];
        if (isTrue(isTrue(!isEqual(type, "future")) && isTrue(!isEqual(type, "swap"))))
        {
            throw new BadRequest ((string)add(this.id, " fetchLeverageTiers only supports swap and future")) ;
        }
        object response = null;
        if (isTrue(isEqual(type, "swap")))
        {
            response = await this.publicFuturesGetSettleContracts(this.extend(request, requestParams));
        } else if (isTrue(isEqual(type, "future")))
        {
            response = await this.publicDeliveryGetSettleContracts(this.extend(request, requestParams));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchLeverageTiers() not support this market type")) ;
        }
        //
        // Perpetual swap
        //
        //    [
        //        {
        //            "name": "BTC_USDT",
        //            "type": "direct",
        //            "quanto_multiplier": "0.0001",
        //            "ref_discount_rate": "0",
        //            "order_price_deviate": "0.5",
        //            "maintenance_rate": "0.005",
        //            "mark_type": "index",
        //            "last_price": "38026",
        //            "mark_price": "37985.6",
        //            "index_price": "37954.92",
        //            "funding_rate_indicative": "0.000219",
        //            "mark_price_round": "0.01",
        //            "funding_offset": 0,
        //            "in_delisting": false,
        //            "risk_limit_base": "1000000",
        //            "interest_rate": "0.0003",
        //            "order_price_round": "0.1",
        //            "order_size_min": 1,
        //            "ref_rebate_rate": "0.2",
        //            "funding_interval": 28800,
        //            "risk_limit_step": "1000000",
        //            "leverage_min": "1",
        //            "leverage_max": "100",
        //            "risk_limit_max": "8000000",
        //            "maker_fee_rate": "-0.00025",
        //            "taker_fee_rate": "0.00075",
        //            "funding_rate": "0.002053",
        //            "order_size_max": 1000000,
        //            "funding_next_apply": 1610035200,
        //            "short_users": 977,
        //            "config_change_time": 1609899548,
        //            "trade_size": 28530850594,
        //            "position_size": 5223816,
        //            "long_users": 455,
        //            "funding_impact_value": "60000",
        //            "orders_limit": 50,
        //            "trade_id": 10851092,
        //            "orderbook_id": 2129638396
        //        }
        //    ]
        //
        // Delivery Futures
        //
        //    [
        //        {
        //            "name": "BTC_USDT_20200814",
        //            "underlying": "BTC_USDT",
        //            "cycle": "WEEKLY",
        //            "type": "direct",
        //            "quanto_multiplier": "0.0001",
        //            "mark_type": "index",
        //            "last_price": "9017",
        //            "mark_price": "9019",
        //            "index_price": "9005.3",
        //            "basis_rate": "0.185095",
        //            "basis_value": "13.7",
        //            "basis_impact_value": "100000",
        //            "settle_price": "0",
        //            "settle_price_interval": 60,
        //            "settle_price_duration": 1800,
        //            "settle_fee_rate": "0.0015",
        //            "expire_time": 1593763200,
        //            "order_price_round": "0.1",
        //            "mark_price_round": "0.1",
        //            "leverage_min": "1",
        //            "leverage_max": "100",
        //            "maintenance_rate": "1000000",
        //            "risk_limit_base": "140.726652109199",
        //            "risk_limit_step": "1000000",
        //            "risk_limit_max": "8000000",
        //            "maker_fee_rate": "-0.00025",
        //            "taker_fee_rate": "0.00075",
        //            "ref_discount_rate": "0",
        //            "ref_rebate_rate": "0.2",
        //            "order_price_deviate": "0.5",
        //            "order_size_min": 1,
        //            "order_size_max": 1000000,
        //            "orders_limit": 50,
        //            "orderbook_id": 63,
        //            "trade_id": 26,
        //            "trade_size": 435,
        //            "position_size": 130,
        //            "config_change_time": 1593158867,
        //            "in_delisting": false
        //        }
        //    ]
        //
        return this.parseLeverageTiers(response, symbols, "name");
    }

    public async override Task<object> fetchMarketLeverageTiers(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchMarketLeverageTiers
        * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes for a single market
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-risk-limit-tiers
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [leverage tiers structure]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var typequeryVariable = this.handleMarketTypeAndParams("fetchMarketLeverageTiers", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        var requestrequestParamsVariable = this.prepareRequest(market, type, query);
        var request = ((IList<object>) requestrequestParamsVariable)[0];
        var requestParams = ((IList<object>) requestrequestParamsVariable)[1];
        if (isTrue(isTrue(!isEqual(type, "future")) && isTrue(!isEqual(type, "swap"))))
        {
            throw new BadRequest ((string)add(this.id, " fetchMarketLeverageTiers only supports swap and future")) ;
        }
        object response = await this.privateFuturesGetSettleRiskLimitTiers(this.extend(request, requestParams));
        //
        //     [
        //         {
        //             "maintenance_rate": "0.004",
        //             "tier": 1,
        //             "initial_rate": "0.008",
        //             "leverage_max": "125",
        //             "risk_limit": "1000000"
        //         }
        //     ]
        //
        return this.parseMarketLeverageTiers(response, market);
    }

    public virtual object parseEmulatedLeverageTiers(object info, object market = null)
    {
        object maintenanceMarginUnit = this.safeString(info, "maintenance_rate"); // '0.005',
        object leverageMax = this.safeString(info, "leverage_max"); // '100',
        object riskLimitStep = this.safeString(info, "risk_limit_step"); // '1000000',
        object riskLimitMax = this.safeString(info, "risk_limit_max"); // '16000000',
        object initialMarginUnit = Precise.stringDiv("1", leverageMax);
        object maintenanceMarginRate = maintenanceMarginUnit;
        object initialMarginRatio = initialMarginUnit;
        object floor = "0";
        object tiers = new List<object>() {};
        while (Precise.stringLt(floor, riskLimitMax))
        {
            object cap = Precise.stringAdd(floor, riskLimitStep);
            ((IList<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.parseNumber(Precise.stringDiv(cap, riskLimitStep)) },
                { "currency", this.safeString(market, "settle") },
                { "minNotional", this.parseNumber(floor) },
                { "maxNotional", this.parseNumber(cap) },
                { "maintenanceMarginRate", this.parseNumber(maintenanceMarginRate) },
                { "maxLeverage", this.parseNumber(Precise.stringDiv("1", initialMarginRatio)) },
                { "info", info },
            });
            maintenanceMarginRate = Precise.stringAdd(maintenanceMarginRate, maintenanceMarginUnit);
            initialMarginRatio = Precise.stringAdd(initialMarginRatio, initialMarginUnit);
            floor = cap;
        }
        return tiers;
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        //
        //     [
        //         {
        //             "maintenance_rate": "0.004",
        //             "tier": 1,
        //             "initial_rate": "0.008",
        //             "leverage_max": "125",
        //             "risk_limit": "1000000"
        //         }
        //     ]
        //
        if (!isTrue(((info is IList<object>) || (info.GetType().IsGenericType && info.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            return this.parseEmulatedLeverageTiers(info, market);
        }
        object minNotional = 0;
        object tiers = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(info)); postFixIncrement(ref i))
        {
            object item = getValue(info, i);
            object maxNotional = this.safeNumber(item, "risk_limit");
            ((IList<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.sum(i, 1) },
                { "currency", getValue(market, "base") },
                { "minNotional", minNotional },
                { "maxNotional", maxNotional },
                { "maintenanceMarginRate", this.safeNumber(item, "maintenance_rate") },
                { "maxLeverage", this.safeNumber(item, "leverage_max") },
                { "info", item },
            });
            minNotional = maxNotional;
        }
        return tiers;
    }

    public async override Task<object> repayIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name gate#repayMargin
        * @description repay borrowed margin and interest
        * @see https://www.gate.io/docs/apiv4/en/#repay-a-loan
        * @param {string} symbol unified market symbol
        * @param {string} code unified currency code of the currency to repay
        * @param {float} amount the amount to repay
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.mode] 'all' or 'partial' payment mode, extra parameter required for isolated margin
        * @param {string} [params.id] '34267567' loan id, extra parameter required for isolated margin
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", ((string)getValue(currency, "id")).ToUpper() },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object market = this.market(symbol);
        ((IDictionary<string,object>)request)["currency_pair"] = getValue(market, "id");
        ((IDictionary<string,object>)request)["type"] = "repay";
        object response = await this.privateMarginPostUniLoans(this.extend(request, parameters));
        //
        // empty response
        //
        return this.parseMarginLoan(response, currency);
    }

    public async override Task<object> repayCrossMargin(object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name gate#repayCrossMargin
        * @description repay cross margin borrowed margin and interest
        * @see https://www.gate.io/docs/developers/apiv4/en/#cross-margin-repayments
        * @param {string} code unified currency code of the currency to repay
        * @param {float} amount the amount to repay
        * @param {string} symbol unified market symbol, required for isolated margin
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.mode] 'all' or 'partial' payment mode, extra parameter required for isolated margin
        * @param {string} [params.id] '34267567' loan id, extra parameter required for isolated margin
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", ((string)getValue(currency, "id")).ToUpper() },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.privateMarginPostCrossRepayments(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "id": "17",
        //             "create_time": 1620381696159,
        //             "update_time": 1620381696159,
        //             "currency": "EOS",
        //             "amount": "110.553635",
        //             "text": "web",
        //             "status": 2,
        //             "repaid": "110.506649705159",
        //             "repaid_interest": "0.046985294841",
        //             "unpaid_interest": "0.0000074393366667"
        //         }
        //     ]
        //
        response = this.safeValue(response, 0);
        return this.parseMarginLoan(response, currency);
    }

    public async override Task<object> borrowIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name gate#borrowMargin
        * @description create a loan to borrow margin
        * @see https://www.gate.io/docs/developers/apiv4/en/#marginuni
        * @param {string} code unified currency code of the currency to borrow
        * @param {float} amount the amount to borrow
        * @param {string} symbol unified market symbol, required for isolated margin
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.rate] '0.0002' or '0.002' extra parameter required for isolated margin
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", ((string)getValue(currency, "id")).ToUpper() },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object response = null;
        object market = this.market(symbol);
        ((IDictionary<string,object>)request)["currency_pair"] = getValue(market, "id");
        ((IDictionary<string,object>)request)["type"] = "borrow";
        response = await this.privateMarginPostUniLoans(this.extend(request, parameters));
        //
        //     {
        //         "id": "34267567",
        //         "create_time": "1656394778",
        //         "expire_time": "1657258778",
        //         "status": "loaned",
        //         "side": "borrow",
        //         "currency": "USDT",
        //         "rate": "0.0002",
        //         "amount": "100",
        //         "days": 10,
        //         "auto_renew": false,
        //         "currency_pair": "LTC_USDT",
        //         "left": "0",
        //         "repaid": "0",
        //         "paid_interest": "0",
        //         "unpaid_interest": "0.003333333333"
        //     }
        //
        return this.parseMarginLoan(response, currency);
    }

    public async override Task<object> borrowCrossMargin(object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name gate#borrowMargin
        * @description create a loan to borrow margin
        * @see https://www.gate.io/docs/apiv4/en/#create-a-cross-margin-borrow-loan
        * @param {string} code unified currency code of the currency to borrow
        * @param {float} amount the amount to borrow
        * @param {string} symbol unified market symbol, required for isolated margin
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.rate] '0.0002' or '0.002' extra parameter required for isolated margin
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", ((string)getValue(currency, "id")).ToUpper() },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.privateMarginPostCrossLoans(this.extend(request, parameters));
        //
        //     {
        //         "id": "17",
        //         "create_time": 1620381696159,
        //         "update_time": 1620381696159,
        //         "currency": "EOS",
        //         "amount": "110.553635",
        //         "text": "web",
        //         "status": 2,
        //         "repaid": "110.506649705159",
        //         "repaid_interest": "0.046985294841",
        //         "unpaid_interest": "0.0000074393366667"
        //     }
        //
        return this.parseMarginLoan(response, currency);
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        // Cross
        //
        //     {
        //         "id": "17",
        //         "create_time": 1620381696159,
        //         "update_time": 1620381696159,
        //         "currency": "EOS",
        //         "amount": "110.553635",
        //         "text": "web",
        //         "status": 2,
        //         "repaid": "110.506649705159",
        //         "repaid_interest": "0.046985294841",
        //         "unpaid_interest": "0.0000074393366667"
        //     }
        //
        // Isolated
        //
        //     {
        //         "id": "34267567",
        //         "create_time": "1656394778",
        //         "expire_time": "1657258778",
        //         "status": "loaned",
        //         "side": "borrow",
        //         "currency": "USDT",
        //         "rate": "0.0002",
        //         "amount": "100",
        //         "days": 10,
        //         "auto_renew": false,
        //         "currency_pair": "LTC_USDT",
        //         "left": "0",
        //         "repaid": "0",
        //         "paid_interest": "0",
        //         "unpaid_interest": "0.003333333333"
        //     }
        //
        object marginMode = this.safeString2(this.options, "defaultMarginMode", "marginMode", "cross");
        object timestamp = this.safeInteger(info, "create_time");
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            timestamp = this.safeTimestamp(info, "create_time");
        }
        object currencyId = this.safeString(info, "currency");
        object marketId = this.safeString(info, "currency_pair");
        return new Dictionary<string, object>() {
            { "id", this.safeInteger(info, "id") },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber(info, "amount") },
            { "symbol", this.safeSymbol(marketId, null, "_", "margin") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= new List<object>();
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object authentication = getValue(api, 0); // public, private
        object type = getValue(api, 1); // spot, margin, future, delivery
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(((parameters is IList<object>) || (parameters.GetType().IsGenericType && parameters.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            // endpoints like createOrders use an array instead of an object
            // so we infer the settle from one of the elements
            // they have to be all the same so relying on the first one is fine
            object first = this.safeValue(parameters, 0, new Dictionary<string, object>() {});
            path = this.implodeParams(path, first);
        } else
        {
            path = this.implodeParams(path, parameters);
        }
        object endPart = ((bool) isTrue((isEqual(path, "")))) ? "" : (add("/", path));
        object entirePath = add(add("/", type), endPart);
        if (isTrue(isTrue((isEqual(type, "subAccounts"))) || isTrue((isEqual(type, "withdrawals")))))
        {
            entirePath = endPart;
        }
        object url = getValue(getValue(getValue(this.urls, "api"), authentication), type);
        if (isTrue(isEqual(url, null)))
        {
            throw new NotSupported ((string)add(add(add(this.id, " does not have a testnet for the "), type), " market type.")) ;
        }
        url = add(url, entirePath);
        if (isTrue(isEqual(authentication, "public")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else
        {
            this.checkRequiredCredentials();
            object queryString = "";
            object requiresURLEncoding = false;
            if (isTrue(isTrue((isTrue((isEqual(type, "futures"))) || isTrue((isEqual(type, "delivery"))))) && isTrue(isEqual(method, "POST"))))
            {
                object pathParts = ((string)path).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
                object secondPart = this.safeString(pathParts, 1, "");
                requiresURLEncoding = isTrue((isGreaterThanOrEqual(getIndexOf(secondPart, "dual"), 0))) || isTrue((isGreaterThanOrEqual(getIndexOf(secondPart, "positions"), 0)));
            }
            if (isTrue(isTrue(isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE")))) || isTrue(requiresURLEncoding)) || isTrue((isEqual(method, "PATCH")))))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    queryString = this.urlencode(query);
                    url = add(url, add("?", queryString));
                }
                if (isTrue(isEqual(method, "PATCH")))
                {
                    body = this.json(query);
                }
            } else
            {
                object urlQueryParams = this.safeValue(query, "query", new Dictionary<string, object>() {});
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)urlQueryParams).Keys))))
                {
                    queryString = this.urlencode(urlQueryParams);
                    url = add(url, add("?", queryString));
                }
                query = this.omit(query, "query");
                body = this.json(query);
            }
            object bodyPayload = ((bool) isTrue((isEqual(body, null)))) ? "" : body;
            object bodySignature = this.hash(this.encode(bodyPayload), sha512);
            object timestamp = this.seconds();
            object timestampString = ((object)timestamp).ToString();
            object signaturePath = add(add("/api/", this.version), entirePath);
            object payloadArray = new List<object> {((string)method).ToUpper(), signaturePath, queryString, bodySignature, timestampString};
            // eslint-disable-next-line quotes
            object payload = String.Join("\n", ((IList<object>)payloadArray).ToArray());
            object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha512);
            headers = new Dictionary<string, object>() {
                { "KEY", this.apiKey },
                { "Timestamp", timestampString },
                { "SIGN", signature },
                { "Content-Type", "application/json" },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var requestqueryVariable = this.prepareRequest(market, null, parameters);
        var request = ((IList<object>) requestqueryVariable)[0];
        var query = ((IList<object>) requestqueryVariable)[1];
        ((IDictionary<string,object>)request)["change"] = this.numberToString(amount);
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.privateFuturesPostSettlePositionsContractMargin(this.extend(request, query));
        } else if (isTrue(getValue(market, "future")))
        {
            response = await this.privateDeliveryPostSettlePositionsContractMargin(this.extend(request, query));
        } else
        {
            throw new NotSupported ((string)add(this.id, " modifyMarginHelper() not support this market type")) ;
        }
        return this.parseMarginModification(response, market);
    }

    public override object parseMarginModification(object data, object market = null)
    {
        //
        //     {
        //         "value": "11.9257",
        //         "leverage": "5",
        //         "mode": "single",
        //         "realised_point": "0",
        //         "contract": "ETH_USDT",
        //         "entry_price": "1203.45",
        //         "mark_price": "1192.57",
        //         "history_point": "0",
        //         "realised_pnl": "-0.00577656",
        //         "close_order": null,
        //         "size": "1",
        //         "cross_leverage_limit": "0",
        //         "pending_orders": "0",
        //         "adl_ranking": "5",
        //         "maintenance_rate": "0.005",
        //         "unrealised_pnl": "-0.1088",
        //         "user": "1486602",
        //         "leverage_max": "100",
        //         "history_pnl": "0",
        //         "risk_limit": "1000000",
        //         "margin": "5.415925875",
        //         "last_close_pnl": "0",
        //         "liq_price": "665.69"
        //     }
        //
        object contract = this.safeString(data, "contract");
        market = this.safeMarket(contract, market, "_", "contract");
        object total = this.safeNumber(data, "margin");
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", getValue(market, "symbol") },
            { "type", null },
            { "marginMode", "isolated" },
            { "amount", null },
            { "total", total },
            { "code", this.safeValue(market, "quote") },
            { "status", "ok" },
            { "timestamp", null },
            { "datetime", null },
        };
    }

    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name gate#reduceMargin
        * @description remove margin from a position
        * @see https://www.gate.io/docs/developers/apiv4/en/#update-position-margin
        * @see https://www.gate.io/docs/developers/apiv4/en/#update-position-margin-2
        * @param {string} symbol unified market symbol
        * @param {float} amount the amount of margin to remove
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, prefixUnaryNeg(ref amount), parameters);
    }

    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name gate#addMargin
        * @description add margin
        * @see https://www.gate.io/docs/developers/apiv4/en/#update-position-margin
        * @see https://www.gate.io/docs/developers/apiv4/en/#update-position-margin-2
        * @param {string} symbol unified market symbol
        * @param {float} amount amount of margin to add
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, parameters);
    }

    public async override Task<object> fetchOpenInterestHistory(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchOpenInterest
        * @description Retrieves the open interest of a currency
        * @see https://www.gate.io/docs/developers/apiv4/en/#futures-stats
        * @param {string} symbol Unified CCXT market symbol
        * @param {string} timeframe "5m", "15m", "30m", "1h", "4h", "1d"
        * @param {int} [since] the time(ms) of the earliest record to retrieve as a unix timestamp
        * @param {int} [limit] default 30
        * @param {object} [params] exchange specific parameters
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
        */
        timeframe ??= "5m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenInterestHistory", "paginate", false);
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOpenInterestHistory", symbol, since, limit, timeframe, parameters, 100);
        }
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterest() supports swap markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "contract", getValue(market, "id") },
            { "settle", getValue(market, "settleId") },
            { "interval", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = since;
        }
        object response = await this.publicFuturesGetSettleContractStats(this.extend(request, parameters));
        //
        //    [
        //        {
        //            "long_liq_size": "0",
        //            "short_liq_size": "0",
        //            "short_liq_usd": "0",
        //            "lsr_account": "3.2808988764045",
        //            "mark_price": "0.34619",
        //            "top_lsr_size": "0",
        //            "time": "1674057000",
        //            "short_liq_amount": "0",
        //            "long_liq_amount": "0",
        //            "open_interest_usd": "9872386.7775",
        //            "top_lsr_account": "0",
        //            "open_interest": "2851725",
        //            "long_liq_usd": "0",
        //            "lsr_taker": "9.3765153315902"
        //        },
        //        ...
        //    ]
        //
        return this.parseOpenInterests(response, market, since, limit);
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        //    {
        //        "long_liq_size": "0",
        //        "short_liq_size": "0",
        //        "short_liq_usd": "0",
        //        "lsr_account": "3.2808988764045",
        //        "mark_price": "0.34619",
        //        "top_lsr_size": "0",
        //        "time": "1674057000",
        //        "short_liq_amount": "0",
        //        "long_liq_amount": "0",
        //        "open_interest_usd": "9872386.7775",
        //        "top_lsr_account": "0",
        //        "open_interest": "2851725",
        //        "long_liq_usd": "0",
        //        "lsr_taker": "9.3765153315902"
        //    }
        //
        object timestamp = this.safeTimestamp(interest, "time");
        return new Dictionary<string, object>() {
            { "symbol", this.safeString(market, "symbol") },
            { "openInterestAmount", this.safeNumber(interest, "open_interest") },
            { "openInterestValue", this.safeNumber(interest, "open_interest_usd") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", interest },
        };
    }

    public async virtual Task<object> fetchSettlementHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchSettlementHistory
        * @description fetches historical settlement records
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-settlement-history-2
        * @param {string} symbol unified market symbol of the settlement history, required on gate
        * @param {int} [since] timestamp in ms
        * @param {int} [limit] number of records
        * @param {object} [params] exchange specific params
        * @returns {object[]} a list of [settlement history objects]{@link https://docs.ccxt.com/#/?id=settlement-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchSettlementHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchSettlementHistory", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(!isEqual(type, "option")))
        {
            throw new NotSupported ((string)add(this.id, " fetchSettlementHistory() supports option markets only")) ;
        }
        object marketId = getValue(market, "id");
        object optionParts = ((string)marketId).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
        object request = new Dictionary<string, object>() {
            { "underlying", this.safeString(optionParts, 0) },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.publicOptionsGetSettlements(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "time": 1685952000,
        //             "profit": "18.266806892718",
        //             "settle_price": "26826.68068927182",
        //             "fee": "0.040240021034",
        //             "contract": "BTC_USDT-20230605-25000-C",
        //             "strike_price": "25000"
        //         }
        //     ]
        //
        object settlements = this.parseSettlements(response, market);
        object sorted = this.sortBy(settlements, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public async virtual Task<object> fetchMySettlementHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchMySettlementHistory
        * @description fetches historical settlement records of the user
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-my-options-settlements
        * @param {string} symbol unified market symbol of the settlement history
        * @param {int} [since] timestamp in ms
        * @param {int} [limit] number of records
        * @param {object} [params] exchange specific params
        * @returns {object[]} a list of [settlement history objects]
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMySettlementHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchMySettlementHistory", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(!isEqual(type, "option")))
        {
            throw new NotSupported ((string)add(this.id, " fetchMySettlementHistory() supports option markets only")) ;
        }
        object marketId = getValue(market, "id");
        object optionParts = ((string)marketId).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
        object request = new Dictionary<string, object>() {
            { "underlying", this.safeString(optionParts, 0) },
            { "contract", marketId },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateOptionsGetMySettlements(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "size": -1,
        //             "settle_profit": "0",
        //             "contract": "BTC_USDT-20220624-26000-C",
        //             "strike_price": "26000",
        //             "time": 1656057600,
        //             "settle_price": "20917.461281337048",
        //             "underlying": "BTC_USDT",
        //             "realised_pnl": "-0.00116042",
        //             "fee": "0"
        //         }
        //     ]
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object data = this.safeValue(result, "list", new List<object>() {});
        object settlements = this.parseSettlements(data, market);
        object sorted = this.sortBy(settlements, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    public virtual object parseSettlement(object settlement, object market)
    {
        //
        // fetchSettlementHistory
        //
        //     {
        //         "time": 1685952000,
        //         "profit": "18.266806892718",
        //         "settle_price": "26826.68068927182",
        //         "fee": "0.040240021034",
        //         "contract": "BTC_USDT-20230605-25000-C",
        //         "strike_price": "25000"
        //     }
        //
        // fetchMySettlementHistory
        //
        //     {
        //         "size": -1,
        //         "settle_profit": "0",
        //         "contract": "BTC_USDT-20220624-26000-C",
        //         "strike_price": "26000",
        //         "time": 1656057600,
        //         "settle_price": "20917.461281337048",
        //         "underlying": "BTC_USDT",
        //         "realised_pnl": "-0.00116042",
        //         "fee": "0"
        //     }
        //
        object timestamp = this.safeTimestamp(settlement, "time");
        object marketId = this.safeString(settlement, "contract");
        return new Dictionary<string, object>() {
            { "info", settlement },
            { "symbol", this.safeSymbol(marketId, market) },
            { "price", this.safeNumber(settlement, "settle_price") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }

    public virtual object parseSettlements(object settlements, object market)
    {
        //
        // fetchSettlementHistory
        //
        //     [
        //         {
        //             "time": 1685952000,
        //             "profit": "18.266806892718",
        //             "settle_price": "26826.68068927182",
        //             "fee": "0.040240021034",
        //             "contract": "BTC_USDT-20230605-25000-C",
        //             "strike_price": "25000"
        //         }
        //     ]
        //
        // fetchMySettlementHistory
        //
        //     [
        //         {
        //             "size": -1,
        //             "settle_profit": "0",
        //             "contract": "BTC_USDT-20220624-26000-C",
        //             "strike_price": "26000",
        //             "time": 1656057600,
        //             "settle_price": "20917.461281337048",
        //             "underlying": "BTC_USDT",
        //             "realised_pnl": "-0.00116042",
        //             "fee": "0"
        //         }
        //     ]
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(settlements)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parseSettlement(getValue(settlements, i), market));
        }
        return result;
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
        * @see https://www.gate.io/docs/developers/apiv4/en/#query-account-book
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-margin-account-balance-change-history
        * @see https://www.gate.io/docs/developers/apiv4/en/#query-account-book-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#query-account-book-3
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-account-changing-history
        * @param {string} code unified currency code
        * @param {int} [since] timestamp in ms of the earliest ledger entry
        * @param {int} [limit] max number of ledger entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] end time in ms
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchLedger", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchLedger", code, since, limit, parameters);
        }
        object type = null;
        object currency = null;
        object response = null;
        object request = new Dictionary<string, object>() {};
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchLedger", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(isTrue((isEqual(type, "spot"))) || isTrue((isEqual(type, "margin")))))
        {
            if (isTrue(!isEqual(code, null)))
            {
                currency = this.currency(code);
                ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id"); // todo: currencies have network-junctions
            }
        }
        if (isTrue(isTrue((isEqual(type, "swap"))) || isTrue((isEqual(type, "future")))))
        {
            object defaultSettle = ((bool) isTrue((isEqual(type, "swap")))) ? "usdt" : "btc";
            object settle = this.safeStringLower(parameters, "settle", defaultSettle);
            parameters = this.omit(parameters, "settle");
            ((IDictionary<string,object>)request)["settle"] = settle;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("to", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            response = await this.privateSpotGetAccountBook(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "margin")))
        {
            response = await this.privateMarginGetAccountBook(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "swap")))
        {
            response = await this.privateFuturesGetSettleAccountBook(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "future")))
        {
            response = await this.privateDeliveryGetSettleAccountBook(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "option")))
        {
            response = await this.privateOptionsGetAccountBook(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     [
        //         {
        //             "id": "123456",
        //             "time": 1547633726123,
        //             "currency": "BTC",
        //             "change": "1.03",
        //             "balance": "4.59316525194",
        //             "type": "margin_in"
        //         }
        //     ]
        //
        // margin
        //
        //     [
        //         {
        //             "id": "123456",
        //             "time": "1547633726",
        //             "time_ms": 1547633726123,
        //             "currency": "BTC",
        //             "currency_pair": "BTC_USDT",
        //             "change": "1.03",
        //             "balance": "4.59316525194"
        //         }
        //     ]
        //
        // swap and future
        //
        //     [
        //         {
        //             "time": 1682294400.123456,
        //             "change": "0.000010152188",
        //             "balance": "4.59316525194",
        //             "text": "ETH_USD:6086261",
        //             "type": "fee"
        //         }
        //     ]
        //
        // option
        //
        //     [
        //         {
        //             "time": 1685594770,
        //             "change": "3.33",
        //             "balance": "29.87911771",
        //             "text": "BTC_USDT-20230602-26500-C:2611026125",
        //             "type": "prem"
        //         }
        //     ]
        //
        return this.parseLedger(response, currency, since, limit);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        // spot
        //
        //     {
        //         "id": "123456",
        //         "time": 1547633726123,
        //         "currency": "BTC",
        //         "change": "1.03",
        //         "balance": "4.59316525194",
        //         "type": "margin_in"
        //     }
        //
        // margin
        //
        //     {
        //         "id": "123456",
        //         "time": "1547633726",
        //         "time_ms": 1547633726123,
        //         "currency": "BTC",
        //         "currency_pair": "BTC_USDT",
        //         "change": "1.03",
        //         "balance": "4.59316525194"
        //     }
        //
        // swap and future
        //
        //     {
        //         "time": 1682294400.123456,
        //         "change": "0.000010152188",
        //         "balance": "4.59316525194",
        //         "text": "ETH_USD:6086261",
        //         "type": "fee"
        //     }
        //
        // option
        //
        //     {
        //         "time": 1685594770,
        //         "change": "3.33",
        //         "balance": "29.87911771",
        //         "text": "BTC_USDT-20230602-26500-C:2611026125",
        //         "type": "prem"
        //     }
        //
        object direction = null;
        object amount = this.safeString(item, "change");
        if (isTrue(Precise.stringLt(amount, "0")))
        {
            direction = "out";
            amount = Precise.stringAbs(amount);
        } else
        {
            direction = "in";
        }
        object currencyId = this.safeString(item, "currency");
        object type = this.safeString(item, "type");
        object rawTimestamp = this.safeString(item, "time");
        object timestamp = null;
        if (isTrue(isGreaterThan(((string)rawTimestamp).Length, 10)))
        {
            timestamp = parseInt(rawTimestamp);
        } else
        {
            timestamp = multiply(parseInt(rawTimestamp), 1000);
        }
        object balanceString = this.safeString(item, "balance");
        object changeString = this.safeString(item, "change");
        object before = this.parseNumber(Precise.stringSub(balanceString, changeString));
        return new Dictionary<string, object>() {
            { "id", this.safeString(item, "id") },
            { "direction", direction },
            { "account", null },
            { "referenceAccount", null },
            { "referenceId", null },
            { "type", this.parseLedgerEntryType(type) },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.parseNumber(amount) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "before", before },
            { "after", this.safeNumber(item, "balance") },
            { "status", null },
            { "fee", null },
            { "info", item },
        };
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object ledgerType = new Dictionary<string, object>() {
            { "deposit", "deposit" },
            { "withdraw", "withdrawal" },
            { "sub_account_transfer", "transfer" },
            { "margin_in", "transfer" },
            { "margin_out", "transfer" },
            { "margin_funding_in", "transfer" },
            { "margin_funding_out", "transfer" },
            { "cross_margin_in", "transfer" },
            { "cross_margin_out", "transfer" },
            { "copy_trading_in", "transfer" },
            { "copy_trading_out", "transfer" },
            { "quant_in", "transfer" },
            { "quant_out", "transfer" },
            { "futures_in", "transfer" },
            { "futures_out", "transfer" },
            { "delivery_in", "transfer" },
            { "delivery_out", "transfer" },
            { "new_order", "trade" },
            { "order_fill", "trade" },
            { "referral_fee", "rebate" },
            { "order_fee", "fee" },
            { "interest", "interest" },
            { "lend", "loan" },
            { "redeem", "loan" },
            { "profit", "interest" },
            { "flash_swap_buy", "trade" },
            { "flash_swap_sell", "trade" },
            { "unknown", "unknown" },
            { "set", "settlement" },
            { "prem", "trade" },
            { "point_refr", "rebate" },
            { "point_fee", "fee" },
            { "point_dnw", "deposit/withdraw" },
            { "fund", "fee" },
            { "refr", "rebate" },
            { "fee", "fee" },
            { "pnl", "trade" },
            { "dnw", "deposit/withdraw" },
        };
        return this.safeString(ledgerType, type, type);
    }

    public async override Task<object> setPositionMode(object hedged, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#setPositionMode
        * @description set dual/hedged mode to true or false for a swap market, make sure all positions are closed and no orders are open before setting dual mode
        * @see https://www.gate.io/docs/developers/apiv4/en/#enable-or-disable-dual-mode
        * @param {bool} hedged set to true to enable dual mode
        * @param {string|undefined} symbol if passed, dual mode is set for all markets with the same settle currency
        * @param {object} params extra parameters specific to the exchange API endpoint
        * @param {string} params.settle settle currency
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        object market = ((bool) isTrue((!isEqual(symbol, null)))) ? this.market(symbol) : null;
        var requestqueryVariable = this.prepareRequest(market, "swap", parameters);
        var request = ((IList<object>) requestqueryVariable)[0];
        var query = ((IList<object>) requestqueryVariable)[1];
        ((IDictionary<string,object>)request)["dual_mode"] = hedged;
        return await this.privateFuturesPostSettleDualMode(this.extend(request, query));
    }

    public async virtual Task<object> fetchUnderlyingAssets(object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchUnderlyingAssets
        * @description fetches the market ids of underlying assets for a specific contract market type
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-underlyings
        * @param {object} [params] exchange specific params
        * @param {string} [params.type] the contract market type, 'option', 'swap' or 'future', the default is 'option'
        * @returns {object[]} a list of [underlying assets]{@link https://docs.ccxt.com/#/?id=underlying-assets-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchUnderlyingAssets", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(isTrue((isEqual(marketType, null))) || isTrue((isEqual(marketType, "spot")))))
        {
            marketType = "option";
        }
        if (isTrue(!isEqual(marketType, "option")))
        {
            throw new NotSupported ((string)add(this.id, " fetchUnderlyingAssets() supports option markets only")) ;
        }
        object response = await this.publicOptionsGetUnderlyings(parameters);
        //
        //    [
        //        {
        //            "index_time": "1646915796",
        //            "name": "BTC_USDT",
        //            "index_price": "39142.73"
        //        }
        //    ]
        //
        object underlyings = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object underlying = getValue(response, i);
            object name = this.safeString(underlying, "name");
            if (isTrue(!isEqual(name, null)))
            {
                ((IList<object>)underlyings).Add(name);
            }
        }
        return underlyings;
    }

    public async override Task<object> fetchLiquidations(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchLiquidations
        * @description retrieves the public liquidations of a trading pair
        * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-liquidation-history
        * @param {string} symbol unified CCXT market symbol
        * @param {int} [since] the earliest time in ms to fetch liquidations for
        * @param {int} [limit] the maximum number of liquidation structures to retrieve
        * @param {object} [params] exchange specific parameters for the exchange API endpoint
        * @param {int} [params.until] timestamp in ms of the latest liquidation
        * @returns {object} an array of [liquidation structures]{@link https://docs.ccxt.com/#/?id=liquidation-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new NotSupported ((string)add(this.id, " fetchLiquidations() supports swap markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "settle", getValue(market, "settleId") },
            { "contract", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("to", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.publicFuturesGetSettleLiqOrders(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "contract": "BTC_USDT",
        //             "left": 0,
        //             "size": -165,
        //             "fill_price": "28070",
        //             "order_price": "28225",
        //             "time": 1696736132
        //         },
        //     ]
        //
        return this.parseLiquidations(response, market, since, limit);
    }

    public async override Task<object> fetchMyLiquidations(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchMyLiquidations
        * @description retrieves the users liquidated positions
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-liquidation-history
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-liquidation-history-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-user-s-liquidation-history-of-specified-underlying
        * @param {string} symbol unified CCXT market symbol
        * @param {int} [since] the earliest time in ms to fetch liquidations for
        * @param {int} [limit] the maximum number of liquidation structures to retrieve
        * @param {object} [params] exchange specific parameters for the exchange API endpoint
        * @returns {object} an array of [liquidation structures]{@link https://docs.ccxt.com/#/?id=liquidation-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyLiquidations() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "contract", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(isTrue((getValue(market, "swap"))) || isTrue((getValue(market, "future")))))
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            ((IDictionary<string,object>)request)["settle"] = getValue(market, "settleId");
        } else if (isTrue(getValue(market, "option")))
        {
            object marketId = getValue(market, "id");
            object optionParts = ((string)marketId).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            ((IDictionary<string,object>)request)["underlying"] = this.safeString(optionParts, 0);
        }
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.privateFuturesGetSettleLiquidates(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "future")))
        {
            response = await this.privateDeliveryGetSettleLiquidates(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "option")))
        {
            response = await this.privateOptionsGetPositionClose(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchMyLiquidations() does not support "), getValue(market, "type")), " orders")) ;
        }
        //
        // swap and future
        //
        //     [
        //         {
        //             "time": 1548654951,
        //             "contract": "BTC_USDT",
        //             "size": 600,
        //             "leverage": "25",
        //             "margin": "0.006705256878",
        //             "entry_price": "3536.123",
        //             "liq_price": "3421.54",
        //             "mark_price": "3420.27",
        //             "order_id": 317393847,
        //             "order_price": "3405",
        //             "fill_price": "3424",
        //             "left": 0
        //         }
        //     ]
        //
        // option
        //
        //     [
        //         {
        //             "time": 1631764800,
        //             "pnl": "-42914.291",
        //             "settle_size": "-10001",
        //             "side": "short",
        //             "contract": "BTC_USDT-20210916-5000-C",
        //             "text": "settled"
        //         }
        //     ]
        //
        return this.parseLiquidations(response, market, since, limit);
    }

    public override object parseLiquidation(object liquidation, object market = null)
    {
        //
        // fetchLiquidations
        //
        //     {
        //         "contract": "BTC_USDT",
        //         "left": 0,
        //         "size": -165,
        //         "fill_price": "28070",
        //         "order_price": "28225",
        //         "time": 1696736132
        //     }
        //
        // swap and future: fetchMyLiquidations
        //
        //     {
        //         "time": 1548654951,
        //         "contract": "BTC_USDT",
        //         "size": 600,
        //         "leverage": "25",
        //         "margin": "0.006705256878",
        //         "entry_price": "3536.123",
        //         "liq_price": "3421.54",
        //         "mark_price": "3420.27",
        //         "order_id": 317393847,
        //         "order_price": "3405",
        //         "fill_price": "3424",
        //         "left": 0
        //     }
        //
        // option: fetchMyLiquidations
        //
        //     {
        //         "time": 1631764800,
        //         "pnl": "-42914.291",
        //         "settle_size": "-10001",
        //         "side": "short",
        //         "contract": "BTC_USDT-20210916-5000-C",
        //         "text": "settled"
        //     }
        //
        object marketId = this.safeString(liquidation, "contract");
        object timestamp = this.safeTimestamp(liquidation, "time");
        object size = this.safeString2(liquidation, "size", "settle_size");
        object left = this.safeString(liquidation, "left", "0");
        object contractsString = Precise.stringAbs(Precise.stringSub(size, left));
        object contractSizeString = this.safeString(market, "contractSize");
        object priceString = this.safeString2(liquidation, "liq_price", "fill_price");
        object baseValueString = Precise.stringMul(contractsString, contractSizeString);
        object quoteValueString = this.safeString(liquidation, "pnl");
        if (isTrue(isEqual(quoteValueString, null)))
        {
            quoteValueString = Precise.stringMul(baseValueString, priceString);
        }
        return this.safeLiquidation(new Dictionary<string, object>() {
            { "info", liquidation },
            { "symbol", this.safeSymbol(marketId, market) },
            { "contracts", this.parseNumber(contractsString) },
            { "contractSize", this.parseNumber(contractSizeString) },
            { "price", this.parseNumber(priceString) },
            { "baseValue", this.parseNumber(baseValueString) },
            { "quoteValue", this.parseNumber(Precise.stringAbs(quoteValueString)) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        });
    }

    public async override Task<object> fetchGreeks(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchGreeks
        * @description fetches an option contracts greeks, financial metrics used to measure the factors that affect the price of an options contract
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-tickers-of-options-contracts
        * @param {string} symbol unified symbol of the market to fetch greeks for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [greeks structure]{@link https://docs.ccxt.com/#/?id=greeks-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "underlying", getValue(getValue(market, "info"), "underlying") },
        };
        object response = await this.publicOptionsGetTickers(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "vega": "1.78992",
        //             "leverage": "6.2096777055417",
        //             "ask_iv": "0.6245",
        //             "delta": "-0.69397",
        //             "last_price": "0",
        //             "theta": "-2.5723",
        //             "bid1_price": "222.9",
        //             "mark_iv": "0.5909",
        //             "name": "ETH_USDT-20231201-2300-P",
        //             "bid_iv": "0.5065",
        //             "ask1_price": "243.6",
        //             "mark_price": "236.57",
        //             "position_size": 0,
        //             "bid1_size": 368,
        //             "ask1_size": -335,
        //             "gamma": "0.00116"
        //         },
        //     ]
        //
        object marketId = getValue(market, "id");
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object entryMarketId = this.safeString(entry, "name");
            if (isTrue(isEqual(entryMarketId, marketId)))
            {
                return this.parseGreeks(entry, market);
            }
        }
        return null;
    }

    public override object parseGreeks(object greeks, object market = null)
    {
        //
        //     {
        //         "vega": "1.78992",
        //         "leverage": "6.2096777055417",
        //         "ask_iv": "0.6245",
        //         "delta": "-0.69397",
        //         "last_price": "0",
        //         "theta": "-2.5723",
        //         "bid1_price": "222.9",
        //         "mark_iv": "0.5909",
        //         "name": "ETH_USDT-20231201-2300-P",
        //         "bid_iv": "0.5065",
        //         "ask1_price": "243.6",
        //         "mark_price": "236.57",
        //         "position_size": 0,
        //         "bid1_size": 368,
        //         "ask1_size": -335,
        //         "gamma": "0.00116"
        //     }
        //
        object marketId = this.safeString(greeks, "name");
        object symbol = this.safeSymbol(marketId, market);
        return new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "delta", this.safeNumber(greeks, "delta") },
            { "gamma", this.safeNumber(greeks, "gamma") },
            { "theta", this.safeNumber(greeks, "theta") },
            { "vega", this.safeNumber(greeks, "vega") },
            { "rho", null },
            { "bidSize", this.safeNumber(greeks, "bid1_size") },
            { "askSize", this.safeNumber(greeks, "ask1_size") },
            { "bidImpliedVolatility", this.safeNumber(greeks, "bid_iv") },
            { "askImpliedVolatility", this.safeNumber(greeks, "ask_iv") },
            { "markImpliedVolatility", this.safeNumber(greeks, "mark_iv") },
            { "bidPrice", this.safeNumber(greeks, "bid1_price") },
            { "askPrice", this.safeNumber(greeks, "ask1_price") },
            { "markPrice", this.safeNumber(greeks, "mark_price") },
            { "lastPrice", this.safeNumber(greeks, "last_price") },
            { "underlyingPrice", this.parseNumber(getValue(getValue(market, "info"), "underlying_price")) },
            { "info", greeks },
        };
    }

    public async override Task<object> closePosition(object symbol, object side = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#closePosition
        * @description closes open positions for a market
        * @see https://www.gate.io/docs/developers/apiv4/en/#create-a-futures-order
        * @see https://www.gate.io/docs/developers/apiv4/en/#create-a-futures-order-2
        * @see https://www.gate.io/docs/developers/apiv4/en/#create-an-options-order
        * @param {string} symbol Unified CCXT market symbol
        * @param {string} side 'buy' or 'sell'
        * @param {object} [params] extra parameters specific to the okx api endpoint
        * @returns {object[]} [A list of position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "close", true },
        };
        parameters = this.extend(request, parameters);
        if (isTrue(isEqual(side, null)))
        {
            side = ""; // side is not used but needs to be present, otherwise crashes in php
        }
        return await this.createOrder(symbol, "market", side, 0, null, parameters);
    }

    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchLeverage
        * @description fetch the set leverage for a market
        * @see https://www.gate.io/docs/developers/apiv4/en/#get-unified-account-information
        * @see https://www.gate.io/docs/developers/apiv4/en/#get-detail-of-lending-market
        * @see https://www.gate.io/docs/developers/apiv4/en/#query-one-single-margin-currency-pair-deprecated
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.unified] default false, set to true for fetching the unified accounts leverage
        * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            // unified account does not require a symbol
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        object response = null;
        object isUnified = this.safeBool(parameters, "unified");
        parameters = this.omit(parameters, "unified");
        if (isTrue(getValue(market, "spot")))
        {
            ((IDictionary<string,object>)request)["currency_pair"] = getValue(market, "id");
            if (isTrue(isUnified))
            {
                response = await this.publicMarginGetUniCurrencyPairsCurrencyPair(this.extend(request, parameters));
            } else
            {
                response = await this.publicMarginGetCurrencyPairsCurrencyPair(this.extend(request, parameters));
            }
        } else if (isTrue(isUnified))
        {
            response = await this.privateUnifiedGetAccounts(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchLeverage() does not support "), getValue(market, "type")), " markets")) ;
        }
        return this.parseLeverage(response, market);
    }

    public async override Task<object> fetchLeverages(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchLeverages
        * @description fetch the set leverage for all leverage markets, only spot margin is supported on gate
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-lending-markets
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-supported-currency-pairs-supported-in-margin-trading-deprecated
        * @param {string[]} symbols a list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.unified] default false, set to true for fetching unified account leverages
        * @returns {object} a list of [leverage structures]{@link https://docs.ccxt.com/#/?id=leverage-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = null;
        object isUnified = this.safeBool(parameters, "unified");
        parameters = this.omit(parameters, "unified");
        object marketIdRequest = "id";
        if (isTrue(isUnified))
        {
            marketIdRequest = "currency_pair";
            response = await this.publicMarginGetUniCurrencyPairs(parameters);
        } else
        {
            response = await this.publicMarginGetCurrencyPairs(parameters);
        }
        return this.parseLeverages(response, symbols, marketIdRequest, "spot");
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        object marketId = this.safeString2(leverage, "currency_pair", "id");
        object leverageValue = this.safeInteger(leverage, "leverage");
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", this.safeSymbol(marketId, market, "_", "spot") },
            { "marginMode", null },
            { "longLeverage", leverageValue },
            { "shortLeverage", leverageValue },
        };
    }

    public async override Task<object> fetchOption(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchOption
        * @description fetches option data that is commonly found in an option chain
        * @see https://www.gate.io/docs/developers/apiv4/en/#query-specified-contract-detail
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [option chain structure]{@link https://docs.ccxt.com/#/?id=option-chain-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "contract", getValue(market, "id") },
        };
        object response = await this.publicOptionsGetContractsContract(this.extend(request, parameters));
        //
        //     {
        //         "is_active": true,
        //         "mark_price_round": "0.01",
        //         "settle_fee_rate": "0.00015",
        //         "bid1_size": 30,
        //         "taker_fee_rate": "0.0003",
        //         "price_limit_fee_rate": "0.1",
        //         "order_price_round": "0.1",
        //         "tag": "month",
        //         "ref_rebate_rate": "0",
        //         "name": "ETH_USDT-20240628-4500-C",
        //         "strike_price": "4500",
        //         "ask1_price": "280.5",
        //         "ref_discount_rate": "0",
        //         "order_price_deviate": "0.2",
        //         "ask1_size": -19,
        //         "mark_price_down": "155.45",
        //         "orderbook_id": 11724695,
        //         "is_call": true,
        //         "last_price": "188.7",
        //         "mark_price": "274.26",
        //         "underlying": "ETH_USDT",
        //         "create_time": 1688024882,
        //         "settle_limit_fee_rate": "0.1",
        //         "orders_limit": 10,
        //         "mark_price_up": "403.83",
        //         "position_size": 80,
        //         "order_size_max": 10000,
        //         "position_limit": 100000,
        //         "multiplier": "0.01",
        //         "order_size_min": 1,
        //         "trade_size": 229,
        //         "underlying_price": "3326.6",
        //         "maker_fee_rate": "0.0003",
        //         "expiration_time": 1719561600,
        //         "trade_id": 15,
        //         "bid1_price": "269.3"
        //     }
        //
        return this.parseOption(response, null, market);
    }

    public async override Task<object> fetchOptionChain(object code, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchOptionChain
        * @description fetches data for an underlying asset that is commonly found in an option chain
        * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-the-contracts-with-specified-underlying-and-expiration-time
        * @param {string} currency base currency to fetch an option chain for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.underlying] the underlying asset, can be obtained from fetchUnderlyingAssets ()
        * @param {int} [params.expiration] unix timestamp of the expiration time
        * @returns {object} a list of [option chain structures]{@link https://docs.ccxt.com/#/?id=option-chain-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "underlying", add(getValue(currency, "code"), "_USDT") },
        };
        object response = await this.publicOptionsGetContracts(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "is_active": true,
        //             "mark_price_round": "0.1",
        //             "settle_fee_rate": "0.00015",
        //             "bid1_size": 434,
        //             "taker_fee_rate": "0.0003",
        //             "price_limit_fee_rate": "0.1",
        //             "order_price_round": "1",
        //             "tag": "day",
        //             "ref_rebate_rate": "0",
        //             "name": "BTC_USDT-20240324-63500-P",
        //             "strike_price": "63500",
        //             "ask1_price": "387",
        //             "ref_discount_rate": "0",
        //             "order_price_deviate": "0.15",
        //             "ask1_size": -454,
        //             "mark_price_down": "124.3",
        //             "orderbook_id": 29600,
        //             "is_call": false,
        //             "last_price": "0",
        //             "mark_price": "366.6",
        //             "underlying": "BTC_USDT",
        //             "create_time": 1711118829,
        //             "settle_limit_fee_rate": "0.1",
        //             "orders_limit": 10,
        //             "mark_price_up": "630",
        //             "position_size": 0,
        //             "order_size_max": 10000,
        //             "position_limit": 10000,
        //             "multiplier": "0.01",
        //             "order_size_min": 1,
        //             "trade_size": 0,
        //             "underlying_price": "64084.65",
        //             "maker_fee_rate": "0.0003",
        //             "expiration_time": 1711267200,
        //             "trade_id": 0,
        //             "bid1_price": "307"
        //         },
        //     ]
        //
        return this.parseOptionChain(response, null, "name");
    }

    public override object parseOption(object chain, object currency = null, object market = null)
    {
        //
        //     {
        //         "is_active": true,
        //         "mark_price_round": "0.1",
        //         "settle_fee_rate": "0.00015",
        //         "bid1_size": 434,
        //         "taker_fee_rate": "0.0003",
        //         "price_limit_fee_rate": "0.1",
        //         "order_price_round": "1",
        //         "tag": "day",
        //         "ref_rebate_rate": "0",
        //         "name": "BTC_USDT-20240324-63500-P",
        //         "strike_price": "63500",
        //         "ask1_price": "387",
        //         "ref_discount_rate": "0",
        //         "order_price_deviate": "0.15",
        //         "ask1_size": -454,
        //         "mark_price_down": "124.3",
        //         "orderbook_id": 29600,
        //         "is_call": false,
        //         "last_price": "0",
        //         "mark_price": "366.6",
        //         "underlying": "BTC_USDT",
        //         "create_time": 1711118829,
        //         "settle_limit_fee_rate": "0.1",
        //         "orders_limit": 10,
        //         "mark_price_up": "630",
        //         "position_size": 0,
        //         "order_size_max": 10000,
        //         "position_limit": 10000,
        //         "multiplier": "0.01",
        //         "order_size_min": 1,
        //         "trade_size": 0,
        //         "underlying_price": "64084.65",
        //         "maker_fee_rate": "0.0003",
        //         "expiration_time": 1711267200,
        //         "trade_id": 0,
        //         "bid1_price": "307"
        //     }
        //
        object marketId = this.safeString(chain, "name");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeTimestamp(chain, "create_time");
        return new Dictionary<string, object>() {
            { "info", chain },
            { "currency", null },
            { "symbol", getValue(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "impliedVolatility", null },
            { "openInterest", null },
            { "bidPrice", this.safeNumber(chain, "bid1_price") },
            { "askPrice", this.safeNumber(chain, "ask1_price") },
            { "midPrice", null },
            { "markPrice", this.safeNumber(chain, "mark_price") },
            { "lastPrice", this.safeNumber(chain, "last_price") },
            { "underlyingPrice", this.safeNumber(chain, "underlying_price") },
            { "change", null },
            { "percentage", null },
            { "baseVolume", null },
            { "quoteVolume", null },
        };
    }

    public async override Task<object> fetchPositionsHistory(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name gate#fetchPositionsHistory
        * @description fetches historical positions
        * @see https://www.gate.io/docs/developers/apiv4/#list-position-close-history
        * @see https://www.gate.io/docs/developers/apiv4/#list-position-close-history-2
        * @param {string[]} symbols unified conract symbols, must all have the same settle currency and the same market type
        * @param {int} [since] the earliest time in ms to fetch positions for
        * @param {int} [limit] the maximum amount of records to fetch, default=1000
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @param {int} [params.until] the latest time in ms to fetch positions for
        *
        * EXCHANGE SPECIFIC PARAMETERS
        * @param {int} offset list offset, starting from 0
        * @param {string} side long or short
        * @param {string} pnl query profit or loss
        * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(isEqual(symbolsLength, 1)))
            {
                market = this.market(getValue(symbols, 0));
            }
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchPositionsHistory", market, parameters, "swap");
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        object request = new Dictionary<string, object>() {};
        var requestparametersVariable = this.prepareRequest(market, marketType, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = this.parseToInt(divide(since, 1000));
        }
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["to"] = this.parseToInt(divide(until, 1000));
        }
        object response = null;
        if (isTrue(isEqual(marketType, "swap")))
        {
            response = await this.privateFuturesGetSettlePositionClose(this.extend(request, parameters));
        } else if (isTrue(isEqual(marketType, "future")))
        {
            response = await this.privateDeliveryGetSettlePositionClose(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(this.id, " fetchPositionsHistory() does not support markets of type "), marketType)) ;
        }
        //
        //    [
        //        {
        //            "contract": "SLERF_USDT",
        //            "text": "web",
        //            "long_price": "0.766306",
        //            "pnl": "-23.41702352",
        //            "pnl_pnl": "-22.7187",
        //            "pnl_fee": "-0.06527125",
        //            "pnl_fund": "-0.63305227",
        //            "accum_size": "100",
        //            "time": 1711279263,
        //            "short_price": "0.539119",
        //            "side": "long",
        //            "max_size": "100",
        //            "first_open_time": 1711037985
        //        },
        //        ...
        //    ]
        //
        return this.parsePositions(response, symbols, parameters);
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        //
        //    {"label": "ORDER_NOT_FOUND", "message": "Order not found"}
        //    {"label": "INVALID_PARAM_VALUE", "message": "invalid argument: status"}
        //    {"label": "INVALID_PARAM_VALUE", "message": "invalid argument: Trigger.rule"}
        //    {"label": "INVALID_PARAM_VALUE", "message": "invalid argument: trigger.expiration invalid range"}
        //    {"label": "INVALID_ARGUMENT", "detail": "invalid size"}
        //
        object label = this.safeString(response, "label");
        if (isTrue(!isEqual(label, null)))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), label, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
