namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class okcoin : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "okcoin" },
            { "name", "OKCoin" },
            { "countries", new List<object>() {"CN", "US"} },
            { "version", "v5" },
            { "rateLimit", 20 },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", true },
                { "option", null },
                { "cancelOrder", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRate", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchBorrowRates", false },
                { "fetchBorrowRatesPerSymbol", false },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchLedger", true },
                { "fetchMarkets", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", null },
                { "fetchOrderTrades", true },
                { "fetchPosition", false },
                { "fetchPositions", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTransactions", null },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", false },
                { "setMargin", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1H" },
                { "2h", "2H" },
                { "4h", "4H" },
                { "6h", "6H" },
                { "12h", "12H" },
                { "1d", "1D" },
                { "1w", "1W" },
                { "1M", "1M" },
                { "3M", "3M" },
            } },
            { "hostname", "okcoin.com" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/51840849/87295551-102fbf00-c50e-11ea-90a9-462eebba5829.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "rest", "https://www.{hostname}" },
                } },
                { "www", "https://www.okcoin.com" },
                { "doc", "https://www.okcoin.com/docs/en/" },
                { "fees", "https://www.okcoin.com/coin-fees" },
                { "referral", "https://www.okcoin.com/account/register?flag=activity&channelId=600001513" },
                { "test", new Dictionary<string, object>() {
                    { "rest", "https://testnet.okex.com" },
                } },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "market/tickers", 1 },
                        { "market/ticker", 1 },
                        { "market/books", divide(1, 2) },
                        { "market/candles", divide(1, 2) },
                        { "market/history-candles", divide(1, 2) },
                        { "market/trades", divide(1, 5) },
                        { "market/history-trades", 2 },
                        { "market/platform-24-volume", 10 },
                        { "market/open-oracle", 50 },
                        { "market/exchange-rate", 20 },
                        { "public/instruments", 1 },
                        { "public/time", 2 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "trade/order", divide(1, 3) },
                        { "trade/orders-pending", divide(1, 3) },
                        { "trade/orders-history", divide(1, 2) },
                        { "trade/orders-history-archive", divide(1, 2) },
                        { "trade/fills", divide(1, 3) },
                        { "trade/fills-history", 2.2 },
                        { "trade/fills-archive", 2 },
                        { "trade/order-algo", 1 },
                        { "trade/orders-algo-pending", 1 },
                        { "trade/orders-algo-history", 1 },
                        { "otc/rfq/trade", 4 },
                        { "otc/rfq/history", 4 },
                        { "account/balance", 2 },
                        { "account/bills", divide(5, 3) },
                        { "account/bills-archive", divide(5, 3) },
                        { "account/config", 4 },
                        { "account/max-size", 4 },
                        { "account/max-avail-size", 4 },
                        { "account/trade-fee", 4 },
                        { "account/max-withdrawal", 4 },
                        { "asset/currencies", divide(5, 3) },
                        { "asset/balances", divide(5, 3) },
                        { "asset/asset-valuation", 10 },
                        { "asset/transfer-state", 10 },
                        { "asset/bills", divide(5, 3) },
                        { "asset/deposit-lightning", 5 },
                        { "asset/deposit-address", divide(5, 3) },
                        { "asset/deposit-history", divide(5, 3) },
                        { "asset/withdrawal-history", divide(5, 3) },
                        { "asset/deposit-withdraw-status", 20 },
                        { "fiat/deposit-history", divide(5, 3) },
                        { "fiat-withdraw-history", divide(5, 3) },
                        { "fiat-channel", divide(5, 3) },
                        { "users/subaccount/list", 10 },
                        { "users/subaccount/apiKey", 10 },
                        { "account/subaccount/balances", 10 },
                        { "asset/subaccount/balances", 10 },
                        { "asset/subaccount/bills", 10 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "trade/order", divide(1, 3) },
                        { "trade/batch-orders", divide(1, 15) },
                        { "trade/cancel-order", divide(1, 3) },
                        { "trade/cancel-batch-orders", divide(1, 15) },
                        { "trade/amend-order", divide(1, 3) },
                        { "trade/amend-batch-orders", divide(1, 150) },
                        { "trade/order-algo", 1 },
                        { "trade/cancel-algos", 1 },
                        { "trade/cancel-advance-algos", 1 },
                        { "otc/rfq/quote", 4 },
                        { "otc/rfq/trade", 4 },
                        { "asset/transfer", 4 },
                        { "asset/withdrawal", 4 },
                        { "asset/withdrawal-lightning", 4 },
                        { "asset/withdrawal-cancel", 4 },
                        { "fiat/deposit", divide(5, 3) },
                        { "fiat/cancel-deposit", divide(5, 3) },
                        { "fiat/withdrawal", divide(5, 3) },
                        { "fiat/cancel-withdrawal", divide(5, 3) },
                        { "asset/subaccount/transfer", 10 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "taker", 0.002 },
                    { "maker", 0.001 },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "taker", 0.0015 },
                    { "maker", 0.001 },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "password", true },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "1", typeof(ExchangeError) },
                    { "2", typeof(ExchangeError) },
                    { "50000", typeof(BadRequest) },
                    { "50001", typeof(OnMaintenance) },
                    { "50002", typeof(BadRequest) },
                    { "50004", typeof(RequestTimeout) },
                    { "50005", typeof(ExchangeNotAvailable) },
                    { "50006", typeof(BadRequest) },
                    { "50007", typeof(AccountSuspended) },
                    { "50008", typeof(AuthenticationError) },
                    { "50009", typeof(AccountSuspended) },
                    { "50010", typeof(ExchangeError) },
                    { "50011", typeof(RateLimitExceeded) },
                    { "50012", typeof(ExchangeError) },
                    { "50013", typeof(ExchangeNotAvailable) },
                    { "50014", typeof(BadRequest) },
                    { "50015", typeof(ExchangeError) },
                    { "50016", typeof(ExchangeError) },
                    { "50017", typeof(ExchangeError) },
                    { "50018", typeof(ExchangeError) },
                    { "50019", typeof(ExchangeError) },
                    { "50020", typeof(ExchangeError) },
                    { "50021", typeof(ExchangeError) },
                    { "50022", typeof(ExchangeError) },
                    { "50023", typeof(ExchangeError) },
                    { "50024", typeof(BadRequest) },
                    { "50025", typeof(ExchangeError) },
                    { "50026", typeof(ExchangeNotAvailable) },
                    { "50027", typeof(PermissionDenied) },
                    { "50028", typeof(ExchangeError) },
                    { "50029", typeof(ExchangeError) },
                    { "50030", typeof(PermissionDenied) },
                    { "50032", typeof(AccountSuspended) },
                    { "50033", typeof(AccountSuspended) },
                    { "50035", typeof(BadRequest) },
                    { "50036", typeof(BadRequest) },
                    { "50037", typeof(BadRequest) },
                    { "50038", typeof(ExchangeError) },
                    { "50039", typeof(ExchangeError) },
                    { "50041", typeof(ExchangeError) },
                    { "50044", typeof(BadRequest) },
                    { "50100", typeof(ExchangeError) },
                    { "50101", typeof(AuthenticationError) },
                    { "50102", typeof(InvalidNonce) },
                    { "50103", typeof(AuthenticationError) },
                    { "50104", typeof(AuthenticationError) },
                    { "50105", typeof(AuthenticationError) },
                    { "50106", typeof(AuthenticationError) },
                    { "50107", typeof(AuthenticationError) },
                    { "50108", typeof(ExchangeError) },
                    { "50109", typeof(ExchangeError) },
                    { "50110", typeof(PermissionDenied) },
                    { "50111", typeof(AuthenticationError) },
                    { "50112", typeof(AuthenticationError) },
                    { "50113", typeof(AuthenticationError) },
                    { "50114", typeof(AuthenticationError) },
                    { "50115", typeof(BadRequest) },
                    { "51000", typeof(BadRequest) },
                    { "51001", typeof(BadSymbol) },
                    { "51002", typeof(BadSymbol) },
                    { "51003", typeof(BadRequest) },
                    { "51004", typeof(InvalidOrder) },
                    { "51005", typeof(InvalidOrder) },
                    { "51006", typeof(InvalidOrder) },
                    { "51007", typeof(InvalidOrder) },
                    { "51008", typeof(InsufficientFunds) },
                    { "51009", typeof(AccountSuspended) },
                    { "51010", typeof(AccountNotEnabled) },
                    { "51011", typeof(InvalidOrder) },
                    { "51012", typeof(BadSymbol) },
                    { "51014", typeof(BadSymbol) },
                    { "51015", typeof(BadSymbol) },
                    { "51016", typeof(InvalidOrder) },
                    { "51017", typeof(ExchangeError) },
                    { "51018", typeof(ExchangeError) },
                    { "51019", typeof(ExchangeError) },
                    { "51020", typeof(InvalidOrder) },
                    { "51023", typeof(ExchangeError) },
                    { "51024", typeof(AccountSuspended) },
                    { "51025", typeof(ExchangeError) },
                    { "51026", typeof(BadSymbol) },
                    { "51030", typeof(InvalidOrder) },
                    { "51031", typeof(InvalidOrder) },
                    { "51032", typeof(InvalidOrder) },
                    { "51033", typeof(InvalidOrder) },
                    { "51037", typeof(InvalidOrder) },
                    { "51038", typeof(InvalidOrder) },
                    { "51044", typeof(InvalidOrder) },
                    { "51046", typeof(InvalidOrder) },
                    { "51047", typeof(InvalidOrder) },
                    { "51048", typeof(InvalidOrder) },
                    { "51049", typeof(InvalidOrder) },
                    { "51050", typeof(InvalidOrder) },
                    { "51051", typeof(InvalidOrder) },
                    { "51052", typeof(InvalidOrder) },
                    { "51053", typeof(InvalidOrder) },
                    { "51054", typeof(BadRequest) },
                    { "51056", typeof(InvalidOrder) },
                    { "51058", typeof(InvalidOrder) },
                    { "51059", typeof(InvalidOrder) },
                    { "51100", typeof(InvalidOrder) },
                    { "51102", typeof(InvalidOrder) },
                    { "51103", typeof(InvalidOrder) },
                    { "51108", typeof(InvalidOrder) },
                    { "51109", typeof(InvalidOrder) },
                    { "51110", typeof(InvalidOrder) },
                    { "51111", typeof(BadRequest) },
                    { "51112", typeof(InvalidOrder) },
                    { "51113", typeof(RateLimitExceeded) },
                    { "51115", typeof(InvalidOrder) },
                    { "51116", typeof(InvalidOrder) },
                    { "51117", typeof(InvalidOrder) },
                    { "51118", typeof(InvalidOrder) },
                    { "51119", typeof(InsufficientFunds) },
                    { "51120", typeof(InvalidOrder) },
                    { "51121", typeof(InvalidOrder) },
                    { "51122", typeof(InvalidOrder) },
                    { "51124", typeof(InvalidOrder) },
                    { "51125", typeof(InvalidOrder) },
                    { "51126", typeof(InvalidOrder) },
                    { "51127", typeof(InsufficientFunds) },
                    { "51128", typeof(InvalidOrder) },
                    { "51129", typeof(InvalidOrder) },
                    { "51130", typeof(BadSymbol) },
                    { "51131", typeof(InsufficientFunds) },
                    { "51132", typeof(InvalidOrder) },
                    { "51133", typeof(InvalidOrder) },
                    { "51134", typeof(InvalidOrder) },
                    { "51135", typeof(InvalidOrder) },
                    { "51136", typeof(InvalidOrder) },
                    { "51137", typeof(InvalidOrder) },
                    { "51138", typeof(InvalidOrder) },
                    { "51139", typeof(InvalidOrder) },
                    { "51156", typeof(BadRequest) },
                    { "51159", typeof(BadRequest) },
                    { "51162", typeof(InvalidOrder) },
                    { "51163", typeof(InvalidOrder) },
                    { "51166", typeof(InvalidOrder) },
                    { "51174", typeof(InvalidOrder) },
                    { "51201", typeof(InvalidOrder) },
                    { "51202", typeof(InvalidOrder) },
                    { "51203", typeof(InvalidOrder) },
                    { "51204", typeof(InvalidOrder) },
                    { "51205", typeof(InvalidOrder) },
                    { "51250", typeof(InvalidOrder) },
                    { "51251", typeof(InvalidOrder) },
                    { "51252", typeof(InvalidOrder) },
                    { "51253", typeof(InvalidOrder) },
                    { "51254", typeof(InvalidOrder) },
                    { "51255", typeof(InvalidOrder) },
                    { "51256", typeof(InvalidOrder) },
                    { "51257", typeof(InvalidOrder) },
                    { "51258", typeof(InvalidOrder) },
                    { "51259", typeof(InvalidOrder) },
                    { "51260", typeof(InvalidOrder) },
                    { "51261", typeof(InvalidOrder) },
                    { "51262", typeof(InvalidOrder) },
                    { "51263", typeof(InvalidOrder) },
                    { "51264", typeof(InvalidOrder) },
                    { "51265", typeof(InvalidOrder) },
                    { "51267", typeof(InvalidOrder) },
                    { "51268", typeof(InvalidOrder) },
                    { "51269", typeof(InvalidOrder) },
                    { "51270", typeof(InvalidOrder) },
                    { "51271", typeof(InvalidOrder) },
                    { "51272", typeof(InvalidOrder) },
                    { "51273", typeof(InvalidOrder) },
                    { "51274", typeof(InvalidOrder) },
                    { "51275", typeof(InvalidOrder) },
                    { "51276", typeof(InvalidOrder) },
                    { "51277", typeof(InvalidOrder) },
                    { "51278", typeof(InvalidOrder) },
                    { "51279", typeof(InvalidOrder) },
                    { "51280", typeof(InvalidOrder) },
                    { "51321", typeof(InvalidOrder) },
                    { "51322", typeof(InvalidOrder) },
                    { "51323", typeof(BadRequest) },
                    { "51324", typeof(BadRequest) },
                    { "51325", typeof(InvalidOrder) },
                    { "51327", typeof(InvalidOrder) },
                    { "51328", typeof(InvalidOrder) },
                    { "51329", typeof(InvalidOrder) },
                    { "51330", typeof(InvalidOrder) },
                    { "51400", typeof(OrderNotFound) },
                    { "51401", typeof(OrderNotFound) },
                    { "51402", typeof(OrderNotFound) },
                    { "51403", typeof(InvalidOrder) },
                    { "51404", typeof(InvalidOrder) },
                    { "51405", typeof(ExchangeError) },
                    { "51406", typeof(ExchangeError) },
                    { "51407", typeof(BadRequest) },
                    { "51408", typeof(ExchangeError) },
                    { "51409", typeof(ExchangeError) },
                    { "51410", typeof(CancelPending) },
                    { "51500", typeof(ExchangeError) },
                    { "51501", typeof(ExchangeError) },
                    { "51502", typeof(InsufficientFunds) },
                    { "51503", typeof(ExchangeError) },
                    { "51506", typeof(ExchangeError) },
                    { "51508", typeof(ExchangeError) },
                    { "51509", typeof(ExchangeError) },
                    { "51510", typeof(ExchangeError) },
                    { "51511", typeof(ExchangeError) },
                    { "51600", typeof(ExchangeError) },
                    { "51601", typeof(ExchangeError) },
                    { "51602", typeof(ExchangeError) },
                    { "51603", typeof(OrderNotFound) },
                    { "51732", typeof(AuthenticationError) },
                    { "51733", typeof(AuthenticationError) },
                    { "51734", typeof(AuthenticationError) },
                    { "51735", typeof(ExchangeError) },
                    { "51736", typeof(InsufficientFunds) },
                    { "52000", typeof(ExchangeError) },
                    { "54000", typeof(ExchangeError) },
                    { "54001", typeof(ExchangeError) },
                    { "58000", typeof(ExchangeError) },
                    { "58001", typeof(AuthenticationError) },
                    { "58002", typeof(PermissionDenied) },
                    { "58003", typeof(ExchangeError) },
                    { "58004", typeof(AccountSuspended) },
                    { "58005", typeof(ExchangeError) },
                    { "58006", typeof(ExchangeError) },
                    { "58007", typeof(ExchangeError) },
                    { "58100", typeof(ExchangeError) },
                    { "58101", typeof(AccountSuspended) },
                    { "58102", typeof(RateLimitExceeded) },
                    { "58103", typeof(ExchangeError) },
                    { "58104", typeof(ExchangeError) },
                    { "58105", typeof(ExchangeError) },
                    { "58106", typeof(ExchangeError) },
                    { "58107", typeof(ExchangeError) },
                    { "58108", typeof(ExchangeError) },
                    { "58109", typeof(ExchangeError) },
                    { "58110", typeof(ExchangeError) },
                    { "58111", typeof(ExchangeError) },
                    { "58112", typeof(ExchangeError) },
                    { "58114", typeof(ExchangeError) },
                    { "58115", typeof(ExchangeError) },
                    { "58116", typeof(ExchangeError) },
                    { "58117", typeof(ExchangeError) },
                    { "58125", typeof(BadRequest) },
                    { "58126", typeof(BadRequest) },
                    { "58127", typeof(BadRequest) },
                    { "58128", typeof(BadRequest) },
                    { "58200", typeof(ExchangeError) },
                    { "58201", typeof(ExchangeError) },
                    { "58202", typeof(ExchangeError) },
                    { "58203", typeof(InvalidAddress) },
                    { "58204", typeof(AccountSuspended) },
                    { "58205", typeof(ExchangeError) },
                    { "58206", typeof(ExchangeError) },
                    { "58207", typeof(InvalidAddress) },
                    { "58208", typeof(ExchangeError) },
                    { "58209", typeof(ExchangeError) },
                    { "58210", typeof(ExchangeError) },
                    { "58211", typeof(ExchangeError) },
                    { "58212", typeof(ExchangeError) },
                    { "58213", typeof(AuthenticationError) },
                    { "58221", typeof(BadRequest) },
                    { "58222", typeof(BadRequest) },
                    { "58224", typeof(BadRequest) },
                    { "58227", typeof(BadRequest) },
                    { "58228", typeof(BadRequest) },
                    { "58229", typeof(InsufficientFunds) },
                    { "58300", typeof(ExchangeError) },
                    { "58350", typeof(InsufficientFunds) },
                    { "59000", typeof(ExchangeError) },
                    { "59001", typeof(ExchangeError) },
                    { "59100", typeof(ExchangeError) },
                    { "59101", typeof(ExchangeError) },
                    { "59102", typeof(ExchangeError) },
                    { "59103", typeof(InsufficientFunds) },
                    { "59104", typeof(ExchangeError) },
                    { "59105", typeof(ExchangeError) },
                    { "59106", typeof(ExchangeError) },
                    { "59107", typeof(ExchangeError) },
                    { "59108", typeof(InsufficientFunds) },
                    { "59109", typeof(ExchangeError) },
                    { "59128", typeof(InvalidOrder) },
                    { "59200", typeof(InsufficientFunds) },
                    { "59201", typeof(InsufficientFunds) },
                    { "59216", typeof(BadRequest) },
                    { "59300", typeof(ExchangeError) },
                    { "59301", typeof(ExchangeError) },
                    { "59313", typeof(ExchangeError) },
                    { "59401", typeof(ExchangeError) },
                    { "59500", typeof(ExchangeError) },
                    { "59501", typeof(ExchangeError) },
                    { "59502", typeof(ExchangeError) },
                    { "59503", typeof(ExchangeError) },
                    { "59504", typeof(ExchangeError) },
                    { "59505", typeof(ExchangeError) },
                    { "59506", typeof(ExchangeError) },
                    { "59507", typeof(ExchangeError) },
                    { "59508", typeof(AccountSuspended) },
                    { "60001", typeof(AuthenticationError) },
                    { "60002", typeof(AuthenticationError) },
                    { "60003", typeof(AuthenticationError) },
                    { "60004", typeof(AuthenticationError) },
                    { "60005", typeof(AuthenticationError) },
                    { "60006", typeof(InvalidNonce) },
                    { "60007", typeof(AuthenticationError) },
                    { "60008", typeof(AuthenticationError) },
                    { "60009", typeof(AuthenticationError) },
                    { "60010", typeof(AuthenticationError) },
                    { "60011", typeof(AuthenticationError) },
                    { "60012", typeof(BadRequest) },
                    { "60013", typeof(BadRequest) },
                    { "60014", typeof(RateLimitExceeded) },
                    { "60015", typeof(NetworkError) },
                    { "60016", typeof(ExchangeNotAvailable) },
                    { "60017", typeof(BadRequest) },
                    { "60018", typeof(BadRequest) },
                    { "60019", typeof(BadRequest) },
                    { "63999", typeof(ExchangeError) },
                    { "70010", typeof(BadRequest) },
                    { "70013", typeof(BadRequest) },
                    { "70016", typeof(BadRequest) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Internal Server Error", typeof(ExchangeNotAvailable) },
                    { "server error", typeof(ExchangeNotAvailable) },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "options", new Dictionary<string, object>() {
                { "fetchOHLCV", new Dictionary<string, object>() {
                    { "type", "Candles" },
                } },
                { "createMarketBuyOrderRequiresPrice", true },
                { "fetchMarkets", new List<object>() {"spot"} },
                { "defaultType", "spot" },
                { "accountsByType", new Dictionary<string, object>() {
                    { "classic", "1" },
                    { "spot", "1" },
                    { "funding", "6" },
                    { "main", "6" },
                    { "unified", "18" },
                } },
                { "accountsById", new Dictionary<string, object>() {
                    { "1", "spot" },
                    { "6", "funding" },
                    { "18", "unified" },
                } },
                { "auth", new Dictionary<string, object>() {
                    { "time", "public" },
                    { "currencies", "private" },
                    { "instruments", "public" },
                    { "rate", "public" },
                    { "{instrument_id}/constituents", "public" },
                } },
                { "warnOnFetchCurrenciesWithoutAuthorization", false },
                { "defaultNetwork", "ERC20" },
                { "networks", new Dictionary<string, object>() {
                    { "ERC20", "Ethereum" },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "AE", "AET" },
                { "BOX", "DefiBox" },
                { "HOT", "Hydro Protocol" },
                { "HSR", "HC" },
                { "MAG", "Maggie" },
                { "SBTC", "Super Bitcoin" },
                { "TRADE", "Unitrade" },
                { "YOYO", "YOYOW" },
                { "WIN", "WinToken" },
            } },
        });
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name okcoin#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetPublicTime(parameters);
        //
        //     {
        //         "iso": "2015-01-07T23:47:25.201Z",
        //         "epoch": 1420674445.201
        //     }
        //
        return this.parse8601(this.safeString(response, "iso"));
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name okcoin#fetchMarkets
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-public-data-get-instruments
        * @description retrieves data on all markets for okcoin
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "instType", "SPOT" },
        };
        object response = await this.publicGetPublicInstruments(this.extend(request, parameters));
        object markets = this.safeValue(response, "data", new List<object>() {});
        return this.parseMarkets(markets);
    }

    public override object parseMarket(object market)
    {
        //
        // spot markets
        //
        //     {
        //         "base_currency": "EOS",
        //         "instrument_id": "EOS-OKB",
        //         "min_size": "0.01",
        //         "quote_currency": "OKB",
        //         "size_increment": "0.000001",
        //         "tick_size": "0.0001"
        //     }
        //
        object id = this.safeString(market, "instId");
        object type = this.safeStringLower(market, "instType");
        if (isTrue(isEqual(type, "futures")))
        {
            type = "future";
        }
        object spot = (isEqual(type, "spot"));
        object future = (isEqual(type, "future"));
        object swap = (isEqual(type, "swap"));
        object option = (isEqual(type, "option"));
        object contract = isTrue(isTrue(swap) || isTrue(future)) || isTrue(option);
        object baseId = this.safeString(market, "baseCcy");
        object quoteId = this.safeString(market, "quoteCcy");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(bs, "/"), quote);
        object tickSize = this.safeString(market, "tickSz");
        object fees = this.safeValue2(this.fees, type, "trading", new Dictionary<string, object>() {});
        object maxLeverage = this.safeString(market, "lever", "1");
        maxLeverage = Precise.stringMax(maxLeverage, "1");
        object maxSpotCost = this.safeNumber(market, "maxMktSz");
        return this.extend(fees, new Dictionary<string, object>() {
            { "id", id },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", null },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", null },
            { "type", type },
            { "spot", spot },
            { "margin", isTrue(spot) && isTrue((Precise.stringGt(maxLeverage, "1"))) },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "active", true },
            { "contract", false },
            { "linear", null },
            { "inverse", null },
            { "contractSize", ((bool) isTrue(contract)) ? this.safeNumber(market, "ctVal") : null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "created", this.safeInteger(market, "listTime") },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber(market, "lotSz") },
                { "price", this.parseNumber(tickSize) },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", this.parseNumber("1") },
                    { "max", this.parseNumber(maxLeverage) },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "minSz") },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", ((bool) isTrue(contract)) ? null : maxSpotCost },
                } },
            } },
            { "info", market },
        });
    }

    public virtual object safeNetwork(object networkId)
    {
        object networksById = new Dictionary<string, object>() {
            { "Bitcoin", "BTC" },
            { "Omni", "OMNI" },
            { "TRON", "TRC20" },
        };
        return this.safeString(networksById, networkId, networkId);
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name okcoin#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(this.checkRequiredCredentials(false)))
        {
            if (isTrue(getValue(this.options, "warnOnFetchCurrenciesWithoutAuthorization")))
            {
                throw new ExchangeError ((string)add(this.id, " fetchCurrencies() is a private API endpoint that requires authentication with API keys. Set the API keys on the exchange instance or exchange.options[\"warnOnFetchCurrenciesWithoutAuthorization\"] = false to suppress this warning message.")) ;
            }
            return null;
        } else
        {
            object response = await this.privateGetAssetCurrencies(parameters);
            object data = this.safeValue(response, "data", new List<object>() {});
            object result = new Dictionary<string, object>() {};
            object dataByCurrencyId = this.groupBy(data, "ccy");
            object currencyIds = new List<object>(((IDictionary<string,object>)dataByCurrencyId).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
            {
                object currencyId = getValue(currencyIds, i);
                object currency = this.safeCurrency(currencyId);
                object code = getValue(currency, "code");
                object chains = getValue(dataByCurrencyId, currencyId);
                object networks = new Dictionary<string, object>() {};
                object currencyActive = false;
                object depositEnabled = false;
                object withdrawEnabled = false;
                object maxPrecision = null;
                for (object j = 0; isLessThan(j, getArrayLength(chains)); postFixIncrement(ref j))
                {
                    object chain = getValue(chains, j);
                    object canDeposit = this.safeValue(chain, "canDep");
                    depositEnabled = ((bool) isTrue((canDeposit))) ? canDeposit : depositEnabled;
                    object canWithdraw = this.safeValue(chain, "canWd");
                    withdrawEnabled = ((bool) isTrue((canWithdraw))) ? canWithdraw : withdrawEnabled;
                    object canInternal = this.safeValue(chain, "canInternal");
                    object active = ((bool) isTrue((isTrue(isTrue(canDeposit) && isTrue(canWithdraw)) && isTrue(canInternal)))) ? true : false;
                    currencyActive = ((bool) isTrue((active))) ? active : currencyActive;
                    object networkId = this.safeString(chain, "chain");
                    if (isTrue(isTrue((!isEqual(networkId, null))) && isTrue((isGreaterThanOrEqual(getIndexOf(networkId, "-"), 0)))))
                    {
                        object parts = ((string)networkId).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
                        object chainPart = this.safeString(parts, 1, networkId);
                        object networkCode = this.safeNetwork(chainPart);
                        object precision = this.parsePrecision(this.safeString(chain, "wdTickSz"));
                        if (isTrue(isEqual(maxPrecision, null)))
                        {
                            maxPrecision = precision;
                        } else
                        {
                            maxPrecision = Precise.stringMin(maxPrecision, precision);
                        }
                        ((IDictionary<string,object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                            { "id", networkId },
                            { "network", networkCode },
                            { "active", active },
                            { "deposit", canDeposit },
                            { "withdraw", canWithdraw },
                            { "fee", this.safeNumber(chain, "minFee") },
                            { "precision", this.parseNumber(precision) },
                            { "limits", new Dictionary<string, object>() {
                                { "withdraw", new Dictionary<string, object>() {
                                    { "min", this.safeNumber(chain, "minWd") },
                                    { "max", this.safeNumber(chain, "maxWd") },
                                } },
                            } },
                            { "info", chain },
                        };
                    }
                }
                object firstChain = this.safeValue(chains, 0);
                ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                    { "info", chains },
                    { "code", code },
                    { "id", currencyId },
                    { "name", this.safeString(firstChain, "name") },
                    { "active", currencyActive },
                    { "deposit", depositEnabled },
                    { "withdraw", withdrawEnabled },
                    { "fee", null },
                    { "precision", this.parseNumber(maxPrecision) },
                    { "limits", new Dictionary<string, object>() {
                        { "amount", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                    } },
                    { "networks", networks },
                };
            }
            return result;
        }
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okcoin#fetchOrderBook
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-market-data-get-order-book
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        limit = ((bool) isTrue((isEqual(limit, null)))) ? 20 : limit;
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["sz"] = limit; // max 400
        }
        object response = await this.publicGetMarketBooks(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "asks": [
        //                     ["0.07228","4.211619","0","2"], // price, amount, liquidated orders, total open orders
        //                     ["0.0723","299.880364","0","2"],
        //                     ["0.07231","3.72832","0","1"],
        //                 ],
        //                 "bids": [
        //                     ["0.07221","18.5","0","1"],
        //                     ["0.0722","18.5","0","1"],
        //                     ["0.07219","0.505407","0","1"],
        //                 ],
        //                 "ts": "1621438475342"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object first = this.safeValue(data, 0, new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(first, "ts");
        return this.parseOrderBook(first, symbol, timestamp);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "instType": "SPOT",
        //         "instId": "ETH-BTC",
        //         "last": "0.07319",
        //         "lastSz": "0.044378",
        //         "askPx": "0.07322",
        //         "askSz": "4.2",
        //         "bidPx": "0.0732",
        //         "bidSz": "6.050058",
        //         "open24h": "0.07801",
        //         "high24h": "0.07975",
        //         "low24h": "0.06019",
        //         "volCcy24h": "11788.887619",
        //         "vol24h": "167493.829229",
        //         "ts": "1621440583784",
        //         "sodUtc0": "0.07872",
        //         "sodUtc8": "0.07345"
        //     }
        //
        object timestamp = this.safeInteger(ticker, "ts");
        object marketId = this.safeString(ticker, "instId");
        market = this.safeMarket(marketId, market, "-");
        object symbol = getValue(market, "symbol");
        object last = this.safeString(ticker, "last");
        object open = this.safeString(ticker, "open24h");
        object spot = this.safeBool(market, "spot", false);
        object quoteVolume = ((bool) isTrue(spot)) ? this.safeString(ticker, "volCcy24h") : null;
        object baseVolume = this.safeString(ticker, "vol24h");
        object high = this.safeString(ticker, "high24h");
        object low = this.safeString(ticker, "low24h");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", high },
            { "low", low },
            { "bid", this.safeString(ticker, "bidPx") },
            { "bidVolume", this.safeString(ticker, "bidSz") },
            { "ask", this.safeString(ticker, "askPx") },
            { "askVolume", this.safeString(ticker, "askSz") },
            { "vwap", null },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name okcoin#fetchTicker
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-market-data-get-ticker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object response = await this.publicGetMarketTicker(this.extend(request, parameters));
        object data = this.safeValue(response, "data", new List<object>() {});
        object first = this.safeValue(data, 0, new Dictionary<string, object>() {});
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "instType": "SPOT",
        //                 "instId": "ETH-BTC",
        //                 "last": "0.07319",
        //                 "lastSz": "0.044378",
        //                 "askPx": "0.07322",
        //                 "askSz": "4.2",
        //                 "bidPx": "0.0732",
        //                 "bidSz": "6.050058",
        //                 "open24h": "0.07801",
        //                 "high24h": "0.07975",
        //                 "low24h": "0.06019",
        //                 "volCcy24h": "11788.887619",
        //                 "vol24h": "167493.829229",
        //                 "ts": "1621440583784",
        //                 "sodUtc0": "0.07872",
        //                 "sodUtc8": "0.07345"
        //             }
        //         ]
        //     }
        //
        return this.parseTicker(first, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name okcoin#fetchTickers
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-market-data-get-tickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {
            { "instType", "SPOT" },
        };
        object response = await this.publicGetMarketTickers(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTickers(data, symbols, parameters);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public fetchTrades
        //
        //     {
        //         "instId": "ETH-BTC",
        //         "side": "sell",
        //         "sz": "0.119501",
        //         "px": "0.07065",
        //         "tradeId": "15826757",
        //         "ts": "1621446178316"
        //     }
        //
        // private fetchMyTrades
        //
        //     {
        //         "side": "buy",
        //         "fillSz": "0.007533",
        //         "fillPx": "2654.98",
        //         "fee": "-0.000007533",
        //         "ordId": "317321390244397056",
        //         "instType": "SPOT",
        //         "instId": "ETH-USDT",
        //         "clOrdId": "",
        //         "posSide": "net",
        //         "billId": "317321390265368576",
        //         "tag": "0",
        //         "execType": "T",
        //         "tradeId": "107601752",
        //         "feeCcy": "ETH",
        //         "ts": "1621927314985"
        //     }
        //
        object id = this.safeString(trade, "tradeId");
        object marketId = this.safeString(trade, "instId");
        market = this.safeMarket(marketId, market, "-");
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger(trade, "ts");
        object price = this.safeString2(trade, "fillPx", "px");
        object amount = this.safeString2(trade, "fillSz", "sz");
        object side = this.safeString(trade, "side");
        object orderId = this.safeString(trade, "ordId");
        object feeCostString = this.safeString(trade, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCostSigned = Precise.stringNeg(feeCostString);
            object feeCurrencyId = this.safeString(trade, "feeCcy");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCostSigned },
                { "currency", feeCurrencyCode },
            };
        }
        object takerOrMaker = this.safeString(trade, "execType");
        if (isTrue(isEqual(takerOrMaker, "T")))
        {
            takerOrMaker = "taker";
        } else if (isTrue(isEqual(takerOrMaker, "M")))
        {
            takerOrMaker = "maker";
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", id },
            { "order", orderId },
            { "type", null },
            { "takerOrMaker", takerOrMaker },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okcoin#fetchTrades
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-market-data-get-trades
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-market-data-get-trades-history
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(isTrue((isEqual(limit, null))) || isTrue((isGreaterThan(limit, 100)))))
        {
            limit = 100; // maximum = default = 100
        }
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object method = null;
        var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchTrades", "method", "publicGetMarketTrades");
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(method, "publicGetMarketTrades")))
        {
            response = await this.publicGetMarketTrades(this.extend(request, parameters));
        } else
        {
            response = await this.publicGetMarketHistoryTrades(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         "1678928760000", // timestamp
        //         "24341.4", // open
        //         "24344", // high
        //         "24313.2", // low
        //         "24323", // close
        //         "628", // contract volume
        //         "2.5819", // base volume
        //         "62800", // quote volume
        //         "0" // candlestick state
        //     ]
        //
        return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okcoin#fetchOHLCV
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-market-data-get-candlesticks
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-market-data-get-candlesticks-history
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object duration = this.parseTimeframe(timeframe);
        object options = this.safeValue(this.options, "fetchOHLCV", new Dictionary<string, object>() {});
        object bar = this.safeString(this.timeframes, timeframe, timeframe);
        object timezone = this.safeString(options, "timezone", "UTC");
        if (isTrue(isTrue((isEqual(timezone, "UTC"))) && isTrue((isGreaterThanOrEqual(duration, 21600)))))
        {
            bar = add(bar, ((string)timezone).ToLower());
        }
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "bar", bar },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 100
        }
        object method = null;
        var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "method", "publicGetMarketCandles");
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(method, "publicGetMarketCandles")))
        {
            response = await this.publicGetMarketCandles(this.extend(request, parameters));
        } else
        {
            response = await this.publicGetMarketHistoryCandles(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public virtual object parseAccountBalance(object response)
    {
        //
        // account
        //
        //     [
        //         {
        //             "balance":  0,
        //             "available":  0,
        //             "currency": "BTC",
        //             "hold":  0
        //         },
        //         {
        //             "balance":  0,
        //             "available":  0,
        //             "currency": "ETH",
        //             "hold":  0
        //         }
        //     ]
        //
        // spot
        //
        //     [
        //         {
        //             "frozen": "0",
        //             "hold": "0",
        //             "id": "2149632",
        //             "currency": "BTC",
        //             "balance": "0.0000000497717339",
        //             "available": "0.0000000497717339",
        //             "holds": "0"
        //         },
        //         {
        //             "frozen": "0",
        //             "hold": "0",
        //             "id": "2149632",
        //             "currency": "ICN",
        //             "balance": "0.00000000925",
        //             "available": "0.00000000925",
        //             "holds": "0"
        //         }
        //     ]
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object balance = getValue(response, i);
            object currencyId = this.safeString(balance, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "balance");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "hold");
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "available");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name okcoin#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(isEqual(marketType, "funding")))
        {
            response = await this.privateGetAssetBalances(this.extend(request, query));
        } else
        {
            response = await this.privateGetAccountBalance(this.extend(request, query));
        }
        //
        //  {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "category": "1",
        //                 "delivery": "",
        //                 "exercise": "",
        //                 "instType": "SPOT",
        //                 "level": "Lv1",
        //                 "maker": "-0.0008",
        //                 "taker": "-0.001",
        //                 "ts": "1639043138472"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        if (isTrue(isEqual(marketType, "funding")))
        {
            return this.parseFundingBalance(response);
        } else
        {
            return this.parseTradingBalance(response);
        }
    }

    public virtual object parseTradingBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object data = this.safeValue(response, "data", new List<object>() {});
        object first = this.safeValue(data, 0, new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(first, "uTime");
        object details = this.safeValue(first, "details", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(details)); postFixIncrement(ref i))
        {
            object balance = getValue(details, i);
            object currencyId = this.safeString(balance, "ccy");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            // it may be incorrect to use total, free and used for swap accounts
            object eq = this.safeString(balance, "eq");
            object availEq = this.safeString(balance, "availEq");
            if (isTrue(isTrue((isEqual(eq, null))) || isTrue((isEqual(availEq, null)))))
            {
                ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "availBal");
                ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "frozenBal");
            } else
            {
                ((IDictionary<string,object>)account)["total"] = eq;
                ((IDictionary<string,object>)account)["free"] = availEq;
            }
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        ((IDictionary<string,object>)result)["timestamp"] = timestamp;
        ((IDictionary<string,object>)result)["datetime"] = this.iso8601(timestamp);
        return this.safeBalance(result);
    }

    public virtual object parseFundingBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object data = this.safeValue(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object balance = getValue(data, i);
            object currencyId = this.safeString(balance, "ccy");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            // it may be incorrect to use total, free and used for swap accounts
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "bal");
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "availBal");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "frozenBal");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        /**
        * @method
        * @name okcoin#createMarketBuyOrderWithCost
        * @description create a market buy order by providing the symbol and cost
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-place-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {float} cost how much you want to trade in units of the quote currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
        }
        ((IDictionary<string,object>)parameters)["createMarketBuyOrderRequiresPrice"] = false;
        ((IDictionary<string,object>)parameters)["tgtCcy"] = "quote_ccy";
        return await this.createOrder(symbol, "market", "buy", cost, null, parameters);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name okcoin#createOrder
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-place-order
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-place-algo-order
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-place-multiple-orders
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-cancel-advance-algo-order
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {bool} [params.reduceOnly] MARGIN orders only, or swap/future orders in net mode
        * @param {bool} [params.postOnly] true to place a post only order
        * @param {float} [params.triggerPrice] conditional orders only, the price at which the order is to be triggered
        * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
        * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
        * @param {float} [params.takeProfit.price] used for take profit limit orders, not used for take profit market price orders
        * @param {string} [params.takeProfit.type] 'market' or 'limit' used to specify the take profit price type
        * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
        * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
        * @param {float} [params.stopLoss.price] used for stop loss limit orders, not used for stop loss market price orders
        * @param {string} [params.stopLoss.type] 'market' or 'limit' used to specify the stop loss price type
        * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object method = this.safeString(this.options, "createOrder", "privatePostTradeBatchOrders");
        object requestOrdType = this.safeString(request, "ordType");
        if (isTrue(isTrue(isTrue(isTrue(isTrue(isTrue((isEqual(requestOrdType, "trigger"))) || isTrue((isEqual(requestOrdType, "conditional")))) || isTrue((isEqual(type, "oco")))) || isTrue((isEqual(type, "move_order_stop")))) || isTrue((isEqual(type, "iceberg")))) || isTrue((isEqual(type, "twap")))))
        {
            method = "privatePostTradeOrderAlgo";
        }
        if (isTrue(isEqual(method, "privatePostTradeBatchOrders")))
        {
            // keep the request body the same
            // submit a single order in an array to the batch order endpoint
            // because it has a lower ratelimit
            request = new List<object>() {request};
        }
        object response = null;
        if (isTrue(isEqual(method, "privatePostTradeOrder")))
        {
            response = await this.privatePostTradeOrder(request);
        } else if (isTrue(isEqual(method, "privatePostTradeOrderAlgo")))
        {
            response = await this.privatePostTradeOrderAlgo(request);
        } else if (isTrue(isEqual(method, "privatePostTradeBatchOrders")))
        {
            response = await this.privatePostTradeBatchOrders(request);
        } else
        {
            throw new ExchangeError ((string)add(this.id, " createOrder() this.options[\"createOrder\"] must be either privatePostTradeBatchOrders or privatePostTradeOrder or privatePostTradeOrderAlgo")) ;
        }
        object data = this.safeValue(response, "data", new List<object>() {});
        object first = this.safeValue(data, 0);
        object order = this.parseOrder(first, market);
        ((IDictionary<string,object>)order)["type"] = type;
        ((IDictionary<string,object>)order)["side"] = side;
        return order;
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "side", side },
            { "ordType", type },
        };
        object triggerPrice = this.safeValueN(parameters, new List<object>() {"triggerPrice", "stopPrice", "triggerPx"});
        object timeInForce = this.safeString(parameters, "timeInForce", "GTC");
        object takeProfitPrice = this.safeValue2(parameters, "takeProfitPrice", "tpTriggerPx");
        object tpOrdPx = this.safeValue(parameters, "tpOrdPx", price);
        object tpTriggerPxType = this.safeString(parameters, "tpTriggerPxType", "last");
        object stopLossPrice = this.safeValue2(parameters, "stopLossPrice", "slTriggerPx");
        object slOrdPx = this.safeValue(parameters, "slOrdPx", price);
        object slTriggerPxType = this.safeString(parameters, "slTriggerPxType", "last");
        object clientOrderId = this.safeString2(parameters, "clOrdId", "clientOrderId");
        object stopLoss = this.safeValue(parameters, "stopLoss");
        object stopLossDefined = (!isEqual(stopLoss, null));
        object takeProfit = this.safeValue(parameters, "takeProfit");
        object takeProfitDefined = (!isEqual(takeProfit, null));
        object defaultMarginMode = this.safeString2(this.options, "defaultMarginMode", "marginMode", "cross");
        object marginMode = this.safeString2(parameters, "marginMode", "tdMode"); // cross or isolated, tdMode not ommited so as to be extended into the request
        object margin = false;
        if (isTrue(isTrue((!isEqual(marginMode, null))) && isTrue((!isEqual(marginMode, "cash")))))
        {
            margin = true;
        } else
        {
            marginMode = defaultMarginMode;
            margin = this.safeBool(parameters, "margin", false);
        }
        if (isTrue(margin))
        {
            object defaultCurrency = ((bool) isTrue((isEqual(side, "buy")))) ? getValue(market, "quote") : getValue(market, "base");
            object currency = this.safeString(parameters, "ccy", defaultCurrency);
            ((IDictionary<string,object>)request)["ccy"] = this.safeCurrencyCode(currency);
        }
        object tradeMode = ((bool) isTrue(margin)) ? marginMode : "cash";
        ((IDictionary<string,object>)request)["tdMode"] = tradeMode;
        object isMarketOrder = isEqual(type, "market");
        object postOnly = false;
        var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, isEqual(type, "post_only"), parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        parameters = this.omit(parameters, new List<object>() {"currency", "ccy", "marginMode", "timeInForce", "stopPrice", "triggerPrice", "clientOrderId", "stopLossPrice", "takeProfitPrice", "slOrdPx", "tpOrdPx", "margin", "stopLoss", "takeProfit"});
        object ioc = isTrue((isEqual(timeInForce, "IOC"))) || isTrue((isEqual(type, "ioc")));
        object fok = isTrue((isEqual(timeInForce, "FOK"))) || isTrue((isEqual(type, "fok")));
        object trigger = isTrue((!isEqual(triggerPrice, null))) || isTrue((isEqual(type, "trigger")));
        object conditional = isTrue(isTrue((!isEqual(stopLossPrice, null))) || isTrue((!isEqual(takeProfitPrice, null)))) || isTrue((isEqual(type, "conditional")));
        object marketIOC = isTrue((isTrue(isMarketOrder) && isTrue(ioc))) || isTrue((isEqual(type, "optimal_limit_ioc")));
        object defaultTgtCcy = this.safeString(this.options, "tgtCcy", "base_ccy");
        object tgtCcy = this.safeString(parameters, "tgtCcy", defaultTgtCcy);
        if (isTrue((!isTrue(margin))))
        {
            ((IDictionary<string,object>)request)["tgtCcy"] = tgtCcy;
        }
        if (isTrue(isTrue(isMarketOrder) || isTrue(marketIOC)))
        {
            ((IDictionary<string,object>)request)["ordType"] = "market";
            if (isTrue(isEqual(side, "buy")))
            {
                // spot market buy: "sz" can refer either to base currency units or to quote currency units
                // see documentation: https://www.okx.com/docs-v5/en/#rest-api-trade-place-order
                if (isTrue(isEqual(tgtCcy, "quote_ccy")))
                {
                    // quote_ccy: sz refers to units of quote currency
                    object quoteAmount = null;
                    object createMarketBuyOrderRequiresPrice = true;
                    var createMarketBuyOrderRequiresPriceparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                    createMarketBuyOrderRequiresPrice = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[0];
                    parameters = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[1];
                    object cost = this.safeNumber2(parameters, "cost", "sz");
                    parameters = this.omit(parameters, new List<object>() {"cost", "sz"});
                    if (isTrue(!isEqual(cost, null)))
                    {
                        quoteAmount = this.costToPrecision(symbol, cost);
                    } else if (isTrue(createMarketBuyOrderRequiresPrice))
                    {
                        if (isTrue(isEqual(price, null)))
                        {
                            throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument")) ;
                        } else
                        {
                            object amountString = this.numberToString(amount);
                            object priceString = this.numberToString(price);
                            object costRequest = Precise.stringMul(amountString, priceString);
                            quoteAmount = this.costToPrecision(symbol, costRequest);
                        }
                    } else
                    {
                        quoteAmount = this.costToPrecision(symbol, amount);
                    }
                    ((IDictionary<string,object>)request)["sz"] = quoteAmount;
                } else
                {
                    ((IDictionary<string,object>)request)["sz"] = this.amountToPrecision(symbol, amount);
                }
            } else
            {
                ((IDictionary<string,object>)request)["sz"] = this.amountToPrecision(symbol, amount);
            }
        } else
        {
            ((IDictionary<string,object>)request)["sz"] = this.amountToPrecision(symbol, amount);
            if (isTrue(isTrue((!isTrue(trigger))) && isTrue((!isTrue(conditional)))))
            {
                ((IDictionary<string,object>)request)["px"] = this.priceToPrecision(symbol, price);
            }
        }
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["ordType"] = "post_only";
        } else if (isTrue(isTrue(ioc) && !isTrue(marketIOC)))
        {
            ((IDictionary<string,object>)request)["ordType"] = "ioc";
        } else if (isTrue(fok))
        {
            ((IDictionary<string,object>)request)["ordType"] = "fok";
        } else if (isTrue(isTrue(stopLossDefined) || isTrue(takeProfitDefined)))
        {
            if (isTrue(stopLossDefined))
            {
                object stopLossTriggerPrice = this.safeValueN(stopLoss, new List<object>() {"triggerPrice", "stopPrice", "slTriggerPx"});
                if (isTrue(isEqual(stopLossTriggerPrice, null)))
                {
                    throw new InvalidOrder ((string)add(this.id, " createOrder() requires a trigger price in params[\"stopLoss\"][\"triggerPrice\"], or params[\"stopLoss\"][\"stopPrice\"], or params[\"stopLoss\"][\"slTriggerPx\"] for a stop loss order")) ;
                }
                ((IDictionary<string,object>)request)["slTriggerPx"] = this.priceToPrecision(symbol, stopLossTriggerPrice);
                object stopLossLimitPrice = this.safeValueN(stopLoss, new List<object>() {"price", "stopLossPrice", "slOrdPx"});
                object stopLossOrderType = this.safeString(stopLoss, "type");
                if (isTrue(!isEqual(stopLossOrderType, null)))
                {
                    object stopLossLimitOrderType = (isEqual(stopLossOrderType, "limit"));
                    object stopLossMarketOrderType = (isEqual(stopLossOrderType, "market"));
                    if (isTrue(isTrue((!isTrue(stopLossLimitOrderType))) && isTrue((!isTrue(stopLossMarketOrderType)))))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() params[\"stopLoss\"][\"type\"] must be either \"limit\" or \"market\"")) ;
                    } else if (isTrue(stopLossLimitOrderType))
                    {
                        if (isTrue(isEqual(stopLossLimitPrice, null)))
                        {
                            throw new InvalidOrder ((string)add(this.id, " createOrder() requires a limit price in params[\"stopLoss\"][\"price\"] or params[\"stopLoss\"][\"slOrdPx\"] for a stop loss limit order")) ;
                        } else
                        {
                            ((IDictionary<string,object>)request)["slOrdPx"] = this.priceToPrecision(symbol, stopLossLimitPrice);
                        }
                    } else if (isTrue(isEqual(stopLossOrderType, "market")))
                    {
                        ((IDictionary<string,object>)request)["slOrdPx"] = "-1";
                    }
                } else if (isTrue(!isEqual(stopLossLimitPrice, null)))
                {
                    ((IDictionary<string,object>)request)["slOrdPx"] = this.priceToPrecision(symbol, stopLossLimitPrice); // limit sl order
                } else
                {
                    ((IDictionary<string,object>)request)["slOrdPx"] = "-1"; // market sl order
                }
                object stopLossTriggerPriceType = this.safeString2(stopLoss, "triggerPriceType", "slTriggerPxType", "last");
                if (isTrue(!isEqual(stopLossTriggerPriceType, null)))
                {
                    if (isTrue(isTrue(isTrue((!isEqual(stopLossTriggerPriceType, "last"))) && isTrue((!isEqual(stopLossTriggerPriceType, "index")))) && isTrue((!isEqual(stopLossTriggerPriceType, "mark")))))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() stop loss trigger price type must be one of \"last\", \"index\" or \"mark\"")) ;
                    }
                    ((IDictionary<string,object>)request)["slTriggerPxType"] = stopLossTriggerPriceType;
                }
            }
            if (isTrue(takeProfitDefined))
            {
                object takeProfitTriggerPrice = this.safeValueN(takeProfit, new List<object>() {"triggerPrice", "stopPrice", "tpTriggerPx"});
                if (isTrue(isEqual(takeProfitTriggerPrice, null)))
                {
                    throw new InvalidOrder ((string)add(this.id, " createOrder() requires a trigger price in params[\"takeProfit\"][\"triggerPrice\"], or params[\"takeProfit\"][\"stopPrice\"], or params[\"takeProfit\"][\"tpTriggerPx\"] for a take profit order")) ;
                }
                ((IDictionary<string,object>)request)["tpTriggerPx"] = this.priceToPrecision(symbol, takeProfitTriggerPrice);
                object takeProfitLimitPrice = this.safeValueN(takeProfit, new List<object>() {"price", "takeProfitPrice", "tpOrdPx"});
                object takeProfitOrderType = this.safeString(takeProfit, "type");
                if (isTrue(!isEqual(takeProfitOrderType, null)))
                {
                    object takeProfitLimitOrderType = (isEqual(takeProfitOrderType, "limit"));
                    object takeProfitMarketOrderType = (isEqual(takeProfitOrderType, "market"));
                    if (isTrue(isTrue((!isTrue(takeProfitLimitOrderType))) && isTrue((!isTrue(takeProfitMarketOrderType)))))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() params[\"takeProfit\"][\"type\"] must be either \"limit\" or \"market\"")) ;
                    } else if (isTrue(takeProfitLimitOrderType))
                    {
                        if (isTrue(isEqual(takeProfitLimitPrice, null)))
                        {
                            throw new InvalidOrder ((string)add(this.id, " createOrder() requires a limit price in params[\"takeProfit\"][\"price\"] or params[\"takeProfit\"][\"tpOrdPx\"] for a take profit limit order")) ;
                        } else
                        {
                            ((IDictionary<string,object>)request)["tpOrdPx"] = this.priceToPrecision(symbol, takeProfitLimitPrice);
                        }
                    } else if (isTrue(isEqual(takeProfitOrderType, "market")))
                    {
                        ((IDictionary<string,object>)request)["tpOrdPx"] = "-1";
                    }
                } else if (isTrue(!isEqual(takeProfitLimitPrice, null)))
                {
                    ((IDictionary<string,object>)request)["tpOrdPx"] = this.priceToPrecision(symbol, takeProfitLimitPrice); // limit tp order
                } else
                {
                    ((IDictionary<string,object>)request)["tpOrdPx"] = "-1"; // market tp order
                }
                object takeProfitTriggerPriceType = this.safeString2(takeProfit, "triggerPriceType", "tpTriggerPxType", "last");
                if (isTrue(!isEqual(takeProfitTriggerPriceType, null)))
                {
                    if (isTrue(isTrue(isTrue((!isEqual(takeProfitTriggerPriceType, "last"))) && isTrue((!isEqual(takeProfitTriggerPriceType, "index")))) && isTrue((!isEqual(takeProfitTriggerPriceType, "mark")))))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() take profit trigger price type must be one of \"last\", \"index\" or \"mark\"")) ;
                    }
                    ((IDictionary<string,object>)request)["tpTriggerPxType"] = takeProfitTriggerPriceType;
                }
            }
        } else if (isTrue(trigger))
        {
            ((IDictionary<string,object>)request)["ordType"] = "trigger";
            ((IDictionary<string,object>)request)["triggerPx"] = this.priceToPrecision(symbol, triggerPrice);
            ((IDictionary<string,object>)request)["orderPx"] = ((bool) isTrue(isMarketOrder)) ? "-1" : this.priceToPrecision(symbol, price);
        } else if (isTrue(conditional))
        {
            ((IDictionary<string,object>)request)["ordType"] = "conditional";
            object twoWayCondition = (isTrue((!isEqual(takeProfitPrice, null))) && isTrue((!isEqual(stopLossPrice, null))));
            // if TP and SL are sent together
            // as ordType 'conditional' only stop-loss order will be applied
            if (isTrue(twoWayCondition))
            {
                ((IDictionary<string,object>)request)["ordType"] = "oco";
            }
            if (isTrue(!isEqual(takeProfitPrice, null)))
            {
                ((IDictionary<string,object>)request)["tpTriggerPx"] = this.priceToPrecision(symbol, takeProfitPrice);
                ((IDictionary<string,object>)request)["tpOrdPx"] = ((bool) isTrue((isEqual(tpOrdPx, null)))) ? "-1" : this.priceToPrecision(symbol, tpOrdPx);
                ((IDictionary<string,object>)request)["tpTriggerPxType"] = tpTriggerPxType;
            }
            if (isTrue(!isEqual(stopLossPrice, null)))
            {
                ((IDictionary<string,object>)request)["slTriggerPx"] = this.priceToPrecision(symbol, stopLossPrice);
                ((IDictionary<string,object>)request)["slOrdPx"] = ((bool) isTrue((isEqual(slOrdPx, null)))) ? "-1" : this.priceToPrecision(symbol, slOrdPx);
                ((IDictionary<string,object>)request)["slTriggerPxType"] = slTriggerPxType;
            }
        }
        if (isTrue(isEqual(clientOrderId, null)))
        {
            object brokerId = this.safeString(this.options, "brokerId");
            if (isTrue(!isEqual(brokerId, null)))
            {
                ((IDictionary<string,object>)request)["clOrdId"] = add(brokerId, this.uuid16());
                ((IDictionary<string,object>)request)["tag"] = brokerId;
            }
        } else
        {
            ((IDictionary<string,object>)request)["clOrdId"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"clOrdId", "clientOrderId"});
        }
        return this.extend(request, parameters);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name okcoin#cancelOrder
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-cancel-order
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-cancel-algo-order
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-cancel-advance-algo-order
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {bool} [params.stop] True if cancel trigger or conditional orders
        * @param {bool} [params.advanced] True if canceling advanced orders only
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object stop = this.safeValue2(parameters, "stop", "trigger");
        object advanced = this.safeValue(parameters, "advanced");
        if (isTrue(isTrue(stop) || isTrue(advanced)))
        {
            object orderInner = await this.cancelOrders(new List<object>() {id}, symbol, parameters);
            return this.safeValue(orderInner, 0);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object clientOrderId = this.safeString2(parameters, "clOrdId", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clOrdId"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["ordId"] = ((object)id).ToString();
        }
        object query = this.omit(parameters, new List<object>() {"clOrdId", "clientOrderId"});
        object response = await this.privatePostTradeCancelOrder(this.extend(request, query));
        // {"code":"0","data":[{"clOrdId":"","ordId":"317251910906576896","sCode":"0","sMsg":""}],"msg":""}
        object data = this.safeValue(response, "data", new List<object>() {});
        object order = this.safeDict(data, 0);
        return this.parseOrder(order, market);
    }

    public virtual object parseIds(object ids)
    {
        /**
         * @ignore
         * @method
         * @name okx#parseIds
         * @param {string[]|string} ids order ids
         * @returns {string[]} list of order ids
         */
        if (isTrue((ids is string)))
        {
            return ((string)ids).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
        } else
        {
            return ids;
        }
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name okcoin#cancelOrders
        * @description cancel multiple orders
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-cancel-multiple-orders
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-cancel-algo-order
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-cancel-advance-algo-order
        * @param {string[]} ids order ids
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object stop = this.safeValue2(parameters, "stop", "trigger");
        object advanced = this.safeValue(parameters, "advanced");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger", "advanced"});
        object market = this.market(symbol);
        object request = new List<object>() {};
        object clientOrderIds = this.parseIds(this.safeValue2(parameters, "clOrdId", "clientOrderId"));
        object algoIds = this.parseIds(this.safeValue(parameters, "algoId"));
        if (isTrue(isEqual(clientOrderIds, null)))
        {
            ids = this.parseIds(ids);
            if (isTrue(!isEqual(algoIds, null)))
            {
                for (object i = 0; isLessThan(i, getArrayLength(algoIds)); postFixIncrement(ref i))
                {
                    ((IList<object>)request).Add(new Dictionary<string, object>() {
                        { "algoId", getValue(algoIds, i) },
                        { "instId", getValue(market, "id") },
                    });
                }
            }
            for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
            {
                if (isTrue(isTrue(stop) || isTrue(advanced)))
                {
                    ((IList<object>)request).Add(new Dictionary<string, object>() {
                        { "algoId", getValue(ids, i) },
                        { "instId", getValue(market, "id") },
                    });
                } else
                {
                    ((IList<object>)request).Add(new Dictionary<string, object>() {
                        { "ordId", getValue(ids, i) },
                        { "instId", getValue(market, "id") },
                    });
                }
            }
        } else
        {
            for (object i = 0; isLessThan(i, getArrayLength(clientOrderIds)); postFixIncrement(ref i))
            {
                ((IList<object>)request).Add(new Dictionary<string, object>() {
                    { "instId", getValue(market, "id") },
                    { "clOrdId", getValue(clientOrderIds, i) },
                });
            }
        }
        object response = null;
        if (isTrue(stop))
        {
            response = await this.privatePostTradeCancelAlgos(request);
        } else if (isTrue(advanced))
        {
            response = await this.privatePostTradeCancelAdvanceAlgos(request);
        } else
        {
            response = await this.privatePostTradeCancelBatchOrders(request); // * dont extend with params, otherwise ARRAY will be turned into OBJECT
        }
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "clOrdId": "e123456789ec4dBC1123456ba123b45e",
        //                 "ordId": "405071912345641543",
        //                 "sCode": "0",
        //                 "sMsg": ""
        //             },
        //             ...
        //         ],
        //         "msg": ""
        //     }
        //
        //
        object ordersData = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(ordersData, market, null, null, parameters);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "canceled", "canceled" },
            { "live", "open" },
            { "partially_filled", "open" },
            { "filled", "closed" },
            { "effective", "closed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //
        //     {
        //         "clOrdId": "oktswap6",
        //         "ordId": "312269865356374016",
        //         "tag": "",
        //         "sCode": "0",
        //         "sMsg": ""
        //     }
        //
        // editOrder
        //
        //     {
        //         "clOrdId": "e847386590ce4dBCc1a045253497a547",
        //         "ordId": "559176536793178112",
        //         "reqId": "",
        //         "sCode": "0",
        //         "sMsg": ""
        //     }
        //
        // Spot and Swap fetchOrder, fetchOpenOrders
        //
        //     {
        //         "accFillSz": "0",
        //         "avgPx": "",
        //         "cTime": "1621910749815",
        //         "category": "normal",
        //         "ccy": "",
        //         "clOrdId": "",
        //         "fee": "0",
        //         "feeCcy": "ETH",
        //         "fillPx": "",
        //         "fillSz": "0",
        //         "fillTime": "",
        //         "instId": "ETH-USDT",
        //         "instType": "SPOT",
        //         "lever": "",
        //         "ordId": "317251910906576896",
        //         "ordType": "limit",
        //         "pnl": "0",
        //         "posSide": "net",
        //         "px": "2000",
        //         "rebate": "0",
        //         "rebateCcy": "USDT",
        //         "side": "buy",
        //         "slOrdPx": "",
        //         "slTriggerPx": "",
        //         "state": "live",
        //         "sz": "0.001",
        //         "tag": "",
        //         "tdMode": "cash",
        //         "tpOrdPx": "",
        //         "tpTriggerPx": "",
        //         "tradeId": "",
        //         "uTime": "1621910749815"
        //     }
        //
        // Algo Order fetchOpenOrders, fetchCanceledOrders, fetchClosedOrders
        //
        //     {
        //         "activePx": "",
        //         "activePxType": "",
        //         "actualPx": "",
        //         "actualSide": "buy",
        //         "actualSz": "0",
        //         "algoId": "431375349042380800",
        //         "cTime": "1649119897778",
        //         "callbackRatio": "",
        //         "callbackSpread": "",
        //         "ccy": "",
        //         "ctVal": "0.01",
        //         "instId": "BTC-USDT-SWAP",
        //         "instType": "SWAP",
        //         "last": "46538.9",
        //         "lever": "125",
        //         "moveTriggerPx": "",
        //         "notionalUsd": "467.059",
        //         "ordId": "",
        //         "ordPx": "50000",
        //         "ordType": "trigger",
        //         "posSide": "long",
        //         "pxLimit": "",
        //         "pxSpread": "",
        //         "pxVar": "",
        //         "side": "buy",
        //         "slOrdPx": "",
        //         "slTriggerPx": "",
        //         "slTriggerPxType": "",
        //         "state": "live",
        //         "sz": "1",
        //         "szLimit": "",
        //         "tag": "",
        //         "tdMode": "isolated",
        //         "tgtCcy": "",
        //         "timeInterval": "",
        //         "tpOrdPx": "",
        //         "tpTriggerPx": "",
        //         "tpTriggerPxType": "",
        //         "triggerPx": "50000",
        //         "triggerPxType": "last",
        //         "triggerTime": "",
        //         "uly": "BTC-USDT"
        //     }
        //
        object id = this.safeString2(order, "algoId", "ordId");
        object timestamp = this.safeInteger(order, "cTime");
        object lastUpdateTimestamp = this.safeInteger(order, "uTime");
        object lastTradeTimestamp = this.safeInteger(order, "fillTime");
        object side = this.safeString(order, "side");
        object type = this.safeString(order, "ordType");
        object postOnly = null;
        object timeInForce = null;
        if (isTrue(isEqual(type, "post_only")))
        {
            postOnly = true;
            type = "limit";
        } else if (isTrue(isEqual(type, "fok")))
        {
            timeInForce = "FOK";
            type = "limit";
        } else if (isTrue(isEqual(type, "ioc")))
        {
            timeInForce = "IOC";
            type = "limit";
        }
        object marketId = this.safeString(order, "instId");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeSymbol(marketId, market, "-");
        object filled = this.safeString(order, "accFillSz");
        object price = this.safeString2(order, "px", "ordPx");
        object average = this.safeString(order, "avgPx");
        object status = this.parseOrderStatus(this.safeString(order, "state"));
        object feeCostString = this.safeString(order, "fee");
        object amount = null;
        object cost = null;
        // spot market buy: "sz" can refer either to base currency units or to quote currency units
        // see documentation: https://www.okx.com/docs-v5/en/#rest-api-trade-place-order
        object defaultTgtCcy = this.safeString(this.options, "tgtCcy", "base_ccy");
        object tgtCcy = this.safeString(order, "tgtCcy", defaultTgtCcy);
        if (isTrue(isTrue(isTrue((isEqual(side, "buy"))) && isTrue((isEqual(type, "market")))) && isTrue((isEqual(tgtCcy, "quote_ccy")))))
        {
            // "sz" refers to the cost
            cost = this.safeString(order, "sz");
        } else
        {
            // "sz" refers to the trade currency amount
            amount = this.safeString(order, "sz");
        }
        object fee = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCostSigned = Precise.stringNeg(feeCostString);
            object feeCurrencyId = this.safeString(order, "feeCcy");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(feeCostSigned) },
                { "currency", feeCurrencyCode },
            };
        }
        object clientOrderId = this.safeString(order, "clOrdId");
        if (isTrue(isTrue((!isEqual(clientOrderId, null))) && isTrue((isLessThan(((string)clientOrderId).Length, 1)))))
        {
            clientOrderId = null; // fix empty clientOrderId string
        }
        object stopLossPrice = this.safeNumber2(order, "slTriggerPx", "slOrdPx");
        object takeProfitPrice = this.safeNumber2(order, "tpTriggerPx", "tpOrdPx");
        object stopPrice = this.safeNumberN(order, new List<object>() {"triggerPx", "moveTriggerPx"});
        object reduceOnlyRaw = this.safeString(order, "reduceOnly");
        object reduceOnly = false;
        if (isTrue(!isEqual(reduceOnly, null)))
        {
            reduceOnly = (isEqual(reduceOnlyRaw, "true"));
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "lastUpdateTimestamp", lastUpdateTimestamp },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "side", side },
            { "price", price },
            { "stopLossPrice", stopLossPrice },
            { "takeProfitPrice", takeProfitPrice },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "average", average },
            { "cost", cost },
            { "amount", amount },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", fee },
            { "trades", null },
            { "reduceOnly", reduceOnly },
        }, market);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name okcoin#fetchOrder
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-get-order-details
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-get-algo-order-list
        * @description fetches information on an order made by the user
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object clientOrderId = this.safeString2(parameters, "clOrdId", "clientOrderId");
        object stop = this.safeValue2(parameters, "stop", "trigger");
        if (isTrue(stop))
        {
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["algoClOrdId"] = clientOrderId;
            } else
            {
                ((IDictionary<string,object>)request)["algoId"] = id;
            }
        } else
        {
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["clOrdId"] = clientOrderId;
            } else
            {
                ((IDictionary<string,object>)request)["ordId"] = id;
            }
        }
        object query = this.omit(parameters, new List<object>() {"clientOrderId", "stop", "trigger"});
        object response = null;
        if (isTrue(stop))
        {
            response = await this.privateGetTradeOrderAlgo(this.extend(request, query));
        } else
        {
            response = await this.privateGetTradeOrder(this.extend(request, query));
        }
        object data = this.safeValue(response, "data", new List<object>() {});
        object order = this.safeDict(data, 0);
        return this.parseOrder(order);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okcoin#fetchOpenOrders
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-get-order-list
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-get-algo-order-list
        * @description fetch all unfilled currently open orders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {bool} [params.stop] True if fetching trigger or conditional orders
        * @param {string} [params.ordType] "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instId"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 100
        }
        object ordType = this.safeString(parameters, "ordType");
        object stop = isTrue(this.safeValue(parameters, "stop")) || isTrue((!isEqual(this.safeString(parameters, "ordType"), null)));
        if (isTrue(isTrue(stop) && isTrue((isEqual(ordType, null)))))
        {
            ((IDictionary<string,object>)request)["ordType"] = "trigger"; // default to trigger
        }
        parameters = this.omit(parameters, new List<object>() {"stop"});
        object response = null;
        if (isTrue(stop))
        {
            response = await this.privateGetTradeOrdersAlgoPending(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetTradeOrdersPending(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okcoin#fetchClosedOrders
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-get-algo-order-history
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-get-order-history-last-3-months
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-get-order-history-last-7-days
        * @description fetches information on multiple closed orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {bool} [params.stop] True if fetching trigger or conditional orders
        * @param {string} [params.ordType] "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "instType", "SPOT" },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instId"] = getValue(market, "id");
        }
        object ordType = this.safeString(parameters, "ordType");
        object stop = isTrue(this.safeValue(parameters, "stop")) || isTrue((!isEqual(this.safeString(parameters, "ordType"), null)));
        if (isTrue(isTrue(stop) && isTrue((isEqual(ordType, null)))))
        {
            ((IDictionary<string,object>)request)["ordType"] = "trigger"; // default to trigger
        }
        parameters = this.omit(parameters, new List<object>() {"stop"});
        object response = null;
        if (isTrue(stop))
        {
            response = await this.privateGetTradeOrdersAlgoHistory(this.extend(request, parameters));
        } else
        {
            object method = null;
            var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchClosedOrders", "method", "privateGetTradeOrdersHistory");
            method = ((IList<object>)methodparametersVariable)[0];
            parameters = ((IList<object>)methodparametersVariable)[1];
            if (isTrue(isEqual(method, "privateGetTradeOrdersHistory")))
            {
                response = await this.privateGetTradeOrdersHistory(this.extend(request, parameters));
            } else
            {
                response = await this.privateGetTradeOrdersHistoryArchive(this.extend(request, parameters));
            }
        }
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "accFillSz": "0",
        //                 "avgPx": "",
        //                 "cTime": "1621910749815",
        //                 "category": "normal",
        //                 "ccy": "",
        //                 "clOrdId": "",
        //                 "fee": "0",
        //                 "feeCcy": "ETH",
        //                 "fillPx": "",
        //                 "fillSz": "0",
        //                 "fillTime": "",
        //                 "instId": "ETH-USDT",
        //                 "instType": "SPOT",
        //                 "lever": "",
        //                 "ordId": "317251910906576896",
        //                 "ordType": "limit",
        //                 "pnl": "0",
        //                 "posSide": "net",
        //                 "px":"20 00",
        //                 "rebate": "0",
        //                 "rebateCcy": "USDT",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "state": "live",
        //                 "sz":"0. 001",
        //                 "tag": "",
        //                 "tdMode": "cash",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tradeId": "",
        //                 "uTime": "1621910749815"
        //             }
        //         ],
        //         "msg":""
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "addr": "okbtothemoon",
        //         "memo": "971668", // may be missing
        //         "tag":"52055", // may be missing
        //         "pmtId": "", // may be missing
        //         "ccy": "BTC",
        //         "to": "6", // 1 SPOT, 3 FUTURES, 6 FUNDING, 9 SWAP, 12 OPTION, 18 Unified account
        //         "selected": true
        //     }
        //
        //     {
        //         "ccy":"usdt-erc20",
        //         "to":"6",
        //         "addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa",
        //         "selected":true
        //     }
        //
        //     {
        //        "chain": "ETH-OKExChain",
        //        "addrEx": { "comment": "6040348" }, // some currencies like TON may have this field,
        //        "ctAddr": "72315c",
        //        "ccy": "ETH",
        //        "to": "6",
        //        "addr": "0x1c9f2244d1ccaa060bd536827c18925db10db102",
        //        "selected": true
        //     }
        //
        object address = this.safeString(depositAddress, "addr");
        object tag = this.safeStringN(depositAddress, new List<object>() {"tag", "pmtId", "memo"});
        if (isTrue(isEqual(tag, null)))
        {
            object addrEx = this.safeValue(depositAddress, "addrEx", new Dictionary<string, object>() {});
            tag = this.safeString(addrEx, "comment");
        }
        object currencyId = this.safeString(depositAddress, "ccy");
        currency = this.safeCurrency(currencyId, currency);
        object code = getValue(currency, "code");
        object chain = this.safeString(depositAddress, "chain");
        object networkId = ((string)chain).Replace((string)add(currencyId, "-"), (string)"");
        object network = this.networkIdToCode(networkId);
        // inconsistent naming responses from exchange
        // with respect to network naming provided in currency info vs address chain-names and ids
        //
        // response from address endpoint:
        //      {
        //          "chain": "USDT-Polygon",
        //          "ctAddr": "",
        //          "ccy": "USDT",
        //          "to":"6" ,
        //          "addr": "0x1903441e386cc49d937f6302955b5feb4286dcfa",
        //          "selected": true
        //      }
        // network information from currency['networks'] field:
        // Polygon: {
        //        "info": {
        //            "canDep": false,
        //            "canInternal": false,
        //            "canWd": false,
        //            "ccy": "USDT",
        //            "chain": "USDT-Polygon-Bridge",
        //            "mainNet": false,
        //            "maxFee": "26.879528",
        //            "minFee": "13.439764",
        //            "minWd": "0.001",
        //            "name": ''
        //        },
        //        "id": "USDT-Polygon-Bridge",
        //        "network": "Polygon",
        //        "active": false,
        //        "deposit": false,
        //        "withdraw": false,
        //        "fee": 13.439764,
        //        "precision": undefined,
        //        "limits": {
        //            "withdraw": {
        //                "min": 0.001,
        //                "max": undefined
        //            }
        //        }
        //     },
        //
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", network },
            { "info", depositAddress },
        };
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-get-deposit-address
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object defaultNetwork = this.safeString(this.options, "defaultNetwork", "ERC20");
        object networkId = this.safeString(parameters, "network", defaultNetwork);
        object networkCode = this.networkIdToCode(networkId);
        parameters = this.omit(parameters, "network");
        object response = await this.fetchDepositAddressesByNetwork(code, parameters);
        object result = this.safeValue(response, networkCode);
        if (isTrue(isEqual(result, null)))
        {
            throw new InvalidAddress ((string)add(add(add(add(this.id, " fetchDepositAddress() cannot find "), networkCode), " deposit address for "), code)) ;
        }
        return result;
    }

    public async override Task<object> fetchDepositAddressesByNetwork(object code, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchDepositAddressesByNetwork
        * @description fetch a dictionary of addresses for a currency, indexed by network
        * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-get-deposit-address
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure} indexed by the network
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
        };
        object response = await this.privateGetAssetDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "addr": "okbtothemoon",
        //                 "memo": "971668", // may be missing
        //                 "tag":"52055", // may be missing
        //                 "pmtId": "", // may be missing
        //                 "ccy": "BTC",
        //                 "to": "6", // 1 SPOT, 3 FUTURES, 6 FUNDING, 9 SWAP, 12 OPTION, 18 Unified account
        //                 "selected": true
        //             },
        //             // {"ccy":"usdt-erc20","to":"6","addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa","selected":true},
        //             // {"ccy":"usdt-trc20","to":"6","addr":"TRrd5SiSZrfQVRKm4e9SRSbn2LNTYqCjqx","selected":true},
        //             // {"ccy":"usdt_okexchain","to":"6","addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa","selected":true},
        //             // {"ccy":"usdt_kip20","to":"6","addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa","selected":true},
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object filtered = this.filterBy(data, "selected", true);
        object parsed = this.parseDepositAddresses(filtered, new List<object>() {getValue(currency, "code")}, false);
        return this.indexBy(parsed, "network");
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name okcoin#transfer
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-funding-funds-transfer
        * @description transfer currency internally between wallets on the same account
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, toAccount);
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
            { "amt", this.currencyToPrecision(code, amount) },
            { "type", "0" },
            { "from", fromId },
            { "to", toId },
        };
        if (isTrue(isEqual(fromId, "master")))
        {
            ((IDictionary<string,object>)request)["type"] = "1";
            ((IDictionary<string,object>)request)["subAcct"] = toId;
            ((IDictionary<string,object>)request)["from"] = this.safeString(parameters, "from", "6");
            ((IDictionary<string,object>)request)["to"] = this.safeString(parameters, "to", "6");
        } else if (isTrue(isEqual(toId, "master")))
        {
            ((IDictionary<string,object>)request)["type"] = "2";
            ((IDictionary<string,object>)request)["subAcct"] = fromId;
            ((IDictionary<string,object>)request)["from"] = this.safeString(parameters, "from", "6");
            ((IDictionary<string,object>)request)["to"] = this.safeString(parameters, "to", "6");
        }
        object response = await this.privatePostAssetTransfer(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "transId": "754147",
        //                 "ccy": "USDT",
        //                 "from": "6",
        //                 "amt": "0.1",
        //                 "to": "18"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object rawTransfer = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseTransfer(rawTransfer, currency);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer
        //
        //     {
        //         "transId": "754147",
        //         "ccy": "USDT",
        //         "from": "6",
        //         "amt": "0.1",
        //         "to": "18"
        //     }
        //
        // fetchTransfer
        //
        //     {
        //         "amt": "5",
        //         "ccy": "USDT",
        //         "from": "18",
        //         "instId": "",
        //         "state": "success",
        //         "subAcct": "",
        //         "to": "6",
        //         "toInstId": "",
        //         "transId": "464424732",
        //         "type": "0"
        //     }
        //
        // fetchTransfers
        //
        //     {
        //         "bal": "70.6874353780312913",
        //         "balChg": "-4.0000000000000000", // negative means "to funding", positive meand "from funding"
        //         "billId": "588900695232225299",
        //         "ccy": "USDT",
        //         "execType": "",
        //         "fee": "",
        //         "from": "18",
        //         "instId": "",
        //         "instType": "",
        //         "mgnMode": "",
        //         "notes": "To Funding Account",
        //         "ordId": "",
        //         "pnl": "",
        //         "posBal": "",
        //         "posBalChg": "",
        //         "price": "0",
        //         "subType": "12",
        //         "sz": "-4",
        //         "to": "6",
        //         "ts": "1686676866989",
        //         "type": "1"
        //     }
        //
        object id = this.safeString2(transfer, "transId", "billId");
        object currencyId = this.safeString(transfer, "ccy");
        object code = this.safeCurrencyCode(currencyId, currency);
        object amount = this.safeNumber(transfer, "amt");
        object fromAccountId = this.safeString(transfer, "from");
        object toAccountId = this.safeString(transfer, "to");
        object accountsById = this.safeValue(this.options, "accountsById", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(transfer, "ts", this.milliseconds());
        object balanceChange = this.safeString(transfer, "sz");
        if (isTrue(!isEqual(balanceChange, null)))
        {
            amount = this.parseNumber(Precise.stringAbs(balanceChange));
        }
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", code },
            { "amount", amount },
            { "fromAccount", this.safeString(accountsById, fromAccountId) },
            { "toAccount", this.safeString(accountsById, toAccountId) },
            { "status", this.parseTransferStatus(this.safeString(transfer, "state")) },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "success", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name okcoin#withdraw
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-funding-withdrawal
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        if (isTrue(isTrue((!isEqual(tag, null))) && isTrue((isGreaterThan(getArrayLength(tag), 0)))))
        {
            address = add(add(address, ":"), tag);
        }
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
            { "toAddr", address },
            { "dest", "4" },
            { "amt", this.numberToString(amount) },
        };
        object network = this.safeString(parameters, "network"); // this line allows the user to specify either ERC20 or ETH
        if (isTrue(!isEqual(network, null)))
        {
            object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
            network = this.safeString(networks, ((string)network).ToUpper(), network); // handle ETH>ERC20 alias
            ((IDictionary<string,object>)request)["chain"] = add(add(getValue(currency, "id"), "-"), network);
            parameters = this.omit(parameters, "network");
        }
        object fee = this.safeString(parameters, "fee");
        if (isTrue(isEqual(fee, null)))
        {
            object targetNetwork = this.safeValue(getValue(currency, "networks"), this.networkIdToCode(network), new Dictionary<string, object>() {});
            fee = this.safeString(targetNetwork, "fee");
            if (isTrue(isEqual(fee, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " withdraw() requires a \"fee\" string parameter, network transaction fee must be ≥ 0. Withdrawals to OKCoin or OKX are fee-free, please set \"0\". Withdrawing to external digital asset address requires network transaction fee.")) ;
            }
        }
        ((IDictionary<string,object>)request)["fee"] = this.numberToString(fee); // withdrawals to OKCoin or OKX are fee-free, please set 0
        object response = await this.privatePostAssetWithdrawal(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "amt": "0.1",
        //                 "wdId": "67485",
        //                 "ccy": "BTC"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object transaction = this.safeDict(data, 0);
        return this.parseTransaction(transaction, currency);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okcoin#fetchDeposits
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-funding-get-deposit-history
        * @description fetch all deposits made to an account
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["ccy"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["before"] = mathMax(subtract(since, 1), 0);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 100
        }
        var requestparametersVariable = this.handleUntilOption("after", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateGetAssetDepositHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "amt": "0.01044408",
        //                 "txId": "1915737_3_0_0_asset",
        //                 "ccy": "BTC",
        //                 "from": "13801825426",
        //                 "to": "",
        //                 "ts": "1597026383085",
        //                 "state": "2",
        //                 "depId": "4703879"
        //             },
        //             {
        //                 "amt": "491.6784211",
        //                 "txId": "1744594_3_184_0_asset",
        //                 "ccy": "OKB",
        //                 "from": "",
        //                 "to": "",
        //                 "ts": "1597026383085",
        //                 "state": "2",
        //                 "depId": "4703809"
        //             },
        //             {
        //                 "amt": "223.18782496",
        //                 "txId": "6d892c669225b1092c780bf0da0c6f912fc7dc8f6b8cc53b003288624c",
        //                 "ccy": "USDT",
        //                 "from": "",
        //                 "to": "39kK4XvgEuM7rX9frgyHoZkWqx4iKu1spD",
        //                 "ts": "1597026383085",
        //                 "state": "2",
        //                 "depId": "4703779"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit, parameters);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okcoin#fetchWithdrawals
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-funding-get-withdrawal-history
        * @description fetch all withdrawals made from an account
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["ccy"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["before"] = mathMax(subtract(since, 1), 0);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 100
        }
        var requestparametersVariable = this.handleUntilOption("after", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateGetAssetWithdrawalHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "amt": "0.094",
        //                 "wdId": "4703879",
        //                 "fee": "0.01000000eth",
        //                 "txId": "0x62477bac6509a04512819bb1455e923a60dea5966c7caeaa0b24eb8fb0432b85",
        //                 "ccy": "ETH",
        //                 "from": "13426335357",
        //                 "to": "0xA41446125D0B5b6785f6898c9D67874D763A1519",
        //                 "ts": "1597026383085",
        //                 "state": "2"
        //             },
        //             {
        //                 "amt": "0.01",
        //                 "wdId": "4703879",
        //                 "fee": "0.00000000btc",
        //                 "txId": "",
        //                 "ccy": "BTC",
        //                 "from": "13426335357",
        //                 "to": "13426335357",
        //                 "ts": "1597026383085",
        //                 "state": "2"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit, parameters);
    }

    public virtual object parseTransactionStatus(object status)
    {
        //
        // deposit statuses
        //
        //     {
        //         "0": "waiting for confirmation",
        //         "1": "confirmation account",
        //         "2": "recharge success"
        //     }
        //
        // withdrawal statues
        //
        //     {
        //        '-3': "pending cancel",
        //        "-2": "cancelled",
        //        "-1": "failed",
        //         "0": "pending",
        //         "1": "sending",
        //         "2": "sent",
        //         "3": "email confirmation",
        //         "4": "manual confirmation",
        //         "5": "awaiting identity confirmation"
        //     }
        //
        object statuses = new Dictionary<string, object>() {
            { "-3", "pending" },
            { "-2", "canceled" },
            { "-1", "failed" },
            { "0", "pending" },
            { "1", "pending" },
            { "2", "ok" },
            { "3", "pending" },
            { "4", "pending" },
            { "5", "pending" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // withdraw
        //
        //     {
        //         "amt": "0.1",
        //         "wdId": "67485",
        //         "ccy": "BTC"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "amt": "0.094",
        //         "wdId": "4703879",
        //         "fee": "0.01000000eth",
        //         "txId": "0x62477bac6509a04512819bb1455e923a60dea5966c7caeaa0b24eb8fb0432b85",
        //         "ccy": "ETH",
        //         "from": "13426335357",
        //         "to": "0xA41446125D0B5b6785f6898c9D67874D763A1519",
        //         "tag",
        //         "pmtId",
        //         "memo",
        //         "ts": "1597026383085",
        //         "state": "2"
        //     }
        //
        // fetchDeposits
        //
        //     {
        //         "amt": "0.01044408",
        //         "txId": "1915737_3_0_0_asset",
        //         "ccy": "BTC",
        //         "from": "13801825426",
        //         "to": "",
        //         "ts": "1597026383085",
        //         "state": "2",
        //         "depId": "4703879"
        //     }
        //
        object type = null;
        object id = null;
        object withdrawalId = this.safeString(transaction, "wdId");
        object addressFrom = this.safeString(transaction, "from");
        object addressTo = this.safeString(transaction, "to");
        object address = addressTo;
        object tagTo = this.safeString2(transaction, "tag", "memo");
        tagTo = this.safeString2(transaction, "pmtId", tagTo);
        if (isTrue(!isEqual(withdrawalId, null)))
        {
            type = "withdrawal";
            id = withdrawalId;
        } else
        {
            // the payment_id will appear on new deposits but appears to be removed from the response after 2 months
            id = this.safeString(transaction, "depId");
            type = "deposit";
        }
        object currencyId = this.safeString(transaction, "ccy");
        object code = this.safeCurrencyCode(currencyId);
        object amount = this.safeNumber(transaction, "amt");
        object status = this.parseTransactionStatus(this.safeString(transaction, "state"));
        object txid = this.safeString(transaction, "txId");
        object timestamp = this.safeInteger(transaction, "ts");
        object feeCost = null;
        if (isTrue(isEqual(type, "deposit")))
        {
            feeCost = 0;
        } else
        {
            feeCost = this.safeNumber(transaction, "fee");
        }
        // todo parse tags
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "currency", code },
            { "amount", amount },
            { "network", null },
            { "addressFrom", addressFrom },
            { "addressTo", addressTo },
            { "address", address },
            { "tagFrom", null },
            { "tagTo", tagTo },
            { "tag", tagTo },
            { "status", status },
            { "type", type },
            { "updated", null },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "comment", null },
            { "internal", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", feeCost },
            } },
        };
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okcoin#fetchMyTrades
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-get-transaction-details-last-3-days
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-trade-get-transaction-details-last-3-months
        * @description fetch all trades made by the user
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "instType", "SPOT" },
        };
        if (isTrue(isTrue((!isEqual(limit, null))) && isTrue((isGreaterThan(limit, 100)))))
        {
            limit = 100;
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instId"] = getValue(market, "id");
        }
        object method = null;
        var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "method", "privateGetTradeFillsHistory");
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(method, "privateGetTradeFillsHistory")))
        {
            response = await this.privateGetTradeFillsHistory(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetTradeFills(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okcoin#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @param {string} id order id
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        return await this.fetchMyTrades(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okcoin#fetchLedger
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-funding-asset-bills-details
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-account-get-bills-details-last-7-days
        * @see https://www.okcoin.com/docs-v5/en/#rest-api-account-get-bills-details-last-3-months
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @param {string} code unified currency code, default is undefined
        * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int} [limit] max number of ledger entrys to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object method = null;
        var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchLedger", "method", "privateGetAccountBills");
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["ccy"] = getValue(currency, "id");
        }
        var requestparametersVariable = this.handleUntilOption("end", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(method, "privateGetAccountBillsArchive")))
        {
            response = await this.privateGetAccountBillsArchive(this.extend(request, parameters));
        } else if (isTrue(isEqual(method, "privateGetAssetBills")))
        {
            response = await this.privateGetAssetBills(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetAccountBills(this.extend(request, parameters));
        }
        //
        // privateGetAccountBills, privateGetAccountBillsArchive
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "bal": "0.0000819307998198",
        //                 "balChg": "-664.2679586599999802",
        //                 "billId": "310394313544966151",
        //                 "ccy": "USDT",
        //                 "fee": "0",
        //                 "from": "",
        //                 "instId": "LTC-USDT",
        //                 "instType": "SPOT",
        //                 "mgnMode": "cross",
        //                 "notes": "",
        //                 "ordId": "310394313519800320",
        //                 "pnl": "0",
        //                 "posBal": "0",
        //                 "posBalChg": "0",
        //                 "subType": "2",
        //                 "sz": "664.26795866",
        //                 "to": "",
        //                 "ts": "1620275771196",
        //                 "type": "2"
        //             }
        //         ]
        //     }
        //
        // privateGetAssetBills
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "billId": "12344",
        //                 "ccy": "BTC",
        //                 "balChg": "2",
        //                 "bal": "12",
        //                 "type": "1",
        //                 "ts": "1597026383085"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseLedger(data, currency, since, limit);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "1", "transfer" },
            { "2", "trade" },
            { "3", "trade" },
            { "4", "rebate" },
            { "5", "trade" },
            { "6", "transfer" },
            { "7", "trade" },
            { "8", "fee" },
            { "9", "trade" },
            { "10", "trade" },
            { "11", "trade" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        // privateGetAccountBills, privateGetAccountBillsArchive
        //
        //     {
        //         "bal": "0.0000819307998198",
        //         "balChg": "-664.2679586599999802",
        //         "billId": "310394313544966151",
        //         "ccy": "USDT",
        //         "fee": "0",
        //         "from": "",
        //         "instId": "LTC-USDT",
        //         "instType": "SPOT",
        //         "mgnMode": "cross",
        //         "notes": "",
        //         "ordId": "310394313519800320",
        //         "pnl": "0",
        //         "posBal": "0",
        //         "posBalChg": "0",
        //         "subType": "2",
        //         "sz": "664.26795866",
        //         "to": "",
        //         "ts": "1620275771196",
        //         "type": "2"
        //     }
        //
        // privateGetAssetBills
        //
        //     {
        //         "billId": "12344",
        //         "ccy": "BTC",
        //         "balChg": "2",
        //         "bal": "12",
        //         "type": "1",
        //         "ts": "1597026383085"
        //     }
        //
        object id = this.safeString(item, "billId");
        object account = null;
        object referenceId = this.safeString(item, "ordId");
        object referenceAccount = null;
        object type = this.parseLedgerEntryType(this.safeString(item, "type"));
        object code = this.safeCurrencyCode(this.safeString(item, "ccy"), currency);
        object amountString = this.safeString(item, "balChg");
        object amount = this.parseNumber(amountString);
        object timestamp = this.safeInteger(item, "ts");
        object feeCostString = this.safeString(item, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(Precise.stringNeg(feeCostString)) },
                { "currency", code },
            };
        }
        object before = null;
        object afterString = this.safeString(item, "bal");
        object after = this.parseNumber(afterString);
        object status = "ok";
        object marketId = this.safeString(item, "instId");
        object symbol = this.safeSymbol(marketId, null, "-");
        return new Dictionary<string, object>() {
            { "id", id },
            { "info", item },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "account", account },
            { "referenceId", referenceId },
            { "referenceAccount", referenceAccount },
            { "type", type },
            { "currency", code },
            { "symbol", symbol },
            { "amount", amount },
            { "before", before },
            { "after", after },
            { "status", status },
            { "fee", fee },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object isArray = ((parameters is IList<object>) || (parameters.GetType().IsGenericType && parameters.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))));
        object request = add(add(add("/api/", this.version), "/"), this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        object url = add(this.implodeHostname(getValue(getValue(this.urls, "api"), "rest")), request);
        if (isTrue(isEqual(api, "public")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object timestamp = this.iso8601(this.milliseconds());
            headers = new Dictionary<string, object>() {
                { "OK-ACCESS-KEY", this.apiKey },
                { "OK-ACCESS-PASSPHRASE", this.password },
                { "OK-ACCESS-TIMESTAMP", timestamp },
            };
            object auth = add(add(timestamp, method), request);
            if (isTrue(isEqual(method, "GET")))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    object urlencodedQuery = add("?", this.urlencode(query));
                    url = add(url, urlencodedQuery);
                    auth = add(auth, urlencodedQuery);
                }
            } else
            {
                if (isTrue(isTrue(isArray) || isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys)))))
                {
                    body = this.json(query);
                    auth = add(auth, body);
                }
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
            }
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256, "base64");
            ((IDictionary<string,object>)headers)["OK-ACCESS-SIGN"] = signature;
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public virtual object parseBalanceByType(object type, object response)
    {
        if (isTrue(isEqual(type, "funding")))
        {
            return this.parseFundingBalance(response);
        } else
        {
            return this.parseTradingBalance(response);
        }
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        //
        //    {
        //        "code": "1",
        //        "data": [
        //            {
        //                "clOrdId": "",
        //                "ordId": "",
        //                "sCode": "51119",
        //                "sMsg": "Order placement failed due to insufficient balance. ",
        //                "tag": ""
        //            }
        //        ],
        //        "msg": ""
        //    },
        //    {
        //        "code": "58001",
        //        "data": [],
        //        "msg": "Incorrect trade password"
        //    }
        //
        object code = this.safeString(response, "code");
        if (isTrue(!isEqual(code, "0")))
        {
            object feedback = add(add(this.id, " "), body);
            object data = this.safeValue(response, "data", new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object error = getValue(data, i);
                object errorCode = this.safeString(error, "sCode");
                object message = this.safeString(error, "sMsg");
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
                this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            }
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
