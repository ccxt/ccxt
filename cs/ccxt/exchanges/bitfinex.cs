namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class bitfinex : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bitfinex" },
            { "name", "Bitfinex" },
            { "countries", new List<object>() {"VG"} },
            { "version", "v1" },
            { "rateLimit", 666.666 },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", null },
                { "swap", null },
                { "future", null },
                { "option", null },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createDepositAddress", true },
                { "createOrder", true },
                { "editOrder", true },
                { "fetchBalance", true },
                { "fetchClosedOrders", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", false },
                { "fetchDepositsWithdrawals", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchIndexOHLCV", false },
                { "fetchLeverageTiers", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", false },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", true },
                { "fetchTransactionFees", true },
                { "fetchTransactions", "emulated" },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "3h", "3h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "12h", "12h" },
                { "1d", "1D" },
                { "1w", "7D" },
                { "2w", "14D" },
                { "1M", "1M" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "v2", "https://api-pub.bitfinex.com" },
                    { "public", "https://api.bitfinex.com" },
                    { "private", "https://api.bitfinex.com" },
                } },
                { "www", "https://www.bitfinex.com" },
                { "referral", "https://www.bitfinex.com/?refcode=P61eYxFL" },
                { "doc", new List<object>() {"https://docs.bitfinex.com/v1/docs", "https://github.com/bitfinexcom/bitfinex-api-node"} },
            } },
            { "api", new Dictionary<string, object>() {
                { "v2", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "platform/status", 3 },
                        { "tickers", 1 },
                        { "ticker/{symbol}", 1 },
                        { "tickers/hist", 1 },
                        { "trades/{symbol}/hist", 1 },
                        { "book/{symbol}/{precision}", 0.375 },
                        { "book/{symbol}/P0", 0.375 },
                        { "book/{symbol}/P1", 0.375 },
                        { "book/{symbol}/P2", 0.375 },
                        { "book/{symbol}/P3", 0.375 },
                        { "book/{symbol}/R0", 0.375 },
                        { "stats1/{key}:{size}:{symbol}:{side}/{section}", 1 },
                        { "stats1/{key}:{size}:{symbol}/{section}", 1 },
                        { "stats1/{key}:{size}:{symbol}:long/last", 1 },
                        { "stats1/{key}:{size}:{symbol}:long/hist", 1 },
                        { "stats1/{key}:{size}:{symbol}:short/last", 1 },
                        { "stats1/{key}:{size}:{symbol}:short/hist", 1 },
                        { "candles/trade:{timeframe}:{symbol}/{section}", 1 },
                        { "candles/trade:{timeframe}:{symbol}/last", 1 },
                        { "candles/trade:{timeframe}:{symbol}/hist", 1 },
                    } },
                } },
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "book/{symbol}", 1 },
                        { "lendbook/{currency}", 6 },
                        { "lends/{currency}", 3 },
                        { "pubticker/{symbol}", 3 },
                        { "stats/{symbol}", 6 },
                        { "symbols", 18 },
                        { "symbols_details", 18 },
                        { "tickers", 1 },
                        { "trades/{symbol}", 3 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "post", new Dictionary<string, object>() {
                        { "account_fees", 18 },
                        { "account_infos", 6 },
                        { "balances", 9.036 },
                        { "basket_manage", 6 },
                        { "credits", 6 },
                        { "deposit/new", 18 },
                        { "funding/close", 6 },
                        { "history", 6 },
                        { "history/movements", 6 },
                        { "key_info", 6 },
                        { "margin_infos", 3 },
                        { "mytrades", 3 },
                        { "mytrades_funding", 6 },
                        { "offer/cancel", 6 },
                        { "offer/new", 6 },
                        { "offer/status", 6 },
                        { "offers", 6 },
                        { "offers/hist", 90.03 },
                        { "order/cancel", 0.2 },
                        { "order/cancel/all", 0.2 },
                        { "order/cancel/multi", 0.2 },
                        { "order/cancel/replace", 0.2 },
                        { "order/new", 0.2 },
                        { "order/new/multi", 0.2 },
                        { "order/status", 0.2 },
                        { "orders", 0.2 },
                        { "orders/hist", 90.03 },
                        { "position/claim", 18 },
                        { "position/close", 18 },
                        { "positions", 18 },
                        { "summary", 18 },
                        { "taken_funds", 6 },
                        { "total_taken_funds", 6 },
                        { "transfer", 18 },
                        { "unused_taken_funds", 6 },
                        { "withdraw", 18 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "feeSide", "get" },
                    { "tierBased", true },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.001") },
                    { "taker", this.parseNumber("0.002") },
                    { "tiers", new Dictionary<string, object>() {
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.002")}, new List<object> {this.parseNumber("500000"), this.parseNumber("0.002")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.002")}, new List<object> {this.parseNumber("2500000"), this.parseNumber("0.002")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.002")}, new List<object> {this.parseNumber("7500000"), this.parseNumber("0.002")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0.0018")}, new List<object> {this.parseNumber("15000000"), this.parseNumber("0.0016")}, new List<object> {this.parseNumber("20000000"), this.parseNumber("0.0014")}, new List<object> {this.parseNumber("25000000"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("30000000"), this.parseNumber("0.001")}} },
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("500000"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("2500000"), this.parseNumber("0.0004")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.0002")}, new List<object> {this.parseNumber("7500000"), this.parseNumber("0")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0")}, new List<object> {this.parseNumber("15000000"), this.parseNumber("0")}, new List<object> {this.parseNumber("20000000"), this.parseNumber("0")}, new List<object> {this.parseNumber("25000000"), this.parseNumber("0")}, new List<object> {this.parseNumber("30000000"), this.parseNumber("0")}} },
                    } },
                } },
                { "funding", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", false },
                    { "deposit", new Dictionary<string, object>() {} },
                    { "withdraw", new Dictionary<string, object>() {} },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "ALG", "ALGO" },
                { "AMP", "AMPL" },
                { "ATO", "ATOM" },
                { "BCHABC", "XEC" },
                { "BCHN", "BCH" },
                { "DAT", "DATA" },
                { "DOG", "MDOGE" },
                { "DSH", "DASH" },
                { "EDO", "PNT" },
                { "EUS", "EURS" },
                { "EUT", "EURT" },
                { "IDX", "ID" },
                { "IOT", "IOTA" },
                { "IQX", "IQ" },
                { "LUNA", "LUNC" },
                { "LUNA2", "LUNA" },
                { "MNA", "MANA" },
                { "ORS", "ORS Group" },
                { "PAS", "PASS" },
                { "QSH", "QASH" },
                { "QTM", "QTUM" },
                { "RBT", "RBTC" },
                { "SNG", "SNGLS" },
                { "STJ", "STORJ" },
                { "TERRAUST", "USTC" },
                { "TSD", "TUSD" },
                { "YGG", "YEED" },
                { "YYW", "YOYOW" },
                { "UDC", "USDC" },
                { "UST", "USDT" },
                { "VSY", "VSYS" },
                { "WAX", "WAXP" },
                { "XCH", "XCHF" },
                { "ZBT", "ZB" },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "temporarily_unavailable", typeof(ExchangeNotAvailable) },
                    { "Order could not be cancelled.", typeof(OrderNotFound) },
                    { "No such order found.", typeof(OrderNotFound) },
                    { "Order price must be positive.", typeof(InvalidOrder) },
                    { "Could not find a key matching the given X-BFX-APIKEY.", typeof(AuthenticationError) },
                    { "Key price should be a decimal number, e.g. \"123.456\"", typeof(InvalidOrder) },
                    { "Key amount should be a decimal number, e.g. \"123.456\"", typeof(InvalidOrder) },
                    { "ERR_RATE_LIMIT", typeof(RateLimitExceeded) },
                    { "Ratelimit", typeof(RateLimitExceeded) },
                    { "Nonce is too small.", typeof(InvalidNonce) },
                    { "No summary found.", typeof(ExchangeError) },
                    { "Cannot evaluate your available balance, please try again", typeof(ExchangeNotAvailable) },
                    { "Unknown symbol", typeof(BadSymbol) },
                    { "Cannot complete transfer. Exchange balance insufficient.", typeof(InsufficientFunds) },
                    { "Momentary balance check. Please wait few seconds and try the transfer again.", typeof(ExchangeError) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Invalid X-BFX-SIGNATURE", typeof(AuthenticationError) },
                    { "This API key does not have permission", typeof(PermissionDenied) },
                    { "not enough exchange balance for ", typeof(InsufficientFunds) },
                    { "minimum size for ", typeof(InvalidOrder) },
                    { "Invalid order", typeof(InvalidOrder) },
                    { "The available balance is only", typeof(InsufficientFunds) },
                } },
            } },
            { "precisionMode", SIGNIFICANT_DIGITS },
            { "options", new Dictionary<string, object>() {
                { "currencyNames", new Dictionary<string, object>() {
                    { "AGI", "agi" },
                    { "AID", "aid" },
                    { "AIO", "aio" },
                    { "ANT", "ant" },
                    { "AVT", "aventus" },
                    { "BAT", "bat" },
                    { "BCH", "bab" },
                    { "BCI", "bci" },
                    { "BFT", "bft" },
                    { "BSV", "bsv" },
                    { "BTC", "bitcoin" },
                    { "BTG", "bgold" },
                    { "CFI", "cfi" },
                    { "COMP", "comp" },
                    { "DAI", "dai" },
                    { "DADI", "dad" },
                    { "DASH", "dash" },
                    { "DATA", "datacoin" },
                    { "DTH", "dth" },
                    { "EDO", "eidoo" },
                    { "ELF", "elf" },
                    { "EOS", "eos" },
                    { "ETC", "ethereumc" },
                    { "ETH", "ethereum" },
                    { "ETP", "metaverse" },
                    { "FUN", "fun" },
                    { "GNT", "golem" },
                    { "IOST", "ios" },
                    { "IOTA", "iota" },
                    { "LEO", "let" },
                    { "LINK", "link" },
                    { "LRC", "lrc" },
                    { "LTC", "litecoin" },
                    { "LYM", "lym" },
                    { "MANA", "mna" },
                    { "MIT", "mit" },
                    { "MKR", "mkr" },
                    { "MTN", "mtn" },
                    { "NEO", "neo" },
                    { "ODE", "ode" },
                    { "OMG", "omisego" },
                    { "OMNI", "mastercoin" },
                    { "QASH", "qash" },
                    { "QTUM", "qtum" },
                    { "RCN", "rcn" },
                    { "RDN", "rdn" },
                    { "REP", "rep" },
                    { "REQ", "req" },
                    { "RLC", "rlc" },
                    { "SAN", "santiment" },
                    { "SNGLS", "sng" },
                    { "SNT", "status" },
                    { "SPANK", "spk" },
                    { "STORJ", "stj" },
                    { "TNB", "tnb" },
                    { "TRX", "trx" },
                    { "TUSD", "tsd" },
                    { "USD", "wire" },
                    { "USDC", "udc" },
                    { "UTK", "utk" },
                    { "USDT", "tetheruso" },
                    { "VEE", "vee" },
                    { "WAX", "wax" },
                    { "XLM", "xlm" },
                    { "XMR", "monero" },
                    { "XRP", "ripple" },
                    { "XVG", "xvg" },
                    { "YOYOW", "yoyow" },
                    { "ZEC", "zcash" },
                    { "ZRX", "zrx" },
                    { "XTZ", "xtz" },
                } },
                { "orderTypes", new Dictionary<string, object>() {
                    { "limit", "exchange limit" },
                    { "market", "exchange market" },
                } },
                { "fiat", new Dictionary<string, object>() {
                    { "USD", "USD" },
                    { "EUR", "EUR" },
                    { "JPY", "JPY" },
                    { "GBP", "GBP" },
                    { "CNH", "CNH" },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "exchange" },
                    { "margin", "trading" },
                    { "funding", "deposit" },
                    { "swap", "trading" },
                } },
            } },
        });
    }

    public async override Task<object> fetchTransactionFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#fetchTransactionFees
        * @deprecated
        * @description please use fetchDepositWithdrawFees instead
        * @see https://docs.bitfinex.com/v1/reference/rest-auth-fees
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [fees structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object result = new Dictionary<string, object>() {};
        object response = await this.privatePostAccountFees(parameters);
        //
        // {
        //     "withdraw": {
        //         "BTC": "0.0004",
        //     }
        // }
        //
        object fees = this.safeValue(response, "withdraw");
        object ids = new List<object>(((IDictionary<string,object>)fees).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object id = getValue(ids, i);
            object code = this.safeCurrencyCode(id);
            if (isTrue(isTrue((!isEqual(codes, null))) && !isTrue(this.inArray(code, codes))))
            {
                continue;
            }
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "withdraw", this.safeNumber(fees, id) },
                { "deposit", new Dictionary<string, object>() {} },
                { "info", this.safeNumber(fees, id) },
            };
        }
        return result;
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://docs.bitfinex.com/v1/reference/rest-auth-fees
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [fees structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostAccountFees(parameters);
        //
        //    {
        //        "withdraw": {
        //            "BTC": "0.0004",
        //            ...
        //        }
        //    }
        //
        object withdraw = this.safeList(response, "withdraw");
        return this.parseDepositWithdrawFees(withdraw, codes);
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //    '0.0004'
        //
        return new Dictionary<string, object>() {
            { "withdraw", new Dictionary<string, object>() {
                { "fee", this.parseNumber(fee) },
                { "percentage", null },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "networks", new Dictionary<string, object>() {} },
            { "info", fee },
        };
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @see https://docs.bitfinex.com/v1/reference/rest-auth-summary
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostSummary(parameters);
        //
        //     {
        //          "time": "2022-02-23T16:05:47.659000Z",
        //          "status": { resid_hint: null, login_last: "2022-02-23T16:05:48Z" },
        //          "is_locked": false,
        //          "leo_lev": "0",
        //          "leo_amount_avg": "0.0",
        //          "trade_vol_30d": [
        //          {
        //              "curr": "Total (USD)",
        //              "vol": "0.0",
        //              "vol_safe": "0.0",
        //              "vol_maker": "0.0",
        //              "vol_BFX": "0.0",
        //              "vol_BFX_safe": "0.0",
        //              "vol_BFX_maker": "0.0"
        //          }
        //          ],
        //          "fees_funding_30d": {},
        //          "fees_funding_total_30d": "0",
        //          "fees_trading_30d": {},
        //          "fees_trading_total_30d": "0",
        //          "rebates_trading_30d": {},
        //          "rebates_trading_total_30d": "0",
        //          "maker_fee": "0.001",
        //          "taker_fee": "0.002",
        //          "maker_fee_2crypto": "0.001",
        //          "maker_fee_2stablecoin": "0.001",
        //          "maker_fee_2fiat": "0.001",
        //          "maker_fee_2deriv": "0.0002",
        //          "taker_fee_2crypto": "0.002",
        //          "taker_fee_2stablecoin": "0.002",
        //          "taker_fee_2fiat": "0.002",
        //          "taker_fee_2deriv": "0.00065",
        //          "deriv_maker_rebate": "0.0002",
        //          "deriv_taker_fee": "0.00065",
        //          "trade_last": null
        //     }
        //
        object result = new Dictionary<string, object>() {};
        object fiat = this.safeValue(this.options, "fiat", new Dictionary<string, object>() {});
        object makerFee = this.safeNumber(response, "maker_fee");
        object takerFee = this.safeNumber(response, "taker_fee");
        object makerFee2Fiat = this.safeNumber(response, "maker_fee_2fiat");
        object takerFee2Fiat = this.safeNumber(response, "taker_fee_2fiat");
        object makerFee2Deriv = this.safeNumber(response, "maker_fee_2deriv");
        object takerFee2Deriv = this.safeNumber(response, "taker_fee_2deriv");
        for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(this.symbols, i);
            object market = this.market(symbol);
            object fee = new Dictionary<string, object>() {
                { "info", response },
                { "symbol", symbol },
                { "percentage", true },
                { "tierBased", true },
            };
            if (isTrue(inOp(fiat, getValue(market, "quote"))))
            {
                ((IDictionary<string,object>)fee)["maker"] = makerFee2Fiat;
                ((IDictionary<string,object>)fee)["taker"] = takerFee2Fiat;
            } else if (isTrue(getValue(market, "contract")))
            {
                ((IDictionary<string,object>)fee)["maker"] = makerFee2Deriv;
                ((IDictionary<string,object>)fee)["taker"] = takerFee2Deriv;
            } else
            {
                ((IDictionary<string,object>)fee)["maker"] = makerFee;
                ((IDictionary<string,object>)fee)["taker"] = takerFee;
            }
            ((IDictionary<string,object>)result)[(string)symbol] = fee;
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#fetchMarkets
        * @description retrieves data on all markets for bitfinex
        * @see https://docs.bitfinex.com/v1/reference/rest-public-symbols
        * @see https://docs.bitfinex.com/v1/reference/rest-public-symbol-details
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object ids = await this.publicGetSymbols();
        //
        //     [ "btcusd", "ltcusd", "ltcbtc" ]
        //
        object details = await this.publicGetSymbolsDetails();
        //
        //     [
        //         {
        //             "pair":"btcusd",
        //             "price_precision":5,
        //             "initial_margin":"10.0",
        //             "minimum_margin":"5.0",
        //             "maximum_order_size":"2000.0",
        //             "minimum_order_size":"0.0002",
        //             "expiration":"NA",
        //             "margin":true
        //         },
        //     ]
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(details)); postFixIncrement(ref i))
        {
            object market = getValue(details, i);
            object id = this.safeString(market, "pair");
            if (!isTrue(this.inArray(id, ids)))
            {
                continue;
            }
            id = ((string)id).ToUpper();
            object baseId = null;
            object quoteId = null;
            if (isTrue(isGreaterThanOrEqual(getIndexOf(id, ":"), 0)))
            {
                object parts = ((string)id).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
                baseId = getValue(parts, 0);
                quoteId = getValue(parts, 1);
            } else
            {
                baseId = slice(id, 0, 3);
                quoteId = slice(id, 3, 6);
            }
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object symbol = add(add(bs, "/"), quote);
            object type = "spot";
            if (isTrue(isGreaterThan(getIndexOf(id, "F0"), -1)))
            {
                type = "swap";
            }
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", type },
                { "spot", (isEqual(type, "spot")) },
                { "margin", this.safeValue(market, "margin") },
                { "swap", (isEqual(type, "swap")) },
                { "future", false },
                { "option", false },
                { "active", true },
                { "contract", (isEqual(type, "swap")) },
                { "linear", null },
                { "inverse", null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", parseInt("8") },
                    { "price", this.safeInteger(market, "price_precision") },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minimum_order_size") },
                        { "max", this.safeNumber(market, "maximum_order_size") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", this.parseNumber("1e-8") },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", market },
            });
        }
        return result;
    }

    public override object amountToPrecision(object symbol, object amount)
    {
        // https://docs.bitfinex.com/docs/introduction#amount-precision
        // The amount field allows up to 8 decimals.
        // Anything exceeding this will be rounded to the 8th decimal.
        symbol = this.safeSymbol(symbol);
        return this.decimalToPrecision(amount, TRUNCATE, getValue(getValue(getValue(this.markets, symbol), "precision"), "amount"), DECIMAL_PLACES);
    }

    public override object priceToPrecision(object symbol, object price)
    {
        symbol = this.safeSymbol(symbol);
        price = this.decimalToPrecision(price, ROUND, getValue(getValue(getValue(this.markets, symbol), "precision"), "price"), this.precisionMode);
        // https://docs.bitfinex.com/docs/introduction#price-precision
        // The precision level of all trading prices is based on significant figures.
        // All pairs on Bitfinex use up to 5 significant digits and up to 8 decimals (e.g. 1.2345, 123.45, 1234.5, 0.00012345).
        // Prices submit with a precision larger than 5 will be cut by the API.
        return this.decimalToPrecision(price, TRUNCATE, 8, DECIMAL_PLACES);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://docs.bitfinex.com/v1/reference/rest-auth-wallet-balances
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object requestedType = this.safeString(parameters, "type", "exchange");
        object accountType = this.safeString(accountsByType, requestedType, requestedType);
        if (isTrue(isEqual(accountType, null)))
        {
            object keys = new List<object>(((IDictionary<string,object>)accountsByType).Keys);
            throw new ExchangeError ((string)add(add(this.id, " fetchBalance() type parameter must be one of "), String.Join(", ", ((IList<object>)keys).ToArray()))) ;
        }
        object query = this.omit(parameters, "type");
        object response = await this.privatePostBalances(query);
        //    [ { type: "deposit",
        //        "currency": "btc",
        //        "amount": "0.00116721",
        //        "available": "0.00116721" },
        //      { type: "exchange",
        //        "currency": "ust",
        //        "amount": "0.0000002",
        //        "available": "0.0000002" },
        //      { type: "trading",
        //        "currency": "btc",
        //        "amount": "0.0005",
        //        "available": "0.0005" } ],
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object isDerivative = isEqual(requestedType, "derivatives");
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object balance = getValue(response, i);
            object type = this.safeString(balance, "type");
            object currencyId = this.safeStringLower(balance, "currency", "");
            object start = subtract(((string)currencyId).Length, 2);
            object isDerivativeCode = isEqual(slice(currencyId, start, null), "f0");
            // this will only filter the derivative codes if the requestedType is 'derivatives'
            object derivativeCondition = (!isTrue(isDerivative) || isTrue(isDerivativeCode));
            if (isTrue(isTrue((isEqual(accountType, type))) && isTrue(derivativeCondition)))
            {
                object code = this.safeCurrencyCode(currencyId);
                // bitfinex had BCH previously, now it's BAB, but the old
                // BCH symbol is kept for backward-compatibility
                // we need a workaround here so that the old BCH balance
                // would not override the new BAB balance (BAB is unified to BCH)
                // https://github.com/ccxt/ccxt/issues/4989
                if (!isTrue((inOp(result, code))))
                {
                    object account = this.account();
                    ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "available");
                    ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "amount");
                    ((IDictionary<string,object>)result)[(string)code] = account;
                }
            }
        }
        return this.safeBalance(result);
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#transfer
        * @description transfer currency internally between wallets on the same account
        * @see https://docs.bitfinex.com/v1/reference/rest-auth-transfer-between-wallets
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        // transferring between derivatives wallet and regular wallet is not documented in their API
        // however we support it in CCXT (from just looking at web inspector)
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, toAccount);
        object currency = this.currency(code);
        object fromCurrencyId = this.convertDerivativesId(getValue(currency, "id"), fromAccount);
        object toCurrencyId = this.convertDerivativesId(getValue(currency, "id"), toAccount);
        object requestedAmount = this.currencyToPrecision(code, amount);
        object request = new Dictionary<string, object>() {
            { "amount", requestedAmount },
            { "currency", fromCurrencyId },
            { "currency_to", toCurrencyId },
            { "walletfrom", fromId },
            { "walletto", toId },
        };
        object response = await this.privatePostTransfer(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "status": "success",
        //             "message": "0.0001 Bitcoin transfered from Margin to Exchange"
        //         }
        //     ]
        //
        object result = this.safeValue(response, 0);
        object message = this.safeString(result, "message");
        if (isTrue(isEqual(message, null)))
        {
            throw new ExchangeError ((string)add(this.id, " transfer failed")) ;
        }
        return this.extend(this.parseTransfer(result, currency), new Dictionary<string, object>() {
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "amount", this.parseNumber(requestedAmount) },
        });
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        //     {
        //         "status": "success",
        //         "message": "0.0001 Bitcoin transfered from Margin to Exchange"
        //     }
        //
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", null },
            { "timestamp", null },
            { "datetime", null },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", this.parseTransferStatus(this.safeString(transfer, "status")) },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "SUCCESS", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object convertDerivativesId(object currencyId, object type)
    {
        object start = subtract(getArrayLength(currencyId), 2);
        object isDerivativeCode = isEqual(slice(currencyId, start, null), "F0");
        if (isTrue(isTrue((isTrue(isTrue(!isEqual(type, "derivatives")) && isTrue(!isEqual(type, "trading"))) && isTrue(!isEqual(type, "margin")))) && isTrue(isDerivativeCode)))
        {
            currencyId = slice(currencyId, 0, start);
        } else if (isTrue(isTrue(isEqual(type, "derivatives")) && !isTrue(isDerivativeCode)))
        {
            currencyId = add(currencyId, "F0");
        }
        return currencyId;
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://docs.bitfinex.com/v1/reference/rest-public-orderbook
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit_bids"] = limit;
            ((IDictionary<string,object>)request)["limit_asks"] = limit;
        }
        object response = await this.publicGetBookSymbol(this.extend(request, parameters));
        return this.parseOrderBook(response, getValue(market, "symbol"), null, "bids", "asks", "price", "amount");
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.publicGetTickers(parameters);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object ticker = this.parseTicker(new Dictionary<string, object>() {
                { "result", getValue(response, i) },
            });
            object symbol = getValue(ticker, "symbol");
            ((IDictionary<string,object>)result)[(string)symbol] = ticker;
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://docs.bitfinex.com/v1/reference/rest-public-ticker
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object ticker = await this.publicGetPubtickerSymbol(this.extend(request, parameters));
        //
        //    {
        //        mid: '63560.5',
        //        bid: '63560.0',
        //        ask: '63561.0',
        //        last_price: '63547.0',
        //        low: '62812.0',
        //        high: '64480.0',
        //        volume: '517.25634977',
        //        timestamp: '1715102384.9849467'
        //    }
        //
        return this.parseTicker(ticker, market);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //    {
        //        mid: '63560.5',
        //        bid: '63560.0',
        //        ask: '63561.0',
        //        last_price: '63547.0',
        //        low: '62812.0',
        //        high: '64480.0',
        //        volume: '517.25634977',
        //        timestamp: '1715102384.9849467'
        //    }
        //
        object timestamp = this.safeTimestamp(ticker, "timestamp");
        object marketId = this.safeString(ticker, "pair");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object last = this.safeString(ticker, "last_price");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(ticker, "bid") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "ask") },
            { "askVolume", null },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", this.safeString(ticker, "mid") },
            { "baseVolume", this.safeString(ticker, "volume") },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public) v1
        //
        //     {
        //          "timestamp":1637258380,
        //          "tid":894452833,
        //          "price":"0.99941",
        //          "amount":"261.38",
        //          "exchange":"bitfinex",
        //          "type":"sell"
        //     }
        //
        // fetchMyTrades (private) v1
        //
        //     {
        //          "price":"0.99941",
        //          "amount":"261.38",
        //          "timestamp":"1637258380.0",
        //          "type":"Sell",
        //          "fee_currency":"UST",
        //          "fee_amount":"-0.52245157",
        //          "tid":894452833,
        //          "order_id":78819731373
        //     }
        //
        //     {
        //         "price":"0.99958",
        //         "amount":"261.90514",
        //         "timestamp":"1637258238.0",
        //         "type":"Buy",
        //         "fee_currency":"UDC",
        //         "fee_amount":"-0.52381028",
        //         "tid":894452800,
        //         "order_id":78819504838
        //     }
        //
        object id = this.safeString(trade, "tid");
        object timestamp = this.safeTimestamp(trade, "timestamp");
        object type = null;
        object side = this.safeStringLower(trade, "type");
        object orderId = this.safeString(trade, "order_id");
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString(trade, "amount");
        object fee = null;
        if (isTrue(inOp(trade, "fee_amount")))
        {
            object feeCostString = Precise.stringNeg(this.safeString(trade, "fee_amount"));
            object feeCurrencyId = this.safeString(trade, "fee_currency");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", feeCurrencyCode },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "order", orderId },
            { "side", side },
            { "takerOrMaker", null },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://docs.bitfinex.com/v1/reference/rest-public-trades
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        limit ??= 50;
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "limit_trades", limit },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["timestamp"] = this.parseToInt(divide(since, 1000));
        }
        object response = await this.publicGetTradesSymbol(this.extend(request, parameters));
        //
        //    [
        //        {
        //            "timestamp": "1694284565",
        //            "tid": "1415415034",
        //            "price": "25862.0",
        //            "amount": "0.00020685",
        //            "exchange": "bitfinex",
        //            "type": "buy"
        //        },
        //    ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://docs.bitfinex.com/v1/reference/rest-auth-past-trades
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit_trades"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["timestamp"] = this.parseToInt(divide(since, 1000));
        }
        object response = await this.privatePostMytrades(this.extend(request, parameters));
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#createOrder
        * @description create a trade order
        * @see https://docs.bitfinex.com/v1/reference/rest-auth-new-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object postOnly = this.safeBool(parameters, "postOnly", false);
        type = ((string)type).ToLower();
        parameters = this.omit(parameters, new List<object>() {"postOnly"});
        if (isTrue(getValue(market, "spot")))
        {
            // although they claim that type needs to be 'exchange limit' or 'exchange market'
            // in fact that's not the case for swap markets
            type = this.safeStringLower(getValue(this.options, "orderTypes"), type, type);
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", side },
            { "amount", this.amountToPrecision(symbol, amount) },
            { "type", type },
            { "ocoorder", false },
            { "buy_price_oco", 0 },
            { "sell_price_oco", 0 },
        };
        if (isTrue(isGreaterThan(getIndexOf(type, "market"), -1)))
        {
            ((IDictionary<string,object>)request)["price"] = ((object)this.nonce()).ToString();
        } else
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["is_postonly"] = true;
        }
        object response = await this.privatePostOrderNew(this.extend(request, parameters));
        return this.parseOrder(response, market);
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object order = new Dictionary<string, object>() {
            { "order_id", parseInt(id) },
        };
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)order)["price"] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)order)["amount"] = this.numberToString(amount);
        }
        if (isTrue(!isEqual(symbol, null)))
        {
            ((IDictionary<string,object>)order)["symbol"] = this.marketId(symbol);
        }
        if (isTrue(!isEqual(side, null)))
        {
            ((IDictionary<string,object>)order)["side"] = side;
        }
        if (isTrue(!isEqual(type, null)))
        {
            ((IDictionary<string,object>)order)["type"] = this.safeString(getValue(this.options, "orderTypes"), type, type);
        }
        object response = await this.privatePostOrderCancelReplace(this.extend(order, parameters));
        return this.parseOrder(response);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#cancelOrder
        * @description cancels an open order
        * @see https://docs.bitfinex.com/v1/reference/rest-auth-cancel-order
        * @param {string} id order id
        * @param {string} symbol not used by bitfinex cancelOrder ()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "order_id", parseInt(id) },
        };
        return await this.privatePostOrderCancel(this.extend(request, parameters));
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#cancelAllOrders
        * @description cancel all open orders
        * @see https://docs.bitfinex.com/v1/reference/rest-auth-cancel-all-orders
        * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} response from exchange
        */
        parameters ??= new Dictionary<string, object>();
        return await this.privatePostOrderCancelAll(parameters);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        //     {
        //           "id": 57334010955,
        //           "cid": 1611584840966,
        //           "cid_date": null,
        //           "gid": null,
        //           "symbol": "ltcbtc",
        //           "exchange": null,
        //           "price": "0.0042125",
        //           "avg_execution_price": "0.0042097",
        //           "side": "sell",
        //           "type": "exchange market",
        //           "timestamp": "1611584841.0",
        //           "is_live": false,
        //           "is_cancelled": false,
        //           "is_hidden": 0,
        //           "oco_order": 0,
        //           "was_forced": false,
        //           "original_amount": "0.205176",
        //           "remaining_amount": "0.0",
        //           "executed_amount": "0.205176",
        //           "src": "web"
        //     }
        //
        object side = this.safeString(order, "side");
        object open = this.safeValue(order, "is_live");
        object canceled = this.safeValue(order, "is_cancelled");
        object status = null;
        if (isTrue(open))
        {
            status = "open";
        } else if (isTrue(canceled))
        {
            status = "canceled";
        } else
        {
            status = "closed";
        }
        object marketId = this.safeStringUpper(order, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object orderType = this.safeString(order, "type", "");
        object exchange = isGreaterThanOrEqual(getIndexOf(orderType, "exchange "), 0);
        if (isTrue(exchange))
        {
            object parts = ((string)getValue(order, "type")).Split(new [] {((string)" ")}, StringSplitOptions.None).ToList<object>();
            orderType = getValue(parts, 1);
        }
        object timestamp = this.safeTimestamp(order, "timestamp");
        object id = this.safeString(order, "id");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", symbol },
            { "type", orderType },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", this.safeString(order, "price") },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "average", this.safeString(order, "avg_execution_price") },
            { "amount", this.safeString(order, "original_amount") },
            { "remaining", this.safeString(order, "remaining_amount") },
            { "filled", this.safeString(order, "executed_amount") },
            { "status", status },
            { "fee", null },
            { "cost", null },
            { "trades", null },
        }, market);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://docs.bitfinex.com/v1/reference/rest-auth-active-orders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(!isEqual(symbol, null)))
        {
            if (!isTrue((inOp(this.markets, symbol))))
            {
                throw new ExchangeError ((string)add(add(this.id, " has no symbol "), symbol)) ;
            }
        }
        object response = await this.privatePostOrders(parameters);
        object orders = this.parseOrders(response, null, since, limit);
        if (isTrue(!isEqual(symbol, null)))
        {
            orders = this.filterBy(orders, "symbol", symbol);
        }
        return orders;
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://docs.bitfinex.com/v1/reference/rest-auth-orders-history
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbol = this.symbol(symbol);
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privatePostOrdersHist(this.extend(request, parameters));
        object orders = this.parseOrders(response, null, since, limit);
        if (isTrue(!isEqual(symbol, null)))
        {
            orders = this.filterBy(orders, "symbol", symbol);
        }
        orders = this.filterByArray(orders, "status", new List<object>() {"closed", "canceled"}, false);
        return orders;
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://docs.bitfinex.com/v1/reference/rest-auth-order-status
        * @param {string} symbol not used by bitfinex fetchOrder
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "order_id", parseInt(id) },
        };
        object response = await this.privatePostOrderStatus(this.extend(request, parameters));
        return this.parseOrder(response);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         1457539800000,
        //         0.02594,
        //         0.02594,
        //         0.02594,
        //         0.02594,
        //         0.1
        //     ]
        //
        return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 5)};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://docs.bitfinex.com/reference/rest-public-candles#aggregate-funding-currency-candles
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100;
        } else
        {
            limit = mathMin(limit, 10000);
        }
        object market = this.market(symbol);
        object v2id = add("t", getValue(market, "id"));
        object request = new Dictionary<string, object>() {
            { "symbol", v2id },
            { "timeframe", this.safeString(this.timeframes, timeframe, timeframe) },
            { "sort", 1 },
            { "limit", limit },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = since;
        }
        object response = await this.v2GetCandlesTradeTimeframeSymbolHist(this.extend(request, parameters));
        //
        //     [
        //         [1457539800000,0.02594,0.02594,0.02594,0.02594,0.1],
        //         [1457547300000,0.02577,0.02577,0.02577,0.02577,0.01],
        //         [1457550240000,0.0255,0.0253,0.0255,0.0252,3.2640000000000002],
        //     ]
        //
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    public virtual object getCurrencyName(object code)
    {
        // todo rewrite for https://api-pub.bitfinex.com//v2/conf/pub:map:tx:method
        if (isTrue(inOp(getValue(this.options, "currencyNames"), code)))
        {
            return getValue(getValue(this.options, "currencyNames"), code);
        }
        throw new NotSupported ((string)add(add(add(this.id, " "), code), " not supported for withdrawal")) ;
    }

    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#createDepositAddress
        * @description create a currency deposit address
        * @see https://docs.bitfinex.com/v1/reference/rest-auth-deposit
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "renew", 1 },
        };
        return await this.fetchDepositAddress(code, this.extend(request, parameters));
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://docs.bitfinex.com/v1/reference/rest-auth-deposit
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        // todo rewrite for https://api-pub.bitfinex.com//v2/conf/pub:map:tx:method
        object name = this.getCurrencyName(code);
        object request = new Dictionary<string, object>() {
            { "method", name },
            { "wallet_name", "exchange" },
            { "renew", 0 },
        };
        object response = await this.privatePostDepositNew(this.extend(request, parameters));
        object address = this.safeValue(response, "address");
        object tag = null;
        if (isTrue(inOp(response, "address_pool")))
        {
            tag = address;
            address = getValue(response, "address_pool");
        }
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", null },
            { "info", response },
        };
    }

    public async override Task<object> fetchDepositsWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#fetchDepositsWithdrawals
        * @description fetch history of deposits and withdrawals
        * @see https://docs.bitfinex.com/v1/reference/rest-auth-deposit-withdrawal-history
        * @param {string} code unified currency code for the currency of the deposit/withdrawals
        * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
        * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currencyId = this.safeString(parameters, "currency");
        object query = this.omit(parameters, "currency");
        object currency = null;
        if (isTrue(isEqual(currencyId, null)))
        {
            if (isTrue(isEqual(code, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchDepositsWithdrawals() requires a currency `code` argument or a `currency` parameter")) ;
            } else
            {
                currency = this.currency(code);
                currencyId = getValue(currency, "id");
            }
        }
        ((IDictionary<string,object>)query)["currency"] = currencyId;
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)query)["since"] = this.parseToInt(divide(since, 1000));
        }
        object response = await this.privatePostHistoryMovements(this.extend(query, parameters));
        //
        //     [
        //         {
        //             "id": 581183,
        //             "txid":  123456,
        //             "currency": "BTC",
        //             "method": "BITCOIN",
        //             "type": "WITHDRAWAL",
        //             "amount": ".01",
        //             "description": "3QXYWgRGX2BPYBpUDBssGbeWEa5zq6snBZ, offchain transfer ",
        //             "address": "3QXYWgRGX2BPYBpUDBssGbeWEa5zq6snBZ",
        //             "status": "COMPLETED",
        //             "timestamp": "1443833327.0",
        //             "timestamp_created":  "1443833327.1",
        //             "fee":  0.1,
        //         }
        //     ]
        //
        return this.parseTransactions(response, currency, since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // crypto
        //
        //     {
        //         "id": 12042490,
        //         "fee": "-0.02",
        //         "txid": "EA5B5A66000B66855865EFF2494D7C8D1921FCBE996482157EBD749F2C85E13D",
        //         "type": "DEPOSIT",
        //         "amount": "2099.849999",
        //         "method": "RIPPLE",
        //         "status": "COMPLETED",
        //         "address": "2505189261",
        //         "currency": "XRP",
        //         "timestamp": "1551730524.0",
        //         "description": "EA5B5A66000B66855865EFF2494D7C8D1921FCBE996482157EBD749F2C85E13D",
        //         "timestamp_created": "1551730523.0"
        //     }
        //
        // fiat
        //
        //     {
        //         "id": 12725095,
        //         "fee": "-60.0",
        //         "txid": null,
        //         "type": "WITHDRAWAL",
        //         "amount": "9943.0",
        //         "method": "WIRE",
        //         "status": "SENDING",
        //         "address": null,
        //         "currency": "EUR",
        //         "timestamp": "1561802484.0",
        //         "description": "Name: bob, AccountAddress: some address, Account: someaccountno, Bank: bank address, SWIFT: foo, Country: UK, Details of Payment: withdrawal name, Intermediary Bank Name: , Intermediary Bank Address: , Intermediary Bank City: , Intermediary Bank Country: , Intermediary Bank Account: , Intermediary Bank SWIFT: , Fee: -60.0",
        //         "timestamp_created": "1561716066.0"
        //     }
        //
        // withdraw
        //
        //     {
        //         "status": "success",
        //         "message": "Your withdrawal request has been successfully submitted.",
        //         "withdrawal_id": 586829
        //     }
        //
        object timestamp = this.safeTimestamp(transaction, "timestamp_created");
        object currencyId = this.safeString(transaction, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object feeCost = this.safeString(transaction, "fee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            feeCost = Precise.stringAbs(feeCost);
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString2(transaction, "id", "withdrawal_id") },
            { "txid", this.safeString(transaction, "txid") },
            { "type", this.safeStringLower(transaction, "type") },
            { "currency", code },
            { "network", null },
            { "amount", this.safeNumber(transaction, "amount") },
            { "status", this.parseTransactionStatus(this.safeString(transaction, "status")) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "address", this.safeString(transaction, "address") },
            { "addressFrom", null },
            { "addressTo", null },
            { "tag", this.safeString(transaction, "description") },
            { "tagFrom", null },
            { "tagTo", null },
            { "updated", this.safeTimestamp(transaction, "timestamp") },
            { "comment", null },
            { "internal", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", this.parseNumber(feeCost) },
                { "rate", null },
            } },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "SENDING", "pending" },
            { "CANCELED", "canceled" },
            { "ZEROCONFIRMED", "failed" },
            { "COMPLETED", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#withdraw
        * @description make a withdrawal
        * @see https://docs.bitfinex.com/v1/reference/rest-auth-withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        // todo rewrite for https://api-pub.bitfinex.com//v2/conf/pub:map:tx:method
        object name = this.getCurrencyName(code);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "withdraw_type", name },
            { "walletselected", "exchange" },
            { "amount", this.numberToString(amount) },
            { "address", address },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["payment_id"] = tag;
        }
        object responses = await this.privatePostWithdraw(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "status":"success",
        //             "message":"Your withdrawal request has been successfully submitted.",
        //             "withdrawal_id":586829
        //         }
        //     ]
        //
        object response = this.safeValue(responses, 0, new Dictionary<string, object>() {});
        object id = this.safeNumber(response, "withdrawal_id");
        object message = this.safeString(response, "message");
        object errorMessage = this.findBroadlyMatchedKey(getValue(this.exceptions, "broad"), message);
        if (isTrue(isEqual(id, 0)))
        {
            if (isTrue(!isEqual(errorMessage, null)))
            {
                object ExceptionClass = getValue(getValue(this.exceptions, "broad"), errorMessage);
                throwDynamicException(ExceptionClass, add(add(this.id, " "), message));return null;
            }
            throw new ExchangeError ((string)add(add(this.id, " withdraw returned an id of zero: "), this.json(response))) ;
        }
        return this.parseTransaction(response, currency);
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bitfinex#fetchPositions
        * @description fetch all open positions
        * @see https://docs.bitfinex.com/v1/reference/rest-auth-active-positions
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostPositions(parameters);
        //
        //     [
        //         {
        //             "id":943715,
        //             "symbol":"btcusd",
        //             "status":"ACTIVE",
        //             "base":"246.94",
        //             "amount":"1.0",
        //             "timestamp":"1444141857.0",
        //             "swap":"0.0",
        //             "pl":"-2.22042"
        //         }
        //     ]
        //
        // todo unify parsePosition/parsePositions
        return response;
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object request = add("/", this.implodeParams(path, parameters));
        if (isTrue(isEqual(api, "v2")))
        {
            request = add(add("/", api), request);
        } else
        {
            request = add(add("/", this.version), request);
        }
        object query = this.omit(parameters, this.extractParams(path));
        object url = add(getValue(getValue(this.urls, "api"), api), request);
        if (isTrue(isTrue((isEqual(api, "public"))) || isTrue((isGreaterThanOrEqual(getIndexOf(path, "/hist"), 0)))))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                object suffix = add("?", this.urlencode(query));
                url = add(url, suffix);
                request = add(request, suffix);
            }
        }
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object nonce = this.nonce();
            query = this.extend(new Dictionary<string, object>() {
                { "nonce", ((object)nonce).ToString() },
                { "request", request },
            }, query);
            body = this.json(query);
            object payload = this.stringToBase64(body);
            object secret = this.encode(this.secret);
            object signature = this.hmac(this.encode(payload), secret, sha384);
            headers = new Dictionary<string, object>() {
                { "X-BFX-APIKEY", this.apiKey },
                { "X-BFX-PAYLOAD", payload },
                { "X-BFX-SIGNATURE", signature },
                { "Content-Type", "application/json" },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        object throwError = false;
        if (isTrue(isGreaterThanOrEqual(code, 400)))
        {
            if (isTrue(isEqual(getValue(body, 0), "{")))
            {
                throwError = true;
            }
        } else
        {
            // json response with error, i.e:
            // [{"status":"error","message":"Momentary balance check. Please wait few seconds and try the transfer again."}]
            object responseObject = this.safeValue(response, 0, new Dictionary<string, object>() {});
            object status = this.safeString(responseObject, "status", "");
            if (isTrue(isEqual(status, "error")))
            {
                throwError = true;
            }
        }
        if (isTrue(throwError))
        {
            object feedback = add(add(this.id, " "), body);
            object message = this.safeString2(response, "message", "error");
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
