namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class hyperliquid : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "hyperliquid" },
            { "name", "Hyperliquid" },
            { "countries", new List<object>() {} },
            { "version", "v1" },
            { "rateLimit", 50 },
            { "certified", false },
            { "pro", false },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", false },
                { "margin", false },
                { "swap", true },
                { "future", true },
                { "option", false },
                { "addMargin", true },
                { "borrowCrossMargin", false },
                { "borrowIsolatedMargin", false },
                { "cancelAllOrders", false },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createMarketBuyOrderWithCost", false },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", true },
                { "createReduceOnlyOrder", false },
                { "editOrder", true },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", false },
                { "fetchDepositAddresses", false },
                { "fetchDeposits", false },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLedger", false },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchLiquidations", false },
                { "fetchMarginMode", null },
                { "fetchMarketLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyLiquidations", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", false },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", false },
                { "fetchOrderTrades", false },
                { "fetchPosition", true },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", false },
                { "fetchTickers", false },
                { "fetchTime", false },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", false },
                { "reduceMargin", true },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", false },
                { "setLeverage", true },
                { "setMarginMode", true },
                { "setPositionMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "3d", "3d" },
                { "1w", "1w" },
                { "1M", "1m" },
            } },
            { "hostname", "hyperliquid.xyz" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/ccxt/ccxt/assets/43336371/3974aea3-c1a1-40c8-8df1-c2c00c829ca1" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.{hostname}" },
                    { "private", "https://api.{hostname}" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "public", "https://api.hyperliquid-testnet.xyz" },
                    { "private", "https://api.hyperliquid-testnet.xyz" },
                } },
                { "www", "https://hyperliquid.xyz" },
                { "doc", "https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api" },
                { "fees", "https://hyperliquid.gitbook.io/hyperliquid-docs/trading/fees" },
                { "referral", "https://app.hyperliquid.xyz/" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "post", new Dictionary<string, object>() {
                        { "info", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "post", new Dictionary<string, object>() {
                        { "exchange", 1 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "swap", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.00035") },
                    { "maker", this.parseNumber("0.0001") },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", false },
                { "secret", false },
                { "walletAddress", true },
                { "privateKey", true },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {} },
                { "broad", new Dictionary<string, object>() {
                    { "Price must be divisible by tick size.", typeof(InvalidOrder) },
                    { "Order must have minimum value of $10", typeof(InvalidOrder) },
                    { "Insufficient margin to place order.", typeof(InvalidOrder) },
                    { "Reduce only order would increase position.", typeof(InvalidOrder) },
                    { "Post only order would have immediately matched,", typeof(InvalidOrder) },
                    { "Order could not immediately match against any resting orders.", typeof(InvalidOrder) },
                    { "Invalid TP/SL price.", typeof(InvalidOrder) },
                    { "No liquidity available for market order.", typeof(InvalidOrder) },
                    { "Order was never placed, already canceled, or filled.", typeof(OrderNotFound) },
                    { "User or API Wallet ", typeof(InvalidOrder) },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "options", new Dictionary<string, object>() {
                { "sandboxMode", false },
                { "defaultSlippage", 0.05 },
                { "zeroAddress", "0x0000000000000000000000000000000000000000" },
            } },
        });
    }

    public override void setSandboxMode(object enabled)
    {
        base.setSandboxMode(enabled);
        ((IDictionary<string,object>)this.options)["sandboxMode"] = enabled;
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-exchange-metadata
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", "meta" },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "universe": [
        //                 {
        //                     "maxLeverage": 50,
        //                     "name": "SOL",
        //                     "onlyIsolated": false,
        //                     "szDecimals": 2
        //                 }
        //             ]
        //         }
        //     ]
        //
        object meta = this.safeList(response, "universe", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(meta)); postFixIncrement(ref i))
        {
            object data = this.safeDict(meta, i, new Dictionary<string, object>() {});
            object id = i;
            object name = this.safeString(data, "name");
            object code = this.safeCurrencyCode(name);
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "name", name },
                { "code", code },
                { "precision", null },
                { "info", data },
                { "active", null },
                { "deposit", null },
                { "withdraw", null },
                { "networks", null },
                { "fee", null },
                { "limits", null },
            };
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#fetchMarkets
        * @description retrieves data on all markets for hyperliquid
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-asset-contexts-includes-mark-price-current-funding-open-interest-etc
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", "metaAndAssetCtxs" },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "universe": [
        //                 {
        //                     "maxLeverage": 50,
        //                     "name": "SOL",
        //                     "onlyIsolated": false,
        //                     "szDecimals": 2
        //                 }
        //             ]
        //         },
        //         [
        //             {
        //                 "dayNtlVlm": "9450588.2273",
        //                 "funding": "0.0000198",
        //                 "impactPxs": [
        //                     "108.04",
        //                     "108.06"
        //                 ],
        //                 "markPx": "108.04",
        //                 "midPx": "108.05",
        //                 "openInterest": "10764.48",
        //                 "oraclePx": "107.99",
        //                 "premium": "0.00055561",
        //                 "prevDayPx": "111.81"
        //             }
        //         ]
        //     ]
        //
        object meta = this.safeDict(response, 0, new Dictionary<string, object>() {});
        meta = this.safeList(meta, "universe", new List<object>() {});
        object assetCtxs = this.safeDict(response, 1, new Dictionary<string, object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(meta)); postFixIncrement(ref i))
        {
            object data = this.extend(this.safeDict(meta, i, new Dictionary<string, object>() {}), this.safeDict(assetCtxs, i, new Dictionary<string, object>() {}));
            ((IDictionary<string,object>)data)["baseId"] = i;
            ((IList<object>)result).Add(data);
        }
        return this.parseMarkets(result);
    }

    public override object parseMarket(object market)
    {
        //
        //     {
        //         "maxLeverage": "50",
        //         "name": "ETH",
        //         "onlyIsolated": false,
        //         "szDecimals": "4",
        //         "dayNtlVlm": "1709813.11535",
        //         "funding": "0.00004807",
        //         "impactPxs": [
        //             "2369.3",
        //             "2369.6"
        //         ],
        //         "markPx": "2369.6",
        //         "midPx": "2369.45",
        //         "openInterest": "1815.4712",
        //         "oraclePx": "2367.3",
        //         "premium": "0.00090821",
        //         "prevDayPx": "2381.5"
        //     }
        //
        object quoteId = "USDC";
        object bs = this.safeString(market, "name");
        object quote = this.safeCurrencyCode(quoteId);
        object baseId = this.safeString(market, "baseId");
        object settleId = "USDC";
        object settle = this.safeCurrencyCode(settleId);
        object symbol = add(add(bs, "/"), quote);
        object contract = true;
        object swap = true;
        if (isTrue(contract))
        {
            if (isTrue(swap))
            {
                symbol = add(add(symbol, ":"), settle);
            }
        }
        object fees = this.safeDict(this.fees, "swap", new Dictionary<string, object>() {});
        object taker = this.safeNumber(fees, "taker");
        object maker = this.safeNumber(fees, "maker");
        return new Dictionary<string, object>() {
            { "id", baseId },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", "swap" },
            { "spot", false },
            { "margin", null },
            { "swap", swap },
            { "future", false },
            { "option", false },
            { "active", true },
            { "contract", contract },
            { "linear", true },
            { "inverse", false },
            { "taker", taker },
            { "maker", maker },
            { "contractSize", this.parseNumber("1") },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", 1e-8 },
                { "price", 1e-8 },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        };
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-state
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.user] user address, will default to this.walletAddress if not provided
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchBalance", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "type", "clearinghouseState" },
            { "user", userAddress },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     {
        //         "assetPositions": [],
        //         "crossMaintenanceMarginUsed": "0.0",
        //         "crossMarginSummary": {
        //             "accountValue": "100.0",
        //             "totalMarginUsed": "0.0",
        //             "totalNtlPos": "0.0",
        //             "totalRawUsd": "100.0"
        //         },
        //         "marginSummary": {
        //             "accountValue": "100.0",
        //             "totalMarginUsed": "0.0",
        //             "totalNtlPos": "0.0",
        //             "totalRawUsd": "100.0"
        //         },
        //         "time": "1704261007014",
        //         "withdrawable": "100.0"
        //     }
        //
        object data = this.safeDict(response, "marginSummary", new Dictionary<string, object>() {});
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "USDC", new Dictionary<string, object>() {
                { "total", this.safeFloat(data, "accountValue") },
                { "used", this.safeFloat(data, "totalMarginUsed") },
            } },
        };
        object timestamp = this.safeInteger(response, "time");
        ((IDictionary<string,object>)result)["timestamp"] = timestamp;
        ((IDictionary<string,object>)result)["datetime"] = this.iso8601(timestamp);
        return this.safeBalance(result);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#info
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "type", "l2Book" },
            { "coin", getValue(market, "base") },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     {
        //         "coin": "ETH",
        //         "levels": [
        //             [
        //                 {
        //                     "n": "2",
        //                     "px": "2216.2",
        //                     "sz": "74.0637"
        //                 }
        //             ],
        //             [
        //                 {
        //                     "n": "2",
        //                     "px": "2216.5",
        //                     "sz": "70.5893"
        //                 }
        //             ]
        //         ],
        //         "time": "1704290104840"
        //     }
        //
        object data = this.safeList(response, "levels", new List<object>() {});
        object result = new Dictionary<string, object>() {
            { "bids", this.safeList(data, 0, new List<object>() {}) },
            { "asks", this.safeList(data, 1, new List<object>() {}) },
        };
        object timestamp = this.safeInteger(response, "time");
        return this.parseOrderBook(result, getValue(market, "symbol"), timestamp, "bids", "asks", "px", "sz");
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#info-1
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents, support '1m', '15m', '1h', '1d'
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp in ms of the latest candle to fetch
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object until = this.safeInteger(parameters, "until", this.milliseconds());
        if (isTrue(isEqual(since, null)))
        {
            since = 0;
        }
        if (isTrue(isEqual(limit, null)))
        {
            limit = 500;
        }
        parameters = this.omit(parameters, new List<object>() {"until"});
        object request = new Dictionary<string, object>() {
            { "type", "candleSnapshot" },
            { "req", new Dictionary<string, object>() {
                { "coin", getValue(market, "base") },
                { "interval", timeframe },
                { "startTime", since },
                { "endTime", until },
            } },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "T": 1704287699999,
        //             "c": "2226.4",
        //             "h": "2247.9",
        //             "i": "15m",
        //             "l": "2224.6",
        //             "n": 46,
        //             "o": "2247.9",
        //             "s": "ETH",
        //             "t": 1704286800000,
        //             "v": "591.6427"
        //         }
        //     ]
        //
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "T": 1704287699999,
        //         "c": "2226.4",
        //         "h": "2247.9",
        //         "i": "15m",
        //         "l": "2224.6",
        //         "n": 46,
        //         "o": "2247.9",
        //         "s": "ETH",
        //         "t": 1704286800000,
        //         "v": "591.6427"
        //     }
        //
        return new List<object> {this.safeInteger(ohlcv, "T"), this.safeNumber(ohlcv, "o"), this.safeNumber(ohlcv, "h"), this.safeNumber(ohlcv, "l"), this.safeNumber(ohlcv, "c"), this.safeNumber(ohlcv, "v")};
    }

    public async override Task<object> fetchTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills-by-time
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp in ms of the latest trade
        * @param {string} [params.address] wallet address that made trades
        * @param {string} [params.user] wallet address that made trades
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchTrades", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        await this.loadMarkets();
        object market = this.safeMarket(symbol);
        object request = new Dictionary<string, object>() {
            { "user", userAddress },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["type"] = "userFillsByTime";
            ((IDictionary<string,object>)request)["startTime"] = since;
        } else
        {
            ((IDictionary<string,object>)request)["type"] = "userFills";
        }
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "closedPnl": "0.19343",
        //             "coin": "ETH",
        //             "crossed": true,
        //             "dir": "Close Long",
        //             "fee": "0.050062",
        //             "hash": "0x09d77c96791e98b5775a04092584ab010d009445119c71e4005c0d634ea322bc",
        //             "liquidationMarkPx": null,
        //             "oid": 3929354691,
        //             "px": "2381.1",
        //             "side": "A",
        //             "startPosition": "0.0841",
        //             "sz": "0.0841",
        //             "tid": 128423918764978,
        //             "time": 1704262888911
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public override object amountToPrecision(object symbol, object amount)
    {
        return this.decimalToPrecision(amount, ROUND, getValue(getValue(getValue(this.markets, symbol), "precision"), "amount"), this.precisionMode);
    }

    public virtual object hashMessage(object message)
    {
        return add("0x", this.hash(message, keccak, "hex"));
    }

    public virtual object signHash(object hash, object privateKey)
    {
        object signature = ecdsa(slice(hash, -64, null), slice(privateKey, -64, null), secp256k1, null);
        return new Dictionary<string, object>() {
            { "r", add("0x", getValue(signature, "r")) },
            { "s", add("0x", getValue(signature, "s")) },
            { "v", this.sum(27, getValue(signature, "v")) },
        };
    }

    public virtual object signMessage(object message, object privateKey)
    {
        return this.signHash(this.hashMessage(message), slice(privateKey, -64, null));
    }

    public virtual object constructPhantomAgent(object hash, object isTestnet = null)
    {
        isTestnet ??= true;
        object source = ((bool) isTrue((isTestnet))) ? "b" : "a";
        return new Dictionary<string, object>() {
            { "source", source },
            { "connectionId", hash },
        };
    }

    public virtual object actionHash(object action, object vaultAddress, object nonce)
    {
        object dataBinary = this.packb(action);
        object dataHex = this.binaryToBase16(dataBinary);
        object data = dataHex;
        data = add(data, add("00000", this.intToBase16(nonce)));
        if (isTrue(isEqual(vaultAddress, null)))
        {
            data = add(data, "00");
        } else
        {
            data = add(data, "01");
            data = add(data, vaultAddress);
        }
        return this.hash(this.base16ToBinary(data), keccak, "binary");
    }

    public virtual object signL1Action(object action, object nonce, object vaultAdress = null)
    {
        object hash = this.actionHash(action, vaultAdress, nonce);
        object isTestnet = this.safeBool(this.options, "sandboxMode", false);
        object phantomAgent = this.constructPhantomAgent(hash, isTestnet);
        // const data = {
        //     'domain': {
        //         'chainId': 1337,
        //         'name': 'Exchange',
        //         'verifyingContract': '0x0000000000000000000000000000000000000000',
        //         'version': '1',
        //     },
        //     'types': {
        //         'Agent': [
        //             { 'name': 'source', 'type': 'string' },
        //             { 'name': 'connectionId', 'type': 'bytes32' },
        //         ],
        //         'EIP712Domain': [
        //             { 'name': 'name', 'type': 'string' },
        //             { 'name': 'version', 'type': 'string' },
        //             { 'name': 'chainId', 'type': 'uint256' },
        //             { 'name': 'verifyingContract', 'type': 'address' },
        //         ],
        //     },
        //     'primaryType': 'Agent',
        //     'message': phantomAgent,
        // };
        object zeroAddress = this.safeString(this.options, "zeroAddress");
        object chainId = 1337; // check this out
        object domain = new Dictionary<string, object>() {
            { "chainId", chainId },
            { "name", "Exchange" },
            { "verifyingContract", zeroAddress },
            { "version", "1" },
        };
        object messageTypes = new Dictionary<string, object>() {
            { "Agent", new List<object>() {new Dictionary<string, object>() {
    { "name", "source" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "connectionId" },
    { "type", "bytes32" },
}} },
        };
        object msg = this.ethEncodeStructuredData(domain, messageTypes, phantomAgent);
        object signature = this.signMessage(msg, this.privateKey);
        return signature;
    }

    public virtual object buildSig(object chainId, object messageTypes, object message)
    {
        object zeroAddress = this.safeString(this.options, "zeroAddress");
        object domain = new Dictionary<string, object>() {
            { "chainId", chainId },
            { "name", "Exchange" },
            { "verifyingContract", zeroAddress },
            { "version", "1" },
        };
        object msg = this.ethEncodeStructuredData(domain, messageTypes, message);
        object signature = this.signMessage(msg, this.privateKey);
        return signature;
    }

    public virtual object buildTransferSig(object message)
    {
        object isSandboxMode = this.safeBool(this.options, "sandboxMode");
        object chainId = ((bool) isTrue((isSandboxMode))) ? 421614 : 42161;
        object messageTypes = new Dictionary<string, object>() {
            { "UsdTransferSignPayload", new List<object>() {new Dictionary<string, object>() {
    { "name", "destination" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "amount" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "time" },
    { "type", "uint64" },
}} },
        };
        return this.buildSig(chainId, messageTypes, message);
    }

    public virtual object buildWithdrawSig(object message)
    {
        object isSandboxMode = this.safeBool(this.options, "sandboxMode");
        object chainId = ((bool) isTrue((isSandboxMode))) ? 421614 : 42161;
        object messageTypes = new Dictionary<string, object>() {
            { "WithdrawFromBridge2SignPayload", new List<object>() {new Dictionary<string, object>() {
    { "name", "destination" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "usd" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "time" },
    { "type", "uint64" },
}} },
        };
        return this.buildSig(chainId, messageTypes, message);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#createOrder
        * @description create a trade order
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#place-an-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.timeInForce] 'Gtc', 'Ioc', 'Alo'
        * @param {bool} [params.postOnly] true or false whether the order is post-only
        * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only
        * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
        * @param {string} [params.clientOrderId] client order id, optional 128 bit hex string
        * @param {string} [params.slippage] the slippage for market order
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object order = new Dictionary<string, object>() {
            { "symbol", ((string)symbol) },
            { "type", type },
            { "side", side },
            { "amount", amount },
            { "price", price },
            { "params", parameters },
        };
        object response = await this.createOrders(new List<object>() {order}, parameters);
        object first = this.safeDict(response, 0);
        return first;
    }

    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#createOrders
        * @description create a list of trade orders
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#place-an-order
        * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        await this.loadMarkets();
        object defaultSlippage = this.safeString(this.options, "defaultSlippage");
        defaultSlippage = this.safeString(parameters, "slippage", defaultSlippage);
        object hasClientOrderId = false;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object clientOrderId = this.safeString2(orderParams, "clientOrderId", "client_id");
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                hasClientOrderId = true;
            }
        }
        if (isTrue(hasClientOrderId))
        {
            for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
            {
                object rawOrder = getValue(orders, i);
                object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
                object clientOrderId = this.safeString2(orderParams, "clientOrderId", "client_id");
                if (isTrue(isEqual(clientOrderId, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " createOrders() all orders must have clientOrderId if at least one has a clientOrderId")) ;
                }
            }
        }
        parameters = this.omit(parameters, new List<object>() {"slippage", "clientOrderId", "client_id", "slippage", "triggerPrice", "stopPrice", "stopLossPrice", "takeProfitPrice"});
        object nonce = this.milliseconds();
        object orderReq = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            object market = this.market(marketId);
            object symbol = getValue(market, "symbol");
            object type = this.safeStringUpper(rawOrder, "type");
            object isMarket = (isEqual(type, "MARKET"));
            object side = this.safeStringUpper(rawOrder, "side");
            object isBuy = (isEqual(side, "BUY"));
            object amount = this.safeString(rawOrder, "amount");
            object price = this.safeString(rawOrder, "price");
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            orderParams = this.extend(parameters, orderParams);
            object clientOrderId = this.safeString2(orderParams, "clientOrderId", "client_id");
            object slippage = this.safeString(orderParams, "slippage", defaultSlippage);
            object defaultTimeInForce = ((bool) isTrue((isMarket))) ? "ioc" : "gtc";
            object postOnly = this.safeBool(orderParams, "postOnly", false);
            if (isTrue(postOnly))
            {
                defaultTimeInForce = "alo";
            }
            object timeInForce = this.safeStringLower(orderParams, "timeInForce", defaultTimeInForce);
            timeInForce = this.capitalize(timeInForce);
            object triggerPrice = this.safeString2(orderParams, "triggerPrice", "stopPrice");
            object stopLossPrice = this.safeString(orderParams, "stopLossPrice", triggerPrice);
            object takeProfitPrice = this.safeString(orderParams, "takeProfitPrice");
            object isTrigger = (isTrue(stopLossPrice) || isTrue(takeProfitPrice));
            object px = null;
            if (isTrue(isMarket))
            {
                if (isTrue(isEqual(price, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, "  market orders require price to calculate the max slippage price. Default slippage can be set in options (default is 5%).")) ;
                }
                px = ((bool) isTrue((isBuy))) ? Precise.stringMul(price, Precise.stringAdd("1", slippage)) : Precise.stringMul(price, Precise.stringSub("1", slippage));
            } else
            {
                px = this.priceToPrecision(symbol, price);
            }
            object sz = this.amountToPrecision(symbol, amount);
            object reduceOnly = this.safeBool(orderParams, "reduceOnly", false);
            object orderType = new Dictionary<string, object>() {};
            if (isTrue(isTrigger))
            {
                object isTp = false;
                if (isTrue(!isEqual(takeProfitPrice, null)))
                {
                    triggerPrice = this.priceToPrecision(symbol, takeProfitPrice);
                    isTp = true;
                } else
                {
                    triggerPrice = this.priceToPrecision(symbol, stopLossPrice);
                }
                ((IDictionary<string,object>)orderType)["trigger"] = new Dictionary<string, object>() {
                    { "isMarket", isMarket },
                    { "triggerPx", triggerPrice },
                    { "tpsl", ((bool) isTrue((isTp))) ? "tp" : "sl" },
                };
            } else
            {
                ((IDictionary<string,object>)orderType)["limit"] = new Dictionary<string, object>() {
                    { "tif", timeInForce },
                };
            }
            object orderObj = new Dictionary<string, object>() {
                { "a", this.parseToInt(getValue(market, "baseId")) },
                { "b", isBuy },
                { "p", px },
                { "s", sz },
                { "r", reduceOnly },
                { "t", orderType },
            };
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)orderObj)["c"] = clientOrderId;
            }
            ((IList<object>)orderReq).Add(orderObj);
        }
        object orderAction = new Dictionary<string, object>() {
            { "type", "order" },
            { "orders", orderReq },
            { "grouping", "na" },
            { "brokerCode", 1 },
        };
        object vaultAddress = this.safeString(parameters, "vaultAddress");
        object signature = this.signL1Action(orderAction, nonce, vaultAddress);
        object request = new Dictionary<string, object>() {
            { "action", orderAction },
            { "nonce", nonce },
            { "signature", signature },
        };
        object response = await this.privatePostExchange(this.extend(request, parameters));
        //
        //     {
        //         "status": "ok",
        //         "response": {
        //             "type": "order",
        //             "data": {
        //                 "statuses": [
        //                     {
        //                         "resting": {
        //                             "oid": 5063830287
        //                         }
        //                     }
        //                 ]
        //             }
        //         }
        //     }
        //
        object responseObj = this.safeDict(response, "response", new Dictionary<string, object>() {});
        object data = this.safeDict(responseObj, "data", new Dictionary<string, object>() {});
        object statuses = this.safeList(data, "statuses", new List<object>() {});
        return this.parseOrders(statuses, null);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#cancelOrder
        * @description cancels an open order
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s-by-cloid
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.clientOrderId] client order id (default undefined)
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.cancelOrders(new List<object>() {id}, symbol, parameters);
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#cancelOrders
        * @description cancel multiple orders
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s-by-cloid
        * @param {string[]} ids order ids
        * @param {string} [symbol] unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string|string[]} [params.clientOrderId] client order ids (default undefined)
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object clientOrderId = this.safeValue2(parameters, "clientOrderId", "client_id");
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "client_id"});
        object nonce = this.milliseconds();
        object request = new Dictionary<string, object>() {
            { "nonce", nonce },
        };
        object cancelReq = new List<object>() {};
        object cancelAction = new Dictionary<string, object>() {
            { "type", "" },
            { "cancels", new List<object>() {} },
        };
        object baseId = this.parseToNumeric(getValue(market, "baseId"));
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            if (!isTrue(((clientOrderId is IList<object>) || (clientOrderId.GetType().IsGenericType && clientOrderId.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                clientOrderId = new List<object>() {clientOrderId};
            }
            ((IDictionary<string,object>)cancelAction)["type"] = "cancelByCloid";
            for (object i = 0; isLessThan(i, getArrayLength(clientOrderId)); postFixIncrement(ref i))
            {
                ((IList<object>)cancelReq).Add(new Dictionary<string, object>() {
                    { "asset", baseId },
                    { "cloid", getValue(clientOrderId, i) },
                });
            }
        } else
        {
            ((IDictionary<string,object>)cancelAction)["type"] = "cancel";
            for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
            {
                ((IList<object>)cancelReq).Add(new Dictionary<string, object>() {
                    { "a", baseId },
                    { "o", this.parseToNumeric(getValue(ids, i)) },
                });
            }
        }
        ((IDictionary<string,object>)cancelAction)["cancels"] = cancelReq;
        object vaultAddress = this.safeString(parameters, "vaultAddress");
        object signature = this.signL1Action(cancelAction, nonce, vaultAddress);
        ((IDictionary<string,object>)request)["action"] = cancelAction;
        ((IDictionary<string,object>)request)["signature"] = signature;
        object response = await this.privatePostExchange(this.extend(request, parameters));
        //
        //     {
        //         "status":"ok",
        //         "response":{
        //             "type":"cancel",
        //             "data":{
        //                 "statuses":[
        //                     "success"
        //                 ]
        //             }
        //         }
        //     }
        //
        return response;
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#editOrder
        * @description edit a trade order
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#modify-an-order
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#modify-multiple-orders
        * @param {string} id cancel order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the base currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.timeInForce] 'Gtc', 'Ioc', 'Alo'
        * @param {bool} [params.postOnly] true or false whether the order is post-only
        * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only
        * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
        * @param {string} [params.clientOrderId] client order id, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        if (isTrue(isEqual(id, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " editOrder() requires an id argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        type = ((string)type).ToUpper();
        object isMarket = (isEqual(type, "MARKET"));
        side = ((string)side).ToUpper();
        object isBuy = (isEqual(side, "BUY"));
        object defaultSlippage = this.safeString(this.options, "defaultSlippage");
        object slippage = this.safeString(parameters, "slippage", defaultSlippage);
        object defaultTimeInForce = ((bool) isTrue((isMarket))) ? "ioc" : "gtc";
        object postOnly = this.safeBool(parameters, "postOnly", false);
        if (isTrue(postOnly))
        {
            defaultTimeInForce = "alo";
        }
        object timeInForce = this.safeStringLower(parameters, "timeInForce", defaultTimeInForce);
        timeInForce = this.capitalize(timeInForce);
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "client_id");
        object triggerPrice = this.safeString2(parameters, "triggerPrice", "stopPrice");
        object stopLossPrice = this.safeString(parameters, "stopLossPrice", triggerPrice);
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        object isTrigger = (isTrue(stopLossPrice) || isTrue(takeProfitPrice));
        parameters = this.omit(parameters, new List<object>() {"slippage", "timeInForce", "triggerPrice", "stopLossPrice", "takeProfitPrice", "clientOrderId", "client_id"});
        object px = ((object)price).ToString();
        if (isTrue(isMarket))
        {
            px = ((bool) isTrue((isBuy))) ? Precise.stringMul(((object)price).ToString(), Precise.stringAdd("1", slippage)) : Precise.stringMul(((object)price).ToString(), Precise.stringSub("1", slippage));
        } else
        {
            px = this.priceToPrecision(symbol, ((object)price).ToString());
        }
        object sz = this.amountToPrecision(symbol, amount);
        object reduceOnly = this.safeBool(parameters, "reduceOnly", false);
        object orderType = new Dictionary<string, object>() {};
        if (isTrue(isTrigger))
        {
            object isTp = false;
            if (isTrue(!isEqual(takeProfitPrice, null)))
            {
                triggerPrice = this.priceToPrecision(symbol, takeProfitPrice);
                isTp = true;
            } else
            {
                triggerPrice = this.priceToPrecision(symbol, stopLossPrice);
            }
            ((IDictionary<string,object>)orderType)["trigger"] = new Dictionary<string, object>() {
                { "isMarket", isMarket },
                { "triggerPx", triggerPrice },
                { "tpsl", ((bool) isTrue((isTp))) ? "tp" : "sl" },
            };
        } else
        {
            ((IDictionary<string,object>)orderType)["limit"] = new Dictionary<string, object>() {
                { "tif", timeInForce },
            };
        }
        if (isTrue(isEqual(triggerPrice, null)))
        {
            triggerPrice = "0";
        }
        object nonce = this.milliseconds();
        object orderReq = new Dictionary<string, object>() {
            { "a", this.parseToInt(getValue(market, "baseId")) },
            { "b", isBuy },
            { "p", px },
            { "s", sz },
            { "r", reduceOnly },
            { "t", orderType },
        };
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)orderReq)["c"] = clientOrderId;
        }
        object modifyReq = new Dictionary<string, object>() {
            { "oid", this.parseToInt(id) },
            { "order", orderReq },
        };
        object modifyAction = new Dictionary<string, object>() {
            { "type", "batchModify" },
            { "modifies", new List<object>() {modifyReq} },
        };
        object vaultAddress = this.safeString(parameters, "vaultAddress");
        object signature = this.signL1Action(modifyAction, nonce, vaultAddress);
        object request = new Dictionary<string, object>() {
            { "action", modifyAction },
            { "nonce", nonce },
            { "signature", signature },
        };
        object response = await this.privatePostExchange(this.extend(request, parameters));
        //
        //     {
        //         "status": "ok",
        //         "response": {
        //             "type": "order",
        //             "data": {
        //                 "statuses": [
        //                     {
        //                         "resting": {
        //                             "oid": 5063830287
        //                         }
        //                     }
        //                 ]
        //             }
        //         }
        //     }
        // when the order is filled immediately
        //     {
        //         "status":"ok",
        //         "response":{
        //            "type":"order",
        //            "data":{
        //               "statuses":[
        //                  {
        //                     "filled":{
        //                        "totalSz":"0.1",
        //                        "avgPx":"100.84",
        //                        "oid":6195281425
        //                     }
        //                  }
        //               ]
        //            }
        //         }
        //     }
        //
        object responseObject = this.safeDict(response, "response", new Dictionary<string, object>() {});
        object dataObject = this.safeDict(responseObject, "data", new Dictionary<string, object>() {});
        object statuses = this.safeList(dataObject, "statuses", new List<object>() {});
        object first = this.safeDict(statuses, 0, new Dictionary<string, object>() {});
        return this.parseOrder(first, market);
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#fetchFundingRateHistory
        * @description fetches historical funding rate prices
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-historical-funding-rates
        * @param {string} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
        * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp in ms of the latest funding rate
        * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "type", "fundingHistory" },
            { "coin", getValue(market, "base") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        } else
        {
            ((IDictionary<string,object>)request)["startTime"] = subtract(this.milliseconds(), multiply(multiply(multiply(100, 60), 60), 1000));
        }
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "coin": "ETH",
        //             "fundingRate": "0.0000125",
        //             "premium": "0.00057962",
        //             "time": 1704290400031
        //         }
        //     ]
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object timestamp = this.safeInteger(entry, "time");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", this.safeSymbol(null, market) },
                { "fundingRate", this.safeNumber(entry, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(result, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-open-orders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.user] user address, will default to this.walletAddress if not provided
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchOpenOrders", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        await this.loadMarkets();
        object market = this.safeMarket(symbol);
        object request = new Dictionary<string, object>() {
            { "type", "openOrders" },
            { "user", userAddress },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "coin": "ETH",
        //             "limitPx": "2000.0",
        //             "oid": 3991946565,
        //             "origSz": "0.1",
        //             "side": "B",
        //             "sz": "0.1",
        //             "timestamp": 1704346468838
        //         }
        //     ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#fetchClosedOrders
        * @description fetch all unfilled currently closed orders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.user] user address, will default to this.walletAddress if not provided
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchClosedOrders", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        await this.loadMarkets();
        object market = this.safeMarket(symbol);
        object request = new Dictionary<string, object>() {
            { "type", "historicalOrders" },
            { "user", userAddress },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "coin": "ETH",
        //             "limitPx": "2000.0",
        //             "oid": 3991946565,
        //             "origSz": "0.1",
        //             "side": "B",
        //             "sz": "0.1",
        //             "timestamp": 1704346468838
        //         }
        //     ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#query-order-status-by-oid-or-cloid
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.user] user address, will default to this.walletAddress if not provided
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchOrder", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        await this.loadMarkets();
        object market = this.safeMarket(symbol);
        object request = new Dictionary<string, object>() {
            { "type", "orderStatus" },
            { "oid", this.parseToNumeric(id) },
            { "user", userAddress },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     {
        //         "order": {
        //             "order": {
        //                 "children": [],
        //                 "cloid": null,
        //                 "coin": "ETH",
        //                 "isPositionTpsl": false,
        //                 "isTrigger": false,
        //                 "limitPx": "2000.0",
        //                 "oid": "3991946565",
        //                 "orderType": "Limit",
        //                 "origSz": "0.1",
        //                 "reduceOnly": false,
        //                 "side": "B",
        //                 "sz": "0.1",
        //                 "tif": "Gtc",
        //                 "timestamp": "1704346468838",
        //                 "triggerCondition": "N/A",
        //                 "triggerPx": "0.0"
        //             },
        //             "status": "open",
        //             "statusTimestamp": "1704346468838"
        //         },
        //         "status": "order"
        //     }
        //
        object data = this.safeDict(response, "order");
        return this.parseOrder(data, market);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        //  fetchOpenOrders
        //
        //     {
        //         "coin": "ETH",
        //         "limitPx": "2000.0",
        //         "oid": 3991946565,
        //         "origSz": "0.1",
        //         "side": "B",
        //         "sz": "0.1",
        //         "timestamp": 1704346468838
        //     }
        // fetchClosedorders
        //    {
        //        "cloid": null,
        //        "closedPnl": "0.0",
        //        "coin": "SOL",
        //        "crossed": true,
        //        "dir": "Open Long",
        //        "fee": "0.003879",
        //        "hash": "0x4a2647998682b7f07bc5040ab531e1011400f9a51bfa0346a0b41ebe510e8875",
        //        "liquidationMarkPx": null,
        //        "oid": "6463280784",
        //        "px": "110.83",
        //        "side": "B",
        //        "startPosition": "1.64",
        //        "sz": "0.1",
        //        "tid": "232174667018988",
        //        "time": "1709142268394"
        //    }
        //
        //  fetchOrder
        //
        //     {
        //         "order": {
        //             "children": [],
        //             "cloid": null,
        //             "coin": "ETH",
        //             "isPositionTpsl": false,
        //             "isTrigger": false,
        //             "limitPx": "2000.0",
        //             "oid": "3991946565",
        //             "orderType": "Limit",
        //             "origSz": "0.1",
        //             "reduceOnly": false,
        //             "side": "B",
        //             "sz": "0.1",
        //             "tif": "Gtc",
        //             "timestamp": "1704346468838",
        //             "triggerCondition": "N/A",
        //             "triggerPx": "0.0"
        //         },
        //         "status": "open",
        //         "statusTimestamp": "1704346468838"
        //     }
        //
        // createOrder
        //
        //     {
        //         "resting": {
        //             "oid": 5063830287
        //         }
        //     }
        //
        //     {
        //        "filled":{
        //           "totalSz":"0.1",
        //           "avgPx":"100.84",
        //           "oid":6195281425
        //        }
        //     }
        //
        object entry = this.safeDictN(order, new List<object>() {"order", "resting", "filled"});
        if (isTrue(isEqual(entry, null)))
        {
            entry = order;
        }
        object coin = this.safeString(entry, "coin");
        object marketId = null;
        if (isTrue(!isEqual(coin, null)))
        {
            marketId = add(coin, "/USDC:USDC");
        }
        if (isTrue(isEqual(this.safeString(entry, "id"), null)))
        {
            market = this.safeMarket(marketId, null);
        } else
        {
            market = this.safeMarket(marketId, market);
        }
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger2(order, "timestamp", "statusTimestamp");
        object status = this.safeString(order, "status");
        object side = this.safeString(entry, "side");
        if (isTrue(!isEqual(side, null)))
        {
            side = ((bool) isTrue((isEqual(side, "A")))) ? "sell" : "buy";
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString(entry, "oid") },
            { "clientOrderId", this.safeString(entry, "cloid") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", null },
            { "symbol", symbol },
            { "type", this.safeStringLower(entry, "orderType") },
            { "timeInForce", this.safeStringUpper(entry, "tif") },
            { "postOnly", null },
            { "reduceOnly", this.safeBool(entry, "reduceOnly") },
            { "side", side },
            { "price", this.safeNumber(entry, "limitPx") },
            { "triggerPrice", ((bool) isTrue(this.safeBool(entry, "isTrigger"))) ? this.safeNumber(entry, "triggerPx") : null },
            { "amount", this.safeNumber2(entry, "sz", "totalSz") },
            { "cost", null },
            { "average", this.safeNumber(entry, "avgPx") },
            { "filled", null },
            { "remaining", null },
            { "status", this.parseOrderStatus(status) },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "triggered", "open" },
            { "filled", "closed" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderType(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "stop limit", "limit" },
            { "stop market", "market" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills-by-time
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp in ms of the latest trade
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchMyTrades", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        await this.loadMarkets();
        object market = this.safeMarket(symbol);
        object request = new Dictionary<string, object>() {
            { "user", userAddress },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["type"] = "userFillsByTime";
            ((IDictionary<string,object>)request)["startTime"] = since;
        } else
        {
            ((IDictionary<string,object>)request)["type"] = "userFills";
        }
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "closedPnl": "0.19343",
        //             "coin": "ETH",
        //             "crossed": true,
        //             "dir": "Close Long",
        //             "fee": "0.050062",
        //             "hash": "0x09d77c96791e98b5775a04092584ab010d009445119c71e4005c0d634ea322bc",
        //             "liquidationMarkPx": null,
        //             "oid": 3929354691,
        //             "px": "2381.1",
        //             "side": "A",
        //             "startPosition": "0.0841",
        //             "sz": "0.0841",
        //             "tid": 128423918764978,
        //             "time": 1704262888911
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        //     {
        //         "closedPnl": "0.19343",
        //         "coin": "ETH",
        //         "crossed": true,
        //         "dir": "Close Long",
        //         "fee": "0.050062",
        //         "hash": "0x09d77c96791e98b5775a04092584ab010d009445119c71e4005c0d634ea322bc",
        //         "liquidationMarkPx": null,
        //         "oid": 3929354691,
        //         "px": "2381.1",
        //         "side": "A",
        //         "startPosition": "0.0841",
        //         "sz": "0.0841",
        //         "tid": 128423918764978,
        //         "time": 1704262888911
        //     }
        //
        object timestamp = this.safeInteger(trade, "time");
        object price = this.safeString(trade, "px");
        object amount = this.safeString(trade, "sz");
        object coin = this.safeString(trade, "coin");
        object marketId = add(coin, "/USDC:USDC");
        market = this.safeMarket(marketId, null);
        object symbol = getValue(market, "symbol");
        object id = this.safeString(trade, "tid");
        object side = this.safeString(trade, "side");
        if (isTrue(!isEqual(side, null)))
        {
            side = ((bool) isTrue((isEqual(side, "A")))) ? "sell" : "buy";
        }
        object fee = this.safeString(trade, "fee");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", id },
            { "order", this.safeString(trade, "oid") },
            { "type", null },
            { "side", side },
            { "takerOrMaker", null },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", new Dictionary<string, object>() {
                { "cost", fee },
                { "currency", "USDC" },
            } },
        }, market);
    }

    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#fetchPosition
        * @description fetch data on an open position
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-state
        * @param {string} symbol unified market symbol of the market the position is held in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.user] user address, will default to this.walletAddress if not provided
        * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object positions = await this.fetchPositions(new List<object>() {symbol}, parameters);
        return this.safeDict(positions, 0, new Dictionary<string, object>() {});
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#fetchPositions
        * @description fetch all open positions
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-state
        * @param {string[]} [symbols] list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.user] user address, will default to this.walletAddress if not provided
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchPositions", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {
            { "type", "clearinghouseState" },
            { "user", userAddress },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     {
        //         "assetPositions": [
        //             {
        //                 "position": {
        //                     "coin": "ETH",
        //                     "cumFunding": {
        //                         "allTime": "0.0",
        //                         "sinceChange": "0.0",
        //                         "sinceOpen": "0.0"
        //                     },
        //                     "entryPx": "2213.9",
        //                     "leverage": {
        //                         "rawUsd": "-475.23904",
        //                         "type": "isolated",
        //                         "value": "20"
        //                     },
        //                     "liquidationPx": "2125.00856238",
        //                     "marginUsed": "24.88097",
        //                     "maxLeverage": "50",
        //                     "positionValue": "500.12001",
        //                     "returnOnEquity": "0.0",
        //                     "szi": "0.2259",
        //                     "unrealizedPnl": "0.0"
        //                 },
        //                 "type": "oneWay"
        //             }
        //         ],
        //         "crossMaintenanceMarginUsed": "0.0",
        //         "crossMarginSummary": {
        //             "accountValue": "100.0",
        //             "totalMarginUsed": "0.0",
        //             "totalNtlPos": "0.0",
        //             "totalRawUsd": "100.0"
        //         },
        //         "marginSummary": {
        //             "accountValue": "100.0",
        //             "totalMarginUsed": "0.0",
        //             "totalNtlPos": "0.0",
        //             "totalRawUsd": "100.0"
        //         },
        //         "time": "1704261007014",
        //         "withdrawable": "100.0"
        //     }
        //
        object data = this.safeList(response, "assetPositions", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parsePosition(getValue(data, i), null));
        }
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         "position": {
        //             "coin": "ETH",
        //             "cumFunding": {
        //                 "allTime": "0.0",
        //                 "sinceChange": "0.0",
        //                 "sinceOpen": "0.0"
        //             },
        //             "entryPx": "2213.9",
        //             "leverage": {
        //                 "rawUsd": "-475.23904",
        //                 "type": "isolated",
        //                 "value": "20"
        //             },
        //             "liquidationPx": "2125.00856238",
        //             "marginUsed": "24.88097",
        //             "maxLeverage": "50",
        //             "positionValue": "500.12001",
        //             "returnOnEquity": "0.0",
        //             "szi": "0.2259",
        //             "unrealizedPnl": "0.0"
        //         },
        //         "type": "oneWay"
        //     }
        //
        object entry = this.safeDict(position, "position", new Dictionary<string, object>() {});
        object coin = this.safeString(entry, "coin");
        object marketId = add(coin, "/USDC:USDC");
        market = this.safeMarket(marketId, null);
        object symbol = getValue(market, "symbol");
        object leverage = this.safeDict(entry, "leverage", new Dictionary<string, object>() {});
        object isIsolated = (isEqual(this.safeString(leverage, "type"), "isolated"));
        object quantity = this.safeNumber(leverage, "rawUsd");
        object side = null;
        if (isTrue(!isEqual(quantity, null)))
        {
            side = ((bool) isTrue((isGreaterThan(quantity, 0)))) ? "short" : "long";
        }
        object unrealizedPnl = this.safeNumber(entry, "unrealizedPnl");
        object initialMargin = this.safeNumber(entry, "marginUsed");
        object percentage = multiply(divide(unrealizedPnl, initialMargin), 100);
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "isolated", isIsolated },
            { "hedged", null },
            { "side", side },
            { "contracts", this.parseNumber(quantity) },
            { "contractSize", null },
            { "entryPrice", this.safeNumber(entry, "entryPx") },
            { "markPrice", null },
            { "notional", this.safeNumber(entry, "positionValue") },
            { "leverage", this.safeNumber(leverage, "value") },
            { "collateral", null },
            { "initialMargin", initialMargin },
            { "maintenanceMargin", null },
            { "initialMarginPercentage", null },
            { "maintenanceMarginPercentage", null },
            { "unrealizedPnl", unrealizedPnl },
            { "liquidationPrice", this.safeNumber(entry, "liquidationPx") },
            { "marginMode", null },
            { "percentage", percentage },
        });
    }

    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#setMarginMode
        * @description set margin mode (symbol)
        * @param {string} marginMode margin mode must be either [isolated, cross]
        * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.leverage] the rate of leverage, is required if setting trade mode (symbol)
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object leverage = this.safeInteger(parameters, "leverage");
        if (isTrue(isEqual(leverage, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a leverage parameter")) ;
        }
        object asset = this.parseToInt(getValue(market, "baseId"));
        object isCross = (isEqual(marginMode, "isolated"));
        object nonce = this.milliseconds();
        parameters = this.omit(parameters, new List<object>() {"leverage"});
        object updateAction = new Dictionary<string, object>() {
            { "type", "updateLeverage" },
            { "asset", asset },
            { "isCross", isCross },
            { "leverage", leverage },
        };
        object vaultAddress = this.safeString(parameters, "vaultAddress");
        object signature = this.signL1Action(updateAction, nonce, vaultAddress);
        object request = new Dictionary<string, object>() {
            { "action", updateAction },
            { "nonce", nonce },
            { "signature", signature },
        };
        object response = await this.privatePostExchange(this.extend(request, parameters));
        //
        //     {
        //         'response': {
        //             'type': 'default'
        //         },
        //         'status': 'ok'
        //     }
        //
        return response;
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#setLeverage
        * @description set the level of leverage for a market
        * @param {float} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] margin mode must be either [isolated, cross], default is cross
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object marginMode = this.safeString(parameters, "marginMode", "cross");
        object isCross = (isEqual(marginMode, "cross"));
        object asset = this.parseToInt(getValue(market, "baseId"));
        object nonce = this.milliseconds();
        parameters = this.omit(parameters, "marginMode");
        object updateAction = new Dictionary<string, object>() {
            { "type", "updateLeverage" },
            { "asset", asset },
            { "isCross", isCross },
            { "leverage", leverage },
        };
        object vaultAddress = this.safeString(parameters, "vaultAddress");
        object signature = this.signL1Action(updateAction, nonce, vaultAddress);
        object request = new Dictionary<string, object>() {
            { "action", updateAction },
            { "nonce", nonce },
            { "signature", signature },
        };
        object response = await this.privatePostExchange(this.extend(request, parameters));
        //
        //     {
        //         'response': {
        //             'type': 'default'
        //         },
        //         'status': 'ok'
        //     }
        //
        return response;
    }

    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#addMargin
        * @description add margin
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#update-isolated-margin
        * @param {string} symbol unified market symbol
        * @param {float} amount amount of margin to add
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "add", parameters);
    }

    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#reduceMargin
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#update-isolated-margin
        * @description remove margin from a position
        * @param {string} symbol unified market symbol
        * @param {float} amount the amount of margin to remove
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "reduce", parameters);
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object asset = this.parseToInt(getValue(market, "baseId"));
        object sz = this.parseToInt(Precise.stringMul(this.amountToPrecision(symbol, amount), "1000000"));
        if (isTrue(isEqual(type, "reduce")))
        {
            sz = prefixUnaryNeg(ref sz);
        }
        object nonce = this.milliseconds();
        object updateAction = new Dictionary<string, object>() {
            { "type", "updateIsolatedMargin" },
            { "asset", asset },
            { "isBuy", true },
            { "ntli", sz },
        };
        object vaultAddress = this.safeString(parameters, "vaultAddress");
        object signature = this.signL1Action(updateAction, nonce, vaultAddress);
        object request = new Dictionary<string, object>() {
            { "action", updateAction },
            { "nonce", nonce },
            { "signature", signature },
        };
        object response = await this.privatePostExchange(this.extend(request, parameters));
        //
        //     {
        //         'response': {
        //             'type': 'default'
        //         },
        //         'status': 'ok'
        //     }
        //
        return response;
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#transfer
        * @description transfer currency internally between wallets on the same account
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#l1-usdc-transfer
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        await this.loadMarkets();
        this.checkAddress(toAccount);
        if (isTrue(!isEqual(code, null)))
        {
            code = ((string)code).ToUpper();
            if (isTrue(!isEqual(code, "USDC")))
            {
                throw new NotSupported ((string)add(this.id, "withdraw() only support USDC")) ;
            }
        }
        object isSandboxMode = this.safeBool(this.options, "sandboxMode");
        object nonce = this.milliseconds();
        object payload = new Dictionary<string, object>() {
            { "destination", toAccount },
            { "amount", ((object)amount).ToString() },
            { "time", nonce },
        };
        object sig = this.buildTransferSig(payload);
        object request = new Dictionary<string, object>() {
            { "action", new Dictionary<string, object>() {
                { "chain", ((bool) isTrue((isSandboxMode))) ? "ArbitrumTestnet" : "Arbitrum" },
                { "payload", payload },
                { "type", "usdTransfer" },
            } },
            { "nonce", nonce },
            { "signature", sig },
        };
        object response = await this.privatePostExchange(this.extend(request, parameters));
        return response;
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#withdraw
        * @description make a withdrawal (only support USDC)
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#initiate-a-withdrawal-request
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        await this.loadMarkets();
        this.checkAddress(address);
        if (isTrue(!isEqual(code, null)))
        {
            code = ((string)code).ToUpper();
            if (isTrue(!isEqual(code, "USDC")))
            {
                throw new NotSupported ((string)add(this.id, "withdraw() only support USDC")) ;
            }
        }
        object isSandboxMode = this.safeBool(this.options, "sandboxMode");
        object nonce = this.milliseconds();
        object payload = new Dictionary<string, object>() {
            { "destination", address },
            { "usd", ((object)amount).ToString() },
            { "time", nonce },
        };
        object sig = this.buildWithdrawSig(payload);
        object request = new Dictionary<string, object>() {
            { "action", new Dictionary<string, object>() {
                { "chain", ((bool) isTrue((isSandboxMode))) ? "ArbitrumTestnet" : "Arbitrum" },
                { "payload", payload },
                { "type", "withdraw2" },
            } },
            { "nonce", nonce },
            { "signature", sig },
        };
        object response = await this.privatePostExchange(this.extend(request, parameters));
        return response;
    }

    public virtual object handlePublicAddress(object methodName, object parameters)
    {
        object userAux = null;
        var userAuxparametersVariable = this.handleOptionAndParams(parameters, methodName, "user");
        userAux = ((IList<object>)userAuxparametersVariable)[0];
        parameters = ((IList<object>)userAuxparametersVariable)[1];
        object user = userAux;
        var userparametersVariable = this.handleOptionAndParams(parameters, methodName, "address", userAux);
        user = ((IList<object>)userparametersVariable)[0];
        parameters = ((IList<object>)userparametersVariable)[1];
        if (isTrue(!isEqual(user, null)))
        {
            return new List<object>() {user, parameters};
        }
        if (isTrue(!isEqual(this.walletAddress, null)))
        {
            return new List<object>() {this.walletAddress, parameters};
        }
        throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a user parameter inside \'params\' or the wallet address set")) ;
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        // {"status":"err","response":"User or API Wallet 0xb8a6f8b26223de27c31938d56e470a5b832703a5 does not exist."}
        //
        //     {
        //         status: 'ok',
        //         response: { type: 'order', data: { statuses: [ { error: 'Insufficient margin to place order. asset=4' } ] } }
        //     }
        //
        object status = this.safeString(response, "status", "");
        object message = null;
        if (isTrue(isEqual(status, "err")))
        {
            message = this.safeString(response, "response");
        } else
        {
            object responsePayload = this.safeDict(response, "response", new Dictionary<string, object>() {});
            object data = this.safeDict(responsePayload, "data", new Dictionary<string, object>() {});
            object statuses = this.safeList(data, "statuses", new List<object>() {});
            object firstStatus = this.safeDict(statuses, 0);
            message = this.safeString(firstStatus, "error");
        }
        object feedback = add(add(this.id, " "), body);
        object nonEmptyMessage = (isTrue((!isEqual(message, null))) && isTrue((!isEqual(message, ""))));
        if (isTrue(nonEmptyMessage))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
        }
        if (isTrue(nonEmptyMessage))
        {
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(this.implodeHostname(getValue(getValue(this.urls, "api"), api)), "/"), path);
        if (isTrue(isEqual(method, "POST")))
        {
            headers = new Dictionary<string, object>() {
                { "Content-Type", "application/json" },
            };
            body = this.json(parameters);
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }
}
