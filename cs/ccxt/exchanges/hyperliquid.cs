namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class hyperliquid : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "hyperliquid" },
            { "name", "Hyperliquid" },
            { "countries", new List<object>() {} },
            { "version", "v1" },
            { "rateLimit", 50 },
            { "certified", false },
            { "pro", true },
            { "dex", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", true },
                { "future", true },
                { "option", false },
                { "addMargin", true },
                { "borrowCrossMargin", false },
                { "borrowIsolatedMargin", false },
                { "cancelAllOrders", false },
                { "cancelAllOrdersAfter", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "cancelOrdersForSymbols", true },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createMarketBuyOrderWithCost", false },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", true },
                { "createReduceOnlyOrder", true },
                { "editOrder", true },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCanceledAndClosedOrders", true },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", false },
                { "fetchDepositAddresses", false },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLedger", true },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchLiquidations", false },
                { "fetchMarginMode", null },
                { "fetchMarketLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyLiquidations", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", false },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchOrderTrades", false },
                { "fetchPosition", true },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", "emulated" },
                { "fetchTickers", true },
                { "fetchTime", false },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", true },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", false },
                { "sandbox", true },
                { "setLeverage", true },
                { "setMarginMode", true },
                { "setPositionMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "8h", "8h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "3d", "3d" },
                { "1w", "1w" },
                { "1M", "1M" },
            } },
            { "hostname", "hyperliquid.xyz" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/ccxt/ccxt/assets/43336371/b371bc6c-4a8c-489f-87f4-20a913dd8d4b" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.{hostname}" },
                    { "private", "https://api.{hostname}" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "public", "https://api.hyperliquid-testnet.xyz" },
                    { "private", "https://api.hyperliquid-testnet.xyz" },
                } },
                { "www", "https://hyperliquid.xyz" },
                { "doc", "https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api" },
                { "fees", "https://hyperliquid.gitbook.io/hyperliquid-docs/trading/fees" },
                { "referral", "https://app.hyperliquid.xyz/" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "post", new Dictionary<string, object>() {
                        { "info", new Dictionary<string, object>() {
                            { "cost", 20 },
                            { "byType", new Dictionary<string, object>() {
                                { "l2Book", 2 },
                                { "allMids", 2 },
                                { "clearinghouseState", 2 },
                                { "orderStatus", 2 },
                                { "spotClearinghouseState", 2 },
                                { "exchangeStatus", 2 },
                            } },
                        } },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "post", new Dictionary<string, object>() {
                        { "exchange", 1 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "swap", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.00035") },
                    { "maker", this.parseNumber("0.0001") },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.00035") },
                    { "maker", this.parseNumber("0.0001") },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", false },
                { "secret", false },
                { "walletAddress", true },
                { "privateKey", true },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {} },
                { "broad", new Dictionary<string, object>() {
                    { "Price must be divisible by tick size.", typeof(InvalidOrder) },
                    { "Order must have minimum value of $10", typeof(InvalidOrder) },
                    { "Insufficient margin to place order.", typeof(InvalidOrder) },
                    { "Reduce only order would increase position.", typeof(InvalidOrder) },
                    { "Post only order would have immediately matched,", typeof(InvalidOrder) },
                    { "Order could not immediately match against any resting orders.", typeof(InvalidOrder) },
                    { "Invalid TP/SL price.", typeof(InvalidOrder) },
                    { "No liquidity available for market order.", typeof(InvalidOrder) },
                    { "Order was never placed, already canceled, or filled.", typeof(OrderNotFound) },
                    { "User or API Wallet ", typeof(InvalidOrder) },
                    { "Order has invalid size", typeof(InvalidOrder) },
                    { "Order price cannot be more than 80% away from the reference price", typeof(InvalidOrder) },
                } },
            } },
            { "precisionMode", DECIMAL_PLACES },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "options", new Dictionary<string, object>() {
                { "defaultType", "swap" },
                { "sandboxMode", false },
                { "defaultSlippage", 0.05 },
                { "zeroAddress", "0x0000000000000000000000000000000000000000" },
            } },
        });
    }

    public override void setSandboxMode(object enabled)
    {
        base.setSandboxMode(enabled);
        ((IDictionary<string,object>)this.options)["sandboxMode"] = enabled;
    }

    /**
     * @method
     * @name hyperliquid#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-perpetuals-metadata
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", "meta" },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "universe": [
        //                 {
        //                     "maxLeverage": 50,
        //                     "name": "SOL",
        //                     "onlyIsolated": false,
        //                     "szDecimals": 2
        //                 }
        //             ]
        //         }
        //     ]
        //
        object meta = this.safeList(response, "universe", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(meta)); postFixIncrement(ref i))
        {
            object data = this.safeDict(meta, i, new Dictionary<string, object>() {});
            object id = i;
            object name = this.safeString(data, "name");
            object code = this.safeCurrencyCode(name);
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "name", name },
                { "code", code },
                { "precision", null },
                { "info", data },
                { "active", null },
                { "deposit", null },
                { "withdraw", null },
                { "networks", null },
                { "fee", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
            };
        }
        return result;
    }

    /**
     * @method
     * @name hyperliquid#fetchMarkets
     * @description retrieves data on all markets for hyperliquid
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-perpetuals-asset-contexts-includes-mark-price-current-funding-open-interest-etc
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/spot#retrieve-spot-asset-contexts
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object rawPromises = new List<object> {this.fetchSwapMarkets(parameters), this.fetchSpotMarkets(parameters)};
        object promises = await promiseAll(rawPromises);
        object swapMarkets = getValue(promises, 0);
        object spotMarkets = getValue(promises, 1);
        return this.arrayConcat(swapMarkets, spotMarkets);
    }

    /**
     * @method
     * @name hyperliquid#fetchMarkets
     * @description retrieves data on all swap markets for hyperliquid
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-perpetuals-asset-contexts-includes-mark-price-current-funding-open-interest-etc
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async virtual Task<object> fetchSwapMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", "metaAndAssetCtxs" },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "universe": [
        //                 {
        //                     "maxLeverage": 50,
        //                     "name": "SOL",
        //                     "onlyIsolated": false,
        //                     "szDecimals": 2
        //                 }
        //             ]
        //         },
        //         [
        //             {
        //                 "dayNtlVlm": "9450588.2273",
        //                 "funding": "0.0000198",
        //                 "impactPxs": [
        //                     "108.04",
        //                     "108.06"
        //                 ],
        //                 "markPx": "108.04",
        //                 "midPx": "108.05",
        //                 "openInterest": "10764.48",
        //                 "oraclePx": "107.99",
        //                 "premium": "0.00055561",
        //                 "prevDayPx": "111.81"
        //             }
        //         ]
        //     ]
        //
        //
        object meta = this.safeDict(response, 0, new Dictionary<string, object>() {});
        object universe = this.safeList(meta, "universe", new List<object>() {});
        object assetCtxs = this.safeList(response, 1, new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(universe)); postFixIncrement(ref i))
        {
            object data = this.extend(this.safeDict(universe, i, new Dictionary<string, object>() {}), this.safeDict(assetCtxs, i, new Dictionary<string, object>() {}));
            ((IDictionary<string,object>)data)["baseId"] = i;
            ((IList<object>)result).Add(data);
        }
        return this.parseMarkets(result);
    }

    /**
     * @method
     * @name hyperliquid#fetchMarkets
     * @description retrieves data on all spot markets for hyperliquid
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/spot#retrieve-spot-asset-contexts
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async virtual Task<object> fetchSpotMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", "spotMetaAndAssetCtxs" },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        // [
        //     {
        //         "tokens": [
        //             {
        //                 "name": "USDC",
        //                 "szDecimals": 8,
        //                 "weiDecimals" 8,
        //                 "index": 0,
        //                 "tokenId": "0x6d1e7cde53ba9467b783cb7c530ce054",
        //                 "isCanonical": true,
        //                 "evmContract":null,
        //                 "fullName":null
        //             },
        //             {
        //                 "name": "PURR",
        //                 "szDecimals": 0,
        //                 "weiDecimals": 5,
        //                 "index": 1,
        //                 "tokenId": "0xc1fb593aeffbeb02f85e0308e9956a90",
        //                 "isCanonical": true,
        //                 "evmContract":null,
        //                 "fullName":null
        //             }
        //         ],
        //         "universe": [
        //             {
        //                 "name": "PURR/USDC",
        //                 "tokens": [1, 0],
        //                 "index": 0,
        //                 "isCanonical": true
        //             }
        //         ]
        //     },
        //     [
        //         {
        //             "dayNtlVlm":"8906.0",
        //             "markPx":"0.14",
        //             "midPx":"0.209265",
        //             "prevDayPx":"0.20432"
        //         }
        //     ]
        // ]
        //
        object first = this.safeDict(response, 0, new Dictionary<string, object>() {});
        object second = this.safeList(response, 1, new List<object>() {});
        object meta = this.safeList(first, "universe", new List<object>() {});
        object tokens = this.safeList(first, "tokens", new List<object>() {});
        object markets = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(meta)); postFixIncrement(ref i))
        {
            object market = this.safeDict(meta, i, new Dictionary<string, object>() {});
            object index = this.safeInteger(market, "index");
            object extraData = this.safeDict(second, index, new Dictionary<string, object>() {});
            object marketName = this.safeString(market, "name");
            // if (marketName.indexOf ('/') < 0) {
            //     // there are some weird spot markets in testnet, eg @2
            //     continue;
            // }
            // const marketParts = marketName.split ('/');
            // const baseName = this.safeString (marketParts, 0);
            // const quoteId = this.safeString (marketParts, 1);
            object fees = this.safeDict(this.fees, "spot", new Dictionary<string, object>() {});
            object taker = this.safeNumber(fees, "taker");
            object maker = this.safeNumber(fees, "maker");
            object tokensPos = this.safeList(market, "tokens", new List<object>() {});
            object baseTokenPos = this.safeInteger(tokensPos, 0);
            object quoteTokenPos = this.safeInteger(tokensPos, 1);
            object baseTokenInfo = this.safeDict(tokens, baseTokenPos, new Dictionary<string, object>() {});
            object quoteTokenInfo = this.safeDict(tokens, quoteTokenPos, new Dictionary<string, object>() {});
            object baseName = this.safeString(baseTokenInfo, "name");
            object quoteId = this.safeString(quoteTokenInfo, "name");
            object bs = this.safeCurrencyCode(baseName);
            object quote = this.safeCurrencyCode(quoteId);
            object symbol = add(add(bs, "/"), quote);
            object innerBaseTokenInfo = this.safeDict(baseTokenInfo, "spec", baseTokenInfo);
            // const innerQuoteTokenInfo = this.safeDict (quoteTokenInfo, 'spec', quoteTokenInfo);
            object amountPrecision = this.safeInteger(innerBaseTokenInfo, "szDecimals");
            // const quotePrecision = this.parseNumber (this.parsePrecision (this.safeString (innerQuoteTokenInfo, 'szDecimals')));
            object baseId = this.numberToString(add(i, 10000));
            ((IList<object>)markets).Add(this.safeMarketStructure(new Dictionary<string, object>() {
                { "id", marketName },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "subType", null },
                { "margin", null },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", true },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", taker },
                { "maker", maker },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", amountPrecision },
                    { "price", subtract(8, amountPrecision) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.parseNumber("10") },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", this.extend(extraData, market) },
            }));
        }
        return markets;
    }

    public override object parseMarket(object market)
    {
        //
        //     {
        //         "maxLeverage": "50",
        //         "name": "ETH",
        //         "onlyIsolated": false,
        //         "szDecimals": "4",
        //         "dayNtlVlm": "1709813.11535",
        //         "funding": "0.00004807",
        //         "impactPxs": [
        //             "2369.3",
        //             "2369.6"
        //         ],
        //         "markPx": "2369.6",
        //         "midPx": "2369.45",
        //         "openInterest": "1815.4712",
        //         "oraclePx": "2367.3",
        //         "premium": "0.00090821",
        //         "prevDayPx": "2381.5"
        //     }
        //
        object quoteId = "USDC";
        object bs = this.safeString(market, "name");
        object quote = this.safeCurrencyCode(quoteId);
        object baseId = this.safeString(market, "baseId");
        object settleId = "USDC";
        object settle = this.safeCurrencyCode(settleId);
        object symbol = add(add(bs, "/"), quote);
        object contract = true;
        object swap = true;
        if (isTrue(contract))
        {
            if (isTrue(swap))
            {
                symbol = add(add(symbol, ":"), settle);
            }
        }
        object fees = this.safeDict(this.fees, "swap", new Dictionary<string, object>() {});
        object taker = this.safeNumber(fees, "taker");
        object maker = this.safeNumber(fees, "maker");
        object amountPrecision = this.safeInteger(market, "szDecimals");
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", baseId },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", "swap" },
            { "spot", false },
            { "margin", null },
            { "swap", swap },
            { "future", false },
            { "option", false },
            { "active", true },
            { "contract", contract },
            { "linear", true },
            { "inverse", false },
            { "taker", taker },
            { "maker", maker },
            { "contractSize", this.parseNumber("1") },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", amountPrecision },
                { "price", subtract(6, amountPrecision) },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", this.safeInteger(market, "maxLeverage") },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", this.parseNumber("10") },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        });
    }

    /**
     * @method
     * @name hyperliquid#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/spot#retrieve-a-users-token-balances
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-users-perpetuals-account-summary
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @param {string} [params.type] wallet type, ['spot', 'swap'], defaults to swap
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchBalance", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object isSpot = (isEqual(type, "spot"));
        object reqType = ((bool) isTrue((isSpot))) ? "spotClearinghouseState" : "clearinghouseState";
        object request = new Dictionary<string, object>() {
            { "type", reqType },
            { "user", userAddress },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     {
        //         "assetPositions": [],
        //         "crossMaintenanceMarginUsed": "0.0",
        //         "crossMarginSummary": {
        //             "accountValue": "100.0",
        //             "totalMarginUsed": "0.0",
        //             "totalNtlPos": "0.0",
        //             "totalRawUsd": "100.0"
        //         },
        //         "marginSummary": {
        //             "accountValue": "100.0",
        //             "totalMarginUsed": "0.0",
        //             "totalNtlPos": "0.0",
        //             "totalRawUsd": "100.0"
        //         },
        //         "time": "1704261007014",
        //         "withdrawable": "100.0"
        //     }
        // spot
        //
        //     {
        //         "balances":[
        //            {
        //               "coin":"USDC",
        //               "hold":"0.0",
        //               "total":"1481.844"
        //            },
        //            {
        //               "coin":"PURR",
        //               "hold":"0.0",
        //               "total":"999.65004"
        //            }
        //     }
        //
        object balances = this.safeList(response, "balances");
        if (isTrue(!isEqual(balances, null)))
        {
            object spotBalances = new Dictionary<string, object>() {
                { "info", response },
            };
            for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
            {
                object balance = getValue(balances, i);
                object code = this.safeCurrencyCode(this.safeString(balance, "coin"));
                object account = this.account();
                object total = this.safeString(balance, "total");
                object used = this.safeString(balance, "hold");
                ((IDictionary<string,object>)account)["total"] = total;
                ((IDictionary<string,object>)account)["used"] = used;
                ((IDictionary<string,object>)spotBalances)[(string)code] = account;
            }
            return this.safeBalance(spotBalances);
        }
        object data = this.safeDict(response, "marginSummary", new Dictionary<string, object>() {});
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "USDC", new Dictionary<string, object>() {
                { "total", this.safeNumber(data, "accountValue") },
                { "free", this.safeNumber(response, "withdrawable") },
            } },
        };
        object timestamp = this.safeInteger(response, "time");
        ((IDictionary<string,object>)result)["timestamp"] = timestamp;
        ((IDictionary<string,object>)result)["datetime"] = this.iso8601(timestamp);
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name hyperliquid#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#l2-book-snapshot
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "type", "l2Book" },
            { "coin", ((bool) isTrue(getValue(market, "swap"))) ? getValue(market, "base") : getValue(market, "id") },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     {
        //         "coin": "ETH",
        //         "levels": [
        //             [
        //                 {
        //                     "n": "2",
        //                     "px": "2216.2",
        //                     "sz": "74.0637"
        //                 }
        //             ],
        //             [
        //                 {
        //                     "n": "2",
        //                     "px": "2216.5",
        //                     "sz": "70.5893"
        //                 }
        //             ]
        //         ],
        //         "time": "1704290104840"
        //     }
        //
        object data = this.safeList(response, "levels", new List<object>() {});
        object result = new Dictionary<string, object>() {
            { "bids", this.safeList(data, 0, new List<object>() {}) },
            { "asks", this.safeList(data, 1, new List<object>() {}) },
        };
        object timestamp = this.safeInteger(response, "time");
        return this.parseOrderBook(result, getValue(market, "symbol"), timestamp, "bids", "asks", "px", "sz");
    }

    /**
     * @method
     * @name hyperliquid#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-perpetuals-asset-contexts-includes-mark-price-current-funding-open-interest-etc
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/spot#retrieve-spot-asset-contexts
     * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] 'spot' or 'swap', by default fetches both
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        // at this stage, to get tickers data, we use fetchMarkets endpoints
        object response = new List<object>() {};
        object type = this.safeString(parameters, "type");
        parameters = this.omit(parameters, "type");
        if (isTrue(isEqual(type, "spot")))
        {
            response = await this.fetchSpotMarkets(parameters);
        } else if (isTrue(isEqual(type, "swap")))
        {
            response = await this.fetchSwapMarkets(parameters);
        } else
        {
            response = await this.fetchMarkets(parameters);
        }
        // same response as under "fetchMarkets"
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object market = getValue(response, i);
            object info = getValue(market, "info");
            object ticker = this.parseTicker(info, market);
            object symbol = this.safeString(ticker, "symbol");
            ((IDictionary<string,object>)result)[(string)symbol] = ticker;
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    /**
     * @method
     * @name hyperliquid#fetchFundingRates
     * @description retrieves data on all swap markets for hyperliquid
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-perpetuals-asset-contexts-includes-mark-price-current-funding-open-interest-etc
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", "metaAndAssetCtxs" },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "universe": [
        //                 {
        //                     "maxLeverage": 50,
        //                     "name": "SOL",
        //                     "onlyIsolated": false,
        //                     "szDecimals": 2
        //                 }
        //             ]
        //         },
        //         [
        //             {
        //                 "dayNtlVlm": "9450588.2273",
        //                 "funding": "0.0000198",
        //                 "impactPxs": [
        //                     "108.04",
        //                     "108.06"
        //                 ],
        //                 "markPx": "108.04",
        //                 "midPx": "108.05",
        //                 "openInterest": "10764.48",
        //                 "oraclePx": "107.99",
        //                 "premium": "0.00055561",
        //                 "prevDayPx": "111.81"
        //             }
        //         ]
        //     ]
        //
        //
        object meta = this.safeDict(response, 0, new Dictionary<string, object>() {});
        object universe = this.safeList(meta, "universe", new List<object>() {});
        object assetCtxs = this.safeList(response, 1, new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(universe)); postFixIncrement(ref i))
        {
            object data = this.extend(this.safeDict(universe, i, new Dictionary<string, object>() {}), this.safeDict(assetCtxs, i, new Dictionary<string, object>() {}));
            ((IList<object>)result).Add(data);
        }
        object funding_rates = this.parseFundingRates(result);
        return this.filterByArray(funding_rates, "symbol", symbols);
    }

    public override object parseFundingRate(object info, object market = null)
    {
        //
        //     {
        //         "maxLeverage": "50",
        //         "name": "ETH",
        //         "onlyIsolated": false,
        //         "szDecimals": "4",
        //         "dayNtlVlm": "1709813.11535",
        //         "funding": "0.00004807",
        //         "impactPxs": [
        //             "2369.3",
        //             "2369.6"
        //         ],
        //         "markPx": "2369.6",
        //         "midPx": "2369.45",
        //         "openInterest": "1815.4712",
        //         "oraclePx": "2367.3",
        //         "premium": "0.00090821",
        //         "prevDayPx": "2381.5"
        //     }
        //
        object bs = this.safeString(info, "name");
        object marketId = this.coinToMarketId(bs);
        object symbol = this.safeSymbol(marketId, market);
        object funding = this.safeNumber(info, "funding");
        object markPx = this.safeNumber(info, "markPx");
        object oraclePx = this.safeNumber(info, "oraclePx");
        object fundingTimestamp = multiply(multiply(multiply((add((Math.Floor(Double.Parse((divide(divide(divide(this.milliseconds(), 60), 60), 1000)).ToString()))), 1)), 60), 60), 1000);
        return new Dictionary<string, object>() {
            { "info", info },
            { "symbol", symbol },
            { "markPrice", markPx },
            { "indexPrice", oraclePx },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", funding },
            { "fundingTimestamp", fundingTimestamp },
            { "fundingDatetime", this.iso8601(fundingTimestamp) },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", "1h" },
        };
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "prevDayPx": "3400.5",
        //         "dayNtlVlm": "511297257.47936022",
        //         "markPx": "3464.7",
        //         "midPx": "3465.05",
        //         "oraclePx": "3460.1", // only in swap
        //         "openInterest": "64638.1108", // only in swap
        //         "premium": "0.00141614", // only in swap
        //         "funding": "0.00008727", // only in swap
        //         "impactPxs": [ "3465.0", "3465.1" ], // only in swap
        //         "coin": "PURR", // only in spot
        //         "circulatingSupply": "998949190.03400207", // only in spot
        //     },
        //
        object bidAsk = this.safeList(ticker, "impactPxs");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", null },
            { "datetime", null },
            { "previousClose", this.safeNumber(ticker, "prevDayPx") },
            { "close", this.safeNumber(ticker, "midPx") },
            { "bid", this.safeNumber(bidAsk, 0) },
            { "ask", this.safeNumber(bidAsk, 1) },
            { "quoteVolume", this.safeNumber(ticker, "dayNtlVlm") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name hyperliquid#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#candle-snapshot
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents, support '1m', '15m', '1h', '1d'
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object until = this.safeInteger(parameters, "until", this.milliseconds());
        object useTail = isEqual(since, null);
        object originalSince = since;
        if (isTrue(isEqual(since, null)))
        {
            if (isTrue(!isEqual(limit, null)))
            {
                // optimization if limit is provided
                object timeframeInMilliseconds = multiply(this.parseTimeframe(timeframe), 1000);
                since = this.sum(until, multiply(multiply(timeframeInMilliseconds, limit), -1));
                useTail = false;
            } else
            {
                since = 0;
            }
        }
        parameters = this.omit(parameters, new List<object>() {"until"});
        object request = new Dictionary<string, object>() {
            { "type", "candleSnapshot" },
            { "req", new Dictionary<string, object>() {
                { "coin", ((bool) isTrue(getValue(market, "swap"))) ? getValue(market, "base") : getValue(market, "id") },
                { "interval", this.safeString(this.timeframes, timeframe, timeframe) },
                { "startTime", since },
                { "endTime", until },
            } },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "T": 1704287699999,
        //             "c": "2226.4",
        //             "h": "2247.9",
        //             "i": "15m",
        //             "l": "2224.6",
        //             "n": 46,
        //             "o": "2247.9",
        //             "s": "ETH",
        //             "t": 1704286800000,
        //             "v": "591.6427"
        //         }
        //     ]
        //
        return this.parseOHLCVs(response, market, timeframe, originalSince, limit, useTail);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "T": 1704287699999,
        //         "c": "2226.4",
        //         "h": "2247.9",
        //         "i": "15m",
        //         "l": "2224.6",
        //         "n": 46,
        //         "o": "2247.9",
        //         "s": "ETH",
        //         "t": 1704286800000,
        //         "v": "591.6427"
        //     }
        //
        return new List<object> {this.safeInteger(ohlcv, "t"), this.safeNumber(ohlcv, "o"), this.safeNumber(ohlcv, "h"), this.safeNumber(ohlcv, "l"), this.safeNumber(ohlcv, "c"), this.safeNumber(ohlcv, "v")};
    }

    /**
     * @method
     * @name hyperliquid#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills-by-time
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest trade
     * @param {string} [params.address] wallet address that made trades
     * @param {string} [params.user] wallet address that made trades
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchTrades", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        await this.loadMarkets();
        object market = this.safeMarket(symbol);
        object request = new Dictionary<string, object>() {
            { "user", userAddress },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["type"] = "userFillsByTime";
            ((IDictionary<string,object>)request)["startTime"] = since;
        } else
        {
            ((IDictionary<string,object>)request)["type"] = "userFills";
        }
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "closedPnl": "0.19343",
        //             "coin": "ETH",
        //             "crossed": true,
        //             "dir": "Close Long",
        //             "fee": "0.050062",
        //             "hash": "0x09d77c96791e98b5775a04092584ab010d009445119c71e4005c0d634ea322bc",
        //             "liquidationMarkPx": null,
        //             "oid": 3929354691,
        //             "px": "2381.1",
        //             "side": "A",
        //             "startPosition": "0.0841",
        //             "sz": "0.0841",
        //             "tid": 128423918764978,
        //             "time": 1704262888911
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public override object amountToPrecision(object symbol, object amount)
    {
        object market = this.market(symbol);
        return this.decimalToPrecision(amount, ROUND, getValue(getValue(market, "precision"), "amount"), this.precisionMode, this.paddingMode);
    }

    public override object priceToPrecision(object symbol, object price)
    {
        object market = this.market(symbol);
        // https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/tick-and-lot-size
        object result = this.decimalToPrecision(price, ROUND, 5, SIGNIFICANT_DIGITS, this.paddingMode);
        object decimalParsedResult = this.decimalToPrecision(result, ROUND, getValue(getValue(market, "precision"), "price"), this.precisionMode, this.paddingMode);
        return decimalParsedResult;
    }

    public virtual object hashMessage(object message)
    {
        return add("0x", this.hash(message, keccak, "hex"));
    }

    public virtual object signHash(object hash, object privateKey)
    {
        object signature = ecdsa(slice(hash, -64, null), slice(privateKey, -64, null), secp256k1, null);
        return new Dictionary<string, object>() {
            { "r", add("0x", getValue(signature, "r")) },
            { "s", add("0x", getValue(signature, "s")) },
            { "v", this.sum(27, getValue(signature, "v")) },
        };
    }

    public virtual object signMessage(object message, object privateKey)
    {
        return this.signHash(this.hashMessage(message), slice(privateKey, -64, null));
    }

    public virtual object constructPhantomAgent(object hash, object isTestnet = null)
    {
        isTestnet ??= true;
        object source = ((bool) isTrue((isTestnet))) ? "b" : "a";
        return new Dictionary<string, object>() {
            { "source", source },
            { "connectionId", hash },
        };
    }

    public virtual object actionHash(object action, object vaultAddress, object nonce)
    {
        object dataBinary = this.packb(action);
        object dataHex = this.binaryToBase16(dataBinary);
        object data = dataHex;
        data = add(data, add("00000", this.intToBase16(nonce)));
        if (isTrue(isEqual(vaultAddress, null)))
        {
            data = add(data, "00");
        } else
        {
            data = add(data, "01");
            data = add(data, vaultAddress);
        }
        return this.hash(this.base16ToBinary(data), keccak, "binary");
    }

    public virtual object signL1Action(object action, object nonce, object vaultAdress = null)
    {
        object hash = this.actionHash(action, vaultAdress, nonce);
        object isTestnet = this.safeBool(this.options, "sandboxMode", false);
        object phantomAgent = this.constructPhantomAgent(hash, isTestnet);
        // const data: Dict = {
        //     'domain': {
        //         'chainId': 1337,
        //         'name': 'Exchange',
        //         'verifyingContract': '0x0000000000000000000000000000000000000000',
        //         'version': '1',
        //     },
        //     'types': {
        //         'Agent': [
        //             { 'name': 'source', 'type': 'string' },
        //             { 'name': 'connectionId', 'type': 'bytes32' },
        //         ],
        //         'EIP712Domain': [
        //             { 'name': 'name', 'type': 'string' },
        //             { 'name': 'version', 'type': 'string' },
        //             { 'name': 'chainId', 'type': 'uint256' },
        //             { 'name': 'verifyingContract', 'type': 'address' },
        //         ],
        //     },
        //     'primaryType': 'Agent',
        //     'message': phantomAgent,
        // };
        object zeroAddress = this.safeString(this.options, "zeroAddress");
        object chainId = 1337; // check this out
        object domain = new Dictionary<string, object>() {
            { "chainId", chainId },
            { "name", "Exchange" },
            { "verifyingContract", zeroAddress },
            { "version", "1" },
        };
        object messageTypes = new Dictionary<string, object>() {
            { "Agent", new List<object>() {new Dictionary<string, object>() {
    { "name", "source" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "connectionId" },
    { "type", "bytes32" },
}} },
        };
        object msg = this.ethEncodeStructuredData(domain, messageTypes, phantomAgent);
        object signature = this.signMessage(msg, this.privateKey);
        return signature;
    }

    public virtual object signUserSignedAction(object messageTypes, object message)
    {
        object zeroAddress = this.safeString(this.options, "zeroAddress");
        object chainId = 421614; // check this out
        object domain = new Dictionary<string, object>() {
            { "chainId", chainId },
            { "name", "HyperliquidSignTransaction" },
            { "verifyingContract", zeroAddress },
            { "version", "1" },
        };
        object msg = this.ethEncodeStructuredData(domain, messageTypes, message);
        object signature = this.signMessage(msg, this.privateKey);
        return signature;
    }

    public virtual object buildTransferSig(object message)
    {
        object messageTypes = new Dictionary<string, object>() {
            { "HyperliquidTransaction:UsdSend", new List<object>() {new Dictionary<string, object>() {
    { "name", "hyperliquidChain" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "destination" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "amount" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "time" },
    { "type", "uint64" },
}} },
        };
        return this.signUserSignedAction(messageTypes, message);
    }

    public virtual object buildWithdrawSig(object message)
    {
        object messageTypes = new Dictionary<string, object>() {
            { "HyperliquidTransaction:Withdraw", new List<object>() {new Dictionary<string, object>() {
    { "name", "hyperliquidChain" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "destination" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "amount" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "time" },
    { "type", "uint64" },
}} },
        };
        return this.signUserSignedAction(messageTypes, message);
    }

    /**
     * @method
     * @name hyperliquid#createOrder
     * @description create a trade order
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#place-an-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.timeInForce] 'Gtc', 'Ioc', 'Alo'
     * @param {bool} [params.postOnly] true or false whether the order is post-only
     * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only
     * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
     * @param {string} [params.clientOrderId] client order id, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
     * @param {string} [params.slippage] the slippage for market order
     * @param {string} [params.vaultAddress] the vault address for order
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        var orderglobalParamsVariable = this.parseCreateOrderArgs(symbol, type, side, amount, price, parameters);
        var order = ((IList<object>) orderglobalParamsVariable)[0];
        var globalParams = ((IList<object>) orderglobalParamsVariable)[1];
        object orders = await this.createOrders(new List<object>() {((object)order)}, globalParams);
        return getValue(orders, 0);
    }

    /**
     * @method
     * @name hyperliquid#createOrders
     * @description create a list of trade orders
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#place-an-order
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = this.createOrdersRequest(orders, parameters);
        object response = await this.privatePostExchange(request);
        //
        //     {
        //         "status": "ok",
        //         "response": {
        //             "type": "order",
        //             "data": {
        //                 "statuses": [
        //                     {
        //                         "resting": {
        //                             "oid": 5063830287
        //                         }
        //                     }
        //                 ]
        //             }
        //         }
        //     }
        //
        object responseObj = this.safeDict(response, "response", new Dictionary<string, object>() {});
        object data = this.safeDict(responseObj, "data", new Dictionary<string, object>() {});
        object statuses = this.safeList(data, "statuses", new List<object>() {});
        return this.parseOrders(statuses, null);
    }

    public virtual object createOrdersRequest(object orders, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#createOrders
        * @description create a list of trade orders
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#place-an-order
        * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object defaultSlippage = this.safeString(this.options, "defaultSlippage");
        defaultSlippage = this.safeString(parameters, "slippage", defaultSlippage);
        object hasClientOrderId = false;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object clientOrderId = this.safeString2(orderParams, "clientOrderId", "client_id");
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                hasClientOrderId = true;
            }
        }
        if (isTrue(hasClientOrderId))
        {
            for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
            {
                object rawOrder = getValue(orders, i);
                object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
                object clientOrderId = this.safeString2(orderParams, "clientOrderId", "client_id");
                if (isTrue(isEqual(clientOrderId, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " createOrders() all orders must have clientOrderId if at least one has a clientOrderId")) ;
                }
            }
        }
        parameters = this.omit(parameters, new List<object>() {"slippage", "clientOrderId", "client_id", "slippage", "triggerPrice", "stopPrice", "stopLossPrice", "takeProfitPrice", "timeInForce"});
        object nonce = this.milliseconds();
        object orderReq = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            object market = this.market(marketId);
            object symbol = getValue(market, "symbol");
            object type = this.safeStringUpper(rawOrder, "type");
            object isMarket = (isEqual(type, "MARKET"));
            object side = this.safeStringUpper(rawOrder, "side");
            object isBuy = (isEqual(side, "BUY"));
            object amount = this.safeString(rawOrder, "amount");
            object price = this.safeString(rawOrder, "price");
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object clientOrderId = this.safeString2(orderParams, "clientOrderId", "client_id");
            object slippage = this.safeString(orderParams, "slippage", defaultSlippage);
            object defaultTimeInForce = ((bool) isTrue((isMarket))) ? "ioc" : "gtc";
            object postOnly = this.safeBool(orderParams, "postOnly", false);
            if (isTrue(postOnly))
            {
                defaultTimeInForce = "alo";
            }
            object timeInForce = this.safeStringLower(orderParams, "timeInForce", defaultTimeInForce);
            timeInForce = this.capitalize(timeInForce);
            object triggerPrice = this.safeString2(orderParams, "triggerPrice", "stopPrice");
            object stopLossPrice = this.safeString(orderParams, "stopLossPrice", triggerPrice);
            object takeProfitPrice = this.safeString(orderParams, "takeProfitPrice");
            object isTrigger = (isTrue(stopLossPrice) || isTrue(takeProfitPrice));
            object px = null;
            if (isTrue(isMarket))
            {
                if (isTrue(isEqual(price, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, "  market orders require price to calculate the max slippage price. Default slippage can be set in options (default is 5%).")) ;
                }
                px = ((bool) isTrue((isBuy))) ? Precise.stringMul(price, Precise.stringAdd("1", slippage)) : Precise.stringMul(price, Precise.stringSub("1", slippage));
                px = this.priceToPrecision(symbol, px); // round after adding slippage
            } else
            {
                px = this.priceToPrecision(symbol, price);
            }
            object sz = this.amountToPrecision(symbol, amount);
            object reduceOnly = this.safeBool(orderParams, "reduceOnly", false);
            object orderType = new Dictionary<string, object>() {};
            if (isTrue(isTrigger))
            {
                object isTp = false;
                if (isTrue(!isEqual(takeProfitPrice, null)))
                {
                    triggerPrice = this.priceToPrecision(symbol, takeProfitPrice);
                    isTp = true;
                } else
                {
                    triggerPrice = this.priceToPrecision(symbol, stopLossPrice);
                }
                ((IDictionary<string,object>)orderType)["trigger"] = new Dictionary<string, object>() {
                    { "isMarket", isMarket },
                    { "triggerPx", triggerPrice },
                    { "tpsl", ((bool) isTrue((isTp))) ? "tp" : "sl" },
                };
            } else
            {
                ((IDictionary<string,object>)orderType)["limit"] = new Dictionary<string, object>() {
                    { "tif", timeInForce },
                };
            }
            orderParams = this.omit(orderParams, new List<object>() {"clientOrderId", "slippage", "triggerPrice", "stopPrice", "stopLossPrice", "takeProfitPrice", "timeInForce", "client_id", "reduceOnly", "postOnly"});
            object orderObj = new Dictionary<string, object>() {
                { "a", this.parseToInt(getValue(market, "baseId")) },
                { "b", isBuy },
                { "p", px },
                { "s", sz },
                { "r", reduceOnly },
                { "t", orderType },
            };
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)orderObj)["c"] = clientOrderId;
            }
            ((IList<object>)orderReq).Add(orderObj);
        }
        object vaultAddress = this.formatVaultAddress(this.safeString(parameters, "vaultAddress"));
        object orderAction = new Dictionary<string, object>() {
            { "type", "order" },
            { "orders", orderReq },
            { "grouping", "na" },
        };
        if (isTrue(isEqual(vaultAddress, null)))
        {
            ((IDictionary<string,object>)orderAction)["brokerCode"] = 1;
        }
        object signature = this.signL1Action(orderAction, nonce, vaultAddress);
        object request = new Dictionary<string, object>() {
            { "action", orderAction },
            { "nonce", nonce },
            { "signature", signature },
        };
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            parameters = this.omit(parameters, "vaultAddress");
            ((IDictionary<string,object>)request)["vaultAddress"] = vaultAddress;
        }
        return request;
    }

    /**
     * @method
     * @name hyperliquid#cancelOrder
     * @description cancels an open order
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s-by-cloid
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] client order id, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
     * @param {string} [params.vaultAddress] the vault address for order
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object orders = await this.cancelOrders(new List<object>() {id}, symbol, parameters);
        return this.safeDict(orders, 0);
    }

    /**
     * @method
     * @name hyperliquid#cancelOrders
     * @description cancel multiple orders
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s-by-cloid
     * @param {string[]} ids order ids
     * @param {string} [symbol] unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string|string[]} [params.clientOrderId] client order ids, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
     * @param {string} [params.vaultAddress] the vault address
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object clientOrderId = this.safeValue2(parameters, "clientOrderId", "client_id");
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "client_id"});
        object nonce = this.milliseconds();
        object request = new Dictionary<string, object>() {
            { "nonce", nonce },
        };
        object cancelReq = new List<object>() {};
        object cancelAction = new Dictionary<string, object>() {
            { "type", "" },
            { "cancels", new List<object>() {} },
        };
        object baseId = this.parseToNumeric(getValue(market, "baseId"));
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            if (!isTrue(((clientOrderId is IList<object>) || (clientOrderId.GetType().IsGenericType && clientOrderId.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                clientOrderId = new List<object>() {clientOrderId};
            }
            ((IDictionary<string,object>)cancelAction)["type"] = "cancelByCloid";
            for (object i = 0; isLessThan(i, getArrayLength(clientOrderId)); postFixIncrement(ref i))
            {
                ((IList<object>)cancelReq).Add(new Dictionary<string, object>() {
                    { "asset", baseId },
                    { "cloid", getValue(clientOrderId, i) },
                });
            }
        } else
        {
            ((IDictionary<string,object>)cancelAction)["type"] = "cancel";
            for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
            {
                ((IList<object>)cancelReq).Add(new Dictionary<string, object>() {
                    { "a", baseId },
                    { "o", this.parseToNumeric(getValue(ids, i)) },
                });
            }
        }
        ((IDictionary<string,object>)cancelAction)["cancels"] = cancelReq;
        object vaultAddress = this.formatVaultAddress(this.safeString(parameters, "vaultAddress"));
        object signature = this.signL1Action(cancelAction, nonce, vaultAddress);
        ((IDictionary<string,object>)request)["action"] = cancelAction;
        ((IDictionary<string,object>)request)["signature"] = signature;
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            parameters = this.omit(parameters, "vaultAddress");
            ((IDictionary<string,object>)request)["vaultAddress"] = vaultAddress;
        }
        object response = await this.privatePostExchange(request);
        //
        //     {
        //         "status":"ok",
        //         "response":{
        //             "type":"cancel",
        //             "data":{
        //                 "statuses":[
        //                     "success"
        //                 ]
        //             }
        //         }
        //     }
        //
        object innerResponse = this.safeDict(response, "response");
        object data = this.safeDict(innerResponse, "data");
        object statuses = this.safeList(data, "statuses");
        object orders = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(statuses)); postFixIncrement(ref i))
        {
            object status = getValue(statuses, i);
            ((IList<object>)orders).Add(this.safeOrder(new Dictionary<string, object>() {
                { "info", status },
                { "status", status },
            }));
        }
        return orders;
    }

    /**
     * @method
     * @name hyperliquid#cancelOrdersForSymbols
     * @description cancel multiple orders for multiple symbols
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s-by-cloid
     * @param {CancellationRequest[]} orders each order should contain the parameters required by cancelOrder namely id and symbol, example [{"id": "a", "symbol": "BTC/USDT"}, {"id": "b", "symbol": "ETH/USDT"}]
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.vaultAddress] the vault address
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrdersForSymbols(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        await this.loadMarkets();
        object nonce = this.milliseconds();
        object request = new Dictionary<string, object>() {
            { "nonce", nonce },
        };
        object cancelReq = new List<object>() {};
        object cancelAction = new Dictionary<string, object>() {
            { "type", "" },
            { "cancels", new List<object>() {} },
        };
        object cancelByCloid = false;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object order = getValue(orders, i);
            object clientOrderId = this.safeString(order, "clientOrderId");
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                cancelByCloid = true;
            }
            object id = this.safeString(order, "id");
            object symbol = this.safeString(order, "symbol");
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " cancelOrdersForSymbols() requires a symbol argument in each order")) ;
            }
            if (isTrue(isTrue(!isEqual(id, null)) && isTrue(cancelByCloid)))
            {
                throw new BadRequest ((string)add(this.id, " cancelOrdersForSymbols() all orders must have either id or clientOrderId")) ;
            }
            object assetKey = ((bool) isTrue(cancelByCloid)) ? "asset" : "a";
            object idKey = ((bool) isTrue(cancelByCloid)) ? "cloid" : "o";
            object market = this.market(symbol);
            object cancelObj = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)cancelObj)[(string)assetKey] = this.parseToNumeric(getValue(market, "baseId"));
            ((IDictionary<string,object>)cancelObj)[(string)idKey] = ((bool) isTrue(cancelByCloid)) ? clientOrderId : this.parseToNumeric(id);
            ((IList<object>)cancelReq).Add(cancelObj);
        }
        ((IDictionary<string,object>)cancelAction)["type"] = ((bool) isTrue(cancelByCloid)) ? "cancelByCloid" : "cancel";
        ((IDictionary<string,object>)cancelAction)["cancels"] = cancelReq;
        object vaultAddress = this.formatVaultAddress(this.safeString(parameters, "vaultAddress"));
        object signature = this.signL1Action(cancelAction, nonce, vaultAddress);
        ((IDictionary<string,object>)request)["action"] = cancelAction;
        ((IDictionary<string,object>)request)["signature"] = signature;
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            parameters = this.omit(parameters, "vaultAddress");
            ((IDictionary<string,object>)request)["vaultAddress"] = vaultAddress;
        }
        object response = await this.privatePostExchange(request);
        //
        //     {
        //         "status":"ok",
        //         "response":{
        //             "type":"cancel",
        //             "data":{
        //                 "statuses":[
        //                     "success"
        //                 ]
        //             }
        //         }
        //     }
        //
        return response;
    }

    /**
     * @method
     * @name hyperliquid#cancelAllOrdersAfter
     * @description dead man's switch, cancel all orders after the given timeout
     * @param {number} timeout time in milliseconds, 0 represents cancel the timer
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.vaultAddress] the vault address
     * @returns {object} the api result
     */
    public async override Task<object> cancelAllOrdersAfter(object timeout, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        await this.loadMarkets();
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "client_id"});
        object nonce = this.milliseconds();
        object request = new Dictionary<string, object>() {
            { "nonce", nonce },
        };
        object cancelAction = new Dictionary<string, object>() {
            { "type", "scheduleCancel" },
            { "time", add(nonce, timeout) },
        };
        object vaultAddress = this.formatVaultAddress(this.safeString(parameters, "vaultAddress"));
        object signature = this.signL1Action(cancelAction, nonce, vaultAddress);
        ((IDictionary<string,object>)request)["action"] = cancelAction;
        ((IDictionary<string,object>)request)["signature"] = signature;
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            parameters = this.omit(parameters, "vaultAddress");
            ((IDictionary<string,object>)request)["vaultAddress"] = vaultAddress;
        }
        object response = await this.privatePostExchange(request);
        //
        //     {
        //         "status":"err",
        //         "response":"Cannot set scheduled cancel time until enough volume traded. Required: $1000000. Traded: $373.47205."
        //     }
        //
        return response;
    }

    public virtual object editOrderRequest(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        if (isTrue(isEqual(id, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " editOrder() requires an id argument")) ;
        }
        object market = this.market(symbol);
        type = ((string)type).ToUpper();
        object isMarket = (isEqual(type, "MARKET"));
        side = ((string)side).ToUpper();
        object isBuy = (isEqual(side, "BUY"));
        object defaultSlippage = this.safeString(this.options, "defaultSlippage");
        object slippage = this.safeString(parameters, "slippage", defaultSlippage);
        object defaultTimeInForce = ((bool) isTrue((isMarket))) ? "ioc" : "gtc";
        object postOnly = this.safeBool(parameters, "postOnly", false);
        if (isTrue(postOnly))
        {
            defaultTimeInForce = "alo";
        }
        object timeInForce = this.safeStringLower(parameters, "timeInForce", defaultTimeInForce);
        timeInForce = this.capitalize(timeInForce);
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "client_id");
        object triggerPrice = this.safeString2(parameters, "triggerPrice", "stopPrice");
        object stopLossPrice = this.safeString(parameters, "stopLossPrice", triggerPrice);
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        object isTrigger = (isTrue(stopLossPrice) || isTrue(takeProfitPrice));
        parameters = this.omit(parameters, new List<object>() {"slippage", "timeInForce", "triggerPrice", "stopLossPrice", "takeProfitPrice", "clientOrderId", "client_id"});
        object px = ((object)price).ToString();
        if (isTrue(isMarket))
        {
            px = ((bool) isTrue((isBuy))) ? Precise.stringMul(((object)price).ToString(), Precise.stringAdd("1", slippage)) : Precise.stringMul(((object)price).ToString(), Precise.stringSub("1", slippage));
        } else
        {
            px = this.priceToPrecision(symbol, ((object)price).ToString());
        }
        object sz = this.amountToPrecision(symbol, amount);
        object reduceOnly = this.safeBool(parameters, "reduceOnly", false);
        object orderType = new Dictionary<string, object>() {};
        if (isTrue(isTrigger))
        {
            object isTp = false;
            if (isTrue(!isEqual(takeProfitPrice, null)))
            {
                triggerPrice = this.priceToPrecision(symbol, takeProfitPrice);
                isTp = true;
            } else
            {
                triggerPrice = this.priceToPrecision(symbol, stopLossPrice);
            }
            ((IDictionary<string,object>)orderType)["trigger"] = new Dictionary<string, object>() {
                { "isMarket", isMarket },
                { "triggerPx", triggerPrice },
                { "tpsl", ((bool) isTrue((isTp))) ? "tp" : "sl" },
            };
        } else
        {
            ((IDictionary<string,object>)orderType)["limit"] = new Dictionary<string, object>() {
                { "tif", timeInForce },
            };
        }
        if (isTrue(isEqual(triggerPrice, null)))
        {
            triggerPrice = "0";
        }
        object nonce = this.milliseconds();
        object orderReq = new Dictionary<string, object>() {
            { "a", this.parseToInt(getValue(market, "baseId")) },
            { "b", isBuy },
            { "p", px },
            { "s", sz },
            { "r", reduceOnly },
            { "t", orderType },
        };
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)orderReq)["c"] = clientOrderId;
        }
        object modifyReq = new Dictionary<string, object>() {
            { "oid", this.parseToInt(id) },
            { "order", orderReq },
        };
        object modifyAction = new Dictionary<string, object>() {
            { "type", "batchModify" },
            { "modifies", new List<object>() {modifyReq} },
        };
        object vaultAddress = this.formatVaultAddress(this.safeString(parameters, "vaultAddress"));
        object signature = this.signL1Action(modifyAction, nonce, vaultAddress);
        object request = new Dictionary<string, object>() {
            { "action", modifyAction },
            { "nonce", nonce },
            { "signature", signature },
        };
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            parameters = this.omit(parameters, "vaultAddress");
            ((IDictionary<string,object>)request)["vaultAddress"] = vaultAddress;
        }
        return request;
    }

    /**
     * @method
     * @name hyperliquid#editOrder
     * @description edit a trade order
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#modify-an-order
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#modify-multiple-orders
     * @param {string} id cancel order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.timeInForce] 'Gtc', 'Ioc', 'Alo'
     * @param {bool} [params.postOnly] true or false whether the order is post-only
     * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only
     * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
     * @param {string} [params.clientOrderId] client order id, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
     * @param {string} [params.vaultAddress] the vault address for order
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = this.editOrderRequest(id, symbol, type, side, amount, price, parameters);
        object response = await this.privatePostExchange(request);
        //
        //     {
        //         "status": "ok",
        //         "response": {
        //             "type": "order",
        //             "data": {
        //                 "statuses": [
        //                     {
        //                         "resting": {
        //                             "oid": 5063830287
        //                         }
        //                     }
        //                 ]
        //             }
        //         }
        //     }
        // when the order is filled immediately
        //     {
        //         "status":"ok",
        //         "response":{
        //            "type":"order",
        //            "data":{
        //               "statuses":[
        //                  {
        //                     "filled":{
        //                        "totalSz":"0.1",
        //                        "avgPx":"100.84",
        //                        "oid":6195281425
        //                     }
        //                  }
        //               ]
        //            }
        //         }
        //     }
        //
        object responseObject = this.safeDict(response, "response", new Dictionary<string, object>() {});
        object dataObject = this.safeDict(responseObject, "data", new Dictionary<string, object>() {});
        object statuses = this.safeList(dataObject, "statuses", new List<object>() {});
        object first = this.safeDict(statuses, 0, new Dictionary<string, object>() {});
        return this.parseOrder(first, market);
    }

    /**
     * @method
     * @name hyperliquid#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-historical-funding-rates
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest funding rate
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "type", "fundingHistory" },
            { "coin", getValue(market, "base") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        } else
        {
            object maxLimit = ((bool) isTrue((isEqual(limit, null)))) ? 500 : limit;
            ((IDictionary<string,object>)request)["startTime"] = subtract(this.milliseconds(), multiply(multiply(multiply(maxLimit, 60), 60), 1000));
        }
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "coin": "ETH",
        //             "fundingRate": "0.0000125",
        //             "premium": "0.00057962",
        //             "time": 1704290400031
        //         }
        //     ]
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object timestamp = this.safeInteger(entry, "time");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", this.safeSymbol(null, market) },
                { "fundingRate", this.safeNumber(entry, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(result, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    /**
     * @method
     * @name hyperliquid#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-open-orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @param {string} [params.method] 'openOrders' or 'frontendOpenOrders' default is 'frontendOpenOrders'
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchOpenOrders", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object method = null;
        var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrders", "method", "frontendOpenOrders");
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        await this.loadMarkets();
        object market = this.safeMarket(symbol);
        object request = new Dictionary<string, object>() {
            { "type", method },
            { "user", userAddress },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "coin": "ETH",
        //             "limitPx": "2000.0",
        //             "oid": 3991946565,
        //             "origSz": "0.1",
        //             "side": "B",
        //             "sz": "0.1",
        //             "timestamp": 1704346468838
        //         }
        //     ]
        //
        object orderWithStatus = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object order = getValue(response, i);
            object extendOrder = new Dictionary<string, object>() {};
            if (isTrue(isEqual(this.safeString(order, "status"), null)))
            {
                ((IDictionary<string,object>)extendOrder)["ccxtStatus"] = "open";
            }
            ((IList<object>)orderWithStatus).Add(this.extend(order, extendOrder));
        }
        return this.parseOrders(orderWithStatus, market, since, limit);
    }

    /**
     * @method
     * @name hyperliquid#fetchClosedOrders
     * @description fetch all unfilled currently closed orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orders = await this.fetchOrders(symbol, null, null, parameters); // don't filter here because we don't want to catch open orders
        object closedOrders = this.filterByArray(orders, "status", new List<object>() {"closed"}, false);
        return this.filterBySymbolSinceLimit(closedOrders, symbol, since, limit);
    }

    /**
     * @method
     * @name hyperliquid#fetchCanceledOrders
     * @description fetch all canceled orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orders = await this.fetchOrders(symbol, null, null, parameters); // don't filter here because we don't want to catch open orders
        object closedOrders = this.filterByArray(orders, "status", new List<object>() {"canceled"}, false);
        return this.filterBySymbolSinceLimit(closedOrders, symbol, since, limit);
    }

    /**
     * @method
     * @name hyperliquid#fetchCanceledAndClosedOrders
     * @description fetch all closed and canceled orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchCanceledAndClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orders = await this.fetchOrders(symbol, null, null, parameters); // don't filter here because we don't want to catch open orders
        object closedOrders = this.filterByArray(orders, "status", new List<object>() {"canceled", "closed", "rejected"}, false);
        return this.filterBySymbolSinceLimit(closedOrders, symbol, since, limit);
    }

    /**
     * @method
     * @name hyperliquid#fetchOrders
     * @description fetch all orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchOrders", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        await this.loadMarkets();
        object market = this.safeMarket(symbol);
        object request = new Dictionary<string, object>() {
            { "type", "historicalOrders" },
            { "user", userAddress },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "coin": "ETH",
        //             "limitPx": "2000.0",
        //             "oid": 3991946565,
        //             "origSz": "0.1",
        //             "side": "B",
        //             "sz": "0.1",
        //             "timestamp": 1704346468838
        //         }
        //     ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    /**
     * @method
     * @name hyperliquid#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#query-order-status-by-oid-or-cloid
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchOrder", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        await this.loadMarkets();
        object market = this.safeMarket(symbol);
        object isClientOrderId = isGreaterThanOrEqual(((string)id).Length, 34);
        object request = new Dictionary<string, object>() {
            { "type", "orderStatus" },
            { "oid", ((bool) isTrue(isClientOrderId)) ? id : this.parseToNumeric(id) },
            { "user", userAddress },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     {
        //         "order": {
        //             "order": {
        //                 "children": [],
        //                 "cloid": null,
        //                 "coin": "ETH",
        //                 "isPositionTpsl": false,
        //                 "isTrigger": false,
        //                 "limitPx": "2000.0",
        //                 "oid": "3991946565",
        //                 "orderType": "Limit",
        //                 "origSz": "0.1",
        //                 "reduceOnly": false,
        //                 "side": "B",
        //                 "sz": "0.1",
        //                 "tif": "Gtc",
        //                 "timestamp": "1704346468838",
        //                 "triggerCondition": "N/A",
        //                 "triggerPx": "0.0"
        //             },
        //             "status": "open",
        //             "statusTimestamp": "1704346468838"
        //         },
        //         "status": "order"
        //     }
        //
        object data = this.safeDict(response, "order");
        return this.parseOrder(data, market);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        //  fetchOpenOrders
        //
        //     {
        //         "coin": "ETH",
        //         "limitPx": "2000.0",
        //         "oid": 3991946565,
        //         "origSz": "0.1",
        //         "side": "B",
        //         "sz": "0.1",
        //         "timestamp": 1704346468838
        //     }
        // fetchClosedorders
        //    {
        //        "cloid": null,
        //        "closedPnl": "0.0",
        //        "coin": "SOL",
        //        "crossed": true,
        //        "dir": "Open Long",
        //        "fee": "0.003879",
        //        "hash": "0x4a2647998682b7f07bc5040ab531e1011400f9a51bfa0346a0b41ebe510e8875",
        //        "liquidationMarkPx": null,
        //        "oid": "6463280784",
        //        "px": "110.83",
        //        "side": "B",
        //        "startPosition": "1.64",
        //        "sz": "0.1",
        //        "tid": "232174667018988",
        //        "time": "1709142268394"
        //    }
        //
        //  fetchOrder
        //
        //     {
        //         "order": {
        //             "children": [],
        //             "cloid": null,
        //             "coin": "ETH",
        //             "isPositionTpsl": false,
        //             "isTrigger": false,
        //             "limitPx": "2000.0",
        //             "oid": "3991946565",
        //             "orderType": "Limit",
        //             "origSz": "0.1",
        //             "reduceOnly": false,
        //             "side": "B",
        //             "sz": "0.1",
        //             "tif": "Gtc",
        //             "timestamp": "1704346468838",
        //             "triggerCondition": "N/A",
        //             "triggerPx": "0.0"
        //         },
        //         "status": "open",
        //         "statusTimestamp": "1704346468838"
        //     }
        //
        // createOrder
        //
        //     {
        //         "resting": {
        //             "oid": 5063830287
        //         }
        //     }
        //
        //     {
        //        "filled":{
        //           "totalSz":"0.1",
        //           "avgPx":"100.84",
        //           "oid":6195281425
        //        }
        //     }
        // frontendOrder
        // {
        //     "children": [],
        //     "cloid": null,
        //     "coin": "BLUR",
        //     "isPositionTpsl": false,
        //     "isTrigger": true,
        //     "limitPx": "0.5",
        //     "oid": 8670487141,
        //     "orderType": "Stop Limit",
        //     "origSz": "20.0",
        //     "reduceOnly": false,
        //     "side": "B",
        //     "sz": "20.0",
        //     "tif": null,
        //     "timestamp": 1715523663687,
        //     "triggerCondition": "Price above 0.6",
        //     "triggerPx": "0.6"
        // }
        //
        object entry = this.safeDictN(order, new List<object>() {"order", "resting", "filled"});
        if (isTrue(isEqual(entry, null)))
        {
            entry = order;
        }
        object coin = this.safeString(entry, "coin");
        object marketId = null;
        if (isTrue(!isEqual(coin, null)))
        {
            marketId = this.coinToMarketId(coin);
        }
        if (isTrue(isEqual(this.safeString(entry, "id"), null)))
        {
            market = this.safeMarket(marketId, null);
        } else
        {
            market = this.safeMarket(marketId, market);
        }
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger2(order, "timestamp", "statusTimestamp");
        object status = this.safeString2(order, "status", "ccxtStatus");
        order = this.omit(order, new List<object>() {"ccxtStatus"});
        object side = this.safeString(entry, "side");
        if (isTrue(!isEqual(side, null)))
        {
            side = ((bool) isTrue((isEqual(side, "A")))) ? "sell" : "buy";
        }
        object totalAmount = this.safeString2(entry, "origSz", "totalSz");
        object remaining = this.safeString(entry, "sz");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString(entry, "oid") },
            { "clientOrderId", this.safeString(entry, "cloid") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", null },
            { "symbol", symbol },
            { "type", this.parseOrderType(this.safeStringLower(entry, "orderType")) },
            { "timeInForce", this.safeStringUpper(entry, "tif") },
            { "postOnly", null },
            { "reduceOnly", this.safeBool(entry, "reduceOnly") },
            { "side", side },
            { "price", this.safeString(entry, "limitPx") },
            { "triggerPrice", ((bool) isTrue(this.safeBool(entry, "isTrigger"))) ? this.safeNumber(entry, "triggerPx") : null },
            { "amount", totalAmount },
            { "cost", null },
            { "average", this.safeString(entry, "avgPx") },
            { "filled", Precise.stringSub(totalAmount, remaining) },
            { "remaining", remaining },
            { "status", this.parseOrderStatus(status) },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "triggered", "open" },
            { "filled", "closed" },
            { "open", "open" },
            { "canceled", "canceled" },
            { "rejected", "rejected" },
            { "marginCanceled", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderType(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "stop limit", "limit" },
            { "stop market", "market" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name hyperliquid#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills-by-time
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest trade
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchMyTrades", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        await this.loadMarkets();
        object market = this.safeMarket(symbol);
        object request = new Dictionary<string, object>() {
            { "user", userAddress },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["type"] = "userFillsByTime";
            ((IDictionary<string,object>)request)["startTime"] = since;
        } else
        {
            ((IDictionary<string,object>)request)["type"] = "userFills";
        }
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "closedPnl": "0.19343",
        //             "coin": "ETH",
        //             "crossed": true,
        //             "dir": "Close Long",
        //             "fee": "0.050062",
        //             "feeToken": "USDC",
        //             "hash": "0x09d77c96791e98b5775a04092584ab010d009445119c71e4005c0d634ea322bc",
        //             "liquidationMarkPx": null,
        //             "oid": 3929354691,
        //             "px": "2381.1",
        //             "side": "A",
        //             "startPosition": "0.0841",
        //             "sz": "0.0841",
        //             "tid": 128423918764978,
        //             "time": 1704262888911
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        //     {
        //         "closedPnl": "0.19343",
        //         "coin": "ETH",
        //         "crossed": true,
        //         "dir": "Close Long",
        //         "fee": "0.050062",
        //         "hash": "0x09d77c96791e98b5775a04092584ab010d009445119c71e4005c0d634ea322bc",
        //         "liquidationMarkPx": null,
        //         "oid": 3929354691,
        //         "px": "2381.1",
        //         "side": "A",
        //         "startPosition": "0.0841",
        //         "sz": "0.0841",
        //         "tid": 128423918764978,
        //         "time": 1704262888911
        //     }
        //
        object timestamp = this.safeInteger(trade, "time");
        object price = this.safeString(trade, "px");
        object amount = this.safeString(trade, "sz");
        object coin = this.safeString(trade, "coin");
        object marketId = this.coinToMarketId(coin);
        market = this.safeMarket(marketId, null);
        object symbol = getValue(market, "symbol");
        object id = this.safeString(trade, "tid");
        object side = this.safeString(trade, "side");
        if (isTrue(!isEqual(side, null)))
        {
            side = ((bool) isTrue((isEqual(side, "A")))) ? "sell" : "buy";
        }
        object fee = this.safeString(trade, "fee");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", id },
            { "order", this.safeString(trade, "oid") },
            { "type", null },
            { "side", side },
            { "takerOrMaker", null },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", new Dictionary<string, object>() {
                { "cost", fee },
                { "currency", this.safeString(trade, "feeToken") },
                { "rate", null },
            } },
        }, market);
    }

    /**
     * @method
     * @name hyperliquid#fetchPosition
     * @description fetch data on an open position
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-users-perpetuals-account-summary
     * @param {string} symbol unified market symbol of the market the position is held in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object positions = await this.fetchPositions(new List<object>() {symbol}, parameters);
        return this.safeDict(positions, 0, new Dictionary<string, object>() {});
    }

    /**
     * @method
     * @name hyperliquid#fetchPositions
     * @description fetch all open positions
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-users-perpetuals-account-summary
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchPositions", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {
            { "type", "clearinghouseState" },
            { "user", userAddress },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     {
        //         "assetPositions": [
        //             {
        //                 "position": {
        //                     "coin": "ETH",
        //                     "cumFunding": {
        //                         "allTime": "0.0",
        //                         "sinceChange": "0.0",
        //                         "sinceOpen": "0.0"
        //                     },
        //                     "entryPx": "2213.9",
        //                     "leverage": {
        //                         "rawUsd": "-475.23904",
        //                         "type": "isolated",
        //                         "value": "20"
        //                     },
        //                     "liquidationPx": "2125.00856238",
        //                     "marginUsed": "24.88097",
        //                     "maxLeverage": "50",
        //                     "positionValue": "500.12001",
        //                     "returnOnEquity": "0.0",
        //                     "szi": "0.2259",
        //                     "unrealizedPnl": "0.0"
        //                 },
        //                 "type": "oneWay"
        //             }
        //         ],
        //         "crossMaintenanceMarginUsed": "0.0",
        //         "crossMarginSummary": {
        //             "accountValue": "100.0",
        //             "totalMarginUsed": "0.0",
        //             "totalNtlPos": "0.0",
        //             "totalRawUsd": "100.0"
        //         },
        //         "marginSummary": {
        //             "accountValue": "100.0",
        //             "totalMarginUsed": "0.0",
        //             "totalNtlPos": "0.0",
        //             "totalRawUsd": "100.0"
        //         },
        //         "time": "1704261007014",
        //         "withdrawable": "100.0"
        //     }
        //
        object data = this.safeList(response, "assetPositions", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parsePosition(getValue(data, i), null));
        }
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         "position": {
        //             "coin": "ETH",
        //             "cumFunding": {
        //                 "allTime": "0.0",
        //                 "sinceChange": "0.0",
        //                 "sinceOpen": "0.0"
        //             },
        //             "entryPx": "2213.9",
        //             "leverage": {
        //                 "rawUsd": "-475.23904",
        //                 "type": "isolated",
        //                 "value": "20"
        //             },
        //             "liquidationPx": "2125.00856238",
        //             "marginUsed": "24.88097",
        //             "maxLeverage": "50",
        //             "positionValue": "500.12001",
        //             "returnOnEquity": "0.0",
        //             "szi": "0.2259",
        //             "unrealizedPnl": "0.0"
        //         },
        //         "type": "oneWay"
        //     }
        //
        object entry = this.safeDict(position, "position", new Dictionary<string, object>() {});
        object coin = this.safeString(entry, "coin");
        object marketId = this.coinToMarketId(coin);
        market = this.safeMarket(marketId, null);
        object symbol = getValue(market, "symbol");
        object leverage = this.safeDict(entry, "leverage", new Dictionary<string, object>() {});
        object marginMode = this.safeString(leverage, "type");
        object isIsolated = (isEqual(marginMode, "isolated"));
        object rawSize = this.safeString(entry, "szi");
        object size = rawSize;
        object side = null;
        if (isTrue(!isEqual(size, null)))
        {
            side = ((bool) isTrue(Precise.stringGt(rawSize, "0"))) ? "long" : "short";
            size = Precise.stringAbs(size);
        }
        object rawUnrealizedPnl = this.safeString(entry, "unrealizedPnl");
        object absRawUnrealizedPnl = Precise.stringAbs(rawUnrealizedPnl);
        object initialMargin = this.safeString(entry, "marginUsed");
        object percentage = Precise.stringMul(Precise.stringDiv(absRawUnrealizedPnl, initialMargin), "100");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "isolated", isIsolated },
            { "hedged", null },
            { "side", side },
            { "contracts", this.parseNumber(size) },
            { "contractSize", null },
            { "entryPrice", this.safeNumber(entry, "entryPx") },
            { "markPrice", null },
            { "notional", this.safeNumber(entry, "positionValue") },
            { "leverage", this.safeNumber(leverage, "value") },
            { "collateral", this.safeNumber(entry, "marginUsed") },
            { "initialMargin", this.parseNumber(initialMargin) },
            { "maintenanceMargin", null },
            { "initialMarginPercentage", null },
            { "maintenanceMarginPercentage", null },
            { "unrealizedPnl", this.parseNumber(rawUnrealizedPnl) },
            { "liquidationPrice", this.safeNumber(entry, "liquidationPx") },
            { "marginMode", marginMode },
            { "percentage", this.parseNumber(percentage) },
        });
    }

    /**
     * @method
     * @name hyperliquid#setMarginMode
     * @description set margin mode (symbol)
     * @param {string} marginMode margin mode must be either [isolated, cross]
     * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.leverage] the rate of leverage, is required if setting trade mode (symbol)
     * @returns {object} response from the exchange
     */
    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object leverage = this.safeInteger(parameters, "leverage");
        if (isTrue(isEqual(leverage, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a leverage parameter")) ;
        }
        object asset = this.parseToInt(getValue(market, "baseId"));
        object isCross = (isEqual(marginMode, "cross"));
        object nonce = this.milliseconds();
        parameters = this.omit(parameters, new List<object>() {"leverage"});
        object updateAction = new Dictionary<string, object>() {
            { "type", "updateLeverage" },
            { "asset", asset },
            { "isCross", isCross },
            { "leverage", leverage },
        };
        object vaultAddress = this.safeString(parameters, "vaultAddress");
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            parameters = this.omit(parameters, "vaultAddress");
            if (isTrue(((string)vaultAddress).StartsWith(((string)"0x"))))
            {
                vaultAddress = ((string)vaultAddress).Replace((string)"0x", (string)"");
            }
        }
        object signature = this.signL1Action(updateAction, nonce, vaultAddress);
        object request = new Dictionary<string, object>() {
            { "action", updateAction },
            { "nonce", nonce },
            { "signature", signature },
        };
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            ((IDictionary<string,object>)request)["vaultAddress"] = vaultAddress;
        }
        object response = await this.privatePostExchange(request);
        //
        //     {
        //         'response': {
        //             'type': 'default'
        //         },
        //         'status': 'ok'
        //     }
        //
        return response;
    }

    /**
     * @method
     * @name hyperliquid#setLeverage
     * @description set the level of leverage for a market
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] margin mode must be either [isolated, cross], default is cross
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object marginMode = this.safeString(parameters, "marginMode", "cross");
        object isCross = (isEqual(marginMode, "cross"));
        object asset = this.parseToInt(getValue(market, "baseId"));
        object nonce = this.milliseconds();
        parameters = this.omit(parameters, "marginMode");
        object updateAction = new Dictionary<string, object>() {
            { "type", "updateLeverage" },
            { "asset", asset },
            { "isCross", isCross },
            { "leverage", leverage },
        };
        object vaultAddress = this.formatVaultAddress(this.safeString(parameters, "vaultAddress"));
        object signature = this.signL1Action(updateAction, nonce, vaultAddress);
        object request = new Dictionary<string, object>() {
            { "action", updateAction },
            { "nonce", nonce },
            { "signature", signature },
        };
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            parameters = this.omit(parameters, "vaultAddress");
            ((IDictionary<string,object>)request)["vaultAddress"] = vaultAddress;
        }
        object response = await this.privatePostExchange(request);
        //
        //     {
        //         'response': {
        //             'type': 'default'
        //         },
        //         'status': 'ok'
        //     }
        //
        return response;
    }

    /**
     * @method
     * @name hyperliquid#addMargin
     * @description add margin
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#update-isolated-margin
     * @param {string} symbol unified market symbol
     * @param {float} amount amount of margin to add
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
     */
    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "add", parameters);
    }

    /**
     * @method
     * @name hyperliquid#reduceMargin
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#update-isolated-margin
     * @description remove margin from a position
     * @param {string} symbol unified market symbol
     * @param {float} amount the amount of margin to remove
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
     */
    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "reduce", parameters);
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object asset = this.parseToInt(getValue(market, "baseId"));
        object sz = this.parseToInt(Precise.stringMul(this.amountToPrecision(symbol, amount), "1000000"));
        if (isTrue(isEqual(type, "reduce")))
        {
            sz = prefixUnaryNeg(ref sz);
        }
        object nonce = this.milliseconds();
        object updateAction = new Dictionary<string, object>() {
            { "type", "updateIsolatedMargin" },
            { "asset", asset },
            { "isBuy", true },
            { "ntli", sz },
        };
        object vaultAddress = this.formatVaultAddress(this.safeString(parameters, "vaultAddress"));
        object signature = this.signL1Action(updateAction, nonce, vaultAddress);
        object request = new Dictionary<string, object>() {
            { "action", updateAction },
            { "nonce", nonce },
            { "signature", signature },
        };
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            parameters = this.omit(parameters, "vaultAddress");
            ((IDictionary<string,object>)request)["vaultAddress"] = vaultAddress;
        }
        object response = await this.privatePostExchange(request);
        //
        //     {
        //         'response': {
        //             'type': 'default'
        //         },
        //         'status': 'ok'
        //     }
        //
        return this.extend(this.parseMarginModification(response, market), new Dictionary<string, object>() {
            { "code", this.safeString(response, "status") },
        });
    }

    public override object parseMarginModification(object data, object market = null)
    {
        //
        //    {
        //        'type': 'default'
        //    }
        //
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", this.safeSymbol(null, market) },
            { "type", null },
            { "marginMode", "isolated" },
            { "amount", null },
            { "total", null },
            { "code", this.safeString(market, "settle") },
            { "status", null },
            { "timestamp", null },
            { "datetime", null },
        };
    }

    /**
     * @method
     * @name hyperliquid#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#l1-usdc-transfer
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account to transfer from *spot, swap*
     * @param {string} toAccount account to transfer to *swap, spot or address*
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.vaultAddress] the vault address for order
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        await this.loadMarkets();
        object isSandboxMode = this.safeBool(this.options, "sandboxMode");
        object nonce = this.milliseconds();
        if (isTrue(this.inArray(fromAccount, new List<object>() {"spot", "swap", "perp"})))
        {
            // handle swap <> spot account transfer
            if (!isTrue(this.inArray(toAccount, new List<object>() {"spot", "swap", "perp"})))
            {
                throw new NotSupported ((string)add(this.id, "transfer() only support spot <> swap transfer")) ;
            }
            object vaultAddress = this.formatVaultAddress(this.safeString(parameters, "vaultAddress"));
            parameters = this.omit(parameters, "vaultAddress");
            object toPerp = isTrue((isEqual(toAccount, "perp"))) || isTrue((isEqual(toAccount, "swap")));
            object action = new Dictionary<string, object>() {
                { "type", "spotUser" },
                { "classTransfer", new Dictionary<string, object>() {
                    { "usdc", amount },
                    { "toPerp", toPerp },
                } },
            };
            object signature = this.signL1Action(action, nonce, vaultAddress);
            object innerRequest = new Dictionary<string, object>() {
                { "action", action },
                { "nonce", nonce },
                { "signature", signature },
            };
            if (isTrue(!isEqual(vaultAddress, null)))
            {
                ((IDictionary<string,object>)innerRequest)["vaultAddress"] = vaultAddress;
            }
            object transferResponse = await this.privatePostExchange(innerRequest);
            return transferResponse;
        }
        // handle sub-account/different account transfer
        this.checkAddress(toAccount);
        if (isTrue(!isEqual(code, null)))
        {
            code = ((string)code).ToUpper();
            if (isTrue(!isEqual(code, "USDC")))
            {
                throw new NotSupported ((string)add(this.id, "transfer() only support USDC")) ;
            }
        }
        object payload = new Dictionary<string, object>() {
            { "hyperliquidChain", ((bool) isTrue(isSandboxMode)) ? "Testnet" : "Mainnet" },
            { "destination", toAccount },
            { "amount", this.numberToString(amount) },
            { "time", nonce },
        };
        object sig = this.buildTransferSig(payload);
        object request = new Dictionary<string, object>() {
            { "action", new Dictionary<string, object>() {
                { "hyperliquidChain", getValue(payload, "hyperliquidChain") },
                { "signatureChainId", "0x66eee" },
                { "destination", toAccount },
                { "amount", ((object)amount).ToString() },
                { "time", nonce },
                { "type", "usdSend" },
            } },
            { "nonce", nonce },
            { "signature", sig },
        };
        object response = await this.privatePostExchange(request);
        return response;
    }

    /**
     * @method
     * @name hyperliquid#withdraw
     * @description make a withdrawal (only support USDC)
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#initiate-a-withdrawal-request
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#deposit-or-withdraw-from-a-vault
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.vaultAddress] vault address withdraw from
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        await this.loadMarkets();
        this.checkAddress(address);
        if (isTrue(!isEqual(code, null)))
        {
            code = ((string)code).ToUpper();
            if (isTrue(!isEqual(code, "USDC")))
            {
                throw new NotSupported ((string)add(this.id, "withdraw() only support USDC")) ;
            }
        }
        object vaultAddress = this.formatVaultAddress(this.safeString(parameters, "vaultAddress"));
        parameters = this.omit(parameters, "vaultAddress");
        object nonce = this.milliseconds();
        object action = new Dictionary<string, object>() {};
        object sig = null;
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            action = new Dictionary<string, object>() {
                { "type", "vaultTransfer" },
                { "vaultAddress", add("0x", vaultAddress) },
                { "isDeposit", false },
                { "usd", amount },
            };
            sig = this.signL1Action(action, nonce);
        } else
        {
            object isSandboxMode = this.safeBool(this.options, "sandboxMode", false);
            object payload = new Dictionary<string, object>() {
                { "hyperliquidChain", ((bool) isTrue(isSandboxMode)) ? "Testnet" : "Mainnet" },
                { "destination", address },
                { "amount", ((object)amount).ToString() },
                { "time", nonce },
            };
            sig = this.buildWithdrawSig(payload);
            action = new Dictionary<string, object>() {
                { "hyperliquidChain", getValue(payload, "hyperliquidChain") },
                { "signatureChainId", "0x66eee" },
                { "destination", address },
                { "amount", ((object)amount).ToString() },
                { "time", nonce },
                { "type", "withdraw3" },
            };
        }
        object request = new Dictionary<string, object>() {
            { "action", action },
            { "nonce", nonce },
            { "signature", sig },
        };
        object response = await this.privatePostExchange(request);
        return this.parseTransaction(response);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // { status: 'ok', response: { type: 'default' } }
        //
        // fetchDeposits / fetchWithdrawals
        // {
        //     "time":1724762307531,
        //     "hash":"0x620a234a7e0eb7930575040f59482a01050058b0802163b4767bfd9033e77781",
        //     "delta":{
        //         "type":"accountClassTransfer",
        //         "usdc":"50.0",
        //         "toPerp":false
        //     }
        // }
        //
        object timestamp = this.safeInteger(transaction, "time");
        object delta = this.safeDict(transaction, "delta", new Dictionary<string, object>() {});
        object fee = null;
        object feeCost = this.safeInteger(delta, "fee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "currency", "USDC" },
                { "cost", feeCost },
            };
        }
        object intern = null;
        object type = this.safeString(delta, "type");
        if (isTrue(!isEqual(type, null)))
        {
            intern = (isEqual(type, "internalTransfer"));
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", null },
            { "txid", this.safeString(transaction, "hash") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", null },
            { "address", null },
            { "addressTo", this.safeString(delta, "destination") },
            { "addressFrom", this.safeString(delta, "user") },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", null },
            { "amount", this.safeInteger(delta, "usdc") },
            { "currency", null },
            { "status", this.safeString(transaction, "status") },
            { "updated", null },
            { "comment", null },
            { "internal", intern },
            { "fee", fee },
        };
    }

    /**
     * @method
     * @name hyperliquid#fetchTradingFee
     * @description fetch the trading fees for a market
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchTradingFee", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "type", "userFees" },
            { "user", userAddress },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     {
        //         "dailyUserVlm": [
        //             {
        //                 "date": "2024-07-08",
        //                 "userCross": "0.0",
        //                 "userAdd": "0.0",
        //                 "exchange": "90597185.23639999"
        //             }
        //         ],
        //         "feeSchedule": {
        //             "cross": "0.00035",
        //             "add": "0.0001",
        //             "tiers": {
        //                 "vip": [
        //                     {
        //                         "ntlCutoff": "5000000.0",
        //                         "cross": "0.0003",
        //                         "add": "0.00005"
        //                     }
        //                 ],
        //                 "mm": [
        //                     {
        //                         "makerFractionCutoff": "0.005",
        //                         "add": "-0.00001"
        //                     }
        //                 ]
        //             },
        //             "referralDiscount": "0.04"
        //         },
        //         "userCrossRate": "0.00035",
        //         "userAddRate": "0.0001",
        //         "activeReferralDiscount": "0.0"
        //     }
        //
        object data = new Dictionary<string, object>() {
            { "userCrossRate", this.safeString(response, "userCrossRate") },
            { "userAddRate", this.safeString(response, "userAddRate") },
        };
        return this.parseTradingFee(data, market);
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        //
        //     {
        //         "dailyUserVlm": [
        //             {
        //                 "date": "2024-07-08",
        //                 "userCross": "0.0",
        //                 "userAdd": "0.0",
        //                 "exchange": "90597185.23639999"
        //             }
        //         ],
        //         "feeSchedule": {
        //             "cross": "0.00035",
        //             "add": "0.0001",
        //             "tiers": {
        //                 "vip": [
        //                     {
        //                         "ntlCutoff": "5000000.0",
        //                         "cross": "0.0003",
        //                         "add": "0.00005"
        //                     }
        //                 ],
        //                 "mm": [
        //                     {
        //                         "makerFractionCutoff": "0.005",
        //                         "add": "-0.00001"
        //                     }
        //                 ]
        //             },
        //             "referralDiscount": "0.04"
        //         },
        //         "userCrossRate": "0.00035",
        //         "userAddRate": "0.0001",
        //         "activeReferralDiscount": "0.0"
        //     }
        //
        object symbol = this.safeSymbol(null, market);
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", symbol },
            { "maker", this.safeNumber(fee, "userAddRate") },
            { "taker", this.safeNumber(fee, "userCrossRate") },
            { "percentage", null },
            { "tierBased", null },
        };
    }

    /**
     * @method
     * @name hyperliquid#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
     * @param {string} [code] unified currency code
     * @param {int} [since] timestamp in ms of the earliest ledger entry
     * @param {int} [limit] max number of ledger entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest ledger entry
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchLedger", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "type", "userNonFundingLedgerUpdates" },
            { "user", userAddress },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
            parameters = this.omit(parameters, new List<object>() {"until"});
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        // [
        //     {
        //         "time":1724762307531,
        //         "hash":"0x620a234a7e0eb7930575040f59482a01050058b0802163b4767bfd9033e77781",
        //         "delta":{
        //             "type":"accountClassTransfer",
        //             "usdc":"50.0",
        //             "toPerp":false
        //         }
        //     }
        // ]
        //
        return this.parseLedger(response, null, since, limit);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        // {
        //     "time":1724762307531,
        //     "hash":"0x620a234a7e0eb7930575040f59482a01050058b0802163b4767bfd9033e77781",
        //     "delta":{
        //         "type":"accountClassTransfer",
        //         "usdc":"50.0",
        //         "toPerp":false
        //     }
        // }
        //
        object timestamp = this.safeInteger(item, "time");
        object delta = this.safeDict(item, "delta", new Dictionary<string, object>() {});
        object fee = null;
        object feeCost = this.safeInteger(delta, "fee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "currency", "USDC" },
                { "cost", feeCost },
            };
        }
        object type = this.safeString(delta, "type");
        object amount = this.safeString(delta, "usdc");
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", this.safeString(item, "hash") },
            { "direction", null },
            { "account", null },
            { "referenceAccount", this.safeString(delta, "user") },
            { "referenceId", this.safeString(item, "hash") },
            { "type", this.parseLedgerEntryType(type) },
            { "currency", null },
            { "amount", this.parseNumber(amount) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "before", null },
            { "after", null },
            { "status", null },
            { "fee", fee },
        }, currency);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object ledgerType = new Dictionary<string, object>() {
            { "internalTransfer", "transfer" },
            { "accountClassTransfer", "transfer" },
        };
        return this.safeString(ledgerType, type, type);
    }

    /**
     * @method
     * @name hyperliquid#fetchDeposits
     * @description fetch all deposits made to an account
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch withdrawals for
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchDepositsWithdrawals", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "type", "userNonFundingLedgerUpdates" },
            { "user", userAddress },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
            parameters = this.omit(parameters, new List<object>() {"until"});
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        // [
        //     {
        //         "time":1724762307531,
        //         "hash":"0x620a234a7e0eb7930575040f59482a01050058b0802163b4767bfd9033e77781",
        //         "delta":{
        //             "type":"accountClassTransfer",
        //             "usdc":"50.0",
        //             "toPerp":false
        //         }
        //     }
        // ]
        //
        object records = this.extractTypeFromDelta(response);
        object deposits = this.filterByArray(records, "type", new List<object>() {"deposit"}, false);
        return this.parseTransactions(deposits, null, since, limit);
    }

    /**
     * @method
     * @name hyperliquid#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch withdrawals for
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchDepositsWithdrawals", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "type", "userNonFundingLedgerUpdates" },
            { "user", userAddress },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
            parameters = this.omit(parameters, new List<object>() {"until"});
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        // [
        //     {
        //         "time":1724762307531,
        //         "hash":"0x620a234a7e0eb7930575040f59482a01050058b0802163b4767bfd9033e77781",
        //         "delta":{
        //             "type":"accountClassTransfer",
        //             "usdc":"50.0",
        //             "toPerp":false
        //         }
        //     }
        // ]
        //
        object records = this.extractTypeFromDelta(response);
        object withdrawals = this.filterByArray(records, "type", new List<object>() {"withdraw"}, false);
        return this.parseTransactions(withdrawals, null, since, limit);
    }

    public virtual object extractTypeFromDelta(object data = null)
    {
        data ??= new List<object>();
        object records = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object record = getValue(data, i);
            ((IDictionary<string,object>)record)["type"] = getValue(getValue(record, "delta"), "type");
            ((IList<object>)records).Add(record);
        }
        return records;
    }

    public virtual object formatVaultAddress(object address = null)
    {
        if (isTrue(isEqual(address, null)))
        {
            return null;
        }
        if (isTrue(((string)address).StartsWith(((string)"0x"))))
        {
            return ((string)address).Replace((string)"0x", (string)"");
        }
        return address;
    }

    public virtual object handlePublicAddress(object methodName, object parameters)
    {
        object userAux = null;
        var userAuxparametersVariable = this.handleOptionAndParams(parameters, methodName, "user");
        userAux = ((IList<object>)userAuxparametersVariable)[0];
        parameters = ((IList<object>)userAuxparametersVariable)[1];
        object user = userAux;
        var userparametersVariable = this.handleOptionAndParams(parameters, methodName, "address", userAux);
        user = ((IList<object>)userparametersVariable)[0];
        parameters = ((IList<object>)userparametersVariable)[1];
        if (isTrue(isTrue((!isEqual(user, null))) && isTrue((!isEqual(user, "")))))
        {
            return new List<object>() {user, parameters};
        }
        if (isTrue(isTrue((!isEqual(this.walletAddress, null))) && isTrue((!isEqual(this.walletAddress, "")))))
        {
            return new List<object>() {this.walletAddress, parameters};
        }
        throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a user parameter inside 'params' or the wallet address set")) ;
    }

    public virtual object coinToMarketId(object coin)
    {
        if (isTrue(isTrue(isGreaterThan(getIndexOf(coin, "/"), -1)) || isTrue(isGreaterThan(getIndexOf(coin, "@"), -1))))
        {
            return coin;  // spot
        }
        return add(coin, "/USDC:USDC");
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        // {"status":"err","response":"User or API Wallet 0xb8a6f8b26223de27c31938d56e470a5b832703a5 does not exist."}
        //
        //     {
        //         status: 'ok',
        //         response: { type: 'order', data: { statuses: [ { error: 'Insufficient margin to place order. asset=4' } ] } }
        //     }
        //
        object status = this.safeString(response, "status", "");
        object message = null;
        if (isTrue(isEqual(status, "err")))
        {
            message = this.safeString(response, "response");
        } else
        {
            object responsePayload = this.safeDict(response, "response", new Dictionary<string, object>() {});
            object data = this.safeDict(responsePayload, "data", new Dictionary<string, object>() {});
            object statuses = this.safeList(data, "statuses", new List<object>() {});
            object firstStatus = this.safeDict(statuses, 0);
            message = this.safeString(firstStatus, "error");
        }
        object feedback = add(add(this.id, " "), body);
        object nonEmptyMessage = (isTrue((!isEqual(message, null))) && isTrue((!isEqual(message, ""))));
        if (isTrue(nonEmptyMessage))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
        }
        if (isTrue(nonEmptyMessage))
        {
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(this.implodeHostname(getValue(getValue(this.urls, "api"), api)), "/"), path);
        if (isTrue(isEqual(method, "POST")))
        {
            headers = new Dictionary<string, object>() {
                { "Content-Type", "application/json" },
            };
            body = this.json(parameters);
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object calculateRateLimiterCost(object api, object method, object path, object parameters, object config = null)
    {
        config ??= new Dictionary<string, object>();
        if (isTrue(isTrue((inOp(config, "byType"))) && isTrue((inOp(parameters, "type")))))
        {
            object type = getValue(parameters, "type");
            object byType = getValue(config, "byType");
            if (isTrue(inOp(byType, type)))
            {
                return getValue(byType, type);
            }
        }
        return this.safeValue(config, "cost", 1);
    }

    public virtual object parseCreateOrderArgs(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object vaultAddress = this.safeString(parameters, "vaultAddress");
        parameters = this.omit(parameters, "vaultAddress");
        symbol = getValue(market, "symbol");
        object order = new Dictionary<string, object>() {
            { "symbol", symbol },
            { "type", type },
            { "side", side },
            { "amount", amount },
            { "price", price },
            { "params", parameters },
        };
        object globalParams = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            ((IDictionary<string,object>)globalParams)["vaultAddress"] = vaultAddress;
        }
        return new List<object>() {order, globalParams};
    }
}
