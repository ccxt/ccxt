namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class hyperliquid : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "hyperliquid" },
            { "name", "Hyperliquid" },
            { "countries", new List<object>() {} },
            { "version", "v1" },
            { "rateLimit", 50 },
            { "certified", true },
            { "pro", true },
            { "dex", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", true },
                { "future", true },
                { "option", false },
                { "addMargin", true },
                { "borrowCrossMargin", false },
                { "borrowIsolatedMargin", false },
                { "cancelAllOrders", false },
                { "cancelAllOrdersAfter", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "cancelOrdersForSymbols", true },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createMarketBuyOrderWithCost", false },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", true },
                { "createOrderWithTakeProfitAndStopLoss", true },
                { "createReduceOnlyOrder", true },
                { "createStopOrder", true },
                { "createTriggerOrder", true },
                { "editOrder", true },
                { "editOrders", true },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCanceledAndClosedOrders", true },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", false },
                { "fetchDepositAddresses", false },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLedger", true },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchLiquidations", false },
                { "fetchMarginMode", null },
                { "fetchMarketLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyLiquidations", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenInterests", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchOrderTrades", false },
                { "fetchPosition", true },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", true },
                { "fetchTicker", "emulated" },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", true },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", false },
                { "sandbox", true },
                { "setLeverage", true },
                { "setMarginMode", true },
                { "setPositionMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "8h", "8h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "3d", "3d" },
                { "1w", "1w" },
                { "1M", "1M" },
            } },
            { "hostname", "hyperliquid.xyz" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/ccxt/ccxt/assets/43336371/b371bc6c-4a8c-489f-87f4-20a913dd8d4b" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.{hostname}" },
                    { "private", "https://api.{hostname}" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "public", "https://api.hyperliquid-testnet.xyz" },
                    { "private", "https://api.hyperliquid-testnet.xyz" },
                } },
                { "www", "https://hyperliquid.xyz" },
                { "doc", "https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api" },
                { "fees", "https://hyperliquid.gitbook.io/hyperliquid-docs/trading/fees" },
                { "referral", "https://app.hyperliquid.xyz/" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "post", new Dictionary<string, object>() {
                        { "info", new Dictionary<string, object>() {
                            { "cost", 20 },
                            { "byType", new Dictionary<string, object>() {
                                { "l2Book", 2 },
                                { "allMids", 2 },
                                { "clearinghouseState", 2 },
                                { "orderStatus", 2 },
                                { "spotClearinghouseState", 2 },
                                { "exchangeStatus", 2 },
                                { "candleSnapshot", 4 },
                            } },
                        } },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "post", new Dictionary<string, object>() {
                        { "exchange", 1 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "swap", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.00045") },
                    { "maker", this.parseNumber("0.00015") },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.0007") },
                    { "maker", this.parseNumber("0.0004") },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", false },
                { "secret", false },
                { "walletAddress", true },
                { "privateKey", true },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {} },
                { "broad", new Dictionary<string, object>() {
                    { "Price must be divisible by tick size.", typeof(InvalidOrder) },
                    { "Order must have minimum value of $10", typeof(InvalidOrder) },
                    { "Insufficient margin to place order.", typeof(InsufficientFunds) },
                    { "Reduce only order would increase position.", typeof(InvalidOrder) },
                    { "Post only order would have immediately matched,", typeof(InvalidOrder) },
                    { "Order could not immediately match against any resting orders.", typeof(InvalidOrder) },
                    { "Invalid TP/SL price.", typeof(InvalidOrder) },
                    { "No liquidity available for market order.", typeof(InvalidOrder) },
                    { "Order was never placed, already canceled, or filled.", typeof(OrderNotFound) },
                    { "User or API Wallet ", typeof(InvalidOrder) },
                    { "Order has invalid size", typeof(InvalidOrder) },
                    { "Order price cannot be more than 80% away from the reference price", typeof(InvalidOrder) },
                    { "Order has zero size.", typeof(InvalidOrder) },
                    { "Insufficient spot balance asset", typeof(InsufficientFunds) },
                    { "Insufficient balance for withdrawal", typeof(InsufficientFunds) },
                    { "Insufficient balance for token transfer", typeof(InsufficientFunds) },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "options", new Dictionary<string, object>() {
                { "defaultType", "swap" },
                { "sandboxMode", false },
                { "defaultSlippage", 0.05 },
                { "marketHelperProps", new List<object>() {"hip3TokensByName", "cachedCurrenciesById"} },
                { "zeroAddress", "0x0000000000000000000000000000000000000000" },
                { "spotCurrencyMapping", new Dictionary<string, object>() {
                    { "UDZ", "2Z" },
                    { "UBONK", "BONK" },
                    { "UBTC", "BTC" },
                    { "UETH", "ETH" },
                    { "UFART", "FARTCOIN" },
                    { "HPENGU", "PENGU" },
                    { "UPUMP", "PUMP" },
                    { "USOL", "SOL" },
                    { "UUUSPX", "SPX" },
                    { "USDT0", "USDT" },
                    { "XAUT0", "XAUT" },
                    { "UXPL", "XPL" },
                } },
                { "fetchMarkets", new Dictionary<string, object>() {
                    { "types", new List<object>() {"spot", "swap", "hip3"} },
                    { "hip3", new Dictionary<string, object>() {
                        { "limit", 10 },
                        { "dexes", new List<object>() {} },
                    } },
                } },
            } },
            { "features", new Dictionary<string, object>() {
                { "default", new Dictionary<string, object>() {
                    { "sandbox", true },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", false },
                        { "triggerPriceType", null },
                        { "triggerDirection", false },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", new Dictionary<string, object>() {
                            { "triggerPriceType", new Dictionary<string, object>() {
                                { "last", false },
                                { "mark", false },
                                { "index", false },
                            } },
                            { "triggerPrice", true },
                            { "type", true },
                            { "price", true },
                        } },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", false },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "trailing", false },
                        { "leverage", false },
                        { "marketBuyByCost", false },
                        { "marketBuyRequiresPrice", false },
                        { "selfTradePrevention", false },
                        { "iceberg", false },
                    } },
                    { "createOrders", new Dictionary<string, object>() {
                        { "max", 1000 },
                    } },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 2000 },
                        { "daysBack", null },
                        { "untilDays", null },
                        { "symbolRequired", true },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", true },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 2000 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", true },
                    } },
                    { "fetchOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 2000 },
                        { "daysBack", null },
                        { "untilDays", null },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", true },
                    } },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 2000 },
                        { "daysBack", null },
                        { "daysBackCanceled", null },
                        { "untilDays", null },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", true },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 5000 },
                    } },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "extends", "default" },
                } },
                { "forPerps", new Dictionary<string, object>() {
                    { "extends", "default" },
                    { "createOrder", new Dictionary<string, object>() {
                        { "stopLossPrice", true },
                        { "takeProfitPrice", true },
                        { "attachedStopLossTakeProfit", null },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "forPerps" },
                    } },
                    { "inverse", new Dictionary<string, object>() {
                        { "extends", "forPerps" },
                    } },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "forPerps" },
                    } },
                    { "inverse", new Dictionary<string, object>() {
                        { "extends", "forPerps" },
                    } },
                } },
            } },
        });
    }

    public override void setSandboxMode(object enabled)
    {
        base.setSandboxMode(enabled);
        ((IDictionary<string,object>)this.options)["sandboxMode"] = enabled;
    }

    public override object market(object symbol)
    {
        if (isTrue(isEqual(this.markets, null)))
        {
            throw new ExchangeError ((string)add(this.id, " markets not loaded")) ;
        }
        if (isTrue(isTrue((!isEqual(symbol, null))) && !isTrue((inOp(this.markets, symbol)))))
        {
            object symbolParts = ((string)symbol).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
            object baseName = this.safeString(symbolParts, 0);
            object spotCurrencyMapping = this.safeDict(this.options, "spotCurrencyMapping", new Dictionary<string, object>() {});
            if (isTrue(inOp(spotCurrencyMapping, baseName)))
            {
                object unifiedBaseName = this.safeString(spotCurrencyMapping, baseName);
                object quote = this.safeString(symbolParts, 1);
                object newSymbol = add(add(this.safeCurrencyCode(unifiedBaseName), "/"), quote);
                if (isTrue(inOp(this.markets, newSymbol)))
                {
                    return getValue(this.markets, newSymbol);
                }
            }
        }
        return base.market(symbol);
    }

    /**
     * @method
     * @name hyperliquid#fetchStatus
     * @description the latest known information on the availability of the exchange API
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/?id=exchange-status-structure}
     */
    public async override Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", "exchangeStatus" },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     {
        //         "status": "ok"
        //     }
        //
        object status = this.safeString(response, "specialStatuses");
        return new Dictionary<string, object>() {
            { "status", ((bool) isTrue((isEqual(status, null)))) ? "ok" : "maintenance" },
            { "updated", this.safeInteger(response, "time") },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    /**
     * @method
     * @name hyperliquid#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", "exchangeStatus" },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        // { specialStatuses: null, time: '1764617438643' }
        //
        return this.safeInteger(response, "time");
    }

    /**
     * @method
     * @name hyperliquid#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-perpetuals-metadata
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(this.checkRequiredCredentials(false)))
        {
            await this.initializeClient();
        }
        object request = new Dictionary<string, object>() {
            { "type", "spotMeta" },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "universe": [
        //                 {
        //                     "maxLeverage": 50,
        //                     "name": "SOL",
        //                     "onlyIsolated": false,
        //                     "szDecimals": 2
        //                 }
        //             ]
        //         }
        //     ]
        //
        // const spotMeta = await this.publicPostInfo ({ 'type': 'spotMeta' });
        object tokens = this.safeList(response, "tokens", new List<object>() {});
        // const meta = this.safeList (response, 'universe', []);
        ((IDictionary<string,object>)this.options)["cachedCurrenciesById"] = new Dictionary<string, object>() {}; // used to map hip3 markets
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(tokens)); postFixIncrement(ref i))
        {
            object data = this.safeDict(tokens, i, new Dictionary<string, object>() {});
            // const id = i;
            object id = this.safeString(data, "index");
            object name = this.safeString(data, "name");
            object code = this.safeCurrencyCode(name);
            ((IDictionary<string,object>)getValue(this.options, "cachedCurrenciesById"))[(string)id] = name;
            ((IDictionary<string,object>)result)[(string)code] = this.safeCurrencyStructure(new Dictionary<string, object>() {
                { "id", id },
                { "name", name },
                { "code", code },
                { "precision", this.parsePrecision(this.safeString(data, "weiDecimals")) },
                { "info", data },
                { "active", null },
                { "deposit", null },
                { "withdraw", null },
                { "networks", null },
                { "fee", null },
                { "type", "crypto" },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
            });
            // add in wrapped map
            object fullName = this.safeString(data, "fullName");
            if (isTrue(isTrue(!isEqual(fullName, null)) && isTrue(!isEqual(name, null))))
            {
                object isWrapped = isTrue(((string)fullName).StartsWith(((string)"Unit "))) && isTrue(((string)name).StartsWith(((string)"U")));
                if (isTrue(isWrapped))
                {
                    object parts = ((string)name).Split(new [] {((string)"U")}, StringSplitOptions.None).ToList<object>();
                    object nameWithoutU = "";
                    for (object j = 0; isLessThan(j, getArrayLength(parts)); postFixIncrement(ref j))
                    {
                        nameWithoutU = add(nameWithoutU, getValue(parts, j));
                    }
                    object baseCode = this.safeCurrencyCode(nameWithoutU);
                    ((IDictionary<string,object>)getValue(this.options, "spotCurrencyMapping"))[(string)code] = baseCode;
                }
            }
        }
        return result;
    }

    /**
     * @method
     * @name hyperliquid#fetchMarkets
     * @description retrieves data on all markets for hyperliquid
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-perpetuals-asset-contexts-includes-mark-price-current-funding-open-interest-etc
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/spot#retrieve-spot-asset-contexts
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object options = this.safeDict(this.options, "fetchMarkets", new Dictionary<string, object>() {});
        object types = this.safeList(options, "types");
        object rawPromises = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(types)); postFixIncrement(ref i))
        {
            object marketType = getValue(types, i);
            if (isTrue(isEqual(marketType, "swap")))
            {
                ((IList<object>)rawPromises).Add(this.fetchSwapMarkets(parameters));
            } else if (isTrue(isEqual(marketType, "spot")))
            {
                ((IList<object>)rawPromises).Add(this.fetchSpotMarkets(parameters));
            } else if (isTrue(isEqual(marketType, "hip3")))
            {
                ((IList<object>)rawPromises).Add(this.fetchHip3Markets(parameters));
            }
        }
        object promises = await promiseAll(rawPromises);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(promises)); postFixIncrement(ref i))
        {
            result = this.arrayConcat(result, getValue(promises, i));
        }
        return result;
    }

    /**
     * @method
     * @name hyperliquid#fetchHip3Markets
     * @description retrieves data on all hip3 markets for hyperliquid
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-all-perpetual-dexs
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-perpetuals-asset-contexts-includes-mark-price-current-funding-open-interest-etc
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async virtual Task<object> fetchHip3Markets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object fetchDexes = await this.publicPostInfo(new Dictionary<string, object>() {
            { "type", "perpDexs" },
        });
        //
        //     [
        //         null,
        //         {
        //             "name": "xyz",
        //             "fullName": "XYZ",
        //             "deployer": "0x88806a71d74ad0a510b350545c9ae490912f0888",
        //             "oracleUpdater": "0x1234567890545d1df9ee64b35fdd16966e08acec",
        //             "feeRecipient": "0x79c0650064b10f73649b7b64c5ebf0b319606140",
        //             "assetToStreamingOiCap": [
        //                 [
        //                     "xyz:XYZ100",
        //                     "100000000.0"
        //                 ]
        //             ]
        //         }
        //     ]
        //
        object perpDexesOffset = new Dictionary<string, object>() {};
        for (object i = 1; isLessThan(i, getArrayLength(fetchDexes)); postFixIncrement(ref i))
        {
            // builder-deployed perp dexs start at 110000
            object dex = getValue(fetchDexes, i);
            object offset = add(110000, multiply((subtract(i, 1)), 10000));
            ((IDictionary<string,object>)perpDexesOffset)[(string)getValue(dex, "name")] = offset;
        }
        object fetchDexesList = new List<object>() {};
        object options = this.safeDict(this.options, "fetchMarkets", new Dictionary<string, object>() {});
        object hip3 = this.safeDict(options, "hip3", new Dictionary<string, object>() {});
        object dexesProvided = this.safeList(hip3, "dexes", new List<object>() {}); // let users provide their own list of dexes to load
        object maxLimit = this.safeInteger(hip3, "limit", 10);
        object userProvidedDexesLength = getArrayLength(dexesProvided);
        if (isTrue(isGreaterThan(userProvidedDexesLength, 0)))
        {
            if (isTrue(isGreaterThan(userProvidedDexesLength, 0)))
            {
                fetchDexesList = dexesProvided;
            }
        } else
        {
            object fetchDexesLength = getArrayLength(fetchDexes);
            for (object i = 1; isLessThan(i, maxLimit); postFixIncrement(ref i))
            {
                if (isTrue(isGreaterThanOrEqual(i, fetchDexesLength)))
                {
                    break;
                }
                object dex = this.safeDict(fetchDexes, i, new Dictionary<string, object>() {});
                if (isTrue(isEqual(dex, null)))
                {
                    continue;
                }
                object dexName = this.safeString(dex, "name");
                ((IList<object>)fetchDexesList).Add(dexName);
            }
        }
        object rawPromises = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(fetchDexesList)); postFixIncrement(ref i))
        {
            object request = new Dictionary<string, object>() {
                { "type", "metaAndAssetCtxs" },
                { "dex", this.safeString(fetchDexesList, i) },
            };
            ((IList<object>)rawPromises).Add(this.publicPostInfo(this.extend(request, parameters)));
        }
        object promises = await promiseAll(rawPromises);
        ((IDictionary<string,object>)this.options)["hip3TokensByName"] = new Dictionary<string, object>() {};
        object markets = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(promises)); postFixIncrement(ref i))
        {
            object dexName = getValue(fetchDexesList, i);
            object offset = getValue(perpDexesOffset, dexName);
            object response = getValue(promises, i);
            object meta = this.safeDict(response, 0, new Dictionary<string, object>() {});
            object collateralToken = this.safeString(meta, "collateralToken");
            object universe = this.safeList(meta, "universe", new List<object>() {});
            object assetCtxs = this.safeList(response, 1, new List<object>() {});
            object result = new List<object>() {};
            // helper because some endpoints return just the coin name like: flx:crcl
            // and we don't have the base/settle information and we can't assume it's USDC for hip3 markets
            for (object j = 0; isLessThan(j, getArrayLength(universe)); postFixIncrement(ref j))
            {
                object data = this.extend(this.safeDict(universe, j, new Dictionary<string, object>() {}), this.safeDict(assetCtxs, j, new Dictionary<string, object>() {}));
                ((IDictionary<string,object>)data)["baseId"] = add(j, offset);
                ((IDictionary<string,object>)data)["collateralToken"] = collateralToken;
                ((IDictionary<string,object>)data)["hip3"] = true;
                ((IDictionary<string,object>)data)["dex"] = dexName;
                object cachedCurrencies = this.safeDict(this.options, "cachedCurrenciesById", new Dictionary<string, object>() {});
                // injecting collateral token name for further usage in parseMarket, already converted from like '0' to 'USDC', etc
                if (isTrue(inOp(cachedCurrencies, collateralToken)))
                {
                    object name = this.safeString(data, "name");
                    object collateralTokenCode = this.safeString(cachedCurrencies, collateralToken);
                    ((IDictionary<string,object>)data)["collateralTokenName"] = collateralTokenCode;
                    // eg: 'flx:crcl' => {'quote': 'USDC', 'code': 'FLX-CRCL'}
                    object safeCode = this.safeCurrencyCode(name);
                    ((IDictionary<string,object>)getValue(this.options, "hip3TokensByName"))[(string)name] = new Dictionary<string, object>() {
                        { "quote", collateralTokenCode },
                        { "code", ((string)safeCode).Replace((string)":", (string)"-") },
                    };
                }
                ((IList<object>)result).Add(data);
            }
            markets = this.arrayConcat(markets, this.parseMarkets(result));
        }
        //
        //     [
        //         {
        //             "universe": [
        //                 {
        //                     "maxLeverage": 50,
        //                     "name": "SOL",
        //                     "onlyIsolated": false,
        //                     "szDecimals": 2
        //                 }
        //             ]
        //         },
        //         [
        //             {
        //                 "dayNtlVlm": "9450588.2273",
        //                 "funding": "0.0000198",
        //                 "impactPxs": [
        //                     "108.04",
        //                     "108.06"
        //                 ],
        //                 "markPx": "108.04",
        //                 "midPx": "108.05",
        //                 "openInterest": "10764.48",
        //                 "oraclePx": "107.99",
        //                 "premium": "0.00055561",
        //                 "prevDayPx": "111.81"
        //             }
        //         ]
        //     ]
        //
        //
        return markets;
    }

    /**
     * @method
     * @name hyperliquid#fetchSwapMarkets
     * @description retrieves data on all swap markets for hyperliquid
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-perpetuals-asset-contexts-includes-mark-price-current-funding-open-interest-etc
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async virtual Task<object> fetchSwapMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", "metaAndAssetCtxs" },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "universe": [
        //                 {
        //                     "maxLeverage": 50,
        //                     "name": "SOL",
        //                     "onlyIsolated": false,
        //                     "szDecimals": 2
        //                 }
        //             ]
        //         },
        //         [
        //             {
        //                 "dayNtlVlm": "9450588.2273",
        //                 "funding": "0.0000198",
        //                 "impactPxs": [
        //                     "108.04",
        //                     "108.06"
        //                 ],
        //                 "markPx": "108.04",
        //                 "midPx": "108.05",
        //                 "openInterest": "10764.48",
        //                 "oraclePx": "107.99",
        //                 "premium": "0.00055561",
        //                 "prevDayPx": "111.81"
        //             }
        //         ]
        //     ]
        //
        //
        object meta = this.safeDict(response, 0, new Dictionary<string, object>() {});
        object universe = this.safeList(meta, "universe", new List<object>() {});
        object assetCtxs = this.safeList(response, 1, new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(universe)); postFixIncrement(ref i))
        {
            object data = this.extend(this.safeDict(universe, i, new Dictionary<string, object>() {}), this.safeDict(assetCtxs, i, new Dictionary<string, object>() {}));
            ((IDictionary<string,object>)data)["baseId"] = i;
            ((IList<object>)result).Add(data);
        }
        return this.parseMarkets(result);
    }

    /**
     * @method
     * @name hyperliquid#calculatePricePrecision
     * @description Helper function to calculate the Hyperliquid DECIMAL_PLACES price precision
     * @param {float} price the price to use in the calculation
     * @param {int} amountPrecision the amountPrecision to use in the calculation
     * @param {int} maxDecimals the maxDecimals to use in the calculation
     * @returns {int} The calculated price precision
     */
    public virtual object calculatePricePrecision(object price, object amountPrecision, object maxDecimals)
    {
        object pricePrecision = 0;
        object priceStr = this.numberToString(price);
        if (isTrue(isEqual(priceStr, null)))
        {
            return 0;
        }
        object priceSplitted = ((string)priceStr).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
        if (isTrue(Precise.stringEq(priceStr, "0")))
        {
            // Significant digits is always 5 in this case
            object significantDigits = 5;
            // Integer digits is always 0 in this case (0 doesn't count)
            object integerDigits = 0;
            // Calculate the price precision
            pricePrecision = mathMin(subtract(maxDecimals, amountPrecision), subtract(significantDigits, integerDigits));
        } else if (isTrue(isTrue(Precise.stringGt(priceStr, "0")) && isTrue(Precise.stringLt(priceStr, "1"))))
        {
            // Significant digits, always 5 in this case
            object significantDigits = 5;
            // Get the part after the decimal separator
            object decimalPart = this.safeString(priceSplitted, 1, "");
            // Count the number of leading zeros in the decimal part
            object leadingZeros = 0;
            while (isTrue((isLessThanOrEqual(leadingZeros, ((string)decimalPart).Length))) && isTrue((isEqual(getValue(decimalPart, leadingZeros), "0"))))
            {
                leadingZeros = add(leadingZeros, 1);
            }
            // Calculate price precision based on leading zeros and significant digits
            pricePrecision = add(leadingZeros, significantDigits);
            // Calculate the price precision based on maxDecimals - szDecimals and the calculated price precision from the previous step
            pricePrecision = mathMin(subtract(maxDecimals, amountPrecision), pricePrecision);
        } else
        {
            // Count the numbers before the decimal separator
            object integerPart = this.safeString(priceSplitted, 0, "");
            // Get significant digits, take the max() of 5 and the integer digits count
            object significantDigits = mathMax(5, ((string)integerPart).Length);
            // Calculate price precision based on maxDecimals - szDecimals and significantDigits - integerPart.length
            pricePrecision = mathMin(subtract(maxDecimals, amountPrecision), subtract(significantDigits, ((string)integerPart).Length));
        }
        return this.parseToInt(pricePrecision);
    }

    /**
     * @method
     * @name hyperliquid#fetchSpotMarkets
     * @description retrieves data on all spot markets for hyperliquid
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/spot#retrieve-spot-asset-contexts
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async virtual Task<object> fetchSpotMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", "spotMetaAndAssetCtxs" },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        // [
        //     {
        //         "tokens": [
        //             {
        //                 "name": "USDC",
        //                 "szDecimals": 8,
        //                 "weiDecimals" 8,
        //                 "index": 0,
        //                 "tokenId": "0x6d1e7cde53ba9467b783cb7c530ce054",
        //                 "isCanonical": true,
        //                 "evmContract":null,
        //                 "fullName":null
        //             },
        //             {
        //                 "name": "PURR",
        //                 "szDecimals": 0,
        //                 "weiDecimals": 5,
        //                 "index": 1,
        //                 "tokenId": "0xc1fb593aeffbeb02f85e0308e9956a90",
        //                 "isCanonical": true,
        //                 "evmContract":null,
        //                 "fullName":null
        //             }
        //         ],
        //         "universe": [
        //             {
        //                 "name": "PURR/USDC",
        //                 "tokens": [1, 0],
        //                 "index": 0,
        //                 "isCanonical": true
        //             }
        //         ]
        //     },
        //     [
        //         {
        //             "dayNtlVlm":"8906.0",
        //             "markPx":"0.14",
        //             "midPx":"0.209265",
        //             "prevDayPx":"0.20432"
        //         }
        //     ]
        // ]
        //
        object first = this.safeDict(response, 0, new Dictionary<string, object>() {});
        object second = this.safeList(response, 1, new List<object>() {});
        object meta = this.safeList(first, "universe", new List<object>() {});
        object tokens = this.safeList(first, "tokens", new List<object>() {});
        object markets = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(meta)); postFixIncrement(ref i))
        {
            object market = this.safeDict(meta, i, new Dictionary<string, object>() {});
            object index = this.safeInteger(market, "index");
            object extraData = this.safeDict(second, index, new Dictionary<string, object>() {});
            object marketName = this.safeString(market, "name");
            // if (marketName.indexOf ('/') < 0) {
            //     // there are some weird spot markets in testnet, eg @2
            //     continue;
            // }
            // const marketParts = marketName.split ('/');
            // const baseName = this.safeString (marketParts, 0);
            // const quoteId = this.safeString (marketParts, 1);
            object fees = this.safeDict(this.fees, "spot", new Dictionary<string, object>() {});
            object taker = this.safeNumber(fees, "taker");
            object maker = this.safeNumber(fees, "maker");
            object tokensPos = this.safeList(market, "tokens", new List<object>() {});
            object baseTokenPos = this.safeInteger(tokensPos, 0);
            object quoteTokenPos = this.safeInteger(tokensPos, 1);
            object baseTokenInfo = this.safeDict(tokens, baseTokenPos, new Dictionary<string, object>() {});
            object quoteTokenInfo = this.safeDict(tokens, quoteTokenPos, new Dictionary<string, object>() {});
            object baseName = this.safeString(baseTokenInfo, "name");
            object quoteId = this.safeString(quoteTokenInfo, "name");
            // do spot currency mapping
            object spotCurrencyMapping = this.safeDict(this.options, "spotCurrencyMapping", new Dictionary<string, object>() {});
            object mappedBaseName = this.safeString(spotCurrencyMapping, baseName, baseName);
            object mappedQuoteId = this.safeString(spotCurrencyMapping, quoteId, quoteId);
            object mappedBase = this.safeCurrencyCode(mappedBaseName);
            object mappedQuote = this.safeCurrencyCode(mappedQuoteId);
            object mappedSymbol = add(add(mappedBase, "/"), mappedQuote);
            object innerBaseTokenInfo = this.safeDict(baseTokenInfo, "spec", baseTokenInfo);
            // const innerQuoteTokenInfo = this.safeDict (quoteTokenInfo, 'spec', quoteTokenInfo);
            object amountPrecisionStr = this.safeString(innerBaseTokenInfo, "szDecimals");
            object amountPrecision = parseInt(amountPrecisionStr);
            object price = this.safeNumber(extraData, "midPx");
            object pricePrecision = 0;
            if (isTrue(!isEqual(price, null)))
            {
                pricePrecision = this.calculatePricePrecision(price, amountPrecision, 8);
            }
            object pricePrecisionStr = this.numberToString(pricePrecision);
            // const quotePrecision = this.parseNumber (this.parsePrecision (this.safeString (innerQuoteTokenInfo, 'szDecimals')));
            object baseId = this.numberToString(add(index, 10000));
            object entry = new Dictionary<string, object>() {
                { "id", marketName },
                { "symbol", mappedSymbol },
                { "base", mappedBase },
                { "quote", mappedQuote },
                { "settle", null },
                { "baseId", baseId },
                { "baseName", baseName },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "subType", null },
                { "margin", null },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", true },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", taker },
                { "maker", maker },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(amountPrecisionStr)) },
                    { "price", this.parseNumber(this.parsePrecision(pricePrecisionStr)) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.parseNumber("10") },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", this.extend(extraData, market) },
            };
            ((IList<object>)markets).Add(this.safeMarketStructure(entry));
        }
        return markets;
    }

    public override object parseMarket(object market)
    {
        //
        //     {
        //         "maxLeverage": "50",
        //         "name": "ETH",
        //         "onlyIsolated": false,
        //         "szDecimals": "4",
        //         "dayNtlVlm": "1709813.11535",
        //         "funding": "0.00004807",
        //         "impactPxs": [
        //             "2369.3",
        //             "2369.6"
        //         ],
        //         "markPx": "2369.6",
        //         "midPx": "2369.45",
        //         "openInterest": "1815.4712",
        //         "oraclePx": "2367.3",
        //         "premium": "0.00090821",
        //         "prevDayPx": "2381.5"
        //         "collateralToken": "0" hip3 tokens only
        //     }
        //
        object collateralTokenCode = this.safeString(market, "collateralTokenName");
        object quoteId = ((bool) isTrue((isEqual(collateralTokenCode, null)))) ? "USDC" : collateralTokenCode;
        object settleId = ((bool) isTrue((isEqual(collateralTokenCode, null)))) ? "USDC" : collateralTokenCode;
        object baseName = this.safeString(market, "name");
        object bs = this.safeCurrencyCode(baseName);
        bs = ((string)bs).Replace((string)":", (string)"-"); // handle hip3 tokens and converts from like flx:crcl to FLX-CRCL
        object quote = this.safeCurrencyCode(quoteId);
        object baseId = this.safeString(market, "baseId");
        object settle = this.safeCurrencyCode(settleId);
        object symbol = add(add(bs, "/"), quote);
        object contract = true;
        object swap = true;
        if (isTrue(contract))
        {
            if (isTrue(swap))
            {
                symbol = add(add(symbol, ":"), settle);
            }
        }
        object fees = this.safeDict(this.fees, "swap", new Dictionary<string, object>() {});
        object taker = this.safeNumber(fees, "taker");
        object maker = this.safeNumber(fees, "maker");
        object amountPrecisionStr = this.safeString(market, "szDecimals");
        object amountPrecision = parseInt(amountPrecisionStr);
        object price = this.safeNumber(market, "markPx", 0);
        object pricePrecision = 0;
        if (isTrue(!isEqual(price, null)))
        {
            pricePrecision = this.calculatePricePrecision(price, amountPrecision, 6);
        }
        object pricePrecisionStr = this.numberToString(pricePrecision);
        object isDelisted = this.safeBool(market, "isDelisted");
        object active = true;
        if (isTrue(!isEqual(isDelisted, null)))
        {
            active = !isTrue(isDelisted);
        }
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", baseId },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "baseName", baseName },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", "swap" },
            { "spot", false },
            { "margin", null },
            { "swap", swap },
            { "future", false },
            { "option", false },
            { "active", active },
            { "contract", contract },
            { "linear", true },
            { "inverse", false },
            { "taker", taker },
            { "maker", maker },
            { "contractSize", this.parseNumber("1") },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.parseNumber(this.parsePrecision(amountPrecisionStr)) },
                { "price", this.parseNumber(this.parsePrecision(pricePrecisionStr)) },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", this.safeInteger(market, "maxLeverage") },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", this.parseNumber("10") },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        });
    }

    public virtual object updateSpotCurrencyCode(object code)
    {
        if (isTrue(isEqual(code, null)))
        {
            return code;
        }
        object spotCurrencyMapping = this.safeDict(this.options, "spotCurrencyMapping", new Dictionary<string, object>() {});
        return this.safeString(spotCurrencyMapping, code, code);
    }

    /**
     * @method
     * @name hyperliquid#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/spot#retrieve-a-users-token-balances
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-users-perpetuals-account-summary
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @param {string} [params.type] wallet type, ['spot', 'swap'], defaults to swap
     * @param {string} [params.marginMode] 'cross' or 'isolated', for margin trading, uses this.options.defaultMarginMode if not passed, defaults to undefined/None/null
     * @param {string} [params.dex] for hip3 markets, the dex name, eg: 'xyz'
     * @param {string} [params.subAccountAddress] sub account user address
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchBalance", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBalance", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object isSpot = (isEqual(type, "spot"));
        object request = new Dictionary<string, object>() {
            { "type", ((bool) isTrue((isSpot))) ? "spotClearinghouseState" : "clearinghouseState" },
            { "user", userAddress },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     {
        //         "assetPositions": [],
        //         "crossMaintenanceMarginUsed": "0.0",
        //         "crossMarginSummary": {
        //             "accountValue": "100.0",
        //             "totalMarginUsed": "0.0",
        //             "totalNtlPos": "0.0",
        //             "totalRawUsd": "100.0"
        //         },
        //         "marginSummary": {
        //             "accountValue": "100.0",
        //             "totalMarginUsed": "0.0",
        //             "totalNtlPos": "0.0",
        //             "totalRawUsd": "100.0"
        //         },
        //         "time": "1704261007014",
        //         "withdrawable": "100.0"
        //     }
        // spot
        //
        //     {
        //         "balances":[
        //            {
        //               "coin":"USDC",
        //               "hold":"0.0",
        //               "total":"1481.844"
        //            },
        //            {
        //               "coin":"PURR",
        //               "hold":"0.0",
        //               "total":"999.65004"
        //            }
        //     }
        //
        object balances = this.safeList(response, "balances");
        if (isTrue(!isEqual(balances, null)))
        {
            object spotBalances = new Dictionary<string, object>() {
                { "info", response },
            };
            for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
            {
                object balance = getValue(balances, i);
                object unifiedCode = this.safeCurrencyCode(this.safeString(balance, "coin"));
                object code = ((bool) isTrue(isSpot)) ? this.updateSpotCurrencyCode(unifiedCode) : unifiedCode;
                object account = this.account();
                object total = this.safeString(balance, "total");
                object used = this.safeString(balance, "hold");
                ((IDictionary<string,object>)account)["total"] = total;
                ((IDictionary<string,object>)account)["used"] = used;
                ((IDictionary<string,object>)spotBalances)[(string)code] = account;
            }
            return this.safeBalance(spotBalances);
        }
        object data = this.safeDict(response, "marginSummary", new Dictionary<string, object>() {});
        object usdcBalance = new Dictionary<string, object>() {
            { "total", this.safeNumber(data, "accountValue") },
        };
        if (isTrue(isTrue((!isEqual(marginMode, null))) && isTrue((isEqual(marginMode, "isolated")))))
        {
            ((IDictionary<string,object>)usdcBalance)["free"] = this.safeNumber(response, "withdrawable");
        } else
        {
            ((IDictionary<string,object>)usdcBalance)["used"] = this.safeNumber(data, "totalMarginUsed");
        }
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "USDC", usdcBalance },
        };
        object timestamp = this.safeInteger(response, "time");
        ((IDictionary<string,object>)result)["timestamp"] = timestamp;
        ((IDictionary<string,object>)result)["datetime"] = this.iso8601(timestamp);
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name hyperliquid#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#l2-book-snapshot
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "type", "l2Book" },
            { "coin", ((bool) isTrue(getValue(market, "swap"))) ? getValue(market, "baseName") : getValue(market, "id") },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     {
        //         "coin": "ETH",
        //         "levels": [
        //             [
        //                 {
        //                     "n": "2",
        //                     "px": "2216.2",
        //                     "sz": "74.0637"
        //                 }
        //             ],
        //             [
        //                 {
        //                     "n": "2",
        //                     "px": "2216.5",
        //                     "sz": "70.5893"
        //                 }
        //             ]
        //         ],
        //         "time": "1704290104840"
        //     }
        //
        object data = this.safeList(response, "levels", new List<object>() {});
        object result = new Dictionary<string, object>() {
            { "bids", this.safeList(data, 0, new List<object>() {}) },
            { "asks", this.safeList(data, 1, new List<object>() {}) },
        };
        object timestamp = this.safeInteger(response, "time");
        return this.parseOrderBook(result, getValue(market, "symbol"), timestamp, "bids", "asks", "px", "sz");
    }

    /**
     * @method
     * @name hyperliquid#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-perpetuals-asset-contexts-includes-mark-price-current-funding-open-interest-etc
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/spot#retrieve-spot-asset-contexts
     * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] 'spot' or 'swap', by default fetches both
     * @param {boolean} [params.hip3] set to true to fetch hip3 markets only
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        // at this stage, to get tickers data, we use fetchMarkets endpoints
        object response = new List<object>() {};
        object type = this.safeString(parameters, "type");
        parameters = this.omit(parameters, "type");
        object hip3 = false;
        var hip3parametersVariable = this.handleOptionAndParams(parameters, "fetchTickers", "hip3", false);
        hip3 = ((IList<object>)hip3parametersVariable)[0];
        parameters = ((IList<object>)hip3parametersVariable)[1];
        if (isTrue(!isEqual(symbols, null)))
        {
            // infer from first symbol
            object firstSymbol = this.safeString(symbols, 0);
            if (isTrue(!isEqual(firstSymbol, null)))
            {
                object market = this.market(firstSymbol);
                if (isTrue(this.safeBool(this.safeDict(market, "info"), "hip3")))
                {
                    hip3 = true;
                }
            }
        }
        if (isTrue(hip3))
        {
            parameters = this.omit(parameters, "hip3");
            response = await this.fetchHip3Markets(parameters);
        } else if (isTrue(isEqual(type, "spot")))
        {
            response = await this.fetchSpotMarkets(parameters);
        } else if (isTrue(isEqual(type, "swap")))
        {
            response = await this.fetchSwapMarkets(parameters);
        } else
        {
            response = await this.fetchMarkets(parameters);
        }
        // same response as under "fetchMarkets"
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object market = getValue(response, i);
            object info = getValue(market, "info");
            object ticker = this.parseTicker(info, market);
            object symbol = this.safeString(ticker, "symbol");
            ((IDictionary<string,object>)result)[(string)symbol] = ticker;
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    /**
     * @method
     * @name hyperliquid#fetchFundingRates
     * @description retrieves data on all swap markets for hyperliquid
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-perpetuals-asset-contexts-includes-mark-price-current-funding-open-interest-etc
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", "metaAndAssetCtxs" },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "universe": [
        //                 {
        //                     "maxLeverage": 50,
        //                     "name": "SOL",
        //                     "onlyIsolated": false,
        //                     "szDecimals": 2
        //                 }
        //             ]
        //         },
        //         [
        //             {
        //                 "dayNtlVlm": "9450588.2273",
        //                 "funding": "0.0000198",
        //                 "impactPxs": [
        //                     "108.04",
        //                     "108.06"
        //                 ],
        //                 "markPx": "108.04",
        //                 "midPx": "108.05",
        //                 "openInterest": "10764.48",
        //                 "oraclePx": "107.99",
        //                 "premium": "0.00055561",
        //                 "prevDayPx": "111.81"
        //             }
        //         ]
        //     ]
        //
        //
        object meta = this.safeDict(response, 0, new Dictionary<string, object>() {});
        object universe = this.safeList(meta, "universe", new List<object>() {});
        object assetCtxs = this.safeList(response, 1, new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(universe)); postFixIncrement(ref i))
        {
            object data = this.extend(this.safeDict(universe, i, new Dictionary<string, object>() {}), this.safeDict(assetCtxs, i, new Dictionary<string, object>() {}));
            ((IList<object>)result).Add(data);
        }
        return this.parseFundingRates(result, symbols);
    }

    public override object parseFundingRate(object info, object market = null)
    {
        //
        //     {
        //         "maxLeverage": "50",
        //         "name": "ETH",
        //         "onlyIsolated": false,
        //         "szDecimals": "4",
        //         "dayNtlVlm": "1709813.11535",
        //         "funding": "0.00004807",
        //         "impactPxs": [
        //             "2369.3",
        //             "2369.6"
        //         ],
        //         "markPx": "2369.6",
        //         "midPx": "2369.45",
        //         "openInterest": "1815.4712",
        //         "oraclePx": "2367.3",
        //         "premium": "0.00090821",
        //         "prevDayPx": "2381.5"
        //     }
        //
        object bs = this.safeString(info, "name");
        object marketId = this.coinToMarketId(bs);
        object symbol = this.safeSymbol(marketId, market);
        object funding = this.safeNumber(info, "funding");
        object markPx = this.safeNumber(info, "markPx");
        object oraclePx = this.safeNumber(info, "oraclePx");
        object fundingTimestamp = multiply(multiply(multiply((add((Math.Floor(Double.Parse((divide(divide(divide(this.milliseconds(), 60), 60), 1000)).ToString()))), 1)), 60), 60), 1000);
        return new Dictionary<string, object>() {
            { "info", info },
            { "symbol", symbol },
            { "markPrice", markPx },
            { "indexPrice", oraclePx },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", funding },
            { "fundingTimestamp", fundingTimestamp },
            { "fundingDatetime", this.iso8601(fundingTimestamp) },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", "1h" },
        };
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "prevDayPx": "3400.5",
        //         "dayNtlVlm": "511297257.47936022",
        //         "markPx": "3464.7",
        //         "midPx": "3465.05",
        //         "oraclePx": "3460.1", // only in swap
        //         "openInterest": "64638.1108", // only in swap
        //         "premium": "0.00141614", // only in swap
        //         "funding": "0.00008727", // only in swap
        //         "impactPxs": [ "3465.0", "3465.1" ], // only in swap
        //         "coin": "PURR", // only in spot
        //         "circulatingSupply": "998949190.03400207", // only in spot
        //     },
        //
        object name = this.safeString(ticker, "name");
        object marketId = this.coinToMarketId(name);
        market = this.safeMarket(marketId, market);
        object bidAsk = this.safeList(ticker, "impactPxs");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", null },
            { "datetime", null },
            { "previousClose", this.safeNumber(ticker, "prevDayPx") },
            { "close", this.safeNumber(ticker, "midPx") },
            { "last", this.safeNumber(ticker, "price") },
            { "bid", this.safeNumber(bidAsk, 0) },
            { "ask", this.safeNumber(bidAsk, 1) },
            { "quoteVolume", this.safeNumber(ticker, "dayNtlVlm") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name hyperliquid#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#candle-snapshot
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents, support '1m', '15m', '1h', '1d'
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object until = this.safeInteger(parameters, "until", this.milliseconds());
        object useTail = isEqual(since, null);
        object originalSince = since;
        if (isTrue(isEqual(since, null)))
        {
            if (isTrue(!isEqual(limit, null)))
            {
                // optimization if limit is provided
                object timeframeInMilliseconds = multiply(this.parseTimeframe(timeframe), 1000);
                since = this.sum(until, multiply(multiply(timeframeInMilliseconds, limit), -1));
                if (isTrue(isLessThan(since, 0)))
                {
                    since = 0;
                }
                useTail = false;
            } else
            {
                since = 0;
            }
        }
        parameters = this.omit(parameters, new List<object>() {"until"});
        object request = new Dictionary<string, object>() {
            { "type", "candleSnapshot" },
            { "req", new Dictionary<string, object>() {
                { "coin", ((bool) isTrue(getValue(market, "swap"))) ? getValue(market, "baseName") : getValue(market, "id") },
                { "interval", this.safeString(this.timeframes, timeframe, timeframe) },
                { "startTime", since },
                { "endTime", until },
            } },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "T": 1704287699999,
        //             "c": "2226.4",
        //             "h": "2247.9",
        //             "i": "15m",
        //             "l": "2224.6",
        //             "n": 46,
        //             "o": "2247.9",
        //             "s": "ETH",
        //             "t": 1704286800000,
        //             "v": "591.6427"
        //         }
        //     ]
        //
        return this.parseOHLCVs(response, market, timeframe, originalSince, limit, useTail);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "T": 1704287699999,
        //         "c": "2226.4",
        //         "h": "2247.9",
        //         "i": "15m",
        //         "l": "2224.6",
        //         "n": 46,
        //         "o": "2247.9",
        //         "s": "ETH",
        //         "t": 1704286800000,
        //         "v": "591.6427"
        //     }
        //
        return new List<object> {this.safeInteger(ohlcv, "t"), this.safeNumber(ohlcv, "o"), this.safeNumber(ohlcv, "h"), this.safeNumber(ohlcv, "l"), this.safeNumber(ohlcv, "c"), this.safeNumber(ohlcv, "v")};
    }

    /**
     * @method
     * @name hyperliquid#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills-by-time
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest trade
     * @param {string} [params.address] wallet address that made trades
     * @param {string} [params.user] wallet address that made trades
     * @param {string} [params.subAccountAddress] sub account user address
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchTrades", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "user", userAddress },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["type"] = "userFillsByTime";
            ((IDictionary<string,object>)request)["startTime"] = since;
        } else
        {
            ((IDictionary<string,object>)request)["type"] = "userFills";
        }
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "closedPnl": "0.19343",
        //             "coin": "ETH",
        //             "crossed": true,
        //             "dir": "Close Long",
        //             "fee": "0.050062",
        //             "hash": "0x09d77c96791e98b5775a04092584ab010d009445119c71e4005c0d634ea322bc",
        //             "liquidationMarkPx": null,
        //             "oid": 3929354691,
        //             "px": "2381.1",
        //             "side": "A",
        //             "startPosition": "0.0841",
        //             "sz": "0.0841",
        //             "tid": 128423918764978,
        //             "time": 1704262888911
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public override object amountToPrecision(object symbol, object amount)
    {
        object market = this.market(symbol);
        return this.decimalToPrecision(amount, ROUND, getValue(getValue(market, "precision"), "amount"), this.precisionMode, this.paddingMode);
    }

    public override object priceToPrecision(object symbol, object price)
    {
        object market = this.market(symbol);
        object priceStr = this.numberToString(price);
        object integerPart = getValue(((string)priceStr).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>(), 0);
        object significantDigits = mathMax(5, ((string)integerPart).Length);
        object result = this.decimalToPrecision(price, ROUND, significantDigits, SIGNIFICANT_DIGITS, this.paddingMode);
        object maxDecimals = ((bool) isTrue(getValue(market, "spot"))) ? 8 : 6;
        object subtractedValue = subtract(maxDecimals, this.precisionFromString(this.safeString(getValue(market, "precision"), "amount")));
        return this.decimalToPrecision(result, ROUND, subtractedValue, DECIMAL_PLACES, this.paddingMode);
    }

    public virtual object hashMessage(object message)
    {
        return add("0x", this.hash(message, keccak, "hex"));
    }

    public virtual object signHash(object hash, object privateKey)
    {
        object signature = ecdsa(slice(hash, -64, null), slice(privateKey, -64, null), secp256k1, null);
        return new Dictionary<string, object>() {
            { "r", add("0x", getValue(signature, "r")) },
            { "s", add("0x", getValue(signature, "s")) },
            { "v", this.sum(27, getValue(signature, "v")) },
        };
    }

    public virtual object signMessage(object message, object privateKey)
    {
        return this.signHash(this.hashMessage(message), slice(privateKey, -64, null));
    }

    public virtual object constructPhantomAgent(object hash, object isTestnet = null)
    {
        isTestnet ??= true;
        object source = ((bool) isTrue((isTestnet))) ? "b" : "a";
        return new Dictionary<string, object>() {
            { "source", source },
            { "connectionId", hash },
        };
    }

    public virtual object actionHash(object action, object vaultAddress, object nonce, object expiresAfter = null)
    {
        object dataBinary = this.packb(action);
        object dataHex = this.binaryToBase16(dataBinary);
        object data = dataHex;
        data = add(data, add("00000", this.intToBase16(nonce)));
        if (isTrue(isEqual(vaultAddress, null)))
        {
            data = add(data, "00");
        } else
        {
            data = add(data, "01");
            data = add(data, vaultAddress);
        }
        if (isTrue(!isEqual(expiresAfter, null)))
        {
            data = add(data, "00");
            data = add(data, add("00000", this.intToBase16(expiresAfter)));
        }
        return this.hash(this.base16ToBinary(data), keccak, "binary");
    }

    public virtual object signL1Action(object action, object nonce, object vaultAdress = null, object expiresAfter = null)
    {
        object hash = this.actionHash(action, vaultAdress, nonce, expiresAfter);
        object isTestnet = this.safeBool(this.options, "sandboxMode", false);
        object phantomAgent = this.constructPhantomAgent(hash, isTestnet);
        // const data: Dict = {
        //     'domain': {
        //         'chainId': 1337,
        //         'name': 'Exchange',
        //         'verifyingContract': '0x0000000000000000000000000000000000000000',
        //         'version': '1',
        //     },
        //     'types': {
        //         'Agent': [
        //             { 'name': 'source', 'type': 'string' },
        //             { 'name': 'connectionId', 'type': 'bytes32' },
        //         ],
        //         'EIP712Domain': [
        //             { 'name': 'name', 'type': 'string' },
        //             { 'name': 'version', 'type': 'string' },
        //             { 'name': 'chainId', 'type': 'uint256' },
        //             { 'name': 'verifyingContract', 'type': 'address' },
        //         ],
        //     },
        //     'primaryType': 'Agent',
        //     'message': phantomAgent,
        // };
        object zeroAddress = this.safeString(this.options, "zeroAddress");
        object chainId = 1337; // check this out
        object domain = new Dictionary<string, object>() {
            { "chainId", chainId },
            { "name", "Exchange" },
            { "verifyingContract", zeroAddress },
            { "version", "1" },
        };
        object messageTypes = new Dictionary<string, object>() {
            { "Agent", new List<object>() {new Dictionary<string, object>() {
    { "name", "source" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "connectionId" },
    { "type", "bytes32" },
}} },
        };
        object msg = this.ethEncodeStructuredData(domain, messageTypes, phantomAgent);
        object signature = this.signMessage(msg, this.privateKey);
        return signature;
    }

    public virtual object signUserSignedAction(object messageTypes, object message)
    {
        object zeroAddress = this.safeString(this.options, "zeroAddress");
        object chainId = 421614; // check this out
        object domain = new Dictionary<string, object>() {
            { "chainId", chainId },
            { "name", "HyperliquidSignTransaction" },
            { "verifyingContract", zeroAddress },
            { "version", "1" },
        };
        object msg = this.ethEncodeStructuredData(domain, messageTypes, message);
        object signature = this.signMessage(msg, this.privateKey);
        return signature;
    }

    public virtual object buildUsdSendSig(object message)
    {
        object messageTypes = new Dictionary<string, object>() {
            { "HyperliquidTransaction:UsdSend", new List<object>() {new Dictionary<string, object>() {
    { "name", "hyperliquidChain" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "destination" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "amount" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "time" },
    { "type", "uint64" },
}} },
        };
        return this.signUserSignedAction(messageTypes, message);
    }

    public virtual object buildUsdClassSendSig(object message)
    {
        object messageTypes = new Dictionary<string, object>() {
            { "HyperliquidTransaction:UsdClassTransfer", new List<object>() {new Dictionary<string, object>() {
    { "name", "hyperliquidChain" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "amount" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "toPerp" },
    { "type", "bool" },
}, new Dictionary<string, object>() {
    { "name", "nonce" },
    { "type", "uint64" },
}} },
        };
        return this.signUserSignedAction(messageTypes, message);
    }

    public virtual object buildWithdrawSig(object message)
    {
        object messageTypes = new Dictionary<string, object>() {
            { "HyperliquidTransaction:Withdraw", new List<object>() {new Dictionary<string, object>() {
    { "name", "hyperliquidChain" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "destination" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "amount" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "time" },
    { "type", "uint64" },
}} },
        };
        return this.signUserSignedAction(messageTypes, message);
    }

    public virtual object buildUserDexAbstractionSig(object message)
    {
        object messageTypes = new Dictionary<string, object>() {
            { "HyperliquidTransaction:UserDexAbstraction", new List<object>() {new Dictionary<string, object>() {
    { "name", "hyperliquidChain" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "user" },
    { "type", "address" },
}, new Dictionary<string, object>() {
    { "name", "enabled" },
    { "type", "bool" },
}, new Dictionary<string, object>() {
    { "name", "nonce" },
    { "type", "uint64" },
}} },
        };
        return this.signUserSignedAction(messageTypes, message);
    }

    public virtual object buildApproveBuilderFeeSig(object message)
    {
        object messageTypes = new Dictionary<string, object>() {
            { "HyperliquidTransaction:ApproveBuilderFee", new List<object>() {new Dictionary<string, object>() {
    { "name", "hyperliquidChain" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "maxFeeRate" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "builder" },
    { "type", "address" },
}, new Dictionary<string, object>() {
    { "name", "nonce" },
    { "type", "uint64" },
}} },
        };
        return this.signUserSignedAction(messageTypes, message);
    }

    public async virtual Task<object> setRef()
    {
        if (isTrue(this.safeBool(this.options, "refSet", false)))
        {
            return true;
        }
        ((IDictionary<string,object>)this.options)["refSet"] = true;
        object action = new Dictionary<string, object>() {
            { "type", "setReferrer" },
            { "code", this.safeString(this.options, "ref", "CCXT1") },
        };
        object nonce = this.milliseconds();
        object signature = this.signL1Action(action, nonce);
        object request = new Dictionary<string, object>() {
            { "action", action },
            { "nonce", nonce },
            { "signature", signature },
        };
        object response = null;
        try
        {
            response = await this.privatePostExchange(request);
            return response;
        } catch(Exception e)
        {
            response = null; // ignore this
        }
        return response;
    }

    public async virtual Task<object> approveBuilderFee(object builder, object maxFeeRate)
    {
        object nonce = this.milliseconds();
        object isSandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object payload = new Dictionary<string, object>() {
            { "hyperliquidChain", ((bool) isTrue(isSandboxMode)) ? "Testnet" : "Mainnet" },
            { "maxFeeRate", maxFeeRate },
            { "builder", builder },
            { "nonce", nonce },
        };
        object sig = this.buildApproveBuilderFeeSig(payload);
        object action = new Dictionary<string, object>() {
            { "hyperliquidChain", getValue(payload, "hyperliquidChain") },
            { "signatureChainId", "0x66eee" },
            { "maxFeeRate", getValue(payload, "maxFeeRate") },
            { "builder", getValue(payload, "builder") },
            { "nonce", nonce },
            { "type", "approveBuilderFee" },
        };
        object request = new Dictionary<string, object>() {
            { "action", action },
            { "nonce", nonce },
            { "signature", sig },
            { "vaultAddress", null },
        };
        //
        // {
        //     "status": "ok",
        //     "response": {
        //         "type": "default"
        //     }
        // }
        //
        return await this.privatePostExchange(request);
    }

    public async virtual Task<object> initializeClient()
    {
        try
        {
            await promiseAll(new List<object> {this.handleBuilderFeeApproval(), this.setRef()});
        } catch(Exception e)
        {
            return false;
        }
        return true;
    }

    public async virtual Task<object> handleBuilderFeeApproval()
    {
        object buildFee = this.safeBool(this.options, "builderFee", true);
        if (!isTrue(buildFee))
        {
            return false;  // skip if builder fee is not enabled
        }
        object approvedBuilderFee = this.safeBool(this.options, "approvedBuilderFee", false);
        if (isTrue(approvedBuilderFee))
        {
            return true;  // skip if builder fee is already approved
        }
        try
        {
            object builder = this.safeString(this.options, "builder", "0x6530512A6c89C7cfCEbC3BA7fcD9aDa5f30827a6");
            object maxFeeRate = this.safeString(this.options, "feeRate", "0.01%");
            await this.approveBuilderFee(builder, maxFeeRate);
            ((IDictionary<string,object>)this.options)["approvedBuilderFee"] = true;
        } catch(Exception e)
        {
            ((IDictionary<string,object>)this.options)["builderFee"] = false; // disable builder fee if an error occurs
        }
        return true;
    }

    public async virtual Task<object> enableUserDexAbstraction(object enabled, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("enableUserDexAbstraction", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object nonce = this.milliseconds();
        object isSandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object payload = new Dictionary<string, object>() {
            { "hyperliquidChain", ((bool) isTrue(isSandboxMode)) ? "Testnet" : "Mainnet" },
            { "user", userAddress },
            { "enabled", enabled },
            { "nonce", nonce },
        };
        object sig = this.buildUserDexAbstractionSig(payload);
        object action = new Dictionary<string, object>() {
            { "hyperliquidChain", getValue(payload, "hyperliquidChain") },
            { "signatureChainId", "0x66eee" },
            { "enabled", getValue(payload, "enabled") },
            { "user", getValue(payload, "user") },
            { "nonce", nonce },
            { "type", "userDexAbstraction" },
        };
        object request = new Dictionary<string, object>() {
            { "action", action },
            { "nonce", nonce },
            { "signature", sig },
            { "vaultAddress", null },
        };
        //
        // {
        //     "status": "ok",
        //     "response": {
        //         "type": "default"
        //     }
        // }
        //
        return await this.privatePostExchange(request);
    }

    /**
     * @method
     * @name hyperliquid#createOrder
     * @description create a trade order
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#place-an-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.timeInForce] 'Gtc', 'Ioc', 'Alo'
     * @param {bool} [params.postOnly] true or false whether the order is post-only
     * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only
     * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
     * @param {string} [params.clientOrderId] client order id, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
     * @param {string} [params.slippage] the slippage for market order
     * @param {string} [params.vaultAddress] the vault address for order
     * @param {string} [params.subAccountAddress] sub account user address
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        var orderglobalParamsVariable = this.parseCreateEditOrderArgs(null, symbol, type, side, amount, price, parameters);
        var order = ((IList<object>) orderglobalParamsVariable)[0];
        var globalParams = ((IList<object>) orderglobalParamsVariable)[1];
        object orders = await this.createOrders(new List<object>() {((object)order)}, globalParams);
        return getValue(orders, 0);
    }

    /**
     * @method
     * @name hyperliquid#createOrders
     * @description create a list of trade orders
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#place-an-order
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.initializeClient();
        object request = this.createOrdersRequest(orders, parameters);
        object response = await this.privatePostExchange(request);
        //
        //     {
        //         "status": "ok",
        //         "response": {
        //             "type": "order",
        //             "data": {
        //                 "statuses": [
        //                     {
        //                         "resting": {
        //                             "oid": 5063830287
        //                         }
        //                     }
        //                 ]
        //             }
        //         }
        //     }
        //
        object responseObj = this.safeDict(response, "response", new Dictionary<string, object>() {});
        object data = this.safeDict(responseObj, "data", new Dictionary<string, object>() {});
        object statuses = this.safeList(data, "statuses", new List<object>() {});
        object ordersToBeParsed = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(statuses)); postFixIncrement(ref i))
        {
            object order = getValue(statuses, i);
            if (isTrue(isEqual(order, "waitingForTrigger")))
            {
                ((IList<object>)ordersToBeParsed).Add(new Dictionary<string, object>() {
                    { "status", order },
                }); // tp/sl orders can return a string like "waitingForTrigger",
            } else
            {
                ((IList<object>)ordersToBeParsed).Add(order);
            }
        }
        return this.parseOrders(ordersToBeParsed, null);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        type = ((string)type).ToUpper();
        side = ((string)side).ToUpper();
        object isMarket = (isEqual(type, "MARKET"));
        object isBuy = (isEqual(side, "BUY"));
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "client_id");
        object slippage = this.safeString(parameters, "slippage");
        object defaultTimeInForce = ((bool) isTrue((isMarket))) ? "ioc" : "gtc";
        object postOnly = this.safeBool(parameters, "postOnly", false);
        if (isTrue(postOnly))
        {
            defaultTimeInForce = "alo";
        }
        object timeInForce = this.safeStringLower(parameters, "timeInForce", defaultTimeInForce);
        timeInForce = this.capitalize(timeInForce);
        object triggerPrice = this.safeString2(parameters, "triggerPrice", "stopPrice");
        object stopLossPrice = this.safeString(parameters, "stopLossPrice", triggerPrice);
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        object isTrigger = (isTrue(stopLossPrice) || isTrue(takeProfitPrice));
        object px = null;
        if (isTrue(isMarket))
        {
            if (isTrue(isEqual(price, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, "  market orders require price to calculate the max slippage price. Default slippage can be set in options (default is 5%).")) ;
            }
            px = ((bool) isTrue((isBuy))) ? Precise.stringMul(price, Precise.stringAdd("1", slippage)) : Precise.stringMul(price, Precise.stringSub("1", slippage));
            px = this.priceToPrecision(symbol, px); // round after adding slippage
        } else
        {
            px = this.priceToPrecision(symbol, price);
        }
        object sz = this.amountToPrecision(symbol, amount);
        object reduceOnly = this.safeBool(parameters, "reduceOnly", false);
        object orderType = new Dictionary<string, object>() {};
        if (isTrue(isTrigger))
        {
            object isTp = false;
            if (isTrue(!isEqual(takeProfitPrice, null)))
            {
                triggerPrice = this.priceToPrecision(symbol, takeProfitPrice);
                isTp = true;
            } else
            {
                triggerPrice = this.priceToPrecision(symbol, stopLossPrice);
            }
            ((IDictionary<string,object>)orderType)["trigger"] = new Dictionary<string, object>() {
                { "isMarket", isMarket },
                { "triggerPx", triggerPrice },
                { "tpsl", ((bool) isTrue((isTp))) ? "tp" : "sl" },
            };
        } else
        {
            ((IDictionary<string,object>)orderType)["limit"] = new Dictionary<string, object>() {
                { "tif", timeInForce },
            };
        }
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "slippage", "triggerPrice", "stopPrice", "stopLossPrice", "takeProfitPrice", "timeInForce", "client_id", "reduceOnly", "postOnly"});
        object orderObj = new Dictionary<string, object>() {
            { "a", this.parseToInt(getValue(market, "baseId")) },
            { "b", isBuy },
            { "p", px },
            { "s", sz },
            { "r", reduceOnly },
            { "t", orderType },
        };
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)orderObj)["c"] = clientOrderId;
        }
        return orderObj;
    }

    public virtual object createOrdersRequest(object orders, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#createOrdersRequest
        * @description create a list of trade orders
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#place-an-order
        * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object defaultSlippage = this.safeString(this.options, "defaultSlippage");
        defaultSlippage = this.safeString(parameters, "slippage", defaultSlippage);
        object hasClientOrderId = false;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object clientOrderId = this.safeString2(orderParams, "clientOrderId", "client_id");
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                hasClientOrderId = true;
            }
        }
        if (isTrue(hasClientOrderId))
        {
            for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
            {
                object rawOrder = getValue(orders, i);
                object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
                object clientOrderId = this.safeString2(orderParams, "clientOrderId", "client_id");
                if (isTrue(isEqual(clientOrderId, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " createOrders() all orders must have clientOrderId if at least one has a clientOrderId")) ;
                }
            }
        }
        parameters = this.omit(parameters, new List<object>() {"slippage", "clientOrderId", "client_id", "slippage", "triggerPrice", "stopPrice", "stopLossPrice", "takeProfitPrice", "timeInForce"});
        object nonce = this.milliseconds();
        object orderReq = new List<object>() {};
        object grouping = "na";
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            object market = this.market(marketId);
            object symbol = getValue(market, "symbol");
            object type = this.safeStringUpper(rawOrder, "type");
            object side = this.safeStringUpper(rawOrder, "side");
            object amount = this.safeString(rawOrder, "amount");
            object price = this.safeString(rawOrder, "price");
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object slippage = this.safeString(orderParams, "slippage", defaultSlippage);
            ((IDictionary<string,object>)orderParams)["slippage"] = slippage;
            object stopLoss = this.safeValue(orderParams, "stopLoss");
            object takeProfit = this.safeValue(orderParams, "takeProfit");
            object hasStopLoss = (!isEqual(stopLoss, null));
            object hasTakeProfit = (!isEqual(takeProfit, null));
            orderParams = this.omit(orderParams, new List<object>() {"stopLoss", "takeProfit"});
            object mainOrderObj = this.createOrderRequest(symbol, type, side, amount, price, orderParams);
            ((IList<object>)orderReq).Add(mainOrderObj);
            if (isTrue(isTrue(hasStopLoss) || isTrue(hasTakeProfit)))
            {
                // grouping opposed orders for sl/tp
                object stopLossOrderTriggerPrice = this.safeStringN(stopLoss, new List<object>() {"triggerPrice", "stopPrice"});
                object stopLossOrderType = this.safeString(stopLoss, "type", "limit");
                object stopLossOrderLimitPrice = this.safeStringN(stopLoss, new List<object>() {"price", "stopLossPrice"}, stopLossOrderTriggerPrice);
                object takeProfitOrderTriggerPrice = this.safeStringN(takeProfit, new List<object>() {"triggerPrice", "stopPrice"});
                object takeProfitOrderType = this.safeString(takeProfit, "type", "limit");
                object takeProfitOrderLimitPrice = this.safeStringN(takeProfit, new List<object>() {"price", "takeProfitPrice"}, takeProfitOrderTriggerPrice);
                grouping = "normalTpsl";
                orderParams = this.omit(orderParams, new List<object>() {"stopLoss", "takeProfit"});
                object triggerOrderSide = "";
                if (isTrue(isEqual(side, "BUY")))
                {
                    triggerOrderSide = "sell";
                } else
                {
                    triggerOrderSide = "buy";
                }
                if (isTrue(hasTakeProfit))
                {
                    object orderObj = this.createOrderRequest(symbol, takeProfitOrderType, triggerOrderSide, amount, takeProfitOrderLimitPrice, this.extend(orderParams, new Dictionary<string, object>() {
                        { "takeProfitPrice", takeProfitOrderTriggerPrice },
                        { "reduceOnly", true },
                    }));
                    ((IList<object>)orderReq).Add(orderObj);
                }
                if (isTrue(hasStopLoss))
                {
                    object orderObj = this.createOrderRequest(symbol, stopLossOrderType, triggerOrderSide, amount, stopLossOrderLimitPrice, this.extend(orderParams, new Dictionary<string, object>() {
                        { "stopLossPrice", stopLossOrderTriggerPrice },
                        { "reduceOnly", true },
                    }));
                    ((IList<object>)orderReq).Add(orderObj);
                }
            }
        }
        object vaultAddress = null;
        var vaultAddressparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "vaultAddress");
        vaultAddress = ((IList<object>)vaultAddressparametersVariable)[0];
        parameters = ((IList<object>)vaultAddressparametersVariable)[1];
        vaultAddress = this.formatVaultAddress(vaultAddress);
        object orderAction = new Dictionary<string, object>() {
            { "type", "order" },
            { "orders", orderReq },
            { "grouping", grouping },
        };
        if (isTrue(this.safeBool(this.options, "approvedBuilderFee", false)))
        {
            object wallet = this.safeStringLower(this.options, "builder", "0x6530512A6c89C7cfCEbC3BA7fcD9aDa5f30827a6");
            ((IDictionary<string,object>)orderAction)["builder"] = new Dictionary<string, object>() {
                { "b", wallet },
                { "f", this.safeInteger(this.options, "feeInt", 10) },
            };
        }
        object signature = this.signL1Action(orderAction, nonce, vaultAddress);
        object request = new Dictionary<string, object>() {
            { "action", orderAction },
            { "nonce", nonce },
            { "signature", signature },
        };
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            parameters = this.omit(parameters, "vaultAddress");
            ((IDictionary<string,object>)request)["vaultAddress"] = vaultAddress;
        }
        return request;
    }

    /**
     * @method
     * @name hyperliquid#cancelOrder
     * @description cancels an open order
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s-by-cloid
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] client order id, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
     * @param {string} [params.vaultAddress] the vault address for order
     * @param {string} [params.subAccountAddress] sub account user address
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object orders = await this.cancelOrders(new List<object>() {id}, symbol, parameters);
        return this.safeDict(orders, 0);
    }

    /**
     * @method
     * @name hyperliquid#cancelOrders
     * @description cancel multiple orders
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s-by-cloid
     * @param {string[]} ids order ids
     * @param {string} [symbol] unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string|string[]} [params.clientOrderId] client order ids, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
     * @param {string} [params.vaultAddress] the vault address
     * @param {string} [params.subAccountAddress] sub account user address
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        await this.initializeClient();
        object request = this.cancelOrdersRequest(ids, symbol, parameters);
        object response = await this.privatePostExchange(request);
        //
        //     {
        //         "status":"ok",
        //         "response":{
        //             "type":"cancel",
        //             "data":{
        //                 "statuses":[
        //                     "success"
        //                 ]
        //             }
        //         }
        //     }
        //
        object innerResponse = this.safeDict(response, "response");
        object data = this.safeDict(innerResponse, "data");
        object statuses = this.safeList(data, "statuses");
        object orders = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(statuses)); postFixIncrement(ref i))
        {
            object status = getValue(statuses, i);
            ((IList<object>)orders).Add(this.safeOrder(new Dictionary<string, object>() {
                { "info", status },
                { "status", status },
            }));
        }
        return orders;
    }

    public virtual object cancelOrdersRequest(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name hyperliquid#cancelOrdersRequest
        * @description build the request payload for cancelling multiple orders
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s
        * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s-by-cloid
        * @param {string[]} ids order ids
        * @param {string} symbol unified market symbol
        * @param {object} [params]
        * @returns {object} the raw request object to be sent to the exchange
        */
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object clientOrderId = this.safeValue2(parameters, "clientOrderId", "client_id");
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "client_id"});
        object nonce = this.milliseconds();
        object request = new Dictionary<string, object>() {
            { "nonce", nonce },
        };
        object cancelReq = new List<object>() {};
        object cancelAction = new Dictionary<string, object>() {
            { "type", "" },
            { "cancels", new List<object>() {} },
        };
        object baseId = this.parseToNumeric(getValue(market, "baseId"));
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            if (!isTrue(((clientOrderId is IList<object>) || (clientOrderId.GetType().IsGenericType && clientOrderId.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                clientOrderId = new List<object>() {clientOrderId};
            }
            ((IDictionary<string,object>)cancelAction)["type"] = "cancelByCloid";
            for (object i = 0; isLessThan(i, getArrayLength(clientOrderId)); postFixIncrement(ref i))
            {
                ((IList<object>)cancelReq).Add(new Dictionary<string, object>() {
                    { "asset", baseId },
                    { "cloid", getValue(clientOrderId, i) },
                });
            }
        } else
        {
            ((IDictionary<string,object>)cancelAction)["type"] = "cancel";
            for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
            {
                ((IList<object>)cancelReq).Add(new Dictionary<string, object>() {
                    { "a", baseId },
                    { "o", this.parseToNumeric(getValue(ids, i)) },
                });
            }
        }
        ((IDictionary<string,object>)cancelAction)["cancels"] = cancelReq;
        object vaultAddress = null;
        var vaultAddressparametersVariable = this.handleOptionAndParams2(parameters, "cancelOrders", "vaultAddress", "subAccountAddress");
        vaultAddress = ((IList<object>)vaultAddressparametersVariable)[0];
        parameters = ((IList<object>)vaultAddressparametersVariable)[1];
        vaultAddress = this.formatVaultAddress(vaultAddress);
        object signature = this.signL1Action(cancelAction, nonce, vaultAddress);
        ((IDictionary<string,object>)request)["action"] = cancelAction;
        ((IDictionary<string,object>)request)["signature"] = signature;
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            parameters = this.omit(parameters, "vaultAddress");
            ((IDictionary<string,object>)request)["vaultAddress"] = vaultAddress;
        }
        return request;
    }

    /**
     * @method
     * @name hyperliquid#cancelOrdersForSymbols
     * @description cancel multiple orders for multiple symbols
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s-by-cloid
     * @param {CancellationRequest[]} orders each order should contain the parameters required by cancelOrder namely id and symbol, example [{"id": "a", "symbol": "BTC/USDT"}, {"id": "b", "symbol": "ETH/USDT"}]
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.vaultAddress] the vault address
     * @param {string} [params.subAccountAddress] sub account user address
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelOrdersForSymbols(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        await this.loadMarkets();
        await this.initializeClient();
        object nonce = this.milliseconds();
        object request = new Dictionary<string, object>() {
            { "nonce", nonce },
        };
        object cancelReq = new List<object>() {};
        object cancelAction = new Dictionary<string, object>() {
            { "type", "" },
            { "cancels", new List<object>() {} },
        };
        object cancelByCloid = false;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object order = getValue(orders, i);
            object clientOrderId = this.safeString(order, "clientOrderId");
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                cancelByCloid = true;
            }
            object id = this.safeString(order, "id");
            object symbol = this.safeString(order, "symbol");
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " cancelOrdersForSymbols() requires a symbol argument in each order")) ;
            }
            if (isTrue(isTrue(!isEqual(id, null)) && isTrue(cancelByCloid)))
            {
                throw new BadRequest ((string)add(this.id, " cancelOrdersForSymbols() all orders must have either id or clientOrderId")) ;
            }
            object assetKey = ((bool) isTrue(cancelByCloid)) ? "asset" : "a";
            object idKey = ((bool) isTrue(cancelByCloid)) ? "cloid" : "o";
            object market = this.market(symbol);
            object cancelObj = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)cancelObj)[(string)assetKey] = this.parseToNumeric(getValue(market, "baseId"));
            ((IDictionary<string,object>)cancelObj)[(string)idKey] = ((bool) isTrue(cancelByCloid)) ? clientOrderId : this.parseToNumeric(id);
            ((IList<object>)cancelReq).Add(cancelObj);
        }
        ((IDictionary<string,object>)cancelAction)["type"] = ((bool) isTrue(cancelByCloid)) ? "cancelByCloid" : "cancel";
        ((IDictionary<string,object>)cancelAction)["cancels"] = cancelReq;
        object vaultAddress = null;
        var vaultAddressparametersVariable = this.handleOptionAndParams2(parameters, "cancelOrdersForSymbols", "vaultAddress", "subAccountAddress");
        vaultAddress = ((IList<object>)vaultAddressparametersVariable)[0];
        parameters = ((IList<object>)vaultAddressparametersVariable)[1];
        vaultAddress = this.formatVaultAddress(vaultAddress);
        object signature = this.signL1Action(cancelAction, nonce, vaultAddress);
        ((IDictionary<string,object>)request)["action"] = cancelAction;
        ((IDictionary<string,object>)request)["signature"] = signature;
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            parameters = this.omit(parameters, "vaultAddress");
            ((IDictionary<string,object>)request)["vaultAddress"] = vaultAddress;
        }
        object response = await this.privatePostExchange(request);
        //
        //     {
        //         "status":"ok",
        //         "response":{
        //             "type":"cancel",
        //             "data":{
        //                 "statuses":[
        //                     "success"
        //                 ]
        //             }
        //         }
        //     }
        //
        return new List<object> {this.safeOrder(new Dictionary<string, object>() {
    { "info", response },
})};
    }

    /**
     * @method
     * @name hyperliquid#cancelAllOrdersAfter
     * @description dead man's switch, cancel all orders after the given timeout
     * @param {number} timeout time in milliseconds, 0 represents cancel the timer
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.vaultAddress] the vault address
     * @param {string} [params.subAccountAddress] sub account user address
     * @returns {object} the api result
     */
    public async override Task<object> cancelAllOrdersAfter(object timeout, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        await this.loadMarkets();
        await this.initializeClient();
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "client_id"});
        object nonce = this.milliseconds();
        object request = new Dictionary<string, object>() {
            { "nonce", nonce },
        };
        object cancelAction = new Dictionary<string, object>() {
            { "type", "scheduleCancel" },
            { "time", add(nonce, timeout) },
        };
        object vaultAddress = null;
        var vaultAddressparametersVariable = this.handleOptionAndParams2(parameters, "cancelAllOrdersAfter", "vaultAddress", "subAccountAddress");
        vaultAddress = ((IList<object>)vaultAddressparametersVariable)[0];
        parameters = ((IList<object>)vaultAddressparametersVariable)[1];
        vaultAddress = this.formatVaultAddress(vaultAddress);
        object signature = this.signL1Action(cancelAction, nonce, vaultAddress);
        ((IDictionary<string,object>)request)["action"] = cancelAction;
        ((IDictionary<string,object>)request)["signature"] = signature;
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            parameters = this.omit(parameters, "vaultAddress");
            ((IDictionary<string,object>)request)["vaultAddress"] = vaultAddress;
        }
        object response = await this.privatePostExchange(request);
        //
        //     {
        //         "status":"err",
        //         "response":"Cannot set scheduled cancel time until enough volume traded. Required: $1000000. Traded: $373.47205."
        //     }
        //
        return response;
    }

    public virtual object editOrdersRequest(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object hasClientOrderId = false;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object clientOrderId = this.safeString2(orderParams, "clientOrderId", "client_id");
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                hasClientOrderId = true;
            }
        }
        if (isTrue(hasClientOrderId))
        {
            for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
            {
                object rawOrder = getValue(orders, i);
                object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
                object clientOrderId = this.safeString2(orderParams, "clientOrderId", "client_id");
                if (isTrue(isEqual(clientOrderId, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " editOrders() all orders must have clientOrderId if at least one has a clientOrderId")) ;
                }
            }
        }
        parameters = this.omit(parameters, new List<object>() {"slippage", "clientOrderId", "client_id", "slippage", "triggerPrice", "stopPrice", "stopLossPrice", "takeProfitPrice", "timeInForce"});
        object modifies = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object id = this.safeString(rawOrder, "id");
            object marketId = this.safeString(rawOrder, "symbol");
            object market = this.market(marketId);
            object symbol = getValue(market, "symbol");
            object type = this.safeStringUpper(rawOrder, "type");
            object isMarket = (isEqual(type, "MARKET"));
            object side = this.safeStringUpper(rawOrder, "side");
            object isBuy = (isEqual(side, "BUY"));
            object amount = this.safeString(rawOrder, "amount");
            object price = this.safeString(rawOrder, "price");
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object defaultSlippage = this.safeString(this.options, "defaultSlippage");
            object slippage = this.safeString(orderParams, "slippage", defaultSlippage);
            object defaultTimeInForce = ((bool) isTrue((isMarket))) ? "ioc" : "gtc";
            object postOnly = this.safeBool(orderParams, "postOnly", false);
            if (isTrue(postOnly))
            {
                defaultTimeInForce = "alo";
            }
            object timeInForce = this.safeStringLower(orderParams, "timeInForce", defaultTimeInForce);
            timeInForce = this.capitalize(timeInForce);
            object clientOrderId = this.safeString2(orderParams, "clientOrderId", "client_id");
            object triggerPrice = this.safeString2(orderParams, "triggerPrice", "stopPrice");
            object stopLossPrice = this.safeString(orderParams, "stopLossPrice", triggerPrice);
            object takeProfitPrice = this.safeString(orderParams, "takeProfitPrice");
            object isTrigger = (isTrue(stopLossPrice) || isTrue(takeProfitPrice));
            object reduceOnly = this.safeBool(orderParams, "reduceOnly", false);
            orderParams = this.omit(orderParams, new List<object>() {"slippage", "timeInForce", "triggerPrice", "stopLossPrice", "takeProfitPrice", "clientOrderId", "client_id", "postOnly", "reduceOnly"});
            object px = this.numberToString(price);
            if (isTrue(isMarket))
            {
                px = ((bool) isTrue((isBuy))) ? Precise.stringMul(px, Precise.stringAdd("1", slippage)) : Precise.stringMul(px, Precise.stringSub("1", slippage));
                px = this.priceToPrecision(symbol, px);
            } else
            {
                px = this.priceToPrecision(symbol, px);
            }
            object sz = this.amountToPrecision(symbol, amount);
            object orderType = new Dictionary<string, object>() {};
            if (isTrue(isTrigger))
            {
                object isTp = false;
                if (isTrue(!isEqual(takeProfitPrice, null)))
                {
                    triggerPrice = this.priceToPrecision(symbol, takeProfitPrice);
                    isTp = true;
                } else
                {
                    triggerPrice = this.priceToPrecision(symbol, stopLossPrice);
                }
                ((IDictionary<string,object>)orderType)["trigger"] = new Dictionary<string, object>() {
                    { "isMarket", isMarket },
                    { "triggerPx", triggerPrice },
                    { "tpsl", ((bool) isTrue((isTp))) ? "tp" : "sl" },
                };
            } else
            {
                ((IDictionary<string,object>)orderType)["limit"] = new Dictionary<string, object>() {
                    { "tif", timeInForce },
                };
            }
            if (isTrue(isEqual(triggerPrice, null)))
            {
                triggerPrice = "0";
            }
            object orderReq = new Dictionary<string, object>() {
                { "a", this.parseToInt(getValue(market, "baseId")) },
                { "b", isBuy },
                { "p", px },
                { "s", sz },
                { "r", reduceOnly },
                { "t", orderType },
            };
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)orderReq)["c"] = clientOrderId;
            }
            object modifyReq = new Dictionary<string, object>() {
                { "oid", this.parseToInt(id) },
                { "order", orderReq },
            };
            ((IList<object>)modifies).Add(modifyReq);
        }
        object nonce = this.milliseconds();
        object modifyAction = new Dictionary<string, object>() {
            { "type", "batchModify" },
            { "modifies", modifies },
        };
        object vaultAddress = null;
        var vaultAddressparametersVariable = this.handleOptionAndParams(parameters, "editOrder", "vaultAddress");
        vaultAddress = ((IList<object>)vaultAddressparametersVariable)[0];
        parameters = ((IList<object>)vaultAddressparametersVariable)[1];
        vaultAddress = this.formatVaultAddress(vaultAddress);
        object signature = this.signL1Action(modifyAction, nonce, vaultAddress);
        object request = new Dictionary<string, object>() {
            { "action", modifyAction },
            { "nonce", nonce },
            { "signature", signature },
        };
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            ((IDictionary<string,object>)request)["vaultAddress"] = vaultAddress;
        }
        return request;
    }

    /**
     * @method
     * @name hyperliquid#editOrder
     * @description edit a trade order
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#modify-multiple-orders
     * @param {string} id cancel order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.timeInForce] 'Gtc', 'Ioc', 'Alo'
     * @param {bool} [params.postOnly] true or false whether the order is post-only
     * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only
     * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
     * @param {string} [params.clientOrderId] client order id, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
     * @param {string} [params.vaultAddress] the vault address for order
     * @param {string} [params.subAccountAddress] sub account user address
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(id, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " editOrder() requires an id argument")) ;
        }
        var orderglobalParamsVariable = this.parseCreateEditOrderArgs(id, symbol, type, side, amount, price, parameters);
        var order = ((IList<object>) orderglobalParamsVariable)[0];
        var globalParams = ((IList<object>) orderglobalParamsVariable)[1];
        object orders = await this.editOrders(new List<object>() {((object)order)}, globalParams);
        return getValue(orders, 0);
    }

    /**
     * @method
     * @name hyperliquid#editOrders
     * @description edit a list of trade orders
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#modify-multiple-orders
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> editOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.initializeClient();
        object request = this.editOrdersRequest(orders, parameters);
        object response = await this.privatePostExchange(request);
        //
        //     {
        //         "status": "ok",
        //         "response": {
        //             "type": "order",
        //             "data": {
        //                 "statuses": [
        //                     {
        //                         "resting": {
        //                             "oid": 5063830287
        //                         }
        //                     }
        //                 ]
        //             }
        //         }
        //     }
        // when the order is filled immediately
        //     {
        //         "status":"ok",
        //         "response":{
        //            "type":"order",
        //            "data":{
        //               "statuses":[
        //                  {
        //                     "filled":{
        //                        "totalSz":"0.1",
        //                        "avgPx":"100.84",
        //                        "oid":6195281425
        //                     }
        //                  }
        //               ]
        //            }
        //         }
        //     }
        //
        object responseObject = this.safeDict(response, "response", new Dictionary<string, object>() {});
        object dataObject = this.safeDict(responseObject, "data", new Dictionary<string, object>() {});
        object statuses = this.safeList(dataObject, "statuses", new List<object>() {});
        return this.parseOrders(statuses);
    }

    /**
     * @method
     * @name hyperliquid#createVault
     * @description creates a value
     * @param {string} name The name of the vault
     * @param {string} description The description of the vault
     * @param {number} initialUsd The initialUsd of the vault
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} the api result
     */
    public async virtual Task<object> createVault(object name, object description, object initialUsd, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        await this.loadMarkets();
        object nonce = this.milliseconds();
        object request = new Dictionary<string, object>() {
            { "nonce", nonce },
        };
        object usd = this.parseToInt(Precise.stringMul(this.numberToString(initialUsd), "1000000"));
        object action = new Dictionary<string, object>() {
            { "type", "createVault" },
            { "name", name },
            { "description", description },
            { "initialUsd", usd },
            { "nonce", nonce },
        };
        object signature = this.signL1Action(action, nonce);
        ((IDictionary<string,object>)request)["action"] = action;
        ((IDictionary<string,object>)request)["signature"] = signature;
        object response = await this.privatePostExchange(this.extend(request, parameters));
        //
        // {
        //     "status": "ok",
        //     "response": {
        //         "type": "createVault",
        //         "data": "0x04fddcbc9ce80219301bd16f18491bedf2a8c2b8"
        //     }
        // }
        //
        return response;
    }

    /**
     * @method
     * @name hyperliquid#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-historical-funding-rates
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure} to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest funding rate
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "type", "fundingHistory" },
            { "coin", getValue(market, "baseName") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        } else
        {
            object maxLimit = ((bool) isTrue((isEqual(limit, null)))) ? 500 : limit;
            ((IDictionary<string,object>)request)["startTime"] = subtract(this.milliseconds(), multiply(multiply(multiply(maxLimit, 60), 60), 1000));
        }
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "coin": "ETH",
        //             "fundingRate": "0.0000125",
        //             "premium": "0.00057962",
        //             "time": 1704290400031
        //         }
        //     ]
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object timestamp = this.safeInteger(entry, "time");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", this.safeSymbol(null, market) },
                { "fundingRate", this.safeNumber(entry, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(result, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public virtual object getDexFromHip3Symbol(object market)
    {
        object baseName = this.safeString(market, "baseName", "");
        object part = ((string)baseName).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
        object partsLength = getArrayLength(part);
        if (isTrue(isGreaterThan(partsLength, 1)))
        {
            return this.safeString(part, 0);
        }
        return null;
    }

    /**
     * @method
     * @name hyperliquid#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-open-orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @param {string} [params.method] 'openOrders' or 'frontendOpenOrders' default is 'frontendOpenOrders'
     * @param {string} [params.subAccountAddress] sub account user address
     * @param {string} [params.dex] perp dex name. default is null
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchOpenOrders", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object method = null;
        var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrders", "method", "frontendOpenOrders");
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "type", method },
            { "user", userAddress },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            // check if is hip3 symbol
            object dexName = this.getDexFromHip3Symbol(market);
            if (isTrue(!isEqual(dexName, null)))
            {
                ((IDictionary<string,object>)request)["dex"] = dexName;
            }
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "coin": "ETH",
        //             "limitPx": "2000.0",
        //             "oid": 3991946565,
        //             "origSz": "0.1",
        //             "side": "B",
        //             "sz": "0.1",
        //             "timestamp": 1704346468838
        //         }
        //     ]
        //
        object orderWithStatus = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object order = getValue(response, i);
            object extendOrder = new Dictionary<string, object>() {};
            if (isTrue(isEqual(this.safeString(order, "status"), null)))
            {
                ((IDictionary<string,object>)extendOrder)["ccxtStatus"] = "open";
            }
            ((IList<object>)orderWithStatus).Add(this.extend(order, extendOrder));
        }
        return this.parseOrders(orderWithStatus, market, since, limit);
    }

    /**
     * @method
     * @name hyperliquid#fetchClosedOrders
     * @description fetch all unfilled currently closed orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orders = await this.fetchOrders(symbol, null, null, parameters); // don't filter here because we don't want to catch open orders
        object closedOrders = this.filterByArray(orders, "status", new List<object>() {"closed"}, false);
        return this.filterBySymbolSinceLimit(closedOrders, symbol, since, limit);
    }

    /**
     * @method
     * @name hyperliquid#fetchCanceledOrders
     * @description fetch all canceled orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orders = await this.fetchOrders(symbol, null, null, parameters); // don't filter here because we don't want to catch open orders
        object closedOrders = this.filterByArray(orders, "status", new List<object>() {"canceled"}, false);
        return this.filterBySymbolSinceLimit(closedOrders, symbol, since, limit);
    }

    /**
     * @method
     * @name hyperliquid#fetchCanceledAndClosedOrders
     * @description fetch all closed and canceled orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchCanceledAndClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orders = await this.fetchOrders(symbol, null, null, parameters); // don't filter here because we don't want to catch open orders
        object closedOrders = this.filterByArray(orders, "status", new List<object>() {"canceled", "closed", "rejected"}, false);
        return this.filterBySymbolSinceLimit(closedOrders, symbol, since, limit);
    }

    /**
     * @method
     * @name hyperliquid#fetchOrders
     * @description fetch all orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @param {string} [params.subAccountAddress] sub account user address
     * @param {string} [params.dex] perp dex name. default is null
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchOrders", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {
            { "type", "historicalOrders" },
            { "user", userAddress },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            // check if is hip3 symbol
            object dexName = this.getDexFromHip3Symbol(market);
            if (isTrue(!isEqual(dexName, null)))
            {
                ((IDictionary<string,object>)request)["dex"] = dexName;
            }
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "coin": "ETH",
        //             "limitPx": "2000.0",
        //             "oid": 3991946565,
        //             "origSz": "0.1",
        //             "side": "B",
        //             "sz": "0.1",
        //             "timestamp": 1704346468838
        //         }
        //     ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    /**
     * @method
     * @name hyperliquid#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#query-order-status-by-oid-or-cloid
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] client order id, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @param {string} [params.subAccountAddress] sub account user address
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchOrder", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        object request = new Dictionary<string, object>() {
            { "type", "orderStatus" },
            { "user", userAddress },
        };
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            parameters = this.omit(parameters, "clientOrderId");
            ((IDictionary<string,object>)request)["oid"] = clientOrderId;
        } else
        {
            object isClientOrderId = isGreaterThanOrEqual(((string)id).Length, 34);
            ((IDictionary<string,object>)request)["oid"] = ((bool) isTrue(isClientOrderId)) ? id : this.parseToNumeric(id);
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     {
        //         "order": {
        //             "order": {
        //                 "children": [],
        //                 "cloid": null,
        //                 "coin": "ETH",
        //                 "isPositionTpsl": false,
        //                 "isTrigger": false,
        //                 "limitPx": "2000.0",
        //                 "oid": "3991946565",
        //                 "orderType": "Limit",
        //                 "origSz": "0.1",
        //                 "reduceOnly": false,
        //                 "side": "B",
        //                 "sz": "0.1",
        //                 "tif": "Gtc",
        //                 "timestamp": "1704346468838",
        //                 "triggerCondition": "N/A",
        //                 "triggerPx": "0.0"
        //             },
        //             "status": "open",
        //             "statusTimestamp": "1704346468838"
        //         },
        //         "status": "order"
        //     }
        //
        object data = this.safeDict(response, "order");
        return this.parseOrder(data, market);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrdersWs error
        //
        //  {error: 'Insufficient margin to place order. asset=159'}
        //
        //  fetchOpenOrders
        //
        //     {
        //         "coin": "ETH",
        //         "limitPx": "2000.0",
        //         "oid": 3991946565,
        //         "origSz": "0.1",
        //         "side": "B",
        //         "sz": "0.1",
        //         "timestamp": 1704346468838
        //     }
        // fetchClosedorders
        //    {
        //        "cloid": null,
        //        "closedPnl": "0.0",
        //        "coin": "SOL",
        //        "crossed": true,
        //        "dir": "Open Long",
        //        "fee": "0.003879",
        //        "hash": "0x4a2647998682b7f07bc5040ab531e1011400f9a51bfa0346a0b41ebe510e8875",
        //        "liquidationMarkPx": null,
        //        "oid": "6463280784",
        //        "px": "110.83",
        //        "side": "B",
        //        "startPosition": "1.64",
        //        "sz": "0.1",
        //        "tid": "232174667018988",
        //        "time": "1709142268394"
        //    }
        //
        //  fetchOrder
        //
        //     {
        //         "order": {
        //             "children": [],
        //             "cloid": null,
        //             "coin": "ETH",
        //             "isPositionTpsl": false,
        //             "isTrigger": false,
        //             "limitPx": "2000.0",
        //             "oid": "3991946565",
        //             "orderType": "Limit",
        //             "origSz": "0.1",
        //             "reduceOnly": false,
        //             "side": "B",
        //             "sz": "0.1",
        //             "tif": "Gtc",
        //             "timestamp": "1704346468838",
        //             "triggerCondition": "N/A",
        //             "triggerPx": "0.0"
        //         },
        //         "status": "open",
        //         "statusTimestamp": "1704346468838"
        //     }
        //
        // createOrder
        //
        //     {
        //         "resting": {
        //             "oid": 5063830287
        //         }
        //     }
        //
        //     {
        //        "filled":{
        //           "totalSz":"0.1",
        //           "avgPx":"100.84",
        //           "oid":6195281425
        //        }
        //     }
        // frontendOrder
        // {
        //     "children": [],
        //     "cloid": null,
        //     "coin": "BLUR",
        //     "isPositionTpsl": false,
        //     "isTrigger": true,
        //     "limitPx": "0.5",
        //     "oid": 8670487141,
        //     "orderType": "Stop Limit",
        //     "origSz": "20.0",
        //     "reduceOnly": false,
        //     "side": "B",
        //     "sz": "20.0",
        //     "tif": null,
        //     "timestamp": 1715523663687,
        //     "triggerCondition": "Price above 0.6",
        //     "triggerPx": "0.6"
        // }
        //
        object error = this.safeString(order, "error");
        if (isTrue(!isEqual(error, null)))
        {
            return this.safeOrder(new Dictionary<string, object>() {
                { "info", order },
                { "status", "rejected" },
            });
        }
        object entry = this.safeDictN(order, new List<object>() {"order", "resting", "filled"});
        if (isTrue(isEqual(entry, null)))
        {
            entry = order;
        }
        object filled = this.safeDict(order, "filled", new Dictionary<string, object>() {});
        object coin = this.safeString(entry, "coin");
        object marketId = null;
        if (isTrue(!isEqual(coin, null)))
        {
            marketId = this.coinToMarketId(coin);
        }
        if (isTrue(isEqual(this.safeString(entry, "id"), null)))
        {
            market = this.safeMarket(marketId, null);
        } else
        {
            market = this.safeMarket(marketId, market);
        }
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger(entry, "timestamp");
        object status = this.safeString2(order, "status", "ccxtStatus");
        order = this.omit(order, new List<object>() {"ccxtStatus"});
        object side = this.safeString(entry, "side");
        if (isTrue(!isEqual(side, null)))
        {
            side = ((bool) isTrue((isEqual(side, "A")))) ? "sell" : "buy";
        }
        object totalAmount = this.safeString2(entry, "origSz", "totalSz");
        object remaining = this.safeString(entry, "sz");
        object tif = this.safeStringUpper(entry, "tif");
        object postOnly = null;
        if (isTrue(!isEqual(tif, null)))
        {
            postOnly = (isEqual(tif, "ALO"));
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString(entry, "oid") },
            { "clientOrderId", this.safeString(entry, "cloid") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", this.safeInteger(order, "statusTimestamp") },
            { "symbol", symbol },
            { "type", this.parseOrderType(this.safeStringLower(entry, "orderType")) },
            { "timeInForce", tif },
            { "postOnly", postOnly },
            { "reduceOnly", this.safeBool(entry, "reduceOnly") },
            { "side", side },
            { "price", this.safeString(entry, "limitPx") },
            { "triggerPrice", ((bool) isTrue(this.safeBool(entry, "isTrigger"))) ? this.safeNumber(entry, "triggerPx") : null },
            { "amount", totalAmount },
            { "cost", null },
            { "average", this.safeString(entry, "avgPx") },
            { "filled", this.safeString(filled, "totalSz", Precise.stringSub(totalAmount, remaining)) },
            { "remaining", remaining },
            { "status", this.parseOrderStatus(status) },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        if (isTrue(isEqual(status, null)))
        {
            return null;
        }
        object statuses = new Dictionary<string, object>() {
            { "triggered", "open" },
            { "filled", "closed" },
            { "open", "open" },
            { "canceled", "canceled" },
            { "rejected", "rejected" },
            { "marginCanceled", "canceled" },
        };
        if (isTrue(((string)status).EndsWith(((string)"Rejected"))))
        {
            return "rejected";
        }
        if (isTrue(((string)status).EndsWith(((string)"Canceled"))))
        {
            return "canceled";
        }
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderType(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "stop limit", "limit" },
            { "stop market", "market" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name hyperliquid#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills-by-time
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest trade
     * @param {string} [params.subAccountAddress] sub account user address
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchMyTrades", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "user", userAddress },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["type"] = "userFillsByTime";
            ((IDictionary<string,object>)request)["startTime"] = since;
        } else
        {
            ((IDictionary<string,object>)request)["type"] = "userFills";
        }
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "closedPnl": "0.19343",
        //             "coin": "ETH",
        //             "crossed": true,
        //             "dir": "Close Long",
        //             "fee": "0.050062",
        //             "feeToken": "USDC",
        //             "hash": "0x09d77c96791e98b5775a04092584ab010d009445119c71e4005c0d634ea322bc",
        //             "liquidationMarkPx": null,
        //             "oid": 3929354691,
        //             "px": "2381.1",
        //             "side": "A",
        //             "startPosition": "0.0841",
        //             "sz": "0.0841",
        //             "tid": 128423918764978,
        //             "time": 1704262888911
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        //     {
        //         "closedPnl": "0.19343",
        //         "coin": "ETH",
        //         "crossed": true,
        //         "dir": "Close Long",
        //         "fee": "0.050062",
        //         "hash": "0x09d77c96791e98b5775a04092584ab010d009445119c71e4005c0d634ea322bc",
        //         "liquidationMarkPx": null,
        //         "oid": 3929354691,
        //         "px": "2381.1",
        //         "side": "A",
        //         "startPosition": "0.0841",
        //         "sz": "0.0841",
        //         "tid": 128423918764978,
        //         "time": 1704262888911
        //     }
        //
        object timestamp = this.safeInteger(trade, "time");
        object price = this.safeString(trade, "px");
        object amount = this.safeString(trade, "sz");
        object coin = this.safeString(trade, "coin");
        object marketId = this.coinToMarketId(coin);
        market = this.safeMarket(marketId, null);
        object symbol = getValue(market, "symbol");
        object id = this.safeString(trade, "tid");
        object side = this.safeString(trade, "side");
        if (isTrue(!isEqual(side, null)))
        {
            side = ((bool) isTrue((isEqual(side, "A")))) ? "sell" : "buy";
        }
        object fee = this.safeString(trade, "fee");
        object takerOrMaker = null;
        object crossed = this.safeBool(trade, "crossed");
        if (isTrue(!isEqual(crossed, null)))
        {
            takerOrMaker = ((bool) isTrue(crossed)) ? "taker" : "maker";
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", id },
            { "order", this.safeString(trade, "oid") },
            { "type", null },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", new Dictionary<string, object>() {
                { "cost", fee },
                { "currency", this.safeString(trade, "feeToken") },
                { "rate", null },
            } },
        }, market);
    }

    /**
     * @method
     * @name hyperliquid#fetchPosition
     * @description fetch data on an open position
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-users-perpetuals-account-summary
     * @param {string} symbol unified market symbol of the market the position is held in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @returns {object} a [position structure]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object positions = await this.fetchPositions(new List<object>() {symbol}, parameters);
        return this.safeDict(positions, 0, new Dictionary<string, object>() {});
    }

    public virtual object getDexFromSymbols(object methodName, object symbols = null)
    {
        if (isTrue(isEqual(symbols, null)))
        {
            return null;
        }
        object symbolsLength = getArrayLength(symbols);
        if (isTrue(isEqual(symbolsLength, 0)))
        {
            return null;
        }
        object dexName = null;
        for (object i = 0; isLessThan(i, symbolsLength); postFixIncrement(ref i))
        {
            if (isTrue(isEqual(dexName, null)))
            {
                object market = this.market(getValue(symbols, i));
                dexName = this.getDexFromHip3Symbol(market);
            } else
            {
                object market = this.market(getValue(symbols, i));
                object currentDexName = this.getDexFromHip3Symbol(market);
                if (isTrue(!isEqual(currentDexName, dexName)))
                {
                    throw new NotSupported ((string)add(add(add(this.id, " "), methodName), " only supports fetching positions for one DEX at a time for HIP3 markets")) ;
                }
            }
        }
        return dexName;
    }

    /**
     * @method
     * @name hyperliquid#fetchPositions
     * @description fetch all open positions
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-users-perpetuals-account-summary
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @param {string} [params.subAccountAddress] sub account user address
     * @param {string} [params.dex] perp dex name, eg: XYZ
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchPositions", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {
            { "type", "clearinghouseState" },
            { "user", userAddress },
        };
        object dexName = this.getDexFromSymbols("fetchPositions", symbols);
        if (isTrue(!isEqual(dexName, null)))
        {
            ((IDictionary<string,object>)request)["dex"] = dexName;
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     {
        //         "assetPositions": [
        //             {
        //                 "position": {
        //                     "coin": "ETH",
        //                     "cumFunding": {
        //                         "allTime": "0.0",
        //                         "sinceChange": "0.0",
        //                         "sinceOpen": "0.0"
        //                     },
        //                     "entryPx": "2213.9",
        //                     "leverage": {
        //                         "rawUsd": "-475.23904",
        //                         "type": "isolated",
        //                         "value": "20"
        //                     },
        //                     "liquidationPx": "2125.00856238",
        //                     "marginUsed": "24.88097",
        //                     "maxLeverage": "50",
        //                     "positionValue": "500.12001",
        //                     "returnOnEquity": "0.0",
        //                     "szi": "0.2259",
        //                     "unrealizedPnl": "0.0"
        //                 },
        //                 "type": "oneWay"
        //             }
        //         ],
        //         "crossMaintenanceMarginUsed": "0.0",
        //         "crossMarginSummary": {
        //             "accountValue": "100.0",
        //             "totalMarginUsed": "0.0",
        //             "totalNtlPos": "0.0",
        //             "totalRawUsd": "100.0"
        //         },
        //         "marginSummary": {
        //             "accountValue": "100.0",
        //             "totalMarginUsed": "0.0",
        //             "totalNtlPos": "0.0",
        //             "totalRawUsd": "100.0"
        //         },
        //         "time": "1704261007014",
        //         "withdrawable": "100.0"
        //     }
        //
        object data = this.safeList(response, "assetPositions", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parsePosition(getValue(data, i), null));
        }
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         "position": {
        //             "coin": "ETH",
        //             "cumFunding": {
        //                 "allTime": "0.0",
        //                 "sinceChange": "0.0",
        //                 "sinceOpen": "0.0"
        //             },
        //             "entryPx": "2213.9",
        //             "leverage": {
        //                 "rawUsd": "-475.23904",
        //                 "type": "isolated",
        //                 "value": "20"
        //             },
        //             "liquidationPx": "2125.00856238",
        //             "marginUsed": "24.88097",
        //             "maxLeverage": "50",
        //             "positionValue": "500.12001",
        //             "returnOnEquity": "0.0",
        //             "szi": "0.2259",
        //             "unrealizedPnl": "0.0"
        //         },
        //         "type": "oneWay"
        //     }
        //
        object entry = this.safeDict(position, "position", new Dictionary<string, object>() {});
        object coin = this.safeString(entry, "coin");
        object marketId = this.coinToMarketId(coin);
        market = this.safeMarket(marketId, null);
        object symbol = getValue(market, "symbol");
        object leverage = this.safeDict(entry, "leverage", new Dictionary<string, object>() {});
        object marginMode = this.safeString(leverage, "type");
        object isIsolated = (isEqual(marginMode, "isolated"));
        object rawSize = this.safeString(entry, "szi");
        object size = rawSize;
        object side = null;
        if (isTrue(!isEqual(size, null)))
        {
            side = ((bool) isTrue(Precise.stringGt(rawSize, "0"))) ? "long" : "short";
            size = Precise.stringAbs(size);
        }
        object rawUnrealizedPnl = this.safeString(entry, "unrealizedPnl");
        object absRawUnrealizedPnl = Precise.stringAbs(rawUnrealizedPnl);
        object marginUsed = this.safeString(entry, "marginUsed");
        object initialMargin = null;
        if (isTrue(isIsolated))
        {
            initialMargin = Precise.stringSub(marginUsed, rawUnrealizedPnl);
        } else
        {
            initialMargin = marginUsed;
        }
        object percentage = Precise.stringMul(Precise.stringDiv(absRawUnrealizedPnl, marginUsed), "100");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "isolated", isIsolated },
            { "hedged", null },
            { "side", side },
            { "contracts", this.parseNumber(size) },
            { "contractSize", null },
            { "entryPrice", this.safeNumber(entry, "entryPx") },
            { "markPrice", null },
            { "notional", this.safeNumber(entry, "positionValue") },
            { "leverage", this.safeNumber(leverage, "value") },
            { "collateral", this.parseNumber(marginUsed) },
            { "initialMargin", this.parseNumber(initialMargin) },
            { "maintenanceMargin", null },
            { "initialMarginPercentage", null },
            { "maintenanceMarginPercentage", null },
            { "unrealizedPnl", this.parseNumber(rawUnrealizedPnl) },
            { "liquidationPrice", this.safeNumber(entry, "liquidationPx") },
            { "marginMode", marginMode },
            { "percentage", this.parseNumber(percentage) },
        });
    }

    /**
     * @method
     * @name hyperliquid#setMarginMode
     * @description set margin mode (symbol)
     * @param {string} marginMode margin mode must be either [isolated, cross]
     * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.leverage] the rate of leverage, is required if setting trade mode (symbol)
     * @param {string} [params.vaultAddress] the vault address
     * @param {string} [params.subAccountAddress] sub account user address
     * @returns {object} response from the exchange
     */
    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object leverage = this.safeInteger(parameters, "leverage");
        if (isTrue(isEqual(leverage, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a leverage parameter")) ;
        }
        object asset = this.parseToInt(getValue(market, "baseId"));
        object isCross = (isEqual(marginMode, "cross"));
        object nonce = this.milliseconds();
        parameters = this.omit(parameters, new List<object>() {"leverage"});
        object updateAction = new Dictionary<string, object>() {
            { "type", "updateLeverage" },
            { "asset", asset },
            { "isCross", isCross },
            { "leverage", leverage },
        };
        object vaultAddress = null;
        var vaultAddressparametersVariable = this.handleOptionAndParams2(parameters, "setMarginMode", "vaultAddress", "subAccountAddress");
        vaultAddress = ((IList<object>)vaultAddressparametersVariable)[0];
        parameters = ((IList<object>)vaultAddressparametersVariable)[1];
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            if (isTrue(((string)vaultAddress).StartsWith(((string)"0x"))))
            {
                vaultAddress = ((string)vaultAddress).Replace((string)"0x", (string)"");
            }
        }
        object signature = this.signL1Action(updateAction, nonce, vaultAddress);
        object request = new Dictionary<string, object>() {
            { "action", updateAction },
            { "nonce", nonce },
            { "signature", signature },
        };
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            ((IDictionary<string,object>)request)["vaultAddress"] = vaultAddress;
        }
        object response = await this.privatePostExchange(request);
        //
        //     {
        //         'response': {
        //             'type': 'default'
        //         },
        //         'status': 'ok'
        //     }
        //
        return response;
    }

    /**
     * @method
     * @name hyperliquid#setLeverage
     * @description set the level of leverage for a market
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] margin mode must be either [isolated, cross], default is cross
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object marginMode = this.safeString(parameters, "marginMode", "cross");
        object isCross = (isEqual(marginMode, "cross"));
        object asset = this.parseToInt(getValue(market, "baseId"));
        object nonce = this.milliseconds();
        parameters = this.omit(parameters, "marginMode");
        object updateAction = new Dictionary<string, object>() {
            { "type", "updateLeverage" },
            { "asset", asset },
            { "isCross", isCross },
            { "leverage", leverage },
        };
        object vaultAddress = null;
        var vaultAddressparametersVariable = this.handleOptionAndParams2(parameters, "setLeverage", "vaultAddress", "subAccountAddress");
        vaultAddress = ((IList<object>)vaultAddressparametersVariable)[0];
        parameters = ((IList<object>)vaultAddressparametersVariable)[1];
        vaultAddress = this.formatVaultAddress(vaultAddress);
        object signature = this.signL1Action(updateAction, nonce, vaultAddress);
        object request = new Dictionary<string, object>() {
            { "action", updateAction },
            { "nonce", nonce },
            { "signature", signature },
        };
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            parameters = this.omit(parameters, "vaultAddress");
            ((IDictionary<string,object>)request)["vaultAddress"] = vaultAddress;
        }
        object response = await this.privatePostExchange(request);
        //
        //     {
        //         'response': {
        //             'type': 'default'
        //         },
        //         'status': 'ok'
        //     }
        //
        return response;
    }

    /**
     * @method
     * @name hyperliquid#addMargin
     * @description add margin
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#update-isolated-margin
     * @param {string} symbol unified market symbol
     * @param {float} amount amount of margin to add
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.vaultAddress] the vault address
     * @param {string} [params.subAccountAddress] sub account user address
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/?id=margin-structure}
     */
    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "add", parameters);
    }

    /**
     * @method
     * @name hyperliquid#reduceMargin
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#update-isolated-margin
     * @description remove margin from a position
     * @param {string} symbol unified market symbol
     * @param {float} amount the amount of margin to remove
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.vaultAddress] the vault address
     * @param {string} [params.subAccountAddress] sub account user address
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/?id=margin-structure}
     */
    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "reduce", parameters);
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object asset = this.parseToInt(getValue(market, "baseId"));
        object sz = this.parseToInt(Precise.stringMul(this.amountToPrecision(symbol, amount), "1000000"));
        if (isTrue(isEqual(type, "reduce")))
        {
            sz = prefixUnaryNeg(ref sz);
        }
        object nonce = this.milliseconds();
        object updateAction = new Dictionary<string, object>() {
            { "type", "updateIsolatedMargin" },
            { "asset", asset },
            { "isBuy", true },
            { "ntli", sz },
        };
        object vaultAddress = null;
        var vaultAddressparametersVariable = this.handleOptionAndParams2(parameters, "modifyMargin", "vaultAddress", "subAccountAddress");
        vaultAddress = ((IList<object>)vaultAddressparametersVariable)[0];
        parameters = ((IList<object>)vaultAddressparametersVariable)[1];
        vaultAddress = this.formatVaultAddress(vaultAddress);
        object signature = this.signL1Action(updateAction, nonce, vaultAddress);
        object request = new Dictionary<string, object>() {
            { "action", updateAction },
            { "nonce", nonce },
            { "signature", signature },
        };
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            ((IDictionary<string,object>)request)["vaultAddress"] = vaultAddress;
        }
        object response = await this.privatePostExchange(request);
        //
        //     {
        //         'response': {
        //             'type': 'default'
        //         },
        //         'status': 'ok'
        //     }
        //
        return this.extend(this.parseMarginModification(response, market), new Dictionary<string, object>() {
            { "code", this.safeString(response, "status") },
        });
    }

    public override object parseMarginModification(object data, object market = null)
    {
        //
        //    {
        //        'type': 'default'
        //    }
        //
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", this.safeSymbol(null, market) },
            { "type", null },
            { "marginMode", "isolated" },
            { "amount", null },
            { "total", null },
            { "code", this.safeString(market, "settle") },
            { "status", null },
            { "timestamp", null },
            { "datetime", null },
        };
    }

    /**
     * @method
     * @name hyperliquid#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#l1-usdc-transfer
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account to transfer from *spot, swap*
     * @param {string} toAccount account to transfer to *swap, spot or address*
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.vaultAddress] the vault address for order
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        await this.loadMarkets();
        object isSandboxMode = this.safeBool(this.options, "sandboxMode");
        object nonce = this.milliseconds();
        if (isTrue(this.inArray(fromAccount, new List<object>() {"spot", "swap", "perp"})))
        {
            // handle swap <> spot account transfer
            if (!isTrue(this.inArray(toAccount, new List<object>() {"spot", "swap", "perp"})))
            {
                throw new NotSupported ((string)add(this.id, " transfer() only support spot <> swap transfer")) ;
            }
            object strAmount = this.numberToString(amount);
            object vaultAddress = this.safeString2(parameters, "vaultAddress", "subAccountAddress");
            if (isTrue(!isEqual(vaultAddress, null)))
            {
                vaultAddress = this.formatVaultAddress(vaultAddress);
                strAmount = add(add(strAmount, " subaccount:"), vaultAddress);
            }
            object toPerp = isTrue((isEqual(toAccount, "perp"))) || isTrue((isEqual(toAccount, "swap")));
            object transferPayload = new Dictionary<string, object>() {
                { "hyperliquidChain", ((bool) isTrue(isSandboxMode)) ? "Testnet" : "Mainnet" },
                { "amount", strAmount },
                { "toPerp", toPerp },
                { "nonce", nonce },
            };
            object transferSig = this.buildUsdClassSendSig(transferPayload);
            object transferRequest = new Dictionary<string, object>() {
                { "action", new Dictionary<string, object>() {
                    { "hyperliquidChain", getValue(transferPayload, "hyperliquidChain") },
                    { "signatureChainId", "0x66eee" },
                    { "type", "usdClassTransfer" },
                    { "amount", strAmount },
                    { "toPerp", toPerp },
                    { "nonce", nonce },
                } },
                { "nonce", nonce },
                { "signature", transferSig },
            };
            object transferResponse = await this.privatePostExchange(transferRequest);
            return transferResponse;
        }
        // transfer between main account and subaccount
        object isDeposit = false;
        object subAccountAddress = null;
        if (isTrue(isEqual(fromAccount, "main")))
        {
            subAccountAddress = toAccount;
            isDeposit = true;
        } else if (isTrue(isEqual(toAccount, "main")))
        {
            subAccountAddress = fromAccount;
        } else
        {
            throw new NotSupported ((string)add(this.id, " transfer() only support main <> subaccount transfer")) ;
        }
        this.checkAddress(subAccountAddress);
        if (isTrue(isTrue(isEqual(code, null)) || isTrue(isEqual(((string)code).ToUpper(), "USDC"))))
        {
            // Transfer USDC with subAccountTransfer
            object usd = this.parseToInt(Precise.stringMul(this.numberToString(amount), "1000000"));
            object action = new Dictionary<string, object>() {
                { "type", "subAccountTransfer" },
                { "subAccountUser", subAccountAddress },
                { "isDeposit", isDeposit },
                { "usd", usd },
            };
            object sig = this.signL1Action(action, nonce);
            object request = new Dictionary<string, object>() {
                { "action", action },
                { "nonce", nonce },
                { "signature", sig },
            };
            object response = await this.privatePostExchange(request);
            //
            // {'response': {'type': 'default'}, 'status': 'ok'}
            //
            return this.parseTransfer(response);
        } else
        {
            // Transfer non-USDC with subAccountSpotTransfer
            object symbol = this.symbol(code);
            object action = new Dictionary<string, object>() {
                { "type", "subAccountSpotTransfer" },
                { "subAccountUser", subAccountAddress },
                { "isDeposit", isDeposit },
                { "token", symbol },
                { "amount", this.numberToString(amount) },
            };
            object sig = this.signL1Action(action, nonce);
            object request = new Dictionary<string, object>() {
                { "action", action },
                { "nonce", nonce },
                { "signature", sig },
            };
            object response = await this.privatePostExchange(request);
            return this.parseTransfer(response);
        }
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // {'response': {'type': 'default'}, 'status': 'ok'}
        //
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", null },
            { "timestamp", null },
            { "datetime", null },
            { "currency", null },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", "ok" },
        };
    }

    /**
     * @method
     * @name hyperliquid#withdraw
     * @description make a withdrawal (only support USDC)
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#initiate-a-withdrawal-request
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#deposit-or-withdraw-from-a-vault
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.vaultAddress] vault address withdraw from
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        await this.loadMarkets();
        this.checkAddress(address);
        if (isTrue(!isEqual(code, null)))
        {
            code = ((string)code).ToUpper();
            if (isTrue(!isEqual(code, "USDC")))
            {
                throw new NotSupported ((string)add(this.id, " withdraw() only support USDC")) ;
            }
        }
        object vaultAddress = null;
        var vaultAddressparametersVariable = this.handleOptionAndParams(parameters, "withdraw", "vaultAddress");
        vaultAddress = ((IList<object>)vaultAddressparametersVariable)[0];
        parameters = ((IList<object>)vaultAddressparametersVariable)[1];
        vaultAddress = this.formatVaultAddress(vaultAddress);
        parameters = this.omit(parameters, "vaultAddress");
        object nonce = this.milliseconds();
        object action = new Dictionary<string, object>() {};
        object sig = null;
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            action = new Dictionary<string, object>() {
                { "type", "vaultTransfer" },
                { "vaultAddress", add("0x", vaultAddress) },
                { "isDeposit", false },
                { "usd", amount },
            };
            sig = this.signL1Action(action, nonce);
        } else
        {
            object isSandboxMode = this.safeBool(this.options, "sandboxMode", false);
            object payload = new Dictionary<string, object>() {
                { "hyperliquidChain", ((bool) isTrue(isSandboxMode)) ? "Testnet" : "Mainnet" },
                { "destination", address },
                { "amount", ((object)amount).ToString() },
                { "time", nonce },
            };
            sig = this.buildWithdrawSig(payload);
            action = new Dictionary<string, object>() {
                { "hyperliquidChain", getValue(payload, "hyperliquidChain") },
                { "signatureChainId", "0x66eee" },
                { "destination", address },
                { "amount", ((object)amount).ToString() },
                { "time", nonce },
                { "type", "withdraw3" },
            };
        }
        object request = new Dictionary<string, object>() {
            { "action", action },
            { "nonce", nonce },
            { "signature", sig },
        };
        object response = await this.privatePostExchange(request);
        return this.parseTransaction(response);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // { status: 'ok', response: { type: 'default' } }
        //
        // fetchDeposits / fetchWithdrawals
        // {
        //     "time":1724762307531,
        //     "hash":"0x620a234a7e0eb7930575040f59482a01050058b0802163b4767bfd9033e77781",
        //     "delta":{
        //         "type":"accountClassTransfer",
        //         "usdc":"50.0",
        //         "toPerp":false
        //     }
        // }
        //
        object timestamp = this.safeInteger(transaction, "time");
        object delta = this.safeDict(transaction, "delta", new Dictionary<string, object>() {});
        object fee = null;
        object feeCost = this.safeInteger(delta, "fee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "currency", "USDC" },
                { "cost", feeCost },
            };
        }
        object intern = null;
        object type = this.safeString(delta, "type");
        if (isTrue(!isEqual(type, null)))
        {
            intern = (isEqual(type, "internalTransfer"));
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", null },
            { "txid", this.safeString(transaction, "hash") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", null },
            { "address", null },
            { "addressTo", this.safeString(delta, "destination") },
            { "addressFrom", this.safeString(delta, "user") },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", null },
            { "amount", this.safeNumber(delta, "usdc") },
            { "currency", null },
            { "status", this.safeString(transaction, "status") },
            { "updated", null },
            { "comment", null },
            { "internal", intern },
            { "fee", fee },
        };
    }

    /**
     * @method
     * @name hyperliquid#fetchTradingFee
     * @description fetch the trading fees for a market
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.user] user address, will default to this.walletAddress if not provided
     * @param {string} [params.subAccountAddress] sub account user address
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/?id=fee-structure}
     */
    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchTradingFee", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "type", "userFees" },
            { "user", userAddress },
        };
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        //     {
        //         "dailyUserVlm": [
        //             {
        //                 "date": "2024-07-08",
        //                 "userCross": "0.0",
        //                 "userAdd": "0.0",
        //                 "exchange": "90597185.23639999"
        //             }
        //         ],
        //         "feeSchedule": {
        //             "cross": "0.00035",
        //             "add": "0.0001",
        //             "tiers": {
        //                 "vip": [
        //                     {
        //                         "ntlCutoff": "5000000.0",
        //                         "cross": "0.0003",
        //                         "add": "0.00005"
        //                     }
        //                 ],
        //                 "mm": [
        //                     {
        //                         "makerFractionCutoff": "0.005",
        //                         "add": "-0.00001"
        //                     }
        //                 ]
        //             },
        //             "referralDiscount": "0.04"
        //         },
        //         "userCrossRate": "0.00035",
        //         "userAddRate": "0.0001",
        //         "activeReferralDiscount": "0.0"
        //     }
        //
        object data = new Dictionary<string, object>() {
            { "userCrossRate", this.safeString(response, "userCrossRate") },
            { "userAddRate", this.safeString(response, "userAddRate") },
        };
        return this.parseTradingFee(data, market);
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        //
        //     {
        //         "dailyUserVlm": [
        //             {
        //                 "date": "2024-07-08",
        //                 "userCross": "0.0",
        //                 "userAdd": "0.0",
        //                 "exchange": "90597185.23639999"
        //             }
        //         ],
        //         "feeSchedule": {
        //             "cross": "0.00035",
        //             "add": "0.0001",
        //             "tiers": {
        //                 "vip": [
        //                     {
        //                         "ntlCutoff": "5000000.0",
        //                         "cross": "0.0003",
        //                         "add": "0.00005"
        //                     }
        //                 ],
        //                 "mm": [
        //                     {
        //                         "makerFractionCutoff": "0.005",
        //                         "add": "-0.00001"
        //                     }
        //                 ]
        //             },
        //             "referralDiscount": "0.04"
        //         },
        //         "userCrossRate": "0.00035",
        //         "userAddRate": "0.0001",
        //         "activeReferralDiscount": "0.0"
        //     }
        //
        object symbol = this.safeSymbol(null, market);
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", symbol },
            { "maker", this.safeNumber(fee, "userAddRate") },
            { "taker", this.safeNumber(fee, "userCrossRate") },
            { "percentage", null },
            { "tierBased", null },
        };
    }

    /**
     * @method
     * @name hyperliquid#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
     * @param {string} [code] unified currency code
     * @param {int} [since] timestamp in ms of the earliest ledger entry
     * @param {int} [limit] max number of ledger entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest ledger entry
     * @param {string} [params.subAccountAddress] sub account user address
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/?id=ledger-entry-structure}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchLedger", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "type", "userNonFundingLedgerUpdates" },
            { "user", userAddress },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
            parameters = this.omit(parameters, new List<object>() {"until"});
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        // [
        //     {
        //         "time":1724762307531,
        //         "hash":"0x620a234a7e0eb7930575040f59482a01050058b0802163b4767bfd9033e77781",
        //         "delta":{
        //             "type":"accountClassTransfer",
        //             "usdc":"50.0",
        //             "toPerp":false
        //         }
        //     }
        // ]
        //
        return this.parseLedger(response, null, since, limit);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        // {
        //     "time":1724762307531,
        //     "hash":"0x620a234a7e0eb7930575040f59482a01050058b0802163b4767bfd9033e77781",
        //     "delta":{
        //         "type":"accountClassTransfer",
        //         "usdc":"50.0",
        //         "toPerp":false
        //     }
        // }
        //
        object timestamp = this.safeInteger(item, "time");
        object delta = this.safeDict(item, "delta", new Dictionary<string, object>() {});
        object fee = null;
        object feeCost = this.safeInteger(delta, "fee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "currency", "USDC" },
                { "cost", feeCost },
            };
        }
        object type = this.safeString(delta, "type");
        object amount = this.safeString(delta, "usdc");
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", this.safeString(item, "hash") },
            { "direction", null },
            { "account", null },
            { "referenceAccount", this.safeString(delta, "user") },
            { "referenceId", this.safeString(item, "hash") },
            { "type", this.parseLedgerEntryType(type) },
            { "currency", null },
            { "amount", this.parseNumber(amount) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "before", null },
            { "after", null },
            { "status", null },
            { "fee", fee },
        }, currency);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object ledgerType = new Dictionary<string, object>() {
            { "internalTransfer", "transfer" },
            { "accountClassTransfer", "transfer" },
        };
        return this.safeString(ledgerType, type, type);
    }

    /**
     * @method
     * @name hyperliquid#fetchDeposits
     * @description fetch all deposits made to an account
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch withdrawals for
     * @param {string} [params.subAccountAddress] sub account user address
     * @param {string} [params.vaultAddress] vault address
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchDepositsWithdrawals", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "type", "userNonFundingLedgerUpdates" },
            { "user", userAddress },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            if (isTrue(isEqual(since, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchDeposits requires since while until is set")) ;
            }
            ((IDictionary<string,object>)request)["endTime"] = until;
            parameters = this.omit(parameters, new List<object>() {"until"});
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        // [
        //     {
        //         "time":1724762307531,
        //         "hash":"0x620a234a7e0eb7930575040f59482a01050058b0802163b4767bfd9033e77781",
        //         "delta":{
        //             "type":"accountClassTransfer",
        //             "usdc":"50.0",
        //             "toPerp":false
        //         }
        //     }
        // ]
        //
        object records = this.extractTypeFromDelta(response);
        object vaultAddress = null;
        var vaultAddressparametersVariable = this.handleOptionAndParams(parameters, "fetchDepositsWithdrawals", "vaultAddress");
        vaultAddress = ((IList<object>)vaultAddressparametersVariable)[0];
        parameters = ((IList<object>)vaultAddressparametersVariable)[1];
        vaultAddress = this.formatVaultAddress(vaultAddress);
        object deposits = new List<object>() {};
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            for (object i = 0; isLessThan(i, getArrayLength(records)); postFixIncrement(ref i))
            {
                object record = getValue(records, i);
                if (isTrue(isEqual(getValue(record, "type"), "vaultDeposit")))
                {
                    object delta = this.safeDict(record, "delta");
                    if (isTrue(isEqual(getValue(delta, "vault"), add("0x", vaultAddress))))
                    {
                        ((IList<object>)deposits).Add(record);
                    }
                }
            }
        } else
        {
            deposits = this.filterByArray(records, "type", new List<object>() {"deposit"}, false);
        }
        return this.parseTransactions(deposits, null, since, limit);
    }

    /**
     * @method
     * @name hyperliquid#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch withdrawals for
     * @param {string} [params.subAccountAddress] sub account user address
     * @param {string} [params.vaultAddress] vault address
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchDepositsWithdrawals", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "type", "userNonFundingLedgerUpdates" },
            { "user", userAddress },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
            parameters = this.omit(parameters, new List<object>() {"until"});
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        // [
        //     {
        //         "time":1724762307531,
        //         "hash":"0x620a234a7e0eb7930575040f59482a01050058b0802163b4767bfd9033e77781",
        //         "delta":{
        //             "type":"accountClassTransfer",
        //             "usdc":"50.0",
        //             "toPerp":false
        //         }
        //     }
        // ]
        //
        object records = this.extractTypeFromDelta(response);
        object vaultAddress = null;
        var vaultAddressparametersVariable = this.handleOptionAndParams(parameters, "fetchDepositsWithdrawals", "vaultAddress");
        vaultAddress = ((IList<object>)vaultAddressparametersVariable)[0];
        parameters = ((IList<object>)vaultAddressparametersVariable)[1];
        vaultAddress = this.formatVaultAddress(vaultAddress);
        object withdrawals = new List<object>() {};
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            for (object i = 0; isLessThan(i, getArrayLength(records)); postFixIncrement(ref i))
            {
                object record = getValue(records, i);
                if (isTrue(isEqual(getValue(record, "type"), "vaultWithdraw")))
                {
                    object delta = this.safeDict(record, "delta");
                    if (isTrue(isEqual(getValue(delta, "vault"), add("0x", vaultAddress))))
                    {
                        ((IList<object>)withdrawals).Add(record);
                    }
                }
            }
        } else
        {
            withdrawals = this.filterByArray(records, "type", new List<object>() {"withdraw"}, false);
        }
        return this.parseTransactions(withdrawals, null, since, limit);
    }

    /**
     * @method
     * @name hyperliquid#fetchOpenInterests
     * @description Retrieves the open interest for a list of symbols
     * @param {string[]} [symbols] Unified CCXT market symbol
     * @param {object} [params] exchange specific parameters
     * @returns {object} an open interest structure{@link https://docs.ccxt.com/?id=open-interest-structure}
     */
    public async override Task<object> fetchOpenInterests(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object swapMarkets = await this.fetchSwapMarkets();
        return this.parseOpenInterests(swapMarkets, symbols);
    }

    /**
     * @method
     * @name hyperliquid#fetchOpenInterest
     * @description retrieves the open interest of a contract trading pair
     * @param {string} symbol unified CCXT market symbol
     * @param {object} [params] exchange specific parameters
     * @returns {object} an [open interest structure]{@link https://docs.ccxt.com/?id=open-interest-structure}
     */
    public async override Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        symbol = this.symbol(symbol);
        await this.loadMarkets();
        object ois = await this.fetchOpenInterests(new List<object>() {symbol}, parameters);
        return getValue(ois, symbol);
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        //  {
        //      szDecimals: '2',
        //      name: 'HYPE',
        //      maxLeverage: '3',
        //      funding: '0.00014735',
        //      openInterest: '14677900.74',
        //      prevDayPx: '26.145',
        //      dayNtlVlm: '299643445.12560016',
        //      premium: '0.00081613',
        //      oraclePx: '27.569',
        //      markPx: '27.63',
        //      midPx: '27.599',
        //      impactPxs: [ '27.5915', '27.6319' ],
        //      dayBaseVlm: '10790652.83',
        //      baseId: 159
        //  }
        //
        interest = this.safeDict(interest, "info", new Dictionary<string, object>() {});
        object coin = this.safeString(interest, "name");
        object marketId = null;
        if (isTrue(!isEqual(coin, null)))
        {
            marketId = this.coinToMarketId(coin);
        }
        return this.safeOpenInterest(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(marketId) },
            { "openInterestAmount", this.safeNumber(interest, "openInterest") },
            { "openInterestValue", null },
            { "timestamp", null },
            { "datetime", null },
            { "info", interest },
        }, market);
    }

    /**
     * @method
     * @name hyperliquid#fetchFundingHistory
     * @description fetch the history of funding payments paid and received on this account
     * @param {string} [symbol] unified market symbol
     * @param {int} [since] the earliest time in ms to fetch funding history for
     * @param {int} [limit] the maximum number of funding history structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subAccountAddress] sub account user address
     * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/?id=funding-history-structure}
     */
    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchFundingHistory", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "user", userAddress },
            { "type", "userFunding" },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.publicPostInfo(this.extend(request, parameters));
        //
        // [
        //     {
        //         "time": 1734026400057,
        //         "hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
        //         "delta": {
        //             "type": "funding",
        //             "coin": "SOL",
        //             "usdc": "75.635093",
        //             "szi": "-7375.9",
        //             "fundingRate": "0.00004381",
        //             "nSamples": null
        //         }
        //     }
        // ]
        //
        return this.parseIncomes(response, market, since, limit);
    }

    public override object parseIncome(object income, object market = null)
    {
        //
        // {
        //     "time": 1734026400057,
        //     "hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
        //     "delta": {
        //         "type": "funding",
        //         "coin": "SOL",
        //         "usdc": "75.635093",
        //         "szi": "-7375.9",
        //         "fundingRate": "0.00004381",
        //         "nSamples": null
        //     }
        // }
        //
        object id = this.safeString(income, "hash");
        object timestamp = this.safeInteger(income, "time");
        object delta = this.safeDict(income, "delta");
        object baseId = this.safeString(delta, "coin");
        object marketSymbol = add(baseId, "/USDC:USDC");
        market = this.safeMarket(marketSymbol);
        object symbol = getValue(market, "symbol");
        object amount = this.safeString(delta, "usdc");
        object code = this.safeCurrencyCode("USDC");
        object rate = this.safeNumber(delta, "fundingRate");
        return new Dictionary<string, object>() {
            { "info", income },
            { "symbol", symbol },
            { "code", code },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", id },
            { "amount", this.parseNumber(amount) },
            { "rate", rate },
        };
    }

    /**
     * @method
     * @name hyperliquid#reserveRequestWeight
     * @description Instead of trading to increase the address based rate limits, this action allows reserving additional actions for 0.0005 USDC per request. The cost is paid from the Perps balance.
     * @param {number} weight the weight to reserve, 1 weight = 1 action, 0.0005 USDC per action
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a response object
     */
    public async virtual Task<object> reserveRequestWeight(object weight, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object nonce = this.milliseconds();
        object request = new Dictionary<string, object>() {
            { "nonce", nonce },
        };
        object action = new Dictionary<string, object>() {
            { "type", "reserveRequestWeight" },
            { "weight", weight },
        };
        object signature = this.signL1Action(action, nonce);
        ((IDictionary<string,object>)request)["action"] = action;
        ((IDictionary<string,object>)request)["signature"] = signature;
        object response = await this.privatePostExchange(this.extend(request, parameters));
        return response;
    }

    /**
     * @method
     * @name hyperliquid#createAccount
     * @description creates a sub-account under the main account
     * @param {string} name the name of the sub-account
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.expiresAfter] time in ms after which the sub-account will expire
     * @returns {object} a response object
     */
    public async override Task<object> createSubAccount(object name, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object nonce = this.milliseconds();
        object request = new Dictionary<string, object>() {
            { "nonce", nonce },
        };
        object action = new Dictionary<string, object>() {
            { "type", "createSubAccount" },
            { "name", name },
        };
        object expiresAfter = this.safeInteger(parameters, "expiresAfter");
        if (isTrue(!isEqual(expiresAfter, null)))
        {
            parameters = this.omit(parameters, "expiresAfter");
            ((IDictionary<string,object>)request)["expiresAfter"] = expiresAfter;
        }
        object signature = this.signL1Action(action, nonce, null, expiresAfter);
        ((IDictionary<string,object>)request)["action"] = action;
        ((IDictionary<string,object>)request)["signature"] = signature;
        object response = await this.privatePostExchange(this.extend(request, parameters));
        return response;
    }

    public virtual object extractTypeFromDelta(object data = null)
    {
        data ??= new List<object>();
        object records = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object record = getValue(data, i);
            ((IDictionary<string,object>)record)["type"] = getValue(getValue(record, "delta"), "type");
            ((IList<object>)records).Add(record);
        }
        return records;
    }

    public virtual object formatVaultAddress(object address = null)
    {
        if (isTrue(isEqual(address, null)))
        {
            return null;
        }
        if (isTrue(((string)address).StartsWith(((string)"0x"))))
        {
            return ((string)address).Replace((string)"0x", (string)"");
        }
        return address;
    }

    public virtual object handlePublicAddress(object methodName, object parameters)
    {
        object userAux = null;
        var userAuxparametersVariable = this.handleOptionAndParams2(parameters, methodName, "user", "subAccountAddress");
        userAux = ((IList<object>)userAuxparametersVariable)[0];
        parameters = ((IList<object>)userAuxparametersVariable)[1];
        object user = userAux;
        var userparametersVariable = this.handleOptionAndParams(parameters, methodName, "address", userAux);
        user = ((IList<object>)userparametersVariable)[0];
        parameters = ((IList<object>)userparametersVariable)[1];
        if (isTrue(isTrue((!isEqual(user, null))) && isTrue((!isEqual(user, "")))))
        {
            return new List<object>() {user, parameters};
        }
        if (isTrue(isTrue((!isEqual(this.walletAddress, null))) && isTrue((!isEqual(this.walletAddress, "")))))
        {
            return new List<object>() {this.walletAddress, parameters};
        }
        throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a user parameter inside 'params' or the wallet address set")) ;
    }

    public virtual object coinToMarketId(object coin)
    {
        // handle also hip3 tokens like flx:CRCL
        if (isTrue(isEqual(coin, null)))
        {
            return null;
        }
        object hi3TokensByname = this.safeDict(this.options, "hip3TokensByName", new Dictionary<string, object>() {});
        if (isTrue(this.safeDict(hi3TokensByname, coin)))
        {
            object hip3Dict = this.safeDict(hi3TokensByname, coin);
            object quote = this.safeString(hip3Dict, "quote", "USDC");
            object code = this.safeString(hip3Dict, "code", coin);
            return add(add(add(add(code, "/"), quote), ":"), quote);
        }
        if (isTrue(isTrue(isGreaterThan(getIndexOf(coin, "/"), -1)) || isTrue(isGreaterThan(getIndexOf(coin, "@"), -1))))
        {
            return coin;  // spot
        }
        if (isTrue(isGreaterThan(getIndexOf(coin, ":"), -1)))
        {
            coin = ((string)coin).Replace((string)":", (string)"-"); // hip3
        }
        return add(this.safeCurrencyCode(coin), "/USDC:USDC");
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        // {"status":"err","response":"User or API Wallet 0xb8a6f8b26223de27c31938d56e470a5b832703a5 does not exist."}
        //
        //     {
        //         status: 'ok',
        //         response: { type: 'order', data: { statuses: [ { error: 'Insufficient margin to place order. asset=4' } ] } }
        //     }
        // {"status":"ok","response":{"type":"order","data":{"statuses":[{"error":"Insufficient margin to place order. asset=84"}]}}}
        //
        // {"status":"unknownOid"}
        //
        object status = this.safeString(response, "status", "");
        object error = this.safeString(response, "error");
        object message = null;
        if (isTrue(isEqual(status, "err")))
        {
            message = this.safeString(response, "response");
        } else if (isTrue(isEqual(status, "unknownOid")))
        {
            throw new OrderNotFound ((string)add(add(this.id, " "), body)) ;
        } else if (isTrue(!isEqual(error, null)))
        {
            message = error;
        } else
        {
            object responsePayload = this.safeDict(response, "response", new Dictionary<string, object>() {});
            object data = this.safeDict(responsePayload, "data", new Dictionary<string, object>() {});
            object statuses = this.safeList(data, "statuses", new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(statuses)); postFixIncrement(ref i))
            {
                message = this.safeString(getValue(statuses, i), "error");
                if (isTrue(!isEqual(message, null)))
                {
                    break;
                }
            }
        }
        object feedback = add(add(this.id, " "), body);
        object nonEmptyMessage = (isTrue((!isEqual(message, null))) && isTrue((!isEqual(message, ""))));
        if (isTrue(nonEmptyMessage))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
        }
        if (isTrue(nonEmptyMessage))
        {
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(this.implodeHostname(getValue(getValue(this.urls, "api"), api)), "/"), path);
        if (isTrue(isEqual(method, "POST")))
        {
            headers = new Dictionary<string, object>() {
                { "Content-Type", "application/json" },
            };
            body = this.json(parameters);
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object calculateRateLimiterCost(object api, object method, object path, object parameters, object config = null)
    {
        config ??= new Dictionary<string, object>();
        if (isTrue(isTrue((inOp(config, "byType"))) && isTrue((inOp(parameters, "type")))))
        {
            object type = getValue(parameters, "type");
            object byType = getValue(config, "byType");
            if (isTrue(inOp(byType, type)))
            {
                return getValue(byType, type);
            }
        }
        return this.safeValue(config, "cost", 1);
    }

    public virtual object parseCreateEditOrderArgs(object id, object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object vaultAddress = null;
        var vaultAddressparametersVariable = this.handleOptionAndParams2(parameters, "createOrder", "vaultAddress", "subAccountAddress");
        vaultAddress = ((IList<object>)vaultAddressparametersVariable)[0];
        parameters = ((IList<object>)vaultAddressparametersVariable)[1];
        vaultAddress = this.formatVaultAddress(vaultAddress);
        symbol = getValue(market, "symbol");
        object order = new Dictionary<string, object>() {
            { "symbol", symbol },
            { "type", type },
            { "side", side },
            { "amount", amount },
            { "price", price },
            { "params", parameters },
        };
        object globalParams = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(vaultAddress, null)))
        {
            ((IDictionary<string,object>)globalParams)["vaultAddress"] = vaultAddress;
        }
        if (isTrue(!isEqual(id, null)))
        {
            ((IDictionary<string,object>)order)["id"] = id;
        }
        return new List<object>() {order, globalParams};
    }
}
