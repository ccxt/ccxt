namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class bydfi : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bydfi" },
            { "name", "BYDFi" },
            { "countries", new List<object>() {"SG"} },
            { "rateLimit", 50 },
            { "version", "v1" },
            { "certified", false },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", false },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "borrowCrossMargin", false },
                { "borrowIsolatedMargin", false },
                { "borrowMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", false },
                { "cancelOrders", false },
                { "cancelOrdersWithClientOrderId", false },
                { "cancelOrderWithClientOrderId", false },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createDepositAddress", false },
                { "createLimitBuyOrder", false },
                { "createLimitOrder", true },
                { "createLimitSellOrder", false },
                { "createMarketBuyOrder", false },
                { "createMarketBuyOrderWithCost", false },
                { "createMarketOrder", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrder", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", true },
                { "createOrderWithTakeProfitAndStopLoss", false },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", true },
                { "createStopLossOrder", true },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "createTakeProfitOrder", true },
                { "createTrailingAmountOrder", false },
                { "createTrailingPercentOrder", true },
                { "createTriggerOrder", false },
                { "deposit", false },
                { "editOrder", true },
                { "editOrders", true },
                { "editOrderWithClientOrderId", true },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchBidsAsks", false },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRate", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchBorrowRates", false },
                { "fetchBorrowRatesPerSymbol", false },
                { "fetchCanceledAndClosedOrders", true },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrder", false },
                { "fetchClosedOrders", false },
                { "fetchConvertCurrencies", false },
                { "fetchConvertQuote", false },
                { "fetchConvertTrade", false },
                { "fetchConvertTradeHistory", false },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", false },
                { "fetchDeposit", false },
                { "fetchDepositAddress", false },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", false },
                { "fetchDepositWithdrawFee", false },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", false },
                { "fetchFundingInterval", false },
                { "fetchFundingIntervals", false },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", false },
                { "fetchGreeks", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchIsolatedPositions", false },
                { "fetchL2OrderBook", true },
                { "fetchL3OrderBook", false },
                { "fetchLastPrices", false },
                { "fetchLedger", false },
                { "fetchLedgerEntry", false },
                { "fetchLeverage", true },
                { "fetchLeverages", false },
                { "fetchLeverageTiers", false },
                { "fetchLiquidations", false },
                { "fetchLongShortRatio", false },
                { "fetchLongShortRatioHistory", false },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", true },
                { "fetchMarginModes", false },
                { "fetchMarketLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMarkPrices", false },
                { "fetchMyLiquidations", false },
                { "fetchMySettlementHistory", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", false },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenInterests", false },
                { "fetchOpenOrder", false },
                { "fetchOpenOrders", true },
                { "fetchOption", false },
                { "fetchOptionChain", false },
                { "fetchOrder", false },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", false },
                { "fetchOrders", false },
                { "fetchOrdersByStatus", false },
                { "fetchOrderTrades", false },
                { "fetchOrderWithClientOrderId", false },
                { "fetchPosition", false },
                { "fetchPositionHistory", true },
                { "fetchPositionMode", true },
                { "fetchPositions", true },
                { "fetchPositionsForSymbol", true },
                { "fetchPositionsHistory", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchSettlementHistory", false },
                { "fetchStatus", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", false },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTradingLimits", false },
                { "fetchTransactionFee", false },
                { "fetchTransactionFees", false },
                { "fetchTransactions", false },
                { "fetchTransfer", false },
                { "fetchTransfers", true },
                { "fetchUnderlyingAssets", false },
                { "fetchVolatilityHistory", false },
                { "fetchWithdrawAddresses", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "fetchWithdrawalWhitelist", false },
                { "reduceMargin", false },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", false },
                { "setLeverage", true },
                { "setMargin", false },
                { "setMarginMode", true },
                { "setPositionMode", true },
                { "signIn", false },
                { "transfer", true },
                { "watchMyLiquidationsForSymbols", false },
                { "withdraw", false },
                { "ws", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/bfffb73d-29bd-465d-b75b-98e210491769" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.bydfi.com/api" },
                    { "private", "https://api.bydfi.com/api" },
                } },
                { "www", "https://bydfi.com/" },
                { "doc", "https://developers.bydfi.com/en/" },
                { "referral", "https://partner.bydfi.com/j/DilWutCI" },
            } },
            { "fees", new Dictionary<string, object>() {} },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "v1/public/api_limits", 1 },
                        { "v1/swap/market/exchange_info", 1 },
                        { "v1/swap/market/depth", 1 },
                        { "v1/swap/market/trades", 1 },
                        { "v1/swap/market/klines", 1 },
                        { "v1/swap/market/ticker/24hr", 1 },
                        { "v1/swap/market/ticker/price", 1 },
                        { "v1/swap/market/mark_price", 1 },
                        { "v1/swap/market/funding_rate", 1 },
                        { "v1/swap/market/funding_rate_history", 1 },
                        { "v1/swap/market/risk_limit", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "v1/account/assets", 1 },
                        { "v1/account/transfer_records", 1 },
                        { "v1/spot/deposit_records", 1 },
                        { "v1/spot/withdraw_records", 1 },
                        { "v1/swap/trade/open_order", 1 },
                        { "v1/swap/trade/plan_order", 1 },
                        { "v1/swap/trade/leverage", 1 },
                        { "v1/swap/trade/history_order", 1 },
                        { "v1/swap/trade/history_trade", 1 },
                        { "v1/swap/trade/position_history", 1 },
                        { "v1/swap/trade/positions", 1 },
                        { "v1/swap/account/balance", 1 },
                        { "v1/swap/user_data/assets_margin", 1 },
                        { "v1/swap/user_data/position_side/dual", 1 },
                        { "v1/agent/teams", 1 },
                        { "v1/agent/agent_links", 1 },
                        { "v1/agent/regular_overview", 1 },
                        { "v1/agent/agent_sub_overview", 1 },
                        { "v1/agent/partener_user_deposit", 1 },
                        { "v1/agent/partener_users_data", 1 },
                        { "v1/agent/affiliate_uids", 1 },
                        { "v1/agent/affiliate_commission", 1 },
                        { "v1/agent/internal_withdrawal_status", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "v1/account/transfer", 1 },
                        { "v1/swap/trade/place_order", 1 },
                        { "v1/swap/trade/batch_place_order", 1 },
                        { "v1/swap/trade/edit_order", 1 },
                        { "v1/swap/trade/batch_edit_order", 1 },
                        { "v1/swap/trade/cancel_all_order", 1 },
                        { "v1/swap/trade/leverage", 1 },
                        { "v1/swap/trade/batch_leverage_margin", 1 },
                        { "v1/swap/user_data/margin_type", 1 },
                        { "v1/swap/user_data/position_side/dual", 1 },
                        { "v1/agent/internal_withdrawal", 1 },
                    } },
                } },
            } },
            { "features", new Dictionary<string, object>() {
                { "spot", null },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "sandbox", false },
                        { "createOrder", new Dictionary<string, object>() {
                            { "marginMode", false },
                            { "triggerPrice", false },
                            { "triggerPriceType", new Dictionary<string, object>() {
                                { "mark", true },
                                { "last", true },
                                { "index", false },
                            } },
                            { "stopLossPrice", true },
                            { "takeProfitPrice", true },
                            { "attachedStopLossTakeProfit", null },
                            { "timeInForce", new Dictionary<string, object>() {
                                { "IOC", true },
                                { "FOK", true },
                                { "PO", true },
                                { "GTD", false },
                            } },
                            { "hedged", true },
                            { "selfTradePrevention", false },
                            { "trailing", true },
                            { "iceberg", false },
                            { "leverage", false },
                            { "marketBuyRequiresPrice", false },
                            { "marketBuyByCost", false },
                        } },
                        { "createOrders", new Dictionary<string, object>() {
                            { "max", 5 },
                        } },
                        { "fetchMyTrades", new Dictionary<string, object>() {
                            { "marginMode", false },
                            { "daysBack", 182 },
                            { "limit", 500 },
                            { "untilDays", 7 },
                            { "symbolRequired", false },
                        } },
                        { "fetchOrder", null },
                        { "fetchOpenOrder", new Dictionary<string, object>() {
                            { "marginMode", false },
                            { "trigger", true },
                            { "trailing", false },
                            { "symbolRequired", true },
                        } },
                        { "fetchOpenOrders", new Dictionary<string, object>() {
                            { "marginMode", false },
                            { "limit", 500 },
                            { "trigger", true },
                            { "trailing", false },
                            { "symbolRequired", true },
                        } },
                        { "fetchOrders", null },
                        { "fetchCanceledAndClosedOrders", new Dictionary<string, object>() {
                            { "marginMode", false },
                            { "limit", 500 },
                            { "daysBack", 182 },
                            { "untilDays", 7 },
                            { "trigger", false },
                            { "trailing", false },
                            { "symbolRequired", false },
                        } },
                        { "fetchClosedOrders", null },
                        { "fetchOHLCV", new Dictionary<string, object>() {
                            { "limit", 500 },
                        } },
                    } },
                    { "inverse", null },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "12h", "12h" },
                { "1d", "1d" },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "101001", typeof(AuthenticationError) },
                    { "101103", typeof(AuthenticationError) },
                    { "102001", typeof(BadRequest) },
                    { "102002", typeof(PermissionDenied) },
                    { "401", typeof(AuthenticationError) },
                    { "500", typeof(ExchangeError) },
                    { "501", typeof(ExchangeError) },
                    { "506", typeof(ExchangeError) },
                    { "510", typeof(RateLimitExceeded) },
                    { "511", typeof(AuthenticationError) },
                    { "513", typeof(BadRequest) },
                    { "514", typeof(BadRequest) },
                    { "600", typeof(BadRequest) },
                    { "Position does not exist", typeof(BadRequest) },
                    { "Requires transaction permissions", typeof(PermissionDenied) },
                    { "Service error", typeof(ExchangeError) },
                    { "transfer failed", typeof(InsufficientFunds) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "is missing", typeof(ArgumentsRequired) },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "options", new Dictionary<string, object>() {
                { "networks", new Dictionary<string, object>() {
                    { "ERC20", "ETH" },
                } },
                { "timeInForce", new Dictionary<string, object>() {
                    { "GTC", "GTC" },
                    { "FOK", "FOK" },
                    { "IOC", "IOC" },
                    { "PO", "POST_ONLY" },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "SPOT" },
                    { "swap", "SWAP" },
                    { "funding", "FUND" },
                } },
                { "accountsById", new Dictionary<string, object>() {
                    { "SPOT", "spot" },
                    { "SWAP", "swap" },
                    { "FUND", "funding" },
                } },
            } },
        });
    }

    /**
     * @method
     * @name bydfi#fetchMarkets
     * @description retrieves data on all markets for bydfi
     * @see https://developers.bydfi.com/en/swap/market#fetching-trading-rules-and-pairs
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetV1SwapMarketExchangeInfo(parameters);
        //
        //     {
        //         "code": "200",
        //         "message": "success",
        //         "data": [
        //             {
        //                 "symbol": "CLANKER-USDT",
        //                 "baseAsset": "CLANKER",
        //                 "marginAsset": "USDT",
        //                 "quoteAsset": "USDT",
        //                 "contractFactor": "0.01",
        //                 "limitMaxQty": "50000",
        //                 "limitMinQty": "1",
        //                 "marketMaxQty": "10000",
        //                 "marketMinQty": "1",
        //                 "pricePrecision": "8",
        //                 "basePrecision": "8",
        //                 "feeRateTaker": "0.0006",
        //                 "feeRateMaker": "0.0002",
        //                 "liqFeeRate": "0.0006",
        //                 "openBuyLimitRateMax": "0.05",
        //                 "openSellLimitRateMax": "100",
        //                 "openBuyLimitRateMin": "0.98",
        //                 "openSellLimitRateMin": "0.05",
        //                 "priceOrderPrecision": "2",
        //                 "baseShowPrecision": "2",
        //                 "maxLeverageLevel": "20",
        //                 "volumePrecision": "2",
        //                 "maxLimitOrderNum": "200",
        //                 "maxPlanOrderNum": "10",
        //                 "reverse": false,
        //                 "onboardTime": "1763373600000",
        //                 "status": "NORMAL"
        //             },
        //             ...
        //         ],
        //         "success": true
        //     }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseMarkets(data);
    }

    public override object parseMarket(object market)
    {
        //
        //     {
        //         "symbol": "CLANKER-USDT",
        //         "baseAsset": "CLANKER",
        //         "marginAsset": "USDT",
        //         "quoteAsset": "USDT",
        //         "contractFactor": "0.01",
        //         "limitMaxQty": "50000",
        //         "limitMinQty": "1",
        //         "marketMaxQty": "10000",
        //         "marketMinQty": "1",
        //         "pricePrecision": "8",
        //         "basePrecision": "8",
        //         "feeRateTaker": "0.0006",
        //         "feeRateMaker": "0.0002",
        //         "liqFeeRate": "0.0006",
        //         "openBuyLimitRateMax": "0.05",
        //         "openSellLimitRateMax": "100",
        //         "openBuyLimitRateMin": "0.98",
        //         "openSellLimitRateMin": "0.05",
        //         "priceOrderPrecision": "2",
        //         "baseShowPrecision": "2",
        //         "maxLeverageLevel": "20",
        //         "volumePrecision": "2",
        //         "maxLimitOrderNum": "200",
        //         "maxPlanOrderNum": "10",
        //         "reverse": false,
        //         "onboardTime": "1763373600000",
        //         "status": "NORMAL"
        //     }
        //
        object id = this.safeString(market, "symbol");
        object baseId = this.safeString(market, "baseAsset");
        object quoteId = this.safeString(market, "quoteAsset");
        object settleId = this.safeString(market, "marginAsset");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object settle = this.safeCurrencyCode(settleId);
        object symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
        object inverse = this.safeBool(market, "reverse");
        object limitMaxQty = this.safeString(market, "limitMaxQty");
        object marketMaxQty = this.safeString(market, "marketMaxQty");
        object maxAmountString = Precise.stringMax(limitMaxQty, marketMaxQty);
        object marketMinQty = this.safeString(market, "marketMinQty");
        object limitMinQty = this.safeString(market, "limitMinQty");
        object minAmountString = Precise.stringMin(marketMinQty, limitMinQty);
        object contractSize = this.safeString(market, "contractFactor");
        object pricePrecision = this.parsePrecision(this.safeString(market, "priceOrderPrecision"));
        object rawAmountPrecision = this.parsePrecision(this.safeString(market, "volumePrecision"));
        object amountPrecision = Precise.stringDiv(rawAmountPrecision, contractSize);
        object basePrecision = this.parsePrecision(this.safeString(market, "basePrecision"));
        object taker = this.safeNumber(market, "feeRateTaker");
        object maker = this.safeNumber(market, "feeRateMaker");
        object maxLeverage = this.safeNumber(market, "maxLeverageLevel");
        object status = this.safeString(market, "status");
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", id },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", "swap" },
            { "spot", false },
            { "margin", null },
            { "swap", true },
            { "future", false },
            { "option", false },
            { "active", isEqual(status, "NORMAL") },
            { "contract", true },
            { "linear", !isTrue(inverse) },
            { "inverse", inverse },
            { "taker", taker },
            { "maker", maker },
            { "contractSize", this.parseNumber(contractSize) },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.parseNumber(amountPrecision) },
                { "price", this.parseNumber(pricePrecision) },
                { "base", this.parseNumber(basePrecision) },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", maxLeverage },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.parseNumber(minAmountString) },
                    { "max", this.parseNumber(maxAmountString) },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "created", this.parse8601(this.safeString(market, "createdAt")) },
            { "info", market },
        });
    }

    /**
     * @method
     * @name bydfi#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://developers.bydfi.com/en/swap/market#depth-information
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return, could be 5, 10, 20, 50, 100, 500 or 1000 (default 500)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.loc] crypto location, default: us
     * @returns {object} A dictionary of [order book structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = this.getClosestLimit(limit);
        }
        object response = await this.publicGetV1SwapMarketDepth(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": {
        //             "lastUpdateId": "221780076",
        //             "symbol": "ETH-USDT",
        //             "asks": [
        //                 {
        //                     "price": "2958.21",
        //                     "amount": "39478"
        //                 },
        //                 ...
        //             ],
        //             "bids": [
        //                 {
        //                     "price": "2958.19",
        //                     "amount": "174498"
        //                 },
        //                 ...
        //             ],
        //             "e": "221780076"
        //         },
        //         "success": true
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.milliseconds();
        object orderBook = this.parseOrderBook(data, getValue(market, "symbol"), timestamp, "bids", "asks", "price", "amount");
        ((IDictionary<string,object>)orderBook)["nonce"] = this.safeInteger(data, "lastUpdateId");
        return orderBook;
    }

    public virtual object getClosestLimit(object limit)
    {
        object limits = new List<object>() {5, 10, 20, 50, 100, 500, 1000};
        object result = 1000;
        for (object i = 0; isLessThan(i, getArrayLength(limits)); postFixIncrement(ref i))
        {
            if (isTrue(isLessThanOrEqual(limit, getValue(limits, i))))
            {
                result = getValue(limits, i);
                break;
            }
        }
        return result;
    }

    /**
     * @method
     * @name bydfi#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://developers.bydfi.com/en/swap/market#recent-trades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch (default 500, max 1000)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.fromId] retrieve from which trade ID to start. Default to retrieve the most recent trade records
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.publicGetV1SwapMarketTrades(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": [
        //             {
        //                 "id": "7407825178362667008",
        //                 "symbol": "ETH-USDT",
        //                 "price": "2970.49",
        //                 "quantity": "63",
        //                 "side": "SELL",
        //                 "time": 1766163153218
        //             }
        //         ],
        //         "success": true
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    /**
     * @method
     * @name bydfi#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://developers.bydfi.com/en/swap/trade#historical-trades-query
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch trades for
     * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
     * @param {string} [params.wallet] The unique code of a sub-wallet
     * @param {string} [params.orderType] order type ('LIMIT', 'MARKET', 'LIQ', 'LIMIT_CLOSE', 'MARKET_CLOSE', 'STOP', 'TAKE_PROFIT', 'STOP_MARKET', 'TAKE_PROFIT_MARKET' or 'TRAILING_STOP_MARKET')
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = this.safeBool(parameters, "paginate", false);
        if (isTrue(paginate))
        {
            object maxLimit = 500;
            parameters = this.omit(parameters, "paginate");
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "paginationDirection", "backward" },
            });
            object paginatedResponse = await this.fetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, parameters, maxLimit, true);
            return this.sortBy(paginatedResponse, "timestamp");
        }
        object contractType = "FUTURE";
        var contractTypeparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "contractType", contractType);
        contractType = ((IList<object>)contractTypeparametersVariable)[0];
        parameters = ((IList<object>)contractTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "contractType", contractType },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        parameters = this.handleSinceAndUntil("fetchMyTrades", since, parameters);
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetV1SwapTradeHistoryTrade(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": [
        //             {
        //                 "orderId": "7408919189505597440",
        //                 "wallet": "W001",
        //                 "symbol": "ETH-USDC",
        //                 "time": "1766423985842",
        //                 "dealPrice": "3032.45",
        //                 "dealVolume": "1",
        //                 "fee": "0",
        //                 "side": "BUY",
        //                 "type": "2",
        //                 "liqPrice": null,
        //                 "basePrecision": "8",
        //                 "baseShowPrecision": "2",
        //                 "tradePnl": "0",
        //                 "marginType": "CROSS",
        //                 "leverageLevel": 1
        //             }
        //         ],
        //         "success": true
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades
        //     {
        //         "id": "7407825178362667008",
        //         "symbol": "ETH-USDT",
        //         "price": "2970.49",
        //         "quantity": "63",
        //         "side": "SELL",
        //         "time": 1766163153218
        //     }
        //
        // fetchMyTrades
        //     {
        //         "orderId": "7408919189505597440",
        //         "wallet": "W001",
        //         "symbol": "ETH-USDC",
        //         "time": "1766423985842",
        //         "dealPrice": "3032.45",
        //         "dealVolume": "1",
        //         "fee": "0",
        //         "side": "BUY",
        //         "type": "2",
        //         "liqPrice": null,
        //         "basePrecision": "8",
        //         "baseShowPrecision": "2",
        //         "tradePnl": "0",
        //         "marginType": "CROSS",
        //         "leverageLevel": 1
        //     }
        //
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(trade, "time");
        object fee = null;
        object rawType = this.safeString(trade, "type");
        object feeCost = this.safeString(trade, "fee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", getValue(market, "settle") },
            };
        }
        object orderId = this.safeString(trade, "orderId");
        object side = null; // fetchMyTrades always returns side BUY
        if (isTrue(isEqual(orderId, null)))
        {
            // from fetchTrades
            side = this.safeStringLower(trade, "side");
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "id", this.safeString(trade, "id") },
            { "order", orderId },
            { "type", this.parseTradeType(rawType) },
            { "side", side },
            { "takerOrMaker", null },
            { "price", this.safeString2(trade, "price", "dealPrice") },
            { "amount", this.safeString2(trade, "quantity", "dealVolume") },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    public virtual object parseTradeType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "1", "limit" },
            { "2", "market" },
            { "3", "liquidation" },
        };
        return this.safeString(types, type, type);
    }

    /**
     * @method
     * @name bydfi#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://developers.bydfi.com/en/swap/market#candlestick-data
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch (max 500)
     * @param {object} [params] extra parameters specific to the bitteam api endpoint
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object maxLimit = 500; // docs says max 1500, but in practice only 500 works
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, maxLimit);
        }
        object market = this.market(symbol);
        object interval = this.safeString(this.timeframes, timeframe, timeframe);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "interval", interval },
        };
        object startTime = since;
        object numberOfCandles = ((bool) isTrue(limit)) ? limit : maxLimit;
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        object now = this.milliseconds();
        object duration = multiply(this.parseTimeframe(timeframe), 1000);
        object timeDelta = multiply(duration, numberOfCandles);
        if (isTrue(isTrue(isEqual(startTime, null)) && isTrue(isEqual(until, null))))
        {
            startTime = subtract(now, timeDelta);
            until = now;
        } else if (isTrue(isEqual(until, null)))
        {
            until = add(startTime, timeDelta);
            if (isTrue(isGreaterThan(until, now)))
            {
                until = now;
            }
        } else if (isTrue(isEqual(startTime, null)))
        {
            startTime = subtract(until, timeDelta);
        }
        ((IDictionary<string,object>)request)["startTime"] = startTime;
        ((IDictionary<string,object>)request)["endTime"] = until;
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.publicGetV1SwapMarketKlines(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": [
        //             {
        //                 "s": "ETH-USDT",
        //                 "t": "1766166000000",
        //                 "c": "2964.990000000000000000",
        //                 "o": "2967.830000000000000000",
        //                 "h": "2967.830000000000000000",
        //                 "l": "2964.130000000000000000",
        //                 "v": "20358.000000000000000000"
        //             }
        //         ],
        //         "success": true
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = this.parseOHLCVs(data, market, timeframe, since, limit);
        return result;
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "s": "ETH-USDT",
        //         "t": "1766166000000",
        //         "c": "2964.990000000000000000",
        //         "o": "2967.830000000000000000",
        //         "h": "2967.830000000000000000",
        //         "l": "2964.130000000000000000",
        //         "v": "20358.000000000000000000"
        //     }
        //
        return new List<object> {this.safeInteger(ohlcv, "t"), this.safeNumber(ohlcv, "o"), this.safeNumber(ohlcv, "h"), this.safeNumber(ohlcv, "l"), this.safeNumber(ohlcv, "c"), this.safeNumber(ohlcv, "v")};
    }

    /**
     * @method
     * @name bydfi#fetchTickers
     * @see https://developers.bydfi.com/en/swap/market#24hr-price-change-statistics
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetV1SwapMarketTicker24hr(parameters);
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": [
        //             {
        //                 "symbol": "BTC-USDT",
        //                 "open": "86452.9",
        //                 "high": "89371.2",
        //                 "low": "84418.5",
        //                 "last": "87050.3",
        //                 "vol": "12938783",
        //                 "time": 1766169423872
        //             }
        //         ],
        //         "success": true
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTickers(data, symbols);
    }

    /**
     * @method
     * @name bydfi#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://developers.bydfi.com/en/swap/market#24hr-price-change-statistics
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetV1SwapMarketTicker24hr(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        object ticker = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseTicker(ticker, market);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // fetchTicker/fetchTickers
        //     {
        //         "symbol": "BTC-USDT",
        //         "open": "86452.9",
        //         "high": "89371.2",
        //         "low": "84418.5",
        //         "last": "87050.3",
        //         "vol": "12938783",
        //         "time": 1766169423872
        //     }
        //
        object marketId = this.safeString2(ticker, "symbol", "s");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger2(ticker, "time", "E");
        object last = this.safeString2(ticker, "last", "c");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(marketId, market) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString2(ticker, "high", "h") },
            { "low", this.safeString2(ticker, "low", "l") },
            { "bid", null },
            { "bidVolume", null },
            { "ask", null },
            { "askVolume", null },
            { "vwap", null },
            { "open", this.safeString2(ticker, "open", "o") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString2(ticker, "vol", "v") },
            { "quoteVolume", null },
            { "markPrice", null },
            { "indexPrice", null },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name bydfi#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://developers.bydfi.com/en/swap/market#recent-funding-rate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetV1SwapMarketFundingRate(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": {
        //             "symbol": "BTC-USDT",
        //             "lastFundingRate": "0.0001",
        //             "nextFundingTime": "1766188800000",
        //             "time": "1766170665007"
        //         },
        //         "success": true
        //     }
        //
        object data = this.safeDict(response, "data");
        return this.parseFundingRate(data, market);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //     {
        //         "symbol": "BTC-USDT",
        //         "lastFundingRate": "0.0001",
        //         "nextFundingTime": "1766188800000",
        //         "time": "1766170665007"
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object timestamp = this.safeInteger(contract, "time");
        object nextFundingTimestamp = this.safeInteger(contract, "nextFundingTime");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fundingRate", this.safeNumber(contract, "lastFundingRate") },
            { "fundingTimestamp", null },
            { "fundingDatetime", null },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", nextFundingTimestamp },
            { "nextFundingDatetime", this.iso8601(nextFundingTimestamp) },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", null },
        };
    }

    /**
     * @method
     * @name bydfi#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://developers.bydfi.com/en/swap/market#historical-funding-rates
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure} to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest funding rate to fetch
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.publicGetV1SwapMarketFundingRateHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": [
        //             {
        //                 "symbol": "ETH-USDT",
        //                 "fundingRate": "0.00000025",
        //                 "fundingTime": "1765584000000",
        //                 "markPrice": "3083.2"
        //             }
        //         ],
        //         "success": true
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseFundingRateHistories(data, market, since, limit);
    }

    public override object parseFundingRateHistory(object contract, object market = null)
    {
        //
        //     {
        //         "symbol": "ETH-USDT",
        //         "fundingRate": "0.00000025",
        //         "fundingTime": "1765584000000",
        //         "markPrice": "3083.2"
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        object timestamp = this.safeInteger(contract, "fundingTime");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", this.safeSymbol(marketId, market) },
            { "fundingRate", this.safeNumber(contract, "fundingRate") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }

    /**
     * @method
     * @name bydfi#createOrder
     * @description create a trade order
     * @see https://developers.bydfi.com/en/swap/trade#placing-an-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
     * @param {bool} [params.hedged] true for hedged mode, false for one way mode, default is false
     * @param {string} [params.clientOrderId] Custom order ID, must be unique for open orders
     * @param {string} [params.timeInForce] 'GTC' (Good Till Cancelled), 'FOK' (Fill Or Kill), 'IOC' (Immediate Or Cancel), 'PO' (Post Only)
     * @param {bool} [params.postOnly] true or false, whether the order is post-only
     * @param {bool} [params.reduceOnly] true or false, true or false whether the order is reduce-only
     * @param {float} [params.stopLossPrice] The price a stop loss order is triggered at
     * @param {float} [params.takeProfitPrice] The price a take profit order is triggered at
     * @param {float} [params.trailingTriggerPrice] the price to activate a trailing order, default uses the price argument or market price if price is not provided
     * @param {float} [params.trailingPercent] the percent to trail away from the current market price
     * @param {string} [params.triggerPriceType] 'MARK_PRICE' or 'CONTRACT_PRICE', default is 'CONTRACT_PRICE', the price type used to trigger stop orders
     * @param {bool} [params.closePosition] true or false, whether to close all positions after triggering, only supported in STOP_MARKET and TAKE_PROFIT_MARKET; not used with quantity;
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object orderRequest = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object wallet = "W001";
        var walletparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "wallet", wallet);
        wallet = ((IList<object>)walletparametersVariable)[0];
        parameters = ((IList<object>)walletparametersVariable)[1];
        orderRequest = this.extend(orderRequest, new Dictionary<string, object>() {
            { "wallet", wallet },
        });
        object response = await this.privatePostV1SwapTradePlaceOrder(orderRequest);
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": {
        //             "wallet": "W001",
        //             "symbol": "ETH-USDT",
        //             "orderId": "7408875768086683648",
        //             "clientOrderId": "7408875768086683648",
        //             "price": "1000",
        //             "origQty": "10",
        //             "avgPrice": null,
        //             "executedQty": "0",
        //             "orderType": "LIMIT",
        //             "side": "BUY",
        //             "status": "NEW",
        //             "stopPrice": null,
        //             "activatePrice": null,
        //             "timeInForce": null,
        //             "workingType": "CONTRACT_PRICE",
        //             "positionSide": "BOTH",
        //             "priceProtect": false,
        //             "reduceOnly": false,
        //             "closePosition": false,
        //             "createTime": "1766413633367",
        //             "updateTime": "1766413633367"
        //         },
        //         "success": true
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", ((string)side).ToUpper() },
        };
        object stopLossPrice = this.safeString(parameters, "stopLossPrice");
        object isStopLossOrder = (!isEqual(stopLossPrice, null));
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        object isTakeProfitOrder = (!isEqual(takeProfitPrice, null));
        object trailingPercent = this.safeString(parameters, "trailingPercent");
        object isTailingStopOrder = (!isEqual(trailingPercent, null));
        object stopPrice = null;
        if (isTrue(isTrue(isStopLossOrder) || isTrue(isTakeProfitOrder)))
        {
            stopPrice = ((bool) isTrue(isStopLossOrder)) ? stopLossPrice : takeProfitPrice;
            parameters = this.omit(parameters, new List<object>() {"stopLossPrice", "takeProfitPrice"});
            ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, stopPrice);
        } else if (isTrue(isTailingStopOrder))
        {
            parameters = this.omit(parameters, new List<object>() {"trailingPercent"});
            ((IDictionary<string,object>)request)["callbackRate"] = trailingPercent;
            object trailingTriggerPrice = this.numberToString(price);
            var trailingTriggerPriceparametersVariable = this.handleParamString(parameters, "trailingTriggerPrice", trailingTriggerPrice);
            trailingTriggerPrice = ((IList<object>)trailingTriggerPriceparametersVariable)[0];
            parameters = ((IList<object>)trailingTriggerPriceparametersVariable)[1];
            if (isTrue(!isEqual(trailingTriggerPrice, null)))
            {
                ((IDictionary<string,object>)request)["activationPrice"] = this.priceToPrecision(symbol, trailingTriggerPrice);
                parameters = this.omit(parameters, new List<object>() {"trailingTriggerPrice"});
            }
        }
        type = ((string)type).ToUpper();
        object isMarketOrder = (isTrue(isTrue(isTrue((isEqual(type, "MARKET"))) || isTrue((isEqual(type, "STOP_MARKET")))) || isTrue((isEqual(type, "TAKE_PROFIT_MARKET")))) || isTrue((isEqual(type, "TRAILING_STOP_MARKET"))));
        if (isTrue(isMarketOrder))
        {
            if (isTrue(isEqual(type, "MARKET")))
            {
                if (isTrue(isStopLossOrder))
                {
                    type = "STOP_MARKET";
                } else if (isTrue(isTakeProfitOrder))
                {
                    type = "TAKE_PROFIT_MARKET";
                } else if (isTrue(isTailingStopOrder))
                {
                    type = "TRAILING_STOP_MARKET";
                }
            }
        } else
        {
            if (isTrue(isEqual(price, null)))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " createOrder() requires a price argument for a "), type), " order")) ;
            }
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            if (isTrue(isStopLossOrder))
            {
                type = "STOP";
            } else if (isTrue(isTakeProfitOrder))
            {
                type = "TAKE_PROFIT";
            }
        }
        ((IDictionary<string,object>)request)["type"] = type;
        object hedged = false;
        var hedgedparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "hedged", hedged);
        hedged = ((IList<object>)hedgedparametersVariable)[0];
        parameters = ((IList<object>)hedgedparametersVariable)[1];
        object reduceOnly = this.safeBool(parameters, "reduceOnly", false);
        if (isTrue(hedged))
        {
            parameters = this.omit(parameters, "reduceOnly");
            if (isTrue(isEqual(side, "buy")))
            {
                ((IDictionary<string,object>)request)["positionSide"] = ((bool) isTrue(reduceOnly)) ? "SHORT" : "LONG";
            } else if (isTrue(isEqual(side, "sell")))
            {
                ((IDictionary<string,object>)request)["positionSide"] = ((bool) isTrue(reduceOnly)) ? "LONG" : "SHORT";
            }
        }
        object closePosition = this.safeBool(parameters, "closePosition", false);
        if (!isTrue(closePosition))
        {
            parameters = this.omit(parameters, "closePosition");
            ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
        } else if (isTrue(isTrue((!isEqual(type, "STOP_MARKET"))) && isTrue((!isEqual(type, "TAKE_PROFIT_MARKET")))))
        {
            throw new NotSupported ((string)add(this.id, " createOrder() closePosition is only supported for stopLoss and takeProfit market orders")) ;
        }
        object timeInForce = this.handleTimeInForce(parameters);
        object postOnly = false;
        var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, isEqual(timeInForce, "POST_ONLY"), parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        if (isTrue(postOnly))
        {
            timeInForce = "POST_ONLY";
        }
        if (isTrue(!isEqual(timeInForce, null)))
        {
            ((IDictionary<string,object>)request)["timeInForce"] = timeInForce;
            parameters = this.omit(parameters, "timeInForce");
        }
        if (isTrue(isTrue(isTrue(isStopLossOrder) || isTrue(isTakeProfitOrder)) || isTrue(isTailingStopOrder)))
        {
            object workingType = "CONTRACT_PRICE";
            var workingTypeparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "triggerPriceType", workingType);
            workingType = ((IList<object>)workingTypeparametersVariable)[0];
            parameters = ((IList<object>)workingTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["workingType"] = this.encodeWorkingType(workingType);
        }
        return this.extend(request, parameters);
    }

    public virtual object encodeWorkingType(object workingType)
    {
        object types = new Dictionary<string, object>() {
            { "markPrice", "MARK_PRICE" },
            { "mark", "MARK_PRICE" },
            { "contractPrice", "CONTRACT_PRICE" },
            { "contract", "CONTRACT_PRICE" },
            { "last", "CONTRACT_PRICE" },
        };
        return this.safeString(types, workingType, workingType);
    }

    /**
     * @method
     * @name bydfi#createOrders
     * @description create a list of trade orders
     * @see https://developers.bydfi.com/en/swap/trade#batch-order-placement
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object length = getArrayLength(orders);
        if (isTrue(isGreaterThan(length, 5)))
        {
            throw new BadRequest ((string)add(this.id, " createOrders() accepts a maximum of 5 orders")) ;
        }
        object ordersRequests = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object symbol = this.safeString(rawOrder, "symbol");
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeNumber(rawOrder, "amount");
            object price = this.safeNumber(rawOrder, "price");
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object orderRequest = this.createOrderRequest(symbol, type, side, amount, price, orderParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object wallet = "W001";
        var walletparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "wallet", wallet);
        wallet = ((IList<object>)walletparametersVariable)[0];
        parameters = ((IList<object>)walletparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "wallet", wallet },
            { "orders", ordersRequests },
        };
        object response = await this.privatePostV1SwapTradeBatchPlaceOrder(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data);
    }

    /**
     * @method
     * @name bydfi#editOrder
     * @description edit a trade order
     * @see https://developers.bydfi.com/en/swap/trade#order-modification
     * @param {string} id order id (mandatory if params.clientOrderId is not provided)
     * @param {string} [symbol] unified symbol of the market to create an order in
     * @param {string} [type] not used by bydfi editOrder
     * @param {string} [side] 'buy' or 'sell'
     * @param {float} [amount] how much of the currency you want to trade in units of the base currency
     * @param {float} [price] the price for the order, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] a unique identifier for the order (could be alternative to id)
     * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = this.createEditOrderRequest(id, symbol, "limit", side, amount, price, parameters);
        object wallet = "W001";
        var walletparametersVariable = this.handleOptionAndParams(parameters, "editOrder", "wallet", wallet);
        wallet = ((IList<object>)walletparametersVariable)[0];
        parameters = ((IList<object>)walletparametersVariable)[1];
        ((IDictionary<string,object>)request)["wallet"] = wallet;
        object response = await this.privatePostV1SwapTradeEditOrder(request);
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data);
    }

    /**
     * @method
     * @name bydfi#editOrders
     * @description edit a list of trade orders
     * @see https://developers.bydfi.com/en/swap/trade#batch-order-modification
     * @param {Array} orders list of orders to edit, each object should contain the parameters required by editOrder, namely id, symbol, amount, price and params
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> editOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object length = getArrayLength(orders);
        if (isTrue(isGreaterThan(length, 5)))
        {
            throw new BadRequest ((string)add(this.id, " editOrders() accepts a maximum of 5 orders")) ;
        }
        object ordersRequests = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object id = this.safeString(rawOrder, "id");
            object symbol = this.safeString(rawOrder, "symbol");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeNumber(rawOrder, "amount");
            object price = this.safeNumber(rawOrder, "price");
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object orderRequest = this.createEditOrderRequest(id, symbol, "limit", side, amount, price, orderParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object wallet = "W001";
        var walletparametersVariable = this.handleOptionAndParams(parameters, "editOrder", "wallet", wallet);
        wallet = ((IList<object>)walletparametersVariable)[0];
        parameters = ((IList<object>)walletparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "wallet", wallet },
            { "editOrders", ordersRequests },
        };
        object response = await this.privatePostV1SwapTradeBatchEditOrder(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data);
    }

    public virtual object createEditOrderRequest(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        object request = new Dictionary<string, object>() {};
        if (isTrue(isTrue((isEqual(id, null))) && isTrue((isEqual(clientOrderId, null)))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " editOrder() requires an id argument or a clientOrderId parameter")) ;
        } else if (isTrue(!isEqual(id, null)))
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        object market = this.market(symbol);
        ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        if (isTrue(!isEqual(side, null)))
        {
            ((IDictionary<string,object>)request)["side"] = ((string)side).ToUpper();
        }
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        return this.extend(request, parameters);
    }

    /**
     * @method
     * @name bydfi#cancelAllOrders
     * @description cancel all open orders in a market
     * @see https://developers.bydfi.com/en/swap/trade#complete-order-cancellation
     * @param {string} symbol unified market symbol of the market to cancel orders in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object wallet = "W001";
        var walletparametersVariable = this.handleOptionAndParams(parameters, "cancelAllOrders", "wallet", wallet);
        wallet = ((IList<object>)walletparametersVariable)[0];
        parameters = ((IList<object>)walletparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "wallet", wallet },
        };
        object response = await this.privatePostV1SwapTradeCancelAllOrder(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": [
        //             {
        //                 "wallet": "W001",
        //                 "symbol": "ETH-USDT",
        //                 "orderId": "7408875768086683648",
        //                 "clientOrderId": "7408875768086683648",
        //                 "price": "1000",
        //                 "origQty": "10",
        //                 "avgPrice": "0",
        //                 "executedQty": "0",
        //                 "orderType": "LIMIT",
        //                 "side": "BUY",
        //                 "status": "CANCELED",
        //                 "stopPrice": null,
        //                 "activatePrice": null,
        //                 "timeInForce": null,
        //                 "workingType": "CONTRACT_PRICE",
        //                 "positionSide": "BOTH",
        //                 "priceProtect": false,
        //                 "reduceOnly": false,
        //                 "closePosition": false,
        //                 "createTime": "1766413633367",
        //                 "updateTime": "1766413633370"
        //             }
        //         ],
        //         "success": true
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market);
    }

    /**
     * @method
     * @name bydfi#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://developers.bydfi.com/en/swap/trade#pending-order-query
     * @see https://developers.bydfi.com/en/swap/trade#planned-order-query
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.trigger] true or false, whether to fetch conditional orders only
     * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOpenOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object wallet = "W001";
        var walletparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrders", "wallet", wallet);
        wallet = ((IList<object>)walletparametersVariable)[0];
        parameters = ((IList<object>)walletparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "wallet", wallet },
        };
        object response = null;
        object trigger = false;
        var triggerparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrders", "trigger", trigger);
        trigger = ((IList<object>)triggerparametersVariable)[0];
        parameters = ((IList<object>)triggerparametersVariable)[1];
        if (!isTrue(trigger))
        {
            //
            //     {
            //         "code": 200,
            //         "message": "success",
            //         "data": [
            //             {
            //                 "wallet": "W001",
            //                 "symbol": "ETH-USDC",
            //                 "orderId": "7408896083240091648",
            //                 "clientOrderId": "7408896083240091648",
            //                 "price": "999",
            //                 "origQty": "1",
            //                 "avgPrice": "0",
            //                 "executedQty": "0",
            //                 "orderType": "LIMIT",
            //                 "side": "BUY",
            //                 "status": "NEW",
            //                 "stopPrice": null,
            //                 "activatePrice": null,
            //                 "timeInForce": null,
            //                 "workingType": "CONTRACT_PRICE",
            //                 "positionSide": "BOTH",
            //                 "priceProtect": false,
            //                 "reduceOnly": false,
            //                 "closePosition": false,
            //                 "createTime": "1766418476877",
            //                 "updateTime": "1766418476880"
            //             }
            //         ],
            //         "success": true
            //     }
            //
            response = await this.privateGetV1SwapTradeOpenOrder(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetV1SwapTradePlanOrder(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    /**
     * @method
     * @name bydfi#fetchOpenOrder
     * @description fetch an open order by the id
     * @see https://developers.bydfi.com/en/swap/trade#pending-order-query
     * @see https://developers.bydfi.com/en/swap/trade#planned-order-query
     * @param {string} id order id (mandatory if params.clientOrderId is not provided)
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.trigger] true or false, whether to fetch conditional orders only
     * @param {string} [params.clientOrderId] a unique identifier for the order (could be alternative to id)
     * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async virtual Task<object> fetchOpenOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOpenOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(isTrue((isEqual(id, null))) && isTrue((isEqual(clientOrderId, null)))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOpenOrder() requires an id argument or a clientOrderId parameter")) ;
        } else if (isTrue(!isEqual(id, null)))
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        object wallet = "W001";
        var walletparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrder", "wallet", wallet);
        wallet = ((IList<object>)walletparametersVariable)[0];
        parameters = ((IList<object>)walletparametersVariable)[1];
        ((IDictionary<string,object>)request)["wallet"] = wallet;
        object response = null;
        object trigger = false;
        var triggerparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrder", "trigger", trigger);
        trigger = ((IList<object>)triggerparametersVariable)[0];
        parameters = ((IList<object>)triggerparametersVariable)[1];
        if (!isTrue(trigger))
        {
            response = await this.privateGetV1SwapTradeOpenOrder(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetV1SwapTradePlanOrder(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        object order = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseOrder(order, market);
    }

    /**
     * @method
     * @name bydfi#fetchCanceledAndClosedOrders
     * @description fetches information on multiple canceled and closed orders made by the user
     * @see https://developers.bydfi.com/en/swap/trade#historical-orders-query
     * @param {string} symbol unified market symbol of the closed orders
     * @param {int} [since] timestamp in ms of the earliest order
     * @param {int} [limit] the max number of closed orders to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest order
     * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
     * @param {string} [params.wallet] The unique code of a sub-wallet
     * @param {string} [params.orderType] order type ('LIMIT', 'MARKET', 'LIQ', 'LIMIT_CLOSE', 'MARKET_CLOSE', 'STOP', 'TAKE_PROFIT', 'STOP_MARKET', 'TAKE_PROFIT_MARKET' or 'TRAILING_STOP_MARKET')
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchCanceledAndClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = this.safeBool(parameters, "paginate", false);
        if (isTrue(paginate))
        {
            object maxLimit = 500;
            parameters = this.omit(parameters, "paginate");
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "paginationDirection", "backward" },
            });
            object paginatedResponse = await this.fetchPaginatedCallDynamic("fetchCanceledAndClosedOrders", symbol, since, limit, parameters, maxLimit, true);
            return this.sortBy(paginatedResponse, "timestamp");
        }
        object contractType = "FUTURE";
        var contractTypeparametersVariable = this.handleOptionAndParams(parameters, "fetchCanceledAndClosedOrders", "contractType", contractType);
        contractType = ((IList<object>)contractTypeparametersVariable)[0];
        parameters = ((IList<object>)contractTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "contractType", contractType },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        parameters = this.handleSinceAndUntil("fetchCanceledAndClosedOrders", since, parameters);
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetV1SwapTradeHistoryOrder(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": [
        //             {
        //                 "orderId": "7408919189505597440",
        //                 "orderType": "MARKET",
        //                 "symbol": "ETH-USDC",
        //                 "origQty": "1",
        //                 "side": "BUY",
        //                 "positionSide": "BOTH",
        //                 "positionAvgPrice": null,
        //                 "positionVolume": null,
        //                 "positionType": null,
        //                 "reduceOnly": false,
        //                 "closePosition": false,
        //                 "action": null,
        //                 "price": "3032.45",
        //                 "avgPrice": "3032.45",
        //                 "brkPrice": null,
        //                 "dealVolume": null,
        //                 "status": "2",
        //                 "wallet": "W001",
        //                 "alias": null,
        //                 "contractId": null,
        //                 "mtime": "1766423985842",
        //                 "ctime": "1766423985840",
        //                 "fixedPrice": null,
        //                 "direction": null,
        //                 "triggerPrice": null,
        //                 "priceType": null,
        //                 "basePrecision": "8",
        //                 "baseShowPrecision": "2",
        //                 "strategyType": null,
        //                 "leverageLevel": 1,
        //                 "marginType": "CROSS",
        //                 "remark": null,
        //                 "callbackRate": null,
        //                 "activationPrice": null
        //             }
        //         ],
        //         "success": true
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public virtual object handleSinceAndUntil(object methodName, object since = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams2(parameters, methodName, "until", "endTime");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        object now = this.milliseconds();
        object sevenDays = multiply(multiply(multiply(multiply(7, 24), 60), 60), 1000); // the maximum range is 7 days
        object startTime = since;
        if (isTrue(isEqual(startTime, null)))
        {
            if (isTrue(isEqual(until, null)))
            {
                // both since and until are undefined
                startTime = subtract(now, sevenDays);
                until = now;
            } else
            {
                // since is undefined but until is defined
                startTime = subtract(until, sevenDays);
            }
        } else if (isTrue(isEqual(until, null)))
        {
            // until is undefined but since is defined
            object delta = subtract(now, startTime);
            if (isTrue(isGreaterThan(delta, sevenDays)))
            {
                until = add(startTime, sevenDays);
            } else
            {
                until = now;
            }
        }
        object request = new Dictionary<string, object>() {
            { "startTime", startTime },
            { "endTime", until },
        };
        return this.extend(request, parameters);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder, fetchOpenOrders, fetchOpenOrder
        //     {
        //         "wallet": "W001",
        //         "symbol": "ETH-USDT",
        //         "orderId": "7408875768086683648",
        //         "clientOrderId": "7408875768086683648",
        //         "price": "1000",
        //         "origQty": "10",
        //         "avgPrice": "0",
        //         "executedQty": "0",
        //         "orderType": "LIMIT",
        //         "side": "BUY",
        //         "status": "CANCELED",
        //         "stopPrice": null,
        //         "activatePrice": null,
        //         "timeInForce": null,
        //         "workingType": "CONTRACT_PRICE",
        //         "positionSide": "BOTH",
        //         "priceProtect": false,
        //         "reduceOnly": false,
        //         "closePosition": false,
        //         "createTime": "1766413633367",
        //         "updateTime": "1766413633370"
        //     }
        //
        // fetchCanceledAndClosedOrders
        //     {
        //         "orderId": "7408919189505597440",
        //         "orderType": "MARKET",
        //         "symbol": "ETH-USDC",
        //         "origQty": "1",
        //         "side": "BUY",
        //         "positionSide": "BOTH",
        //         "positionAvgPrice": null,
        //         "positionVolume": null,
        //         "positionType": null,
        //         "reduceOnly": false,
        //         "closePosition": false,
        //         "action": null,
        //         "price": "3032.45",
        //         "avgPrice": "3032.45",
        //         "brkPrice": null,
        //         "dealVolume": null,
        //         "status": "2",
        //         "wallet": "W001",
        //         "alias": null,
        //         "contractId": null,
        //         "mtime": "1766423985842",
        //         "ctime": "1766423985840",
        //         "fixedPrice": null,
        //         "direction": null,
        //         "triggerPrice": null,
        //         "priceType": null,
        //         "basePrecision": "8",
        //         "baseShowPrecision": "2",
        //         "strategyType": null,
        //         "leverageLevel": 1,
        //         "marginType": "CROSS",
        //         "remark": null,
        //         "callbackRate": null,
        //         "activationPrice": null
        //     }
        //
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger2(order, "createTime", "ctime");
        object rawType = this.safeString(order, "orderType");
        object stopPrice = this.safeStringN(order, new List<object>() {"stopPrice", "activatePrice", "triggerPrice"});
        object isStopLossOrder = isTrue(isTrue((isEqual(rawType, "STOP"))) || isTrue((isEqual(rawType, "STOP_MARKET")))) || isTrue((isEqual(rawType, "TRAILING_STOP_MARKET")));
        object isTakeProfitOrder = isTrue((isEqual(rawType, "TAKE_PROFIT"))) || isTrue((isEqual(rawType, "TAKE_PROFIT_MARKET")));
        object rawTimeInForce = this.safeString(order, "timeInForce");
        object timeInForce = this.parseOrderTimeInForce(rawTimeInForce);
        object postOnly = null;
        if (isTrue(isEqual(timeInForce, "PO")))
        {
            postOnly = true;
        }
        object rawStatus = this.safeString(order, "status");
        object fee = new Dictionary<string, object>() {};
        object quoteFee = this.safeNumber(order, "quoteFee");
        if (isTrue(!isEqual(quoteFee, null)))
        {
            ((IDictionary<string,object>)fee)["cost"] = quoteFee;
            ((IDictionary<string,object>)fee)["currency"] = getValue(market, "quote");
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString(order, "orderId") },
            { "clientOrderId", this.safeString(order, "clientOrderId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", this.safeInteger2(order, "updateTime", "mtime") },
            { "status", this.parseOrderStatus(rawStatus) },
            { "symbol", getValue(market, "symbol") },
            { "type", this.parseOrderType(rawType) },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "reduceOnly", this.safeBool(order, "reduceOnly") },
            { "side", this.safeStringLower(order, "side") },
            { "price", this.safeString(order, "price") },
            { "triggerPrice", stopPrice },
            { "stopLossPrice", ((bool) isTrue(isStopLossOrder)) ? stopPrice : null },
            { "takeProfitPrice", ((bool) isTrue(isTakeProfitOrder)) ? stopPrice : null },
            { "amount", this.safeString(order, "origQty") },
            { "filled", this.safeString(order, "executedQty") },
            { "remaining", null },
            { "cost", null },
            { "trades", null },
            { "fee", fee },
            { "average", this.omitZero(this.safeString(order, "avgPrice")) },
        }, market);
    }

    public virtual object parseOrderType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "LIMIT", "limit" },
            { "MARKET", "market" },
            { "STOP", "limit" },
            { "STOP_MARKET", "market" },
            { "TAKE_PROFIT", "limit" },
            { "TAKE_PROFIT_MARKET", "market" },
            { "TRAILING_STOP_MARKET", "market" },
        };
        return this.safeString(types, type, type);
    }

    public virtual object parseOrderTimeInForce(object timeInForce)
    {
        object timeInForces = new Dictionary<string, object>() {
            { "GTC", "GTC" },
            { "FOK", "FOK" },
            { "IOC", "IOC" },
            { "POST_ONLY", "PO" },
            { "TRAILING_STOP", "IOC" },
        };
        return this.safeString(timeInForces, timeInForce, timeInForce);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "open" },
            { "PARTIALLY_FILLED", "open" },
            { "FILLED", "closed" },
            { "EXPIRED", "canceled" },
            { "PART_FILLED_CANCELLED", "canceled" },
            { "CANCELED", "canceled" },
            { "2", "closed" },
            { "4", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name bydfi#setLeverage
     * @description set the level of leverage for a market
     * @see https://developers.bydfi.com/en/swap/trade#set-leverage-for-single-trading-pair
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object wallet = "W001";
        var walletparametersVariable = this.handleOptionAndParams(parameters, "setLeverage", "wallet", wallet);
        wallet = ((IList<object>)walletparametersVariable)[0];
        parameters = ((IList<object>)walletparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "leverage", leverage },
            { "wallet", wallet },
        };
        object response = await this.privatePostV1SwapTradeLeverage(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return data;
    }

    /**
     * @method
     * @name bydfi#fetchLeverage
     * @description fetch the set leverage for a market
     * @see https://developers.bydfi.com/en/swap/trade#get-leverage-for-single-trading-pair
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
     * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/?id=leverage-structure}
     */
    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object wallet = "W001";
        var walletparametersVariable = this.handleOptionAndParams(parameters, "fetchLeverage", "wallet", wallet);
        wallet = ((IList<object>)walletparametersVariable)[0];
        parameters = ((IList<object>)walletparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "wallet", wallet },
        };
        object response = await this.privateGetV1SwapTradeLeverage(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": {
        //             "symbol": "ETH-USDC",
        //             "leverage": 1,
        //             "maxNotionalValue": "100000000"
        //         },
        //         "success": true
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseLeverage(data, market);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        object marketId = this.safeString(leverage, "symbol");
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", this.safeSymbol(marketId, market) },
            { "marginMode", null },
            { "longLeverage", this.safeInteger(leverage, "leverage") },
            { "shortLeverage", this.safeInteger(leverage, "leverage") },
        };
    }

    /**
     * @method
     * @name bydfi#fetchPositions
     * @description fetch all open positions
     * @see https://developers.bydfi.com/en/swap/trade#positions-query
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
     * @param {string} [params.settleCoin] the settlement currency (USDT or USDC or USD)
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object contractType = "FUTURE";
        var contractTypeparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "contractType", contractType);
        contractType = ((IList<object>)contractTypeparametersVariable)[0];
        parameters = ((IList<object>)contractTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "contractType", contractType },
        };
        object response = await this.privateGetV1SwapTradePositions(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": [
        //             {
        //                 "symbol": "ETH-USDC",
        //                 "side": "BUY",
        //                 "volume": "0.001",
        //                 "avgPrice": "3032.45",
        //                 "liqPrice": "0",
        //                 "markPrice": "3032.37",
        //                 "unPnl": "-0.00008",
        //                 "positionMargin": "0",
        //                 "settleCoin": "USDC",
        //                 "im": "3.03245",
        //                 "mm": "0.007581125"
        //             }
        //         ],
        //         "success": true
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parsePositions(data, symbols);
    }

    /**
     * @method
     * @name bydfi#fetchPositionsForSymbol
     * @description fetch open positions for a single market
     * @see https://developers.bydfi.com/en/swap/trade#positions-query
     * @description fetch all open positions for specific symbol
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> fetchPositionsForSymbol(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object contractType = "FUTURE";
        var contractTypeparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "contractType", contractType);
        contractType = ((IList<object>)contractTypeparametersVariable)[0];
        parameters = ((IList<object>)contractTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "contractType", contractType },
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateGetV1SwapTradePositions(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parsePositions(data, new List<object>() {getValue(market, "symbol")});
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // fetchPositions, fetchPositionsForSymbol
        //     {
        //         "symbol": "ETH-USDC",
        //         "side": "BUY",
        //         "volume": "0.001",
        //         "avgPrice": "3032.45",
        //         "liqPrice": "0",
        //         "markPrice": "3032.37",
        //         "unPnl": "-0.00008",
        //         "positionMargin": "0",
        //         "settleCoin": "USDC",
        //         "im": "3.03245",
        //         "mm": "0.007581125"
        //     }
        //
        // fetchPositionsHistory
        //     {
        //         "id": "16788366",
        //         "wallet": "W001",
        //         "currency": "USDC",
        //         "symbol": "ETH-USDC",
        //         "side": "BUY",
        //         "positionSide": "BOTH",
        //         "leverage": 1,
        //         "avgOpenPositionPrice": "3032.45",
        //         "openPositionVolume": "1",
        //         "openCount": 1,
        //         "highPrice": "3032.45",
        //         "lowPrice": "2953.67",
        //         "avgClosePositionPrice": "2953.67",
        //         "closePositionVolume": "1",
        //         "closePositionCost": "2.95367",
        //         "closeCount": 1,
        //         "positionProfits": "-0.07878",
        //         "lossBonus": "0",
        //         "capitalFeeTotal": "-0.00026361",
        //         "capitalFeeOutCash": "-0.00026361",
        //         "capitalFeeInCash": "0",
        //         "capitalFeeBonus": "0",
        //         "openFeeTotal": "-0.00181947",
        //         "openFeeBonus": "0",
        //         "closeFeeTotal": "-0.00177221",
        //         "closeFeeBonus": "0",
        //         "liqLoss": "0",
        //         "liqClosed": false,
        //         "sequence": "53685341336",
        //         "updateTime": "1766494929423",
        //         "createTime": "1766423985842"
        //     }
        //
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market);
        object buyOrSell = this.safeString(position, "side");
        object rawPositionSide = this.safeStringLower(position, "positionSide");
        object positionSide = this.parsePositionSide(buyOrSell);
        object hedged = null;
        object isFetchPositionsHistory = false;
        if (isTrue(!isEqual(rawPositionSide, null)))
        {
            isFetchPositionsHistory = true;
            if (isTrue(!isEqual(rawPositionSide, "both")))
            {
                positionSide = rawPositionSide;
                hedged = true;
            } else
            {
                hedged = false;
            }
        }
        object contractSize = this.safeString(market, "contractSize");
        object contracts = this.safeString2(position, "volume", "openPositionVolume");
        if (!isTrue(isFetchPositionsHistory))
        {
            // in fetchPositions, the 'volume' is in base currency units, need to convert to contracts
            contracts = Precise.stringDiv(contracts, contractSize);
        }
        object timestamp = this.safeInteger(position, "createTime");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", this.safeString(position, "id") },
            { "symbol", getValue(market, "symbol") },
            { "entryPrice", this.parseNumber(this.safeString2(position, "avgOpenPositionPrice", "avgPrice")) },
            { "markPrice", this.parseNumber(this.safeString(position, "markPrice")) },
            { "lastPrice", this.parseNumber(this.safeString(position, "avgClosePositionPrice")) },
            { "notional", this.parseNumber(this.safeString(position, "closePositionCost")) },
            { "collateral", null },
            { "unrealizedPnl", this.parseNumber(this.safeString(position, "unPnl")) },
            { "realizedPnl", this.parseNumber(this.safeString(position, "positionProfits")) },
            { "side", positionSide },
            { "contracts", this.parseNumber(contracts) },
            { "contractSize", this.parseNumber(contractSize) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", this.safeInteger(position, "updateTime") },
            { "hedged", hedged },
            { "maintenanceMargin", this.parseNumber(this.safeString(position, "mm")) },
            { "maintenanceMarginPercentage", null },
            { "initialMargin", this.parseNumber(this.safeString(position, "im")) },
            { "initialMarginPercentage", null },
            { "leverage", this.parseNumber(this.safeString(position, "leverage")) },
            { "liquidationPrice", this.parseNumber(this.safeString(position, "liqPrice")) },
            { "marginRatio", null },
            { "marginMode", null },
            { "percentage", null },
        });
    }

    public virtual object parsePositionSide(object side)
    {
        object sides = new Dictionary<string, object>() {
            { "BUY", "long" },
            { "SELL", "short" },
        };
        return this.safeString(sides, side, side);
    }

    /**
     * @method
     * @name bydfi#fetchPositionHistory
     * @description fetches historical positions
     * @see https://developers.bydfi.com/en/swap/trade#query-historical-position-profit-and-loss-records
     * @param {string} symbol a unified market symbol
     * @param {int} [since] timestamp in ms of the earliest position to fetch , params["until"] - since <= 7 days
     * @param {int} [limit] the maximum amount of records to fetch (default 500, max 500)
     * @param {object} params extra parameters specific to the exchange api endpoint
     * @param {int} [params.until] timestamp in ms of the latest position to fetch , params["until"] - since <= 7 days
     * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
     * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
     * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> fetchPositionHistory(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object contractType = "FUTURE";
        var contractTypeparametersVariable = this.handleOptionAndParams(parameters, "fetchPositionsHistory", "contractType", contractType);
        contractType = ((IList<object>)contractTypeparametersVariable)[0];
        parameters = ((IList<object>)contractTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "contractType", contractType },
        };
        parameters = this.handleSinceAndUntil("fetchPositionsHistory", since, parameters);
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetV1SwapTradePositionHistory(this.extend(request, parameters));
        //
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object positions = this.parsePositions(data);
        return this.filterBySinceLimit(positions, since, limit);
    }

    /**
     * @method
     * @name bydfi#fetchPositionsHistory
     * @description fetches historical positions
     * @see https://developers.bydfi.com/en/swap/trade#query-historical-position-profit-and-loss-records
     * @param {string[]} symbols a list of unified market symbols
     * @param {int} [since] timestamp in ms of the earliest position to fetch , params["until"] - since <= 7 days
     * @param {int} [limit] the maximum amount of records to fetch (default 500, max 500)
     * @param {object} params extra parameters specific to the exchange api endpoint
     * @param {int} [params.until] timestamp in ms of the latest position to fetch , params["until"] - since <= 7 days
     * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
     * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
     * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> fetchPositionsHistory(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object contractType = "FUTURE";
        var contractTypeparametersVariable = this.handleOptionAndParams(parameters, "fetchPositionsHistory", "contractType", contractType);
        contractType = ((IList<object>)contractTypeparametersVariable)[0];
        parameters = ((IList<object>)contractTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "contractType", contractType },
        };
        parameters = this.handleSinceAndUntil("fetchPositionsHistory", since, parameters);
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetV1SwapTradePositionHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": [
        //             {
        //                 "id": "16788366",
        //                 "wallet": "W001",
        //                 "currency": "USDC",
        //                 "symbol": "ETH-USDC",
        //                 "side": "BUY",
        //                 "positionSide": "BOTH",
        //                 "leverage": 1,
        //                 "avgOpenPositionPrice": "3032.45",
        //                 "openPositionVolume": "1",
        //                 "openCount": 1,
        //                 "highPrice": "3032.45",
        //                 "lowPrice": "2953.67",
        //                 "avgClosePositionPrice": "2953.67",
        //                 "closePositionVolume": "1",
        //                 "closePositionCost": "2.95367",
        //                 "closeCount": 1,
        //                 "positionProfits": "-0.07878",
        //                 "lossBonus": "0",
        //                 "capitalFeeTotal": "-0.00026361",
        //                 "capitalFeeOutCash": "-0.00026361",
        //                 "capitalFeeInCash": "0",
        //                 "capitalFeeBonus": "0",
        //                 "openFeeTotal": "-0.00181947",
        //                 "openFeeBonus": "0",
        //                 "closeFeeTotal": "-0.00177221",
        //                 "closeFeeBonus": "0",
        //                 "liqLoss": "0",
        //                 "liqClosed": false,
        //                 "sequence": "53685341336",
        //                 "updateTime": "1766494929423",
        //                 "createTime": "1766423985842"
        //             }
        //         ],
        //         "success": true
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object positions = this.parsePositions(data, symbols);
        return this.filterBySinceLimit(positions, since, limit);
    }

    /**
     * @method
     * @name bydfi#fetchMarginMode
     * @description fetches the margin mode of a trading pair
     * @see https://developers.bydfi.com/en/swap/user#margin-mode-query
     * @param {string} symbol unified symbol of the market to fetch the margin mode for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
     * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
     * @returns {object} a [margin mode structure]{@link https://docs.ccxt.com/?id=margin-mode-structure}
     */
    public async override Task<object> fetchMarginMode(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object contractType = "FUTURE";
        var contractTypeparametersVariable = this.handleOptionAndParams(parameters, "fetchMarginMode", "contractType", contractType);
        contractType = ((IList<object>)contractTypeparametersVariable)[0];
        parameters = ((IList<object>)contractTypeparametersVariable)[1];
        object wallet = "W001";
        var walletparametersVariable = this.handleOptionAndParams(parameters, "fetchMarginMode", "wallet", wallet);
        wallet = ((IList<object>)walletparametersVariable)[0];
        parameters = ((IList<object>)walletparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "contractType", contractType },
            { "symbol", getValue(market, "id") },
            { "wallet", wallet },
        };
        object response = await this.privateGetV1SwapUserDataAssetsMargin(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": {
        //             "wallet": "W001",
        //             "symbol": "ETH-USDC",
        //             "marginType": "CROSS"
        //         },
        //         "success": true
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginMode(data, market);
    }

    public override object parseMarginMode(object marginMode, object market = null)
    {
        object marketId = this.safeString(marginMode, "symbol");
        return new Dictionary<string, object>() {
            { "info", marginMode },
            { "symbol", this.safeSymbol(marketId, market) },
            { "marginMode", this.safeStringLower(marginMode, "marginType") },
        };
    }

    /**
     * @method
     * @name bydfi#setMarginMode
     * @description set margin mode to 'cross' or 'isolated'
     * @see https://developers.bydfi.com/en/swap/user#change-margin-type-cross-margin
     * @param {string} marginMode 'cross' or 'isolated'
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
     * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
     * @returns {object} response from the exchange
     */
    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        marginMode = ((string)marginMode).ToLower();
        if (isTrue(isTrue(!isEqual(marginMode, "isolated")) && isTrue(!isEqual(marginMode, "cross"))))
        {
            throw new BadRequest ((string)add(this.id, " setMarginMode() marginMode argument should be isolated or cross")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object contractType = "FUTURE";
        var contractTypeparametersVariable = this.handleOptionAndParams(parameters, "fetchMarginMode", "contractType", contractType);
        contractType = ((IList<object>)contractTypeparametersVariable)[0];
        parameters = ((IList<object>)contractTypeparametersVariable)[1];
        object wallet = "W001";
        var walletparametersVariable = this.handleOptionAndParams(parameters, "fetchMarginMode", "wallet", wallet);
        wallet = ((IList<object>)walletparametersVariable)[0];
        parameters = ((IList<object>)walletparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "contractType", contractType },
            { "symbol", getValue(market, "id") },
            { "marginType", ((string)marginMode).ToUpper() },
            { "wallet", wallet },
        };
        return await this.privatePostV1SwapUserDataMarginType(this.extend(request, parameters));
    }

    /**
     * @method
     * @name bydfi#setPositionMode
     * @description set hedged to true or false for a market, hedged for bydfi is set identically for all markets with same settle currency
     * @see https://developers.bydfi.com/en/swap/user#change-position-mode-dual
     * @param {bool} hedged set to true to use dualSidePosition
     * @param {string} [symbol] not used by bydfi setPositionMode ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
     * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
     * @param {string} [params.settleCoin] The settlement currency - USDT or USDC or USD (default is USDT)
     * @returns {object} response from the exchange
     */
    public async override Task<object> setPositionMode(object hedged, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(!isEqual(symbol, null)))
        {
            throw new NotSupported ((string)add(this.id, " setPositionMode() does not support a symbol argument. The position mode is set identically for all markets with same settle currency")) ;
        }
        await this.loadMarkets();
        object positionType = ((bool) isTrue(hedged)) ? "HEDGE" : "ONEWAY";
        object wallet = "W001";
        var walletparametersVariable = this.handleOptionAndParams(parameters, "setPositionMode", "wallet", wallet);
        wallet = ((IList<object>)walletparametersVariable)[0];
        parameters = ((IList<object>)walletparametersVariable)[1];
        object contractType = "FUTURE";
        var contractTypeparametersVariable = this.handleOptionAndParams(parameters, "setPositionMode", "contractType", contractType);
        contractType = ((IList<object>)contractTypeparametersVariable)[0];
        parameters = ((IList<object>)contractTypeparametersVariable)[1];
        object settleCoin = "USDT";
        var settleCoinparametersVariable = this.handleOptionAndParams(parameters, "setPositionMode", "settleCoin", settleCoin);
        settleCoin = ((IList<object>)settleCoinparametersVariable)[0];
        parameters = ((IList<object>)settleCoinparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "contractType", contractType },
            { "wallet", wallet },
            { "positionType", positionType },
            { "settleCoin", settleCoin },
        };
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "success": true
        //     }
        //
        return await this.privatePostV1SwapUserDataPositionSideDual(this.extend(request, parameters));
    }

    /**
     * @method
     * @name bydfi#fetchPositionMode
     * @description fetchs the position mode, hedged or one way, hedged for bydfi is set identically for all markets with same settle currency
     * @see https://developers.bydfi.com/en/swap/user#get-position-mode
     * @param {string} [symbol] unified symbol of the market to fetch the order book for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
     * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
     * @param {string} [params.settleCoin] The settlement currency - USDT or USDC or USD (default is USDT or settle currency of the market if market is provided)
     * @returns {object} an object detailing whether the market is in hedged or one-way mode
     */
    public async override Task<object> fetchPositionMode(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object wallet = "W001";
        var walletparametersVariable = this.handleOptionAndParams(parameters, "fetchPositionMode", "wallet", wallet);
        wallet = ((IList<object>)walletparametersVariable)[0];
        parameters = ((IList<object>)walletparametersVariable)[1];
        object contractType = "FUTURE";
        var contractTypeparametersVariable = this.handleOptionAndParams(parameters, "fetchPositionMode", "contractType", contractType);
        contractType = ((IList<object>)contractTypeparametersVariable)[0];
        parameters = ((IList<object>)contractTypeparametersVariable)[1];
        object settleCoin = "USDT";
        if (isTrue(isEqual(symbol, null)))
        {
            var settleCoinparametersVariable = this.handleOptionAndParams(parameters, "fetchPositionMode", "settleCoin", settleCoin);
            settleCoin = ((IList<object>)settleCoinparametersVariable)[0];
            parameters = ((IList<object>)settleCoinparametersVariable)[1];
        } else
        {
            object market = this.market(symbol);
            settleCoin = getValue(market, "settleId");
        }
        object request = new Dictionary<string, object>() {
            { "contractType", contractType },
            { "settleCoin", settleCoin },
            { "wallet", wallet },
        };
        object response = await this.privateGetV1SwapUserDataPositionSideDual(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": {
        //             "wallet": "W001",
        //             "contractType": "FUTURE",
        //             "settleCoin": "USDT",
        //             "positionType": "HEDGE",
        //             "unitModel": 2,
        //             "pricingModel": "FLAG",
        //             "priceProtection": "CLOSE",
        //             "totalWallet": 2
        //         },
        //         "success": true
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object hedged = isEqual(this.safeString(data, "positionType"), "HEDGE");
        return new Dictionary<string, object>() {
            { "info", response },
            { "hedged", hedged },
        };
    }

    /**
     * @method
     * @name bydfi#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://developers.bydfi.com/en/account#asset-inquiry
     * @see https://developers.bydfi.com/en/swap/user#asset-query
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.accountType] the type of account to fetch the balance for, either 'spot' or 'swap'  or 'funding' (default is 'spot')
     * @param {string} [params.wallet] *swap only* The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
     * @param {string} [params.asset] currency id for the balance to fetch
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object accountType = "spot";
        var accountTypeparametersVariable = this.handleOptionAndParams2(parameters, "fetchBalance", "accountType", "type", accountType);
        accountType = ((IList<object>)accountTypeparametersVariable)[0];
        parameters = ((IList<object>)accountTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(!isEqual(accountType, "swap")))
        {
            object options = this.safeDict(this.options, "accountsByType", new Dictionary<string, object>() {});
            object parsedAccountType = this.safeString(options, accountType, accountType);
            ((IDictionary<string,object>)request)["walletType"] = parsedAccountType;
            //
            //     {
            //         "code": 200,
            //         "message": "success",
            //         "data": [
            //             {
            //                 "walletType": "spot",
            //                 "asset": "USDC",
            //                 "total": "100",
            //                 "available": "100",
            //                 "frozen": "0"
            //             }
            //         ],
            //         "success": true
            //     }
            //
            response = await this.privateGetV1AccountAssets(this.extend(request, parameters));
        } else
        {
            object wallet = "W001";
            var walletparametersVariable = this.handleOptionAndParams(parameters, "fetchBalance", "wallet", wallet);
            wallet = ((IList<object>)walletparametersVariable)[0];
            parameters = ((IList<object>)walletparametersVariable)[1];
            ((IDictionary<string,object>)request)["wallet"] = wallet;
            //
            //     {
            //         "code": 200,
            //         "message": "success",
            //         "data": [
            //             {
            //                 "wallet": "W001",
            //                 "asset": "USDT",
            //                 "balance": "0",
            //                 "frozen": "0",
            //                 "positionMargin": "0",
            //                 "availableBalance": "0",
            //                 "canWithdrawAmount": "0",
            //                 "bonusAmount": "0"
            //             },
            //             {
            //                 "wallet": "W001",
            //                 "asset": "USDC",
            //                 "balance": "99.99505828",
            //                 "frozen": "4.0024",
            //                 "positionMargin": "2.95342",
            //                 "availableBalance": "92.96020828",
            //                 "canWithdrawAmount": "92.96020828",
            //                 "bonusAmount": "0"
            //             }
            //         ],
            //         "success": true
            //     }
            response = await this.privateGetV1SwapAccountBalance(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseBalance(data);
    }

    public override object parseBalance(object response)
    {
        object timestamp = this.milliseconds();
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object balance = getValue(response, i);
            object symbol = this.safeString(balance, "asset");
            object code = this.safeCurrencyCode(symbol);
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString2(balance, "total", "balance");
            ((IDictionary<string,object>)account)["free"] = this.safeString2(balance, "available", "availableBalance");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name budfi#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://developers.bydfi.com/en/account#asset-transfer-between-accounts
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount 'spot', 'funding', or 'swap'
     * @param {string} toAccount 'spot', 'funding', or 'swap'
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountsByType = this.safeDict(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, toAccount);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
            { "fromType", fromId },
            { "toType", toId },
        };
        object response = await this.privatePostV1AccountTransfer(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "success": true
        //     }
        //
        object transfer = this.parseTransfer(response, currency);
        object transferOptions = this.safeDict(this.options, "transfer", new Dictionary<string, object>() {});
        object fillResponseFromRequest = this.safeBool(transferOptions, "fillResponseFromRequest", true);
        if (isTrue(fillResponseFromRequest))
        {
            object timestamp = this.milliseconds();
            ((IDictionary<string,object>)transfer)["timestamp"] = timestamp;
            ((IDictionary<string,object>)transfer)["datetime"] = this.iso8601(timestamp);
            ((IDictionary<string,object>)transfer)["currency"] = code;
            ((IDictionary<string,object>)transfer)["fromAccount"] = fromAccount;
            ((IDictionary<string,object>)transfer)["toAccount"] = toAccount;
            ((IDictionary<string,object>)transfer)["amount"] = amount;
        }
        return transfer;
    }

    /**
     * @method
     * @name bydfi#fetchTransfers
     * @description fetch a history of internal transfers made on an account
     * @see https://developers.bydfi.com/en/account#query-wallet-transfer-records
     * @param {string} code unified currency code of the currency transferred
     * @param {int} [since] the earliest time in ms to fetch transfers for
     * @param {int} [limit] the maximum number of transfers structures to retrieve (default 10)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/?id=transfer-structure}
     */
    public async override Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchTransfers() requires a code argument")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(code);
        object paginate = this.safeBool(parameters, "paginate", false);
        if (isTrue(paginate))
        {
            object maxLimit = 50;
            parameters = this.omit(parameters, "paginate");
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "paginationDirection", "backward" },
            });
            object paginatedResponse = await this.fetchPaginatedCallDynamic("fetchTransfers", getValue(currency, "code"), since, limit, parameters, maxLimit, true);
            return this.sortBy(paginatedResponse, "timestamp");
        }
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
        };
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams2(parameters, "fetchTransfers", "until", "endTime");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        if (isTrue(isEqual(until, null)))
        {
            until = this.milliseconds(); // exchange requires endTime
        }
        if (isTrue(isEqual(since, null)))
        {
            since = 1; // exchange requires startTime but allows any value
        }
        ((IDictionary<string,object>)request)["startTime"] = since;
        ((IDictionary<string,object>)request)["endTime"] = until;
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["rows"] = limit;
        }
        object response = await this.privateGetV1AccountTransferRecords(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": [
        //             {
        //                 "orderId": "1209991065294581760",
        //                 "txId": "6km5fRK83Gwdp43HA479DW1Colh2pKyS",
        //                 "sourceWallet": "SPOT",
        //                 "targetWallet": "SWAP",
        //                 "asset": "USDC",
        //                 "amount": "100",
        //                 "status": "SUCCESS",
        //                 "timestamp": 1766413950000
        //             }
        //         ],
        //         "success": true
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransfers(data, currency, since, limit);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "success": true
        //     }
        //
        // fetchTransfers
        //     {
        //         "orderId": "1209991065294581760",
        //         "txId": "6km5fRK83Gwdp43HA479DW1Colh2pKyS",
        //         "sourceWallet": "SPOT",
        //         "targetWallet": "SWAP",
        //         "asset": "USDC",
        //         "amount": "100",
        //         "status": "SUCCESS",
        //         "timestamp": 1766413950000
        //     }
        //
        object status = this.safeStringUpper2(transfer, "message", "status");
        object accountsById = this.safeDict(this.options, "accountsById", new Dictionary<string, object>() {});
        object fromId = this.safeStringUpper(transfer, "sourceWallet");
        object toId = this.safeStringUpper(transfer, "targetWallet");
        object fromAccount = this.safeString(accountsById, fromId, fromId);
        object toAccount = this.safeString(accountsById, toId, toId);
        object timestamp = this.safeInteger(transfer, "timestamp");
        object currencyId = this.safeString(transfer, "asset");
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", this.safeString(transfer, "txId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber(transfer, "amount") },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "status", this.paraseTransferStatus(status) },
        };
    }

    public virtual object paraseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "SUCCESS", "ok" },
            { "WAIT", "pending" },
            { "FAILED", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name bydfi#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://developers.bydfi.com/en/spot/account#query-deposit-records
     * @param {string} code unified currency code (mandatory)
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsHelper("deposit", code, since, limit, parameters);
    }

    /**
     * @method
     * @name bydfi#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://developers.bydfi.com/en/spot/account#query-withdrawal-records
     * @param {string} code unified currency code (mandatory)
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawal structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsHelper("withdrawal", code, since, limit, parameters);
    }

    public async virtual Task<object> fetchTransactionsHelper(object type, object code, object since, object limit, object parameters)
    {
        object methodName = ((bool) isTrue((isEqual(type, "deposit")))) ? "fetchDeposits" : "fetchWithdrawals";
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a code argument")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(code);
        object paginate = this.safeBool(parameters, "paginate", false);
        if (isTrue(paginate))
        {
            object maxLimit = 50;
            parameters = this.omit(parameters, "paginate");
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "paginationDirection", "backward" },
            });
            object paginatedResponse = await this.fetchPaginatedCallDynamic(methodName, getValue(currency, "code"), since, limit, parameters, maxLimit, true);
            return this.sortBy(paginatedResponse, "timestamp");
        }
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
        };
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams2(parameters, "fetchTransfers", "until", "endTime");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        object now = this.milliseconds();
        object sevenDays = multiply(multiply(multiply(multiply(7, 24), 60), 60), 1000); // the maximum range is 7 days
        object startTime = since;
        if (isTrue(isEqual(startTime, null)))
        {
            if (isTrue(isEqual(until, null)))
            {
                // both since and until are undefined
                startTime = subtract(now, sevenDays);
                until = now;
            } else
            {
                // since is undefined but until is defined
                startTime = subtract(until, sevenDays);
            }
        } else if (isTrue(isEqual(until, null)))
        {
            // until is undefined but since is defined
            object delta = subtract(now, startTime);
            if (isTrue(isGreaterThan(delta, sevenDays)))
            {
                until = add(startTime, sevenDays);
            } else
            {
                until = now;
            }
        }
        ((IDictionary<string,object>)request)["startTime"] = startTime;
        ((IDictionary<string,object>)request)["endTime"] = until;
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(isEqual(type, "deposit")))
        {
            //
            //     {
            //         "code": 200,
            //         "message": "success",
            //         "data": [
            //             {
            //                 "orderId": "1208864446987255809",
            //                 "asset": "USDC",
            //                 "amount": "200",
            //                 "status": "SUCCESS",
            //                 "txId": "0xd059a82a55ffc737722bd23c1ef3db2884ce8525b72ff0b3c038b430ce0c8ca5",
            //                 "network": "ETH",
            //                 "address": "0x8346b46f6aa9843c09f79f1c170a37aca83c8fcd",
            //                 "addressTag": null,
            //                 "finishTime": 1766145475000,
            //                 "createTime": 1766145344000
            //             }
            //         ],
            //         "success": true
            //     }
            //
            response = await this.privateGetV1SpotDepositRecords(this.extend(request, parameters));
        } else
        {
            //
            // todo check after withdrawal
            //
            response = await this.privateGetV1SpotWithdrawRecords(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        object transactionParams = new Dictionary<string, object>() {
            { "type", type },
        };
        parameters = this.extend(parameters, transactionParams);
        return this.parseTransactions(data, currency, since, limit, parameters);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //     {
        //         "orderId": "1208864446987255809",
        //         "asset": "USDC",
        //         "amount": "200",
        //         "status": "SUCCESS",
        //         "txId": "0xd059a82a55ffc737722bd23c1ef3db2884ce8525b72ff0b3c038b430ce0c8ca5",
        //         "network": "ETH",
        //         "address": "0x8346b46f6aa9843c09f79f1c170a37aca83c8fcd",
        //         "addressTag": null,
        //         "finishTime": 1766145475000,
        //         "createTime": 1766145344000
        //     }
        //
        object currencyId = this.safeString(transaction, "asset");
        object code = this.safeCurrencyCode(currencyId, currency);
        object rawStatus = this.safeStringLower(transaction, "status");
        object timestamp = this.safeInteger(transaction, "createTime");
        object fee = null;
        object feeCost = this.safeNumber(transaction, "fee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", null },
            };
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString(transaction, "orderId") },
            { "txid", this.safeString(transaction, "txId") },
            { "type", null },
            { "currency", code },
            { "network", this.networkIdToCode(this.safeString(transaction, "network")) },
            { "amount", this.safeNumber(transaction, "amount") },
            { "status", this.parseTransactionStatus(rawStatus) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "address", this.safeString(transaction, "address") },
            { "addressFrom", null },
            { "addressTo", null },
            { "tag", this.safeString(transaction, "addressTag") },
            { "tagFrom", null },
            { "tagTo", null },
            { "updated", this.safeInteger(transaction, "finishTime") },
            { "comment", null },
            { "fee", fee },
            { "internal", false },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "success", "ok" },
            { "wait", "pending" },
            { "failed", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = getValue(getValue(this.urls, "api"), api);
        object endpoint = add("/", path);
        object query = "";
        object sortedParams = this.keysort(parameters);
        if (isTrue(isEqual(method, "GET")))
        {
            query = this.urlencode(sortedParams);
            if (isTrue(!isEqual(((string)query).Length, 0)))
            {
                endpoint = add(endpoint, add("?", query));
            }
        }
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object timestamp = ((object)this.milliseconds()).ToString();
            if (isTrue(isEqual(method, "GET")))
            {
                object payload = add(add(this.apiKey, timestamp), query);
                object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha256, "hex");
                headers = new Dictionary<string, object>() {
                    { "X-API-KEY", this.apiKey },
                    { "X-API-TIMESTAMP", timestamp },
                    { "X-API-SIGNATURE", signature },
                };
            } else
            {
                body = this.json(sortedParams);
                object payload = add(add(this.apiKey, timestamp), body);
                object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha256, "hex");
                headers = new Dictionary<string, object>() {
                    { "Content-Type", "application/json" },
                    { "X-API-KEY", this.apiKey },
                    { "X-API-TIMESTAMP", timestamp },
                    { "X-API-SIGNATURE", signature },
                };
            }
        }
        url = add(url, endpoint);
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        //
        //     {
        //         "code": 101107,
        //         "message": "Requires transaction permissions"
        //     }
        //
        object code = this.safeString(response, "code");
        object message = this.safeString(response, "message");
        if (isTrue(!isEqual(code, "200")))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
