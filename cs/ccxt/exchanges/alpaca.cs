namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class alpaca : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "alpaca" },
            { "name", "Alpaca" },
            { "countries", new List<object>() {"US"} },
            { "rateLimit", 333 },
            { "hostname", "alpaca.markets" },
            { "pro", true },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/e9476df8-a450-4c3e-ab9a-1a7794219e1b" },
                { "www", "https://alpaca.markets" },
                { "api", new Dictionary<string, object>() {
                    { "broker", "https://broker-api.{hostname}" },
                    { "trader", "https://api.{hostname}" },
                    { "market", "https://data.{hostname}" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "broker", "https://broker-api.sandbox.{hostname}" },
                    { "trader", "https://paper-api.{hostname}" },
                    { "market", "https://data.{hostname}" },
                } },
                { "doc", "https://alpaca.markets/docs/" },
                { "fees", "https://docs.alpaca.markets/docs/crypto-fees" },
            } },
            { "has", new Dictionary<string, object>() {
                { "CORS", false },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createMarketBuyOrder", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", true },
                { "createOrder", true },
                { "createStopOrder", true },
                { "createTriggerOrder", true },
                { "editOrder", true },
                { "fetchBalance", true },
                { "fetchBidsAsks", false },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", false },
                { "fetchDepositAddress", true },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchL1OrderBook", true },
                { "fetchL2OrderBook", false },
                { "fetchMarkets", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrder", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchPosition", false },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsForSymbol", false },
                { "fetchPositionsHistory", false },
                { "fetchPositionsRisk", false },
                { "fetchStatus", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTransactionFees", false },
                { "fetchTransactions", false },
                { "fetchTransfers", false },
                { "fetchWithdrawals", true },
                { "sandbox", true },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "broker", new Dictionary<string, object>() {} },
                { "trader", new Dictionary<string, object>() {
                    { "private", new Dictionary<string, object>() {
                        { "get", new List<object>() {"v2/account", "v2/orders", "v2/orders/{order_id}", "v2/positions", "v2/positions/{symbol_or_asset_id}", "v2/account/portfolio/history", "v2/watchlists", "v2/watchlists/{watchlist_id}", "v2/watchlists:by_name", "v2/account/configurations", "v2/account/activities", "v2/account/activities/{activity_type}", "v2/calendar", "v2/clock", "v2/assets", "v2/assets/{symbol_or_asset_id}", "v2/corporate_actions/announcements/{id}", "v2/corporate_actions/announcements", "v2/wallets", "v2/wallets/transfers"} },
                        { "post", new List<object>() {"v2/orders", "v2/watchlists", "v2/watchlists/{watchlist_id}", "v2/watchlists:by_name", "v2/wallets/transfers"} },
                        { "put", new List<object>() {"v2/orders/{order_id}", "v2/watchlists/{watchlist_id}", "v2/watchlists:by_name"} },
                        { "patch", new List<object>() {"v2/orders/{order_id}", "v2/account/configurations"} },
                        { "delete", new List<object>() {"v2/orders", "v2/orders/{order_id}", "v2/positions", "v2/positions/{symbol_or_asset_id}", "v2/watchlists/{watchlist_id}", "v2/watchlists:by_name", "v2/watchlists/{watchlist_id}/{symbol}"} },
                    } },
                } },
                { "market", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new List<object>() {"v1beta3/crypto/{loc}/bars", "v1beta3/crypto/{loc}/latest/bars", "v1beta3/crypto/{loc}/latest/orderbooks", "v1beta3/crypto/{loc}/latest/quotes", "v1beta3/crypto/{loc}/latest/trades", "v1beta3/crypto/{loc}/quotes", "v1beta3/crypto/{loc}/snapshots", "v1beta3/crypto/{loc}/trades"} },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new List<object>() {"v1beta1/corporate-actions", "v1beta1/forex/latest/rates", "v1beta1/forex/rates", "v1beta1/logos/{symbol}", "v1beta1/news", "v1beta1/screener/stocks/most-actives", "v1beta1/screener/{market_type}/movers", "v2/stocks/auctions", "v2/stocks/bars", "v2/stocks/bars/latest", "v2/stocks/meta/conditions/{ticktype}", "v2/stocks/meta/exchanges", "v2/stocks/quotes", "v2/stocks/quotes/latest", "v2/stocks/snapshots", "v2/stocks/trades", "v2/stocks/trades/latest", "v2/stocks/{symbol}/auctions", "v2/stocks/{symbol}/bars", "v2/stocks/{symbol}/bars/latest", "v2/stocks/{symbol}/quotes", "v2/stocks/{symbol}/quotes/latest", "v2/stocks/{symbol}/snapshot", "v2/stocks/{symbol}/trades", "v2/stocks/{symbol}/trades/latest"} },
                    } },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1min" },
                { "3m", "3min" },
                { "5m", "5min" },
                { "15m", "15min" },
                { "30m", "30min" },
                { "1h", "1H" },
                { "2h", "2H" },
                { "4h", "4H" },
                { "6h", "6H" },
                { "8h", "8H" },
                { "12h", "12H" },
                { "1d", "1D" },
                { "3d", "3D" },
                { "1w", "1W" },
                { "1M", "1M" },
            } },
            { "precisionMode", TICK_SIZE },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.0015") },
                    { "taker", this.parseNumber("0.0025") },
                    { "tiers", new Dictionary<string, object>() {
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0025")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.0022")}, new List<object> {this.parseNumber("500000"), this.parseNumber("0.0020")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.0018")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0.0015")}, new List<object> {this.parseNumber("25000000"), this.parseNumber("0.0013")}, new List<object> {this.parseNumber("50000000"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("100000000"), this.parseNumber("0.001")}} },
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0015")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("500000"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("25000000"), this.parseNumber("0.0002")}, new List<object> {this.parseNumber("50000000"), this.parseNumber("0.0002")}, new List<object> {this.parseNumber("100000000"), this.parseNumber("0.00")}} },
                    } },
                } },
            } },
            { "headers", new Dictionary<string, object>() {
                { "APCA-PARTNER-ID", "ccxt" },
            } },
            { "options", new Dictionary<string, object>() {
                { "defaultExchange", "CBSE" },
                { "exchanges", new List<object>() {"CBSE", "FTX", "GNSS", "ERSX"} },
                { "defaultTimeInForce", "gtc" },
                { "clientOrderId", "ccxt_{id}" },
            } },
            { "features", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "sandbox", true },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", true },
                        { "triggerPriceType", null },
                        { "triggerDirection", false },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", new Dictionary<string, object>() {
                            { "triggerPriceType", new Dictionary<string, object>() {
                                { "last", true },
                                { "mark", true },
                                { "index", true },
                            } },
                            { "price", true },
                        } },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "trailing", true },
                        { "leverage", false },
                        { "marketBuyRequiresPrice", false },
                        { "marketBuyByCost", false },
                        { "selfTradePrevention", false },
                        { "iceberg", false },
                    } },
                    { "createOrders", null },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "daysBack", 100000 },
                        { "untilDays", 100000 },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 500 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 500 },
                        { "daysBack", 100000 },
                        { "untilDays", 100000 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 500 },
                        { "daysBack", 100000 },
                        { "daysBackCanceled", null },
                        { "untilDays", 100000 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 1000 },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "forbidden.", typeof(PermissionDenied) },
                    { "40410000", typeof(InvalidOrder) },
                    { "40010001", typeof(BadRequest) },
                    { "40110000", typeof(PermissionDenied) },
                    { "40310000", typeof(InsufficientFunds) },
                    { "42910000", typeof(RateLimitExceeded) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Invalid format for parameter", typeof(BadRequest) },
                    { "Invalid symbol", typeof(BadSymbol) },
                } },
            } },
        });
    }

    /**
     * @method
     * @name alpaca#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.traderPrivateGetV2Clock(parameters);
        //
        //     {
        //         timestamp: '2023-11-22T08:07:57.654738097-05:00',
        //         is_open: false,
        //         next_open: '2023-11-22T09:30:00-05:00',
        //         next_close: '2023-11-22T16:00:00-05:00'
        //     }
        //
        object timestamp = this.safeString(response, "timestamp");
        object localTime = slice(timestamp, 0, 23);
        object jetlagStrStart = subtract(((string)timestamp).Length, 6);
        object jetlagStrEnd = subtract(((string)timestamp).Length, 3);
        object jetlag = slice(timestamp, jetlagStrStart, jetlagStrEnd);
        object iso = subtract(this.parse8601(localTime), multiply(multiply(this.parseToNumeric(jetlag), 3600), 1000));
        return iso;
    }

    /**
     * @method
     * @name alpaca#fetchMarkets
     * @description retrieves data on all markets for alpaca
     * @see https://docs.alpaca.markets/reference/get-v2-assets
     * @param {object} [params] extra parameters specific to the exchange api endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "asset_class", "crypto" },
            { "status", "active" },
        };
        object assets = await this.traderPrivateGetV2Assets(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "id": "c150e086-1e75-44e6-9c2c-093bb1e93139",
        //             "class": "crypto",
        //             "exchange": "CRYPTO",
        //             "symbol": "BTC/USDT",
        //             "name": "Bitcoin / USD Tether",
        //             "status": "active",
        //             "tradable": true,
        //             "marginable": false,
        //             "maintenance_margin_requirement": 100,
        //             "shortable": false,
        //             "easy_to_borrow": false,
        //             "fractionable": true,
        //             "attributes": [],
        //             "min_order_size": "0.000026873",
        //             "min_trade_increment": "0.000000001",
        //             "price_increment": "1"
        //         }
        //     ]
        //
        return this.parseMarkets(assets);
    }

    public override object parseMarket(object asset)
    {
        //
        //     {
        //         "id": "c150e086-1e75-44e6-9c2c-093bb1e93139",
        //         "class": "crypto",
        //         "exchange": "CRYPTO",
        //         "symbol": "BTC/USDT",
        //         "name": "Bitcoin / USD Tether",
        //         "status": "active",
        //         "tradable": true,
        //         "marginable": false,
        //         "maintenance_margin_requirement": 101,
        //         "shortable": false,
        //         "easy_to_borrow": false,
        //         "fractionable": true,
        //         "attributes": [],
        //         "min_order_size": "0.000026873",
        //         "min_trade_increment": "0.000000001",
        //         "price_increment": "1"
        //     }
        //
        object marketId = this.safeString(asset, "symbol");
        object parts = ((string)marketId).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
        object assetClass = this.safeString(asset, "class");
        object baseId = this.safeString(parts, 0);
        object quoteId = this.safeString(parts, 1);
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        // Us equity markets do not include quote in symbol.
        // We can safely coerce us_equity quote to USD
        if (isTrue(isTrue(isEqual(quote, null)) && isTrue(isEqual(assetClass, "us_equity"))))
        {
            quote = "USD";
        }
        object symbol = add(add(bs, "/"), quote);
        object status = this.safeString(asset, "status");
        object active = (isEqual(status, "active"));
        object minAmount = this.safeNumber(asset, "min_order_size");
        object amount = this.safeNumber(asset, "min_trade_increment");
        object price = this.safeNumber(asset, "price_increment");
        return new Dictionary<string, object>() {
            { "id", marketId },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", null },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", null },
            { "type", "spot" },
            { "spot", true },
            { "margin", null },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "active", active },
            { "contract", false },
            { "linear", null },
            { "inverse", null },
            { "contractSize", null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", amount },
                { "price", price },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", minAmount },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", asset },
        };
    }

    /**
     * @method
     * @name alpaca#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://docs.alpaca.markets/reference/cryptotrades
     * @see https://docs.alpaca.markets/reference/cryptolatesttrades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.loc] crypto location, default: us
     * @param {string} [params.method] method, default: marketPublicGetV1beta3CryptoLocTrades
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = getValue(market, "id");
        object loc = this.safeString(parameters, "loc", "us");
        object method = this.safeString(parameters, "method", "marketPublicGetV1beta3CryptoLocTrades");
        object request = new Dictionary<string, object>() {
            { "symbols", marketId },
            { "loc", loc },
        };
        parameters = this.omit(parameters, new List<object>() {"loc", "method"});
        object symbolTrades = null;
        if (isTrue(isEqual(method, "marketPublicGetV1beta3CryptoLocTrades")))
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["start"] = this.iso8601(since);
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            object response = await this.marketPublicGetV1beta3CryptoLocTrades(this.extend(request, parameters));
            //
            //    {
            //        "next_page_token": null,
            //        "trades": {
            //            "BTC/USD": [
            //                {
            //                    "i": 36440704,
            //                    "p": 22625,
            //                    "s": 0.0001,
            //                    "t": "2022-07-21T11:47:31.073391Z",
            //                    "tks": "B"
            //                }
            //            ]
            //        }
            //    }
            //
            object trades = this.safeDict(response, "trades", new Dictionary<string, object>() {});
            symbolTrades = this.safeList(trades, marketId, new List<object>() {});
        } else if (isTrue(isEqual(method, "marketPublicGetV1beta3CryptoLocLatestTrades")))
        {
            object response = await this.marketPublicGetV1beta3CryptoLocLatestTrades(this.extend(request, parameters));
            //
            //    {
            //       "trades": {
            //            "BTC/USD": {
            //                "i": 36440704,
            //                "p": 22625,
            //                "s": 0.0001,
            //                "t": "2022-07-21T11:47:31.073391Z",
            //                "tks": "B"
            //            }
            //        }
            //    }
            //
            object trades = this.safeDict(response, "trades", new Dictionary<string, object>() {});
            symbolTrades = this.safeDict(trades, marketId, new Dictionary<string, object>() {});
            symbolTrades = new List<object>() {symbolTrades};
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchTrades() does not support "), method), ", marketPublicGetV1beta3CryptoLocTrades and marketPublicGetV1beta3CryptoLocLatestTrades are supported")) ;
        }
        return this.parseTrades(symbolTrades, market, since, limit);
    }

    /**
     * @method
     * @name alpaca#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://docs.alpaca.markets/reference/cryptolatestorderbooks
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.loc] crypto location, default: us
     * @returns {object} A dictionary of [order book structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object id = getValue(market, "id");
        object loc = this.safeString(parameters, "loc", "us");
        object request = new Dictionary<string, object>() {
            { "symbols", id },
            { "loc", loc },
        };
        object response = await this.marketPublicGetV1beta3CryptoLocLatestOrderbooks(this.extend(request, parameters));
        //
        //   {
        //       "orderbooks":{
        //          "BTC/USD":{
        //             "a":[
        //                {
        //                   "p":22208,
        //                   "s":0.0051
        //                },
        //                {
        //                   "p":22209,
        //                   "s":0.1123
        //                },
        //                {
        //                   "p":22210,
        //                   "s":0.2465
        //                }
        //             ],
        //             "b":[
        //                {
        //                   "p":22203,
        //                   "s":0.395
        //                },
        //                {
        //                   "p":22202,
        //                   "s":0.2465
        //                },
        //                {
        //                   "p":22201,
        //                   "s":0.6455
        //                }
        //             ],
        //             "t":"2022-07-19T13:41:55.13210112Z"
        //          }
        //       }
        //   }
        //
        object orderbooks = this.safeDict(response, "orderbooks", new Dictionary<string, object>() {});
        object rawOrderbook = this.safeDict(orderbooks, id, new Dictionary<string, object>() {});
        object timestamp = this.parse8601(this.safeString(rawOrderbook, "t"));
        return this.parseOrderBook(rawOrderbook, getValue(market, "symbol"), timestamp, "b", "a", "p", "s");
    }

    /**
     * @method
     * @name alpaca#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://docs.alpaca.markets/reference/cryptobars
     * @see https://docs.alpaca.markets/reference/cryptolatestbars
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the alpha api endpoint
     * @param {string} [params.loc] crypto location, default: us
     * @param {string} [params.method] method, default: marketPublicGetV1beta3CryptoLocBars
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = getValue(market, "id");
        object loc = this.safeString(parameters, "loc", "us");
        object method = this.safeString(parameters, "method", "marketPublicGetV1beta3CryptoLocBars");
        object request = new Dictionary<string, object>() {
            { "symbols", marketId },
            { "loc", loc },
        };
        parameters = this.omit(parameters, new List<object>() {"loc", "method"});
        object ohlcvs = null;
        if (isTrue(isEqual(method, "marketPublicGetV1beta3CryptoLocBars")))
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["start"] = this.yyyymmdd(since);
            }
            ((IDictionary<string,object>)request)["timeframe"] = this.safeString(this.timeframes, timeframe, timeframe);
            object response = await this.marketPublicGetV1beta3CryptoLocBars(this.extend(request, parameters));
            //
            //    {
            //        "bars": {
            //           "BTC/USD": [
            //              {
            //                 "c": 22887,
            //                 "h": 22888,
            //                 "l": 22873,
            //                 "n": 11,
            //                 "o": 22883,
            //                 "t": "2022-07-21T05:00:00Z",
            //                 "v": 1.1138,
            //                 "vw": 22883.0155324116
            //              },
            //              {
            //                 "c": 22895,
            //                 "h": 22895,
            //                 "l": 22884,
            //                 "n": 6,
            //                 "o": 22884,
            //                 "t": "2022-07-21T05:01:00Z",
            //                 "v": 0.001,
            //                 "vw": 22889.5
            //              }
            //           ]
            //        },
            //        "next_page_token": "QlRDL1VTRHxNfDIwMjItMDctMjFUMDU6MDE6MDAuMDAwMDAwMDAwWg=="
            //     }
            //
            object bars = this.safeDict(response, "bars", new Dictionary<string, object>() {});
            ohlcvs = this.safeList(bars, marketId, new List<object>() {});
        } else if (isTrue(isEqual(method, "marketPublicGetV1beta3CryptoLocLatestBars")))
        {
            object response = await this.marketPublicGetV1beta3CryptoLocLatestBars(this.extend(request, parameters));
            //
            //    {
            //        "bars": {
            //           "BTC/USD": {
            //              "c": 22887,
            //              "h": 22888,
            //              "l": 22873,
            //              "n": 11,
            //              "o": 22883,
            //              "t": "2022-07-21T05:00:00Z",
            //              "v": 1.1138,
            //              "vw": 22883.0155324116
            //           }
            //        }
            //     }
            //
            object bars = this.safeDict(response, "bars", new Dictionary<string, object>() {});
            ohlcvs = this.safeDict(bars, marketId, new Dictionary<string, object>() {});
            ohlcvs = new List<object>() {ohlcvs};
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOHLCV() does not support "), method), ", marketPublicGetV1beta3CryptoLocBars and marketPublicGetV1beta3CryptoLocLatestBars are supported")) ;
        }
        return this.parseOHLCVs(ohlcvs, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //        "c":22895,
        //        "h":22895,
        //        "l":22884,
        //        "n":6,
        //        "o":22884,
        //        "t":"2022-07-21T05:01:00Z",
        //        "v":0.001,
        //        "vw":22889.5
        //     }
        //
        object datetime = this.safeString(ohlcv, "t");
        object timestamp = this.parse8601(datetime);
        return new List<object>() {timestamp, this.safeNumber(ohlcv, "o"), this.safeNumber(ohlcv, "h"), this.safeNumber(ohlcv, "l"), this.safeNumber(ohlcv, "c"), this.safeNumber(ohlcv, "v")};
    }

    /**
     * @method
     * @name alpaca#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://docs.alpaca.markets/reference/cryptosnapshots-1
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.loc] crypto location, default: us
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbol = this.symbol(symbol);
        object tickers = await this.fetchTickers(new List<object>() {symbol}, parameters);
        return this.safeDict(tickers, symbol);
    }

    /**
     * @method
     * @name alpaca#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://docs.alpaca.markets/reference/cryptosnapshots-1
     * @param {string[]} symbols unified symbols of the markets to fetch tickers for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.loc] crypto location, default: us
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbols, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchTickers() requires a symbols argument")) ;
        }
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object loc = this.safeString(parameters, "loc", "us");
        object ids = this.marketIds(symbols);
        object request = new Dictionary<string, object>() {
            { "symbols", String.Join(",", ((IList<object>)ids).ToArray()) },
            { "loc", loc },
        };
        parameters = this.omit(parameters, "loc");
        object response = await this.marketPublicGetV1beta3CryptoLocSnapshots(this.extend(request, parameters));
        //
        //     {
        //         "snapshots": {
        //             "BTC/USD": {
        //                 "dailyBar": {
        //                     "c": 69403.554,
        //                     "h": 69609.6515,
        //                     "l": 69013.26,
        //                     "n": 9,
        //                     "o": 69536.7,
        //                     "t": "2024-11-01T05:00:00Z",
        //                     "v": 0.210809181,
        //                     "vw": 69327.655393908
        //                 },
        //                 "latestQuote": {
        //                     "ap": 69424.19,
        //                     "as": 0.68149,
        //                     "bp": 69366.086,
        //                     "bs": 0.68312,
        //                     "t": "2024-11-01T08:31:41.880246926Z"
        //                 },
        //                 "latestTrade": {
        //                     "i": 5272941104897543146,
        //                     "p": 69416.9,
        //                     "s": 0.014017324,
        //                     "t": "2024-11-01T08:14:28.245088803Z",
        //                     "tks": "B"
        //                 },
        //                 "minuteBar": {
        //                     "c": 69403.554,
        //                     "h": 69403.554,
        //                     "l": 69399.125,
        //                     "n": 0,
        //                     "o": 69399.125,
        //                     "t": "2024-11-01T08:30:00Z",
        //                     "v": 0,
        //                     "vw": 0
        //                 },
        //                 "prevDailyBar": {
        //                     "c": 69515.1415,
        //                     "h": 72668.837,
        //                     "l": 68796.85,
        //                     "n": 129,
        //                     "o": 72258.9,
        //                     "t": "2024-10-31T05:00:00Z",
        //                     "v": 2.217683307,
        //                     "vw": 70782.6811608144
        //                 }
        //             },
        //         }
        //     }
        //
        object results = new List<object>() {};
        object snapshots = this.safeDict(response, "snapshots", new Dictionary<string, object>() {});
        object marketIds = new List<object>(((IDictionary<string,object>)snapshots).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = getValue(marketIds, i);
            object market = this.safeMarket(marketId);
            object entry = this.safeDict(snapshots, marketId);
            object dailyBar = this.safeDict(entry, "dailyBar", new Dictionary<string, object>() {});
            object prevDailyBar = this.safeDict(entry, "prevDailyBar", new Dictionary<string, object>() {});
            object latestQuote = this.safeDict(entry, "latestQuote", new Dictionary<string, object>() {});
            object latestTrade = this.safeDict(entry, "latestTrade", new Dictionary<string, object>() {});
            object datetime = this.safeString(latestQuote, "t");
            object ticker = this.safeTicker(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", getValue(market, "symbol") },
                { "timestamp", this.parse8601(datetime) },
                { "datetime", datetime },
                { "high", this.safeString(dailyBar, "h") },
                { "low", this.safeString(dailyBar, "l") },
                { "bid", this.safeString(latestQuote, "bp") },
                { "bidVolume", this.safeString(latestQuote, "bs") },
                { "ask", this.safeString(latestQuote, "ap") },
                { "askVolume", this.safeString(latestQuote, "as") },
                { "vwap", this.safeString(dailyBar, "vw") },
                { "open", this.safeString(dailyBar, "o") },
                { "close", this.safeString(dailyBar, "c") },
                { "last", this.safeString(latestTrade, "p") },
                { "previousClose", this.safeString(prevDailyBar, "c") },
                { "change", null },
                { "percentage", null },
                { "average", null },
                { "baseVolume", this.safeString(dailyBar, "v") },
                { "quoteVolume", this.safeString(dailyBar, "n") },
            }, market);
            ((IList<object>)results).Add(ticker);
        }
        return this.filterByArray(results, "symbol", symbols);
    }

    public virtual object generateClientOrderId(object parameters)
    {
        object clientOrderIdprefix = this.safeString(this.options, "clientOrderId");
        object uuid = this.uuid();
        object parts = ((string)uuid).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
        object random_id = String.Join("", ((IList<object>)parts).ToArray());
        object defaultClientId = this.implodeParams(clientOrderIdprefix, new Dictionary<string, object>() {
            { "id", random_id },
        });
        object clientOrderId = this.safeString(parameters, "clientOrderId", defaultClientId);
        return clientOrderId;
    }

    /**
     * @method
     * @name alpaca#createMarketOrderWithCost
     * @description create a market order by providing the symbol, side and cost
     * @see https://docs.alpaca.markets/reference/postorder
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} side 'buy' or 'sell'
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketOrderWithCost(object symbol, object side, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object req = new Dictionary<string, object>() {
            { "cost", cost },
        };
        return await this.createOrder(symbol, "market", side, 0, null, this.extend(req, parameters));
    }

    /**
     * @method
     * @name alpaca#createMarketBuyOrderWithCost
     * @description create a market buy order by providing the symbol and cost
     * @see https://docs.alpaca.markets/reference/postorder
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object req = new Dictionary<string, object>() {
            { "cost", cost },
        };
        return await this.createOrder(symbol, "market", "buy", 0, null, this.extend(req, parameters));
    }

    /**
     * @method
     * @name alpaca#createMarketSellOrderWithCost
     * @description create a market sell order by providing the symbol and cost
     * @see https://docs.alpaca.markets/reference/postorder
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketSellOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object req = new Dictionary<string, object>() {
            { "cost", cost },
        };
        return await this.createOrder(symbol, "market", "sell", cost, null, this.extend(req, parameters));
    }

    /**
     * @method
     * @name alpaca#createOrder
     * @description create a trade order
     * @see https://docs.alpaca.markets/reference/postorder
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market', 'limit' or 'stop_limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
     * @param {float} [params.cost] *market orders only* the cost of the order in units of the quote currency
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object id = getValue(market, "id");
        object request = new Dictionary<string, object>() {
            { "symbol", id },
            { "side", side },
            { "type", type },
        };
        object triggerPrice = this.safeStringN(parameters, new List<object>() {"triggerPrice", "stop_price"});
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            object newType = null;
            if (isTrue(isGreaterThanOrEqual(getIndexOf(type, "limit"), 0)))
            {
                newType = "stop_limit";
            } else
            {
                throw new NotSupported ((string)add(add(add(this.id, " createOrder() does not support stop orders for "), type), " orders, only stop_limit orders are supported")) ;
            }
            ((IDictionary<string,object>)request)["stop_price"] = this.priceToPrecision(symbol, triggerPrice);
            ((IDictionary<string,object>)request)["type"] = newType;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(type, "limit"), 0)))
        {
            ((IDictionary<string,object>)request)["limit_price"] = this.priceToPrecision(symbol, price);
        }
        object cost = this.safeString(parameters, "cost");
        if (isTrue(!isEqual(cost, null)))
        {
            parameters = this.omit(parameters, "cost");
            ((IDictionary<string,object>)request)["notional"] = this.costToPrecision(symbol, cost);
        } else
        {
            ((IDictionary<string,object>)request)["qty"] = this.amountToPrecision(symbol, amount);
        }
        object defaultTIF = this.safeString(this.options, "defaultTimeInForce");
        ((IDictionary<string,object>)request)["time_in_force"] = this.safeString(parameters, "timeInForce", defaultTIF);
        parameters = this.omit(parameters, new List<object>() {"timeInForce", "triggerPrice"});
        ((IDictionary<string,object>)request)["client_order_id"] = this.generateClientOrderId(parameters);
        parameters = this.omit(parameters, new List<object>() {"clientOrderId"});
        object order = await this.traderPrivatePostV2Orders(this.extend(request, parameters));
        //
        //   {
        //      "id": "61e69015-8549-4bfd-b9c3-01e75843f47d",
        //      "client_order_id": "eb9e2aaa-f71a-4f51-b5b4-52a6c565dad4",
        //      "created_at": "2021-03-16T18:38:01.942282Z",
        //      "updated_at": "2021-03-16T18:38:01.942282Z",
        //      "submitted_at": "2021-03-16T18:38:01.937734Z",
        //      "filled_at": null,
        //      "expired_at": null,
        //      "canceled_at": null,
        //      "failed_at": null,
        //      "replaced_at": null,
        //      "replaced_by": null,
        //      "replaces": null,
        //      "asset_id": "b0b6dd9d-8b9b-48a9-ba46-b9d54906e415",
        //      "symbol": "AAPL",
        //      "asset_class": "us_equity",
        //      "notional": "500",
        //      "qty": null,
        //      "filled_qty": "0",
        //      "filled_avg_price": null,
        //      "order_class": "",
        //      "order_type": "market",
        //      "type": "market",
        //      "side": "buy",
        //      "time_in_force": "day",
        //      "limit_price": null,
        //      "stop_price": null,
        //      "status": "accepted",
        //      "extended_hours": false,
        //      "legs": null,
        //      "trail_percent": null,
        //      "trail_price": null,
        //      "hwm": null
        //   }
        //
        return this.parseOrder(order, market);
    }

    /**
     * @method
     * @name alpaca#cancelOrder
     * @description cancels an open order
     * @see https://docs.alpaca.markets/reference/deleteorderbyorderid
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        object response = await this.traderPrivateDeleteV2OrdersOrderId(this.extend(request, parameters));
        //
        //   {
        //       "code": 40410000,
        //       "message": "order is not found."
        //   }
        //
        return this.parseOrder(response);
    }

    /**
     * @method
     * @name alpaca#cancelAllOrders
     * @description cancel all open orders in a market
     * @see https://docs.alpaca.markets/reference/deleteallorders
     * @param {string} symbol alpaca cancelAllOrders cannot setting symbol, it will cancel all open orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.traderPrivateDeleteV2Orders(parameters);
        if (isTrue(((response is IList<object>) || (response.GetType().IsGenericType && response.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            return this.parseOrders(response, null);
        } else
        {
            return new List<object> {this.safeOrder(new Dictionary<string, object>() {
    { "info", response },
})};
        }
    }

    /**
     * @method
     * @name alpaca#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://docs.alpaca.markets/reference/getorderbyorderid
     * @param {string} id the order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        object order = await this.traderPrivateGetV2OrdersOrderId(this.extend(request, parameters));
        object marketId = this.safeString(order, "symbol");
        object market = this.safeMarket(marketId);
        return this.parseOrder(order, market);
    }

    /**
     * @method
     * @name alpaca#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @see https://docs.alpaca.markets/reference/getallorders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "status", "all" },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbols"] = getValue(market, "id");
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, "until");
            ((IDictionary<string,object>)request)["endTime"] = this.iso8601(until);
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["after"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.traderPrivateGetV2Orders(this.extend(request, parameters));
        //
        //     [
        //         {
        //           "id": "cbaf12d7-69b8-49c0-a31b-b46af35c755c",
        //           "client_order_id": "ccxt_b36156ae6fd44d098ac9c179bab33efd",
        //           "created_at": "2023-11-17T04:21:42.234579Z",
        //           "updated_at": "2023-11-17T04:22:34.442765Z",
        //           "submitted_at": "2023-11-17T04:21:42.233357Z",
        //           "filled_at": null,
        //           "expired_at": null,
        //           "canceled_at": "2023-11-17T04:22:34.399019Z",
        //           "failed_at": null,
        //           "replaced_at": null,
        //           "replaced_by": null,
        //           "replaces": null,
        //           "asset_id": "77c6f47f-0939-4b23-b41e-47b4469c4bc8",
        //           "symbol": "LTC/USDT",
        //           "asset_class": "crypto",
        //           "notional": null,
        //           "qty": "0.001",
        //           "filled_qty": "0",
        //           "filled_avg_price": null,
        //           "order_class": "",
        //           "order_type": "limit",
        //           "type": "limit",
        //           "side": "sell",
        //           "time_in_force": "gtc",
        //           "limit_price": "1000",
        //           "stop_price": null,
        //           "status": "canceled",
        //           "extended_hours": false,
        //           "legs": null,
        //           "trail_percent": null,
        //           "trail_price": null,
        //           "hwm": null,
        //           "subtag": null,
        //           "source": "access_key"
        //         }
        //     ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    /**
     * @method
     * @name alpaca#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://docs.alpaca.markets/reference/getallorders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "status", "open" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    /**
     * @method
     * @name alpaca#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://docs.alpaca.markets/reference/getallorders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "status", "closed" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    /**
     * @method
     * @name alpaca#editOrder
     * @description edit a trade order
     * @see https://docs.alpaca.markets/reference/patchorderbyorderid-1
     * @param {string} id order id
     * @param {string} [symbol] unified symbol of the market to create an order in
     * @param {string} [type] 'market', 'limit' or 'stop_limit'
     * @param {string} [side] 'buy' or 'sell'
     * @param {float} [amount] how much of the currency you want to trade in units of the base currency
     * @param {float} [price] the price for the order, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.triggerPrice] the price to trigger a stop order
     * @param {string} [params.timeInForce] for crypto trading either 'gtc' or 'ioc' can be used
     * @param {string} [params.clientOrderId] a unique identifier for the order, automatically generated if not sent
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["qty"] = this.amountToPrecision(symbol, amount);
        }
        object triggerPrice = this.safeStringN(parameters, new List<object>() {"triggerPrice", "stop_price"});
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((IDictionary<string,object>)request)["stop_price"] = this.priceToPrecision(symbol, triggerPrice);
            parameters = this.omit(parameters, "triggerPrice");
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["limit_price"] = this.priceToPrecision(symbol, price);
        }
        object timeInForce = null;
        var timeInForceparametersVariable = this.handleOptionAndParams2(parameters, "editOrder", "timeInForce", "defaultTimeInForce");
        timeInForce = ((IList<object>)timeInForceparametersVariable)[0];
        parameters = ((IList<object>)timeInForceparametersVariable)[1];
        if (isTrue(!isEqual(timeInForce, null)))
        {
            ((IDictionary<string,object>)request)["time_in_force"] = timeInForce;
        }
        ((IDictionary<string,object>)request)["client_order_id"] = this.generateClientOrderId(parameters);
        parameters = this.omit(parameters, new List<object>() {"clientOrderId"});
        object response = await this.traderPrivatePatchV2OrdersOrderId(this.extend(request, parameters));
        return this.parseOrder(response, market);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        //    {
        //        "id":"6ecfcc34-4bed-4b53-83ba-c564aa832a81",
        //        "client_order_id":"ccxt_1c6ceab0b5e84727b2f1c0394ba17560",
        //        "created_at":"2022-06-14T13:59:30.224037068Z",
        //        "updated_at":"2022-06-14T13:59:30.224037068Z",
        //        "submitted_at":"2022-06-14T13:59:30.221856828Z",
        //        "filled_at":null,
        //        "expired_at":null,
        //        "canceled_at":null,
        //        "failed_at":null,
        //        "replaced_at":null,
        //        "replaced_by":null,
        //        "replaces":null,
        //        "asset_id":"64bbff51-59d6-4b3c-9351-13ad85e3c752",
        //        "symbol":"BTCUSD",
        //        "asset_class":"crypto",
        //        "notional":null,
        //        "qty":"0.01",
        //        "filled_qty":"0",
        //        "filled_avg_price":null,
        //        "order_class":"",
        //        "order_type":"limit",
        //        "type":"limit",
        //        "side":"buy",
        //        "time_in_force":"day",
        //        "limit_price":"14000",
        //        "stop_price":null,
        //        "status":"accepted",
        //        "extended_hours":false,
        //        "legs":null,
        //        "trail_percent":null,
        //        "trail_price":null,
        //        "hwm":null,
        //        "commission":"0.42",
        //        "source":null
        //    }
        //
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object alpacaStatus = this.safeString(order, "status");
        object status = this.parseOrderStatus(alpacaStatus);
        object feeValue = this.safeString(order, "commission");
        object fee = null;
        if (isTrue(!isEqual(feeValue, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeValue },
                { "currency", "USD" },
            };
        }
        object orderType = this.safeString(order, "order_type");
        if (isTrue(!isEqual(orderType, null)))
        {
            if (isTrue(isGreaterThanOrEqual(getIndexOf(orderType, "limit"), 0)))
            {
                // might be limit or stop-limit
                orderType = "limit";
            }
        }
        object datetime = this.safeString(order, "submitted_at");
        object timestamp = this.parse8601(datetime);
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(order, "id") },
            { "clientOrderId", this.safeString(order, "client_order_id") },
            { "timestamp", timestamp },
            { "datetime", datetime },
            { "lastTradeTimeStamp", null },
            { "status", status },
            { "symbol", symbol },
            { "type", orderType },
            { "timeInForce", this.parseTimeInForce(this.safeString(order, "time_in_force")) },
            { "postOnly", null },
            { "side", this.safeString(order, "side") },
            { "price", this.safeNumber(order, "limit_price") },
            { "triggerPrice", this.safeNumber(order, "stop_price") },
            { "cost", null },
            { "average", this.safeNumber(order, "filled_avg_price") },
            { "amount", this.safeNumber(order, "qty") },
            { "filled", this.safeNumber(order, "filled_qty") },
            { "remaining", null },
            { "trades", null },
            { "fee", fee },
            { "info", order },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "pending_new", "open" },
            { "accepted", "open" },
            { "new", "open" },
            { "partially_filled", "open" },
            { "activated", "open" },
            { "filled", "closed" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseTimeInForce(object timeInForce)
    {
        object timeInForces = new Dictionary<string, object>() {
            { "day", "Day" },
        };
        return this.safeString(timeInForces, timeInForce, timeInForce);
    }

    /**
     * @method
     * @name alpaca#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://docs.alpaca.markets/reference/getaccountactivitiesbyactivitytype-1
     * @param {string} [symbol] unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trade structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch trades for
     * @param {string} [params.page_token] page_token - used for paging
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {
            { "activity_type", "FILL" },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, "until");
            ((IDictionary<string,object>)request)["until"] = this.iso8601(until);
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["after"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("until", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.traderPrivateGetV2AccountActivitiesActivityType(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "id": "20221228071929579::ca2aafd0-1270-4b56-b0a9-85423b4a07c8",
        //             "activity_type": "FILL",
        //             "transaction_time": "2022-12-28T12:19:29.579352Z",
        //             "type": "fill",
        //             "price": "67.31",
        //             "qty": "0.07",
        //             "side": "sell",
        //             "symbol": "LTC/USD",
        //             "leaves_qty": "0",
        //             "order_id": "82eebcf7-6e66-4b7e-93f8-be0df0e4f12e",
        //             "cum_qty": "0.07",
        //             "order_status": "filled",
        //             "swap_rate": "1"
        //         },
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades
        //
        //   {
        //       "t":"2022-06-14T05:00:00.027869Z",
        //       "x":"CBSE",
        //       "p":"21942.15",
        //       "s":"0.0001",
        //       "tks":"S",
        //       "i":"355681339"
        //   }
        //
        // fetchMyTrades
        //
        //     {
        //         "id": "20221228071929579::ca2aafd0-1270-4b56-b0a9-85423b4a07c8",
        //         "activity_type": "FILL",
        //         "transaction_time": "2022-12-28T12:19:29.579352Z",
        //         "type": "fill",
        //         "price": "67.31",
        //         "qty": "0.07",
        //         "side": "sell",
        //         "symbol": "LTC/USD",
        //         "leaves_qty": "0",
        //         "order_id": "82eebcf7-6e66-4b7e-93f8-be0df0e4f12e",
        //         "cum_qty": "0.07",
        //         "order_status": "filled",
        //         "swap_rate": "1"
        //     },
        //
        object marketId = this.safeString2(trade, "S", "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object datetime = this.safeString2(trade, "t", "transaction_time");
        object timestamp = this.parse8601(datetime);
        object alpacaSide = this.safeString(trade, "tks");
        object side = this.safeString(trade, "side");
        if (isTrue(isEqual(alpacaSide, "B")))
        {
            side = "buy";
        } else if (isTrue(isEqual(alpacaSide, "S")))
        {
            side = "sell";
        }
        object priceString = this.safeString2(trade, "p", "price");
        object amountString = this.safeString2(trade, "s", "qty");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString2(trade, "i", "id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "order", this.safeString(trade, "order_id") },
            { "type", null },
            { "side", side },
            { "takerOrMaker", "taker" },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "fee", null },
        }, market);
    }

    /**
     * @method
     * @name alpaca#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://docs.alpaca.markets/reference/listcryptofundingwallets
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
        };
        object response = await this.traderPrivateGetV2Wallets(this.extend(request, parameters));
        //
        //     {
        //         "asset_id": "4fa30c85-77b7-4cbc-92dd-7b7513640aad",
        //         "address": "bc1q2fpskfnwem3uq9z8660e4z6pfv7aqfamysk75r",
        //         "created_at": "2024-11-03T07:30:05.609976344Z"
        //     }
        //
        return this.parseDepositAddress(response, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "asset_id": "4fa30c85-77b7-4cbc-92dd-7b7513640aad",
        //         "address": "bc1q2fpskfnwem3uq9z8660e4z6pfv7aqfamysk75r",
        //         "created_at": "2024-11-03T07:30:05.609976344Z"
        //     }
        //
        object parsedCurrency = null;
        if (isTrue(!isEqual(currency, null)))
        {
            parsedCurrency = getValue(currency, "id");
        }
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", parsedCurrency },
            { "network", null },
            { "address", this.safeString(depositAddress, "address") },
            { "tag", null },
        };
    }

    /**
     * @method
     * @name alpaca#withdraw
     * @description make a withdrawal
     * @see https://docs.alpaca.markets/reference/createcryptotransferforaccount
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag a memo for the transaction
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        if (isTrue(tag))
        {
            address = add(add(address, ":"), tag);
        }
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "address", address },
            { "amount", this.numberToString(amount) },
        };
        object response = await this.traderPrivatePostV2WalletsTransfers(this.extend(request, parameters));
        //
        //     {
        //         "id": "e27b70a6-5610-40d7-8468-a516a284b776",
        //         "tx_hash": null,
        //         "direction": "OUTGOING",
        //         "amount": "20",
        //         "usd_value": "19.99856",
        //         "chain": "ETH",
        //         "asset": "USDT",
        //         "from_address": "0x123930E4dCA196E070d39B60c644C8Aae02f23",
        //         "to_address": "0x1232c0925196e4dcf05945f67f690153190fbaab",
        //         "status": "PROCESSING",
        //         "created_at": "2024-11-07T02:39:01.775495Z",
        //         "network_fee": "4",
        //         "fees": "0.1"
        //     }
        //
        return this.parseTransaction(response, currency);
    }

    public async virtual Task<object> fetchTransactionsHelper(object type, object code, object since, object limit, object parameters)
    {
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object response = await this.traderPrivateGetV2WalletsTransfers(parameters);
        //
        //     {
        //         "id": "e27b70a6-5610-40d7-8468-a516a284b776",
        //         "tx_hash": null,
        //         "direction": "OUTGOING",
        //         "amount": "20",
        //         "usd_value": "19.99856",
        //         "chain": "ETH",
        //         "asset": "USDT",
        //         "from_address": "0x123930E4dCA196E070d39B60c644C8Aae02f23",
        //         "to_address": "0x1232c0925196e4dcf05945f67f690153190fbaab",
        //         "status": "PROCESSING",
        //         "created_at": "2024-11-07T02:39:01.775495Z",
        //         "network_fee": "4",
        //         "fees": "0.1"
        //     }
        //
        object results = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object direction = this.safeString(entry, "direction");
            if (isTrue(isEqual(direction, type)))
            {
                ((IList<object>)results).Add(entry);
            } else if (isTrue(isEqual(type, "BOTH")))
            {
                ((IList<object>)results).Add(entry);
            }
        }
        return this.parseTransactions(results, currency, since, limit, parameters);
    }

    /**
     * @method
     * @name alpaca#fetchDepositsWithdrawals
     * @description fetch history of deposits and withdrawals
     * @see https://docs.alpaca.markets/reference/listcryptofundingtransfers
     * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
     * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
     * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDepositsWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsHelper("BOTH", code, since, limit, parameters);
    }

    /**
     * @method
     * @name alpaca#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://docs.alpaca.markets/reference/listcryptofundingtransfers
     * @param {string} [code] unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposit structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsHelper("INCOMING", code, since, limit, parameters);
    }

    /**
     * @method
     * @name alpaca#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://docs.alpaca.markets/reference/listcryptofundingtransfers
     * @param {string} [code] unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawal structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsHelper("OUTGOING", code, since, limit, parameters);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        //     {
        //         "id": "e27b70a6-5610-40d7-8468-a516a284b776",
        //         "tx_hash": null,
        //         "direction": "OUTGOING",
        //         "amount": "20",
        //         "usd_value": "19.99856",
        //         "chain": "ETH",
        //         "asset": "USDT",
        //         "from_address": "0x123930E4dCA196E070d39B60c644C8Aae02f23",
        //         "to_address": "0x1232c0925196e4dcf05945f67f690153190fbaab",
        //         "status": "PROCESSING",
        //         "created_at": "2024-11-07T02:39:01.775495Z",
        //         "network_fee": "4",
        //         "fees": "0.1"
        //     }
        //
        object datetime = this.safeString(transaction, "created_at");
        object currencyId = this.safeString(transaction, "asset");
        object code = this.safeCurrencyCode(currencyId, currency);
        object fees = this.safeString(transaction, "fees");
        object networkFee = this.safeString(transaction, "network_fee");
        object totalFee = Precise.stringAdd(fees, networkFee);
        object fee = new Dictionary<string, object>() {
            { "cost", this.parseNumber(totalFee) },
            { "currency", code },
        };
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString(transaction, "id") },
            { "txid", this.safeString(transaction, "tx_hash") },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "network", this.safeString(transaction, "chain") },
            { "address", this.safeString(transaction, "to_address") },
            { "addressTo", this.safeString(transaction, "to_address") },
            { "addressFrom", this.safeString(transaction, "from_address") },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", this.parseTransactionType(this.safeString(transaction, "direction")) },
            { "amount", this.safeNumber(transaction, "amount") },
            { "currency", code },
            { "status", this.parseTransactionStatus(this.safeString(transaction, "status")) },
            { "updated", null },
            { "fee", fee },
            { "comment", null },
            { "internal", null },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "PROCESSING", "pending" },
            { "FAILED", "failed" },
            { "COMPLETE", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseTransactionType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "INCOMING", "deposit" },
            { "OUTGOING", "withdrawal" },
        };
        return this.safeString(types, type, type);
    }

    /**
     * @method
     * @name alpaca#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://docs.alpaca.markets/reference/getaccount-1
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.traderPrivateGetV2Account(parameters);
        //
        //     {
        //         "id": "43a01bde-4eb1-64fssc26adb5",
        //         "admin_configurations": {
        //             "allow_instant_ach": true,
        //             "max_margin_multiplier": "4"
        //         },
        //         "user_configurations": {
        //             "fractional_trading": true,
        //             "max_margin_multiplier": "4"
        //         },
        //         "account_number": "744873727",
        //         "status": "ACTIVE",
        //         "crypto_status": "ACTIVE",
        //         "currency": "USD",
        //         "buying_power": "5.92",
        //         "regt_buying_power": "5.92",
        //         "daytrading_buying_power": "0",
        //         "effective_buying_power": "5.92",
        //         "non_marginable_buying_power": "5.92",
        //         "bod_dtbp": "0",
        //         "cash": "5.92",
        //         "accrued_fees": "0",
        //         "portfolio_value": "48.6",
        //         "pattern_day_trader": false,
        //         "trading_blocked": false,
        //         "transfers_blocked": false,
        //         "account_blocked": false,
        //         "created_at": "2022-06-13T14:59:18.318096Z",
        //         "trade_suspended_by_user": false,
        //         "multiplier": "1",
        //         "shorting_enabled": false,
        //         "equity": "48.6",
        //         "last_equity": "48.8014266",
        //         "long_market_value": "42.68",
        //         "short_market_value": "0",
        //         "position_market_value": "42.68",
        //         "initial_margin": "0",
        //         "maintenance_margin": "0",
        //         "last_maintenance_margin": "0",
        //         "sma": "5.92",
        //         "daytrade_count": 0,
        //         "balance_asof": "2024-12-10",
        //         "crypto_tier": 1,
        //         "intraday_adjustments": "0",
        //         "pending_reg_taf_fees": "0"
        //     }
        //
        return this.parseBalance(response);
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object account = this.account();
        object currencyId = this.safeString(response, "currency");
        object code = this.safeCurrencyCode(currencyId);
        ((IDictionary<string,object>)account)["free"] = this.safeString(response, "cash");
        ((IDictionary<string,object>)account)["total"] = this.safeString(response, "equity");
        ((IDictionary<string,object>)result)[(string)code] = account;
        return this.safeBalance(result);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object endpoint = add("/", this.implodeParams(path, parameters));
        object url = this.implodeHostname(getValue(getValue(this.urls, "api"), getValue(api, 0)));
        headers = ((bool) isTrue((!isEqual(headers, null)))) ? headers : new Dictionary<string, object>() {};
        if (isTrue(isEqual(getValue(api, 1), "private")))
        {
            this.checkRequiredCredentials();
            ((IDictionary<string,object>)headers)["APCA-API-KEY-ID"] = this.apiKey;
            ((IDictionary<string,object>)headers)["APCA-API-SECRET-KEY"] = this.secret;
        }
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
        {
            if (isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE")))))
            {
                endpoint = add(endpoint, add("?", this.urlencode(query)));
            } else
            {
                body = this.json(query);
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
            }
        }
        url = add(url, endpoint);
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // default error handler
        }
        // {
        //     "code": 40110000,
        //     "message": "request is not authorized"
        // }
        object feedback = add(add(this.id, " "), body);
        object errorCode = this.safeString(response, "code");
        if (isTrue(!isEqual(code, null)))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
        }
        object message = this.safeValue(response, "message", null);
        if (isTrue(!isEqual(message, null)))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
