namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class ndax : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "ndax" },
            { "name", "NDAX" },
            { "countries", new List<object>() {"CA"} },
            { "rateLimit", 1000 },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createDepositAddress", true },
                { "createOrder", true },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "editOrder", true },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLedger", true },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchOrderTrades", true },
                { "fetchPosition", false },
                { "fetchPositions", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", false },
                { "fetchTime", false },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "signIn", true },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "60" },
                { "5m", "300" },
                { "15m", "900" },
                { "30m", "1800" },
                { "1h", "3600" },
                { "2h", "7200" },
                { "4h", "14400" },
                { "6h", "21600" },
                { "12h", "43200" },
                { "1d", "86400" },
                { "1w", "604800" },
                { "1M", "2419200" },
                { "4M", "9676800" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/108623144-67a3ef00-744e-11eb-8140-75c6b851e945.jpg" },
                { "test", new Dictionary<string, object>() {
                    { "public", "https://ndaxmarginstaging.cdnhop.net:8443/AP" },
                    { "private", "https://ndaxmarginstaging.cdnhop.net:8443/AP" },
                } },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.ndax.io:8443/AP" },
                    { "private", "https://api.ndax.io:8443/AP" },
                } },
                { "www", "https://ndax.io" },
                { "doc", new List<object>() {"https://apidoc.ndax.io/"} },
                { "fees", "https://ndax.io/fees" },
                { "referral", "https://one.ndax.io/bfQiSL" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "Activate2FA", 1 },
                        { "Authenticate2FA", 1 },
                        { "AuthenticateUser", 1 },
                        { "GetL2Snapshot", 1 },
                        { "GetLevel1", 1 },
                        { "GetValidate2FARequiredEndpoints", 1 },
                        { "LogOut", 1 },
                        { "GetTickerHistory", 1 },
                        { "GetProduct", 1 },
                        { "GetProducts", 1 },
                        { "GetInstrument", 1 },
                        { "GetInstruments", 1 },
                        { "Ping", 1 },
                        { "trades", 1 },
                        { "GetLastTrades", 1 },
                        { "SubscribeLevel1", 1 },
                        { "SubscribeLevel2", 1 },
                        { "SubscribeTicker", 1 },
                        { "SubscribeTrades", 1 },
                        { "SubscribeBlockTrades", 1 },
                        { "UnsubscribeBlockTrades", 1 },
                        { "UnsubscribeLevel1", 1 },
                        { "UnsubscribeLevel2", 1 },
                        { "UnsubscribeTicker", 1 },
                        { "UnsubscribeTrades", 1 },
                        { "Authenticate", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "GetUserAccountInfos", 1 },
                        { "GetUserAccounts", 1 },
                        { "GetUserAffiliateCount", 1 },
                        { "GetUserAffiliateTag", 1 },
                        { "GetUserConfig", 1 },
                        { "GetAllUnredactedUserConfigsForUser", 1 },
                        { "GetUnredactedUserConfigByKey", 1 },
                        { "GetUserDevices", 1 },
                        { "GetUserReportTickets", 1 },
                        { "GetUserReportWriterResultRecords", 1 },
                        { "GetAccountInfo", 1 },
                        { "GetAccountPositions", 1 },
                        { "GetAllAccountConfigs", 1 },
                        { "GetTreasuryProductsForAccount", 1 },
                        { "GetAccountTrades", 1 },
                        { "GetAccountTransactions", 1 },
                        { "GetOpenTradeReports", 1 },
                        { "GetAllOpenTradeReports", 1 },
                        { "GetTradesHistory", 1 },
                        { "GetOpenOrders", 1 },
                        { "GetOpenQuotes", 1 },
                        { "GetOrderFee", 1 },
                        { "GetOrderHistory", 1 },
                        { "GetOrdersHistory", 1 },
                        { "GetOrderStatus", 1 },
                        { "GetOmsFeeTiers", 1 },
                        { "GetAccountDepositTransactions", 1 },
                        { "GetAccountWithdrawTransactions", 1 },
                        { "GetAllDepositRequestInfoTemplates", 1 },
                        { "GetDepositInfo", 1 },
                        { "GetDepositRequestInfoTemplate", 1 },
                        { "GetDeposits", 1 },
                        { "GetDepositTicket", 1 },
                        { "GetDepositTickets", 1 },
                        { "GetOMSWithdrawFees", 1 },
                        { "GetWithdrawFee", 1 },
                        { "GetWithdraws", 1 },
                        { "GetWithdrawTemplate", 1 },
                        { "GetWithdrawTemplateTypes", 1 },
                        { "GetWithdrawTicket", 1 },
                        { "GetWithdrawTickets", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "AddUserAffiliateTag", 1 },
                        { "CancelUserReport", 1 },
                        { "RegisterNewDevice", 1 },
                        { "SubscribeAccountEvents", 1 },
                        { "UpdateUserAffiliateTag", 1 },
                        { "GenerateTradeActivityReport", 1 },
                        { "GenerateTransactionActivityReport", 1 },
                        { "GenerateTreasuryActivityReport", 1 },
                        { "ScheduleTradeActivityReport", 1 },
                        { "ScheduleTransactionActivityReport", 1 },
                        { "ScheduleTreasuryActivityReport", 1 },
                        { "CancelAllOrders", 1 },
                        { "CancelOrder", 1 },
                        { "CancelQuote", 1 },
                        { "CancelReplaceOrder", 1 },
                        { "CreateQuote", 1 },
                        { "ModifyOrder", 1 },
                        { "SendOrder", 1 },
                        { "SubmitBlockTrade", 1 },
                        { "UpdateQuote", 1 },
                        { "CancelWithdraw", 1 },
                        { "CreateDepositTicket", 1 },
                        { "CreateWithdrawTicket", 1 },
                        { "SubmitDepositTicketComment", 1 },
                        { "SubmitWithdrawTicketComment", 1 },
                        { "GetOrderHistoryByOrderId", 1 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.002") },
                    { "taker", this.parseNumber("0.0025") },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "uid", true },
                { "login", true },
                { "password", true },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "Not_Enough_Funds", typeof(InsufficientFunds) },
                    { "Server Error", typeof(ExchangeError) },
                    { "Resource Not Found", typeof(OrderNotFound) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Invalid InstrumentId", typeof(BadSymbol) },
                    { "This endpoint requires 2FACode along with the payload", typeof(AuthenticationError) },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "omsId", 1 },
                { "orderTypes", new Dictionary<string, object>() {
                    { "Market", 1 },
                    { "Limit", 2 },
                    { "StopMarket", 3 },
                    { "StopLimit", 4 },
                    { "TrailingStopMarket", 5 },
                    { "TrailingStopLimit", 6 },
                    { "BlockTrade", 7 },
                    { "1", 1 },
                    { "2", 2 },
                    { "3", 3 },
                    { "4", 4 },
                    { "5", 5 },
                    { "6", 6 },
                    { "7", 7 },
                } },
            } },
        });
    }

    public async override Task<object> signIn(object parameters = null)
    {
        /**
        * @method
        * @name ndax#signIn
        * @description sign in, must be called prior to using other authenticated methods
        * @see https://apidoc.ndax.io/#authenticate2fa
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns response from exchange
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        if (isTrue(isTrue(isEqual(this.login, null)) || isTrue(isEqual(this.password, null))))
        {
            throw new AuthenticationError ((string)add(this.id, " signIn() requires exchange.login, exchange.password")) ;
        }
        object request = new Dictionary<string, object>() {
            { "grant_type", "client_credentials" },
        };
        object response = await this.publicGetAuthenticate(this.extend(request, parameters));
        //
        //     {
        //         "Authenticated":true,
        //         "Requires2FA":true,
        //         "AuthType":"Google",
        //         "AddtlInfo":"",
        //         "Pending2FaToken": "6f5c4e66-f3ee-493e-9227-31cc0583b55f"
        //     }
        //
        object sessionToken = this.safeString(response, "SessionToken");
        if (isTrue(!isEqual(sessionToken, null)))
        {
            ((IDictionary<string,object>)this.options)["sessionToken"] = sessionToken;
            return response;
        }
        object pending2faToken = this.safeString(response, "Pending2FaToken");
        if (isTrue(!isEqual(pending2faToken, null)))
        {
            if (isTrue(isEqual(this.twofa, null)))
            {
                throw new AuthenticationError ((string)add(this.id, " signIn() requires exchange.twofa credentials")) ;
            }
            ((IDictionary<string,object>)this.options)["pending2faToken"] = pending2faToken;
            request = ((object)new Dictionary<string, object>() {
                { "Code", totp(this.twofa) },
            });
            object responseInner = await this.publicGetAuthenticate2FA(this.extend(request, parameters));
            //
            //     {
            //         "Authenticated": true,
            //         "UserId":57765,
            //         "SessionToken":"4a2a5857-c4e5-4fac-b09e-2c4c30b591a0"
            //     }
            //
            sessionToken = this.safeString(responseInner, "SessionToken");
            ((IDictionary<string,object>)this.options)["sessionToken"] = sessionToken;
            return responseInner;
        }
        return response;
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name ndax#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://apidoc.ndax.io/#getproduct
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        object request = new Dictionary<string, object>() {
            { "omsId", omsId },
        };
        object response = await this.publicGetGetProducts(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "OMSId":1,
        //             "ProductId":1,
        //             "Product":"BTC",
        //             "ProductFullName":"Bitcoin",
        //             "ProductType":"CryptoCurrency",
        //             "DecimalPlaces":8,
        //             "TickSize":0.0000000100000000000000000000,
        //             "NoFees":false,
        //             "IsDisabled":false,
        //             "MarginEnabled":false
        //         },
        //     ]
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object currency = getValue(response, i);
            object id = this.safeString(currency, "ProductId");
            object name = this.safeString(currency, "ProductFullName");
            object ProductType = this.safeString(currency, "ProductType");
            object type = ((bool) isTrue((isEqual(ProductType, "NationalCurrency")))) ? "fiat" : "crypto";
            if (isTrue(isEqual(ProductType, "Unknown")))
            {
                // such currency is just a blanket entry
                type = "other";
            }
            object code = this.safeCurrencyCode(this.safeString(currency, "Product"));
            object isDisabled = this.safeValue(currency, "IsDisabled");
            object active = !isTrue(isDisabled);
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "name", name },
                { "code", code },
                { "type", type },
                { "precision", this.safeNumber(currency, "TickSize") },
                { "info", currency },
                { "active", active },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "networks", new Dictionary<string, object>() {} },
            };
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name ndax#fetchMarkets
        * @description retrieves data on all markets for ndax
        * @see https://apidoc.ndax.io/#getinstruments
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        object request = new Dictionary<string, object>() {
            { "omsId", omsId },
        };
        object response = await this.publicGetGetInstruments(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "OMSId":1,
        //             "InstrumentId":3,
        //             "Symbol":"LTCBTC",
        //             "Product1":3,
        //             "Product1Symbol":"LTC",
        //             "Product2":1,
        //             "Product2Symbol":"BTC",
        //             "InstrumentType":"Standard",
        //             "VenueInstrumentId":3,
        //             "VenueId":1,
        //             "SortIndex":0,
        //             "SessionStatus":"Running",
        //             "PreviousSessionStatus":"Stopped",
        //             "SessionStatusDateTime":"2020-11-25T19:42:15.245Z",
        //             "SelfTradePrevention":true,
        //             "QuantityIncrement":0.0000000100000000000000000000,
        //             "PriceIncrement":0.0000000100000000000000000000,
        //             "MinimumQuantity":0.0100000000000000000000000000,
        //             "MinimumPrice":0.0000010000000000000000000000,
        //             "VenueSymbol":"LTCBTC",
        //             "IsDisable":false,
        //             "MasterDataId":0,
        //             "PriceCollarThreshold":0.0000000000000000000000000000,
        //             "PriceCollarPercent":0.0000000000000000000000000000,
        //             "PriceCollarEnabled":false,
        //             "PriceFloorLimit":0.0000000000000000000000000000,
        //             "PriceFloorLimitEnabled":false,
        //             "PriceCeilingLimit":0.0000000000000000000000000000,
        //             "PriceCeilingLimitEnabled":false,
        //             "CreateWithMarketRunning":true,
        //             "AllowOnlyMarketMakerCounterParty":false,
        //             "PriceCollarIndexDifference":0.0000000000000000000000000000,
        //             "PriceCollarConvertToOtcEnabled":false,
        //             "PriceCollarConvertToOtcClientUserId":0,
        //             "PriceCollarConvertToOtcAccountId":0,
        //             "PriceCollarConvertToOtcThreshold":0.0000000000000000000000000000,
        //             "OtcConvertSizeThreshold":0.0000000000000000000000000000,
        //             "OtcConvertSizeEnabled":false,
        //             "OtcTradesPublic":true,
        //             "PriceTier":0
        //         },
        //     ]
        //
        return this.parseMarkets(response);
    }

    public override object parseMarket(object market)
    {
        object id = this.safeString(market, "InstrumentId");
        // const lowercaseId = this.safeStringLower (market, 'symbol');
        object baseId = this.safeString(market, "Product1");
        object quoteId = this.safeString(market, "Product2");
        object bs = this.safeCurrencyCode(this.safeString(market, "Product1Symbol"));
        object quote = this.safeCurrencyCode(this.safeString(market, "Product2Symbol"));
        object sessionStatus = this.safeString(market, "SessionStatus");
        object isDisable = this.safeValue(market, "IsDisable");
        object sessionRunning = (isEqual(sessionStatus, "Running"));
        return new Dictionary<string, object>() {
            { "id", id },
            { "symbol", add(add(bs, "/"), quote) },
            { "base", bs },
            { "quote", quote },
            { "settle", null },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", null },
            { "type", "spot" },
            { "spot", true },
            { "margin", false },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "active", (isTrue(sessionRunning) && !isTrue(isDisable)) },
            { "contract", false },
            { "linear", null },
            { "inverse", null },
            { "contractSize", null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber(market, "QuantityIncrement") },
                { "price", this.safeNumber(market, "PriceIncrement") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "MinimumQuantity") },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "MinimumPrice") },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        };
    }

    public override object parseOrderBook(object orderbook, object symbol, object timestamp = null, object bidsKey = null, object asksKey = null, object priceKey = null, object amountKey = null, object countOrIdKey = null)
    {
        bidsKey ??= "bids";
        asksKey ??= "asks";
        priceKey ??= 6;
        amountKey ??= 8;
        countOrIdKey ??= 2;
        object nonce = null;
        object result = new Dictionary<string, object>() {
            { "symbol", symbol },
            { "bids", new List<object>() {} },
            { "asks", new List<object>() {} },
            { "timestamp", null },
            { "datetime", null },
            { "nonce", null },
        };
        for (object i = 0; isLessThan(i, getArrayLength(orderbook)); postFixIncrement(ref i))
        {
            object level = getValue(orderbook, i);
            if (isTrue(isEqual(timestamp, null)))
            {
                timestamp = this.safeInteger(level, 2);
            } else
            {
                object newTimestamp = this.safeInteger(level, 2);
                timestamp = mathMax(timestamp, newTimestamp);
            }
            if (isTrue(isEqual(nonce, null)))
            {
                nonce = this.safeInteger(level, 0);
            } else
            {
                object newNonce = this.safeInteger(level, 0);
                nonce = mathMax(nonce, newNonce);
            }
            object bidask = this.parseBidAsk(level, priceKey, amountKey);
            object levelSide = this.safeInteger(level, 9);
            object side = ((bool) isTrue(levelSide)) ? asksKey : bidsKey;
            ((IList<object>)getValue(result, side)).Add(bidask);
        }
        ((IDictionary<string,object>)result)["bids"] = this.sortBy(getValue(result, "bids"), 0, true);
        ((IDictionary<string,object>)result)["asks"] = this.sortBy(getValue(result, "asks"), 0);
        ((IDictionary<string,object>)result)["timestamp"] = timestamp;
        ((IDictionary<string,object>)result)["datetime"] = this.iso8601(timestamp);
        ((IDictionary<string,object>)result)["nonce"] = nonce;
        return result;
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ndax#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://apidoc.ndax.io/#getl2snapshot
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        await this.loadMarkets();
        object market = this.market(symbol);
        limit = ((bool) isTrue((isEqual(limit, null)))) ? 100 : limit; // default 100
        object request = new Dictionary<string, object>() {
            { "omsId", omsId },
            { "InstrumentId", getValue(market, "id") },
            { "Depth", limit },
        };
        object response = await this.publicGetGetL2Snapshot(this.extend(request, parameters));
        //
        //     [
        //         [
        //             0,   // 0 MDUpdateId
        //             1,   // 1 Number of Unique Accounts
        //             123, // 2 ActionDateTime in Posix format X 1000
        //             0,   // 3 ActionType 0 (New), 1 (Update), 2(Delete)
        //             0.0, // 4 LastTradePrice
        //             0,   // 5 Number of Orders
        //             0.0, // 6 Price
        //             0,   // 7 ProductPairCode
        //             0.0, // 8 Quantity
        //             0,   // 9 Side
        //         ],
        //         [97244115,1,1607456142963,0,19069.32,1,19069.31,8,0.140095,0],
        //         [97244115,0,1607456142963,0,19069.32,1,19068.64,8,0.0055,0],
        //         [97244115,0,1607456142963,0,19069.32,1,19068.26,8,0.021291,0],
        //         [97244115,1,1607456142964,0,19069.32,1,19069.32,8,0.099636,1],
        //         [97244115,0,1607456142964,0,19069.32,1,19069.98,8,0.1,1],
        //         [97244115,0,1607456142964,0,19069.32,1,19069.99,8,0.141604,1],
        //     ]
        //
        return this.parseOrderBook(response, symbol);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // fetchTicker
        //
        //     {
        //         "OMSId":1,
        //         "InstrumentId":8,
        //         "BestBid":19069.31,
        //         "BestOffer":19069.32,
        //         "LastTradedPx":19069.32,
        //         "LastTradedQty":0.0001,
        //         "LastTradeTime":1607040406424,
        //         "SessionOpen":19069.32,
        //         "SessionHigh":19069.32,
        //         "SessionLow":19069.32,
        //         "SessionClose":19069.32,
        //         "Volume":0.0001,
        //         "CurrentDayVolume":0.0001,
        //         "CurrentDayNotional":1.906932,
        //         "CurrentDayNumTrades":1,
        //         "CurrentDayPxChange":0.00,
        //         "Rolling24HrVolume":0.000000000000000000000000000,
        //         "Rolling24HrNotional":0.00000000000000000000000,
        //         "Rolling24NumTrades":0,
        //         "Rolling24HrPxChange":0,
        //         "TimeStamp":"1607040406425",
        //         "BidQty":0,
        //         "AskQty":0,
        //         "BidOrderCt":0,
        //         "AskOrderCt":0,
        //         "Rolling24HrPxChangePercent":0,
        //     }
        //
        object timestamp = this.safeInteger(ticker, "TimeStamp");
        object marketId = this.safeString(ticker, "InstrumentId");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeSymbol(marketId, market);
        object last = this.safeString(ticker, "LastTradedPx");
        object percentage = this.safeString(ticker, "Rolling24HrPxChangePercent");
        object change = this.safeString(ticker, "Rolling24HrPxChange");
        object open = this.safeString(ticker, "SessionOpen");
        object baseVolume = this.safeString(ticker, "Rolling24HrVolume");
        object quoteVolume = this.safeString(ticker, "Rolling24HrNotional");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "SessionHigh") },
            { "low", this.safeString(ticker, "SessionLow") },
            { "bid", this.safeString(ticker, "BestBid") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "BestOffer") },
            { "askVolume", null },
            { "vwap", null },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", change },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name ndax#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://apidoc.ndax.io/#getlevel1
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "omsId", omsId },
            { "InstrumentId", getValue(market, "id") },
        };
        object response = await this.publicGetGetLevel1(this.extend(request, parameters));
        //
        //     {
        //         "OMSId":1,
        //         "InstrumentId":8,
        //         "BestBid":19069.31,
        //         "BestOffer":19069.32,
        //         "LastTradedPx":19069.32,
        //         "LastTradedQty":0.0001,
        //         "LastTradeTime":1607040406424,
        //         "SessionOpen":19069.32,
        //         "SessionHigh":19069.32,
        //         "SessionLow":19069.32,
        //         "SessionClose":19069.32,
        //         "Volume":0.0001,
        //         "CurrentDayVolume":0.0001,
        //         "CurrentDayNotional":1.906932,
        //         "CurrentDayNumTrades":1,
        //         "CurrentDayPxChange":0.00,
        //         "Rolling24HrVolume":0.000000000000000000000000000,
        //         "Rolling24HrNotional":0.00000000000000000000000,
        //         "Rolling24NumTrades":0,
        //         "Rolling24HrPxChange":0,
        //         "TimeStamp":"1607040406425",
        //         "BidQty":0,
        //         "AskQty":0,
        //         "BidOrderCt":0,
        //         "AskOrderCt":0,
        //         "Rolling24HrPxChangePercent":0,
        //     }
        //
        return this.parseTicker(response, market);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         1501603632000, // 0 DateTime
        //         2700.33,       // 1 High
        //         2687.01,       // 2 Low
        //         2687.01,       // 3 Open
        //         2687.01,       // 4 Close
        //         24.86100992,   // 5 Volume
        //         0,             // 6 Inside Bid Price
        //         2870.95,       // 7 Inside Ask Price
        //         1              // 8 InstrumentId
        //     ]
        //
        return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ndax#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://apidoc.ndax.io/#gettickerhistory
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "omsId", omsId },
            { "InstrumentId", getValue(market, "id") },
            { "Interval", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        object duration = this.parseTimeframe(timeframe);
        object now = this.milliseconds();
        if (isTrue(isEqual(since, null)))
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["FromDate"] = this.ymdhms(subtract(now, multiply(multiply(duration, limit), 1000)));
                ((IDictionary<string,object>)request)["ToDate"] = this.ymdhms(now);
            }
        } else
        {
            ((IDictionary<string,object>)request)["FromDate"] = this.ymdhms(since);
            if (isTrue(isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["ToDate"] = this.ymdhms(now);
            } else
            {
                ((IDictionary<string,object>)request)["ToDate"] = this.ymdhms(this.sum(since, multiply(multiply(duration, limit), 1000)));
            }
        }
        object response = await this.publicGetGetTickerHistory(this.extend(request, parameters));
        //
        //     [
        //         [1607299260000,19069.32,19069.32,19069.32,19069.32,0,19069.31,19069.32,8,1607299200000],
        //         [1607299320000,19069.32,19069.32,19069.32,19069.32,0,19069.31,19069.32,8,1607299260000],
        //         [1607299380000,19069.32,19069.32,19069.32,19069.32,0,19069.31,19069.32,8,1607299320000],
        //     ]
        //
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //     [
        //         6913253,       //  0 TradeId
        //         8,             //  1 ProductPairCode
        //         0.03340802,    //  2 Quantity
        //         19116.08,      //  3 Price
        //         2543425077,    //  4 Order1
        //         2543425482,    //  5 Order2
        //         1606935922416, //  6 Tradetime
        //         0,             //  7 Direction
        //         1,             //  8 TakerSide
        //         0,             //  9 BlockTrade
        //         0,             // 10 Either Order1ClientId or Order2ClientId
        //     ]
        //
        // fetchMyTrades (private)
        //
        //     {
        //         "OMSId":1,
        //         "ExecutionId":16916567,
        //         "TradeId":14476351,
        //         "OrderId":2543565231,
        //         "AccountId":449,
        //         "AccountName":"igor@ccxt.trade",
        //         "SubAccountId":0,
        //         "ClientOrderId":0,
        //         "InstrumentId":8,
        //         "Side":"Sell",
        //         "OrderType":"Market",
        //         "Quantity":0.1230000000000000000000000000,
        //         "RemainingQuantity":0.0000000000000000000000000000,
        //         "Price":19069.310000000000000000000000,
        //         "Value":2345.5251300000000000000000000,
        //         "CounterParty":"7",
        //         "OrderTradeRevision":1,
        //         "Direction":"NoChange",
        //         "IsBlockTrade":false,
        //         "Fee":1.1727625650000000000000000000,
        //         "FeeProductId":8,
        //         "OrderOriginator":446,
        //         "UserName":"igor@ccxt.trade",
        //         "TradeTimeMS":1607565031569,
        //         "MakerTaker":"Taker",
        //         "AdapterTradeId":0,
        //         "InsideBid":19069.310000000000000000000000,
        //         "InsideBidSize":0.2400950000000000000000000000,
        //         "InsideAsk":19069.320000000000000000000000,
        //         "InsideAskSize":0.0997360000000000000000000000,
        //         "IsQuote":false,
        //         "CounterPartyClientUserId":1,
        //         "NotionalProductId":2,
        //         "NotionalRate":1.0000000000000000000000000000,
        //         "NotionalValue":2345.5251300000000000000000000,
        //         "NotionalHoldAmount":0,
        //         "TradeTime":637431618315686826
        //     }
        //
        // fetchOrderTrades
        //
        //     {
        //         "Side":"Sell",
        //         "OrderId":2543565235,
        //         "Price":18600.000000000000000000000000,
        //         "Quantity":0.0000000000000000000000000000,
        //         "DisplayQuantity":0.0000000000000000000000000000,
        //         "Instrument":8,
        //         "Account":449,
        //         "AccountName":"igor@ccxt.trade",
        //         "OrderType":"Limit",
        //         "ClientOrderId":0,
        //         "OrderState":"FullyExecuted",
        //         "ReceiveTime":1607585844956,
        //         "ReceiveTimeTicks":637431826449564182,
        //         "LastUpdatedTime":1607585844959,
        //         "LastUpdatedTimeTicks":637431826449593893,
        //         "OrigQuantity":0.1230000000000000000000000000,
        //         "QuantityExecuted":0.1230000000000000000000000000,
        //         "GrossValueExecuted":2345.3947500000000000000000000,
        //         "ExecutableValue":0.0000000000000000000000000000,
        //         "AvgPrice":19068.250000000000000000000000,
        //         "CounterPartyId":0,
        //         "ChangeReason":"Trade",
        //         "OrigOrderId":2543565235,
        //         "OrigClOrdId":0,
        //         "EnteredBy":446,
        //         "UserName":"igor@ccxt.trade",
        //         "IsQuote":false,
        //         "InsideAsk":19069.320000000000000000000000,
        //         "InsideAskSize":0.0997360000000000000000000000,
        //         "InsideBid":19068.250000000000000000000000,
        //         "InsideBidSize":1.3300010000000000000000000000,
        //         "LastTradePrice":19068.250000000000000000000000,
        //         "RejectReason":"",
        //         "IsLockedIn":false,
        //         "CancelReason":"",
        //         "OrderFlag":"0",
        //         "UseMargin":false,
        //         "StopPrice":0.0000000000000000000000000000,
        //         "PegPriceType":"Unknown",
        //         "PegOffset":0.0000000000000000000000000000,
        //         "PegLimitOffset":0.0000000000000000000000000000,
        //         "IpAddress":"x.x.x.x",
        //         "ClientOrderIdUuid":null,
        //         "OMSId":1
        //     }
        //
        object priceString = null;
        object amountString = null;
        object costString = null;
        object timestamp = null;
        object id = null;
        object marketId = null;
        object side = null;
        object orderId = null;
        object takerOrMaker = null;
        object fee = null;
        object type = null;
        if (isTrue(((trade is IList<object>) || (trade.GetType().IsGenericType && trade.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            priceString = this.safeString(trade, 3);
            amountString = this.safeString(trade, 2);
            timestamp = this.safeInteger(trade, 6);
            id = this.safeString(trade, 0);
            marketId = this.safeString(trade, 1);
            object takerSide = this.safeValue(trade, 8);
            side = ((bool) isTrue(takerSide)) ? "sell" : "buy";
            orderId = this.safeString(trade, 4);
        } else
        {
            timestamp = this.safeInteger2(trade, "TradeTimeMS", "ReceiveTime");
            id = this.safeString(trade, "TradeId");
            orderId = this.safeString2(trade, "OrderId", "OrigOrderId");
            marketId = this.safeString2(trade, "InstrumentId", "Instrument");
            priceString = this.safeString(trade, "Price");
            amountString = this.safeString(trade, "Quantity");
            costString = this.safeString2(trade, "Value", "GrossValueExecuted");
            takerOrMaker = this.safeStringLower(trade, "MakerTaker");
            side = this.safeStringLower(trade, "Side");
            type = this.safeStringLower(trade, "OrderType");
            object feeCostString = this.safeString(trade, "Fee");
            if (isTrue(!isEqual(feeCostString, null)))
            {
                object feeCurrencyId = this.safeString(trade, "FeeProductId");
                object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
                fee = new Dictionary<string, object>() {
                    { "cost", feeCostString },
                    { "currency", feeCurrencyCode },
                };
            }
        }
        object symbol = this.safeSymbol(marketId, market);
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "order", orderId },
            { "type", type },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", priceString },
            { "amount", amountString },
            { "cost", costString },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ndax#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "omsId", omsId },
            { "InstrumentId", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["Count"] = limit;
        }
        object response = await this.publicGetGetLastTrades(this.extend(request, parameters));
        //
        //     [
        //         [6913253,8,0.03340802,19116.08,2543425077,2543425482,1606935922416,0,1,0,0],
        //         [6913254,8,0.01391671,19117.42,2543427510,2543427811,1606935927998,1,1,0,0],
        //         [6913255,8,0.000006,19107.81,2543430495,2543430793,1606935933881,2,0,0,0],
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> fetchAccounts(object parameters = null)
    {
        /**
        * @method
        * @name ndax#fetchAccounts
        * @description fetch all the accounts associated with a profile
        * @see https://apidoc.ndax.io/#getuseraccounts
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
        */
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(this.login))
        {
            throw new AuthenticationError ((string)add(this.id, " fetchAccounts() requires exchange.login email credential")) ;
        }
        object omsId = this.safeInteger(this.options, "omsId", 1);
        this.checkRequiredCredentials();
        object request = new Dictionary<string, object>() {
            { "omsId", omsId },
            { "UserId", this.uid },
            { "UserName", this.login },
        };
        object response = await this.privateGetGetUserAccounts(this.extend(request, parameters));
        //
        //     [ 449 ] // comma-separated list of account ids
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object accountId = this.safeString(response, i);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", accountId },
                { "type", null },
                { "currency", null },
                { "info", accountId },
            });
        }
        return result;
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object balance = getValue(response, i);
            object currencyId = this.safeString(balance, "ProductId");
            if (isTrue(inOp(this.currencies_by_id, currencyId)))
            {
                object code = this.safeCurrencyCode(currencyId);
                object account = this.account();
                ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "Amount");
                ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "Hold");
                ((IDictionary<string,object>)result)[(string)code] = account;
            }
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name ndax#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://apidoc.ndax.io/#getaccountpositions
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        await this.loadMarkets();
        await this.loadAccounts();
        object defaultAccountId = this.safeInteger2(this.options, "accountId", "AccountId", parseInt(getValue(getValue(this.accounts, 0), "id")));
        object accountId = this.safeInteger2(parameters, "accountId", "AccountId", defaultAccountId);
        parameters = this.omit(parameters, new List<object>() {"accountId", "AccountId"});
        object request = new Dictionary<string, object>() {
            { "omsId", omsId },
            { "AccountId", accountId },
        };
        object response = await this.privateGetGetAccountPositions(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "OMSId":1,
        //             "AccountId":449,
        //             "ProductSymbol":"BTC",
        //             "ProductId":1,
        //             "Amount":10.000000000000000000000000000,
        //             "Hold":0,
        //             "PendingDeposits":0.0000000000000000000000000000,
        //             "PendingWithdraws":0.0000000000000000000000000000,
        //             "TotalDayDeposits":10.000000000000000000000000000,
        //             "TotalMonthDeposits":10.000000000000000000000000000,
        //             "TotalYearDeposits":10.000000000000000000000000000,
        //             "TotalDayDepositNotional":10.000000000000000000000000000,
        //             "TotalMonthDepositNotional":10.000000000000000000000000000,
        //             "TotalYearDepositNotional":10.000000000000000000000000000,
        //             "TotalDayWithdraws":0,
        //             "TotalMonthWithdraws":0,
        //             "TotalYearWithdraws":0,
        //             "TotalDayWithdrawNotional":0,
        //             "TotalMonthWithdrawNotional":0,
        //             "TotalYearWithdrawNotional":0,
        //             "NotionalProductId":8,
        //             "NotionalProductSymbol":"USDT",
        //             "NotionalValue":10.000000000000000000000000000,
        //             "NotionalHoldAmount":0,
        //             "NotionalRate":1
        //         },
        //     ]
        //
        return this.parseBalance(response);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "Trade", "trade" },
            { "Deposit", "transaction" },
            { "Withdraw", "transaction" },
            { "Transfer", "transfer" },
            { "OrderHold", "trade" },
            { "WithdrawHold", "transaction" },
            { "DepositHold", "transaction" },
            { "MarginHold", "trade" },
            { "ManualHold", "trade" },
            { "ManualEntry", "trade" },
            { "MarginAcquisition", "trade" },
            { "MarginRelinquish", "trade" },
            { "MarginQuoteHold", "trade" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //         "TransactionId": 2663709493,
        //         "ReferenceId": 68,
        //         "OMSId": 1,
        //         "AccountId": 449,
        //         "CR": 10.000000000000000000000000000,
        //         "DR": 0.0000000000000000000000000000,
        //         "Counterparty": 3,
        //         "TransactionType": "Other",
        //         "ReferenceType": "Deposit",
        //         "ProductId": 1,
        //         "Balance": 10.000000000000000000000000000,
        //         "TimeStamp": 1607532331591
        //     }
        //
        object currencyId = this.safeString(item, "ProductId");
        object credit = this.safeString(item, "CR");
        object debit = this.safeString(item, "DR");
        object amount = null;
        object direction = null;
        if (isTrue(Precise.stringLt(credit, "0")))
        {
            amount = credit;
            direction = "in";
        } else if (isTrue(Precise.stringLt(debit, "0")))
        {
            amount = debit;
            direction = "out";
        }
        object before = null;
        object after = this.safeString(item, "Balance");
        if (isTrue(isEqual(direction, "out")))
        {
            before = Precise.stringAdd(after, amount);
        } else if (isTrue(isEqual(direction, "in")))
        {
            before = Precise.stringMax("0", Precise.stringSub(after, amount));
        }
        object timestamp = this.safeInteger(item, "TimeStamp");
        return new Dictionary<string, object>() {
            { "info", item },
            { "id", this.safeString(item, "TransactionId") },
            { "direction", direction },
            { "account", this.safeString(item, "AccountId") },
            { "referenceId", this.safeString(item, "ReferenceId") },
            { "referenceAccount", this.safeString(item, "Counterparty") },
            { "type", this.parseLedgerEntryType(this.safeString(item, "ReferenceType")) },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.parseNumber(amount) },
            { "before", this.parseNumber(before) },
            { "after", this.parseNumber(after) },
            { "status", "ok" },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fee", null },
        };
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ndax#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @see https://apidoc.ndax.io/#getaccounttransactions
        * @param {string} code unified currency code, default is undefined
        * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int} [limit] max number of ledger entrys to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        await this.loadMarkets();
        await this.loadAccounts();
        object defaultAccountId = this.safeInteger2(this.options, "accountId", "AccountId", parseInt(getValue(getValue(this.accounts, 0), "id")));
        object accountId = this.safeInteger2(parameters, "accountId", "AccountId", defaultAccountId);
        parameters = this.omit(parameters, new List<object>() {"accountId", "AccountId"});
        object request = new Dictionary<string, object>() {
            { "omsId", omsId },
            { "AccountId", accountId },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["Depth"] = limit;
        }
        object response = await this.privateGetGetAccountTransactions(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "TransactionId":2663709493,
        //             "ReferenceId":68,
        //             "OMSId":1,
        //             "AccountId":449,
        //             "CR":10.000000000000000000000000000,
        //             "DR":0.0000000000000000000000000000,
        //             "Counterparty":3,
        //             "TransactionType":"Other",
        //             "ReferenceType":"Deposit",
        //             "ProductId":1,
        //             "Balance":10.000000000000000000000000000,
        //             "TimeStamp":1607532331591
        //         },
        //     ]
        //
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        return this.parseLedger(response, currency, since, limit);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "Accepted", "open" },
            { "Rejected", "rejected" },
            { "Working", "open" },
            { "Canceled", "canceled" },
            { "Expired", "expired" },
            { "FullyExecuted", "closed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //
        //     {
        //         "status":"Accepted",
        //         "errormsg":"",
        //         "OrderId": 2543565231
        //     }
        //
        // editOrder
        //
        //     {
        //         "ReplacementOrderId": 1234,
        //         "ReplacementClOrdId": 1561,
        //         "OrigOrderId": 5678,
        //         "OrigClOrdId": 91011,
        //     }
        //
        // fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "Side":"Buy",
        //         "OrderId":2543565233,
        //         "Price":19010,
        //         "Quantity":0.345,
        //         "DisplayQuantity":0.345,
        //         "Instrument":8,
        //         "Account":449,
        //         "AccountName":"igor@ccxt.trade",
        //         "OrderType":"Limit",
        //         "ClientOrderId":0,
        //         "OrderState":"Working",
        //         "ReceiveTime":1607579326003,
        //         "ReceiveTimeTicks":637431761260028981,
        //         "LastUpdatedTime":1607579326005,
        //         "LastUpdatedTimeTicks":637431761260054714,
        //         "OrigQuantity":0.345,
        //         "QuantityExecuted":0,
        //         "GrossValueExecuted":0,
        //         "ExecutableValue":0,
        //         "AvgPrice":0,
        //         "CounterPartyId":0,
        //         "ChangeReason":"NewInputAccepted",
        //         "OrigOrderId":2543565233,
        //         "OrigClOrdId":0,
        //         "EnteredBy":446,
        //         "UserName":"igor@ccxt.trade",
        //         "IsQuote":false,
        //         "InsideAsk":19069.32,
        //         "InsideAskSize":0.099736,
        //         "InsideBid":19068.25,
        //         "InsideBidSize":1.330001,
        //         "LastTradePrice":19068.25,
        //         "RejectReason":"",
        //         "IsLockedIn":false,
        //         "CancelReason":"",
        //         "OrderFlag":"AddedToBook",
        //         "UseMargin":false,
        //         "StopPrice":0,
        //         "PegPriceType":"Unknown",
        //         "PegOffset":0,
        //         "PegLimitOffset":0,
        //         "IpAddress":null,
        //         "ClientOrderIdUuid":null,
        //         "OMSId":1
        //     }
        //
        object timestamp = this.safeInteger(order, "ReceiveTime");
        object marketId = this.safeString(order, "Instrument");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString2(order, "ReplacementOrderId", "OrderId") },
            { "clientOrderId", this.safeString2(order, "ReplacementClOrdId", "ClientOrderId") },
            { "info", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", this.safeInteger(order, "LastUpdatedTime") },
            { "status", this.parseOrderStatus(this.safeString(order, "OrderState")) },
            { "symbol", this.safeSymbol(marketId, market) },
            { "type", this.safeStringLower(order, "OrderType") },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", this.safeStringLower(order, "Side") },
            { "price", this.safeString(order, "Price") },
            { "stopPrice", this.parseNumber(this.omitZero(this.safeString(order, "StopPrice"))) },
            { "cost", this.safeString(order, "GrossValueExecuted") },
            { "amount", this.safeString(order, "OrigQuantity") },
            { "filled", this.safeString(order, "QuantityExecuted") },
            { "average", this.safeString(order, "AvgPrice") },
            { "remaining", null },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name ndax#createOrder
        * @description create a trade order
        * @see https://apidoc.ndax.io/#sendorder
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.triggerPrice] the price at which a trigger order would be triggered
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        await this.loadMarkets();
        await this.loadAccounts();
        object defaultAccountId = this.safeInteger2(this.options, "accountId", "AccountId", parseInt(getValue(getValue(this.accounts, 0), "id")));
        object accountId = this.safeInteger2(parameters, "accountId", "AccountId", defaultAccountId);
        object clientOrderId = this.safeInteger2(parameters, "ClientOrderId", "clientOrderId");
        object orderType = this.safeInteger(getValue(this.options, "orderTypes"), this.capitalize(type));
        object triggerPrice = this.safeString(parameters, "triggerPrice");
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            if (isTrue(isEqual(type, "market")))
            {
                orderType = 3;
            } else if (isTrue(isEqual(type, "limit")))
            {
                orderType = 4;
            }
        }
        parameters = this.omit(parameters, new List<object>() {"accountId", "AccountId", "clientOrderId", "ClientOrderId", "triggerPrice"});
        object market = this.market(symbol);
        object orderSide = ((bool) isTrue((isEqual(side, "buy")))) ? 0 : 1;
        object request = new Dictionary<string, object>() {
            { "InstrumentId", parseInt(getValue(market, "id")) },
            { "omsId", omsId },
            { "AccountId", accountId },
            { "TimeInForce", 1 },
            { "Side", orderSide },
            { "Quantity", parseFloat(this.amountToPrecision(symbol, amount)) },
            { "OrderType", orderType },
        };
        // If OrderType=1 (Market), Side=0 (Buy), and LimitPrice is supplied, the Market order will execute up to the value specified
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["LimitPrice"] = parseFloat(this.priceToPrecision(symbol, price));
        }
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["ClientOrderId"] = clientOrderId;
        }
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((IDictionary<string,object>)request)["StopPrice"] = triggerPrice;
        }
        object response = await this.privatePostSendOrder(this.extend(request, parameters));
        //
        //     {
        //         "status":"Accepted",
        //         "errormsg":"",
        //         "OrderId": 2543565231
        //     }
        //
        return this.parseOrder(response, market);
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        await this.loadMarkets();
        await this.loadAccounts();
        object defaultAccountId = this.safeInteger2(this.options, "accountId", "AccountId", parseInt(getValue(getValue(this.accounts, 0), "id")));
        object accountId = this.safeInteger2(parameters, "accountId", "AccountId", defaultAccountId);
        object clientOrderId = this.safeInteger2(parameters, "ClientOrderId", "clientOrderId");
        parameters = this.omit(parameters, new List<object>() {"accountId", "AccountId", "clientOrderId", "ClientOrderId"});
        object market = this.market(symbol);
        object orderSide = ((bool) isTrue((isEqual(side, "buy")))) ? 0 : 1;
        object request = new Dictionary<string, object>() {
            { "OrderIdToReplace", parseInt(id) },
            { "InstrumentId", parseInt(getValue(market, "id")) },
            { "omsId", omsId },
            { "AccountId", accountId },
            { "TimeInForce", 1 },
            { "Side", orderSide },
            { "Quantity", parseFloat(this.amountToPrecision(symbol, amount)) },
            { "OrderType", this.safeInteger(getValue(this.options, "orderTypes"), this.capitalize(type)) },
        };
        // If OrderType=1 (Market), Side=0 (Buy), and LimitPrice is supplied, the Market order will execute up to the value specified
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["LimitPrice"] = parseFloat(this.priceToPrecision(symbol, price));
        }
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["ClientOrderId"] = clientOrderId;
        }
        object response = await this.privatePostCancelReplaceOrder(this.extend(request, parameters));
        //
        //     {
        //         "replacementOrderId": 1234,
        //         "replacementClOrdId": 1561,
        //         "origOrderId": 5678,
        //         "origClOrdId": 91011,
        //     }
        //
        return this.parseOrder(response, market);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ndax#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://apidoc.ndax.io/#gettradeshistory
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        await this.loadMarkets();
        await this.loadAccounts();
        object defaultAccountId = this.safeInteger2(this.options, "accountId", "AccountId", parseInt(getValue(getValue(this.accounts, 0), "id")));
        object accountId = this.safeInteger2(parameters, "accountId", "AccountId", defaultAccountId);
        parameters = this.omit(parameters, new List<object>() {"accountId", "AccountId"});
        object request = new Dictionary<string, object>() {
            { "omsId", omsId },
            { "AccountId", accountId },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["InstrumentId"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["StartTimeStamp"] = this.parseToInt(divide(since, 1000));
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["Depth"] = limit;
        }
        object response = await this.privateGetGetTradesHistory(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "OMSId":1,
        //             "ExecutionId":16916567,
        //             "TradeId":14476351,
        //             "OrderId":2543565231,
        //             "AccountId":449,
        //             "AccountName":"igor@ccxt.trade",
        //             "SubAccountId":0,
        //             "ClientOrderId":0,
        //             "InstrumentId":8,
        //             "Side":"Sell",
        //             "OrderType":"Market",
        //             "Quantity":0.1230000000000000000000000000,
        //             "RemainingQuantity":0.0000000000000000000000000000,
        //             "Price":19069.310000000000000000000000,
        //             "Value":2345.5251300000000000000000000,
        //             "CounterParty":"7",
        //             "OrderTradeRevision":1,
        //             "Direction":"NoChange",
        //             "IsBlockTrade":false,
        //             "Fee":1.1727625650000000000000000000,
        //             "FeeProductId":8,
        //             "OrderOriginator":446,
        //             "UserName":"igor@ccxt.trade",
        //             "TradeTimeMS":1607565031569,
        //             "MakerTaker":"Taker",
        //             "AdapterTradeId":0,
        //             "InsideBid":19069.310000000000000000000000,
        //             "InsideBidSize":0.2400950000000000000000000000,
        //             "InsideAsk":19069.320000000000000000000000,
        //             "InsideAskSize":0.0997360000000000000000000000,
        //             "IsQuote":false,
        //             "CounterPartyClientUserId":1,
        //             "NotionalProductId":2,
        //             "NotionalRate":1.0000000000000000000000000000,
        //             "NotionalValue":2345.5251300000000000000000000,
        //             "NotionalHoldAmount":0,
        //             "TradeTime":637431618315686826
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name ndax#cancelAllOrders
        * @description cancel all open orders
        * @see https://apidoc.ndax.io/#cancelallorders
        * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        await this.loadMarkets();
        await this.loadAccounts();
        object defaultAccountId = this.safeInteger2(this.options, "accountId", "AccountId", parseInt(getValue(getValue(this.accounts, 0), "id")));
        object accountId = this.safeInteger2(parameters, "accountId", "AccountId", defaultAccountId);
        parameters = this.omit(parameters, new List<object>() {"accountId", "AccountId"});
        object request = new Dictionary<string, object>() {
            { "omsId", omsId },
            { "AccountId", accountId },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["IntrumentId"] = getValue(market, "id");
        }
        object response = await this.privatePostCancelAllOrders(this.extend(request, parameters));
        //
        //     {
        //         "result":true,
        //         "errormsg":null,
        //         "errorcode":0,
        //         "detail":null
        //     }
        //
        return response;
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name ndax#cancelOrder
        * @description cancels an open order
        * @see https://apidoc.ndax.io/#cancelorder
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        await this.loadMarkets();
        await this.loadAccounts();
        // const defaultAccountId = this.safeInteger2 (this.options, 'accountId', 'AccountId', parseInt (this.accounts[0]['id']));
        // const accountId = this.safeInteger2 (params, 'accountId', 'AccountId', defaultAccountId);
        // params = this.omit (params, [ 'accountId', 'AccountId' ]);
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "omsId", omsId },
        };
        object clientOrderId = this.safeInteger2(parameters, "clientOrderId", "ClOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["ClOrderId"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["OrderId"] = parseInt(id);
        }
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "ClOrderId"});
        object response = await this.privatePostCancelOrder(this.extend(request, parameters));
        object order = this.parseOrder(response, market);
        return this.extend(order, new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", clientOrderId },
        });
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ndax#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://apidoc.ndax.io/#getopenorders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        await this.loadMarkets();
        await this.loadAccounts();
        object defaultAccountId = this.safeInteger2(this.options, "accountId", "AccountId", parseInt(getValue(getValue(this.accounts, 0), "id")));
        object accountId = this.safeInteger2(parameters, "accountId", "AccountId", defaultAccountId);
        parameters = this.omit(parameters, new List<object>() {"accountId", "AccountId"});
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "omsId", omsId },
            { "AccountId", accountId },
        };
        object response = await this.privateGetGetOpenOrders(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "Side":"Buy",
        //             "OrderId":2543565233,
        //             "Price":19010,
        //             "Quantity":0.345,
        //             "DisplayQuantity":0.345,
        //             "Instrument":8,
        //             "Account":449,
        //             "AccountName":"igor@ccxt.trade",
        //             "OrderType":"Limit",
        //             "ClientOrderId":0,
        //             "OrderState":"Working",
        //             "ReceiveTime":1607579326003,
        //             "ReceiveTimeTicks":637431761260028981,
        //             "LastUpdatedTime":1607579326005,
        //             "LastUpdatedTimeTicks":637431761260054714,
        //             "OrigQuantity":0.345,
        //             "QuantityExecuted":0,
        //             "GrossValueExecuted":0,
        //             "ExecutableValue":0,
        //             "AvgPrice":0,
        //             "CounterPartyId":0,
        //             "ChangeReason":"NewInputAccepted",
        //             "OrigOrderId":2543565233,
        //             "OrigClOrdId":0,
        //             "EnteredBy":446,
        //             "UserName":"igor@ccxt.trade",
        //             "IsQuote":false,
        //             "InsideAsk":19069.32,
        //             "InsideAskSize":0.099736,
        //             "InsideBid":19068.25,
        //             "InsideBidSize":1.330001,
        //             "LastTradePrice":19068.25,
        //             "RejectReason":"",
        //             "IsLockedIn":false,
        //             "CancelReason":"",
        //             "OrderFlag":"AddedToBook",
        //             "UseMargin":false,
        //             "StopPrice":0,
        //             "PegPriceType":"Unknown",
        //             "PegOffset":0,
        //             "PegLimitOffset":0,
        //             "IpAddress":null,
        //             "ClientOrderIdUuid":null,
        //             "OMSId":1
        //         }
        //     ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ndax#fetchOrders
        * @description fetches information on multiple orders made by the user
        * @see https://apidoc.ndax.io/#getorderhistory
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        await this.loadMarkets();
        await this.loadAccounts();
        object defaultAccountId = this.safeInteger2(this.options, "accountId", "AccountId", parseInt(getValue(getValue(this.accounts, 0), "id")));
        object accountId = this.safeInteger2(parameters, "accountId", "AccountId", defaultAccountId);
        parameters = this.omit(parameters, new List<object>() {"accountId", "AccountId"});
        object request = new Dictionary<string, object>() {
            { "omsId", omsId },
            { "AccountId", accountId },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["InstrumentId"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["StartTimeStamp"] = this.parseToInt(divide(since, 1000));
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["Depth"] = limit;
        }
        object response = await this.privateGetGetOrdersHistory(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "Side":"Buy",
        //             "OrderId":2543565233,
        //             "Price":19010.000000000000000000000000,
        //             "Quantity":0.0000000000000000000000000000,
        //             "DisplayQuantity":0.3450000000000000000000000000,
        //             "Instrument":8,
        //             "Account":449,
        //             "AccountName":"igor@ccxt.trade",
        //             "OrderType":"Limit",
        //             "ClientOrderId":0,
        //             "OrderState":"Canceled",
        //             "ReceiveTime":1607579326003,
        //             "ReceiveTimeTicks":637431761260028981,
        //             "LastUpdatedTime":1607580965346,
        //             "LastUpdatedTimeTicks":637431777653463754,
        //             "OrigQuantity":0.3450000000000000000000000000,
        //             "QuantityExecuted":0.0000000000000000000000000000,
        //             "GrossValueExecuted":0.0000000000000000000000000000,
        //             "ExecutableValue":0.0000000000000000000000000000,
        //             "AvgPrice":0.0000000000000000000000000000,
        //             "CounterPartyId":0,
        //             "ChangeReason":"UserModified",
        //             "OrigOrderId":2543565233,
        //             "OrigClOrdId":0,
        //             "EnteredBy":446,
        //             "UserName":"igor@ccxt.trade",
        //             "IsQuote":false,
        //             "InsideAsk":19069.320000000000000000000000,
        //             "InsideAskSize":0.0997360000000000000000000000,
        //             "InsideBid":19068.250000000000000000000000,
        //             "InsideBidSize":1.3300010000000000000000000000,
        //             "LastTradePrice":19068.250000000000000000000000,
        //             "RejectReason":"",
        //             "IsLockedIn":false,
        //             "CancelReason":"UserModified",
        //             "OrderFlag":"AddedToBook, RemovedFromBook",
        //             "UseMargin":false,
        //             "StopPrice":0.0000000000000000000000000000,
        //             "PegPriceType":"Unknown",
        //             "PegOffset":0.0000000000000000000000000000,
        //             "PegLimitOffset":0.0000000000000000000000000000,
        //             "IpAddress":"x.x.x.x",
        //             "ClientOrderIdUuid":null,
        //             "OMSId":1
        //         },
        //     ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name ndax#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://apidoc.ndax.io/#getorderstatus
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        await this.loadMarkets();
        await this.loadAccounts();
        object defaultAccountId = this.safeInteger2(this.options, "accountId", "AccountId", parseInt(getValue(getValue(this.accounts, 0), "id")));
        object accountId = this.safeInteger2(parameters, "accountId", "AccountId", defaultAccountId);
        parameters = this.omit(parameters, new List<object>() {"accountId", "AccountId"});
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "omsId", omsId },
            { "AccountId", accountId },
            { "OrderId", parseInt(id) },
        };
        object response = await this.privateGetGetOrderStatus(this.extend(request, parameters));
        //
        //     {
        //         "Side":"Sell",
        //         "OrderId":2543565232,
        //         "Price":0.0000000000000000000000000000,
        //         "Quantity":0.0000000000000000000000000000,
        //         "DisplayQuantity":0.0000000000000000000000000000,
        //         "Instrument":8,
        //         "Account":449,
        //         "AccountName":"igor@ccxt.trade",
        //         "OrderType":"Market",
        //         "ClientOrderId":0,
        //         "OrderState":"FullyExecuted",
        //         "ReceiveTime":1607569475591,
        //         "ReceiveTimeTicks":637431662755912377,
        //         "LastUpdatedTime":1607569475596,
        //         "LastUpdatedTimeTicks":637431662755960902,
        //         "OrigQuantity":1.0000000000000000000000000000,
        //         "QuantityExecuted":1.0000000000000000000000000000,
        //         "GrossValueExecuted":19068.270478610000000000000000,
        //         "ExecutableValue":0.0000000000000000000000000000,
        //         "AvgPrice":19068.270478610000000000000000,
        //         "CounterPartyId":0,
        //         "ChangeReason":"Trade",
        //         "OrigOrderId":2543565232,
        //         "OrigClOrdId":0,
        //         "EnteredBy":446,
        //         "UserName":"igor@ccxt.trade",
        //         "IsQuote":false,
        //         "InsideAsk":19069.320000000000000000000000,
        //         "InsideAskSize":0.0997360000000000000000000000,
        //         "InsideBid":19069.310000000000000000000000,
        //         "InsideBidSize":0.2400950000000000000000000000,
        //         "LastTradePrice":19069.310000000000000000000000,
        //         "RejectReason":"",
        //         "IsLockedIn":false,
        //         "CancelReason":"",
        //         "OrderFlag":"0",
        //         "UseMargin":false,
        //         "StopPrice":0.0000000000000000000000000000,
        //         "PegPriceType":"Unknown",
        //         "PegOffset":0.0000000000000000000000000000,
        //         "PegLimitOffset":0.0000000000000000000000000000,
        //         "IpAddress":"x.x.x.x",
        //         "ClientOrderIdUuid":null,
        //         "OMSId":1
        //     }
        //
        return this.parseOrder(response, market);
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ndax#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @see https://apidoc.ndax.io/#getorderhistorybyorderid
        * @param {string} id order id
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        await this.loadMarkets();
        await this.loadAccounts();
        // const defaultAccountId = this.safeInteger2 (this.options, 'accountId', 'AccountId', parseInt (this.accounts[0]['id']));
        // const accountId = this.safeInteger2 (params, 'accountId', 'AccountId', defaultAccountId);
        // params = this.omit (params, [ 'accountId', 'AccountId' ]);
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "OMSId", this.parseToInt(omsId) },
            { "OrderId", parseInt(id) },
        };
        object response = await this.privatePostGetOrderHistoryByOrderId(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "Side":"Sell",
        //             "OrderId":2543565235,
        //             "Price":18600.000000000000000000000000,
        //             "Quantity":0.0000000000000000000000000000,
        //             "DisplayQuantity":0.0000000000000000000000000000,
        //             "Instrument":8,
        //             "Account":449,
        //             "AccountName":"igor@ccxt.trade",
        //             "OrderType":"Limit",
        //             "ClientOrderId":0,
        //             "OrderState":"FullyExecuted",
        //             "ReceiveTime":1607585844956,
        //             "ReceiveTimeTicks":637431826449564182,
        //             "LastUpdatedTime":1607585844959,
        //             "LastUpdatedTimeTicks":637431826449593893,
        //             "OrigQuantity":0.1230000000000000000000000000,
        //             "QuantityExecuted":0.1230000000000000000000000000,
        //             "GrossValueExecuted":2345.3947500000000000000000000,
        //             "ExecutableValue":0.0000000000000000000000000000,
        //             "AvgPrice":19068.250000000000000000000000,
        //             "CounterPartyId":0,
        //             "ChangeReason":"Trade",
        //             "OrigOrderId":2543565235,
        //             "OrigClOrdId":0,
        //             "EnteredBy":446,
        //             "UserName":"igor@ccxt.trade",
        //             "IsQuote":false,
        //             "InsideAsk":19069.320000000000000000000000,
        //             "InsideAskSize":0.0997360000000000000000000000,
        //             "InsideBid":19068.250000000000000000000000,
        //             "InsideBidSize":1.3300010000000000000000000000,
        //             "LastTradePrice":19068.250000000000000000000000,
        //             "RejectReason":"",
        //             "IsLockedIn":false,
        //             "CancelReason":"",
        //             "OrderFlag":"0",
        //             "UseMargin":false,
        //             "StopPrice":0.0000000000000000000000000000,
        //             "PegPriceType":"Unknown",
        //             "PegOffset":0.0000000000000000000000000000,
        //             "PegLimitOffset":0.0000000000000000000000000000,
        //             "IpAddress":"x.x.x.x",
        //             "ClientOrderIdUuid":null,
        //             "OMSId":1
        //         },
        //     ]
        //
        object grouped = this.groupBy(response, "ChangeReason");
        object trades = this.safeValue(grouped, "Trade", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name ndax#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        await this.loadMarkets();
        await this.loadAccounts();
        object defaultAccountId = this.safeInteger2(this.options, "accountId", "AccountId", parseInt(getValue(getValue(this.accounts, 0), "id")));
        object accountId = this.safeInteger2(parameters, "accountId", "AccountId", defaultAccountId);
        parameters = this.omit(parameters, new List<object>() {"accountId", "AccountId"});
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "omsId", omsId },
            { "AccountId", accountId },
            { "ProductId", getValue(currency, "id") },
            { "GenerateNewKey", false },
        };
        object response = await this.privateGetGetDepositInfo(this.extend(request, parameters));
        //
        //     {
        //         "result":true,
        //         "errormsg":null,
        //         "statuscode":0,
        //         "AssetManagerId":1,
        //         "AccountId":57922,
        //         "AssetId":16,
        //         "ProviderId":23,
        //         "DepositInfo":"[\"0x8A27564b5c30b91C93B1591821642420F323a210\"]"
        //     }
        //
        return this.parseDepositAddress(response, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        // fetchDepositAddress, createDepositAddress
        //
        //     {
        //         "result":true,
        //         "errormsg":null,
        //         "statuscode":0,
        //         "AssetManagerId":1,
        //         "AccountId":449,
        //         "AssetId":1,
        //         "ProviderId":1,
        //         "DepositInfo":"[\"r3e95RwVsLH7yCbnMfyh7SA8FdwUJCB4S2?memo=241452010\"]"
        //     }
        //
        object depositInfoString = this.safeString(depositAddress, "DepositInfo");
        object depositInfo = parseJson(depositInfoString);
        object depositInfoLength = getArrayLength(depositInfo);
        object lastString = this.safeString(depositInfo, subtract(depositInfoLength, 1));
        object parts = ((string)lastString).Split(new [] {((string)"?memo=")}, StringSplitOptions.None).ToList<object>();
        object address = this.safeString(parts, 0);
        object tag = this.safeString(parts, 1);
        object code = null;
        if (isTrue(!isEqual(currency, null)))
        {
            code = getValue(currency, "code");
        }
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", null },
            { "info", depositAddress },
        };
    }

    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name ndax#createDepositAddress
        * @description create a currency deposit address
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "GenerateNewKey", true },
        };
        return await this.fetchDepositAddress(code, this.extend(request, parameters));
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ndax#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://apidoc.ndax.io/#getdeposits
        * @param {string} code unified currency code
        * @param {int} [since] not used by ndax fetchDeposits
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        await this.loadMarkets();
        await this.loadAccounts();
        object defaultAccountId = this.safeInteger2(this.options, "accountId", "AccountId", parseInt(getValue(getValue(this.accounts, 0), "id")));
        object accountId = this.safeInteger2(parameters, "accountId", "AccountId", defaultAccountId);
        parameters = this.omit(parameters, new List<object>() {"accountId", "AccountId"});
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object request = new Dictionary<string, object>() {
            { "omsId", omsId },
            { "AccountId", accountId },
        };
        object response = await this.privateGetGetDeposits(this.extend(request, parameters));
        //
        //    "[
        //        {
        //            "OMSId": 1,
        //            "DepositId": 44,
        //            "AccountId": 449,
        //            "SubAccountId": 0,
        //            "ProductId": 4,
        //            "Amount": 200.00000000000000000000000000,
        //            "LastUpdateTimeStamp": 637431291261187806,
        //            "ProductType": "CryptoCurrency",
        //            "TicketStatus": "FullyProcessed",
        //            "DepositInfo": "{
        //                "AccountProviderId":42,
        //                "AccountProviderName":"USDT_BSC",
        //                "TXId":"0x3879b02632c69482646409e991149290bc9a58e4603be63c7c2c90a843f45d2b",
        //                "FromAddress":"0x8894E0a0c962CB723c1976a4421c95949bE2D4E3",
        //                "ToAddress":"0x5428EcEB1F7Ee058f64158589e27D087149230CB"
        //            },",
        //            "DepositCode": "ab0e23d5-a9ce-4d94-865f-9ab464fb1de3",
        //            "TicketNumber": 71,
        //            "NotionalProductId": 13,
        //            "NotionalValue": 200.00000000000000000000000000,
        //            "FeeAmount": 0.0000000000000000000000000000,
        //        },
        //        ...
        //    ]"
        //
        if (isTrue((response is string)))
        {
            return this.parseTransactions(parseJson(response), currency, since, limit);
        }
        return this.parseTransactions(response, currency, since, limit);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ndax#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://apidoc.ndax.io/#getwithdraws
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object omsId = this.safeInteger(this.options, "omsId", 1);
        await this.loadMarkets();
        await this.loadAccounts();
        object defaultAccountId = this.safeInteger2(this.options, "accountId", "AccountId", parseInt(getValue(getValue(this.accounts, 0), "id")));
        object accountId = this.safeInteger2(parameters, "accountId", "AccountId", defaultAccountId);
        parameters = this.omit(parameters, new List<object>() {"accountId", "AccountId"});
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object request = new Dictionary<string, object>() {
            { "omsId", omsId },
            { "AccountId", accountId },
        };
        object response = await this.privateGetGetWithdraws(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "Amount": 0.0,
        //             "FeeAmount": 0.0,
        //             "NotionalValue": 0.0,
        //             "WithdrawId": 0,
        //             "AssetManagerId": 0,
        //             "AccountId": 0,
        //             "AssetId": 0,
        //             "TemplateForm": "{\"TemplateType\": \"TetherRPCWithdraw\",\"Comment\": \"TestWithdraw\",\"ExternalAddress\": \"ms6C3pKAAr8gRCcnVebs8VRkVrjcvqNYv3\"}",
        //             "TemplateFormType": "TetherRPCWithdraw",
        //             "omsId": 0,
        //             "TicketStatus": 0,
        //             "TicketNumber": 0,
        //             "WithdrawTransactionDetails": "",
        //             "WithdrawType": "",
        //             "WithdrawCode": "490b4fa3-53fc-44f4-bd29-7e16be86fba3",
        //             "AssetType": 0,
        //             "Reaccepted": true,
        //             "NotionalProductId": 0
        //         },
        //     ]
        //
        return this.parseTransactions(response, currency, since, limit);
    }

    public virtual object parseTransactionStatusByType(object status, object type = null)
    {
        object statusesByType = new Dictionary<string, object>() {
            { "deposit", new Dictionary<string, object>() {
                { "New", "pending" },
                { "AdminProcessing", "pending" },
                { "Accepted", "pending" },
                { "Rejected", "rejected" },
                { "SystemProcessing", "pending" },
                { "FullyProcessed", "ok" },
                { "Failed", "failed" },
                { "Pending", "pending" },
                { "Confirmed", "pending" },
                { "AmlProcessing", "pending" },
                { "AmlAccepted", "pending" },
                { "AmlRejected", "rejected" },
                { "AmlFailed", "failed" },
                { "LimitsAccepted", "pending" },
                { "LimitsRejected", "rejected" },
            } },
            { "withdrawal", new Dictionary<string, object>() {
                { "New", "pending" },
                { "AdminProcessing", "pending" },
                { "Accepted", "pending" },
                { "Rejected", "rejected" },
                { "SystemProcessing", "pending" },
                { "FullyProcessed", "ok" },
                { "Failed", "failed" },
                { "Pending", "pending" },
                { "Pending2Fa", "pending" },
                { "AutoAccepted", "pending" },
                { "Delayed", "pending" },
                { "UserCanceled", "canceled" },
                { "AdminCanceled", "canceled" },
                { "AmlProcessing", "pending" },
                { "AmlAccepted", "pending" },
                { "AmlRejected", "rejected" },
                { "AmlFailed", "failed" },
                { "LimitsAccepted", "pending" },
                { "LimitsRejected", "rejected" },
                { "Submitted", "pending" },
                { "Confirmed", "pending" },
                { "ManuallyConfirmed", "pending" },
                { "Confirmed2Fa", "pending" },
            } },
        };
        object statuses = this.safeValue(statusesByType, type, new Dictionary<string, object>() {});
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //    {
        //        "OMSId": 1,
        //        "DepositId": 44,
        //        "AccountId": 449,
        //        "SubAccountId": 0,
        //        "ProductId": 4,
        //        "Amount": 200.00000000000000000000000000,
        //        "LastUpdateTimeStamp": 637431291261187806,
        //        "ProductType": "CryptoCurrency",
        //        "TicketStatus": "FullyProcessed",
        //        "DepositInfo": "{
        //            "AccountProviderId":42,
        //            "AccountProviderName":"USDT_BSC",
        //            "TXId":"0x3879b02632c69482646409e991149290bc9a58e4603be63c7c2c90a843f45d2b",
        //            "FromAddress":"0x8894E0a0c962CB723c1976a4421c95949bE2D4E3",
        //            "ToAddress":"0x5428EcEB1F7Ee058f64158589e27D087149230CB"
        //        }",
        //        "DepositCode": "ab0e23d5-a9ce-4d94-865f-9ab464fb1de3",
        //        "TicketNumber": 71,
        //        "NotionalProductId": 13,
        //        "NotionalValue": 200.00000000000000000000000000,
        //        "FeeAmount": 0.0000000000000000000000000000,
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "Amount": 0.0,
        //         "FeeAmount": 0.0,
        //         "NotionalValue": 0.0,
        //         "WithdrawId": 0,
        //         "AssetManagerId": 0,
        //         "AccountId": 0,
        //         "AssetId": 0,
        //         "TemplateForm": "{\"TemplateType\": \"TetherRPCWithdraw\",\"Comment\": \"TestWithdraw\",\"ExternalAddress\": \"ms6C3pKAAr8gRCcnVebs8VRkVrjcvqNYv3\"}",
        //         "TemplateFormType": "TetherRPCWithdraw",
        //         "omsId": 0,
        //         "TicketStatus": 0,
        //         "TicketNumber": 0,
        //         "WithdrawTransactionDetails": "",
        //         "WithdrawType": "",
        //         "WithdrawCode": "490b4fa3-53fc-44f4-bd29-7e16be86fba3",
        //         "AssetType": 0,
        //         "Reaccepted": true,
        //         "NotionalProductId": 0
        //     }
        //
        object id = null;
        object currencyId = this.safeString(transaction, "ProductId");
        object code = this.safeCurrencyCode(currencyId, currency);
        object type = null;
        if (isTrue(inOp(transaction, "DepositId")))
        {
            id = this.safeString(transaction, "DepositId");
            type = "deposit";
        } else if (isTrue(inOp(transaction, "WithdrawId")))
        {
            id = this.safeString(transaction, "WithdrawId");
            type = "withdrawal";
        }
        object templateForm = this.parseJson(this.safeValue2(transaction, "TemplateForm", "DepositInfo"));
        object updated = this.safeInteger(transaction, "LastUpdateTimeStamp");
        if (isTrue(!isEqual(templateForm, null)))
        {
            updated = this.safeInteger(templateForm, "LastUpdated", updated);
        }
        object address = this.safeString2(templateForm, "ExternalAddress", "ToAddress");
        object timestamp = this.safeInteger(templateForm, "TimeSubmitted");
        object feeCost = this.safeNumber(transaction, "FeeAmount");
        object transactionStatus = this.safeString(transaction, "TicketStatus");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "currency", code },
                { "cost", feeCost },
            };
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", this.safeString2(templateForm, "TxId", "TXId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "address", address },
            { "addressTo", address },
            { "addressFrom", this.safeString(templateForm, "FromAddress") },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", type },
            { "amount", this.safeNumber(transaction, "Amount") },
            { "currency", code },
            { "status", this.parseTransactionStatusByType(transactionStatus, type) },
            { "updated", updated },
            { "fee", fee },
            { "internal", null },
            { "comment", null },
            { "network", null },
        };
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name ndax#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        // this method required login, password and twofa key
        object sessionToken = this.safeString(this.options, "sessionToken");
        if (isTrue(isEqual(sessionToken, null)))
        {
            throw new AuthenticationError ((string)add(this.id, " call signIn() method to obtain a session token")) ;
        }
        if (isTrue(isEqual(this.twofa, null)))
        {
            throw new AuthenticationError ((string)add(this.id, " withdraw() requires exchange.twofa credentials")) ;
        }
        this.checkAddress(address);
        object omsId = this.safeInteger(this.options, "omsId", 1);
        await this.loadMarkets();
        await this.loadAccounts();
        object defaultAccountId = this.safeInteger2(this.options, "accountId", "AccountId", parseInt(getValue(getValue(this.accounts, 0), "id")));
        object accountId = this.safeInteger2(parameters, "accountId", "AccountId", defaultAccountId);
        parameters = this.omit(parameters, new List<object>() {"accountId", "AccountId"});
        object currency = this.currency(code);
        object withdrawTemplateTypesRequest = new Dictionary<string, object>() {
            { "omsId", omsId },
            { "AccountId", accountId },
            { "ProductId", getValue(currency, "id") },
        };
        object withdrawTemplateTypesResponse = await this.privateGetGetWithdrawTemplateTypes(withdrawTemplateTypesRequest);
        //
        //     {
        //         "result": true,
        //         "errormsg": null,
        //         "statuscode": "0",
        //         "TemplateTypes": [
        //             { AccountProviderId: "14", TemplateName: "ToExternalBitcoinAddress", AccountProviderName: "BitgoRPC-BTC" },
        //             { AccountProviderId: "20", TemplateName: "ToExternalBitcoinAddress", AccountProviderName: "TrezorBTC" },
        //             { AccountProviderId: "31", TemplateName: "BTC", AccountProviderName: "BTC Fireblocks 1" }
        //         ]
        //     }
        //
        object templateTypes = this.safeValue(withdrawTemplateTypesResponse, "TemplateTypes", new List<object>() {});
        object firstTemplateType = this.safeValue(templateTypes, 0);
        if (isTrue(isEqual(firstTemplateType, null)))
        {
            throw new ExchangeError ((string)add(add(this.id, " withdraw() could not find a withdraw template type for "), getValue(currency, "code"))) ;
        }
        object templateName = this.safeString(firstTemplateType, "TemplateName");
        object withdrawTemplateRequest = new Dictionary<string, object>() {
            { "omsId", omsId },
            { "AccountId", accountId },
            { "ProductId", getValue(currency, "id") },
            { "TemplateType", templateName },
            { "AccountProviderId", getValue(firstTemplateType, "AccountProviderId") },
        };
        object withdrawTemplateResponse = await this.privateGetGetWithdrawTemplate(withdrawTemplateRequest);
        //
        //     {
        //         "result": true,
        //         "errormsg": null,
        //         "statuscode": "0",
        //         "Template": "{\"TemplateType\":\"ToExternalBitcoinAddress\",\"Comment\":\"\",\"ExternalAddress\":\"\"}"
        //     }
        //
        object template = this.safeString(withdrawTemplateResponse, "Template");
        if (isTrue(isEqual(template, null)))
        {
            throw new ExchangeError ((string)add(add(this.id, " withdraw() could not find a withdraw template for "), getValue(currency, "code"))) ;
        }
        object withdrawTemplate = parseJson(template);
        ((IDictionary<string,object>)withdrawTemplate)["ExternalAddress"] = address;
        if (isTrue(!isEqual(tag, null)))
        {
            if (isTrue(inOp(withdrawTemplate, "Memo")))
            {
                ((IDictionary<string,object>)withdrawTemplate)["Memo"] = tag;
            }
        }
        object withdrawPayload = new Dictionary<string, object>() {
            { "omsId", omsId },
            { "AccountId", accountId },
            { "ProductId", getValue(currency, "id") },
            { "TemplateForm", this.json(withdrawTemplate) },
            { "TemplateType", templateName },
        };
        object withdrawRequest = new Dictionary<string, object>() {
            { "TfaType", "Google" },
            { "TFaCode", totp(this.twofa) },
            { "Payload", this.json(withdrawPayload) },
        };
        object response = await this.privatePostCreateWithdrawTicket(this.deepExtend(withdrawRequest, parameters));
        return this.parseTransaction(response, currency);
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(getValue(getValue(this.urls, "api"), api), "/"), this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(isEqual(api, "public")))
        {
            if (isTrue(isEqual(path, "Authenticate")))
            {
                object auth = add(add(this.login, ":"), this.password);
                object auth64 = this.stringToBase64(auth);
                headers = new Dictionary<string, object>() {
                    { "Authorization", add("Basic ", auth64) },
                };
            } else if (isTrue(isEqual(path, "Authenticate2FA")))
            {
                object pending2faToken = this.safeString(this.options, "pending2faToken");
                if (isTrue(!isEqual(pending2faToken, null)))
                {
                    headers = new Dictionary<string, object>() {
                        { "Pending2FaToken", pending2faToken },
                    };
                    query = this.omit(query, "pending2faToken");
                }
            }
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object sessionToken = this.safeString(this.options, "sessionToken");
            if (isTrue(isEqual(sessionToken, null)))
            {
                object nonce = ((object)this.nonce()).ToString();
                object auth = add(add(nonce, this.uid), this.apiKey);
                object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
                headers = new Dictionary<string, object>() {
                    { "Nonce", nonce },
                    { "APIKey", this.apiKey },
                    { "Signature", signature },
                    { "UserId", this.uid },
                };
            } else
            {
                headers = new Dictionary<string, object>() {
                    { "APToken", sessionToken },
                };
            }
            if (isTrue(isEqual(method, "POST")))
            {
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
                body = this.json(query);
            } else
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    url = add(url, add("?", this.urlencode(query)));
                }
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(code, 404)))
        {
            throw new AuthenticationError ((string)add(add(this.id, " "), body)) ;
        }
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        //
        //     {"status":"Rejected","errormsg":"Not_Enough_Funds","errorcode":101}
        //     {"result":false,"errormsg":"Server Error","errorcode":102,"detail":null}
        //
        object message = this.safeString(response, "errormsg");
        if (isTrue(isTrue((!isEqual(message, null))) && isTrue((!isEqual(message, "")))))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
