namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class coinbasepro : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "coinbasepro" },
            { "name", "Coinbase Pro(Deprecated)" },
            { "countries", new List<object>() {"US"} },
            { "rateLimit", 100 },
            { "userAgent", getValue(this.userAgents, "chrome") },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", true },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createDepositAddress", true },
                { "createOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", false },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", true },
                { "fetchFundingRate", false },
                { "fetchLedger", true },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchOrderTrades", true },
                { "fetchPosition", false },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsForSymbol", false },
                { "fetchPositionsHistory", false },
                { "fetchPositionsRisk", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", true },
                { "fetchTransactions", "emulated" },
                { "fetchWithdrawals", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", 60 },
                { "5m", 300 },
                { "15m", 900 },
                { "1h", 3600 },
                { "6h", 21600 },
                { "1d", 86400 },
            } },
            { "hostname", "pro.coinbase.com" },
            { "urls", new Dictionary<string, object>() {
                { "test", new Dictionary<string, object>() {
                    { "public", "https://api-public.sandbox.pro.coinbase.com" },
                    { "private", "https://api-public.sandbox.pro.coinbase.com" },
                } },
                { "logo", "https://user-images.githubusercontent.com/1294454/41764625-63b7ffde-760a-11e8-996d-a6328fa9347a.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.{hostname}" },
                    { "private", "https://api.{hostname}" },
                } },
                { "www", "https://pro.coinbase.com/" },
                { "doc", "https://docs.pro.coinbase.com" },
                { "fees", new List<object>() {"https://docs.pro.coinbase.com/#fees", "https://support.pro.coinbase.com/customer/en/portal/articles/2945310-fees"} },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "password", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"currencies", "products", "products/{id}", "products/{id}/book", "products/{id}/candles", "products/{id}/stats", "products/{id}/ticker", "products/{id}/trades", "time", "products/spark-lines"} },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new List<object>() {"address-book", "accounts", "accounts/{id}", "accounts/{id}/holds", "accounts/{id}/ledger", "accounts/{id}/transfers", "coinbase-accounts", "fills", "funding", "fees", "margin/profile_information", "margin/buying_power", "margin/withdrawal_power", "margin/withdrawal_power_all", "margin/exit_plan", "margin/liquidation_history", "margin/position_refresh_amounts", "margin/status", "oracle", "orders", "orders/{id}", "orders/client:{client_oid}", "otc/orders", "payment-methods", "position", "profiles", "profiles/{id}", "reports/{report_id}", "transfers", "transfers/{transfer_id}", "users/self/exchange-limits", "users/self/hold-balances", "users/self/trailing-volume", "withdrawals/fee-estimate", "conversions/{conversion_id}", "conversions/fees"} },
                    { "post", new List<object>() {"conversions", "deposits/coinbase-account", "deposits/payment-method", "coinbase-accounts/{id}/addresses", "funding/repay", "orders", "position/close", "profiles/margin-transfer", "profiles/transfer", "reports", "withdrawals/coinbase", "withdrawals/coinbase-account", "withdrawals/crypto", "withdrawals/payment-method"} },
                    { "delete", new List<object>() {"orders", "orders/client:{client_oid}", "orders/{id}"} },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "CGLD", "CELO" },
            } },
            { "precisionMode", TICK_SIZE },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.004") },
                    { "taker", this.parseNumber("0.006") },
                } },
                { "funding", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", false },
                    { "withdraw", new Dictionary<string, object>() {
                        { "BCH", 0 },
                        { "BTC", 0 },
                        { "LTC", 0 },
                        { "ETH", 0 },
                        { "EUR", 0.15 },
                        { "USD", 25 },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "BCH", 0 },
                        { "BTC", 0 },
                        { "LTC", 0 },
                        { "ETH", 0 },
                        { "EUR", 0.15 },
                        { "USD", 10 },
                    } },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "Insufficient funds", typeof(InsufficientFunds) },
                    { "NotFound", typeof(OrderNotFound) },
                    { "Invalid API Key", typeof(AuthenticationError) },
                    { "invalid signature", typeof(AuthenticationError) },
                    { "Invalid Passphrase", typeof(AuthenticationError) },
                    { "Invalid order id", typeof(InvalidOrder) },
                    { "Private rate limit exceeded", typeof(RateLimitExceeded) },
                    { "Trading pair not available", typeof(PermissionDenied) },
                    { "Product not found", typeof(InvalidOrder) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Order already done", typeof(OrderNotFound) },
                    { "order not found", typeof(OrderNotFound) },
                    { "price too small", typeof(InvalidOrder) },
                    { "price too precise", typeof(InvalidOrder) },
                    { "under maintenance", typeof(OnMaintenance) },
                    { "size is too small", typeof(InvalidOrder) },
                    { "Cancel only mode", typeof(OnMaintenance) },
                } },
            } },
        });
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getcurrencies
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetCurrencies(parameters);
        //
        //     [
        //         {
        //             "id": "XTZ",
        //             "name": "Tezos",
        //             "min_size": "0.000001",
        //             "status": "online",
        //             "message": '',
        //             "max_precision": "0.000001",
        //             "convertible_to": [],
        //             "details": {
        //                 "type": "crypto",
        //                 "symbol": "Î¤",
        //                 "network_confirmations": 60,
        //                 "sort_order": 53,
        //                 "crypto_address_link": "https://tzstats.com/{{address}}",
        //                 "crypto_transaction_link": "https://tzstats.com/{{txId}}",
        //                 "push_payment_methods": [ "crypto" ],
        //                 "group_types": [],
        //                 "display_name": '',
        //                 "processing_time_seconds": 0,
        //                 "min_withdrawal_amount": 1
        //             }
        //         }
        //     ]
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object currency = getValue(response, i);
            object id = this.safeString(currency, "id");
            object name = this.safeString(currency, "name");
            object code = this.safeCurrencyCode(id);
            object details = this.safeValue(currency, "details", new Dictionary<string, object>() {});
            object status = this.safeString(currency, "status");
            object active = (isEqual(status, "online"));
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "code", code },
                { "info", currency },
                { "type", this.safeString(details, "type") },
                { "name", name },
                { "active", active },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "precision", this.safeNumber(currency, "max_precision") },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(details, "min_size") },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.safeNumber(details, "min_withdrawal_amount") },
                        { "max", null },
                    } },
                } },
                { "networks", new Dictionary<string, object>() {} },
            };
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchMarkets
        * @description retrieves data on all markets for coinbasepro
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getproducts
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetProducts(parameters);
        //
        //     [
        //         {
        //             "id": "BTCAUCTION-USD",
        //             "base_currency": "BTC",
        //             "quote_currency": "USD",
        //             "base_min_size": "0.000016",
        //             "base_max_size": "1500",
        //             "quote_increment": "0.01",
        //             "base_increment": "0.00000001",
        //             "display_name": "BTCAUCTION/USD",
        //             "min_market_funds": "1",
        //             "max_market_funds": "20000000",
        //             "margin_enabled": false,
        //             "fx_stablecoin": false,
        //             "max_slippage_percentage": "0.02000000",
        //             "post_only": false,
        //             "limit_only": false,
        //             "cancel_only": true,
        //             "trading_disabled": false,
        //             "status": "online",
        //             "status_message": '',
        //             "auction_mode": false
        //         },
        //         {
        //             "id": "BTC-USD",
        //             "base_currency": "BTC",
        //             "quote_currency": "USD",
        //             "base_min_size": "0.000016",
        //             "base_max_size": "1500",
        //             "quote_increment": "0.01",
        //             "base_increment": "0.00000001",
        //             "display_name": "BTC/USD",
        //             "min_market_funds": "1",
        //             "max_market_funds": "20000000",
        //             "margin_enabled": false,
        //             "fx_stablecoin": false,
        //             "max_slippage_percentage": "0.02000000",
        //             "post_only": false,
        //             "limit_only": false,
        //             "cancel_only": false,
        //             "trading_disabled": false,
        //             "status": "online",
        //             "status_message": '',
        //             "auction_mode": false
        //         }
        //     ]
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object market = getValue(response, i);
            object id = this.safeString(market, "id");
            var baseIdquoteIdVariable = ((string)id).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            var baseId = ((IList<object>) baseIdquoteIdVariable)[0];
            var quoteId = ((IList<object>) baseIdquoteIdVariable)[1];
            // BTCAUCTION-USD vs BTC-USD conflict workaround, see the output sample above
            // const baseId = this.safeString (market, 'base_currency');
            // const quoteId = this.safeString (market, 'quote_currency');
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object status = this.safeString(market, "status");
            ((IList<object>)result).Add(this.extend(getValue(this.fees, "trading"), new Dictionary<string, object>() {
                { "id", id },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", this.safeValue(market, "margin_enabled") },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", (isEqual(status, "online")) },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.safeNumber(market, "base_increment") },
                    { "price", this.safeNumber(market, "quote_increment") },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_market_funds") },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", market },
            }));
        }
        return result;
    }

    public async override Task<object> fetchAccounts(object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchAccounts
        * @description fetch all the accounts associated with a profile
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getaccounts
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetAccounts(parameters);
        //
        //     [
        //         {
        //             "id": "4aac9c60-cbda-4396-9da4-4aa71e95fba0",
        //             "currency": "BTC",
        //             "balance": "0.0000000000000000",
        //             "available": "0",
        //             "hold": "0.0000000000000000",
        //             "profile_id": "b709263e-f42a-4c7d-949a-a95c83d065da"
        //         },
        //         {
        //             "id": "f75fa69a-1ad1-4a80-bd61-ee7faa6135a3",
        //             "currency": "USDC",
        //             "balance": "0.0000000000000000",
        //             "available": "0",
        //             "hold": "0.0000000000000000",
        //             "profile_id": "b709263e-f42a-4c7d-949a-a95c83d065da"
        //         },
        //     ]
        //
        return this.parseAccounts(response, parameters);
    }

    public override object parseAccount(object account)
    {
        //
        //     {
        //         "id": "4aac9c60-cbda-4396-9da4-4aa71e95fba0",
        //         "currency": "BTC",
        //         "balance": "0.0000000000000000",
        //         "available": "0",
        //         "hold": "0.0000000000000000",
        //         "profile_id": "b709263e-f42a-4c7d-949a-a95c83d065da"
        //     }
        //
        object currencyId = this.safeString(account, "currency");
        return new Dictionary<string, object>() {
            { "id", this.safeString(account, "id") },
            { "type", null },
            { "code", this.safeCurrencyCode(currencyId) },
            { "info", account },
        };
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object balance = getValue(response, i);
            object currencyId = this.safeString(balance, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "available");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "hold");
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "balance");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getaccounts
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetAccounts(parameters);
        return this.parseBalance(response);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchOrderBook
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getproductbook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        // level 1 - only the best bid and ask
        // level 2 - top 50 bids and asks (aggregated)
        // level 3 - full order book (non aggregated)
        object request = new Dictionary<string, object>() {
            { "id", this.marketId(symbol) },
            { "level", 2 },
        };
        object response = await this.publicGetProductsIdBook(this.extend(request, parameters));
        //
        //     {
        //         "sequence":1924393896,
        //         "bids":[
        //             ["0.01825","24.34811287",2],
        //             ["0.01824","72.5463",3],
        //             ["0.01823","424.54298049",6],
        //         ],
        //         "asks":[
        //             ["0.01826","171.10414904",4],
        //             ["0.01827","22.60427028",1],
        //             ["0.01828","397.46018784",7],
        //         ]
        //     }
        //
        object orderbook = this.parseOrderBook(response, symbol);
        ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger(response, "sequence");
        return orderbook;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // fetchTickers
        //
        //      [
        //         1639472400, // timestamp
        //         4.26, // low
        //         4.38, // high
        //         4.35, // open
        //         4.27 // close
        //      ]
        //
        // fetchTicker
        //
        //     publicGetProductsIdTicker
        //
        //     {
        //         "trade_id":843439,
        //         "price":"0.997999",
        //         "size":"80.29769",
        //         "time":"2020-01-28T02:13:33.012523Z",
        //         "bid":"0.997094",
        //         "ask":"0.998",
        //         "volume":"1903188.03750000"
        //     }
        //
        //     publicGetProductsIdStats
        //
        //     {
        //         "open": "34.19000000",
        //         "high": "95.70000000",
        //         "low": "7.06000000",
        //         "volume": "2.41000000"
        //     }
        //
        object timestamp = null;
        object bid = null;
        object ask = null;
        object last = null;
        object high = null;
        object low = null;
        object open = null;
        object volume = null;
        object symbol = ((bool) isTrue((isEqual(market, null)))) ? null : getValue(market, "symbol");
        if (isTrue(((ticker is IList<object>) || (ticker.GetType().IsGenericType && ticker.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            last = this.safeString(ticker, 4);
            timestamp = this.milliseconds();
        } else
        {
            timestamp = this.parse8601(this.safeValue(ticker, "time"));
            bid = this.safeString(ticker, "bid");
            ask = this.safeString(ticker, "ask");
            high = this.safeString(ticker, "high");
            low = this.safeString(ticker, "low");
            open = this.safeString(ticker, "open");
            last = this.safeString2(ticker, "price", "last");
            volume = this.safeString(ticker, "volume");
        }
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", high },
            { "low", low },
            { "bid", bid },
            { "bidVolume", null },
            { "ask", ask },
            { "askVolume", null },
            { "vwap", null },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", volume },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getproduct
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {};
        object response = await this.publicGetProductsSparkLines(this.extend(request, parameters));
        //
        //     {
        //         YYY-USD: [
        //             [
        //                 1639472400, // timestamp
        //                 4.26, // low
        //                 4.38, // high
        //                 4.35, // open
        //                 4.27 // close
        //             ],
        //             [
        //                 1639468800,
        //                 4.31,
        //                 4.45,
        //                 4.35,
        //                 4.35
        //             ],
        //         ]
        //     }
        //
        object result = new Dictionary<string, object>() {};
        object marketIds = new List<object>(((IDictionary<string,object>)response).Keys);
        object delimiter = "-";
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = getValue(marketIds, i);
            object entry = this.safeValue(response, marketId, new List<object>() {});
            object first = this.safeValue(entry, 0, new List<object>() {});
            object market = this.safeMarket(marketId, null, delimiter);
            object symbol = getValue(market, "symbol");
            ((IDictionary<string,object>)result)[(string)symbol] = this.parseTicker(first, market);
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchTicker
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getproductticker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "id", getValue(market, "id") },
        };
        // publicGetProductsIdTicker or publicGetProductsIdStats
        object method = this.safeString(this.options, "fetchTickerMethod", "publicGetProductsIdTicker");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // publicGetProductsIdTicker
        //
        //     {
        //         "trade_id":843439,
        //         "price":"0.997999",
        //         "size":"80.29769",
        //         "time":"2020-01-28T02:13:33.012523Z",
        //         "bid":"0.997094",
        //         "ask":"0.998",
        //         "volume":"1903188.03750000"
        //     }
        //
        // publicGetProductsIdStats
        //
        //     {
        //         "open": "34.19000000",
        //         "high": "95.70000000",
        //         "low": "7.06000000",
        //         "volume": "2.41000000"
        //     }
        //
        return this.parseTicker(response, market);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        //     {
        //         "type": "match",
        //         "trade_id": 82047307,
        //         "maker_order_id": "0f358725-2134-435e-be11-753912a326e0",
        //         "taker_order_id": "252b7002-87a3-425c-ac73-f5b9e23f3caf",
        //         "order_id": "d50ec984-77a8-460a-b958-66f114b0de9b",
        //         "side": "sell",
        //         "size": "0.00513192",
        //         "price": "9314.78",
        //         "product_id": "BTC-USD",
        //         "profile_id": "6244401d-c078-40d9-b305-7ad3551bc3b0",
        //         "sequence": 12038915443,
        //         "time": "2020-01-31T20:03:41.158814Z"
        //         "created_at": "2014-11-07T22:19:28.578544Z",
        //         "liquidity": "T",
        //         "fee": "0.00025",
        //         "settled": true,
        //         "usd_volume": "0.0924556000000000",
        //         "user_id": "595eb864313c2b02ddf2937d"
        //     }
        //
        object timestamp = this.parse8601(this.safeString2(trade, "time", "created_at"));
        object marketId = this.safeString(trade, "product_id");
        market = this.safeMarket(marketId, market, "-");
        object feeRate = null;
        object takerOrMaker = null;
        object cost = null;
        object feeCurrencyId = this.safeStringLower(market, "quoteId");
        if (isTrue(!isEqual(feeCurrencyId, null)))
        {
            object costField = add(feeCurrencyId, "_value");
            cost = this.safeString(trade, costField);
            object liquidity = this.safeString(trade, "liquidity");
            if (isTrue(!isEqual(liquidity, null)))
            {
                takerOrMaker = ((bool) isTrue((isEqual(liquidity, "T")))) ? "taker" : "maker";
                feeRate = this.safeString(market, takerOrMaker);
            }
        }
        object feeCost = this.safeString2(trade, "fill_fees", "fee");
        object fee = new Dictionary<string, object>() {
            { "cost", feeCost },
            { "currency", getValue(market, "quote") },
            { "rate", feeRate },
        };
        object id = this.safeString(trade, "trade_id");
        object side = ((bool) isTrue((isEqual(getValue(trade, "side"), "buy")))) ? "sell" : "buy";
        object orderId = this.safeString(trade, "order_id");
        // Coinbase Pro returns inverted side to fetchMyTrades vs fetchTrades
        object makerOrderId = this.safeString(trade, "maker_order_id");
        object takerOrderId = this.safeString(trade, "taker_order_id");
        if (isTrue(isTrue((!isEqual(orderId, null))) || isTrue((isTrue((!isEqual(makerOrderId, null))) && isTrue((!isEqual(takerOrderId, null)))))))
        {
            side = ((bool) isTrue((isEqual(getValue(trade, "side"), "buy")))) ? "buy" : "sell";
        }
        object price = this.safeString(trade, "price");
        object amount = this.safeString(trade, "size");
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "order", orderId },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "type", null },
            { "takerOrMaker", takerOrMaker },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "fee", fee },
            { "cost", cost },
        }, market);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchMyTrades
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getfills
        * @description fetch all trades made by the user
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch trades for
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, parameters, 100);
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "product_id", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_date"] = this.iso8601(since);
        }
        object until = this.safeValue2(parameters, "until", "end_date");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)["end_date"] = this.iso8601(until);
        }
        object response = await this.privateGetFills(this.extend(request, parameters));
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchTrades
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getproducttrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "id", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100
        }
        object response = await this.publicGetProductsIdTrades(this.extend(request, parameters));
        //
        //    [
        //        {
        //            "trade_id": "15035219",
        //            "side": "sell",
        //            "size": "0.27426731",
        //            "price": "25820.42000000",
        //            "time": "2023-09-10T13:47:41.447577Z"
        //        },
        //    ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getfees
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetFees(parameters);
        //
        //    {
        //        "maker_fee_rate": "0.0050",
        //        "taker_fee_rate": "0.0050",
        //        "usd_volume": "43806.92"
        //    }
        //
        object maker = this.safeNumber(response, "maker_fee_rate");
        object taker = this.safeNumber(response, "taker_fee_rate");
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(this.symbols, i);
            ((IDictionary<string,object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "info", response },
                { "symbol", symbol },
                { "maker", maker },
                { "taker", taker },
                { "percentage", true },
                { "tierBased", true },
            };
        }
        return result;
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         1591514160,
        //         0.02507,
        //         0.02507,
        //         0.02507,
        //         0.02507,
        //         0.02816506
        //     ]
        //
        return new List<object> {this.safeTimestamp(ohlcv, 0), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchOHLCV
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getproductcandles
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch trades for
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate", false);
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, 300);
        }
        object market = this.market(symbol);
        object parsedTimeframe = this.safeInteger(this.timeframes, timeframe);
        object request = new Dictionary<string, object>() {
            { "id", getValue(market, "id") },
        };
        if (isTrue(!isEqual(parsedTimeframe, null)))
        {
            ((IDictionary<string,object>)request)["granularity"] = parsedTimeframe;
        } else
        {
            ((IDictionary<string,object>)request)["granularity"] = timeframe;
        }
        object until = this.safeValue2(parameters, "until", "end");
        parameters = this.omit(parameters, new List<object>() {"until"});
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = this.iso8601(since);
            if (isTrue(isEqual(limit, null)))
            {
                // https://docs.pro.coinbase.com/#get-historic-rates
                limit = 300; // max = 300
            } else
            {
                limit = mathMin(300, limit);
            }
            if (isTrue(isEqual(until, null)))
            {
                object parsedTimeframeMilliseconds = multiply(parsedTimeframe, 1000);
                if (isTrue(this.isRoundNumber(mod(since, parsedTimeframeMilliseconds))))
                {
                    ((IDictionary<string,object>)request)["end"] = this.iso8601(this.sum(multiply((subtract(limit, 1)), parsedTimeframeMilliseconds), since));
                } else
                {
                    ((IDictionary<string,object>)request)["end"] = this.iso8601(this.sum(multiply(limit, parsedTimeframeMilliseconds), since));
                }
            } else
            {
                ((IDictionary<string,object>)request)["end"] = this.iso8601(until);
            }
        }
        object response = await this.publicGetProductsIdCandles(this.extend(request, parameters));
        //
        //     [
        //         [1591514160,0.02507,0.02507,0.02507,0.02507,0.02816506],
        //         [1591514100,0.02507,0.02507,0.02507,0.02507,1.63830323],
        //         [1591514040,0.02505,0.02507,0.02505,0.02507,0.19918178]
        //     ]
        //
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetTime(parameters);
        //
        //     {
        //         "iso":"2020-05-12T08:00:51.504Z",
        //         "epoch":1589270451.504
        //     }
        //
        return this.safeTimestamp(response, "epoch");
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "pending", "open" },
            { "active", "open" },
            { "open", "open" },
            { "done", "closed" },
            { "canceled", "canceled" },
            { "canceling", "open" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //
        //     {
        //         "id": "d0c5340b-6d6c-49d9-b567-48c4bfca13d2",
        //         "price": "0.10000000",
        //         "size": "0.01000000",
        //         "product_id": "BTC-USD",
        //         "side": "buy",
        //         "stp": "dc",
        //         "type": "limit",
        //         "time_in_force": "GTC",
        //         "post_only": false,
        //         "created_at": "2016-12-08T20:02:28.53864Z",
        //         "fill_fees": "0.0000000000000000",
        //         "filled_size": "0.00000000",
        //         "executed_value": "0.0000000000000000",
        //         "status": "pending",
        //         "settled": false
        //     }
        //
        object timestamp = this.parse8601(this.safeString(order, "created_at"));
        object marketId = this.safeString(order, "product_id");
        market = this.safeMarket(marketId, market, "-");
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object doneReason = this.safeString(order, "done_reason");
        if (isTrue(isTrue((isEqual(status, "closed"))) && isTrue((isEqual(doneReason, "canceled")))))
        {
            status = "canceled";
        }
        object price = this.safeString(order, "price");
        object filled = this.safeString(order, "filled_size");
        object amount = this.safeString(order, "size", filled);
        object cost = this.safeString(order, "executed_value");
        object feeCost = this.safeNumber(order, "fill_fees");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", getValue(market, "quote") },
                { "rate", null },
            };
        }
        object id = this.safeString(order, "id");
        object type = this.safeString(order, "type");
        object side = this.safeString(order, "side");
        object timeInForce = this.safeString(order, "time_in_force");
        object postOnly = this.safeValue(order, "post_only");
        object stopPrice = this.safeNumber(order, "stop_price");
        object clientOrderId = this.safeString(order, "client_oid");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "info", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "status", status },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "cost", cost },
            { "amount", amount },
            { "filled", filled },
            { "remaining", null },
            { "fee", fee },
            { "average", null },
            { "trades", null },
        }, market);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchOrder
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getorder
        * @description fetches information on an order made by the user
        * @param {string} symbol not used by coinbasepro fetchOrder
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "client_oid");
        object method = null;
        if (isTrue(isEqual(clientOrderId, null)))
        {
            method = "privateGetOrdersId";
            ((IDictionary<string,object>)request)["id"] = id;
        } else
        {
            method = "privateGetOrdersClientClientOid";
            ((IDictionary<string,object>)request)["client_oid"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"clientOrderId", "client_oid"});
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        return this.parseOrder(response);
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @param {string} id order id
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        object response = await this.privateGetFills(this.extend(request, parameters));
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchOrders
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getorders
        * @description fetches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch open orders for
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "status", "all" },
        };
        return await this.fetchOpenOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchOpenOrders
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getorders
        * @description fetch all unfilled currently open orders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch open orders for
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchOpenOrders", symbol, since, limit, parameters, 100);
        }
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["product_id"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_date"] = this.iso8601(since);
        }
        object until = this.safeValue2(parameters, "until", "end_date");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)["end_date"] = this.iso8601(until);
        }
        object response = await this.privateGetOrders(this.extend(request, parameters));
        return this.parseOrders(response, market, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchClosedOrders
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getorders
        * @description fetches information on multiple closed orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch open orders for
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "status", "done" },
        };
        return await this.fetchOpenOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#createOrder
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_postorders
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "type", type },
            { "side", side },
            { "product_id", getValue(market, "id") },
        };
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "client_oid");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["client_oid"] = clientOrderId;
        }
        object stopPrice = this.safeNumberN(parameters, new List<object>() {"stopPrice", "stop_price", "triggerPrice"});
        if (isTrue(!isEqual(stopPrice, null)))
        {
            ((IDictionary<string,object>)request)["stop_price"] = this.priceToPrecision(symbol, stopPrice);
        }
        object timeInForce = this.safeString2(parameters, "timeInForce", "time_in_force");
        if (isTrue(!isEqual(timeInForce, null)))
        {
            ((IDictionary<string,object>)request)["time_in_force"] = timeInForce;
        }
        object postOnly = this.safeValue2(parameters, "postOnly", "post_only", false);
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["post_only"] = true;
        }
        parameters = this.omit(parameters, new List<object>() {"timeInForce", "time_in_force", "stopPrice", "stop_price", "clientOrderId", "client_oid", "postOnly", "post_only", "triggerPrice"});
        if (isTrue(isEqual(type, "limit")))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            ((IDictionary<string,object>)request)["size"] = this.amountToPrecision(symbol, amount);
        } else if (isTrue(isEqual(type, "market")))
        {
            object cost = this.safeNumber2(parameters, "cost", "funds");
            if (isTrue(isEqual(cost, null)))
            {
                if (isTrue(!isEqual(price, null)))
                {
                    cost = multiply(amount, price);
                }
            } else
            {
                parameters = this.omit(parameters, new List<object>() {"cost", "funds"});
            }
            if (isTrue(!isEqual(cost, null)))
            {
                ((IDictionary<string,object>)request)["funds"] = this.costToPrecision(symbol, cost);
            } else
            {
                ((IDictionary<string,object>)request)["size"] = this.amountToPrecision(symbol, amount);
            }
        }
        object response = await this.privatePostOrders(this.extend(request, parameters));
        //
        //     {
        //         "id": "d0c5340b-6d6c-49d9-b567-48c4bfca13d2",
        //         "price": "0.10000000",
        //         "size": "0.01000000",
        //         "product_id": "BTC-USD",
        //         "side": "buy",
        //         "stp": "dc",
        //         "type": "limit",
        //         "time_in_force": "GTC",
        //         "post_only": false,
        //         "created_at": "2016-12-08T20:02:28.53864Z",
        //         "fill_fees": "0.0000000000000000",
        //         "filled_size": "0.00000000",
        //         "executed_value": "0.0000000000000000",
        //         "status": "pending",
        //         "settled": false
        //     }
        //
        return this.parseOrder(response, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#cancelOrder
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_deleteorder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "client_oid");
        object method = null;
        if (isTrue(isEqual(clientOrderId, null)))
        {
            method = "privateDeleteOrdersId";
            ((IDictionary<string,object>)request)["id"] = id;
        } else
        {
            method = "privateDeleteOrdersClientClientOid";
            ((IDictionary<string,object>)request)["client_oid"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"clientOrderId", "client_oid"});
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["product_id"] = getValue(market, "symbol"); // the request will be more performant if you include it
        }
        return await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#cancelAllOrders
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_deleteorders
        * @description cancel all open orders
        * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["product_id"] = getValue(market, "symbol"); // the request will be more performant if you include it
        }
        return await this.privateDeleteOrders(this.extend(request, parameters));
    }

    public async override Task<object> fetchPaymentMethods(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.privateGetPaymentMethods(parameters);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#withdraw
        * @description make a withdrawal
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_postwithdrawpaymentmethod
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_postwithdrawcoinbaseaccount
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", amount },
        };
        object method = "privatePostWithdrawals";
        if (isTrue(inOp(parameters, "payment_method_id")))
        {
            method = add(method, "PaymentMethod");
        } else if (isTrue(inOp(parameters, "coinbase_account_id")))
        {
            method = add(method, "CoinbaseAccount");
        } else
        {
            method = add(method, "Crypto");
            ((IDictionary<string,object>)request)["crypto_address"] = address;
            if (isTrue(!isEqual(tag, null)))
            {
                ((IDictionary<string,object>)request)["destination_tag"] = tag;
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        if (!isTrue(response))
        {
            throw new ExchangeError ((string)add(add(this.id, " withdraw() error: "), this.json(response))) ;
        }
        return this.parseTransaction(response, currency);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "transfer", "transfer" },
            { "match", "trade" },
            { "fee", "fee" },
            { "rebate", "rebate" },
            { "conversion", "trade" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //  {
        //      "id": "12087495079",
        //      "amount": "-0.0100000000000000",
        //      "balance": "0.0645419900000000",
        //      "created_at": "2021-10-28T17:14:32.593168Z",
        //      "type": "transfer",
        //      "details": {
        //          "from": "2f74edf7-1440-4586-86dc-ae58c5693691",
        //          "profile_transfer_id": "3ef093ad-2482-40d1-8ede-2f89cff5099e",
        //          "to": "dda99503-4980-4b60-9549-0b770ee51336"
        //      }
        //  },
        //  {
        //     "id": "11740725774",
        //     "amount": "-1.7565669701255000",
        //     "balance": "0.0016490047745000",
        //     "created_at": "2021-10-22T03:47:34.764122Z",
        //     "type": "fee",
        //     "details": {
        //         "order_id": "ad06abf4-95ab-432a-a1d8-059ef572e296",
        //         "product_id": "ETH-DAI",
        //         "trade_id": "1740617"
        //     }
        //  }
        object id = this.safeString(item, "id");
        object amountString = this.safeString(item, "amount");
        object direction = null;
        object afterString = this.safeString(item, "balance");
        object beforeString = Precise.stringSub(afterString, amountString);
        if (isTrue(Precise.stringLt(amountString, "0")))
        {
            direction = "out";
            amountString = Precise.stringAbs(amountString);
        } else
        {
            direction = "in";
        }
        object amount = this.parseNumber(amountString);
        object after = this.parseNumber(afterString);
        object before = this.parseNumber(beforeString);
        object timestamp = this.parse8601(this.safeValue(item, "created_at"));
        object type = this.parseLedgerEntryType(this.safeString(item, "type"));
        object code = this.safeCurrencyCode(null, currency);
        object details = this.safeValue(item, "details", new Dictionary<string, object>() {});
        object account = null;
        object referenceAccount = null;
        object referenceId = null;
        if (isTrue(isEqual(type, "transfer")))
        {
            account = this.safeString(details, "from");
            referenceAccount = this.safeString(details, "to");
            referenceId = this.safeString(details, "profile_transfer_id");
        } else
        {
            referenceId = this.safeString(details, "order_id");
        }
        object status = "ok";
        return new Dictionary<string, object>() {
            { "id", id },
            { "currency", code },
            { "account", account },
            { "referenceAccount", referenceAccount },
            { "referenceId", referenceId },
            { "status", status },
            { "amount", amount },
            { "before", before },
            { "after", after },
            { "fee", null },
            { "direction", direction },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "type", type },
            { "info", item },
        };
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchLedger
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getaccountledger
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @param {string} code unified currency code, default is undefined
        * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int} [limit] max number of ledger entrys to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch trades for
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        // https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getaccountledger
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchLedger() requires a code param")) ;
        }
        await this.loadMarkets();
        await this.loadAccounts();
        object currency = this.currency(code);
        object accountsByCurrencyCode = this.indexBy(this.accounts, "code");
        object account = this.safeValue(accountsByCurrencyCode, code);
        if (isTrue(isEqual(account, null)))
        {
            throw new ExchangeError ((string)add(add(this.id, " fetchLedger() could not find account id for "), code)) ;
        }
        object request = new Dictionary<string, object>() {
            { "id", getValue(account, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_date"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100
        }
        object until = this.safeValue2(parameters, "until", "end_date");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)["end_date"] = this.iso8601(until);
        }
        object response = await this.privateGetAccountsIdLedger(this.extend(request, parameters));
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            ((IDictionary<string,object>)getValue(response, i))["currency"] = code;
        }
        return this.parseLedger(response, currency, since, limit);
    }

    public async override Task<object> fetchDepositsWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchDepositsWithdrawals
        * @description fetch history of deposits and withdrawals
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_gettransfers
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getaccounttransfers
        * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
        * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
        * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.id] account id, when defined, the endpoint used is '/accounts/{account_id}/transfers/' instead of '/transfers/'
        * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object currency = null;
        object id = this.safeString(parameters, "id"); // account id
        if (isTrue(isEqual(id, null)))
        {
            if (isTrue(!isEqual(code, null)))
            {
                currency = this.currency(code);
                object accountsByCurrencyCode = this.indexBy(this.accounts, "code");
                object account = this.safeValue(accountsByCurrencyCode, code);
                if (isTrue(isEqual(account, null)))
                {
                    throw new ExchangeError ((string)add(add(this.id, " fetchDepositsWithdrawals() could not find account id for "), code)) ;
                }
                id = getValue(account, "id");
            }
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(id, null)))
        {
            ((IDictionary<string,object>)request)["id"] = id;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(isEqual(id, null)))
        {
            response = await this.privateGetTransfers(this.extend(request, parameters));
            //
            //    [
            //        {
            //            "id": "bee6fd7c-afb2-4e47-8298-671d09997d16",
            //            "type": "deposit",
            //            "created_at": "2022-12-21 00:48:45.477503+00",
            //            "completed_at": null,
            //            "account_id": "sal3802-36bd-46be-a7b8-alsjf383sldak",
            //            "user_id": "6382048209f92as392039dlks2",
            //            "amount": "0.01000000",
            //            "details": {
            //                "network": "litecoin",
            //                "crypto_address": "MKemtnCFUYKsNWaf5EMYMpwSszcXWFDtTY",
            //                "coinbase_account_id": "fl2b6925-f6ba-403n-jj03-40fl435n430f",
            //                "coinbase_transaction_id": "63a25bb13cb5cf0001d2cf17", // withdrawals only
            //                "crypto_transaction_hash": "752f35570736341e2a253f7041a34cf1e196fc56128c900fd03d99da899d94c1",
            //                "tx_service_transaction_id": "1873249104",
            //                "coinbase_payment_method_id": ""
            //            },
            //            "canceled_at": null,
            //            "processed_at": null,
            //            "user_nonce": null,
            //            "idem": "5e3201b0-e390-5k3k-a913-c32932049242",
            //            "profile_id": "k3k302a8-c4dk-4f49-9d39-3203923wpk39",
            //            "currency": "LTC"
            //        }
            //    ]
            //
            for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
            {
                object account_id = this.safeString(getValue(response, i), "account_id");
                object account = this.safeValue(this.accountsById, account_id);
                object codeInner = this.safeString(account, "code");
                ((IDictionary<string,object>)getValue(response, i))["currency"] = codeInner;
            }
        } else
        {
            response = await this.privateGetAccountsIdTransfers(this.extend(request, parameters));
            //
            //    [
            //        {
            //            "id": "bee6fd7c-afb2-4e47-8298-671d09997d16",
            //            "type": "deposit",
            //            "created_at": "2022-12-21 00:48:45.477503+00",
            //            "completed_at": null,
            //            "amount": "0.01000000",
            //            "details": {
            //                "network": "litecoin",
            //                "crypto_address": "MKemtnCFUYKsNWaf5EMYMpwSszcXWFDtTY",
            //                "coinbase_account_id": "fl2b6925-f6ba-403n-jj03-40fl435n430f",
            //                "coinbase_transaction_id": "63a25bb13cb5cf0001d2cf17", // withdrawals only
            //                "crypto_transaction_hash": "752f35570736341e2a253f7041a34cf1e196fc56128c900fd03d99da899d94c1",
            //                "tx_service_transaction_id": "1873249104",
            //                "coinbase_payment_method_id": ""
            //            },
            //            "canceled_at": null,
            //            "processed_at": null,
            //            "user_nonce": null,
            //            "idem": "5e3201b0-e390-5k3k-a913-c32932049242",
            //            "profile_id": "k3k302a8-c4dk-4f49-9d39-3203923wpk39",
            //            "currency": "LTC"
            //        }
            //    ]
            //
            for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
            {
                ((IDictionary<string,object>)getValue(response, i))["currency"] = code;
            }
        }
        return this.parseTransactions(response, currency, since, limit);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_gettransfers
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getaccounttransfers
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchDepositsWithdrawals(code, since, limit, this.extend(new Dictionary<string, object>() {
            { "type", "deposit" },
        }, parameters));
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_gettransfers
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getaccounttransfers
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchDepositsWithdrawals(code, since, limit, this.extend(new Dictionary<string, object>() {
            { "type", "withdraw" },
        }, parameters));
    }

    public virtual object parseTransactionStatus(object transaction)
    {
        object canceled = this.safeValue(transaction, "canceled_at");
        if (isTrue(canceled))
        {
            return "canceled";
        }
        object processed = this.safeValue(transaction, "processed_at");
        object completed = this.safeValue(transaction, "completed_at");
        if (isTrue(completed))
        {
            return "ok";
        } else if (isTrue(isTrue(processed) && !isTrue(completed)))
        {
            return "failed";
        } else
        {
            return "pending";
        }
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // privateGetTransfers
        //
        //    [
        //        {
        //            "id": "bee6fd7c-afb2-4e47-8298-671d09997d16",
        //            "type": "deposit",
        //            "created_at": "2022-12-21 00:48:45.477503+00",
        //            "completed_at": null,
        //            "account_id": "sal3802-36bd-46be-a7b8-alsjf383sldak",     // only from privateGetTransfers
        //            "user_id": "6382048209f92as392039dlks2",                  // only from privateGetTransfers
        //            "amount": "0.01000000",
        //            "details": {
        //                "network": "litecoin",
        //                "crypto_address": "MKemtnCFUYKsNWaf5EMYMpwSszcXWFDtTY",
        //                "coinbase_account_id": "fl2b6925-f6ba-403n-jj03-40fl435n430f",
        //                "coinbase_transaction_id": "63a25bb13cb5cf0001d2cf17", // withdrawals only
        //                "crypto_transaction_hash": "752f35570736341e2a253f7041a34cf1e196fc56128c900fd03d99da899d94c1",
        //                "tx_service_transaction_id": "1873249104",
        //                "coinbase_payment_method_id": ""
        //            },
        //            "canceled_at": null,
        //            "processed_at": null,
        //            "user_nonce": null,
        //            "idem": "5e3201b0-e390-5k3k-a913-c32932049242",
        //            "profile_id": "k3k302a8-c4dk-4f49-9d39-3203923wpk39",
        //            "currency": "LTC"
        //        }
        //    ]
        //
        object details = this.safeValue(transaction, "details", new Dictionary<string, object>() {});
        object timestamp = this.parse8601(this.safeString(transaction, "created_at"));
        object currencyId = this.safeString(transaction, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object amount = this.safeNumber(transaction, "amount");
        object type = this.safeString(transaction, "type");
        object address = this.safeString(details, "crypto_address");
        address = this.safeString(transaction, "crypto_address", address);
        object fee = new Dictionary<string, object>() {
            { "currency", null },
            { "cost", null },
            { "rate", null },
        };
        if (isTrue(isEqual(type, "withdraw")))
        {
            type = "withdrawal";
            address = this.safeString(details, "sent_to_address", address);
            object feeCost = this.safeNumber(details, "fee");
            if (isTrue(!isEqual(feeCost, null)))
            {
                if (isTrue(!isEqual(amount, null)))
                {
                    amount = subtract(amount, feeCost);
                }
                ((IDictionary<string,object>)fee)["cost"] = feeCost;
                ((IDictionary<string,object>)fee)["currency"] = code;
            }
        }
        object networkId = this.safeString(details, "network");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString(transaction, "id") },
            { "txid", this.safeString(details, "crypto_transaction_hash") },
            { "type", type },
            { "currency", code },
            { "network", this.networkIdToCode(networkId) },
            { "amount", amount },
            { "status", this.parseTransactionStatus(transaction) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "address", address },
            { "addressFrom", null },
            { "addressTo", this.safeString(details, "crypto_address") },
            { "tag", this.safeString(details, "destination_tag") },
            { "tagFrom", null },
            { "tagTo", null },
            { "updated", this.parse8601(this.safeString(transaction, "processed_at")) },
            { "comment", null },
            { "internal", false },
            { "fee", fee },
        };
    }

    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name coinbasepro#createDepositAddress
        * @description create a currency deposit address
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_postcoinbaseaccountaddresses
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accounts = this.safeValue(this.options, "coinbaseAccounts");
        if (isTrue(isEqual(accounts, null)))
        {
            accounts = await this.privateGetCoinbaseAccounts();
            ((IDictionary<string,object>)this.options)["coinbaseAccounts"] = accounts; // cache it
            ((IDictionary<string,object>)this.options)["coinbaseAccountsByCurrencyId"] = this.indexBy(accounts, "currency");
        }
        object currencyId = getValue(currency, "id");
        object account = this.safeValue(getValue(this.options, "coinbaseAccountsByCurrencyId"), currencyId);
        if (isTrue(isEqual(account, null)))
        {
            throw new InvalidAddress ((string)add(add(add(add(add(this.id, " createDepositAddress() could not find currency code "), code), " with id = "), currencyId), " in this.options[\'coinbaseAccountsByCurrencyId\']")) ;
        }
        object request = new Dictionary<string, object>() {
            { "id", getValue(account, "id") },
        };
        object response = await this.privatePostCoinbaseAccountsIdAddresses(this.extend(request, parameters));
        object address = this.safeString(response, "address");
        object tag = this.safeString(response, "destination_tag");
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", this.checkAddress(address) },
            { "tag", tag },
            { "info", response },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object request = add("/", this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(isEqual(method, "GET")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                request = add(request, add("?", this.urlencode(query)));
            }
        }
        object url = add(this.implodeHostname(getValue(getValue(this.urls, "api"), api)), request);
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object nonce = ((object)this.nonce()).ToString();
            object payload = "";
            if (isTrue(!isEqual(method, "GET")))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    body = this.json(query);
                    payload = body;
                }
            }
            object what = add(add(add(nonce, method), request), payload);
            object secret = null;
            try
            {
                secret = this.base64ToBinary(this.secret);
            } catch(Exception e)
            {
                throw new AuthenticationError ((string)add(this.id, " sign() invalid base64 secret")) ;
            }
            object signature = this.hmac(this.encode(what), secret, sha256, "base64");
            headers = new Dictionary<string, object>() {
                { "CB-ACCESS-KEY", this.apiKey },
                { "CB-ACCESS-SIGN", signature },
                { "CB-ACCESS-TIMESTAMP", nonce },
                { "CB-ACCESS-PASSPHRASE", this.password },
                { "Content-Type", "application/json" },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isTrue((isEqual(code, 400))) || isTrue((isEqual(code, 404)))))
        {
            if (isTrue(isEqual(getValue(body, 0), "{")))
            {
                object message = this.safeString(response, "message");
                object feedback = add(add(this.id, " "), message);
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
                this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
                throw new ExchangeError ((string)feedback) ;
            }
            throw new ExchangeError ((string)add(add(this.id, " "), body)) ;
        }
        return null;
    }

    public async override Task<object> request(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null, object config = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        config ??= new Dictionary<string, object>();
        object response = await this.fetch2(path, api, method, parameters, headers, body, config);
        if (isTrue(!(response is string)))
        {
            if (isTrue(inOp(response, "message")))
            {
                throw new ExchangeError ((string)add(add(this.id, " "), this.json(response))) ;
            }
        }
        return response;
    }
}
