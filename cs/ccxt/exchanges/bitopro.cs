namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class bitopro : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bitopro" },
            { "name", "BitoPro" },
            { "countries", new List<object>() {"TW"} },
            { "version", "v3" },
            { "rateLimit", 100 },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createOrder", true },
                { "editOrder", false },
                { "fetchBalance", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", false },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", false },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", false },
                { "fetchOrderTrades", false },
                { "fetchPosition", false },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsForSymbol", false },
                { "fetchPositionsHistory", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", false },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", true },
                { "fetchTransactionFees", false },
                { "fetchTransactions", false },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "fetchWithdrawal", true },
                { "fetchWithdrawals", true },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "3h", "3h" },
                { "6h", "6h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "1w", "1w" },
                { "1M", "1M" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/158227251-3a92a220-9222-453c-9277-977c6677fe71.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "rest", "https://api.bitopro.com/v3" },
                } },
                { "www", "https://www.bitopro.com" },
                { "doc", new List<object>() {"https://github.com/bitoex/bitopro-offical-api-docs/blob/master/v3-1/rest-1/rest.md"} },
                { "fees", "https://www.bitopro.com/fees" },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "order-book/{pair}", 1 },
                        { "tickers", 1 },
                        { "tickers/{pair}", 1 },
                        { "trades/{pair}", 1 },
                        { "provisioning/currencies", 1 },
                        { "provisioning/trading-pairs", 1 },
                        { "provisioning/limitations-and-fees", 1 },
                        { "trading-history/{pair}", 1 },
                        { "price/otc/{currency}", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "accounts/balance", 1 },
                        { "orders/history", 1 },
                        { "orders/all/{pair}", 1 },
                        { "orders/trades/{pair}", 1 },
                        { "orders/{pair}/{orderId}", 1 },
                        { "wallet/withdraw/{currency}/{serial}", 1 },
                        { "wallet/withdraw/{currency}/id/{id}", 1 },
                        { "wallet/depositHistory/{currency}", 1 },
                        { "wallet/withdrawHistory/{currency}", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "orders/{pair}", divide(1, 2) },
                        { "orders/batch", divide(20, 3) },
                        { "wallet/withdraw/{currency}", 10 },
                    } },
                    { "put", new Dictionary<string, object>() {
                        { "orders", 5 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "orders/{pair}/{id}", divide(2, 3) },
                        { "orders/all", 5 },
                        { "orders/{pair}", 5 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.001") },
                    { "taker", this.parseNumber("0.002") },
                    { "tiers", new Dictionary<string, object>() {
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.002")}, new List<object> {this.parseNumber("3000000"), this.parseNumber("0.00194")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.0015")}, new List<object> {this.parseNumber("30000000"), this.parseNumber("0.0014")}, new List<object> {this.parseNumber("300000000"), this.parseNumber("0.0013")}, new List<object> {this.parseNumber("550000000"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("1300000000"), this.parseNumber("0.0011")}} },
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("3000000"), this.parseNumber("0.00097")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("30000000"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("300000000"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("550000000"), this.parseNumber("0.0004")}, new List<object> {this.parseNumber("1300000000"), this.parseNumber("0.0003")}} },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "networks", new Dictionary<string, object>() {
                    { "ERC20", "ERC20" },
                    { "ETH", "ERC20" },
                    { "TRX", "TRX" },
                    { "TRC20", "TRX" },
                    { "BEP20", "BSC" },
                    { "BSC", "BSC" },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "Unsupported currency.", typeof(BadRequest) },
                    { "Unsupported order type", typeof(BadRequest) },
                    { "Invalid body", typeof(BadRequest) },
                    { "Invalid Signature", typeof(AuthenticationError) },
                    { "Address not in whitelist.", typeof(BadRequest) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Invalid amount", typeof(InvalidOrder) },
                    { "Balance for ", typeof(InsufficientFunds) },
                    { "Invalid ", typeof(BadRequest) },
                    { "Wrong parameter", typeof(BadRequest) },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {} },
        });
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name bitopro#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/public/get_currency_info.md
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetProvisioningCurrencies(parameters);
        object currencies = this.safeValue(response, "data", new List<object>() {});
        //
        //     {
        //         "data":[
        //             {
        //                 "currency":"eth",
        //                 "withdrawFee":"0.007",
        //                 "minWithdraw":"0.001",
        //                 "maxWithdraw":"1000",
        //                 "maxDailyWithdraw":"2000",
        //                 "withdraw":true,
        //                 "deposit":true,
        //                 "depositConfirmation":"12"
        //             }
        //         ]
        //     }
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currency = getValue(currencies, i);
            object currencyId = this.safeString(currency, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object deposit = this.safeValue(currency, "deposit");
            object withdraw = this.safeValue(currency, "withdraw");
            object fee = this.safeNumber(currency, "withdrawFee");
            object withdrawMin = this.safeNumber(currency, "minWithdraw");
            object withdrawMax = this.safeNumber(currency, "maxWithdraw");
            object limits = new Dictionary<string, object>() {
                { "withdraw", new Dictionary<string, object>() {
                    { "min", withdrawMin },
                    { "max", withdrawMax },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            };
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", currencyId },
                { "code", code },
                { "info", currency },
                { "type", null },
                { "name", null },
                { "active", isTrue(deposit) && isTrue(withdraw) },
                { "deposit", deposit },
                { "withdraw", withdraw },
                { "fee", fee },
                { "precision", null },
                { "limits", limits },
            };
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name bitopro#fetchMarkets
        * @description retrieves data on all markets for bitopro
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/public/get_trading_pair_info.md
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetProvisioningTradingPairs();
        object markets = this.safeValue(response, "data", new List<object>() {});
        //
        //     {
        //         "data":[
        //             {
        //                 "pair":"shib_twd",
        //                 "base":"shib",
        //                 "quote":"twd",
        //                 "basePrecision":"8",
        //                 "quotePrecision":"6",
        //                 "minLimitBaseAmount":"100000",
        //                 "maxLimitBaseAmount":"5500000000",
        //                 "minMarketBuyQuoteAmount":"1000",
        //                 "orderOpenLimit":"200",
        //                 "maintain":false,
        //                 "orderBookQuotePrecision":"6",
        //                 "orderBookQuoteScaleLevel":"5"
        //             }
        //         ]
        //     }
        //
        return this.parseMarkets(markets);
    }

    public override object parseMarket(object market)
    {
        object active = !isTrue(this.safeValue(market, "maintain"));
        object id = this.safeString(market, "pair");
        object uppercaseId = ((string)id).ToUpper();
        object baseId = this.safeString(market, "base");
        object quoteId = this.safeString(market, "quote");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(bs, "/"), quote);
        object limits = new Dictionary<string, object>() {
            { "amount", new Dictionary<string, object>() {
                { "min", this.safeNumber(market, "minLimitBaseAmount") },
                { "max", this.safeNumber(market, "maxLimitBaseAmount") },
            } },
            { "price", new Dictionary<string, object>() {
                { "min", null },
                { "max", null },
            } },
            { "cost", new Dictionary<string, object>() {
                { "min", null },
                { "max", null },
            } },
            { "leverage", new Dictionary<string, object>() {
                { "min", null },
                { "max", null },
            } },
        };
        return new Dictionary<string, object>() {
            { "id", id },
            { "uppercaseId", uppercaseId },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "baseId", bs },
            { "quoteId", quote },
            { "settle", null },
            { "settleId", null },
            { "type", "spot" },
            { "spot", true },
            { "margin", false },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "contract", false },
            { "linear", null },
            { "inverse", null },
            { "contractSize", null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "limits", limits },
            { "precision", new Dictionary<string, object>() {
                { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "quotePrecision"))) },
                { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "basePrecision"))) },
            } },
            { "active", active },
            { "created", null },
            { "info", market },
        };
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "pair":"btc_twd",
        //         "lastPrice":"1182449.00000000",
        //         "isBuyer":false,
        //         "priceChange24hr":"-1.99",
        //         "volume24hr":"9.13089740",
        //         "high24hr":"1226097.00000000",
        //         "low24hr":"1181000.00000000"
        //     }
        //
        object marketId = this.safeString(ticker, "pair");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeString(market, "symbol");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "high", this.safeString(ticker, "high24hr") },
            { "low", this.safeString(ticker, "low24hr") },
            { "bid", null },
            { "bidVolume", null },
            { "ask", null },
            { "askVolume", null },
            { "vwap", null },
            { "open", null },
            { "close", this.safeString(ticker, "lastPrice") },
            { "last", this.safeString(ticker, "lastPrice") },
            { "previousClose", null },
            { "change", null },
            { "percentage", this.safeString(ticker, "priceChange24hr") },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "volume24hr") },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitopro#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/public/get_ticker_data.md
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        object response = await this.publicGetTickersPair(this.extend(request, parameters));
        object ticker = this.safeValue(response, "data", new Dictionary<string, object>() {});
        //
        //     {
        //         "data":{
        //             "pair":"btc_twd",
        //             "lastPrice":"1182449.00000000",
        //             "isBuyer":false,
        //             "priceChange24hr":"-1.99",
        //             "volume24hr":"9.13089740",
        //             "high24hr":"1226097.00000000",
        //             "low24hr":"1181000.00000000"
        //         }
        //     }
        //
        return this.parseTicker(ticker, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bitopro#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/public/get_ticker_data.md
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetTickers();
        object tickers = this.safeValue(response, "data", new List<object>() {});
        //
        //     {
        //         "data":[
        //             {
        //                 "pair":"xrp_twd",
        //                 "lastPrice":"21.26110000",
        //                 "isBuyer":false,
        //                 "priceChange24hr":"-6.53",
        //                 "volume24hr":"102846.47084802",
        //                 "high24hr":"23.24460000",
        //                 "low24hr":"21.13730000"
        //             }
        //         ]
        //     }
        //
        return this.parseTickers(tickers, symbols);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitopro#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/public/get_orderbook_data.md
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.publicGetOrderBookPair(this.extend(request, parameters));
        //
        //     {
        //         "bids":[
        //             {
        //                 "price":"1175271",
        //                 "amount":"0.00022804",
        //                 "count":1,
        //                 "total":"0.00022804"
        //             }
        //         ],
        //         "asks":[
        //             {
        //                 "price":"1176906",
        //                 "amount":"0.0496",
        //                 "count":1,
        //                 "total":"0.0496"
        //             }
        //         ]
        //     }
        //
        return this.parseOrderBook(response, getValue(market, "symbol"), null, "bids", "asks", "price", "amount");
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades
        //         {
        //                 "timestamp":1644651458,
        //                 "price":"1180785.00000000",
        //                 "amount":"0.00020000",
        //                 "isBuyer":false
        //         }
        //
        // fetchMyTrades
        //         {
        //                 "tradeId":"5685030251",
        //                 "orderId":"9669168142",
        //                 "price":"11821.8",
        //                 "action":"SELL",
        //                 "baseAmount":"0.01",
        //                 "quoteAmount":"118.218",
        //                 "fee":"0.236436",
        //                 "feeSymbol":"BNB",
        //                 "isTaker":true,
        //                 "timestamp":1644905714862,
        //                 "createdTimestamp":1644905714862
        //         }
        //
        object id = this.safeString(trade, "tradeId");
        object orderId = this.safeString(trade, "orderId");
        object timestamp = null;
        if (isTrue(isEqual(id, null)))
        {
            timestamp = this.safeTimestamp(trade, "timestamp");
        } else
        {
            timestamp = this.safeInteger(trade, "timestamp");
        }
        object marketId = this.safeString(trade, "pair");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeString(market, "symbol");
        object price = this.safeString(trade, "price");
        object type = this.safeStringLower(trade, "type");
        object side = this.safeStringLower(trade, "action");
        if (isTrue(isEqual(side, null)))
        {
            object isBuyer = this.safeValue(trade, "isBuyer");
            if (isTrue(isBuyer))
            {
                side = "buy";
            } else
            {
                side = "sell";
            }
        }
        object amount = this.safeString(trade, "amount");
        if (isTrue(isEqual(amount, null)))
        {
            amount = this.safeString(trade, "baseAmount");
        }
        object fee = null;
        object feeAmount = this.safeString(trade, "fee");
        object feeSymbol = this.safeCurrencyCode(this.safeString(trade, "feeSymbol"));
        if (isTrue(!isEqual(feeAmount, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeAmount },
                { "currency", feeSymbol },
                { "rate", null },
            };
        }
        object isTaker = this.safeValue(trade, "isTaker");
        object takerOrMaker = null;
        if (isTrue(!isEqual(isTaker, null)))
        {
            if (isTrue(isTaker))
            {
                takerOrMaker = "taker";
            } else
            {
                takerOrMaker = "maker";
            }
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "info", trade },
            { "order", orderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "takerOrMaker", takerOrMaker },
            { "type", type },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitopro#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/public/get_trades_data.md
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        object response = await this.publicGetTradesPair(this.extend(request, parameters));
        object trades = this.safeValue(response, "data", new List<object>() {});
        //
        //     {
        //         "data":[
        //             {
        //                 "timestamp":1644651458,
        //                 "price":"1180785.00000000",
        //                 "amount":"0.00020000",
        //                 "isBuyer":false
        //             }
        //         ]
        //     }
        //
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name bitopro#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/public/get_limitations_and_fees.md
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetProvisioningLimitationsAndFees(parameters);
        object tradingFeeRate = this.safeValue(response, "tradingFeeRate", new Dictionary<string, object>() {});
        object first = this.safeValue(tradingFeeRate, 0);
        //
        //     {
        //         "tradingFeeRate":[
        //             {
        //                 "rank":0,
        //                 "twdVolumeSymbol":"\u003c",
        //                 "twdVolume":"3000000",
        //                 "bitoAmountSymbol":"\u003c",
        //                 "bitoAmount":"7500",
        //                 "makerFee":"0.001",
        //                 "takerFee":"0.002",
        //                 "makerBitoFee":"0.0008",
        //                 "takerBitoFee":"0.0016"
        //             }
        //         ],
        //         "orderFeesAndLimitations":[
        //             {
        //                 "pair":"BTC/TWD",
        //                 "minimumOrderAmount":"0.0001",
        //                 "minimumOrderAmountBase":"BTC",
        //                 "minimumOrderNumberOfDigits":"0"
        //             }
        //         ],
        //         "restrictionsOfWithdrawalFees":[
        //             {
        //                 "currency":"TWD",
        //                 "fee":"15",
        //                 "minimumTradingAmount":"100",
        //                 "maximumTradingAmount":"1000000",
        //                 "dailyCumulativeMaximumAmount":"2000000",
        //                 "remarks":"",
        //                 "protocol":""
        //             }
        //         ],
        //         "cryptocurrencyDepositFeeAndConfirmation":[
        //             {
        //                 "currency":"TWD",
        //                 "generalDepositFees":"0",
        //                 "blockchainConfirmationRequired":""
        //             }
        //         ],
        //         "ttCheckFeesAndLimitationsLevel1":[
        //             {
        //                 "currency":"TWD",
        //                 "redeemDailyCumulativeMaximumAmount":"",
        //                 "generateMinimumTradingAmount":"",
        //                 "generateMaximumTradingAmount":"",
        //                 "generateDailyCumulativeMaximumAmount":""
        //             }
        //         ],
        //         "ttCheckFeesAndLimitationsLevel2":[
        //             {
        //                 "currency":"TWD",
        //                 "redeemDailyCumulativeMaximumAmount":"20000000",
        //                 "generateMinimumTradingAmount":"30",
        //                 "generateMaximumTradingAmount":"10000000",
        //                 "generateDailyCumulativeMaximumAmount":"10000000"
        //             }
        //         ]
        //     }
        //
        object result = new Dictionary<string, object>() {};
        object maker = this.safeNumber(first, "makerFee");
        object taker = this.safeNumber(first, "takerFee");
        for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(this.symbols, i);
            ((IDictionary<string,object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "info", first },
                { "symbol", symbol },
                { "maker", maker },
                { "taker", taker },
                { "percentage", true },
                { "tierBased", true },
            };
        }
        return result;
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        return new List<object> {this.safeInteger(ohlcv, "timestamp"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitopro#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/public/get_ohlc_data.md
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object resolution = this.safeString(this.timeframes, timeframe, timeframe);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
            { "resolution", resolution },
        };
        // we need to have a limit argument because "to" and "from" are required
        if (isTrue(isEqual(limit, null)))
        {
            limit = 500;
        } else
        {
            limit = mathMin(limit, 75000); // supports slightly more than 75k candles atm, but limit here to avoid errors
        }
        object timeframeInSeconds = this.parseTimeframe(timeframe);
        object alignedSince = null;
        if (isTrue(isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["to"] = this.seconds();
            ((IDictionary<string,object>)request)["from"] = subtract(getValue(request, "to"), (multiply(limit, timeframeInSeconds)));
        } else
        {
            object timeframeInMilliseconds = multiply(timeframeInSeconds, 1000);
            alignedSince = multiply((Math.Floor(Double.Parse((divide(since, timeframeInMilliseconds)).ToString()))), timeframeInMilliseconds);
            ((IDictionary<string,object>)request)["from"] = (Math.Floor(Double.Parse((divide(since, 1000)).ToString())));
            ((IDictionary<string,object>)request)["to"] = this.sum(getValue(request, "from"), multiply(limit, timeframeInSeconds));
        }
        object response = await this.publicGetTradingHistoryPair(this.extend(request, parameters));
        object data = this.safeValue(response, "data", new List<object>() {});
        //
        //     {
        //         "data":[
        //             {
        //                 "timestamp":1644581100000,
        //                 "open":"1214737",
        //                 "high":"1215110",
        //                 "low":"1214737",
        //                 "close":"1215110",
        //                 "volume":"0.08423959"
        //             }
        //         ]
        //     }
        //
        object sparse = this.parseOHLCVs(data, market, timeframe, since, limit);
        return this.insertMissingCandles(sparse, timeframeInSeconds, alignedSince, limit);
    }

    public virtual object insertMissingCandles(object candles, object distance, object since, object limit)
    {
        // the exchange doesn't send zero volume candles so we emulate them instead
        // otherwise sending a limit arg leads to unexpected results
        object length = getArrayLength(candles);
        if (isTrue(isEqual(length, 0)))
        {
            return candles;
        }
        object result = new List<object>() {};
        object copyFrom = getValue(candles, 0);
        object timestamp = null;
        if (isTrue(isEqual(since, null)))
        {
            timestamp = getValue(copyFrom, 0);
        } else
        {
            timestamp = since;
        }
        object i = 0;
        object candleLength = getArrayLength(candles);
        object resultLength = 0;
        while (isTrue((isLessThan(resultLength, limit))) && isTrue((isLessThan(i, candleLength))))
        {
            object candle = getValue(candles, i);
            if (isTrue(isEqual(getValue(candle, 0), timestamp)))
            {
                ((IList<object>)result).Add(candle);
                i = this.sum(i, 1);
            } else
            {
                object copy = this.arrayConcat(new List<object>() {}, copyFrom);
                ((List<object>)copy)[Convert.ToInt32(0)] = timestamp;
                // set open, high, low to close
                ((List<object>)copy)[Convert.ToInt32(1)] = getValue(copy, 4);
                ((List<object>)copy)[Convert.ToInt32(2)] = getValue(copy, 4);
                ((List<object>)copy)[Convert.ToInt32(3)] = getValue(copy, 4);
                ((List<object>)copy)[Convert.ToInt32(5)] = this.parseNumber("0");
                ((IList<object>)result).Add(copy);
            }
            timestamp = this.sum(timestamp, multiply(distance, 1000));
            resultLength = getArrayLength(result);
            copyFrom = getValue(result, subtract(resultLength, 1));
        }
        return result;
    }

    public override object parseBalance(object response)
    {
        //
        //     [{
        //         "currency":"twd",
        //         "amount":"0",
        //         "available":"0",
        //         "stake":"0",
        //         "tradable":true
        //     }]
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object balance = getValue(response, i);
            object currencyId = this.safeString(balance, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object amount = this.safeString(balance, "amount");
            object available = this.safeString(balance, "available");
            object account = new Dictionary<string, object>() {
                { "free", available },
                { "total", amount },
            };
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bitopro#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/private/get_account_balance.md
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetAccountsBalance(parameters);
        object balances = this.safeValue(response, "data", new List<object>() {});
        //
        //     {
        //         "data":[
        //             {
        //                 "currency":"twd",
        //                 "amount":"0",
        //                 "available":"0",
        //                 "stake":"0",
        //                 "tradable":true
        //             }
        //         ]
        //     }
        //
        return this.parseBalance(balances);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "-1", "open" },
            { "0", "open" },
            { "1", "open" },
            { "2", "closed" },
            { "3", "closed" },
            { "4", "canceled" },
            { "6", "canceled" },
        };
        return this.safeString(statuses, status, null);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //         {
        //             "orderId": "2220595581",
        //             "timestamp": "1644896744886",
        //             "action": "SELL",
        //             "amount": "0.01",
        //             "price": "15000",
        //             "timeInForce": "GTC"
        //         }
        //
        // fetchOrder
        //         {
        //             "id":"8777138788",
        //             "pair":"bnb_twd",
        //             "price":"16000",
        //             "avgExecutionPrice":"0",
        //             "action":"SELL",
        //             "type":"LIMIT",
        //             "timestamp":1644899002598,
        //             "status":4,
        //             "originalAmount":"0.01",
        //             "remainingAmount":"0.01",
        //             "executedAmount":"0",
        //             "fee":"0",
        //             "feeSymbol":"twd",
        //             "bitoFee":"0",
        //             "total":"0",
        //             "seq":"BNBTWD548774666",
        //             "timeInForce":"GTC",
        //             "createdTimestamp":1644898944074,
        //             "updatedTimestamp":1644899002598
        //         }
        //
        object id = this.safeString2(order, "id", "orderId");
        object timestamp = this.safeInteger2(order, "timestamp", "createdTimestamp");
        object side = this.safeString(order, "action");
        side = ((string)side).ToLower();
        object amount = this.safeString2(order, "amount", "originalAmount");
        object price = this.safeString(order, "price");
        object marketId = this.safeString(order, "pair");
        market = this.safeMarket(marketId, market, "_");
        object symbol = this.safeString(market, "symbol");
        object orderStatus = this.safeString(order, "status");
        object status = this.parseOrderStatus(orderStatus);
        object type = this.safeStringLower(order, "type");
        object average = this.safeString(order, "avgExecutionPrice");
        object filled = this.safeString(order, "executedAmount");
        object remaining = this.safeString(order, "remainingAmount");
        object timeInForce = this.safeString(order, "timeInForce");
        object postOnly = null;
        if (isTrue(isEqual(timeInForce, "POST_ONLY")))
        {
            postOnly = true;
        }
        object fee = null;
        object feeAmount = this.safeString(order, "fee");
        object feeSymbol = this.safeCurrencyCode(this.safeString(order, "feeSymbol"));
        if (isTrue(Precise.stringGt(feeAmount, "0")))
        {
            fee = new Dictionary<string, object>() {
                { "currency", feeSymbol },
                { "cost", feeAmount },
            };
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", this.safeInteger(order, "updatedTimestamp") },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "side", side },
            { "price", price },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "amount", amount },
            { "cost", null },
            { "average", average },
            { "filled", filled },
            { "remaining", remaining },
            { "status", status },
            { "fee", fee },
            { "trades", null },
            { "info", order },
        }, market);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitopro#createOrder
        * @description create a trade order
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/private/create_an_order.md
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "type", type },
            { "pair", getValue(market, "id") },
            { "action", side },
            { "amount", this.amountToPrecision(symbol, amount) },
            { "timestamp", this.milliseconds() },
        };
        object orderType = ((string)type).ToUpper();
        if (isTrue(isEqual(orderType, "LIMIT")))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(isEqual(orderType, "STOP_LIMIT")))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            object stopPrice = this.safeValue2(parameters, "triggerPrice", "stopPrice");
            parameters = this.omit(parameters, new List<object>() {"triggerPrice", "stopPrice"});
            if (isTrue(isEqual(stopPrice, null)))
            {
                throw new InvalidOrder ((string)add(add(add(this.id, " createOrder() requires a stopPrice parameter for "), orderType), " orders")) ;
            } else
            {
                ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, stopPrice);
            }
            object condition = this.safeString(parameters, "condition");
            if (isTrue(isEqual(condition, null)))
            {
                throw new InvalidOrder ((string)add(add(add(this.id, " createOrder() requires a condition parameter for "), orderType), " orders")) ;
            } else
            {
                ((IDictionary<string,object>)request)["condition"] = condition;
            }
        }
        object postOnly = this.isPostOnly(isEqual(orderType, "MARKET"), null, parameters);
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["timeInForce"] = "POST_ONLY";
        }
        object response = await this.privatePostOrdersPair(this.extend(request, parameters));
        //
        //     {
        //         "orderId": "2220595581",
        //         "timestamp": "1644896744886",
        //         "action": "SELL",
        //         "amount": "0.01",
        //         "price": "15000",
        //         "timeInForce": "GTC"
        //     }
        //
        return this.parseOrder(response, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitopro#cancelOrder
        * @description cancels an open order
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/private/cancel_an_order.md
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "id", id },
            { "pair", getValue(market, "id") },
        };
        object response = await this.privateDeleteOrdersPairId(this.extend(request, parameters));
        //
        //     {
        //         "orderId":"8777138788",
        //         "action":"SELL",
        //         "timestamp":1644899002465,
        //         "price":"16000",
        //         "amount":"0.01"
        //     }
        //
        return this.parseOrder(response, market);
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitopro#cancelOrders
        * @description cancel multiple orders
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/private/cancel_batch_orders.md
        * @param {string[]} ids order ids
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object id = getValue(market, "uppercaseId");
        object request = new Dictionary<string, object>() {};
        ((IDictionary<string,object>)request)[(string)id] = ids;
        object response = await this.privatePutOrders(this.extend(request, parameters));
        //
        //     {
        //         "data":{
        //             "BNB_TWD":[
        //                 "5236347105",
        //                 "359488711"
        //             ]
        //         }
        //     }
        //
        return response;
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitopro#cancelAllOrders
        * @description cancel all open orders
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/private/cancel_all_orders.md
        * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["pair"] = getValue(market, "id");
            response = await this.privateDeleteOrdersPair(this.extend(request, parameters));
        } else
        {
            response = await this.privateDeleteOrdersAll(this.extend(request, parameters));
        }
        object result = this.safeValue(response, "data", new Dictionary<string, object>() {});
        //
        //     {
        //         "data":{
        //             "BNB_TWD":[
        //                 "9515988421",
        //                 "4639130027"
        //             ]
        //         }
        //     }
        //
        return result;
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitopro#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/private/get_an_order_data.md
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "orderId", id },
            { "pair", getValue(market, "id") },
        };
        object response = await this.privateGetOrdersPairOrderId(this.extend(request, parameters));
        //
        //     {
        //         "id":"8777138788",
        //         "pair":"bnb_twd",
        //         "price":"16000",
        //         "avgExecutionPrice":"0",
        //         "action":"SELL",
        //         "type":"LIMIT",
        //         "timestamp":1644899002598,
        //         "status":4,
        //         "originalAmount":"0.01",
        //         "remainingAmount":"0.01",
        //         "executedAmount":"0",
        //         "fee":"0",
        //         "feeSymbol":"twd",
        //         "bitoFee":"0",
        //         "total":"0",
        //         "seq":"BNBTWD548774666",
        //         "timeInForce":"GTC",
        //         "createdTimestamp":1644898944074,
        //         "updatedTimestamp":1644899002598
        //     }
        //
        return this.parseOrder(response, market);
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitopro#fetchOrders
        * @description fetches information on multiple orders made by the user
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/private/get_orders_data.md
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTimestamp"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetOrdersAllPair(this.extend(request, parameters));
        object orders = this.safeValue(response, "data");
        if (isTrue(isEqual(orders, null)))
        {
            orders = new List<object>() {};
        }
        //
        //     {
        //         "data":[
        //             {
        //                 "id":"2220595581",
        //                 "pair":"bnb_twd",
        //                 "price":"15000",
        //                 "avgExecutionPrice":"0",
        //                 "action":"SELL",
        //                 "type":"LIMIT",
        //                 "createdTimestamp":1644896744886,
        //                 "updatedTimestamp":1644898706236,
        //                 "status":4,
        //                 "originalAmount":"0.01",
        //                 "remainingAmount":"0.01",
        //                 "executedAmount":"0",
        //                 "fee":"0",
        //                 "feeSymbol":"twd",
        //                 "bitoFee":"0",
        //                 "total":"0",
        //                 "seq":"BNBTWD8540871774",
        //                 "timeInForce":"GTC"
        //             }
        //         ]
        //     }
        //
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "statusKind", "OPEN" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitopro#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/private/get_orders_data.md
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "statusKind", "DONE" },
        };
        return this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitopro#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/private/get_trades_data.md
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        object response = await this.privateGetOrdersTradesPair(this.extend(request, parameters));
        object trades = this.safeValue(response, "data", new List<object>() {});
        //
        //     {
        //         "data":[
        //             {
        //                 "tradeId":"5685030251",
        //                 "orderId":"9669168142",
        //                 "price":"11821.8",
        //                 "action":"SELL",
        //                 "baseAmount":"0.01",
        //                 "quoteAmount":"118.218",
        //                 "fee":"0.236436",
        //                 "feeSymbol":"BNB",
        //                 "isTaker":true,
        //                 "timestamp":1644905714862,
        //                 "createdTimestamp":1644905714862
        //             }
        //         ]
        //     }
        //
        return this.parseTrades(trades, market, since, limit);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object states = new Dictionary<string, object>() {
            { "COMPLETE", "ok" },
            { "INVALID", "failed" },
            { "PROCESSING", "pending" },
            { "WAIT_PROCESS", "pending" },
            { "FAILED", "failed" },
            { "EXPIRED", "failed" },
            { "CANCELLED", "failed" },
            { "EMAIL_VERIFICATION", "pending" },
            { "WAIT_CONFIRMATION", "pending" },
        };
        return this.safeString(states, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //    {
        //        "serial": "20220214X766799",
        //        "timestamp": "1644833015053",
        //        "address": "bnb1xml62k5a9dcewgc542fha75fyxdcp0zv8eqfsh",
        //        "amount": "0.20000000",
        //        "fee": "0.00000000",
        //        "total": "0.20000000",
        //        "status": "COMPLETE",
        //        "txid": "A3CC4F6828CC752B9F3737F48B5826B9EC2857040CB5141D0CC955F7E53DB6D9",
        //        "message": "778553959",
        //        "protocol": "MAIN",
        //        "id": "2905906537"
        //    }
        //
        // fetchWithdrawals || fetchWithdraw
        //
        //    {
        //        "serial": "20220215BW14069838",
        //        "timestamp": "1644907716044",
        //        "address": "TKrwMaZaGiAvtXCFT41xHuusNcs4LPWS7w",
        //        "amount": "8.00000000",
        //        "fee": "2.00000000",
        //        "total": "10.00000000",
        //        "status": "COMPLETE",
        //        "txid": "50bf250c71a582f40cf699fb58bab978437ea9bdf7259ff8072e669aab30c32b",
        //        "protocol": "TRX",
        //        "id": "9925310345"
        //    }
        //
        // withdraw
        //
        //    {
        //        "serial": "20220215BW14069838",
        //        "currency": "USDT",
        //        "protocol": "TRX",
        //        "address": "TKrwMaZaGiAvtXCFT41xHuusNcs4LPWS7w",
        //        "amount": "8",
        //        "fee": "2",
        //        "total": "10"
        //    }
        //
        object currencyId = this.safeString(transaction, "coin");
        object code = this.safeCurrencyCode(currencyId, currency);
        object timestamp = this.safeInteger(transaction, "timestamp");
        object address = this.safeString(transaction, "address");
        object tag = this.safeString(transaction, "message");
        object status = this.safeString(transaction, "status");
        object networkId = this.safeString(transaction, "protocol");
        if (isTrue(isEqual(networkId, "MAIN")))
        {
            networkId = code;
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString(transaction, "serial") },
            { "txid", this.safeString(transaction, "txid") },
            { "type", null },
            { "currency", code },
            { "network", this.networkIdToCode(networkId) },
            { "amount", this.safeNumber(transaction, "total") },
            { "status", this.parseTransactionStatus(status) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "address", address },
            { "addressFrom", null },
            { "addressTo", address },
            { "tag", tag },
            { "tagFrom", null },
            { "tagTo", tag },
            { "updated", null },
            { "comment", null },
            { "internal", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", this.safeNumber(transaction, "fee") },
                { "rate", null },
            } },
        };
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitopro#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/private/get_deposit_invoices_data.md
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDeposits() requires the code argument")) ;
        }
        await this.loadMarkets();
        object currency = this.safeCurrency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTimestamp"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetWalletDepositHistoryCurrency(this.extend(request, parameters));
        object result = this.safeValue(response, "data", new List<object>() {});
        //
        //     {
        //         "data":[
        //             {
        //                 "serial":"20220214X766799",
        //                 "timestamp":"1644833015053",
        //                 "address":"bnb1xml62k5a9dcewgc542fha75fyxdcp0zv8eqfsh",
        //                 "amount":"0.20000000",
        //                 "fee":"0.00000000",
        //                 "total":"0.20000000",
        //                 "status":"COMPLETE",
        //                 "txid":"A3CC4F6828CC752B9F3737F48B5826B9EC2857040CB5141D0CC955F7E53DB6D9",
        //                 "message":"778553959",
        //                 "protocol":"MAIN",
        //                 "id":"2905906537"
        //             }
        //         ]
        //     }
        //
        return this.parseTransactions(result, currency, since, limit, new Dictionary<string, object>() {
            { "type", "deposit" },
        });
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitopro#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/private/get_withdraw_invoices_data.md
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchWithdrawals() requires the code argument")) ;
        }
        await this.loadMarkets();
        object currency = this.safeCurrency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTimestamp"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetWalletWithdrawHistoryCurrency(this.extend(request, parameters));
        object result = this.safeValue(response, "data", new List<object>() {});
        //
        //     {
        //         "data":[
        //             {
        //                 "serial":"20220215BW14069838",
        //                 "timestamp":"1644907716044",
        //                 "address":"TKrwMaZaGiAvtXCFT41xHuusNcs4LPWS7w",
        //                 "amount":"8.00000000",
        //                 "fee":"2.00000000",
        //                 "total":"10.00000000",
        //                 "status":"COMPLETE",
        //                 "txid":"50bf250c71a582f40cf699fb58bab978437ea9bdf7259ff8072e669aab30c32b",
        //                 "protocol":"TRX",
        //                 "id":"9925310345"
        //             }
        //         ]
        //     }
        //
        return this.parseTransactions(result, currency, since, limit, new Dictionary<string, object>() {
            { "type", "withdrawal" },
        });
    }

    public async virtual Task<object> fetchWithdrawal(object id, object code = null, object parameters = null)
    {
        /**
        * @method
        * @name bitopro#fetchWithdrawal
        * @description fetch data on a currency withdrawal via the withdrawal id
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/private/get_an_withdraw_invoice_data.md
        * @param {string} id withdrawal id
        * @param {string} code unified currency code of the currency withdrawn, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchWithdrawal() requires the code argument")) ;
        }
        await this.loadMarkets();
        object currency = this.safeCurrency(code);
        object request = new Dictionary<string, object>() {
            { "serial", id },
            { "currency", getValue(currency, "id") },
        };
        object response = await this.privateGetWalletWithdrawCurrencySerial(this.extend(request, parameters));
        object result = this.safeValue(response, "data", new Dictionary<string, object>() {});
        //
        //     {
        //         "data":{
        //             "serial":"20220215BW14069838",
        //             "address":"TKrwMaZaGiAvtXCFT41xHuusNcs4LPWS7w",
        //             "amount":"8.00000000",
        //             "fee":"2.00000000",
        //             "total":"10.00000000",
        //             "status":"COMPLETE",
        //             "txid":"50bf250c71a582f40cf699fb58bab978437ea9bdf7259ff8072e669aab30c32b",
        //             "protocol":"TRX",
        //             "id":"9925310345",
        //             "timestamp":"1644907716044"
        //         }
        //     }
        //
        return this.parseTransaction(result, currency);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name bitopro#withdraw
        * @description make a withdrawal
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/private/create_an_withdraw_invoice.md
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        this.checkAddress(address);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", this.numberToString(amount) },
            { "address", address },
        };
        if (isTrue(inOp(parameters, "network")))
        {
            object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
            object requestedNetwork = this.safeStringUpper(parameters, "network");
            parameters = this.omit(parameters, new List<object>() {"network"});
            object networkId = this.safeString(networks, requestedNetwork);
            if (isTrue(isEqual(networkId, null)))
            {
                throw new ExchangeError ((string)add(add(this.id, " invalid network "), requestedNetwork)) ;
            }
            ((IDictionary<string,object>)request)["protocol"] = networkId;
        }
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["message"] = tag;
        }
        object response = await this.privatePostWalletWithdrawCurrency(this.extend(request, parameters));
        object result = this.safeValue(response, "data", new Dictionary<string, object>() {});
        //
        //     {
        //         "data":{
        //             "serial":"20220215BW14069838",
        //             "currency":"USDT",
        //             "protocol":"TRX",
        //             "address":"TKrwMaZaGiAvtXCFT41xHuusNcs4LPWS7w",
        //             "amount":"8",
        //             "fee":"2",
        //             "total":"10"
        //         }
        //     }
        //
        return this.parseTransaction(result, currency);
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //    {
        //        "currency":"eth",
        //        "withdrawFee":"0.007",
        //        "minWithdraw":"0.001",
        //        "maxWithdraw":"1000",
        //        "maxDailyWithdraw":"2000",
        //        "withdraw":true,
        //        "deposit":true,
        //        "depositConfirmation":"12"
        //    }
        return new Dictionary<string, object>() {
            { "info", fee },
            { "withdraw", new Dictionary<string, object>() {
                { "fee", this.safeNumber(fee, "withdrawFee") },
                { "percentage", false },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name bitopro#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/api/v3/public/get_currency_info.md
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetProvisioningCurrencies(parameters);
        //
        //     {
        //         "data":[
        //             {
        //                 "currency":"eth",
        //                 "withdrawFee":"0.007",
        //                 "minWithdraw":"0.001",
        //                 "maxWithdraw":"1000",
        //                 "maxDailyWithdraw":"2000",
        //                 "withdraw":true,
        //                 "deposit":true,
        //                 "depositConfirmation":"12"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseDepositWithdrawFees(data, codes, "currency");
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add("/", this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(isEqual(headers, null)))
        {
            headers = new Dictionary<string, object>() {};
        }
        ((IDictionary<string,object>)headers)["X-BITOPRO-API"] = "ccxt";
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            if (isTrue(isTrue(isEqual(method, "POST")) || isTrue(isEqual(method, "PUT"))))
            {
                body = this.json(parameters);
                object payload = this.stringToBase64(body);
                object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha384);
                ((IDictionary<string,object>)headers)["X-BITOPRO-APIKEY"] = this.apiKey;
                ((IDictionary<string,object>)headers)["X-BITOPRO-PAYLOAD"] = payload;
                ((IDictionary<string,object>)headers)["X-BITOPRO-SIGNATURE"] = signature;
            } else if (isTrue(isTrue(isEqual(method, "GET")) || isTrue(isEqual(method, "DELETE"))))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    url = add(url, add("?", this.urlencode(query)));
                }
                object nonce = this.milliseconds();
                object rawData = new Dictionary<string, object>() {
                    { "nonce", nonce },
                };
                object data = this.json(rawData);
                object payload = this.stringToBase64(data);
                object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha384);
                ((IDictionary<string,object>)headers)["X-BITOPRO-APIKEY"] = this.apiKey;
                ((IDictionary<string,object>)headers)["X-BITOPRO-PAYLOAD"] = payload;
                ((IDictionary<string,object>)headers)["X-BITOPRO-SIGNATURE"] = signature;
            }
        } else if (isTrue(isTrue(isEqual(api, "public")) && isTrue(isEqual(method, "GET"))))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        }
        url = add(getValue(getValue(this.urls, "api"), "rest"), url);
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to the default error handler
        }
        if (isTrue(isTrue(isGreaterThanOrEqual(code, 200)) && isTrue(isLessThan(code, 300))))
        {
            return null;
        }
        object feedback = add(add(this.id, " "), body);
        object error = this.safeString(response, "error");
        this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), error, feedback);
        this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), error, feedback);
        throw new ExchangeError ((string)feedback) ;
    }
}
