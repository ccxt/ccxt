namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class bitmart : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bitmart" },
            { "name", "BitMart" },
            { "countries", new List<object>() {"US", "CN", "HK", "KR"} },
            { "rateLimit", 33.34 },
            { "version", "v2" },
            { "certified", true },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "borrowCrossMargin", false },
                { "borrowIsolatedMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", true },
                { "createPostOnlyOrder", true },
                { "createStopLimitOrder", false },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "createTrailingPercentOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowInterest", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDeposit", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", true },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIsolatedBorrowRate", true },
                { "fetchIsolatedBorrowRates", true },
                { "fetchLedger", true },
                { "fetchLiquidations", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMyLiquidations", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", false },
                { "fetchOrderTrades", true },
                { "fetchPosition", true },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchTransactionFee", true },
                { "fetchTransactionFees", false },
                { "fetchTransfer", false },
                { "fetchTransfers", true },
                { "fetchWithdrawAddressesByNetwork", false },
                { "fetchWithdrawal", true },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", true },
                { "setLeverage", true },
                { "setMarginMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "hostname", "bitmart.com" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/0623e9c4-f50e-48c9-82bd-65c3908c3a14" },
                { "api", new Dictionary<string, object>() {
                    { "spot", "https://api-cloud.{hostname}" },
                    { "swap", "https://api-cloud-v2.{hostname}" },
                } },
                { "www", "https://www.bitmart.com/" },
                { "doc", "https://developer-pro.bitmart.com/" },
                { "referral", new Dictionary<string, object>() {
                    { "url", "http://www.bitmart.com/?r=rQCFLh" },
                    { "discount", 0.3 },
                } },
                { "fees", "https://www.bitmart.com/fee/en" },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "uid", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "system/time", 3 },
                        { "system/service", 3 },
                        { "spot/v1/currencies", 7.5 },
                        { "spot/v1/symbols", 7.5 },
                        { "spot/v1/symbols/details", 5 },
                        { "spot/quotation/v3/tickers", 6 },
                        { "spot/quotation/v3/ticker", 4 },
                        { "spot/quotation/v3/lite-klines", 5 },
                        { "spot/quotation/v3/klines", 7 },
                        { "spot/quotation/v3/books", 4 },
                        { "spot/quotation/v3/trades", 4 },
                        { "spot/v1/ticker", 5 },
                        { "spot/v2/ticker", 30 },
                        { "spot/v1/ticker_detail", 5 },
                        { "spot/v1/steps", 30 },
                        { "spot/v1/symbols/kline", 6 },
                        { "spot/v1/symbols/book", 5 },
                        { "spot/v1/symbols/trades", 5 },
                        { "contract/v1/tickers", 15 },
                        { "contract/public/details", 5 },
                        { "contract/public/depth", 5 },
                        { "contract/public/open-interest", 30 },
                        { "contract/public/funding-rate", 30 },
                        { "contract/public/funding-rate-history", 30 },
                        { "contract/public/kline", 6 },
                        { "account/v1/currencies", 30 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "account/sub-account/v1/transfer-list", 7.5 },
                        { "account/sub-account/v1/transfer-history", 7.5 },
                        { "account/sub-account/main/v1/wallet", 5 },
                        { "account/sub-account/main/v1/subaccount-list", 7.5 },
                        { "account/contract/sub-account/main/v1/wallet", 5 },
                        { "account/contract/sub-account/main/v1/transfer-list", 7.5 },
                        { "account/contract/sub-account/v1/transfer-history", 7.5 },
                        { "account/v1/wallet", 5 },
                        { "account/v1/currencies", 30 },
                        { "spot/v1/wallet", 5 },
                        { "account/v1/deposit/address", 30 },
                        { "account/v1/withdraw/charge", 32 },
                        { "account/v2/deposit-withdraw/history", 7.5 },
                        { "account/v1/deposit-withdraw/detail", 7.5 },
                        { "spot/v1/order_detail", 1 },
                        { "spot/v2/orders", 5 },
                        { "spot/v1/trades", 5 },
                        { "spot/v2/trades", 4 },
                        { "spot/v3/orders", 5 },
                        { "spot/v2/order_detail", 1 },
                        { "spot/v1/margin/isolated/borrow_record", 1 },
                        { "spot/v1/margin/isolated/repay_record", 1 },
                        { "spot/v1/margin/isolated/pairs", 30 },
                        { "spot/v1/margin/isolated/account", 5 },
                        { "spot/v1/trade_fee", 30 },
                        { "spot/v1/user_fee", 30 },
                        { "spot/v1/broker/rebate", 1 },
                        { "contract/private/assets-detail", 5 },
                        { "contract/private/order", 1.2 },
                        { "contract/private/order-history", 10 },
                        { "contract/private/position", 10 },
                        { "contract/private/get-open-orders", 1.2 },
                        { "contract/private/current-plan-order", 1.2 },
                        { "contract/private/trades", 10 },
                        { "contract/private/position-risk", 10 },
                        { "contract/private/affilate/rebate-list", 10 },
                        { "contract/private/affilate/trade-list", 10 },
                        { "contract/private/transaction-history", 10 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "account/sub-account/main/v1/sub-to-main", 30 },
                        { "account/sub-account/sub/v1/sub-to-main", 30 },
                        { "account/sub-account/main/v1/main-to-sub", 30 },
                        { "account/sub-account/sub/v1/sub-to-sub", 30 },
                        { "account/sub-account/main/v1/sub-to-sub", 30 },
                        { "account/contract/sub-account/main/v1/sub-to-main", 7.5 },
                        { "account/contract/sub-account/main/v1/main-to-sub", 7.5 },
                        { "account/contract/sub-account/sub/v1/sub-to-main", 7.5 },
                        { "account/v1/withdraw/apply", 7.5 },
                        { "spot/v1/submit_order", 1 },
                        { "spot/v1/batch_orders", 1 },
                        { "spot/v2/cancel_order", 1 },
                        { "spot/v1/cancel_orders", 15 },
                        { "spot/v4/query/order", 1 },
                        { "spot/v4/query/client-order", 1 },
                        { "spot/v4/query/open-orders", 5 },
                        { "spot/v4/query/history-orders", 5 },
                        { "spot/v4/query/trades", 5 },
                        { "spot/v4/query/order-trades", 5 },
                        { "spot/v4/cancel_orders", 3 },
                        { "spot/v4/cancel_all", 90 },
                        { "spot/v4/batch_orders", 3 },
                        { "spot/v3/cancel_order", 1 },
                        { "spot/v2/batch_orders", 1 },
                        { "spot/v2/submit_order", 1 },
                        { "spot/v1/margin/submit_order", 1 },
                        { "spot/v1/margin/isolated/borrow", 30 },
                        { "spot/v1/margin/isolated/repay", 30 },
                        { "spot/v1/margin/isolated/transfer", 30 },
                        { "account/v1/transfer-contract-list", 60 },
                        { "account/v1/transfer-contract", 60 },
                        { "contract/private/submit-order", 2.5 },
                        { "contract/private/cancel-order", 1.5 },
                        { "contract/private/cancel-orders", 30 },
                        { "contract/private/submit-plan-order", 2.5 },
                        { "contract/private/cancel-plan-order", 1.5 },
                        { "contract/private/submit-leverage", 2.5 },
                        { "contract/private/submit-tp-sl-order", 2.5 },
                        { "contract/private/modify-plan-order", 2.5 },
                        { "contract/private/modify-preset-plan-order", 2.5 },
                        { "contract/private/modify-tp-sl-order", 2.5 },
                    } },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", 1 },
                { "3m", 3 },
                { "5m", 5 },
                { "15m", 15 },
                { "30m", 30 },
                { "45m", 45 },
                { "1h", 60 },
                { "2h", 120 },
                { "3h", 180 },
                { "4h", 240 },
                { "1d", 1440 },
                { "1w", 10080 },
                { "1M", 43200 },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.0040") },
                    { "maker", this.parseNumber("0.0035") },
                    { "tiers", new Dictionary<string, object>() {
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0020")}, new List<object> {this.parseNumber("10"), this.parseNumber("0.18")}, new List<object> {this.parseNumber("50"), this.parseNumber("0.0016")}, new List<object> {this.parseNumber("250"), this.parseNumber("0.0014")}, new List<object> {this.parseNumber("1000"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("5000"), this.parseNumber("0.0010")}, new List<object> {this.parseNumber("25000"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.0006")}} },
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("10"), this.parseNumber("0.0009")}, new List<object> {this.parseNumber("50"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("250"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("1000"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("5000"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("25000"), this.parseNumber("0.0004")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.0003")}} },
                    } },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "30000", typeof(ExchangeError) },
                    { "30001", typeof(AuthenticationError) },
                    { "30002", typeof(AuthenticationError) },
                    { "30003", typeof(AccountSuspended) },
                    { "30004", typeof(AuthenticationError) },
                    { "30005", typeof(AuthenticationError) },
                    { "30006", typeof(AuthenticationError) },
                    { "30007", typeof(AuthenticationError) },
                    { "30008", typeof(AuthenticationError) },
                    { "30010", typeof(PermissionDenied) },
                    { "30011", typeof(AuthenticationError) },
                    { "30012", typeof(AuthenticationError) },
                    { "30013", typeof(RateLimitExceeded) },
                    { "30014", typeof(ExchangeNotAvailable) },
                    { "30016", typeof(OnMaintenance) },
                    { "30017", typeof(RateLimitExceeded) },
                    { "30018", typeof(BadRequest) },
                    { "30019", typeof(PermissionDenied) },
                    { "60000", typeof(BadRequest) },
                    { "60001", typeof(BadRequest) },
                    { "60002", typeof(BadRequest) },
                    { "60003", typeof(ExchangeError) },
                    { "60004", typeof(ExchangeError) },
                    { "60005", typeof(ExchangeError) },
                    { "60006", typeof(ExchangeError) },
                    { "60007", typeof(InvalidAddress) },
                    { "60008", typeof(InsufficientFunds) },
                    { "60009", typeof(ExchangeError) },
                    { "60010", typeof(ExchangeError) },
                    { "60011", typeof(InvalidAddress) },
                    { "60012", typeof(ExchangeError) },
                    { "60020", typeof(PermissionDenied) },
                    { "60021", typeof(PermissionDenied) },
                    { "60022", typeof(PermissionDenied) },
                    { "60026", typeof(PermissionDenied) },
                    { "60027", typeof(PermissionDenied) },
                    { "60028", typeof(AccountSuspended) },
                    { "60029", typeof(AccountSuspended) },
                    { "60030", typeof(BadRequest) },
                    { "60031", typeof(BadRequest) },
                    { "60050", typeof(ExchangeError) },
                    { "60051", typeof(ExchangeError) },
                    { "61001", typeof(InsufficientFunds) },
                    { "61003", typeof(BadRequest) },
                    { "61004", typeof(BadRequest) },
                    { "61005", typeof(BadRequest) },
                    { "61006", typeof(NotSupported) },
                    { "61007", typeof(ExchangeError) },
                    { "61008", typeof(ExchangeError) },
                    { "70000", typeof(ExchangeError) },
                    { "70001", typeof(BadRequest) },
                    { "70002", typeof(BadSymbol) },
                    { "70003", typeof(NetworkError) },
                    { "71001", typeof(BadRequest) },
                    { "71002", typeof(BadRequest) },
                    { "71003", typeof(BadRequest) },
                    { "71004", typeof(BadRequest) },
                    { "71005", typeof(BadRequest) },
                    { "50000", typeof(BadRequest) },
                    { "50001", typeof(BadSymbol) },
                    { "50002", typeof(BadRequest) },
                    { "50003", typeof(BadRequest) },
                    { "50004", typeof(BadRequest) },
                    { "50005", typeof(OrderNotFound) },
                    { "50006", typeof(InvalidOrder) },
                    { "50007", typeof(InvalidOrder) },
                    { "50008", typeof(InvalidOrder) },
                    { "50009", typeof(InvalidOrder) },
                    { "50010", typeof(InvalidOrder) },
                    { "50011", typeof(InvalidOrder) },
                    { "50012", typeof(InvalidOrder) },
                    { "50013", typeof(InvalidOrder) },
                    { "50014", typeof(BadRequest) },
                    { "50015", typeof(BadRequest) },
                    { "50016", typeof(BadRequest) },
                    { "50017", typeof(BadRequest) },
                    { "50018", typeof(BadRequest) },
                    { "50019", typeof(ExchangeError) },
                    { "50020", typeof(InsufficientFunds) },
                    { "50021", typeof(BadRequest) },
                    { "50022", typeof(ExchangeNotAvailable) },
                    { "50023", typeof(BadSymbol) },
                    { "50024", typeof(BadRequest) },
                    { "50025", typeof(BadRequest) },
                    { "50026", typeof(BadRequest) },
                    { "50027", typeof(BadRequest) },
                    { "50028", typeof(BadRequest) },
                    { "50029", typeof(InvalidOrder) },
                    { "50030", typeof(OrderNotFound) },
                    { "50031", typeof(OrderNotFound) },
                    { "50032", typeof(OrderNotFound) },
                    { "50033", typeof(InvalidOrder) },
                    { "50034", typeof(InvalidOrder) },
                    { "50035", typeof(InvalidOrder) },
                    { "50036", typeof(ExchangeError) },
                    { "50037", typeof(BadRequest) },
                    { "50038", typeof(BadRequest) },
                    { "50039", typeof(BadRequest) },
                    { "50040", typeof(BadSymbol) },
                    { "50041", typeof(ExchangeError) },
                    { "50042", typeof(BadRequest) },
                    { "51000", typeof(BadSymbol) },
                    { "51001", typeof(ExchangeError) },
                    { "51002", typeof(ExchangeError) },
                    { "51003", typeof(ExchangeError) },
                    { "51004", typeof(InsufficientFunds) },
                    { "51005", typeof(InvalidOrder) },
                    { "51006", typeof(InvalidOrder) },
                    { "51007", typeof(BadRequest) },
                    { "51008", typeof(ExchangeError) },
                    { "51009", typeof(InvalidOrder) },
                    { "51010", typeof(InvalidOrder) },
                    { "51011", typeof(InvalidOrder) },
                    { "51012", typeof(InvalidOrder) },
                    { "51013", typeof(InvalidOrder) },
                    { "51014", typeof(InvalidOrder) },
                    { "51015", typeof(InvalidOrder) },
                    { "52000", typeof(BadRequest) },
                    { "52001", typeof(BadRequest) },
                    { "52002", typeof(BadRequest) },
                    { "52003", typeof(BadRequest) },
                    { "52004", typeof(BadRequest) },
                    { "53000", typeof(AccountSuspended) },
                    { "53001", typeof(AccountSuspended) },
                    { "53002", typeof(PermissionDenied) },
                    { "53003", typeof(PermissionDenied) },
                    { "53005", typeof(PermissionDenied) },
                    { "53006", typeof(PermissionDenied) },
                    { "53007", typeof(PermissionDenied) },
                    { "53008", typeof(PermissionDenied) },
                    { "53009", typeof(PermissionDenied) },
                    { "53010", typeof(PermissionDenied) },
                    { "57001", typeof(BadRequest) },
                    { "58001", typeof(BadRequest) },
                    { "59001", typeof(ExchangeError) },
                    { "59002", typeof(ExchangeError) },
                    { "59003", typeof(ExchangeError) },
                    { "59004", typeof(ExchangeError) },
                    { "59005", typeof(PermissionDenied) },
                    { "59006", typeof(ExchangeError) },
                    { "59007", typeof(ExchangeError) },
                    { "59008", typeof(ExchangeError) },
                    { "59009", typeof(ExchangeError) },
                    { "59010", typeof(InsufficientFunds) },
                    { "59011", typeof(ExchangeError) },
                    { "40001", typeof(ExchangeError) },
                    { "40002", typeof(ExchangeError) },
                    { "40003", typeof(ExchangeError) },
                    { "40004", typeof(ExchangeError) },
                    { "40005", typeof(ExchangeError) },
                    { "40006", typeof(PermissionDenied) },
                    { "40007", typeof(BadRequest) },
                    { "40008", typeof(InvalidNonce) },
                    { "40009", typeof(BadRequest) },
                    { "40010", typeof(BadRequest) },
                    { "40011", typeof(BadRequest) },
                    { "40012", typeof(ExchangeError) },
                    { "40013", typeof(ExchangeError) },
                    { "40014", typeof(BadSymbol) },
                    { "40015", typeof(BadSymbol) },
                    { "40016", typeof(InvalidOrder) },
                    { "40017", typeof(InvalidOrder) },
                    { "40018", typeof(InvalidOrder) },
                    { "40019", typeof(ExchangeError) },
                    { "40020", typeof(InvalidOrder) },
                    { "40021", typeof(ExchangeError) },
                    { "40022", typeof(ExchangeError) },
                    { "40023", typeof(ExchangeError) },
                    { "40024", typeof(ExchangeError) },
                    { "40025", typeof(ExchangeError) },
                    { "40026", typeof(ExchangeError) },
                    { "40027", typeof(InsufficientFunds) },
                    { "40028", typeof(PermissionDenied) },
                    { "40029", typeof(InvalidOrder) },
                    { "40030", typeof(InvalidOrder) },
                    { "40031", typeof(InvalidOrder) },
                    { "40032", typeof(InvalidOrder) },
                    { "40033", typeof(InvalidOrder) },
                    { "40034", typeof(BadSymbol) },
                    { "40035", typeof(OrderNotFound) },
                    { "40036", typeof(InvalidOrder) },
                    { "40037", typeof(OrderNotFound) },
                    { "40038", typeof(BadRequest) },
                    { "40039", typeof(BadRequest) },
                    { "40040", typeof(InvalidOrder) },
                    { "40041", typeof(InvalidOrder) },
                    { "40042", typeof(InvalidOrder) },
                    { "40043", typeof(InvalidOrder) },
                    { "40044", typeof(InvalidOrder) },
                    { "40045", typeof(InvalidOrder) },
                    { "40046", typeof(PermissionDenied) },
                    { "40047", typeof(PermissionDenied) },
                    { "40048", typeof(InvalidOrder) },
                    { "40049", typeof(InvalidOrder) },
                    { "40050", typeof(InvalidOrder) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "You contract account available balance not enough", typeof(InsufficientFunds) },
                    { "you contract account available balance not enough", typeof(InsufficientFunds) },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "$GM", "GOLDMINER" },
                { "$HERO", "Step Hero" },
                { "$PAC", "PAC" },
                { "BP", "BEYOND" },
                { "GDT", "Gorilla Diamond" },
                { "GLD", "Goldario" },
                { "MVP", "MVP Coin" },
                { "TRU", "Truebit" },
            } },
            { "options", new Dictionary<string, object>() {
                { "defaultNetworks", new Dictionary<string, object>() {
                    { "USDT", "TRC20" },
                    { "BTC", "BTC" },
                    { "ETH", "ERC20" },
                } },
                { "timeDifference", 0 },
                { "adjustForTimeDifference", false },
                { "networks", new Dictionary<string, object>() {
                    { "ERC20", "ERC20" },
                    { "SOL", "SOL" },
                    { "BTC", "BTC" },
                    { "TRC20", "TRC20" },
                    { "OMNI", "OMNI" },
                    { "XLM", "XLM" },
                    { "EOS", "EOS" },
                    { "NEO", "NEO" },
                    { "BTM", "BTM" },
                    { "BCH", "BCH" },
                    { "LTC", "LTC" },
                    { "BSV", "BSV" },
                    { "XRP", "XRP" },
                    { "PLEX", "PLEX" },
                    { "XCH", "XCH" },
                    { "NEAR", "NEAR" },
                    { "FIO", "FIO" },
                    { "SCRT", "SCRT" },
                    { "IOTX", "IOTX" },
                    { "ALGO", "ALGO" },
                    { "ATOM", "ATOM" },
                    { "DOT", "DOT" },
                    { "ADA", "ADA" },
                    { "DOGE", "DOGE" },
                    { "XYM", "XYM" },
                    { "GLMR", "GLMR" },
                    { "MOVR", "MOVR" },
                    { "ZIL", "ZIL" },
                    { "INJ", "INJ" },
                    { "KSM", "KSM" },
                    { "ZEC", "ZEC" },
                    { "NAS", "NAS" },
                    { "POLYGON", "MATIC" },
                    { "HRC20", "HECO" },
                    { "XDC", "XDC" },
                    { "ONE", "ONE" },
                    { "LAT", "LAT" },
                    { "CSPR", "Casper" },
                    { "ICP", "Computer" },
                    { "XTZ", "XTZ" },
                    { "MINA", "MINA" },
                    { "BEP20", "BSC_BNB" },
                    { "THETA", "THETA" },
                    { "AKT", "AKT" },
                    { "AR", "AR" },
                    { "CELO", "CELO" },
                    { "FIL", "FIL" },
                    { "NULS", "NULS" },
                    { "ETC", "ETC" },
                    { "DASH", "DASH" },
                    { "DGB", "DGB" },
                    { "BEP2", "BEP2" },
                    { "GRIN", "GRIN" },
                    { "WAVES", "WAVES" },
                    { "ABBC", "ABBC" },
                    { "ACA", "ACA" },
                    { "QTUM", "QTUM" },
                    { "PAC", "PAC" },
                    { "TLOS", "TLOS" },
                    { "KARDIA", "KardiaChain" },
                    { "FUSE", "FUSE" },
                    { "TRC10", "TRC10" },
                    { "FIRO", "FIRO" },
                    { "FTM", "Fantom" },
                    { "EVER", "EVER" },
                    { "KAVA", "KAVA" },
                    { "HYDRA", "HYDRA" },
                    { "PLCU", "PLCU" },
                    { "BRISE", "BRISE" },
                    { "OPTIMISM", "OPTIMISM" },
                    { "REEF", "REEF" },
                    { "SYS", "SYS" },
                    { "VITE", "VITE" },
                    { "STX", "STX" },
                    { "SXP", "SXP" },
                    { "BITCI", "BITCI" },
                    { "XRD", "XRD" },
                    { "ASTR", "ASTAR" },
                    { "ZEN", "HORIZEN" },
                    { "LTO", "LTO" },
                    { "ETHW", "ETHW" },
                    { "ETHF", "ETHF" },
                    { "IOST", "IOST" },
                    { "APT", "APT" },
                    { "ONT", "ONT" },
                    { "EVMOS", "EVMOS" },
                    { "XMR", "XMR" },
                    { "OASYS", "OAS" },
                    { "OSMO", "OSMO" },
                    { "OMAX", "OMAX Chain" },
                    { "DESO", "DESO" },
                    { "BFIC", "BFIC" },
                    { "OHO", "OHO" },
                    { "CS", "CS" },
                    { "CHEQ", "CHEQ" },
                    { "NODL", "NODL" },
                    { "NEM", "XEM" },
                    { "FRA", "FRA" },
                    { "ERGO", "ERG" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "ETH", "ERC20" },
                    { "Ethereum", "ERC20" },
                    { "USDT", "OMNI" },
                    { "Bitcoin", "BTC" },
                } },
                { "defaultType", "spot" },
                { "fetchBalance", new Dictionary<string, object>() {
                    { "type", "spot" },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "spot" },
                    { "swap", "swap" },
                } },
                { "createMarketBuyOrderRequiresPrice", true },
                { "brokerId", "CCXTxBitmart000" },
            } },
            { "features", new Dictionary<string, object>() {
                { "default", new Dictionary<string, object>() {
                    { "sandbox", false },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "triggerPrice", false },
                        { "triggerPriceType", null },
                        { "triggerDirection", false },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", false },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "trailing", false },
                        { "marketBuyRequiresPrice", false },
                        { "marketBuyByCost", true },
                        { "leverage", true },
                        { "selfTradePrevention", false },
                        { "iceberg", false },
                    } },
                    { "createOrders", new Dictionary<string, object>() {
                        { "max", 10 },
                    } },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", 200 },
                        { "daysBack", null },
                        { "untilDays", 99999 },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", 200 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", null },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", 200 },
                        { "daysBack", null },
                        { "daysBackCanceled", null },
                        { "untilDays", null },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 1000 },
                    } },
                } },
                { "forDerivatives", new Dictionary<string, object>() {
                    { "extends", "default" },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "triggerPrice", true },
                        { "triggerPriceType", new Dictionary<string, object>() {
                            { "last", true },
                            { "mark", true },
                            { "index", false },
                        } },
                        { "triggerDirection", true },
                        { "stopLossPrice", true },
                        { "takeProfitPrice", true },
                        { "attachedStopLossTakeProfit", new Dictionary<string, object>() {
                            { "triggerPriceType", new Dictionary<string, object>() {
                                { "last", true },
                                { "mark", true },
                                { "index", false },
                            } },
                            { "price", false },
                        } },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "trailing", true },
                        { "marketBuyRequiresPrice", true },
                        { "marketBuyByCost", true },
                    } },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", null },
                        { "daysBack", null },
                        { "untilDays", 99999 },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", true },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "trigger", true },
                        { "trailing", false },
                    } },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", 200 },
                        { "daysBack", null },
                        { "daysBackCanceled", null },
                        { "untilDays", null },
                        { "trigger", false },
                        { "trailing", false },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 500 },
                    } },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "extends", "default" },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "forDerivatives" },
                    } },
                    { "inverse", new Dictionary<string, object>() {
                        { "extends", "forDerivatives" },
                    } },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
            } },
        });
    }

    /**
     * @method
     * @name bitmart#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetSystemTime(parameters);
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"c4e5e5b7-fe9f-4191-89f7-53f6c5bf9030",
        //         "data":{
        //             "server_time":1599843709578
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.safeInteger(data, "server_time");
    }

    /**
     * @method
     * @name bitmart#fetchStatus
     * @description the latest known information on the availability of the exchange API
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
     */
    public async override Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object options = this.safeDict(this.options, "fetchStatus", new Dictionary<string, object>() {});
        object defaultType = this.safeString(this.options, "defaultType");
        object type = this.safeString(options, "type", defaultType);
        type = this.safeString(parameters, "type", type);
        parameters = this.omit(parameters, "type");
        object response = await this.publicGetSystemService(parameters);
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "1d3f28b0-763e-4f78-90c4-5e3ad19dc595",
        //         "data": {
        //           "service": [
        //             {
        //               "title": "Spot API Stop",
        //               "service_type": "spot",
        //               "status": 2,
        //               "start_time": 1648639069125,
        //               "end_time": 1648639069125
        //             },
        //             {
        //               "title": "Contract API Stop",
        //               "service_type": "contract",
        //               "status": 2,
        //               "start_time": 1648639069125,
        //               "end_time": 1648639069125
        //             }
        //           ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object services = this.safeList(data, "service", new List<object>() {});
        object servicesByType = this.indexBy(services, "service_type");
        if (isTrue(isEqual(type, "swap")))
        {
            type = "contract";
        }
        object service = this.safeString(servicesByType, type);
        object status = null;
        object eta = null;
        if (isTrue(!isEqual(service, null)))
        {
            object statusCode = this.safeInteger(service, "status");
            if (isTrue(isEqual(statusCode, 2)))
            {
                status = "ok";
            } else
            {
                status = "maintenance";
                eta = this.safeInteger(service, "end_time");
            }
        }
        return new Dictionary<string, object>() {
            { "status", status },
            { "updated", null },
            { "eta", eta },
            { "url", null },
            { "info", response },
        };
    }

    public async virtual Task<object> fetchSpotMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetSpotV1SymbolsDetails(parameters);
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"a67c9146-086d-4d3f-9897-5636a9bb26e1",
        //         "data":{
        //             "symbols":[
        //               {
        //                  "symbol": "BTC_USDT",
        //                  "symbol_id": 53,
        //                  "base_currency": "BTC",
        //                  "quote_currency": "USDT",
        //                  "base_min_size": "0.000010000000000000000000000000",
        //                  "base_max_size": "100000000.000000000000000000000000000000",
        //                  "price_min_precision": -1,
        //                  "price_max_precision": 2,
        //                  "quote_increment": "0.00001", // Api docs says "The minimum order quantity is also the minimum order quantity increment", however I think they mistakenly use the term 'order quantity'
        //                  "expiration": "NA",
        //                  "min_buy_amount": "5.000000000000000000000000000000",
        //                  "min_sell_amount": "5.000000000000000000000000000000",
        //                  "trade_status": "trading"
        //               },
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object symbols = this.safeList(data, "symbols", new List<object>() {});
        object result = new List<object>() {};
        object fees = getValue(this.fees, "trading");
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object market = getValue(symbols, i);
            object id = this.safeString(market, "symbol");
            object numericId = this.safeInteger(market, "symbol_id");
            object baseId = this.safeString(market, "base_currency");
            object quoteId = this.safeString(market, "quote_currency");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object symbol = add(add(bs, "/"), quote);
            object minBuyCost = this.safeString(market, "min_buy_amount");
            object minSellCost = this.safeString(market, "min_sell_amount");
            object minCost = Precise.stringMax(minBuyCost, minSellCost);
            object baseMinSize = this.safeNumber(market, "base_min_size");
            ((IList<object>)result).Add(this.safeMarketStructure(new Dictionary<string, object>() {
                { "id", id },
                { "numericId", numericId },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", true },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "maker", getValue(fees, "maker") },
                { "taker", getValue(fees, "taker") },
                { "precision", new Dictionary<string, object>() {
                    { "amount", baseMinSize },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "price_max_precision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", baseMinSize },
                        { "max", this.safeNumber(market, "base_max_size") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.parseNumber(minCost) },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", market },
            }));
        }
        return result;
    }

    public async virtual Task<object> fetchContractMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetContractPublicDetails(parameters);
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": {
        //             "symbols": [
        //                 {
        //                     "symbol": "BTCUSDT",
        //                     "product_type": 1,
        //                     "open_timestamp": 1645977600000,
        //                     "expire_timestamp": 0,
        //                     "settle_timestamp": 0,
        //                     "base_currency": "BTC",
        //                     "quote_currency": "USDT",
        //                     "last_price": "63547.4",
        //                     "volume_24h": "110938430",
        //                     "turnover_24h": "7004836342.6944",
        //                     "index_price": "63587.85404255",
        //                     "index_name": "BTCUSDT",
        //                     "contract_size": "0.001",
        //                     "min_leverage": "1",
        //                     "max_leverage": "100",
        //                     "price_precision": "0.1",
        //                     "vol_precision": "1",
        //                     "max_volume": "1000000",
        //                     "min_volume": "1",
        //                     "funding_rate": "0.0000801",
        //                     "expected_funding_rate": "-0.0000035",
        //                     "open_interest": "278214",
        //                     "open_interest_value": "17555316.9355496",
        //                     "high_24h": "64109.4",
        //                     "low_24h": "61857.6",
        //                     "change_24h": "0.0239264900886327",
        //                     "funding_time": 1726819200000
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object symbols = this.safeList(data, "symbols", new List<object>() {});
        object result = new List<object>() {};
        object fees = getValue(this.fees, "trading");
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object market = getValue(symbols, i);
            object id = this.safeString(market, "symbol");
            object baseId = this.safeString(market, "base_currency");
            object quoteId = this.safeString(market, "quote_currency");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object settleId = "USDT"; // this is bitmart's ID for usdt
            object settle = this.safeCurrencyCode(settleId);
            object symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
            object productType = this.safeInteger(market, "product_type");
            object isSwap = (isEqual(productType, 1));
            object isFutures = (isEqual(productType, 2));
            object expiry = this.safeInteger(market, "expire_timestamp");
            if (isTrue(!isTrue(isFutures) && isTrue((isEqual(expiry, 0)))))
            {
                expiry = null;
            }
            ((IList<object>)result).Add(this.safeMarketStructure(new Dictionary<string, object>() {
                { "id", id },
                { "numericId", null },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", ((bool) isTrue(isSwap)) ? "swap" : "future" },
                { "spot", false },
                { "margin", false },
                { "swap", isSwap },
                { "future", isFutures },
                { "option", false },
                { "active", true },
                { "contract", true },
                { "linear", true },
                { "inverse", false },
                { "contractSize", this.safeNumber(market, "contract_size") },
                { "expiry", expiry },
                { "expiryDatetime", this.iso8601(expiry) },
                { "strike", null },
                { "optionType", null },
                { "maker", getValue(fees, "maker") },
                { "taker", getValue(fees, "taker") },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.safeNumber(market, "vol_precision") },
                    { "price", this.safeNumber(market, "price_precision") },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_leverage") },
                        { "max", this.safeNumber(market, "max_leverage") },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_volume") },
                        { "max", this.safeNumber(market, "max_volume") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", this.safeInteger(market, "open_timestamp") },
                { "info", market },
            }));
        }
        return result;
    }

    /**
     * @method
     * @name bitmart#fetchMarkets
     * @see https://developer-pro.bitmart.com/en/futuresv2/#get-contract-details
     * @description retrieves data on all markets for bitmart
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.options, "adjustForTimeDifference")))
        {
            await this.loadTimeDifference();
        }
        object spot = await this.fetchSpotMarkets(parameters);
        object contract = await this.fetchContractMarkets(parameters);
        return this.arrayConcat(spot, contract);
    }

    /**
     * @method
     * @name bitmart#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetAccountV1Currencies(parameters);
        //
        //     {
        //         "message": "OK",
        //         "code":1000,
        //         "trace": "9eaec51cd80d46d48a1c6b447206c4d6.71.17392193317851454",
        //         "data": {
        //             "currencies": [
        //                 {
        //                     "currency": "BTC",
        //                     "name": "Bitcoin",
        //                     "contract_address": null,
        //                     "network": "BTC",
        //                     "withdraw_enabled": true,
        //                     "deposit_enabled": true,
        //                     "withdraw_minsize": "0.0003",
        //                     "withdraw_minfee": "9.74"
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object currencies = this.safeList(data, "currencies", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currency = getValue(currencies, i);
            object fullId = this.safeString(currency, "currency");
            object currencyId = fullId;
            object networkId = this.safeString(currency, "network");
            if (isTrue(isLessThan(getIndexOf(fullId, "NFT"), 0)))
            {
                object parts = ((string)fullId).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
                currencyId = this.safeString(parts, 0);
                object second = this.safeString(parts, 1);
                if (isTrue(!isEqual(second, null)))
                {
                    networkId = ((string)second).ToUpper();
                }
            }
            object currencyCode = this.safeCurrencyCode(currencyId);
            object entry = this.safeDict(result, currencyCode);
            if (isTrue(isEqual(entry, null)))
            {
                entry = new Dictionary<string, object>() {
                    { "info", currency },
                    { "id", currencyId },
                    { "code", currencyCode },
                    { "precision", null },
                    { "name", this.safeString(currency, "name") },
                    { "deposit", null },
                    { "withdraw", null },
                    { "active", null },
                    { "networks", new Dictionary<string, object>() {} },
                };
            }
            object networkCode = this.networkIdToCode(networkId);
            object withdraw = this.safeBool(currency, "withdraw_enabled");
            object deposit = this.safeBool(currency, "deposit_enabled");
            ((IDictionary<string,object>)getValue(entry, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                { "info", currency },
                { "id", networkId },
                { "code", networkCode },
                { "withdraw", withdraw },
                { "deposit", deposit },
                { "active", isTrue(withdraw) && isTrue(deposit) },
                { "fee", this.safeNumber(currency, "withdraw_minfee") },
                { "limits", new Dictionary<string, object>() {
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.safeNumber(currency, "withdraw_minsize") },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
            };
            ((IDictionary<string,object>)result)[(string)currencyCode] = entry;
        }
        object keys = new List<object>(((IDictionary<string,object>)result).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object currency = getValue(result, key);
            ((IDictionary<string,object>)result)[(string)key] = this.safeCurrencyStructure(currency);
        }
        return result;
    }

    public virtual object getCurrencyIdFromCodeAndNetwork(object currencyCode, object networkCode)
    {
        if (isTrue(isEqual(networkCode, null)))
        {
            networkCode = this.defaultNetworkCode(currencyCode); // use default network code if not provided
        }
        object currency = this.currency(currencyCode);
        object id = getValue(currency, "id");
        object idFromNetwork = null;
        object networks = this.safeDict(currency, "networks", new Dictionary<string, object>() {});
        object networkInfo = new Dictionary<string, object>() {};
        if (isTrue(isEqual(networkCode, null)))
        {
            // network code is not provided and there is no default network code
            object network = this.safeDict(networks, currencyCode); // trying to find network that has the same code as currency
            if (isTrue(isEqual(network, null)))
            {
                // use the first network in the networks list if there is no network code with the same code as currency
                object keys = new List<object>(((IDictionary<string,object>)networks).Keys);
                object length = getArrayLength(keys);
                if (isTrue(isGreaterThan(length, 0)))
                {
                    network = this.safeValue(networks, getValue(keys, 0));
                }
            }
            networkInfo = this.safeDict(network, "info", new Dictionary<string, object>() {});
            idFromNetwork = this.safeString(networkInfo, "currency"); // use currency name from network
        } else
        {
            object providedOrDefaultNetwork = this.safeDict(networks, networkCode);
            if (isTrue(!isEqual(providedOrDefaultNetwork, null)))
            {
                networkInfo = this.safeDict(providedOrDefaultNetwork, "info", new Dictionary<string, object>() {});
                idFromNetwork = this.safeString(networkInfo, "currency"); // use currency name from network
            } else
            {
                id = add(id, add("-", this.networkCodeToId(networkCode, currencyCode))); // use concatenated currency id and network code if network is not found
            }
        }
        return ((bool) isTrue((!isEqual(idFromNetwork, null)))) ? idFromNetwork : id;
    }

    /**
     * @method
     * @name bitmart#fetchTransactionFee
     * @deprecated
     * @description please use fetchDepositWithdrawFee instead
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network] the network code of the currency
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public async override Task<object> fetchTransactionFee(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object network = null;
        var networkparametersVariable = this.handleNetworkCodeAndParams(parameters);
        network = ((IList<object>)networkparametersVariable)[0];
        parameters = ((IList<object>)networkparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "currency", this.getCurrencyIdFromCodeAndNetwork(getValue(currency, "code"), network) },
        };
        object response = await this.privateGetAccountV1WithdrawCharge(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": "1000",
        //         "trace": "3ecc0adf-91bd-4de7-aca1-886c1122f54f",
        //         "data": {
        //             "today_available_withdraw_BTC": "100.0000",
        //             "min_withdraw": "0.005",
        //             "withdraw_precision": "8",
        //             "withdraw_fee": "0.000500000000000000000000000000"
        //         }
        //     }
        //
        object data = getValue(response, "data");
        object withdrawFees = new Dictionary<string, object>() {};
        ((IDictionary<string,object>)withdrawFees)[(string)code] = this.safeNumber(data, "withdraw_fee");
        return new Dictionary<string, object>() {
            { "info", response },
            { "withdraw", withdrawFees },
            { "deposit", new Dictionary<string, object>() {} },
        };
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //    {
        //        "today_available_withdraw_BTC": "100.0000",
        //        "min_withdraw": "0.005",
        //        "withdraw_precision": "8",
        //        "withdraw_fee": "0.000500000000000000000000000000"
        //    }
        //
        return new Dictionary<string, object>() {
            { "info", fee },
            { "withdraw", new Dictionary<string, object>() {
                { "fee", this.safeNumber(fee, "withdraw_fee") },
                { "percentage", null },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
    }

    /**
     * @method
     * @name bitmart#fetchDepositWithdrawFee
     * @description fetch the fee for deposits and withdrawals
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network] the network code of the currency
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public async override Task<object> fetchDepositWithdrawFee(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object network = null;
        var networkparametersVariable = this.handleNetworkCodeAndParams(parameters);
        network = ((IList<object>)networkparametersVariable)[0];
        parameters = ((IList<object>)networkparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "currency", this.getCurrencyIdFromCodeAndNetwork(code, network) },
        };
        object response = await this.privateGetAccountV1WithdrawCharge(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": "1000",
        //         "trace": "3ecc0adf-91bd-4de7-aca1-886c1122f54f",
        //         "data": {
        //             "today_available_withdraw_BTC": "100.0000",
        //             "min_withdraw": "0.005",
        //             "withdraw_precision": "8",
        //             "withdraw_fee": "0.000500000000000000000000000000"
        //         }
        //     }
        //
        object data = getValue(response, "data");
        return ((object)this.parseDepositWithdrawFee(data));
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // spot (REST) fetchTickers
        //
        //     {
        //         'result': [
        //             "AFIN_USDT",     // symbol
        //             "0.001047",      // last
        //             "11110",         // v_24h
        //             "11.632170",     // qv_24h
        //             "0.001048",      // open_24h
        //             "0.001048",      // high_24h
        //             "0.001047",      // low_24h
        //             "-0.00095",      // price_change_24h
        //             "0.001029",      // bid_px
        //             "5555",          // bid_sz
        //             "0.001041",      // ask_px
        //             "5297",          // ask_sz
        //             "1717122550482"  // timestamp
        //         ]
        //     }
        //
        // spot (REST) fetchTicker
        //
        //     {
        //         "symbol": "BTC_USDT",
        //         "last": "68500.00",
        //         "v_24h": "10491.65490",
        //         "qv_24h": "717178990.42",
        //         "open_24h": "68149.75",
        //         "high_24h": "69499.99",
        //         "low_24h": "67132.40",
        //         "fluctuation": "0.00514",
        //         "bid_px": "68500",
        //         "bid_sz": "0.00162",
        //         "ask_px": "68500.01",
        //         "ask_sz": "0.01722",
        //         "ts": "1717131391671"
        //     }
        //
        // spot (WS)
        //
        //      {
        //          "symbol":"BTC_USDT",
        //          "last_price":"146.24",
        //          "open_24h":"147.17",
        //          "high_24h":"147.48",
        //          "low_24h":"143.88",
        //          "base_volume_24h":"117387.58", // NOT base, but quote currency!!!
        //          "s_t": 1610936002
        //      }
        //
        // swap
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "product_type": 1,
        //         "open_timestamp": 1645977600000,
        //         "expire_timestamp": 0,
        //         "settle_timestamp": 0,
        //         "base_currency": "BTC",
        //         "quote_currency": "USDT",
        //         "last_price": "63547.4",
        //         "volume_24h": "110938430",
        //         "turnover_24h": "7004836342.6944",
        //         "index_price": "63587.85404255",
        //         "index_name": "BTCUSDT",
        //         "contract_size": "0.001",
        //         "min_leverage": "1",
        //         "max_leverage": "100",
        //         "price_precision": "0.1",
        //         "vol_precision": "1",
        //         "max_volume": "1000000",
        //         "min_volume": "1",
        //         "funding_rate": "0.0000801",
        //         "expected_funding_rate": "-0.0000035",
        //         "open_interest": "278214",
        //         "open_interest_value": "17555316.9355496",
        //         "high_24h": "64109.4",
        //         "low_24h": "61857.6",
        //         "change_24h": "0.0239264900886327",
        //         "funding_time": 1726819200000
        //     }
        //
        object result = this.safeList(ticker, "result", new List<object>() {});
        object average = this.safeString2(ticker, "avg_price", "index_price");
        object marketId = this.safeString2(ticker, "symbol", "contract_symbol");
        object timestamp = this.safeInteger2(ticker, "timestamp", "ts");
        object last = this.safeString2(ticker, "last_price", "last");
        object percentage = this.safeString2(ticker, "price_change_percent_24h", "change_24h");
        object change = this.safeString(ticker, "fluctuation");
        object high = this.safeString2(ticker, "high_24h", "high_price");
        object low = this.safeString2(ticker, "low_24h", "low_price");
        object bid = this.safeString2(ticker, "best_bid", "bid_px");
        object bidVolume = this.safeString2(ticker, "best_bid_size", "bid_sz");
        object ask = this.safeString2(ticker, "best_ask", "ask_px");
        object askVolume = this.safeString2(ticker, "best_ask_size", "ask_sz");
        object open = this.safeString(ticker, "open_24h");
        object baseVolume = this.safeStringN(ticker, new List<object>() {"base_volume_24h", "v_24h", "volume_24h"});
        object quoteVolume = this.safeStringLowerN(ticker, new List<object>() {"quote_volume_24h", "qv_24h", "turnover_24h"});
        object listMarketId = this.safeString(result, 0);
        if (isTrue(!isEqual(listMarketId, null)))
        {
            marketId = listMarketId;
            timestamp = this.safeInteger(result, 12);
            high = this.safeString(result, 5);
            low = this.safeString(result, 6);
            bid = this.safeString(result, 8);
            bidVolume = this.safeString(result, 9);
            ask = this.safeString(result, 10);
            askVolume = this.safeString(result, 11);
            open = this.safeString(result, 4);
            last = this.safeString(result, 1);
            change = this.safeString(result, 7);
            baseVolume = this.safeString(result, 2);
            quoteVolume = this.safeStringLower(result, 3);
        }
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        if (isTrue(isEqual(timestamp, null)))
        {
            // ticker from WS has a different field (in seconds)
            timestamp = this.safeIntegerProduct(ticker, "s_t", 1000);
        }
        if (isTrue(isEqual(percentage, null)))
        {
            percentage = Precise.stringMul(change, "100");
        }
        if (isTrue(isEqual(quoteVolume, null)))
        {
            if (isTrue(isEqual(baseVolume, null)))
            {
                // this is swap
                quoteVolume = this.safeString(ticker, "volume_24h", quoteVolume);
            } else
            {
                // this is a ticker from websockets
                // contrary to name and documentation, base_volume_24h is actually the quote volume
                quoteVolume = baseVolume;
                baseVolume = null;
            }
        }
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", high },
            { "low", low },
            { "bid", bid },
            { "bidVolume", bidVolume },
            { "ask", ask },
            { "askVolume", askVolume },
            { "vwap", null },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", percentage },
            { "average", average },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "indexPrice", this.safeString(ticker, "index_price") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name bitmart#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://developer-pro.bitmart.com/en/spot/#get-ticker-of-a-trading-pair-v3
     * @see https://developer-pro.bitmart.com/en/futuresv2/#get-contract-details
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.publicGetContractPublicDetails(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "spot")))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.publicGetSpotQuotationV3Ticker(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchTicker() does not support "), getValue(market, "type")), " markets, only spot and swap markets are accepted")) ;
        }
        // fails in naming for contract tickers 'contract_symbol'
        object tickers = new List<object>() {};
        object ticker = new Dictionary<string, object>() {};
        if (isTrue(getValue(market, "spot")))
        {
            ticker = this.safeDict(response, "data", new Dictionary<string, object>() {});
        } else
        {
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            tickers = this.safeList(data, "symbols", new List<object>() {});
            ticker = this.safeDict(tickers, 0, new Dictionary<string, object>() {});
        }
        return this.parseTicker(ticker, market);
    }

    /**
     * @method
     * @name bitmart#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://developer-pro.bitmart.com/en/spot/#get-ticker-of-all-pairs-v3
     * @see https://developer-pro.bitmart.com/en/futuresv2/#get-contract-details
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object type = null;
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = this.safeString(symbols, 0);
            market = this.market(symbol);
        }
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(type, "spot")))
        {
            response = await this.publicGetSpotQuotationV3Tickers(parameters);
        } else if (isTrue(isEqual(type, "swap")))
        {
            response = await this.publicGetContractPublicDetails(parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchTickers() does not support "), type), " markets, only spot and swap markets are accepted")) ;
        }
        object tickers = new List<object>() {};
        if (isTrue(isEqual(type, "spot")))
        {
            tickers = this.safeList(response, "data", new List<object>() {});
        } else
        {
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            tickers = this.safeList(data, "symbols", new List<object>() {});
        }
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(tickers)); postFixIncrement(ref i))
        {
            object ticker = new Dictionary<string, object>() {};
            if (isTrue(isEqual(type, "spot")))
            {
                ticker = this.parseTicker(new Dictionary<string, object>() {
                    { "result", getValue(tickers, i) },
                });
            } else
            {
                ticker = this.parseTicker(getValue(tickers, i));
            }
            object symbol = getValue(ticker, "symbol");
            ((IDictionary<string,object>)result)[(string)symbol] = ticker;
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    /**
     * @method
     * @name bitmart#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://developer-pro.bitmart.com/en/spot/#get-depth-v3
     * @see https://developer-pro.bitmart.com/en/futures/#get-market-depth
     * @see https://developer-pro.bitmart.com/en/futuresv2/#get-market-depth
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit; // default 35, max 50
            }
            response = await this.publicGetSpotQuotationV3Books(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "swap")))
        {
            response = await this.publicGetContractPublicDepth(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOrderBook() does not support "), getValue(market, "type")), " markets, only spot and swap markets are accepted")) ;
        }
        //
        // spot
        //
        //     {
        //         "code": 1000,
        //         "message": "success",
        //         "data": {
        //             "ts": "1695264191808",
        //             "symbol": "BTC_USDT",
        //             "asks": [
        //                 ["26942.57","0.06492"],
        //                 ["26942.73","0.05447"],
        //                 ["26943.00","0.07154"]
        //             ],
        //             "bids": [
        //                 ["26942.45","0.00074"],
        //                 ["26941.53","0.00371"],
        //                 ["26940.94","0.08992"]
        //             ]
        //         },
        //         "trace": "430a7f69581d4258a8e4b424dfb10782.73.16952341919017619"
        //     }
        //
        // swap
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": {
        //             "asks": [
        //                 ["26938.3","3499","3499"],
        //                 ["26938.5","14702","18201"],
        //                 ["26938.6","20457","38658"]
        //             ],
        //             "bids": [
        //                 ["26938.2","20","20"],
        //                 ["26937.9","1913","1933"],
        //                 ["26937.8","2588","4521"]
        //             ],
        //             "timestamp": 1695264383999,
        //             "symbol": "BTCUSDT"
        //         },
        //         "trace": "4cad855074664097ac6ba5258c47305d.72.16952643834721135"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger2(data, "ts", "timestamp");
        return this.parseOrderBook(data, getValue(market, "symbol"), timestamp);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public fetchTrades spot ( amount = count * price )
        //
        //     [
        //         "BTC_USDT",      // symbol
        //         "1717212457302", // timestamp
        //         "67643.11",      // price
        //         "0.00106",       // size
        //         "sell"           // side
        //     ]
        //
        // spot: fetchMyTrades
        //
        //    {
        //        "tradeId":"182342999769370687",
        //        "orderId":"183270218784142990",
        //        "clientOrderId":"183270218784142990",
        //        "symbol":"ADA_USDT",
        //        "side":"buy",
        //        "orderMode":"spot",
        //        "type":"market",
        //        "price":"0.245948",
        //        "size":"20.71",
        //        "notional":"5.09358308",
        //        "fee":"0.00509358",
        //        "feeCoinName":"USDT",
        //        "tradeRole":"taker",
        //        "createTime":1695658457836,
        //    }
        //
        // swap: fetchMyTrades
        //
        //    {
        //        "order_id": "230930336848609",
        //        "trade_id": "6212604014",
        //        "symbol": "BTCUSDT",
        //        "side": 3,
        //        "price": "26910.4",
        //        "vol": "1",
        //        "exec_type": "Taker",
        //        "profit": false,
        //        "create_time": 1695961596692,
        //        "realised_profit": "-0.0003",
        //        "paid_fees": "0.01614624"
        //    }
        //
        // ws swap
        //
        //    {
        //        'fee': '-0.000044502',
        //        'feeCcy': 'USDT',
        //        'fillPrice': '74.17',
        //        'fillQty': '1',
        //        'lastTradeID': 6802340762
        //    }
        //
        object timestamp = this.safeIntegerN(trade, new List<object>() {"createTime", "create_time", 1});
        object isPublic = this.safeString(trade, 0);
        object isPublicTrade = (!isEqual(isPublic, null));
        object amount = null;
        object cost = null;
        object type = null;
        object side = null;
        if (isTrue(isPublicTrade))
        {
            amount = this.safeString2(trade, "count", 3);
            cost = this.safeString(trade, "amount");
            side = this.safeString2(trade, "type", 4);
        } else
        {
            amount = this.safeStringN(trade, new List<object>() {"size", "vol", "fillQty"});
            cost = this.safeString(trade, "notional");
            type = this.safeString(trade, "type");
            side = this.parseOrderSide(this.safeString(trade, "side"));
        }
        object marketId = this.safeString2(trade, "symbol", 0);
        market = this.safeMarket(marketId, market);
        object feeCostString = this.safeString2(trade, "fee", "paid_fees");
        object fee = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCurrencyId = this.safeString(trade, "feeCoinName");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            if (isTrue(isEqual(feeCurrencyCode, null)))
            {
                feeCurrencyCode = ((bool) isTrue((isEqual(side, "buy")))) ? getValue(market, "base") : getValue(market, "quote");
            }
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", feeCurrencyCode },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeStringN(trade, new List<object>() {"tradeId", "trade_id", "lastTradeID"}) },
            { "order", this.safeString2(trade, "orderId", "order_id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "side", side },
            { "price", this.safeStringN(trade, new List<object>() {"price", "fillPrice", 2}) },
            { "amount", amount },
            { "cost", cost },
            { "takerOrMaker", this.safeStringLower2(trade, "tradeRole", "exec_type") },
            { "fee", fee },
        }, market);
    }

    /**
     * @method
     * @name bitmart#fetchTrades
     * @description get a list of the most recent trades for a particular symbol
     * @see https://developer-pro.bitmart.com/en/spot/#get-recent-trades-v3
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum number of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchTrades() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.publicGetSpotQuotationV3Trades(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "trace": "58031f9a5bd.111.17117",
        //         "message": "success",
        //         "data": [
        //             [
        //                 "BTC_USDT",
        //                 "1717212457302",
        //                 "67643.11",
        //                 "0.00106",
        //                 "sell"
        //             ],
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        // spot
        //    [
        //        "1699512060", // timestamp
        //        "36746.49", // open
        //        "36758.71", // high
        //        "36736.13", // low
        //        "36755.99", // close
        //        "2.83965", // base volume
        //        "104353.57" // quote volume
        //    ]
        //
        // swap
        //    {
        //        "low_price": "20090.3",
        //        "high_price": "20095.5",
        //        "open_price": "20092.6",
        //        "close_price": "20091.4",
        //        "volume": "8748",
        //        "timestamp": 1665002281
        //    }
        //
        // ws
        //    [
        //        1631056350, // timestamp
        //        "46532.83", // open
        //        "46555.71", // high
        //        "46511.41", // low
        //        "46555.71", // close
        //        "0.25", // volume
        //    ]
        //
        // ws swap
        //    {
        //        "symbol":"BTCUSDT",
        //        "o":"146.24",
        //        "h":"146.24",
        //        "l":"146.24",
        //        "c":"146.24",
        //        "v":"146"
        //    }
        //
        if (isTrue(((ohlcv is IList<object>) || (ohlcv.GetType().IsGenericType && ohlcv.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            return new List<object> {this.safeTimestamp(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
        } else
        {
            return new List<object> {this.safeTimestamp2(ohlcv, "timestamp", "ts"), this.safeNumber2(ohlcv, "open_price", "o"), this.safeNumber2(ohlcv, "high_price", "h"), this.safeNumber2(ohlcv, "low_price", "l"), this.safeNumber2(ohlcv, "close_price", "c"), this.safeNumber2(ohlcv, "volume", "v")};
        }
    }

    /**
     * @method
     * @name bitmart#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://developer-pro.bitmart.com/en/spot/#get-history-k-line-v3
     * @see https://developer-pro.bitmart.com/en/futuresv2/#get-k-line
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp of the latest candle in ms
     * @param {boolean} [params.paginate] *spot only* default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate", false);
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, 200);
        }
        object market = this.market(symbol);
        object duration = this.parseTimeframe(timeframe);
        object parsedTimeframe = this.safeInteger(this.timeframes, timeframe);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(parsedTimeframe, null)))
        {
            ((IDictionary<string,object>)request)["step"] = parsedTimeframe;
        } else
        {
            ((IDictionary<string,object>)request)["step"] = timeframe;
        }
        if (isTrue(getValue(market, "spot")))
        {
            var requestparametersVariable = this.handleUntilOption("before", request, parameters, 0.001);
            request = ((IList<object>)requestparametersVariable)[0];
            parameters = ((IList<object>)requestparametersVariable)[1];
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["after"] = subtract(this.parseToInt((divide(since, 1000))), 1);
            }
        } else
        {
            object maxLimit = 500;
            if (isTrue(isEqual(limit, null)))
            {
                limit = maxLimit;
            }
            limit = mathMin(maxLimit, limit);
            object now = this.parseToInt(divide(this.milliseconds(), 1000));
            if (isTrue(isEqual(since, null)))
            {
                object start = subtract(now, multiply(limit, duration));
                ((IDictionary<string,object>)request)["start_time"] = start;
                ((IDictionary<string,object>)request)["end_time"] = now;
            } else
            {
                object start = subtract(this.parseToInt((divide(since, 1000))), 1);
                object end = this.sum(start, multiply(limit, duration));
                ((IDictionary<string,object>)request)["start_time"] = start;
                ((IDictionary<string,object>)request)["end_time"] = mathMin(end, now);
            }
            var requestparametersVariable = this.handleUntilOption("end_time", request, parameters, 0.001);
            request = ((IList<object>)requestparametersVariable)[0];
            parameters = ((IList<object>)requestparametersVariable)[1];
        }
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.publicGetContractPublicKline(this.extend(request, parameters));
        } else
        {
            response = await this.publicGetSpotQuotationV3Klines(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "code": 1000,
        //         "message": "success",
        //         "data": [
        //             ["1699512060","36746.49","36758.71","36736.13","36755.99","2.83965","104353.57"],
        //             ["1699512120","36756.00","36758.70","36737.14","36737.63","1.96070","72047.10"],
        //             ["1699512180","36737.63","36740.45","36737.62","36740.44","0.63194","23217.62"]
        //         ],
        //         "trace": "6591fc7b508845359d5fa442e3b3a4fb.72.16995122398750695"
        //     }
        //
        // swap
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": [
        //             {
        //                 "low_price": "20090.3",
        //                 "high_price": "20095.5",
        //                 "open_price": "20092.6",
        //                 "close_price": "20091.4",
        //                 "volume": "8748",
        //                 "timestamp": 1665002281
        //             },
        //             ...
        //         ],
        //         "trace": "96c989db-e0f5-46f5-bba6-60cfcbde699b"
        //     }
        //
        object ohlcv = this.safeList(response, "data", new List<object>() {});
        return this.parseOHLCVs(ohlcv, market, timeframe, since, limit);
    }

    /**
     * @method
     * @name bitmart#fetchMyTrades
     * @see https://developer-pro.bitmart.com/en/spot/#account-trade-list-v4-signed
     * @see https://developer-pro.bitmart.com/en/futures/#get-order-trade-keyed
     * @description fetch all trades made by the user
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch trades for
     * @param {boolean} [params.marginMode] *spot* whether to fetch trades for margin orders or spot orders, defaults to spot orders (only isolated margin orders are supported)
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object type = null;
        object response = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object until = this.safeIntegerN(parameters, new List<object>() {"until", "endTime", "end_time"});
        parameters = this.omit(parameters, new List<object>() {"until"});
        if (isTrue(isEqual(type, "spot")))
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchMyTrades", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                ((IDictionary<string,object>)request)["orderMode"] = "iso_margin";
            }
            object options = this.safeDict(this.options, "fetchMyTrades", new Dictionary<string, object>() {});
            object maxLimit = 200;
            object defaultLimit = this.safeInteger(options, "limit", maxLimit);
            if (isTrue(isEqual(limit, null)))
            {
                limit = defaultLimit;
            }
            ((IDictionary<string,object>)request)["limit"] = mathMin(limit, maxLimit);
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["startTime"] = since;
            }
            if (isTrue(!isEqual(until, null)))
            {
                ((IDictionary<string,object>)request)["endTime"] = until;
            }
            response = await this.privatePostSpotV4QueryTrades(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "swap")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
            }
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["start_time"] = since;
            }
            if (isTrue(!isEqual(until, null)))
            {
                ((IDictionary<string,object>)request)["end_time"] = until;
            }
            response = await this.privateGetContractPrivateTrades(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchMyTrades() does not support "), type), " orders, only spot and swap orders are accepted")) ;
        }
        //
        // spot
        //
        //    {
        //        "code":1000,
        //        "message":"success",
        //        "data":[
        //           {
        //              "tradeId":"182342999769370687",
        //              "orderId":"183270218784142990",
        //              "clientOrderId":"183270218784142990",
        //              "symbol":"ADA_USDT",
        //              "side":"buy",
        //              "orderMode":"spot",
        //              "type":"market",
        //              "price":"0.245948",
        //              "size":"20.71",
        //              "notional":"5.09358308",
        //              "fee":"0.00509358",
        //              "feeCoinName":"USDT",
        //              "tradeRole":"taker",
        //              "createTime":1695658457836,
        //              "updateTime":1695658457836
        //           }
        //        ],
        //        "trace":"fbaee9e0e2f5442fba5b3262fc86b0ac.65.16956593456523085"
        //    }
        //
        // swap
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": [
        //             {
        //                 "order_id": "230930336848609",
        //                 "trade_id": "6212604014",
        //                 "symbol": "BTCUSDT",
        //                 "side": 3,
        //                 "price": "26910.4",
        //                 "vol": "1",
        //                 "exec_type": "Taker",
        //                 "profit": false,
        //                 "create_time": 1695961596692,
        //                 "realised_profit": "-0.0003",
        //                 "paid_fees": "0.01614624"
        //             },
        //         ],
        //         "trace": "4cad855074634097ac6ba5257c47305d.62.16959616054873723"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    /**
     * @method
     * @name bitmart#fetchOrderTrades
     * @see https://developer-pro.bitmart.com/en/spot/#order-trade-list-v4-signed
     * @description fetch all the trades made from a single order
     * @param {string} id order id
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        object response = await this.privatePostSpotV4QueryOrderTrades(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, null, since, limit);
    }

    public virtual object customParseBalance(object response, object marketType)
    {
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object wallet = null;
        if (isTrue(isEqual(marketType, "swap")))
        {
            wallet = this.safeList(response, "data", new List<object>() {});
        } else if (isTrue(isEqual(marketType, "margin")))
        {
            wallet = this.safeList(data, "symbols", new List<object>() {});
        } else
        {
            wallet = this.safeList(data, "wallet", new List<object>() {});
        }
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        if (isTrue(isEqual(marketType, "margin")))
        {
            for (object i = 0; isLessThan(i, getArrayLength(wallet)); postFixIncrement(ref i))
            {
                object entry = getValue(wallet, i);
                object marketId = this.safeString(entry, "symbol");
                object symbol = this.safeSymbol(marketId, null, "_");
                object bs = this.safeDict(entry, "base", new Dictionary<string, object>() {});
                object quote = this.safeDict(entry, "quote", new Dictionary<string, object>() {});
                object baseCode = this.safeCurrencyCode(this.safeString(bs, "currency"));
                object quoteCode = this.safeCurrencyCode(this.safeString(quote, "currency"));
                object subResult = new Dictionary<string, object>() {};
                ((IDictionary<string,object>)subResult)[(string)baseCode] = this.parseBalanceHelper(bs);
                ((IDictionary<string,object>)subResult)[(string)quoteCode] = this.parseBalanceHelper(quote);
                ((IDictionary<string,object>)result)[(string)symbol] = this.safeBalance(subResult);
            }
            return result;
        } else
        {
            for (object i = 0; isLessThan(i, getArrayLength(wallet)); postFixIncrement(ref i))
            {
                object balance = getValue(wallet, i);
                object currencyId = this.safeString2(balance, "id", "currency");
                currencyId = this.safeString(balance, "coin_code", currencyId);
                object code = this.safeCurrencyCode(currencyId);
                object account = this.account();
                ((IDictionary<string,object>)account)["free"] = this.safeString2(balance, "available", "available_balance");
                ((IDictionary<string,object>)account)["used"] = this.safeString2(balance, "frozen", "frozen_balance");
                ((IDictionary<string,object>)result)[(string)code] = account;
            }
            return this.safeBalance(result);
        }
    }

    public virtual object parseBalanceHelper(object entry)
    {
        object account = this.account();
        ((IDictionary<string,object>)account)["used"] = this.safeString(entry, "frozen");
        ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "available");
        ((IDictionary<string,object>)account)["total"] = this.safeString(entry, "total_asset");
        object debt = this.safeString(entry, "borrow_unpaid");
        object interest = this.safeString(entry, "interest_unpaid");
        ((IDictionary<string,object>)account)["debt"] = Precise.stringAdd(debt, interest);
        return account;
    }

    /**
     * @method
     * @name bitmart#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://developer-pro.bitmart.com/en/spot/#get-spot-wallet-balance
     * @see https://developer-pro.bitmart.com/en/futures/#get-contract-assets-detail
     * @see https://developer-pro.bitmart.com/en/futuresv2/#get-contract-assets-keyed
     * @see https://developer-pro.bitmart.com/en/spot/#get-account-balance
     * @see https://developer-pro.bitmart.com/en/spot/#get-margin-account-details-isolated
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object marginMode = this.safeString(parameters, "marginMode");
        object isMargin = this.safeBool(parameters, "margin", false);
        parameters = this.omit(parameters, new List<object>() {"margin", "marginMode"});
        if (isTrue(isTrue(!isEqual(marginMode, null)) || isTrue(isMargin)))
        {
            marketType = "margin";
        }
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.privateGetSpotV1Wallet(parameters);
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            response = await this.privateGetContractPrivateAssetsDetail(parameters);
        } else if (isTrue(isEqual(marketType, "account")))
        {
            response = await this.privateGetAccountV1Wallet(parameters);
        } else if (isTrue(isEqual(marketType, "margin")))
        {
            response = await this.privateGetSpotV1MarginIsolatedAccount(parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchBalance() does not support "), marketType), " markets, only spot, swap and account and margin markets are accepted")) ;
        }
        //
        // spot
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"39069916-72f9-44c7-acde-2ad5afd21cad",
        //         "data":{
        //             "wallet":[
        //                 {"id":"BTC","name":"Bitcoin","available":"0.00000062","frozen":"0.00000000"},
        //                 {"id":"ETH","name":"Ethereum","available":"0.00002277","frozen":"0.00000000"},
        //                 {"id":"BMX","name":"BitMart Token","available":"0.00000000","frozen":"0.00000000"}
        //             ]
        //         }
        //     }
        //
        // account
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"5c3b7fc7-93b2-49ef-bb59-7fdc56915b59",
        //         "data":{
        //             "wallet":[
        //                 {"currency":"BTC","name":"Bitcoin","available":"0.00000062","frozen":"0.00000000"},
        //                 {"currency":"ETH","name":"Ethereum","available":"0.00002277","frozen":"0.00000000"}
        //             ]
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": [
        //             {
        //                 "currency": "USDT",
        //                 "available_balance": "0",
        //                 "frozen_balance": "0",
        //                 "unrealized": "0",
        //                 "equity": "0",
        //                 "position_deposit": "0"
        //             },
        //             ...
        //         ],
        //         "trace": "f9da3a39-cf45-42e7-914d-294f565dfc33"
        //     }
        //
        // margin
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "61dd6ab265c04064b72d8bc9b205f741.71.16701055600915302",
        //         "data": {
        //             "symbols": [
        //                 {
        //                     "symbol": "BTC_USDT",
        //                     "risk_rate": "999.00",
        //                     "risk_level": "1",
        //                     "buy_enabled": false,
        //                     "sell_enabled": false,
        //                     "liquidate_price": null,
        //                     "liquidate_rate": "1.15",
        //                     "base": {
        //                         "currency": "BTC",
        //                         "borrow_enabled": true,
        //                         "borrowed": "0.00000000",
        //                         "available": "0.00000000",
        //                         "frozen": "0.00000000",
        //                         "net_asset": "0.00000000",
        //                         "net_assetBTC": "0.00000000",
        //                         "total_asset": "0.00000000",
        //                         "borrow_unpaid": "0.00000000",
        //                         "interest_unpaid": "0.00000000"
        //                     },
        //                     "quote": {
        //                         "currency": "USDT",
        //                         "borrow_enabled": true,
        //                         "borrowed": "0.00000000",
        //                         "available": "20.00000000",
        //                         "frozen": "0.00000000",
        //                         "net_asset": "20.00000000",
        //                         "net_assetBTC": "0.00118008",
        //                         "total_asset": "20.00000000",
        //                         "borrow_unpaid": "0.00000000",
        //                         "interest_unpaid": "0.00000000"
        //                     }
        //                 }
        //             ]
        //         }
        //     }
        //
        return this.customParseBalance(response, marketType);
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        //
        //     {
        //         "symbol": "ETH_USDT",
        //         "taker_fee_rate": "0.0025",
        //         "maker_fee_rate": "0.0025"
        //     }
        //
        object marketId = this.safeString(fee, "symbol");
        object symbol = this.safeSymbol(marketId);
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", symbol },
            { "maker", this.safeNumber(fee, "maker_fee_rate") },
            { "taker", this.safeNumber(fee, "taker_fee_rate") },
            { "percentage", null },
            { "tierBased", null },
        };
    }

    /**
     * @method
     * @name bitmart#fetchTradingFee
     * @description fetch the trading fees for a market
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchTradingFee() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateGetSpotV1TradeFee(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": "1000",
        //         "trace": "5a6f1e40-37fe-4849-a494-03279fadcc62",
        //         "data": {
        //             "symbol": "ETH_USDT",
        //             "taker_fee_rate": "0.0025",
        //             "maker_fee_rate": "0.0025"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTradingFee(data);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder, editOrder
        //
        //     {
        //         "order_id": 2707217580
        //     }
        //
        // swap
        //   "data": {
        //       "order_id": 231116359426639,
        //       "price": "market price"
        //    },
        //
        // cancelOrder
        //
        //     "2707217580" // order id
        //
        // spot fetchOrder, fetchOrdersByStatus, fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "order_id":1736871726781,
        //         "symbol":"BTC_USDT",
        //         "create_time":1591096004000,
        //         "side":"sell",
        //         "type":"market", // limit, market, limit_maker, ioc
        //         "price":"0.00",
        //         "price_avg":"0.00",
        //         "size":"0.02000",
        //         "notional":"0.00000000",
        //         "filled_notional":"0.00000000",
        //         "filled_size":"0.00000",
        //         "status":"8"
        //     }
        //
        // spot v4
        //    {
        //        "orderId" : "118100034543076010",
        //        "clientOrderId" : "118100034543076010",
        //        "symbol" : "BTC_USDT",
        //        "side" : "buy",
        //        "orderMode" : "spot",
        //        "type" : "limit",
        //        "state" : "filled",
        //        "price" : "48800.00",
        //        "priceAvg" : "39999.00",
        //        "size" : "0.10000",
        //        "filledSize" : "0.10000",
        //        "notional" : "4880.00000000",
        //        "filledNotional" : "3999.90000000",
        //        "createTime" : 1681701557927,
        //        "updateTime" : 1681701559408
        //    }
        //
        // swap: fetchOrder, fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "order_id": "230935812485489",
        //         "client_order_id": "",
        //         "price": "24000",
        //         "size": "1",
        //         "symbol": "BTCUSDT",
        //         "state": 2,
        //         "side": 1,
        //         "type": "limit",
        //         "leverage": "10",
        //         "open_type": "isolated",
        //         "deal_avg_price": "0",
        //         "deal_size": "0",
        //         "create_time": 1695702258629,
        //         "update_time": 1695702258642,
        //         "activation_price_type": 0,
        //         "activation_price": "",
        //         "callback_rate": ""
        //     }
        //
        object id = null;
        if (isTrue((order is string)))
        {
            id = order;
            order = new Dictionary<string, object>() {};
        }
        id = this.safeString2(order, "order_id", "orderId", id);
        object timestamp = this.safeInteger2(order, "create_time", "createTime");
        object marketId = this.safeString(order, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        market = this.safeMarket(symbol, market);
        object orderType = this.safeString(market, "type", "spot");
        object type = this.safeString(order, "type");
        object timeInForce = null;
        object postOnly = null;
        if (isTrue(isEqual(type, "limit_maker")))
        {
            type = "limit";
            postOnly = true;
            timeInForce = "PO";
        }
        if (isTrue(isEqual(type, "ioc")))
        {
            type = "limit";
            timeInForce = "IOC";
        }
        object priceString = this.safeString(order, "price");
        if (isTrue(isEqual(priceString, "market price")))
        {
            priceString = null;
        }
        object trailingActivationPrice = this.safeNumber(order, "activation_price");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", this.safeString2(order, "client_order_id", "clientOrderId") },
            { "info", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", this.safeInteger(order, "update_time") },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "side", this.parseOrderSide(this.safeString(order, "side")) },
            { "price", this.omitZero(priceString) },
            { "triggerPrice", trailingActivationPrice },
            { "amount", this.omitZero(this.safeString(order, "size")) },
            { "cost", this.safeString2(order, "filled_notional", "filledNotional") },
            { "average", this.safeStringN(order, new List<object>() {"price_avg", "priceAvg", "deal_avg_price"}) },
            { "filled", this.safeStringN(order, new List<object>() {"filled_size", "filledSize", "deal_size"}) },
            { "remaining", null },
            { "status", this.parseOrderStatusByType(orderType, this.safeString2(order, "status", "state")) },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public virtual object parseOrderSide(object side)
    {
        object sides = new Dictionary<string, object>() {
            { "1", "buy" },
            { "2", "buy" },
            { "3", "sell" },
            { "4", "sell" },
        };
        return this.safeString(sides, side, side);
    }

    public virtual object parseOrderStatusByType(object type, object status)
    {
        object statusesByType = new Dictionary<string, object>() {
            { "spot", new Dictionary<string, object>() {
                { "1", "rejected" },
                { "2", "open" },
                { "3", "rejected" },
                { "4", "open" },
                { "5", "open" },
                { "6", "closed" },
                { "7", "canceled" },
                { "8", "canceled" },
                { "new", "open" },
                { "partially_filled", "open" },
                { "filled", "closed" },
                { "partially_canceled", "canceled" },
            } },
            { "swap", new Dictionary<string, object>() {
                { "1", "open" },
                { "2", "open" },
                { "4", "closed" },
            } },
        };
        object statuses = this.safeDict(statusesByType, type, new Dictionary<string, object>() {});
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name bitmart#createMarketBuyOrderWithCost
     * @description create a market buy order by providing the symbol and cost
     * @see https://developer-pro.bitmart.com/en/spot/#new-order-v2-signed
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
        }
        ((IDictionary<string,object>)parameters)["createMarketBuyOrderRequiresPrice"] = false;
        return await this.createOrder(symbol, "market", "buy", cost, null, parameters);
    }

    /**
     * @method
     * @name bitmart#createOrder
     * @description create a trade order
     * @see https://developer-pro.bitmart.com/en/spot/#new-order-v2-signed
     * @see https://developer-pro.bitmart.com/en/spot/#place-margin-order
     * @see https://developer-pro.bitmart.com/en/futures/#submit-order-signed
     * @see https://developer-pro.bitmart.com/en/futures/#submit-plan-order-signed
     * @see https://developer-pro.bitmart.com/en/futuresv2/#submit-plan-order-signed
     * @see https://developer-pro.bitmart.com/en/futuresv2/#submit-tp-or-sl-order-signed
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market', 'limit' or 'trailing' for swap markets only
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated'
     * @param {string} [params.leverage] *swap only* leverage level
     * @param {string} [params.clientOrderId] client order id of the order
     * @param {boolean} [params.reduceOnly] *swap only* reduce only
     * @param {boolean} [params.postOnly] make sure the order is posted to the order book and not matched immediately
     * @param {string} [params.triggerPrice] *swap only* the price to trigger a stop order
     * @param {int} [params.price_type] *swap only* 1: last price, 2: fair price, default is 1
     * @param {int} [params.price_way] *swap only* 1: price way long, 2: price way short
     * @param {int} [params.activation_price_type] *swap trailing order only* 1: last price, 2: fair price, default is 1
     * @param {string} [params.trailingPercent] *swap only* the percent to trail away from the current market price, min 0.1 max 5
     * @param {string} [params.trailingTriggerPrice] *swap only* the price to trigger a trailing order, default uses the price argument
     * @param {string} [params.stopLossPrice] *swap only* the price to trigger a stop-loss order
     * @param {string} [params.takeProfitPrice] *swap only* the price to trigger a take-profit order
     * @param {int} [params.plan_category] *swap tp/sl only* 1: tp/sl, 2: position tp/sl, default is 1
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object result = this.handleMarginModeAndParams("createOrder", parameters);
        object marginMode = this.safeString(result, 0);
        object triggerPrice = this.safeStringN(parameters, new List<object>() {"triggerPrice", "stopPrice", "trigger_price"});
        object stopLossPrice = this.safeString(parameters, "stopLossPrice");
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        object isStopLoss = !isEqual(stopLossPrice, null);
        object isTakeProfit = !isEqual(takeProfitPrice, null);
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            object spotRequest = this.createSpotOrderRequest(symbol, type, side, amount, price, parameters);
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                response = await this.privatePostSpotV1MarginSubmitOrder(spotRequest);
            } else
            {
                response = await this.privatePostSpotV2SubmitOrder(spotRequest);
            }
        } else
        {
            object swapRequest = this.createSwapOrderRequest(symbol, type, side, amount, price, parameters);
            if (isTrue(isTriggerOrder))
            {
                response = await this.privatePostContractPrivateSubmitPlanOrder(swapRequest);
            } else if (isTrue(isTrue(isStopLoss) || isTrue(isTakeProfit)))
            {
                response = await this.privatePostContractPrivateSubmitTpSlOrder(swapRequest);
            } else
            {
                response = await this.privatePostContractPrivateSubmitOrder(swapRequest);
            }
        }
        //
        // spot and margin
        //
        //     {
        //         "code": 1000,
        //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
        //         "message": "OK",
        //         "data": {
        //             "order_id": 2707217580
        //         }
        //     }
        //
        // swap
        // {"code":1000,"message":"Ok","data":{"order_id":231116359426639,"price":"market price"},"trace":"7f9c94e10f9d4513bc08a7bfc2a5559a.62.16996369620521911"}
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object order = this.parseOrder(data, market);
        ((IDictionary<string,object>)order)["type"] = type;
        ((IDictionary<string,object>)order)["side"] = side;
        ((IDictionary<string,object>)order)["amount"] = amount;
        ((IDictionary<string,object>)order)["price"] = price;
        return order;
    }

    /**
     * @method
     * @name bitmart#createOrders
     * @description create a list of trade orders
     * @see https://developer-pro.bitmart.com/en/spot/#new-batch-order-v4-signed
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params]  extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        object symbol = null;
        object market = null;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            market = this.market(marketId);
            if (!isTrue(getValue(market, "spot")))
            {
                throw new NotSupported ((string)add(this.id, " createOrders() supports spot orders only")) ;
            }
            if (isTrue(isEqual(symbol, null)))
            {
                symbol = marketId;
            } else
            {
                if (isTrue(!isEqual(symbol, marketId)))
                {
                    throw new BadRequest ((string)add(this.id, " createOrders() requires all orders to have the same symbol")) ;
                }
            }
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object orderRequest = this.createSpotOrderRequest(marketId, type, side, amount, price, orderParams);
            orderRequest = this.omit(orderRequest, new List<object>() {"symbol"}); // not needed because it goes in the outter object
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "orderParams", ordersRequests },
        };
        object response = await this.privatePostSpotV4BatchOrders(request);
        //
        // {
        //     "message": "OK",
        //     "code": 1000,
        //     "trace": "5fc697fb817a4b5396284786a9b2609a.263.17022620476480263",
        //     "data": {
        //       "code": 0,
        //       "msg": "success",
        //       "data": {
        //         "orderIds": [
        //           "212751308355553320"
        //         ]
        //       }
        //     }
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object innderData = this.safeDict(data, "data", new Dictionary<string, object>() {});
        object orderIds = this.safeList(innderData, "orderIds", new List<object>() {});
        object parsedOrders = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orderIds)); postFixIncrement(ref i))
        {
            object orderId = getValue(orderIds, i);
            object order = this.safeOrder(new Dictionary<string, object>() {
                { "id", orderId },
            }, market);
            ((IList<object>)parsedOrders).Add(order);
        }
        return parsedOrders;
    }

    public virtual object createSwapOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#createSwapOrderRequest
        * @ignore
        * @description create a trade order
        * @see https://developer-pro.bitmart.com/en/futuresv2/#submit-order-signed
        * @see https://developer-pro.bitmart.com/en/futuresv2/#submit-plan-order-signed
        * @see https://developer-pro.bitmart.com/en/futuresv2/#submit-tp-or-sl-order-signed
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market', 'limit', 'trailing', 'stop_loss', or 'take_profit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.leverage] leverage level
        * @param {boolean} [params.reduceOnly] *swap only* reduce only
        * @param {string} [params.marginMode] 'cross' or 'isolated', default is 'cross'
        * @param {string} [params.clientOrderId] client order id of the order
        * @param {string} [params.triggerPrice] *swap only* the price to trigger a stop order
        * @param {int} [params.price_type] *swap only* 1: last price, 2: fair price, default is 1
        * @param {int} [params.price_way] *swap only* 1: price way long, 2: price way short
        * @param {int} [params.activation_price_type] *swap trailing order only* 1: last price, 2: fair price, default is 1
        * @param {string} [params.trailingPercent] *swap only* the percent to trail away from the current market price, min 0.1 max 5
        * @param {string} [params.trailingTriggerPrice] *swap only* the price to trigger a trailing order, default uses the price argument
        * @param {string} [params.stopLossPrice] *swap only* the price to trigger a stop-loss order
        * @param {string} [params.takeProfitPrice] *swap only* the price to trigger a take-profit order
        * @param {int} [params.plan_category] *swap tp/sl only* 1: tp/sl, 2: position tp/sl, default is 1
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object stopLossPrice = this.safeString(parameters, "stopLossPrice");
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        object isStopLoss = !isEqual(stopLossPrice, null);
        object isTakeProfit = !isEqual(takeProfitPrice, null);
        if (isTrue(isStopLoss))
        {
            type = "stop_loss";
        } else if (isTrue(isTakeProfit))
        {
            type = "take_profit";
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "type", type },
            { "size", parseInt(this.amountToPrecision(symbol, amount)) },
        };
        object timeInForce = this.safeString(parameters, "timeInForce");
        object mode = this.safeInteger(parameters, "mode"); // only for swap
        object isMarketOrder = isEqual(type, "market");
        object postOnly = null;
        object reduceOnly = this.safeBool(parameters, "reduceOnly");
        object isExchangeSpecificPo = (isEqual(mode, 4));
        var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, isExchangeSpecificPo, parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        object ioc = (isTrue((isEqual(timeInForce, "IOC"))) || isTrue((isEqual(mode, 3))));
        object isLimitOrder = isTrue(isTrue((isEqual(type, "limit"))) || isTrue(postOnly)) || isTrue(ioc);
        if (isTrue(isEqual(timeInForce, "GTC")))
        {
            ((IDictionary<string,object>)request)["mode"] = 1;
        } else if (isTrue(isEqual(timeInForce, "FOK")))
        {
            ((IDictionary<string,object>)request)["mode"] = 2;
        } else if (isTrue(isEqual(timeInForce, "IOC")))
        {
            ((IDictionary<string,object>)request)["mode"] = 3;
        }
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["mode"] = 4;
        }
        object triggerPrice = this.safeStringN(parameters, new List<object>() {"triggerPrice", "stopPrice", "trigger_price"});
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object trailingTriggerPrice = this.safeString2(parameters, "trailingTriggerPrice", "activation_price", this.numberToString(price));
        object trailingPercent = this.safeString2(parameters, "trailingPercent", "callback_rate");
        object isTrailingPercentOrder = !isEqual(trailingPercent, null);
        if (isTrue(isLimitOrder))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        } else if (isTrue(isTrue(isEqual(type, "trailing")) || isTrue(isTrailingPercentOrder)))
        {
            ((IDictionary<string,object>)request)["callback_rate"] = trailingPercent;
            ((IDictionary<string,object>)request)["activation_price"] = this.priceToPrecision(symbol, trailingTriggerPrice);
            ((IDictionary<string,object>)request)["activation_price_type"] = this.safeInteger(parameters, "activation_price_type", 1);
        }
        if (isTrue(isTriggerOrder))
        {
            if (isTrue(isTrue(isLimitOrder) || isTrue(!isEqual(price, null))))
            {
                ((IDictionary<string,object>)request)["executive_price"] = this.priceToPrecision(symbol, price);
            }
            ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, triggerPrice);
            ((IDictionary<string,object>)request)["price_type"] = this.safeInteger(parameters, "price_type", 1);
            if (isTrue(isEqual(side, "buy")))
            {
                if (isTrue(reduceOnly))
                {
                    ((IDictionary<string,object>)request)["price_way"] = 2;
                } else
                {
                    ((IDictionary<string,object>)request)["price_way"] = 1;
                }
            } else if (isTrue(isEqual(side, "sell")))
            {
                if (isTrue(reduceOnly))
                {
                    ((IDictionary<string,object>)request)["price_way"] = 1;
                } else
                {
                    ((IDictionary<string,object>)request)["price_way"] = 2;
                }
            }
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters, "cross");
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isTrue(isStopLoss) || isTrue(isTakeProfit)))
        {
            reduceOnly = true;
            ((IDictionary<string,object>)request)["price_type"] = this.safeInteger(parameters, "price_type", 1);
            ((IDictionary<string,object>)request)["executive_price"] = this.priceToPrecision(symbol, price);
            if (isTrue(isStopLoss))
            {
                ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, stopLossPrice);
            } else
            {
                ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, takeProfitPrice);
            }
        } else
        {
            ((IDictionary<string,object>)request)["open_type"] = marginMode;
        }
        if (isTrue(isEqual(side, "buy")))
        {
            if (isTrue(reduceOnly))
            {
                ((IDictionary<string,object>)request)["side"] = 2; // buy close short
            } else
            {
                ((IDictionary<string,object>)request)["side"] = 1; // buy open long
            }
        } else if (isTrue(isEqual(side, "sell")))
        {
            if (isTrue(reduceOnly))
            {
                ((IDictionary<string,object>)request)["side"] = 3; // sell close long
            } else
            {
                ((IDictionary<string,object>)request)["side"] = 4; // sell open short
            }
        }
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            parameters = this.omit(parameters, "clientOrderId");
            ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
        }
        object leverage = this.safeInteger(parameters, "leverage");
        parameters = this.omit(parameters, new List<object>() {"timeInForce", "postOnly", "reduceOnly", "leverage", "trailingTriggerPrice", "trailingPercent", "triggerPrice", "stopPrice", "stopLossPrice", "takeProfitPrice"});
        if (isTrue(!isEqual(leverage, null)))
        {
            ((IDictionary<string,object>)request)["leverage"] = this.numberToString(leverage);
        } else if (isTrue(isTriggerOrder))
        {
            ((IDictionary<string,object>)request)["leverage"] = "1"; // for plan orders leverage is required, if not available default to 1
        }
        return this.extend(request, parameters);
    }

    public virtual object createSpotOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#createSpotOrderRequest
        * @ignore
        * @description create a spot order request
        * @see https://developer-pro.bitmart.com/en/spot/#place-spot-order
        * @see https://developer-pro.bitmart.com/en/spot/#place-margin-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'cross' or 'isolated'
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", side },
            { "type", type },
        };
        object timeInForce = this.safeString(parameters, "timeInForce");
        if (isTrue(isEqual(timeInForce, "FOK")))
        {
            throw new InvalidOrder ((string)add(this.id, " createOrder() only accepts timeInForce parameter values of IOC or PO")) ;
        }
        object mode = this.safeInteger(parameters, "mode"); // only for swap
        object isMarketOrder = isEqual(type, "market");
        object postOnly = null;
        object isExchangeSpecificPo = isTrue((isEqual(type, "limit_maker"))) || isTrue((isEqual(mode, 4)));
        var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, isExchangeSpecificPo, parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        parameters = this.omit(parameters, new List<object>() {"timeInForce", "postOnly"});
        object ioc = (isTrue((isEqual(timeInForce, "IOC"))) || isTrue((isEqual(type, "ioc"))));
        object isLimitOrder = isTrue(isTrue((isEqual(type, "limit"))) || isTrue(postOnly)) || isTrue(ioc);
        // method = 'privatePostSpotV2SubmitOrder';
        if (isTrue(isLimitOrder))
        {
            ((IDictionary<string,object>)request)["size"] = this.amountToPrecision(symbol, amount);
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        } else if (isTrue(isMarketOrder))
        {
            // for market buy it requires the amount of quote currency to spend
            if (isTrue(isEqual(side, "buy")))
            {
                object notional = this.safeString2(parameters, "cost", "notional");
                parameters = this.omit(parameters, "cost");
                object createMarketBuyOrderRequiresPrice = true;
                var createMarketBuyOrderRequiresPriceparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                createMarketBuyOrderRequiresPrice = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[0];
                parameters = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[1];
                if (isTrue(createMarketBuyOrderRequiresPrice))
                {
                    if (isTrue(isTrue((isEqual(price, null))) && isTrue((isEqual(notional, null)))))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument or in the \"notional\" extra parameter (the exchange-specific behaviour)")) ;
                    } else
                    {
                        object amountString = this.numberToString(amount);
                        object priceString = this.numberToString(price);
                        notional = Precise.stringMul(amountString, priceString);
                    }
                } else
                {
                    notional = ((bool) isTrue((isEqual(notional, null)))) ? this.numberToString(amount) : notional;
                }
                ((IDictionary<string,object>)request)["notional"] = this.decimalToPrecision(notional, TRUNCATE, getValue(getValue(market, "precision"), "price"), this.precisionMode);
            } else if (isTrue(isEqual(side, "sell")))
            {
                ((IDictionary<string,object>)request)["size"] = this.amountToPrecision(symbol, amount);
            }
        }
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["type"] = "limit_maker";
        }
        if (isTrue(ioc))
        {
            ((IDictionary<string,object>)request)["type"] = "ioc";
        }
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            parameters = this.omit(parameters, "clientOrderId");
            ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
        }
        return this.extend(request, parameters);
    }

    /**
     * @method
     * @name bitmart#cancelOrder
     * @description cancels an open order
     * @see https://developer-pro.bitmart.com/en/futures/#cancel-order-signed
     * @see https://developer-pro.bitmart.com/en/spot/#cancel-order-v3-signed
     * @see https://developer-pro.bitmart.com/en/futures/#cancel-plan-order-signed
     * @see https://developer-pro.bitmart.com/en/futures/#cancel-plan-order-signed
     * @see https://developer-pro.bitmart.com/en/futures/#cancel-order-signed
     * @see https://developer-pro.bitmart.com/en/futures/#cancel-plan-order-signed
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] *spot only* the client order id of the order to cancel
     * @param {boolean} [params.trigger] *swap only* whether the order is a trigger order
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "client_order_id");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["order_id"] = ((object)id).ToString();
        }
        parameters = this.omit(parameters, new List<object>() {"clientOrderId"});
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.privatePostSpotV3CancelOrder(this.extend(request, parameters));
        } else
        {
            object trigger = this.safeBool2(parameters, "stop", "trigger");
            parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
            if (!isTrue(trigger))
            {
                response = await this.privatePostContractPrivateCancelOrder(this.extend(request, parameters));
            } else
            {
                response = await this.privatePostContractPrivateCancelPlanOrder(this.extend(request, parameters));
            }
        }
        // swap
        // {"code":1000,"message":"Ok","trace":"7f9c94e10f9d4513bc08a7bfc2a5559a.55.16959817848001851"}
        //
        // spot
        //
        //     {
        //         "code": 1000,
        //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
        //         "message": "OK",
        //         "data": {
        //             "result": true
        //         }
        //     }
        //
        // spot alternative
        //
        //     {
        //         "code": 1000,
        //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
        //         "message": "OK",
        //         "data": true
        //     }
        //
        if (isTrue(getValue(market, "swap")))
        {
            return response;
        }
        object data = this.safeValue(response, "data");
        if (isTrue(isEqual(data, true)))
        {
            return this.safeOrder(new Dictionary<string, object>() {
                { "id", id },
            }, market);
        }
        object succeeded = this.safeValue(data, "succeed");
        if (isTrue(!isEqual(succeeded, null)))
        {
            id = this.safeString(succeeded, 0);
            if (isTrue(isEqual(id, null)))
            {
                throw new InvalidOrder ((string)add(add(add(add(this.id, " cancelOrder() failed to cancel "), symbol), " order id "), id)) ;
            }
        } else
        {
            object result = this.safeValue(data, "result");
            if (!isTrue(result))
            {
                throw new InvalidOrder ((string)add(add(add(add(add(this.id, " cancelOrder() "), symbol), " order id "), id), " is filled or canceled")) ;
            }
        }
        object order = this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "symbol", getValue(market, "symbol") },
            { "info", new Dictionary<string, object>() {} },
        }, market);
        return order;
    }

    /**
     * @method
     * @name bitmart#cancelOrders
     * @description cancel multiple orders
     * @see https://developer-pro.bitmart.com/en/spot/#cancel-batch-order-v4-signed
     * @param {string[]} ids order ids
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string[]} [params.clientOrderIds] client order ids
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " cancelOrders() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object clientOrderIds = this.safeList(parameters, "clientOrderIds");
        parameters = this.omit(parameters, new List<object>() {"clientOrderIds"});
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(clientOrderIds, null)))
        {
            ((IDictionary<string,object>)request)["clientOrderIds"] = clientOrderIds;
        } else
        {
            ((IDictionary<string,object>)request)["orderIds"] = ids;
        }
        object response = await this.privatePostSpotV4CancelOrders(this.extend(request, parameters));
        //
        //  {
        //      "message": "OK",
        //      "code": 1000,
        //      "trace": "c4edbce860164203954f7c3c81d60fc6.309.17022669632770001",
        //      "data": {
        //        "successIds": [
        //          "213055379155243012"
        //        ],
        //        "failIds": [],
        //        "totalCount": 1,
        //        "successCount": 1,
        //        "failedCount": 0
        //      }
        //  }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object allOrders = new List<object>() {};
        object successIds = this.safeList(data, "successIds", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(successIds)); postFixIncrement(ref i))
        {
            object id = getValue(successIds, i);
            ((IList<object>)allOrders).Add(this.safeOrder(new Dictionary<string, object>() {
                { "id", id },
                { "status", "canceled" },
            }, market));
        }
        object failIds = this.safeList(data, "failIds", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(failIds)); postFixIncrement(ref i))
        {
            object id = getValue(failIds, i);
            ((IList<object>)allOrders).Add(this.safeOrder(new Dictionary<string, object>() {
                { "id", id },
                { "status", "failed" },
            }, market));
        }
        return allOrders;
    }

    /**
     * @method
     * @name bitmart#cancelAllOrders
     * @description cancel all open orders in a market
     * @see https://developer-pro.bitmart.com/en/spot/#cancel-all-orders
     * @see https://developer-pro.bitmart.com/en/spot/#new-batch-order-v4-signed
     * @see https://developer-pro.bitmart.com/en/futures/#cancel-all-orders-signed
     * @see https://developer-pro.bitmart.com/en/futuresv2/#cancel-all-orders-signed
     * @param {string} symbol unified market symbol of the market to cancel orders in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.side] *spot only* 'buy' or 'sell'
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object response = null;
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("cancelAllOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            response = await this.privatePostSpotV4CancelAll(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "swap")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
            }
            response = await this.privatePostContractPrivateCancelOrders(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "code": 1000,
        //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
        //         "message": "OK",
        //         "data": {}
        //     }
        //
        // swap
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "trace": "7f9c94e10f9d4513bc08a7bfc2a5559a.70.16954131323145323"
        //     }
        //
        return response;
    }

    public async virtual Task<object> fetchOrdersByStatus(object status, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrdersByStatus() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOrdersByStatus() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "offset", 1 },
            { "N", 100 },
        };
        if (isTrue(isEqual(status, "open")))
        {
            ((IDictionary<string,object>)request)["status"] = 9;
        } else if (isTrue(isEqual(status, "closed")))
        {
            ((IDictionary<string,object>)request)["status"] = 6;
        } else if (isTrue(isEqual(status, "canceled")))
        {
            ((IDictionary<string,object>)request)["status"] = 8;
        } else
        {
            ((IDictionary<string,object>)request)["status"] = status;
        }
        object response = await this.privateGetSpotV3Orders(this.extend(request, parameters));
        //
        // spot
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"70e7d427-7436-4fb8-8cdd-97e1f5eadbe9",
        //         "data":{
        //             "current_page":1,
        //             "orders":[
        //                 {
        //                     "order_id":2147601241,
        //                     "symbol":"BTC_USDT",
        //                     "create_time":1591099963000,
        //                     "side":"sell",
        //                     "type":"limit",
        //                     "price":"9000.00",
        //                     "price_avg":"0.00",
        //                     "size":"1.00000",
        //                     "notional":"9000.00000000",
        //                     "filled_notional":"0.00000000",
        //                     "filled_size":"0.00000",
        //                     "status":"4"
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeList(data, "orders", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    /**
     * @method
     * @name bitmart#fetchOpenOrders
     * @see https://developer-pro.bitmart.com/en/spot/#current-open-orders-v4-signed
     * @see https://developer-pro.bitmart.com/en/futures/#get-all-open-orders-keyed
     * @see https://developer-pro.bitmart.com/en/futures/#get-all-current-plan-orders-keyed
     * @description fetch all unfilled currently open orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.marginMode] *spot* whether to fetch trades for margin orders or spot orders, defaults to spot orders (only isolated margin orders are supported)
     * @param {int} [params.until] *spot* the latest time in ms to fetch orders for
     * @param {string} [params.type] *swap* order type, 'limit' or 'market'
     * @param {string} [params.order_state] *swap* the order state, 'all' or 'partially_filled', default is 'all'
     * @param {string} [params.orderType] *swap only* 'limit', 'market', or 'trailing'
     * @param {boolean} [params.trailing] *swap only* set to true if you want to fetch trailing orders
     * @param {boolean} [params.trigger] *swap only* set to true if you want to fetch trigger orders
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object type = null;
        object response = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchOpenOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 200);
            }
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOpenOrders", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                ((IDictionary<string,object>)request)["orderMode"] = "iso_margin";
            }
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["startTime"] = since;
            }
            object until = this.safeInteger2(parameters, "until", "endTime");
            if (isTrue(!isEqual(until, null)))
            {
                parameters = this.omit(parameters, new List<object>() {"endTime"});
                ((IDictionary<string,object>)request)["endTime"] = until;
            }
            response = await this.privatePostSpotV4QueryOpenOrders(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "swap")))
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 100);
            }
            object isTrigger = this.safeBool2(parameters, "stop", "trigger");
            parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
            if (isTrue(isTrigger))
            {
                response = await this.privateGetContractPrivateCurrentPlanOrder(this.extend(request, parameters));
            } else
            {
                object trailing = this.safeBool(parameters, "trailing", false);
                object orderType = this.safeString(parameters, "orderType");
                parameters = this.omit(parameters, new List<object>() {"orderType", "trailing"});
                if (isTrue(trailing))
                {
                    orderType = "trailing";
                }
                if (isTrue(!isEqual(orderType, null)))
                {
                    ((IDictionary<string,object>)request)["type"] = orderType;
                }
                response = await this.privateGetContractPrivateGetOpenOrders(this.extend(request, parameters));
            }
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOpenOrders() does not support "), type), " orders, only spot and swap orders are accepted")) ;
        }
        //
        // spot
        //
        //     {
        //         "code": 1000,
        //         "message": "success",
        //         "data": [
        //             {
        //                 "orderId": "183299373022163211",
        //                 "clientOrderId": "183299373022163211",
        //                 "symbol": "BTC_USDT",
        //                 "side": "buy",
        //                 "orderMode": "spot",
        //                 "type": "limit",
        //                 "state": "new",
        //                 "price": "25000.00",
        //                 "priceAvg": "0.00",
        //                 "size": "0.00020",
        //                 "filledSize": "0.00000",
        //                 "notional": "5.00000000",
        //                 "filledNotional": "0.00000000",
        //                 "createTime": 1695703703338,
        //                 "updateTime": 1695703703359
        //             }
        //         ],
        //         "trace": "15f11d48e3234c81a2e786cr2e7a38e6.71.16957022303515933"
        //     }
        //
        // swap
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": [
        //             {
        //                 "order_id": "230935812485489",
        //                 "client_order_id": "",
        //                 "price": "24000",
        //                 "size": "1",
        //                 "symbol": "BTCUSDT",
        //                 "state": 2,
        //                 "side": 1,
        //                 "type": "limit",
        //                 "leverage": "10",
        //                 "open_type": "isolated",
        //                 "deal_avg_price": "0",
        //                 "deal_size": "0",
        //                 "create_time": 1695702258629,
        //                 "update_time": 1695702258642
        //             }
        //         ],
        //         "trace": "7f9d94g10f9d4513bc08a7rfc3a5559a.71.16957022303515933"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    /**
     * @method
     * @name bitmart#fetchClosedOrders
     * @see https://developer-pro.bitmart.com/en/spot/#account-orders-v4-signed
     * @see https://developer-pro.bitmart.com/en/futures/#get-order-history-keyed
     * @see https://developer-pro.bitmart.com/en/futuresv2/#get-order-history-keyed
     * @description fetches information on multiple closed orders made by the user
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest entry
     * @param {string} [params.marginMode] *spot only* 'cross' or 'isolated', for margin trading
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchClosedOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(!isEqual(type, "spot")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchClosedOrders() requires a symbol argument")) ;
            }
        }
        if (isTrue(!isEqual(since, null)))
        {
            object startTimeKey = ((bool) isTrue((isEqual(type, "spot")))) ? "startTime" : "start_time";
            ((IDictionary<string,object>)request)[(string)startTimeKey] = since;
        }
        object endTimeKey = ((bool) isTrue((isEqual(type, "spot")))) ? "endTime" : "end_time";
        object until = this.safeInteger2(parameters, "until", endTimeKey);
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)[(string)endTimeKey] = until;
        }
        object response = null;
        if (isTrue(isEqual(type, "spot")))
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchClosedOrders", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                ((IDictionary<string,object>)request)["orderMode"] = "iso_margin";
            }
            response = await this.privatePostSpotV4QueryHistoryOrders(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetContractPrivateOrderHistory(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    /**
     * @method
     * @name bitmart#fetchCanceledOrders
     * @description fetches information on multiple canceled orders made by the user
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] timestamp in ms of the earliest order, default is undefined
     * @param {int} [limit] max number of orders to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("canceled", symbol, since, limit, parameters);
    }

    /**
     * @method
     * @name bitmart#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://developer-pro.bitmart.com/en/spot/#query-order-by-id-v4-signed
     * @see https://developer-pro.bitmart.com/en/spot/#query-order-by-clientorderid-v4-signed
     * @see https://developer-pro.bitmart.com/en/futures/#get-order-detail-keyed
     * @see https://developer-pro.bitmart.com/en/futuresv2/#get-order-detail-keyed
     * @param {string} id the id of the order
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] *spot* fetch the order by client order id instead of order id
     * @param {string} [params.orderType] *swap only* 'limit', 'market', 'liquidate', 'bankruptcy', 'adl' or 'trailing'
     * @param {boolean} [params.trailing] *swap only* set to true if you want to fetch a trailing order
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object type = null;
        object market = null;
        object response = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchOrder", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            object clientOrderId = this.safeString(parameters, "clientOrderId");
            if (!isTrue(clientOrderId))
            {
                ((IDictionary<string,object>)request)["orderId"] = id;
            }
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                response = await this.privatePostSpotV4QueryClientOrder(this.extend(request, parameters));
            } else
            {
                response = await this.privatePostSpotV4QueryOrder(this.extend(request, parameters));
            }
        } else if (isTrue(isEqual(type, "swap")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
            }
            object trailing = this.safeBool(parameters, "trailing", false);
            object orderType = this.safeString(parameters, "orderType");
            parameters = this.omit(parameters, new List<object>() {"orderType", "trailing"});
            if (isTrue(trailing))
            {
                orderType = "trailing";
            }
            if (isTrue(!isEqual(orderType, null)))
            {
                ((IDictionary<string,object>)request)["type"] = orderType;
            }
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            ((IDictionary<string,object>)request)["order_id"] = id;
            response = await this.privateGetContractPrivateOrder(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "code": 1000,
        //         "message": "success",
        //         "data": {
        //             "orderId": "183347420821295423",
        //             "clientOrderId": "183347420821295423",
        //             "symbol": "BTC_USDT",
        //             "side": "buy",
        //             "orderMode": "spot",
        //             "type": "limit",
        //             "state": "new",
        //             "price": "24000.00",
        //             "priceAvg": "0.00",
        //             "size": "0.00022",
        //             "filledSize": "0.00000",
        //             "notional": "5.28000000",
        //             "filledNotional": "0.00000000",
        //             "createTime": 1695783014734,
        //             "updateTime": 1695783014762
        //         },
        //         "trace": "ce3e6422c8b44d5fag855348a68693ed.63.14957831547451715"
        //     }
        //
        // swap
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": {
        //             "order_id": "230927283405028",
        //             "client_order_id": "",
        //             "price": "23000",
        //             "size": "1",
        //             "symbol": "BTCUSDT",
        //             "state": 2,
        //             "side": 1,
        //             "type": "limit",
        //             "leverage": "10",
        //             "open_type": "isolated",
        //             "deal_avg_price": "0",
        //             "deal_size": "0",
        //             "create_time": 1695783433600,
        //             "update_time": 1695783433613
        //         },
        //         "trace": "4cad855075664097af6ba5257c47605d.63.14957831547451715"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    /**
     * @method
     * @name bitmart#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://developer-pro.bitmart.com/en/spot/#deposit-address-keyed
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object network = null;
        var networkparametersVariable = this.handleNetworkCodeAndParams(parameters);
        network = ((IList<object>)networkparametersVariable)[0];
        parameters = ((IList<object>)networkparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "currency", this.getCurrencyIdFromCodeAndNetwork(code, network) },
        };
        object response = await this.privateGetAccountV1DepositAddress(this.extend(request, parameters));
        //
        //    {
        //        "message": "OK",
        //        "code": 1000,
        //        "trace": "0e6edd79-f77f-4251-abe5-83ba75d06c1a",
        //        "data": {
        //            currency: 'ETH',
        //            chain: 'Ethereum',
        //            address: '0x99B5EEc2C520f86F0F62F05820d28D05D36EccCf',
        //            address_memo: ''
        //        }
        //    }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseDepositAddress(data, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //    {
        //        currency: 'ETH',
        //        chain: 'Ethereum',
        //        address: '0x99B5EEc2C520f86F0F62F05820d28D05D36EccCf',
        //        address_memo: ''
        //    }
        //
        object currencyId = this.safeString(depositAddress, "currency");
        object network = this.safeString(depositAddress, "chain");
        if (isTrue(isLessThan(getIndexOf(currencyId, "NFT"), 0)))
        {
            object parts = ((string)currencyId).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            currencyId = this.safeString(parts, 0);
            object secondPart = this.safeString(parts, 1);
            if (isTrue(!isEqual(secondPart, null)))
            {
                network = secondPart;
            }
        }
        object address = this.safeString(depositAddress, "address");
        currency = this.safeCurrency(currencyId, currency);
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", this.safeString(currency, "code") },
            { "network", this.networkIdToCode(network) },
            { "address", address },
            { "tag", this.safeString(depositAddress, "address_memo") },
        };
    }

    /**
     * @method
     * @name bitmart#withdraw
     * @description make a withdrawal
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network] the network name for this withdrawal
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object network = null;
        var networkparametersVariable = this.handleNetworkCodeAndParams(parameters);
        network = ((IList<object>)networkparametersVariable)[0];
        parameters = ((IList<object>)networkparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "currency", this.getCurrencyIdFromCodeAndNetwork(code, network) },
            { "amount", amount },
            { "destination", "To Digital Address" },
            { "address", address },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["address_memo"] = tag;
        }
        object response = await this.privatePostAccountV1WithdrawApply(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
        //         "message": "OK",
        //         "data": {
        //             "withdraw_id": "121212"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object transaction = this.parseTransaction(data, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "code", code },
            { "address", address },
            { "tag", tag },
        });
    }

    public async virtual Task<object> fetchTransactionsByType(object type, object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(limit, null)))
        {
            limit = 50; // max 50
        }
        object request = new Dictionary<string, object>() {
            { "operation_type", type },
            { "offset", 1 },
            { "N", limit },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        object response = await this.privateGetAccountV2DepositWithdrawHistory(this.extend(request, parameters));
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"142bf92a-fc50-4689-92b6-590886f90b97",
        //         "data":{
        //             "records":[
        //                 {
        //                     "withdraw_id":"1679952",
        //                     "deposit_id":"",
        //                     "operation_type":"withdraw",
        //                     "currency":"BMX",
        //                     "apply_time":1588867374000,
        //                     "arrival_amount":"59.000000000000",
        //                     "fee":"1.000000000000",
        //                     "status":0,
        //                     "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
        //                     "address_memo":"",
        //                     "tx_id":""
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object records = this.safeList(data, "records", new List<object>() {});
        return this.parseTransactions(records, currency, since, limit);
    }

    /**
     * @method
     * @name bitmart#fetchDeposit
     * @description fetch information on a deposit
     * @param {string} id deposit id
     * @param {string} code not used by bitmart fetchDeposit ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async virtual Task<object> fetchDeposit(object id, object code = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object response = await this.privateGetAccountV1DepositWithdrawDetail(this.extend(request, parameters));
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"f7f74924-14da-42a6-b7f2-d3799dd9a612",
        //         "data":{
        //             "record":{
        //                 "withdraw_id":"",
        //                 "deposit_id":"1679952",
        //                 "operation_type":"deposit",
        //                 "currency":"BMX",
        //                 "apply_time":1588867374000,
        //                 "arrival_amount":"59.000000000000",
        //                 "fee":"1.000000000000",
        //                 "status":0,
        //                 "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
        //                 "address_memo":"",
        //                 "tx_id":""
        //             }
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object record = this.safeDict(data, "record", new Dictionary<string, object>() {});
        return this.parseTransaction(record);
    }

    /**
     * @method
     * @name bitmart#fetchDeposits
     * @description fetch all deposits made to an account
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsByType("deposit", code, since, limit, parameters);
    }

    /**
     * @method
     * @name bitmart#fetchWithdrawal
     * @description fetch data on a currency withdrawal via the withdrawal id
     * @param {string} id withdrawal id
     * @param {string} code not used by bitmart.fetchWithdrawal
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async virtual Task<object> fetchWithdrawal(object id, object code = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object response = await this.privateGetAccountV1DepositWithdrawDetail(this.extend(request, parameters));
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"f7f74924-14da-42a6-b7f2-d3799dd9a612",
        //         "data":{
        //             "record":{
        //                 "withdraw_id":"1679952",
        //                 "deposit_id":"",
        //                 "operation_type":"withdraw",
        //                 "currency":"BMX",
        //                 "apply_time":1588867374000,
        //                 "arrival_amount":"59.000000000000",
        //                 "fee":"1.000000000000",
        //                 "status":0,
        //                 "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
        //                 "address_memo":"",
        //                 "tx_id":""
        //             }
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object record = this.safeDict(data, "record", new Dictionary<string, object>() {});
        return this.parseTransaction(record);
    }

    /**
     * @method
     * @name bitmart#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsByType("withdraw", code, since, limit, parameters);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "0", "pending" },
            { "1", "pending" },
            { "2", "pending" },
            { "3", "ok" },
            { "4", "canceled" },
            { "5", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // withdraw
        //
        //     {
        //         "withdraw_id": "121212"
        //     }
        //
        // fetchDeposits, fetchWithdrawals, fetchWithdrawal
        //
        //     {
        //         "withdraw_id":"1679952",
        //         "deposit_id":"",
        //         "operation_type":"withdraw",
        //         "currency":"BMX",
        //         "apply_time":1588867374000,
        //         "arrival_amount":"59.000000000000",
        //         "fee":"1.000000000000",
        //         "status":0,
        //         "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
        //         "address_memo":"",
        //         "tx_id":""
        //     }
        //
        object id = null;
        object withdrawId = this.safeString(transaction, "withdraw_id");
        object depositId = this.safeString(transaction, "deposit_id");
        object type = null;
        if (isTrue(isTrue((!isEqual(withdrawId, null))) && isTrue((!isEqual(withdrawId, "")))))
        {
            type = "withdraw";
            id = withdrawId;
        } else if (isTrue(isTrue((!isEqual(depositId, null))) && isTrue((!isEqual(depositId, "")))))
        {
            type = "deposit";
            id = depositId;
        }
        object amount = this.safeNumber(transaction, "arrival_amount");
        object timestamp = this.safeInteger(transaction, "apply_time");
        object currencyId = this.safeString(transaction, "currency");
        object networkId = null;
        if (isTrue(isLessThan(getIndexOf(currencyId, "NFT"), 0)))
        {
            object parts = ((string)currencyId).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            currencyId = this.safeString(parts, 0);
            networkId = this.safeString(parts, 1);
        }
        object code = this.safeCurrencyCode(currencyId, currency);
        object status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        object feeCost = this.safeNumber(transaction, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", code },
            };
        }
        object txid = this.safeString(transaction, "tx_id");
        object address = this.safeString(transaction, "address");
        object tag = this.safeString(transaction, "address_memo");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "currency", code },
            { "amount", amount },
            { "network", this.networkIdToCode(networkId) },
            { "address", address },
            { "addressFrom", null },
            { "addressTo", null },
            { "tag", tag },
            { "tagFrom", null },
            { "tagTo", null },
            { "status", status },
            { "type", type },
            { "updated", null },
            { "txid", txid },
            { "internal", null },
            { "comment", null },
            { "timestamp", ((bool) isTrue((!isEqual(timestamp, 0)))) ? timestamp : null },
            { "datetime", ((bool) isTrue((!isEqual(timestamp, 0)))) ? this.iso8601(timestamp) : null },
            { "fee", fee },
        };
    }

    /**
     * @method
     * @name bitmart#repayIsolatedMargin
     * @description repay borrowed margin and interest
     * @see https://developer-pro.bitmart.com/en/spot/#margin-repay-isolated
     * @param {string} symbol unified market symbol
     * @param {string} code unified currency code of the currency to repay
     * @param {string} amount the amount to repay
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
     */
    public async override Task<object> repayIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "currency", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.privatePostSpotV1MarginIsolatedRepay(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "b0a60b4c-e986-4b54-a190-8f7c05ddf685",
        //         "data": {
        //             "repay_id": "2afcc16d99bd4707818c5a355dc89bed"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object transaction = this.parseMarginLoan(data, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    /**
     * @method
     * @name bitmart#borrowIsolatedMargin
     * @description create a loan to borrow margin
     * @see https://developer-pro.bitmart.com/en/spot/#margin-borrow-isolated
     * @param {string} symbol unified market symbol
     * @param {string} code unified currency code of the currency to borrow
     * @param {string} amount the amount to borrow
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
     */
    public async override Task<object> borrowIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "currency", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.privatePostSpotV1MarginIsolatedBorrow(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "e6fda683-181e-4e78-ac9c-b27c4c8ba035",
        //         "data": {
        //             "borrow_id": "629a7177a4ed4cf09869c6a4343b788c"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object transaction = this.parseMarginLoan(data, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        // borrowMargin
        //
        //     {
        //         "borrow_id": "629a7177a4ed4cf09869c6a4343b788c",
        //     }
        //
        // repayMargin
        //
        //     {
        //         "repay_id": "2afcc16d99bd4707818c5a355dc89bed",
        //     }
        //
        return new Dictionary<string, object>() {
            { "id", this.safeString2(info, "borrow_id", "repay_id") },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "amount", null },
            { "symbol", null },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    /**
     * @method
     * @name bitmart#fetchIsolatedBorrowRate
     * @description fetch the rate of interest to borrow a currency for margin trading
     * @see https://developer-pro.bitmart.com/en/spot/#get-trading-pair-borrowing-rate-and-amount-keyed
     * @param {string} symbol unified symbol of the market to fetch the borrow rate for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [isolated borrow rate structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#isolated-borrow-rate-structure}
     */
    public async override Task<object> fetchIsolatedBorrowRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateGetSpotV1MarginIsolatedPairs(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "0985a130-a5ae-4fc1-863f-4704e214f585",
        //         "data": {
        //             "symbols": [
        //                 {
        //                     "symbol": "BTC_USDT",
        //                     "max_leverage": "5",
        //                     "symbol_enabled": true,
        //                     "base": {
        //                         "currency": "BTC",
        //                         "daily_interest": "0.00055000",
        //                         "hourly_interest": "0.00002291",
        //                         "max_borrow_amount": "2.00000000",
        //                         "min_borrow_amount": "0.00000001",
        //                         "borrowable_amount": "0.00670810"
        //                     },
        //                     "quote": {
        //                         "currency": "USDT",
        //                         "daily_interest": "0.00055000",
        //                         "hourly_interest": "0.00002291",
        //                         "max_borrow_amount": "50000.00000000",
        //                         "min_borrow_amount": "0.00000001",
        //                         "borrowable_amount": "135.12575038"
        //                     }
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object symbols = this.safeList(data, "symbols", new List<object>() {});
        object borrowRate = this.safeDict(symbols, 0, new List<object>() {});
        return this.parseIsolatedBorrowRate(borrowRate, market);
    }

    public override object parseIsolatedBorrowRate(object info, object market = null)
    {
        //
        //     {
        //         "symbol": "BTC_USDT",
        //         "max_leverage": "5",
        //         "symbol_enabled": true,
        //         "base": {
        //             "currency": "BTC",
        //             "daily_interest": "0.00055000",
        //             "hourly_interest": "0.00002291",
        //             "max_borrow_amount": "2.00000000",
        //             "min_borrow_amount": "0.00000001",
        //             "borrowable_amount": "0.00670810"
        //         },
        //         "quote": {
        //             "currency": "USDT",
        //             "daily_interest": "0.00055000",
        //             "hourly_interest": "0.00002291",
        //             "max_borrow_amount": "50000.00000000",
        //             "min_borrow_amount": "0.00000001",
        //             "borrowable_amount": "135.12575038"
        //         }
        //     }
        //
        object marketId = this.safeString(info, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object baseData = this.safeDict(info, "base", new Dictionary<string, object>() {});
        object quoteData = this.safeDict(info, "quote", new Dictionary<string, object>() {});
        object baseId = this.safeString(baseData, "currency");
        object quoteId = this.safeString(quoteData, "currency");
        return new Dictionary<string, object>() {
            { "symbol", symbol },
            { "base", this.safeCurrencyCode(baseId) },
            { "baseRate", this.safeNumber(baseData, "hourly_interest") },
            { "quote", this.safeCurrencyCode(quoteId) },
            { "quoteRate", this.safeNumber(quoteData, "hourly_interest") },
            { "period", 3600000 },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    /**
     * @method
     * @name bitmart#fetchIsolatedBorrowRates
     * @description fetch the borrow interest rates of all currencies, currently only works for isolated margin
     * @see https://developer-pro.bitmart.com/en/spot/#get-trading-pair-borrowing-rate-and-amount-keyed
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [isolated borrow rate structures]{@link https://docs.ccxt.com/#/?id=isolated-borrow-rate-structure}
     */
    public async override Task<object> fetchIsolatedBorrowRates(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetSpotV1MarginIsolatedPairs(parameters);
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "0985a130-a5ae-4fc1-863f-4704e214f585",
        //         "data": {
        //             "symbols": [
        //                 {
        //                     "symbol": "BTC_USDT",
        //                     "max_leverage": "5",
        //                     "symbol_enabled": true,
        //                     "base": {
        //                         "currency": "BTC",
        //                         "daily_interest": "0.00055000",
        //                         "hourly_interest": "0.00002291",
        //                         "max_borrow_amount": "2.00000000",
        //                         "min_borrow_amount": "0.00000001",
        //                         "borrowable_amount": "0.00670810"
        //                     },
        //                     "quote": {
        //                         "currency": "USDT",
        //                         "daily_interest": "0.00055000",
        //                         "hourly_interest": "0.00002291",
        //                         "max_borrow_amount": "50000.00000000",
        //                         "min_borrow_amount": "0.00000001",
        //                         "borrowable_amount": "135.12575038"
        //                     }
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object symbols = this.safeList(data, "symbols", new List<object>() {});
        return this.parseIsolatedBorrowRates(symbols);
    }

    /**
     * @method
     * @name bitmart#transfer
     * @description transfer currency internally between wallets on the same account, currently only supports transfer between spot and margin
     * @see https://developer-pro.bitmart.com/en/spot/#margin-asset-transfer-signed
     * @see https://developer-pro.bitmart.com/en/futures/#transfer-signed
     * @see https://developer-pro.bitmart.com/en/futuresv2/#transfer-signed
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account to transfer from
     * @param {string} toAccount account to transfer to
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object amountToPrecision = this.currencyToPrecision(code, amount);
        object request = new Dictionary<string, object>() {
            { "amount", amountToPrecision },
            { "currency", getValue(currency, "id") },
        };
        object fromId = this.convertTypeToAccount(fromAccount);
        object toId = this.convertTypeToAccount(toAccount);
        if (isTrue(isEqual(fromAccount, "spot")))
        {
            if (isTrue(isEqual(toAccount, "margin")))
            {
                ((IDictionary<string,object>)request)["side"] = "in";
                ((IDictionary<string,object>)request)["symbol"] = toId;
            } else if (isTrue(isEqual(toAccount, "swap")))
            {
                ((IDictionary<string,object>)request)["type"] = "spot_to_contract";
            }
        } else if (isTrue(isEqual(toAccount, "spot")))
        {
            if (isTrue(isEqual(fromAccount, "margin")))
            {
                ((IDictionary<string,object>)request)["side"] = "out";
                ((IDictionary<string,object>)request)["symbol"] = fromId;
            } else if (isTrue(isEqual(fromAccount, "swap")))
            {
                ((IDictionary<string,object>)request)["type"] = "contract_to_spot";
            }
        } else
        {
            throw new ArgumentsRequired ((string)add(this.id, " transfer() requires either fromAccount or toAccount to be spot")) ;
        }
        object response = null;
        if (isTrue(isTrue((isEqual(fromAccount, "margin"))) || isTrue((isEqual(toAccount, "margin")))))
        {
            response = await this.privatePostSpotV1MarginIsolatedTransfer(this.extend(request, parameters));
        } else if (isTrue(isTrue((isEqual(fromAccount, "swap"))) || isTrue((isEqual(toAccount, "swap")))))
        {
            response = await this.privatePostAccountV1TransferContract(this.extend(request, parameters));
        }
        //
        // margin
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "b26cecec-ef5a-47d9-9531-2bd3911d3d55",
        //         "data": {
        //             "transfer_id": "ca90d97a621e47d49774f19af6b029f5"
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "4cad858074667097ac6ba5257c57305d.68.16953302431189455",
        //         "data": {
        //             "currency": "USDT",
        //             "amount": "5"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.extend(this.parseTransfer(data, currency), new Dictionary<string, object>() {
            { "status", this.parseTransferStatus(this.safeString2(response, "code", "message")) },
        });
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "1000", "ok" },
            { "OK", "ok" },
            { "FINISHED", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseTransferToAccount(object type)
    {
        object types = new Dictionary<string, object>() {
            { "contract_to_spot", "spot" },
            { "spot_to_contract", "swap" },
        };
        return this.safeString(types, type, type);
    }

    public virtual object parseTransferFromAccount(object type)
    {
        object types = new Dictionary<string, object>() {
            { "contract_to_spot", "swap" },
            { "spot_to_contract", "spot" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // margin
        //
        //     {
        //         "transfer_id": "ca90d97a621e47d49774f19af6b029f5"
        //     }
        //
        // swap
        //
        //     {
        //         "currency": "USDT",
        //         "amount": "5"
        //     }
        //
        // fetchTransfers
        //
        //     {
        //         "transfer_id": "902463535961567232",
        //         "currency": "USDT",
        //         "amount": "5",
        //         "type": "contract_to_spot",
        //         "state": "FINISHED",
        //         "timestamp": 1695330539565
        //     }
        //
        object currencyId = this.safeString(transfer, "currency");
        object timestamp = this.safeInteger(transfer, "timestamp");
        return new Dictionary<string, object>() {
            { "id", this.safeString(transfer, "transfer_id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber(transfer, "amount") },
            { "fromAccount", this.parseTransferFromAccount(this.safeString(transfer, "type")) },
            { "toAccount", this.parseTransferToAccount(this.safeString(transfer, "type")) },
            { "status", this.parseTransferStatus(this.safeString(transfer, "state")) },
        };
    }

    /**
     * @method
     * @name bitmart#fetchTransfers
     * @description fetch a history of internal transfers made on an account, only transfers between spot and swap are supported
     * @see https://developer-pro.bitmart.com/en/futures/#get-transfer-list-signed
     * @param {string} code unified currency code of the currency transferred
     * @param {int} [since] the earliest time in ms to fetch transfers for
     * @param {int} [limit] the maximum number of transfer structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.page] the required number of pages, default is 1, max is 1000
     * @param {int} [params.until] the latest time in ms to fetch transfers for
     * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(limit, null)))
        {
            limit = 10;
        }
        object request = new Dictionary<string, object>() {
            { "page", this.safeInteger(parameters, "page", 1) },
            { "limit", limit },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["time_start"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = this.safeInteger(parameters, "until"); // unified in milliseconds
        object endTime = this.safeInteger(parameters, "time_end", until); // exchange-specific in milliseconds
        parameters = this.omit(parameters, new List<object>() {"until"});
        if (isTrue(!isEqual(endTime, null)))
        {
            ((IDictionary<string,object>)request)["time_end"] = endTime;
        }
        object response = await this.privatePostAccountV1TransferContractList(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "7f9d93e10f9g4513bc08a7btc2a5559a.69.16953325693032193",
        //         "data": {
        //             "records": [
        //                 {
        //                     "transfer_id": "902463535961567232",
        //                     "currency": "USDT",
        //                     "amount": "5",
        //                     "type": "contract_to_spot",
        //                     "state": "FINISHED",
        //                     "timestamp": 1695330539565
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object records = this.safeList(data, "records", new List<object>() {});
        return this.parseTransfers(records, currency, since, limit);
    }

    /**
     * @method
     * @name bitmart#fetchBorrowInterest
     * @description fetch the interest owed by the user for borrowing currency for margin trading
     * @see https://developer-pro.bitmart.com/en/spot/#get-borrow-record-isolated
     * @param {string} code unified currency code
     * @param {string} symbol unified market symbol when fetch interest in isolated markets
     * @param {int} [since] the earliest time in ms to fetch borrrow interest for
     * @param {int} [limit] the maximum number of structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
     */
    public async override Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchBorrowInterest() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["N"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        object response = await this.privateGetSpotV1MarginIsolatedBorrowRecord(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "8ea27a2a-4aba-49fa-961d-43a0137b0ef3",
        //         "data": {
        //             "records": [
        //                 {
        //                     "borrow_id": "1659045283903rNvJnuRTJNL5J53n",
        //                     "symbol": "BTC_USDT",
        //                     "currency": "USDT",
        //                     "borrow_amount": "100.00000000",
        //                     "daily_interest": "0.00055000",
        //                     "hourly_interest": "0.00002291",
        //                     "interest_amount": "0.00229166",
        //                     "create_time": 1659045284000
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeList(data, "records", new List<object>() {});
        object interest = this.parseBorrowInterests(rows, market);
        return this.filterByCurrencySinceLimit(interest, code, since, limit);
    }

    public override object parseBorrowInterest(object info, object market = null)
    {
        //
        //     {
        //         "borrow_id": "1657664327844Lk5eJJugXmdHHZoe",
        //         "symbol": "BTC_USDT",
        //         "currency": "USDT",
        //         "borrow_amount": "20.00000000",
        //         "daily_interest": "0.00055000",
        //         "hourly_interest": "0.00002291",
        //         "interest_amount": "0.00045833",
        //         "create_time": 1657664329000
        //     }
        //
        object marketId = this.safeString(info, "symbol");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(info, "create_time");
        return new Dictionary<string, object>() {
            { "info", info },
            { "symbol", this.safeString(market, "symbol") },
            { "currency", this.safeCurrencyCode(this.safeString(info, "currency")) },
            { "interest", this.safeNumber(info, "interest_amount") },
            { "interestRate", this.safeNumber(info, "hourly_interest") },
            { "amountBorrowed", this.safeNumber(info, "borrow_amount") },
            { "marginMode", "isolated" },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }

    /**
     * @method
     * @name bitmart#fetchOpenInterest
     * @description Retrieves the open interest of a currency
     * @see https://developer-pro.bitmart.com/en/futuresv2/#get-futures-openinterest
     * @param {string} symbol Unified CCXT market symbol
     * @param {object} [params] exchange specific parameters
     * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
     */
    public async override Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "contract")))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterest() supports contract markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetContractPublicOpenInterest(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": {
        //             "timestamp": 1694657502415,
        //             "symbol": "BTCUSDT",
        //             "open_interest": "265231.721368593081729069",
        //             "open_interest_value": "7006353.83988919"
        //         },
        //         "trace": "7f9c94e10f9d4513bc08a7bfc2a5559a.72.16946575108274991"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOpenInterest(data, market);
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        //     {
        //         "timestamp": 1694657502415,
        //         "symbol": "BTCUSDT",
        //         "open_interest": "265231.721368593081729069",
        //         "open_interest_value": "7006353.83988919"
        //     }
        //
        object timestamp = this.safeInteger(interest, "timestamp");
        object id = this.safeString(interest, "symbol");
        return this.safeOpenInterest(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(id, market) },
            { "openInterestAmount", this.safeNumber(interest, "open_interest") },
            { "openInterestValue", this.safeNumber(interest, "open_interest_value") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", interest },
        }, market);
    }

    /**
     * @method
     * @name bitmart#setLeverage
     * @description set the level of leverage for a market
     * @see https://developer-pro.bitmart.com/en/futures/#submit-leverage-signed
     * @see https://developer-pro.bitmart.com/en/futuresv2/#submit-leverage-signed
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'isolated' or 'cross'
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("setLeverage", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        this.checkRequiredArgument("setLeverage", marginMode, "marginMode", new List<object>() {"isolated", "cross"});
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " setLeverage() supports swap contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "leverage", ((object)leverage).ToString() },
            { "open_type", marginMode },
        };
        return await this.privatePostContractPrivateSubmitLeverage(this.extend(request, parameters));
    }

    /**
     * @method
     * @name bitmart#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://developer-pro.bitmart.com/en/futuresv2/#get-current-funding-rate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRate() supports swap contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetContractPublicFundingRate(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": {
        //             "timestamp": 1695184410697,
        //             "symbol": "BTCUSDT",
        //             "rate_value": "-0.00002614",
        //             "expected_rate": "-0.00002"
        //         },
        //         "trace": "4cad855074654097ac7ba5257c47305d.54.16951844206655589"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseFundingRate(data, market);
    }

    /**
     * @method
     * @name bitmart#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://developer-pro.bitmart.com/en/futuresv2/#get-funding-rate-history
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] not sent to exchange api, exchange api always returns the most recent data, only used to filter exchange response
     * @param {int} [limit] the maximum amount of funding rate structures to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.publicGetContractPublicFundingRateHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": {
        //             "list": [
        //                 {
        //                     "symbol": "BTCUSDT",
        //                     "funding_rate": "0.000091412174",
        //                     "funding_time": "1734336000000"
        //                 },
        //             ]
        //         },
        //         "trace": "fg73d949fgfdf6a40c8fc7f5ae6738.54.345345345345"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object result = this.safeList(data, "list", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
        {
            object entry = getValue(result, i);
            object marketId = this.safeString(entry, "symbol");
            object symbolInner = this.safeSymbol(marketId, market, "-", "swap");
            object timestamp = this.safeInteger(entry, "funding_time");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbolInner },
                { "fundingRate", this.safeNumber(entry, "funding_rate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //     {
        //         "timestamp": 1695184410697,
        //         "symbol": "BTCUSDT",
        //         "rate_value": "-0.00002614",
        //         "expected_rate": "-0.00002"
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        object timestamp = this.safeInteger(contract, "timestamp");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", this.safeSymbol(marketId, market) },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fundingRate", this.safeNumber(contract, "expected_rate") },
            { "fundingTimestamp", null },
            { "fundingDatetime", null },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", this.safeNumber(contract, "rate_value") },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", null },
        };
    }

    /**
     * @method
     * @name bitmart#fetchPosition
     * @description fetch data on a single open contract trade position
     * @see https://developer-pro.bitmart.com/en/futures/#get-current-position-keyed
     * @see https://developer-pro.bitmart.com/en/futuresv2/#get-current-position-risk-details-keyed
     * @param {string} symbol unified market symbol of the market the position is held in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateGetContractPrivatePosition(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "leverage": "10",
        //                 "timestamp": 1696392515269,
        //                 "current_fee": "0.0014250028",
        //                 "open_timestamp": 1696392256998,
        //                 "current_value": "27.4039",
        //                 "mark_price": "27.4039",
        //                 "position_value": "27.4079",
        //                 "position_cross": "3.75723474",
        //                 "maintenance_margin": "0.1370395",
        //                 "close_vol": "0",
        //                 "close_avg_price": "0",
        //                 "open_avg_price": "27407.9",
        //                 "entry_price": "27407.9",
        //                 "current_amount": "1",
        //                 "unrealized_value": "-0.004",
        //                 "realized_value": "-0.01644474",
        //                 "position_type": 1
        //             }
        //         ],
        //         "trace":"4cad855074664097ac5ba5257c47305d.67.16963925142065945"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parsePosition(first, market);
    }

    /**
     * @method
     * @name bitmart#fetchPositions
     * @description fetch all open contract positions
     * @see https://developer-pro.bitmart.com/en/futures/#get-current-position-keyed
     * @see https://developer-pro.bitmart.com/en/futuresv2/#get-current-position-risk-details-keyed
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object symbolsLength = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            symbolsLength = getArrayLength(symbols);
            object first = this.safeString(symbols, 0);
            market = this.market(first);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(isEqual(symbolsLength, 1)))
        {
            // only supports symbols as undefined or sending one symbol
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object response = await this.privateGetContractPrivatePosition(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "leverage": "10",
        //                 "timestamp": 1696392515269,
        //                 "current_fee": "0.0014250028",
        //                 "open_timestamp": 1696392256998,
        //                 "current_value": "27.4039",
        //                 "mark_price": "27.4039",
        //                 "position_value": "27.4079",
        //                 "position_cross": "3.75723474",
        //                 "maintenance_margin": "0.1370395",
        //                 "close_vol": "0",
        //                 "close_avg_price": "0",
        //                 "open_avg_price": "27407.9",
        //                 "entry_price": "27407.9",
        //                 "current_amount": "1",
        //                 "unrealized_value": "-0.004",
        //                 "realized_value": "-0.01644474",
        //                 "position_type": 1
        //             },
        //         ],
        //         "trace":"4cad855074664097ac5ba5257c47305d.67.16963925142065945"
        //     }
        //
        object positions = this.safeList(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parsePosition(getValue(positions, i)));
        }
        symbols = this.marketSymbols(symbols);
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "leverage": "10",
        //         "timestamp": 1696392515269,
        //         "current_fee": "0.0014250028",
        //         "open_timestamp": 1696392256998,
        //         "current_value": "27.4039",
        //         "mark_price": "27.4039",
        //         "position_value": "27.4079",
        //         "position_cross": "3.75723474",
        //         "maintenance_margin": "0.1370395",
        //         "close_vol": "0",
        //         "close_avg_price": "0",
        //         "open_avg_price": "27407.9",
        //         "entry_price": "27407.9",
        //         "current_amount": "1",
        //         "unrealized_value": "-0.004",
        //         "realized_value": "-0.01644474",
        //         "position_type": 1
        //     }
        //
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger(position, "timestamp");
        object side = this.safeInteger(position, "position_type");
        object maintenanceMargin = this.safeString(position, "maintenance_margin");
        object notional = this.safeString(position, "current_value");
        object collateral = this.safeString(position, "position_cross");
        object maintenanceMarginPercentage = Precise.stringDiv(maintenanceMargin, notional);
        object marginRatio = Precise.stringDiv(maintenanceMargin, collateral);
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", null },
            { "hedged", null },
            { "side", ((bool) isTrue((isEqual(side, 1)))) ? "long" : "short" },
            { "contracts", this.safeNumber(position, "current_amount") },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "entryPrice", this.safeNumber(position, "entry_price") },
            { "markPrice", this.safeNumber(position, "mark_price") },
            { "lastPrice", null },
            { "notional", this.parseNumber(notional) },
            { "leverage", this.safeNumber(position, "leverage") },
            { "collateral", this.parseNumber(collateral) },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "maintenanceMargin", this.parseNumber(maintenanceMargin) },
            { "maintenanceMarginPercentage", this.parseNumber(maintenanceMarginPercentage) },
            { "unrealizedPnl", this.safeNumber(position, "unrealized_value") },
            { "realizedPnl", this.safeNumber(position, "realized_value") },
            { "liquidationPrice", null },
            { "marginMode", null },
            { "percentage", null },
            { "marginRatio", this.parseNumber(marginRatio) },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    /**
     * @method
     * @name bitmart#fetchMyLiquidations
     * @description retrieves the users liquidated positions
     * @see https://developer-pro.bitmart.com/en/futures/#get-order-history-keyed
     * @param {string} symbol unified CCXT market symbol
     * @param {int} [since] the earliest time in ms to fetch liquidations for
     * @param {int} [limit] the maximum number of liquidation structures to retrieve
     * @param {object} [params] exchange specific parameters for the bitmart api endpoint
     * @param {int} [params.until] timestamp in ms of the latest liquidation
     * @returns {object} an array of [liquidation structures]{@link https://docs.ccxt.com/#/?id=liquidation-structure}
     */
    public async override Task<object> fetchMyLiquidations(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyLiquidations() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new NotSupported ((string)add(this.id, " fetchMyLiquidations() supports swap markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateGetContractPrivateOrderHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": [
        //             {
        //                 "order_id": "231007865458273",
        //                 "client_order_id": "",
        //                 "price": "27407.9",
        //                 "size": "1",
        //                 "symbol": "BTCUSDT",
        //                 "state": 4,
        //                 "side": 3,
        //                 "type": "liquidate",
        //                 "leverage": "10",
        //                 "open_type": "isolated",
        //                 "deal_avg_price": "27422.6",
        //                 "deal_size": "1",
        //                 "create_time": 1696405864011,
        //                 "update_time": 1696405864045
        //             },
        //         ],
        //         "trace": "4cad855074664097ac6ba4257c47305d.71.16965658195443021"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object checkLiquidation = this.safeString(entry, "type");
            if (isTrue(isEqual(checkLiquidation, "liquidate")))
            {
                ((IList<object>)result).Add(entry);
            }
        }
        return this.parseLiquidations(result, market, since, limit);
    }

    public override object parseLiquidation(object liquidation, object market = null)
    {
        //
        //     {
        //         "order_id": "231007865458273",
        //         "client_order_id": "",
        //         "price": "27407.9",
        //         "size": "1",
        //         "symbol": "BTCUSDT",
        //         "state": 4,
        //         "side": 3,
        //         "type": "market",
        //         "leverage": "10",
        //         "open_type": "isolated",
        //         "deal_avg_price": "27422.6",
        //         "deal_size": "1",
        //         "create_time": 1696405864011,
        //         "update_time": 1696405864045
        //     }
        //
        object marketId = this.safeString(liquidation, "symbol");
        object timestamp = this.safeInteger(liquidation, "update_time");
        object contractsString = this.safeString(liquidation, "deal_size");
        object contractSizeString = this.safeString(market, "contractSize");
        object priceString = this.safeString(liquidation, "deal_avg_price");
        object baseValueString = Precise.stringMul(contractsString, contractSizeString);
        object quoteValueString = Precise.stringMul(baseValueString, priceString);
        return this.safeLiquidation(new Dictionary<string, object>() {
            { "info", liquidation },
            { "symbol", this.safeSymbol(marketId, market) },
            { "contracts", this.parseNumber(contractsString) },
            { "contractSize", this.parseNumber(contractSizeString) },
            { "price", this.parseNumber(priceString) },
            { "baseValue", this.parseNumber(baseValueString) },
            { "quoteValue", this.parseNumber(quoteValueString) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        });
    }

    /**
     * @method
     * @name bitmart#editOrder
     * @description edits an open order
     * @see https://developer-pro.bitmart.com/en/futuresv2/#modify-plan-order-signed
     * @see https://developer-pro.bitmart.com/en/futuresv2/#modify-tp-sl-order-signed
     * @see https://developer-pro.bitmart.com/en/futuresv2/#modify-preset-plan-order-signed
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market to edit an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} [amount] how much you want to trade in units of the base currency
     * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.triggerPrice] *swap only* the price to trigger a stop order
     * @param {string} [params.stopLossPrice] *swap only* the price to trigger a stop-loss order
     * @param {string} [params.takeProfitPrice] *swap only* the price to trigger a take-profit order
     * @param {string} [params.stopLoss.triggerPrice] *swap only* the price to trigger a preset stop-loss order
     * @param {string} [params.takeProfit.triggerPrice] *swap only* the price to trigger a preset take-profit order
     * @param {string} [params.clientOrderId] client order id of the order
     * @param {int} [params.price_type] *swap only* 1: last price, 2: fair price, default is 1
     * @param {int} [params.plan_category] *swap tp/sl only* 1: tp/sl, 2: position tp/sl, default is 1
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " editOrder() does not support "), getValue(market, "type")), " markets, only swap markets are supported")) ;
        }
        object stopLossPrice = this.safeString(parameters, "stopLossPrice");
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        object triggerPrice = this.safeStringN(parameters, new List<object>() {"triggerPrice", "stopPrice", "trigger_price"});
        object stopLoss = this.safeDict(parameters, "stopLoss", new Dictionary<string, object>() {});
        object takeProfit = this.safeDict(parameters, "takeProfit", new Dictionary<string, object>() {});
        object presetStopLoss = this.safeString(stopLoss, "triggerPrice");
        object presetTakeProfit = this.safeString(takeProfit, "triggerPrice");
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object isStopLoss = !isEqual(stopLossPrice, null);
        object isTakeProfit = !isEqual(takeProfitPrice, null);
        object isPresetStopLoss = !isEqual(presetStopLoss, null);
        object isPresetTakeProfit = !isEqual(presetTakeProfit, null);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            parameters = this.omit(parameters, "clientOrderId");
            ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
        }
        if (isTrue(!isEqual(id, null)))
        {
            ((IDictionary<string,object>)request)["order_id"] = id;
        }
        parameters = this.omit(parameters, new List<object>() {"triggerPrice", "stopPrice", "stopLossPrice", "takeProfitPrice", "stopLoss", "takeProfit"});
        object response = null;
        if (isTrue(isTrue(isTrue(isTriggerOrder) || isTrue(isStopLoss)) || isTrue(isTakeProfit)))
        {
            ((IDictionary<string,object>)request)["price_type"] = this.safeInteger(parameters, "price_type", 1);
            if (isTrue(!isEqual(price, null)))
            {
                ((IDictionary<string,object>)request)["executive_price"] = this.priceToPrecision(symbol, price);
            }
        }
        if (isTrue(isTriggerOrder))
        {
            ((IDictionary<string,object>)request)["type"] = type;
            ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, triggerPrice);
            response = await this.privatePostContractPrivateModifyPlanOrder(this.extend(request, parameters));
        } else if (isTrue(isTrue(isStopLoss) || isTrue(isTakeProfit)))
        {
            ((IDictionary<string,object>)request)["category"] = type;
            if (isTrue(isStopLoss))
            {
                ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, stopLossPrice);
            } else
            {
                ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, takeProfitPrice);
            }
            response = await this.privatePostContractPrivateModifyTpSlOrder(this.extend(request, parameters));
        } else if (isTrue(isTrue(isPresetStopLoss) || isTrue(isPresetTakeProfit)))
        {
            if (isTrue(isPresetStopLoss))
            {
                ((IDictionary<string,object>)request)["preset_stop_loss_price_type"] = this.safeInteger(parameters, "price_type", 1);
                ((IDictionary<string,object>)request)["preset_stop_loss_price"] = this.priceToPrecision(symbol, presetStopLoss);
            } else
            {
                ((IDictionary<string,object>)request)["preset_take_profit_price_type"] = this.safeInteger(parameters, "price_type", 1);
                ((IDictionary<string,object>)request)["preset_take_profit_price"] = this.priceToPrecision(symbol, presetTakeProfit);
            }
            response = await this.privatePostContractPrivateModifyPresetPlanOrder(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(this.id, " editOrder() only supports trigger, stop loss and take profit orders")) ;
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    /**
     * @method
     * @name bitmart#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
     * @see https://developer-pro.bitmart.com/en/futuresv2/#get-transaction-history-keyed
     * @param {string} [code] unified currency code
     * @param {int} [since] timestamp in ms of the earliest ledger entry
     * @param {int} [limit] max number of ledger entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest ledger entry
     * @returns {object[]} a list of [ledger structures]{@link https://docs.ccxt.com/#/?id=ledger}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object request = new Dictionary<string, object>() {};
        var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object transactionsRequest = this.fetchTransactionsRequest(0, null, since, limit, parameters);
        object response = await this.privateGetContractPrivateTransactionHistory(transactionsRequest);
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": [
        //             {
        //                 "time": "1734422402121",
        //                 "type": "Funding Fee",
        //                 "amount": "-0.00008253",
        //                 "asset": "USDT",
        //                 "symbol": "LTCUSDT",
        //                 "tran_id": "1734422402121",
        //                 "flow_type": 3
        //             },
        //         ],
        //         "trace": "4cd11f83c71egfhfgh842790f07241e.23.173442343427772866"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseLedger(data, currency, since, limit);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //         "time": "1734422402121",
        //         "type": "Funding Fee",
        //         "amount": "-0.00008253",
        //         "asset": "USDT",
        //         "symbol": "LTCUSDT",
        //         "tran_id": "1734422402121",
        //         "flow_type": 3
        //     }
        //
        object amount = this.safeString(item, "amount");
        object direction = null;
        if (isTrue(Precise.stringLe(amount, "0")))
        {
            direction = "out";
            amount = Precise.stringMul("-1", amount);
        } else
        {
            direction = "in";
        }
        object currencyId = this.safeString(item, "asset");
        currency = this.safeCurrency(currencyId, currency);
        object timestamp = this.safeInteger(item, "time");
        object type = this.safeString(item, "type");
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", this.safeString(item, "tran_id") },
            { "direction", direction },
            { "account", null },
            { "referenceAccount", null },
            { "referenceId", this.safeString(item, "tradeId") },
            { "type", this.parseLedgerEntryType(type) },
            { "currency", getValue(currency, "code") },
            { "amount", this.parseNumber(amount) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "before", null },
            { "after", null },
            { "status", null },
            { "fee", null },
        }, currency);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object ledgerType = new Dictionary<string, object>() {
            { "Commission Fee", "fee" },
            { "Funding Fee", "fee" },
            { "Realized PNL", "trade" },
            { "Transfer", "transfer" },
            { "Liquidation Clearance", "settlement" },
        };
        return this.safeString(ledgerType, type, type);
    }

    public virtual object fetchTransactionsRequest(object flowType = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(flowType, null)))
        {
            ((IDictionary<string,object>)request)["flow_type"] = flowType;
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        return this.extend(request, parameters);
    }

    /**
     * @method
     * @name bitmart#fetchFundingHistory
     * @description fetch the history of funding payments paid and received on this account
     * @see https://developer-pro.bitmart.com/en/futuresv2/#get-transaction-history-keyed
     * @param {string} [symbol] unified market symbol
     * @param {int} [since] the starting timestamp in milliseconds
     * @param {int} [limit] the number of entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch funding history for
     * @returns {object[]} a list of [funding history structures]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
     */
    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object transactionsRequest = this.fetchTransactionsRequest(3, symbol, since, limit, parameters);
        object response = await this.privateGetContractPrivateTransactionHistory(transactionsRequest);
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": [
        //             {
        //                 "time": "1734422402121",
        //                 "type": "Funding Fee",
        //                 "amount": "-0.00008253",
        //                 "asset": "USDT",
        //                 "symbol": "LTCUSDT",
        //                 "tran_id": "1734422402121",
        //                 "flow_type": 3
        //             },
        //         ],
        //         "trace": "4cd11f83c71egfhfgh842790f07241e.23.173442343427772866"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseFundingHistories(data, market, since, limit);
    }

    public virtual object parseFundingHistory(object contract, object market = null)
    {
        //
        //     {
        //         "time": "1734422402121",
        //         "type": "Funding Fee",
        //         "amount": "-0.00008253",
        //         "asset": "USDT",
        //         "symbol": "LTCUSDT",
        //         "tran_id": "1734422402121",
        //         "flow_type": 3
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        object currencyId = this.safeString(contract, "asset");
        object timestamp = this.safeInteger(contract, "time");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", this.safeSymbol(marketId, market, null, "swap") },
            { "code", this.safeCurrencyCode(currencyId) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", this.safeString(contract, "tran_id") },
            { "amount", this.safeNumber(contract, "amount") },
        };
    }

    public virtual object parseFundingHistories(object contracts, object market = null, object since = null, object limit = null)
    {
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(contracts)); postFixIncrement(ref i))
        {
            object contract = getValue(contracts, i);
            ((IList<object>)result).Add(this.parseFundingHistory(contract, market));
        }
        object sorted = this.sortBy(result, "timestamp");
        return this.filterBySinceLimit(sorted, since, limit);
    }

    public override object nonce()
    {
        return subtract(this.milliseconds(), getValue(this.options, "timeDifference"));
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object parts = ((string)path).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
        // to do: refactor api endpoints with spot/swap sections
        object category = this.safeString(parts, 0, "spot");
        object market = ((bool) isTrue((isTrue(isEqual(category, "spot")) || isTrue(isEqual(category, "account"))))) ? "spot" : "swap";
        object baseUrl = this.implodeHostname(getValue(getValue(this.urls, "api"), market));
        object url = add(add(baseUrl, "/"), this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        object queryString = "";
        object getOrDelete = isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE")));
        if (isTrue(getOrDelete))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                queryString = this.urlencode(query);
                url = add(url, add("?", queryString));
            }
        }
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object timestamp = ((object)this.nonce()).ToString();
            object brokerId = this.safeString(this.options, "brokerId", "CCXTxBitmart000");
            headers = new Dictionary<string, object>() {
                { "X-BM-KEY", this.apiKey },
                { "X-BM-TIMESTAMP", timestamp },
                { "X-BM-BROKER-ID", brokerId },
                { "Content-Type", "application/json" },
            };
            if (!isTrue(getOrDelete))
            {
                body = this.json(query);
                queryString = body;
            }
            object auth = add(add(add(add(timestamp, "#"), this.uid), "#"), queryString);
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
            ((IDictionary<string,object>)headers)["X-BM-SIGN"] = signature;
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        //
        // spot
        //
        //     {"message":"Bad Request [to is empty]","code":50000,"trace":"f9d46e1b-4edb-4d07-a06e-4895fb2fc8fc","data":{}}
        //     {"message":"Bad Request [from is empty]","code":50000,"trace":"579986f7-c93a-4559-926b-06ba9fa79d76","data":{}}
        //     {"message":"Kline size over 500","code":50004,"trace":"d625caa8-e8ca-4bd2-b77c-958776965819","data":{}}
        //     {"message":"Balance not enough","code":50020,"trace":"7c709d6a-3292-462c-98c5-32362540aeef","data":{}}
        //     {"code":40012,"message":"You contract account available balance not enough.","trace":"..."}
        //
        // contract
        //
        //     {"errno":"OK","message":"INVALID_PARAMETER","code":49998,"trace":"eb5ebb54-23cd-4de2-9064-e090b6c3b2e3","data":null}
        //
        object message = this.safeStringLower(response, "message");
        object isErrorMessage = isTrue(isTrue((!isEqual(message, null))) && isTrue((!isEqual(message, "ok")))) && isTrue((!isEqual(message, "success")));
        object errorCode = this.safeString(response, "code");
        object isErrorCode = isTrue((!isEqual(errorCode, null))) && isTrue((!isEqual(errorCode, "1000")));
        if (isTrue(isTrue(isErrorCode) || isTrue(isErrorMessage)))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), errorCode, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
