namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class bitmart : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bitmart" },
            { "name", "BitMart" },
            { "countries", new List<object>() {"US", "CN", "HK", "KR"} },
            { "rateLimit", 33.34 },
            { "version", "v2" },
            { "certified", true },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "borrowCrossMargin", false },
                { "borrowIsolatedMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", false },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createPostOnlyOrder", true },
                { "createStopLimitOrder", false },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "createTrailingPercentOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowInterest", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDeposit", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", true },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", null },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIsolatedBorrowRate", true },
                { "fetchIsolatedBorrowRates", true },
                { "fetchLiquidations", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMyLiquidations", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", false },
                { "fetchOrderTrades", true },
                { "fetchPosition", true },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchTransactionFee", true },
                { "fetchTransactionFees", false },
                { "fetchTransfer", false },
                { "fetchTransfers", true },
                { "fetchWithdrawAddressesByNetwork", false },
                { "fetchWithdrawal", true },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", true },
                { "setLeverage", true },
                { "setMarginMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "hostname", "bitmart.com" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/129991357-8f47464b-d0f4-41d6-8a82-34122f0d1398.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "rest", "https://api-cloud.{hostname}" },
                } },
                { "www", "https://www.bitmart.com/" },
                { "doc", "https://developer-pro.bitmart.com/" },
                { "referral", new Dictionary<string, object>() {
                    { "url", "http://www.bitmart.com/?r=rQCFLh" },
                    { "discount", 0.3 },
                } },
                { "fees", "https://www.bitmart.com/fee/en" },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "uid", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "system/time", 3 },
                        { "system/service", 3 },
                        { "spot/v1/currencies", 7.5 },
                        { "spot/v1/symbols", 7.5 },
                        { "spot/v1/symbols/details", 5 },
                        { "spot/quotation/v3/tickers", 6 },
                        { "spot/quotation/v3/ticker", 4 },
                        { "spot/quotation/v3/lite-klines", 5 },
                        { "spot/quotation/v3/klines", 7 },
                        { "spot/quotation/v3/books", 4 },
                        { "spot/quotation/v3/trades", 4 },
                        { "spot/v1/ticker", 5 },
                        { "spot/v2/ticker", 30 },
                        { "spot/v1/ticker_detail", 5 },
                        { "spot/v1/steps", 30 },
                        { "spot/v1/symbols/kline", 6 },
                        { "spot/v1/symbols/book", 5 },
                        { "spot/v1/symbols/trades", 5 },
                        { "contract/v1/tickers", 15 },
                        { "contract/public/details", 5 },
                        { "contract/public/depth", 5 },
                        { "contract/public/open-interest", 30 },
                        { "contract/public/funding-rate", 30 },
                        { "contract/public/kline", 6 },
                        { "account/v1/currencies", 30 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "account/sub-account/v1/transfer-list", 7.5 },
                        { "account/sub-account/v1/transfer-history", 7.5 },
                        { "account/sub-account/main/v1/wallet", 5 },
                        { "account/sub-account/main/v1/subaccount-list", 7.5 },
                        { "account/contract/sub-account/main/v1/wallet", 5 },
                        { "account/contract/sub-account/main/v1/transfer-list", 7.5 },
                        { "account/contract/sub-account/v1/transfer-history", 7.5 },
                        { "account/v1/wallet", 5 },
                        { "account/v1/currencies", 30 },
                        { "spot/v1/wallet", 5 },
                        { "account/v1/deposit/address", 30 },
                        { "account/v1/withdraw/charge", 32 },
                        { "account/v2/deposit-withdraw/history", 7.5 },
                        { "account/v1/deposit-withdraw/detail", 7.5 },
                        { "spot/v1/order_detail", 1 },
                        { "spot/v2/orders", 5 },
                        { "spot/v1/trades", 5 },
                        { "spot/v2/trades", 5 },
                        { "spot/v3/orders", 5 },
                        { "spot/v2/order_detail", 1 },
                        { "spot/v1/margin/isolated/borrow_record", 1 },
                        { "spot/v1/margin/isolated/repay_record", 1 },
                        { "spot/v1/margin/isolated/pairs", 30 },
                        { "spot/v1/margin/isolated/account", 5 },
                        { "spot/v1/trade_fee", 30 },
                        { "spot/v1/user_fee", 30 },
                        { "spot/v1/broker/rebate", 1 },
                        { "contract/private/assets-detail", 5 },
                        { "contract/private/order", 1.2 },
                        { "contract/private/order-history", 10 },
                        { "contract/private/position", 10 },
                        { "contract/private/get-open-orders", 1.2 },
                        { "contract/private/current-plan-order", 1.2 },
                        { "contract/private/trades", 10 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "account/sub-account/main/v1/sub-to-main", 30 },
                        { "account/sub-account/sub/v1/sub-to-main", 30 },
                        { "account/sub-account/main/v1/main-to-sub", 30 },
                        { "account/sub-account/sub/v1/sub-to-sub", 30 },
                        { "account/sub-account/main/v1/sub-to-sub", 30 },
                        { "account/contract/sub-account/main/v1/sub-to-main", 7.5 },
                        { "account/contract/sub-account/main/v1/main-to-sub", 7.5 },
                        { "account/contract/sub-account/sub/v1/sub-to-main", 7.5 },
                        { "account/v1/withdraw/apply", 7.5 },
                        { "spot/v1/submit_order", 1 },
                        { "spot/v1/batch_orders", 1 },
                        { "spot/v2/cancel_order", 1 },
                        { "spot/v1/cancel_orders", 15 },
                        { "spot/v4/query/order", 1 },
                        { "spot/v4/query/client-order", 1 },
                        { "spot/v4/query/open-orders", 5 },
                        { "spot/v4/query/history-orders", 5 },
                        { "spot/v4/query/trades", 5 },
                        { "spot/v4/query/order-trades", 5 },
                        { "spot/v3/cancel_order", 1 },
                        { "spot/v2/batch_orders", 1 },
                        { "spot/v2/submit_order", 1 },
                        { "spot/v1/margin/submit_order", 1 },
                        { "spot/v1/margin/isolated/borrow", 30 },
                        { "spot/v1/margin/isolated/repay", 30 },
                        { "spot/v1/margin/isolated/transfer", 30 },
                        { "account/v1/transfer-contract-list", 60 },
                        { "account/v1/transfer-contract", 60 },
                        { "contract/private/submit-order", 2.5 },
                        { "contract/private/cancel-order", 1.5 },
                        { "contract/private/cancel-orders", 30 },
                        { "contract/private/submit-plan-order", 2.5 },
                        { "contract/private/cancel-plan-order", 1.5 },
                        { "contract/private/submit-leverage", 2.5 },
                    } },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", 1 },
                { "3m", 3 },
                { "5m", 5 },
                { "15m", 15 },
                { "30m", 30 },
                { "45m", 45 },
                { "1h", 60 },
                { "2h", 120 },
                { "3h", 180 },
                { "4h", 240 },
                { "1d", 1440 },
                { "1w", 10080 },
                { "1M", 43200 },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.0040") },
                    { "maker", this.parseNumber("0.0035") },
                    { "tiers", new Dictionary<string, object>() {
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0020")}, new List<object> {this.parseNumber("10"), this.parseNumber("0.18")}, new List<object> {this.parseNumber("50"), this.parseNumber("0.0016")}, new List<object> {this.parseNumber("250"), this.parseNumber("0.0014")}, new List<object> {this.parseNumber("1000"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("5000"), this.parseNumber("0.0010")}, new List<object> {this.parseNumber("25000"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.0006")}} },
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("10"), this.parseNumber("0.0009")}, new List<object> {this.parseNumber("50"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("250"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("1000"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("5000"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("25000"), this.parseNumber("0.0004")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.0003")}} },
                    } },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "30000", typeof(ExchangeError) },
                    { "30001", typeof(AuthenticationError) },
                    { "30002", typeof(AuthenticationError) },
                    { "30003", typeof(AccountSuspended) },
                    { "30004", typeof(AuthenticationError) },
                    { "30005", typeof(AuthenticationError) },
                    { "30006", typeof(AuthenticationError) },
                    { "30007", typeof(AuthenticationError) },
                    { "30008", typeof(AuthenticationError) },
                    { "30010", typeof(PermissionDenied) },
                    { "30011", typeof(AuthenticationError) },
                    { "30012", typeof(AuthenticationError) },
                    { "30013", typeof(RateLimitExceeded) },
                    { "30014", typeof(ExchangeNotAvailable) },
                    { "30016", typeof(OnMaintenance) },
                    { "30017", typeof(RateLimitExceeded) },
                    { "30018", typeof(BadRequest) },
                    { "30019", typeof(PermissionDenied) },
                    { "60000", typeof(BadRequest) },
                    { "60001", typeof(BadRequest) },
                    { "60002", typeof(BadRequest) },
                    { "60003", typeof(ExchangeError) },
                    { "60004", typeof(ExchangeError) },
                    { "60005", typeof(ExchangeError) },
                    { "60006", typeof(ExchangeError) },
                    { "60007", typeof(InvalidAddress) },
                    { "60008", typeof(InsufficientFunds) },
                    { "60009", typeof(ExchangeError) },
                    { "60010", typeof(ExchangeError) },
                    { "60011", typeof(InvalidAddress) },
                    { "60012", typeof(ExchangeError) },
                    { "60020", typeof(PermissionDenied) },
                    { "60021", typeof(PermissionDenied) },
                    { "60022", typeof(PermissionDenied) },
                    { "60026", typeof(PermissionDenied) },
                    { "60027", typeof(PermissionDenied) },
                    { "60028", typeof(AccountSuspended) },
                    { "60029", typeof(AccountSuspended) },
                    { "60030", typeof(BadRequest) },
                    { "60031", typeof(BadRequest) },
                    { "60050", typeof(ExchangeError) },
                    { "60051", typeof(ExchangeError) },
                    { "61001", typeof(InsufficientFunds) },
                    { "61003", typeof(BadRequest) },
                    { "61004", typeof(BadRequest) },
                    { "61005", typeof(BadRequest) },
                    { "61006", typeof(NotSupported) },
                    { "61007", typeof(ExchangeError) },
                    { "61008", typeof(ExchangeError) },
                    { "70000", typeof(ExchangeError) },
                    { "70001", typeof(BadRequest) },
                    { "70002", typeof(BadSymbol) },
                    { "70003", typeof(NetworkError) },
                    { "71001", typeof(BadRequest) },
                    { "71002", typeof(BadRequest) },
                    { "71003", typeof(BadRequest) },
                    { "71004", typeof(BadRequest) },
                    { "71005", typeof(BadRequest) },
                    { "50000", typeof(BadRequest) },
                    { "50001", typeof(BadSymbol) },
                    { "50002", typeof(BadRequest) },
                    { "50003", typeof(BadRequest) },
                    { "50004", typeof(BadRequest) },
                    { "50005", typeof(OrderNotFound) },
                    { "50006", typeof(InvalidOrder) },
                    { "50007", typeof(InvalidOrder) },
                    { "50008", typeof(InvalidOrder) },
                    { "50009", typeof(InvalidOrder) },
                    { "50010", typeof(InvalidOrder) },
                    { "50011", typeof(InvalidOrder) },
                    { "50012", typeof(InvalidOrder) },
                    { "50013", typeof(InvalidOrder) },
                    { "50014", typeof(BadRequest) },
                    { "50015", typeof(BadRequest) },
                    { "50016", typeof(BadRequest) },
                    { "50017", typeof(BadRequest) },
                    { "50018", typeof(BadRequest) },
                    { "50019", typeof(ExchangeError) },
                    { "50020", typeof(InsufficientFunds) },
                    { "50021", typeof(BadRequest) },
                    { "50022", typeof(ExchangeNotAvailable) },
                    { "50023", typeof(BadSymbol) },
                    { "50024", typeof(BadRequest) },
                    { "50025", typeof(BadRequest) },
                    { "50026", typeof(BadRequest) },
                    { "50027", typeof(BadRequest) },
                    { "50028", typeof(BadRequest) },
                    { "50029", typeof(InvalidOrder) },
                    { "50030", typeof(OrderNotFound) },
                    { "50031", typeof(OrderNotFound) },
                    { "50032", typeof(OrderNotFound) },
                    { "50033", typeof(InvalidOrder) },
                    { "50034", typeof(InvalidOrder) },
                    { "50035", typeof(InvalidOrder) },
                    { "50036", typeof(ExchangeError) },
                    { "50037", typeof(BadRequest) },
                    { "50038", typeof(BadRequest) },
                    { "50039", typeof(BadRequest) },
                    { "50040", typeof(BadSymbol) },
                    { "50041", typeof(ExchangeError) },
                    { "50042", typeof(BadRequest) },
                    { "51000", typeof(BadSymbol) },
                    { "51001", typeof(ExchangeError) },
                    { "51002", typeof(ExchangeError) },
                    { "51003", typeof(ExchangeError) },
                    { "51004", typeof(InsufficientFunds) },
                    { "51005", typeof(InvalidOrder) },
                    { "51006", typeof(InvalidOrder) },
                    { "51007", typeof(BadRequest) },
                    { "51008", typeof(ExchangeError) },
                    { "51009", typeof(InvalidOrder) },
                    { "51010", typeof(InvalidOrder) },
                    { "51011", typeof(InvalidOrder) },
                    { "51012", typeof(InvalidOrder) },
                    { "51013", typeof(InvalidOrder) },
                    { "51014", typeof(InvalidOrder) },
                    { "51015", typeof(InvalidOrder) },
                    { "52000", typeof(BadRequest) },
                    { "52001", typeof(BadRequest) },
                    { "52002", typeof(BadRequest) },
                    { "52003", typeof(BadRequest) },
                    { "52004", typeof(BadRequest) },
                    { "53000", typeof(AccountSuspended) },
                    { "53001", typeof(AccountSuspended) },
                    { "53002", typeof(PermissionDenied) },
                    { "53003", typeof(PermissionDenied) },
                    { "53005", typeof(PermissionDenied) },
                    { "53006", typeof(PermissionDenied) },
                    { "53007", typeof(PermissionDenied) },
                    { "53008", typeof(PermissionDenied) },
                    { "53009", typeof(PermissionDenied) },
                    { "53010", typeof(PermissionDenied) },
                    { "57001", typeof(BadRequest) },
                    { "58001", typeof(BadRequest) },
                    { "59001", typeof(ExchangeError) },
                    { "59002", typeof(ExchangeError) },
                    { "59003", typeof(ExchangeError) },
                    { "59004", typeof(ExchangeError) },
                    { "59005", typeof(PermissionDenied) },
                    { "59006", typeof(ExchangeError) },
                    { "59007", typeof(ExchangeError) },
                    { "59008", typeof(ExchangeError) },
                    { "59009", typeof(ExchangeError) },
                    { "59010", typeof(InsufficientFunds) },
                    { "59011", typeof(ExchangeError) },
                    { "40001", typeof(ExchangeError) },
                    { "40002", typeof(ExchangeError) },
                    { "40003", typeof(ExchangeError) },
                    { "40004", typeof(ExchangeError) },
                    { "40005", typeof(ExchangeError) },
                    { "40006", typeof(PermissionDenied) },
                    { "40007", typeof(BadRequest) },
                    { "40008", typeof(InvalidNonce) },
                    { "40009", typeof(BadRequest) },
                    { "40010", typeof(BadRequest) },
                    { "40011", typeof(BadRequest) },
                    { "40012", typeof(ExchangeError) },
                    { "40013", typeof(ExchangeError) },
                    { "40014", typeof(BadSymbol) },
                    { "40015", typeof(BadSymbol) },
                    { "40016", typeof(InvalidOrder) },
                    { "40017", typeof(InvalidOrder) },
                    { "40018", typeof(InvalidOrder) },
                    { "40019", typeof(ExchangeError) },
                    { "40020", typeof(InvalidOrder) },
                    { "40021", typeof(ExchangeError) },
                    { "40022", typeof(ExchangeError) },
                    { "40023", typeof(ExchangeError) },
                    { "40024", typeof(ExchangeError) },
                    { "40025", typeof(ExchangeError) },
                    { "40026", typeof(ExchangeError) },
                    { "40027", typeof(InsufficientFunds) },
                    { "40028", typeof(PermissionDenied) },
                    { "40029", typeof(InvalidOrder) },
                    { "40030", typeof(InvalidOrder) },
                    { "40031", typeof(InvalidOrder) },
                    { "40032", typeof(InvalidOrder) },
                    { "40033", typeof(InvalidOrder) },
                    { "40034", typeof(BadSymbol) },
                    { "40035", typeof(OrderNotFound) },
                    { "40036", typeof(InvalidOrder) },
                    { "40037", typeof(OrderNotFound) },
                    { "40038", typeof(BadRequest) },
                    { "40039", typeof(BadRequest) },
                    { "40040", typeof(InvalidOrder) },
                    { "40041", typeof(InvalidOrder) },
                    { "40042", typeof(InvalidOrder) },
                    { "40043", typeof(InvalidOrder) },
                    { "40044", typeof(InvalidOrder) },
                    { "40045", typeof(InvalidOrder) },
                    { "40046", typeof(PermissionDenied) },
                    { "40047", typeof(PermissionDenied) },
                    { "40048", typeof(BadRequest) },
                    { "40049", typeof(BadRequest) },
                    { "40050", typeof(InvalidOrder) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "$GM", "GOLDMINER" },
                { "$HERO", "Step Hero" },
                { "$PAC", "PAC" },
                { "BP", "BEYOND" },
                { "GDT", "Gorilla Diamond" },
                { "GLD", "Goldario" },
                { "MVP", "MVP Coin" },
                { "TRU", "Truebit" },
            } },
            { "options", new Dictionary<string, object>() {
                { "defaultNetwork", "ERC20" },
                { "defaultNetworks", new Dictionary<string, object>() {
                    { "USDT", "ERC20" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "ERC20", "ERC20" },
                    { "SOL", "SOL" },
                    { "BTC", "BTC" },
                    { "TRC20", "TRC20" },
                    { "OMNI", "OMNI" },
                    { "XLM", "XLM" },
                    { "EOS", "EOS" },
                    { "NEO", "NEO" },
                    { "BTM", "BTM" },
                    { "BCH", "BCH" },
                    { "LTC", "LTC" },
                    { "BSV", "BSV" },
                    { "XRP", "XRP" },
                    { "PLEX", "PLEX" },
                    { "XCH", "XCH" },
                    { "NEAR", "NEAR" },
                    { "FIO", "FIO" },
                    { "SCRT", "SCRT" },
                    { "IOTX", "IOTX" },
                    { "ALGO", "ALGO" },
                    { "ATOM", "ATOM" },
                    { "DOT", "DOT" },
                    { "ADA", "ADA" },
                    { "DOGE", "DOGE" },
                    { "XYM", "XYM" },
                    { "GLMR", "GLMR" },
                    { "MOVR", "MOVR" },
                    { "ZIL", "ZIL" },
                    { "INJ", "INJ" },
                    { "KSM", "KSM" },
                    { "ZEC", "ZEC" },
                    { "NAS", "NAS" },
                    { "HRC20", "HECO" },
                    { "XDC", "XDC" },
                    { "ONE", "ONE" },
                    { "LAT", "LAT" },
                    { "CSPR", "Casper" },
                    { "ICP", "Computer" },
                    { "XTZ", "XTZ" },
                    { "MINA", "MINA" },
                    { "THETA", "THETA" },
                    { "AKT", "AKT" },
                    { "AR", "AR" },
                    { "CELO", "CELO" },
                    { "FIL", "FIL" },
                    { "NULS", "NULS" },
                    { "ETC", "ETC" },
                    { "DASH", "DASH" },
                    { "DGB", "DGB" },
                    { "BEP2", "BEP2" },
                    { "GRIN", "GRIN" },
                    { "WAVES", "WAVES" },
                    { "ABBC", "ABBC" },
                    { "ACA", "ACA" },
                    { "QTUM", "QTUM" },
                    { "PAC", "PAC" },
                    { "TLOS", "TLOS" },
                    { "KARDIA", "KardiaChain" },
                    { "FUSE", "FUSE" },
                    { "TRC10", "TRC10" },
                    { "FIRO", "FIRO" },
                    { "FTM", "Fantom" },
                    { "EVER", "EVER" },
                    { "KAVA", "KAVA" },
                    { "HYDRA", "HYDRA" },
                    { "PLCU", "PLCU" },
                    { "BRISE", "BRISE" },
                    { "OPTIMISM", "OPTIMISM" },
                    { "REEF", "REEF" },
                    { "SYS", "SYS" },
                    { "VITE", "VITE" },
                    { "STX", "STX" },
                    { "SXP", "SXP" },
                    { "BITCI", "BITCI" },
                    { "XRD", "XRD" },
                    { "ASTR", "ASTAR" },
                    { "ZEN", "HORIZEN" },
                    { "LTO", "LTO" },
                    { "ETHW", "ETHW" },
                    { "ETHF", "ETHF" },
                    { "IOST", "IOST" },
                    { "APT", "APT" },
                    { "ONT", "ONT" },
                    { "EVMOS", "EVMOS" },
                    { "XMR", "XMR" },
                    { "OASYS", "OAS" },
                    { "OSMO", "OSMO" },
                    { "OMAX", "OMAX Chain" },
                    { "DESO", "DESO" },
                    { "BFIC", "BFIC" },
                    { "OHO", "OHO" },
                    { "CS", "CS" },
                    { "CHEQ", "CHEQ" },
                    { "NODL", "NODL" },
                    { "NEM", "XEM" },
                    { "FRA", "FRA" },
                    { "ERGO", "ERG" },
                } },
                { "defaultType", "spot" },
                { "fetchBalance", new Dictionary<string, object>() {
                    { "type", "spot" },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "spot" },
                    { "swap", "swap" },
                } },
                { "createMarketBuyOrderRequiresPrice", true },
                { "brokerId", "CCXTxBitmart000" },
            } },
        });
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetSystemTime(parameters);
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"c4e5e5b7-fe9f-4191-89f7-53f6c5bf9030",
        //         "data":{
        //             "server_time":1599843709578
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.safeInteger(data, "server_time");
    }

    public async override Task<object> fetchStatus(object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchStatus
        * @description the latest known information on the availability of the exchange API
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object options = this.safeValue(this.options, "fetchStatus", new Dictionary<string, object>() {});
        object defaultType = this.safeString(this.options, "defaultType");
        object type = this.safeString(options, "type", defaultType);
        type = this.safeString(parameters, "type", type);
        parameters = this.omit(parameters, "type");
        object response = await this.publicGetSystemService(parameters);
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "1d3f28b0-763e-4f78-90c4-5e3ad19dc595",
        //         "data": {
        //           "service": [
        //             {
        //               "title": "Spot API Stop",
        //               "service_type": "spot",
        //               "status": 2,
        //               "start_time": 1648639069125,
        //               "end_time": 1648639069125
        //             },
        //             {
        //               "title": "Contract API Stop",
        //               "service_type": "contract",
        //               "status": 2,
        //               "start_time": 1648639069125,
        //               "end_time": 1648639069125
        //             }
        //           ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object services = this.safeValue(data, "service", new List<object>() {});
        object servicesByType = this.indexBy(services, "service_type");
        if (isTrue(isEqual(type, "swap")))
        {
            type = "contract";
        }
        object service = this.safeValue(servicesByType, type);
        object status = null;
        object eta = null;
        if (isTrue(!isEqual(service, null)))
        {
            object statusCode = this.safeInteger(service, "status");
            if (isTrue(isEqual(statusCode, 2)))
            {
                status = "ok";
            } else
            {
                status = "maintenance";
                eta = this.safeInteger(service, "end_time");
            }
        }
        return new Dictionary<string, object>() {
            { "status", status },
            { "updated", null },
            { "eta", eta },
            { "url", null },
            { "info", response },
        };
    }

    public async virtual Task<object> fetchSpotMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetSpotV1SymbolsDetails(parameters);
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"a67c9146-086d-4d3f-9897-5636a9bb26e1",
        //         "data":{
        //             "symbols":[
        //               {
        //                  "symbol": "BTC_USDT",
        //                  "symbol_id": 53,
        //                  "base_currency": "BTC",
        //                  "quote_currency": "USDT",
        //                  "base_min_size": "0.000010000000000000000000000000",
        //                  "base_max_size": "100000000.000000000000000000000000000000",
        //                  "price_min_precision": -1,
        //                  "price_max_precision": 2,
        //                  "quote_increment": "0.00001", // Api docs says "The minimum order quantity is also the minimum order quantity increment", however I think they mistakenly use the term 'order quantity'
        //                  "expiration": "NA",
        //                  "min_buy_amount": "5.000000000000000000000000000000",
        //                  "min_sell_amount": "5.000000000000000000000000000000",
        //                  "trade_status": "trading"
        //               },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object symbols = this.safeValue(data, "symbols", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object market = getValue(symbols, i);
            object id = this.safeString(market, "symbol");
            object numericId = this.safeInteger(market, "symbol_id");
            object baseId = this.safeString(market, "base_currency");
            object quoteId = this.safeString(market, "quote_currency");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object symbol = add(add(bs, "/"), quote);
            object minBuyCost = this.safeString(market, "min_buy_amount");
            object minSellCost = this.safeString(market, "min_sell_amount");
            object minCost = Precise.stringMax(minBuyCost, minSellCost);
            object baseMinSize = this.safeNumber(market, "base_min_size");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "numericId", numericId },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", true },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", baseMinSize },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "price_max_precision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", baseMinSize },
                        { "max", this.safeNumber(market, "base_max_size") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.parseNumber(minCost) },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", market },
            });
        }
        return result;
    }

    public async virtual Task<object> fetchContractMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetContractPublicDetails(parameters);
        //
        //     {
        //       "code": 1000,
        //       "message": "Ok",
        //       "trace": "9b92a999-9463-4c96-91a4-93ad1cad0d72",
        //       "data": {
        //       "symbols": [{
        //             "symbol": "BTCUSDT",
        //             "product_type": 1,
        //             "open_timestamp": 1594080000,
        //             "expire_timestamp": 0,
        //             "settle_timestamp": 0,
        //             "base_currency": "BTC",
        //             "quote_currency": "USDT",
        //             "last_price": "23920",
        //             "volume_24h": "18969368",
        //             "turnover_24h": "458933659.7858",
        //             "index_price": "23945.25191635",
        //             "index_name": "BTCUSDT",
        //             "contract_size": "0.001",
        //             "min_leverage": "1",
        //             "max_leverage": "100",
        //             "price_precision": "0.1",
        //             "vol_precision": "1",
        //             "max_volume": "500000",
        //             "min_volume": "1"
        //           },
        //           ...
        //         ]
        //       }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object symbols = this.safeValue(data, "symbols", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object market = getValue(symbols, i);
            object id = this.safeString(market, "symbol");
            object baseId = this.safeString(market, "base_currency");
            object quoteId = this.safeString(market, "quote_currency");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object settleId = "USDT"; // this is bitmart's ID for usdt
            object settle = this.safeCurrencyCode(settleId);
            object symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
            object productType = this.safeInteger(market, "product_type");
            object isSwap = (isEqual(productType, 1));
            object isFutures = (isEqual(productType, 2));
            object expiry = this.safeInteger(market, "expire_timestamp");
            if (isTrue(!isTrue(isFutures) && isTrue((isEqual(expiry, 0)))))
            {
                expiry = null;
            }
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "numericId", null },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", ((bool) isTrue(isSwap)) ? "swap" : "future" },
                { "spot", false },
                { "margin", false },
                { "swap", isSwap },
                { "future", isFutures },
                { "option", false },
                { "active", true },
                { "contract", true },
                { "linear", true },
                { "inverse", false },
                { "contractSize", this.safeNumber(market, "contract_size") },
                { "expiry", expiry },
                { "expiryDatetime", this.iso8601(expiry) },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.safeNumber(market, "vol_precision") },
                    { "price", this.safeNumber(market, "price_precision") },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_leverage") },
                        { "max", this.safeNumber(market, "max_leverage") },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_volume") },
                        { "max", this.safeNumber(market, "max_volume") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", this.safeInteger(market, "open_timestamp") },
                { "info", market },
            });
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchMarkets
        * @description retrieves data on all markets for bitmart
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object spot = await this.fetchSpotMarkets(parameters);
        object contract = await this.fetchContractMarkets(parameters);
        return this.arrayConcat(spot, contract);
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetSpotV1Currencies(parameters);
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"8c768b3c-025f-413f-bec5-6d6411d46883",
        //         "data":{
        //             "currencies":[
        //                 {"currency":"MATIC","name":"Matic Network","withdraw_enabled":true,"deposit_enabled":true},
        //                 {"currency":"KTN","name":"Kasoutuuka News","withdraw_enabled":true,"deposit_enabled":false},
        //                 {"currency":"BRT","name":"Berith","withdraw_enabled":true,"deposit_enabled":true},
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object currencies = this.safeValue(data, "currencies", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currency = getValue(currencies, i);
            object id = this.safeString(currency, "id");
            object code = this.safeCurrencyCode(id);
            object name = this.safeString(currency, "name");
            object withdrawEnabled = this.safeValue(currency, "withdraw_enabled");
            object depositEnabled = this.safeValue(currency, "deposit_enabled");
            object active = isTrue(withdrawEnabled) && isTrue(depositEnabled);
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "code", code },
                { "name", name },
                { "info", currency },
                { "active", active },
                { "deposit", depositEnabled },
                { "withdraw", withdrawEnabled },
                { "fee", null },
                { "precision", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
            };
        }
        return result;
    }

    public async override Task<object> fetchTransactionFee(object code, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchTransactionFee
        * @deprecated
        * @description please use fetchDepositWithdrawFee instead
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.privateGetAccountV1WithdrawCharge(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": "1000",
        //         "trace": "3ecc0adf-91bd-4de7-aca1-886c1122f54f",
        //         "data": {
        //             "today_available_withdraw_BTC": "100.0000",
        //             "min_withdraw": "0.005",
        //             "withdraw_precision": "8",
        //             "withdraw_fee": "0.000500000000000000000000000000"
        //         }
        //     }
        //
        object data = getValue(response, "data");
        object withdrawFees = new Dictionary<string, object>() {};
        ((IDictionary<string,object>)withdrawFees)[(string)code] = this.safeNumber(data, "withdraw_fee");
        return new Dictionary<string, object>() {
            { "info", response },
            { "withdraw", withdrawFees },
            { "deposit", new Dictionary<string, object>() {} },
        };
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //    {
        //        "today_available_withdraw_BTC": "100.0000",
        //        "min_withdraw": "0.005",
        //        "withdraw_precision": "8",
        //        "withdraw_fee": "0.000500000000000000000000000000"
        //    }
        //
        return new Dictionary<string, object>() {
            { "info", fee },
            { "withdraw", new Dictionary<string, object>() {
                { "fee", this.safeNumber(fee, "withdraw_fee") },
                { "percentage", null },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
    }

    public async override Task<object> fetchDepositWithdrawFee(object code, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchDepositWithdrawFee
        * @description fetch the fee for deposits and withdrawals
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.privateGetAccountV1WithdrawCharge(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": "1000",
        //         "trace": "3ecc0adf-91bd-4de7-aca1-886c1122f54f",
        //         "data": {
        //             "today_available_withdraw_BTC": "100.0000",
        //             "min_withdraw": "0.005",
        //             "withdraw_precision": "8",
        //             "withdraw_fee": "0.000500000000000000000000000000"
        //         }
        //     }
        //
        object data = getValue(response, "data");
        return ((object)this.parseDepositWithdrawFee(data));
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // spot (REST)
        //
        //      {
        //          "symbol": "SOLAR_USDT",
        //          "last_price": "0.020342",
        //          "quote_volume_24h": "56817.811802",
        //          "base_volume_24h": "2172060",
        //          "high_24h": "0.256000",
        //          "low_24h": "0.016980",
        //          "open_24h": "0.022309",
        //          "close_24h": "0.020342",
        //          "best_ask": "0.020389",
        //          "best_ask_size": "339.000000000000000000000000000000",
        //          "best_bid": "0.020342",
        //          "best_bid_size": "3369.000000000000000000000000000000",
        //          "fluctuation": "-0.0882",
        //          "url": "https://www.bitmart.com/trade?symbol=SOLAR_USDT",
        //          "timestamp": 1667403439367
        //      }
        //
        // spot (WS)
        //      {
        //          "symbol":"BTC_USDT",
        //          "last_price":"146.24",
        //          "open_24h":"147.17",
        //          "high_24h":"147.48",
        //          "low_24h":"143.88",
        //          "base_volume_24h":"117387.58", // NOT base, but quote currency!!!
        //          "s_t": 1610936002
        //      }
        //
        // swap
        //
        //      {
        //          "contract_symbol":"DOGEUSDT",
        //          "last_price":"0.130340",
        //          "index_price":"0.13048245",
        //          "last_funding_rate":"0.00002287",
        //          "price_change_percent_24h":"-2.074",
        //          "volume_24h":"113705028.59482228",
        //          "url":"https://futures.bitmart.com/en?symbol=DOGEUSDT",
        //          "high_price":"0.134520",
        //          "low_price":"0.128570",
        //          "legal_coin_price":"0.1302699"
        //      }
        //
        object timestamp = this.safeInteger(ticker, "timestamp");
        if (isTrue(isEqual(timestamp, null)))
        {
            // ticker from WS has a different field (in seconds)
            timestamp = this.safeIntegerProduct(ticker, "s_t", 1000);
        }
        object marketId = this.safeString2(ticker, "symbol", "contract_symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object last = this.safeString2(ticker, "close_24h", "last_price");
        object percentage = this.safeString(ticker, "price_change_percent_24h");
        if (isTrue(isEqual(percentage, null)))
        {
            object percentageRaw = this.safeString(ticker, "fluctuation");
            if (isTrue(isTrue((!isEqual(percentageRaw, null))) && isTrue((!isEqual(percentageRaw, "0")))))
            {
                object direction = getValue(percentageRaw, 0);
                percentage = add(direction, Precise.stringMul(((string)percentageRaw).Replace((string)direction, (string)""), "100"));
            } else if (isTrue(isEqual(percentageRaw, "0")))
            {
                percentage = "0";
            }
        }
        object baseVolume = this.safeString(ticker, "base_volume_24h");
        object quoteVolume = this.safeString(ticker, "quote_volume_24h");
        if (isTrue(isEqual(quoteVolume, null)))
        {
            if (isTrue(isEqual(baseVolume, null)))
            {
                // this is swap
                quoteVolume = this.safeString(ticker, "volume_24h", quoteVolume);
            } else
            {
                // this is a ticker from websockets
                // contrary to name and documentation, base_volume_24h is actually the quote volume
                quoteVolume = baseVolume;
                baseVolume = null;
            }
        }
        object average = this.safeString2(ticker, "avg_price", "index_price");
        object high = this.safeString2(ticker, "high_24h", "high_price");
        object low = this.safeString2(ticker, "low_24h", "low_price");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", high },
            { "low", low },
            { "bid", this.safeString(ticker, "best_bid") },
            { "bidVolume", this.safeString(ticker, "best_bid_size") },
            { "ask", this.safeString(ticker, "best_ask") },
            { "askVolume", this.safeString(ticker, "best_ask_size") },
            { "vwap", null },
            { "open", this.safeString(ticker, "open_24h") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", percentage },
            { "average", average },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            ((IDictionary<string,object>)request)["contract_symbol"] = getValue(market, "id");
            response = await this.publicGetContractV1Tickers(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "spot")))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.publicGetSpotV1Ticker(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchTicker() does not support "), getValue(market, "type")), " markets, only spot and swap markets are accepted")) ;
        }
        //
        // spot
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"6aa5b923-2f57-46e3-876d-feca190e0b82",
        //         "data":{
        //             "tickers":[
        //                 {
        //                     "symbol":"ETH_BTC",
        //                     "last_price":"0.036037",
        //                     "quote_volume_24h":"4380.6660000000",
        //                     "base_volume_24h":"159.3582006712",
        //                     "high_24h":"0.036972",
        //                     "low_24h":"0.035524",
        //                     "open_24h":"0.036561",
        //                     "close_24h":"0.036037",
        //                     "best_ask":"0.036077",
        //                     "best_ask_size":"9.9500",
        //                     "best_bid":"0.035983",
        //                     "best_bid_size":"4.2792",
        //                     "fluctuation":"-0.0143",
        //                     "url":"https://www.bitmart.com/trade?symbol=ETH_BTC"
        //                 }
        //             ]
        //         }
        //     }
        //
        // swap
        //
        //      {
        //          "message":"OK",
        //          "code":1000,
        //          "trace":"4a0ebceb-d3f7-45a3-8feb-f61e230e24cd",
        //          "data":{
        //              "tickers":[
        //                  {
        //                      "contract_symbol":"DOGEUSDT",
        //                      "last_price":"0.130180",
        //                      "index_price":"0.13028635",
        //                      "last_funding_rate":"0.00002025",
        //                      "price_change_percent_24h":"-2.326",
        //                      "volume_24h":"116789313.01797258",
        //                      "url":"https://futures.bitmart.com/en?symbol=DOGEUSDT",
        //                      "high_price":"0.134520",
        //                      "low_price":"0.128570",
        //                      "legal_coin_price":"0.13017401"
        //                  }
        //              ]
        //          }
        //      }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object tickers = this.safeValue(data, "tickers", new List<object>() {});
        // fails in naming for contract tickers 'contract_symbol'
        object tickersById = null;
        if (isTrue(getValue(market, "spot")))
        {
            tickersById = this.indexBy(tickers, "symbol");
        } else if (isTrue(getValue(market, "swap")))
        {
            tickersById = this.indexBy(tickers, "contract_symbol");
        }
        object ticker = this.safeDict(tickersById, getValue(market, "id"));
        return this.parseTicker(ticker, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://developer-pro.bitmart.com/en/spot/#get-ticker-of-all-pairs-v2
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object type = null;
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = this.safeValue(symbols, 0);
            market = this.market(symbol);
        }
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(type, "spot")))
        {
            response = await this.publicGetSpotV2Ticker(parameters);
        } else if (isTrue(isEqual(type, "swap")))
        {
            response = await this.publicGetContractV1Tickers(parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchTickers() does not support "), type), " markets, only spot and swap markets are accepted")) ;
        }
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object tickers = this.safeValue(data, "tickers", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(tickers)); postFixIncrement(ref i))
        {
            object ticker = this.parseTicker(getValue(tickers, i));
            object symbol = getValue(ticker, "symbol");
            ((IDictionary<string,object>)result)[(string)symbol] = ticker;
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://developer-pro.bitmart.com/en/spot/#get-depth-v3
        * @see https://developer-pro.bitmart.com/en/futures/#get-market-depth
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit; // default 35, max 50
            }
            response = await this.publicGetSpotQuotationV3Books(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "swap")))
        {
            response = await this.publicGetContractPublicDepth(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOrderBook() does not support "), getValue(market, "type")), " markets, only spot and swap markets are accepted")) ;
        }
        //
        // spot
        //
        //     {
        //         "code": 1000,
        //         "message": "success",
        //         "data": {
        //             "ts": "1695264191808",
        //             "symbol": "BTC_USDT",
        //             "asks": [
        //                 ["26942.57","0.06492"],
        //                 ["26942.73","0.05447"],
        //                 ["26943.00","0.07154"]
        //             ],
        //             "bids": [
        //                 ["26942.45","0.00074"],
        //                 ["26941.53","0.00371"],
        //                 ["26940.94","0.08992"]
        //             ]
        //         },
        //         "trace": "430a7f69581d4258a8e4b424dfb10782.73.16952341919017619"
        //     }
        //
        // swap
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": {
        //             "asks": [
        //                 ["26938.3","3499","3499"],
        //                 ["26938.5","14702","18201"],
        //                 ["26938.6","20457","38658"]
        //             ],
        //             "bids": [
        //                 ["26938.2","20","20"],
        //                 ["26937.9","1913","1933"],
        //                 ["26937.8","2588","4521"]
        //             ],
        //             "timestamp": 1695264383999,
        //             "symbol": "BTCUSDT"
        //         },
        //         "trace": "4cad855074664097ac6ba5258c47305d.72.16952643834721135"
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger2(data, "ts", "timestamp");
        return this.parseOrderBook(data, getValue(market, "symbol"), timestamp);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public fetchTrades spot ( amount = count * price )
        //
        //    {
        //        "amount": "818.94",
        //        "order_time": "1637601839035",    // ETH/USDT
        //        "price": "4221.99",
        //        "count": "0.19397",
        //        "type": "buy"
        //    }
        //
        // spot: fetchMyTrades
        //
        //    {
        //        "tradeId":"182342999769370687",
        //        "orderId":"183270218784142990",
        //        "clientOrderId":"183270218784142990",
        //        "symbol":"ADA_USDT",
        //        "side":"buy",
        //        "orderMode":"spot",
        //        "type":"market",
        //        "price":"0.245948",
        //        "size":"20.71",
        //        "notional":"5.09358308",
        //        "fee":"0.00509358",
        //        "feeCoinName":"USDT",
        //        "tradeRole":"taker",
        //        "createTime":1695658457836,
        //    }
        //
        // swap: fetchMyTrades
        //
        //    {
        //        "order_id": "230930336848609",
        //        "trade_id": "6212604014",
        //        "symbol": "BTCUSDT",
        //        "side": 3,
        //        "price": "26910.4",
        //        "vol": "1",
        //        "exec_type": "Taker",
        //        "profit": false,
        //        "create_time": 1695961596692,
        //        "realised_profit": "-0.0003",
        //        "paid_fees": "0.01614624"
        //    }
        //
        // ws swap
        //
        //    {
        //        'fee': '-0.000044502',
        //        'feeCcy': 'USDT',
        //        'fillPrice': '74.17',
        //        'fillQty': '1',
        //        'lastTradeID': 6802340762
        //    }
        //
        object timestamp = this.safeIntegerN(trade, new List<object>() {"order_time", "createTime", "create_time"});
        object isPublicTrade = (inOp(trade, "order_time"));
        object amount = null;
        object cost = null;
        object type = null;
        object side = null;
        if (isTrue(isPublicTrade))
        {
            amount = this.safeString(trade, "count");
            cost = this.safeString(trade, "amount");
            side = this.safeString(trade, "type");
        } else
        {
            amount = this.safeStringN(trade, new List<object>() {"size", "vol", "fillQty"});
            cost = this.safeString(trade, "notional");
            type = this.safeString(trade, "type");
            side = this.parseOrderSide(this.safeString(trade, "side"));
        }
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market);
        object feeCostString = this.safeString2(trade, "fee", "paid_fees");
        object fee = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCurrencyId = this.safeString(trade, "feeCoinName");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            if (isTrue(isEqual(feeCurrencyCode, null)))
            {
                feeCurrencyCode = ((bool) isTrue((isEqual(side, "buy")))) ? getValue(market, "base") : getValue(market, "quote");
            }
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", feeCurrencyCode },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeStringN(trade, new List<object>() {"tradeId", "trade_id", "lastTradeID"}) },
            { "order", this.safeString2(trade, "orderId", "order_id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "side", side },
            { "price", this.safeString2(trade, "price", "fillPrice") },
            { "amount", amount },
            { "cost", cost },
            { "takerOrMaker", this.safeStringLower2(trade, "tradeRole", "exec_type") },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchTrades() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetSpotV1SymbolsTrades(this.extend(request, parameters));
        //
        // spot
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"222d74c0-8f6d-49d9-8e1b-98118c50eeba",
        //         "data":{
        //             "trades":[
        //                 {
        //                     "amount":"0.005703",
        //                     "order_time":1599652045394,
        //                     "price":"0.034029",
        //                     "count":"0.1676",
        //                     "type":"sell"
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object trades = this.safeList(data, "trades", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        // spot
        //    [
        //        "1699512060", // timestamp
        //        "36746.49", // open
        //        "36758.71", // high
        //        "36736.13", // low
        //        "36755.99", // close
        //        "2.83965", // base volume
        //        "104353.57" // quote volume
        //    ]
        //
        // swap
        //    {
        //        "low_price": "20090.3",
        //        "high_price": "20095.5",
        //        "open_price": "20092.6",
        //        "close_price": "20091.4",
        //        "volume": "8748",
        //        "timestamp": 1665002281
        //    }
        //
        // ws
        //    [
        //        1631056350, // timestamp
        //        "46532.83", // open
        //        "46555.71", // high
        //        "46511.41", // low
        //        "46555.71", // close
        //        "0.25", // volume
        //    ]
        //
        // ws swap
        //    {
        //        "symbol":"BTCUSDT",
        //        "o":"146.24",
        //        "h":"146.24",
        //        "l":"146.24",
        //        "c":"146.24",
        //        "v":"146"
        //    }
        //
        if (isTrue(((ohlcv is IList<object>) || (ohlcv.GetType().IsGenericType && ohlcv.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            return new List<object> {this.safeTimestamp(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
        } else
        {
            return new List<object> {this.safeTimestamp2(ohlcv, "timestamp", "ts"), this.safeNumber2(ohlcv, "open_price", "o"), this.safeNumber2(ohlcv, "high_price", "h"), this.safeNumber2(ohlcv, "low_price", "l"), this.safeNumber2(ohlcv, "close_price", "c"), this.safeNumber2(ohlcv, "volume", "v")};
        }
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://developer-pro.bitmart.com/en/spot/#get-history-k-line-v3
        * @see https://developer-pro.bitmart.com/en/futures/#get-k-line
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp of the latest candle in ms
        * @param {boolean} [params.paginate] *spot only* default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate", false);
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, 200);
        }
        object market = this.market(symbol);
        object duration = this.parseTimeframe(timeframe);
        object parsedTimeframe = this.safeInteger(this.timeframes, timeframe);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(parsedTimeframe, null)))
        {
            ((IDictionary<string,object>)request)["step"] = parsedTimeframe;
        } else
        {
            ((IDictionary<string,object>)request)["step"] = timeframe;
        }
        if (isTrue(getValue(market, "spot")))
        {
            var requestparametersVariable = this.handleUntilOption("before", request, parameters, 0.001);
            request = ((IList<object>)requestparametersVariable)[0];
            parameters = ((IList<object>)requestparametersVariable)[1];
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["after"] = subtract(this.parseToInt((divide(since, 1000))), 1);
            }
        } else
        {
            object maxLimit = 1200;
            if (isTrue(isEqual(limit, null)))
            {
                limit = maxLimit;
            }
            limit = mathMin(maxLimit, limit);
            object now = this.parseToInt(divide(this.milliseconds(), 1000));
            if (isTrue(isEqual(since, null)))
            {
                object start = subtract(now, multiply(limit, duration));
                ((IDictionary<string,object>)request)["start_time"] = start;
                ((IDictionary<string,object>)request)["end_time"] = now;
            } else
            {
                object start = subtract(this.parseToInt((divide(since, 1000))), 1);
                object end = this.sum(start, multiply(limit, duration));
                ((IDictionary<string,object>)request)["start_time"] = start;
                ((IDictionary<string,object>)request)["end_time"] = mathMin(end, now);
            }
            var requestparametersVariable = this.handleUntilOption("end_time", request, parameters, 0.001);
            request = ((IList<object>)requestparametersVariable)[0];
            parameters = ((IList<object>)requestparametersVariable)[1];
        }
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.publicGetContractPublicKline(this.extend(request, parameters));
        } else
        {
            response = await this.publicGetSpotQuotationV3Klines(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "code": 1000,
        //         "message": "success",
        //         "data": [
        //             ["1699512060","36746.49","36758.71","36736.13","36755.99","2.83965","104353.57"],
        //             ["1699512120","36756.00","36758.70","36737.14","36737.63","1.96070","72047.10"],
        //             ["1699512180","36737.63","36740.45","36737.62","36740.44","0.63194","23217.62"]
        //         ],
        //         "trace": "6591fc7b508845359d5fa442e3b3a4fb.72.16995122398750695"
        //     }
        //
        // swap
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": [
        //             {
        //                 "low_price": "20090.3",
        //                 "high_price": "20095.5",
        //                 "open_price": "20092.6",
        //                 "close_price": "20091.4",
        //                 "volume": "8748",
        //                 "timestamp": 1665002281
        //             },
        //             ...
        //         ],
        //         "trace": "96c989db-e0f5-46f5-bba6-60cfcbde699b"
        //     }
        //
        object ohlcv = this.safeList(response, "data", new List<object>() {});
        return this.parseOHLCVs(ohlcv, market, timeframe, since, limit);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchMyTrades
        * @see https://developer-pro.bitmart.com/en/spot/#account-trade-list-v4-signed
        * @see https://developer-pro.bitmart.com/en/futures/#get-order-trade-keyed
        * @description fetch all trades made by the user
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch trades for
        * @param {boolean} [params.marginMode] *spot* whether to fetch trades for margin orders or spot orders, defaults to spot orders (only isolated margin orders are supported)
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object type = null;
        object response = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object until = this.safeIntegerN(parameters, new List<object>() {"until", "endTime", "end_time"});
        parameters = this.omit(parameters, new List<object>() {"until"});
        if (isTrue(isEqual(type, "spot")))
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchMyTrades", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                ((IDictionary<string,object>)request)["orderMode"] = "iso_margin";
            }
            object options = this.safeValue(this.options, "fetchMyTrades", new Dictionary<string, object>() {});
            object defaultLimit = this.safeInteger(options, "limit", 200);
            if (isTrue(isEqual(limit, null)))
            {
                limit = defaultLimit;
            }
            ((IDictionary<string,object>)request)["limit"] = limit;
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["startTime"] = since;
            }
            if (isTrue(!isEqual(until, null)))
            {
                ((IDictionary<string,object>)request)["endTime"] = until;
            }
            response = await this.privatePostSpotV4QueryTrades(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "swap")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
            }
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["start_time"] = since;
            }
            if (isTrue(!isEqual(until, null)))
            {
                ((IDictionary<string,object>)request)["end_time"] = until;
            }
            response = await this.privateGetContractPrivateTrades(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchMyTrades() does not support "), type), " orders, only spot and swap orders are accepted")) ;
        }
        //
        // spot
        //
        //    {
        //        "code":1000,
        //        "message":"success",
        //        "data":[
        //           {
        //              "tradeId":"182342999769370687",
        //              "orderId":"183270218784142990",
        //              "clientOrderId":"183270218784142990",
        //              "symbol":"ADA_USDT",
        //              "side":"buy",
        //              "orderMode":"spot",
        //              "type":"market",
        //              "price":"0.245948",
        //              "size":"20.71",
        //              "notional":"5.09358308",
        //              "fee":"0.00509358",
        //              "feeCoinName":"USDT",
        //              "tradeRole":"taker",
        //              "createTime":1695658457836,
        //              "updateTime":1695658457836
        //           }
        //        ],
        //        "trace":"fbaee9e0e2f5442fba5b3262fc86b0ac.65.16956593456523085"
        //    }
        //
        // swap
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": [
        //             {
        //                 "order_id": "230930336848609",
        //                 "trade_id": "6212604014",
        //                 "symbol": "BTCUSDT",
        //                 "side": 3,
        //                 "price": "26910.4",
        //                 "vol": "1",
        //                 "exec_type": "Taker",
        //                 "profit": false,
        //                 "create_time": 1695961596692,
        //                 "realised_profit": "-0.0003",
        //                 "paid_fees": "0.01614624"
        //             },
        //         ],
        //         "trace": "4cad855074634097ac6ba5257c47305d.62.16959616054873723"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchOrderTrades
        * @see https://developer-pro.bitmart.com/en/spot/#order-trade-list-v4-signed
        * @description fetch all the trades made from a single order
        * @param {string} id order id
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        object response = await this.privatePostSpotV4QueryOrderTrades(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, null, since, limit);
    }

    public virtual object customParseBalance(object response, object marketType)
    {
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object wallet = null;
        if (isTrue(isEqual(marketType, "swap")))
        {
            wallet = this.safeValue(response, "data", new List<object>() {});
        } else if (isTrue(isEqual(marketType, "margin")))
        {
            wallet = this.safeValue(data, "symbols", new List<object>() {});
        } else
        {
            wallet = this.safeValue(data, "wallet", new List<object>() {});
        }
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        if (isTrue(isEqual(marketType, "margin")))
        {
            for (object i = 0; isLessThan(i, getArrayLength(wallet)); postFixIncrement(ref i))
            {
                object entry = getValue(wallet, i);
                object marketId = this.safeString(entry, "symbol");
                object symbol = this.safeSymbol(marketId, null, "_");
                object bs = this.safeValue(entry, "base", new Dictionary<string, object>() {});
                object quote = this.safeValue(entry, "quote", new Dictionary<string, object>() {});
                object baseCode = this.safeCurrencyCode(this.safeString(bs, "currency"));
                object quoteCode = this.safeCurrencyCode(this.safeString(quote, "currency"));
                object subResult = new Dictionary<string, object>() {};
                ((IDictionary<string,object>)subResult)[(string)baseCode] = this.parseBalanceHelper(bs);
                ((IDictionary<string,object>)subResult)[(string)quoteCode] = this.parseBalanceHelper(quote);
                ((IDictionary<string,object>)result)[(string)symbol] = this.safeBalance(subResult);
            }
            return result;
        } else
        {
            for (object i = 0; isLessThan(i, getArrayLength(wallet)); postFixIncrement(ref i))
            {
                object balance = getValue(wallet, i);
                object currencyId = this.safeString2(balance, "id", "currency");
                currencyId = this.safeString(balance, "coin_code", currencyId);
                object code = this.safeCurrencyCode(currencyId);
                object account = this.account();
                ((IDictionary<string,object>)account)["free"] = this.safeString2(balance, "available", "available_balance");
                ((IDictionary<string,object>)account)["used"] = this.safeString2(balance, "frozen", "frozen_balance");
                ((IDictionary<string,object>)result)[(string)code] = account;
            }
            return this.safeBalance(result);
        }
    }

    public virtual object parseBalanceHelper(object entry)
    {
        object account = this.account();
        ((IDictionary<string,object>)account)["used"] = this.safeString(entry, "frozen");
        ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "available");
        ((IDictionary<string,object>)account)["total"] = this.safeString(entry, "total_asset");
        object debt = this.safeString(entry, "borrow_unpaid");
        object interest = this.safeString(entry, "interest_unpaid");
        ((IDictionary<string,object>)account)["debt"] = Precise.stringAdd(debt, interest);
        return account;
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://developer-pro.bitmart.com/en/spot/#get-spot-wallet-balance
        * @see https://developer-pro.bitmart.com/en/futures/#get-contract-assets-detail
        * @see https://developer-pro.bitmart.com/en/spot/#get-account-balance
        * @see https://developer-pro.bitmart.com/en/spot/#get-margin-account-details-isolated
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object marginMode = this.safeString(parameters, "marginMode");
        object isMargin = this.safeBool(parameters, "margin", false);
        parameters = this.omit(parameters, new List<object>() {"margin", "marginMode"});
        if (isTrue(isTrue(!isEqual(marginMode, null)) || isTrue(isMargin)))
        {
            marketType = "margin";
        }
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.privateGetSpotV1Wallet(parameters);
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            response = await this.privateGetContractPrivateAssetsDetail(parameters);
        } else if (isTrue(isEqual(marketType, "account")))
        {
            response = await this.privateGetAccountV1Wallet(parameters);
        } else if (isTrue(isEqual(marketType, "margin")))
        {
            response = await this.privateGetSpotV1MarginIsolatedAccount(parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchBalance() does not support "), marketType), " markets, only spot, swap and account and margin markets are accepted")) ;
        }
        //
        // spot
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"39069916-72f9-44c7-acde-2ad5afd21cad",
        //         "data":{
        //             "wallet":[
        //                 {"id":"BTC","name":"Bitcoin","available":"0.00000062","frozen":"0.00000000"},
        //                 {"id":"ETH","name":"Ethereum","available":"0.00002277","frozen":"0.00000000"},
        //                 {"id":"BMX","name":"BitMart Token","available":"0.00000000","frozen":"0.00000000"}
        //             ]
        //         }
        //     }
        //
        // account
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"5c3b7fc7-93b2-49ef-bb59-7fdc56915b59",
        //         "data":{
        //             "wallet":[
        //                 {"currency":"BTC","name":"Bitcoin","available":"0.00000062","frozen":"0.00000000"},
        //                 {"currency":"ETH","name":"Ethereum","available":"0.00002277","frozen":"0.00000000"}
        //             ]
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": [
        //             {
        //                 "currency": "USDT",
        //                 "available_balance": "0",
        //                 "frozen_balance": "0",
        //                 "unrealized": "0",
        //                 "equity": "0",
        //                 "position_deposit": "0"
        //             },
        //             ...
        //         ],
        //         "trace": "f9da3a39-cf45-42e7-914d-294f565dfc33"
        //     }
        //
        // margin
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "61dd6ab265c04064b72d8bc9b205f741.71.16701055600915302",
        //         "data": {
        //             "symbols": [
        //                 {
        //                     "symbol": "BTC_USDT",
        //                     "risk_rate": "999.00",
        //                     "risk_level": "1",
        //                     "buy_enabled": false,
        //                     "sell_enabled": false,
        //                     "liquidate_price": null,
        //                     "liquidate_rate": "1.15",
        //                     "base": {
        //                         "currency": "BTC",
        //                         "borrow_enabled": true,
        //                         "borrowed": "0.00000000",
        //                         "available": "0.00000000",
        //                         "frozen": "0.00000000",
        //                         "net_asset": "0.00000000",
        //                         "net_assetBTC": "0.00000000",
        //                         "total_asset": "0.00000000",
        //                         "borrow_unpaid": "0.00000000",
        //                         "interest_unpaid": "0.00000000"
        //                     },
        //                     "quote": {
        //                         "currency": "USDT",
        //                         "borrow_enabled": true,
        //                         "borrowed": "0.00000000",
        //                         "available": "20.00000000",
        //                         "frozen": "0.00000000",
        //                         "net_asset": "20.00000000",
        //                         "net_assetBTC": "0.00118008",
        //                         "total_asset": "20.00000000",
        //                         "borrow_unpaid": "0.00000000",
        //                         "interest_unpaid": "0.00000000"
        //                     }
        //                 }
        //             ]
        //         }
        //     }
        //
        return this.customParseBalance(response, marketType);
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        //
        //     {
        //         "symbol": "ETH_USDT",
        //         "taker_fee_rate": "0.0025",
        //         "maker_fee_rate": "0.0025"
        //     }
        //
        object marketId = this.safeString(fee, "symbol");
        object symbol = this.safeSymbol(marketId);
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", symbol },
            { "maker", this.safeNumber(fee, "maker_fee_rate") },
            { "taker", this.safeNumber(fee, "taker_fee_rate") },
            { "percentage", null },
            { "tierBased", null },
        };
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchTradingFee
        * @description fetch the trading fees for a market
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchTradingFee() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateGetSpotV1TradeFee(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": "1000",
        //         "trace": "5a6f1e40-37fe-4849-a494-03279fadcc62",
        //         "data": {
        //             "symbol": "ETH_USDT",
        //             "taker_fee_rate": "0.0025",
        //             "maker_fee_rate": "0.0025"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data");
        return this.parseTradingFee(data);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //
        //     {
        //         "order_id": 2707217580
        //     }
        //
        // swap
        //   "data": {
        //       "order_id": 231116359426639,
        //       "price": "market price"
        //    },
        //
        // cancelOrder
        //
        //     "2707217580" // order id
        //
        // spot fetchOrder, fetchOrdersByStatus, fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "order_id":1736871726781,
        //         "symbol":"BTC_USDT",
        //         "create_time":1591096004000,
        //         "side":"sell",
        //         "type":"market", // limit, market, limit_maker, ioc
        //         "price":"0.00",
        //         "price_avg":"0.00",
        //         "size":"0.02000",
        //         "notional":"0.00000000",
        //         "filled_notional":"0.00000000",
        //         "filled_size":"0.00000",
        //         "status":"8"
        //     }
        //
        // spot v4
        //    {
        //        "orderId" : "118100034543076010",
        //        "clientOrderId" : "118100034543076010",
        //        "symbol" : "BTC_USDT",
        //        "side" : "buy",
        //        "orderMode" : "spot",
        //        "type" : "limit",
        //        "state" : "filled",
        //        "price" : "48800.00",
        //        "priceAvg" : "39999.00",
        //        "size" : "0.10000",
        //        "filledSize" : "0.10000",
        //        "notional" : "4880.00000000",
        //        "filledNotional" : "3999.90000000",
        //        "createTime" : 1681701557927,
        //        "updateTime" : 1681701559408
        //    }
        //
        // swap: fetchOrder, fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "order_id": "230935812485489",
        //         "client_order_id": "",
        //         "price": "24000",
        //         "size": "1",
        //         "symbol": "BTCUSDT",
        //         "state": 2,
        //         "side": 1,
        //         "type": "limit",
        //         "leverage": "10",
        //         "open_type": "isolated",
        //         "deal_avg_price": "0",
        //         "deal_size": "0",
        //         "create_time": 1695702258629,
        //         "update_time": 1695702258642,
        //         "activation_price_type": 0,
        //         "activation_price": "",
        //         "callback_rate": ""
        //     }
        //
        object id = null;
        if (isTrue((order is string)))
        {
            id = order;
            order = new Dictionary<string, object>() {};
        }
        id = this.safeString2(order, "order_id", "orderId", id);
        object timestamp = this.safeInteger2(order, "create_time", "createTime");
        object marketId = this.safeString(order, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        market = this.safeMarket(symbol, market);
        object orderType = this.safeString(market, "type", "spot");
        object type = this.safeString(order, "type");
        object timeInForce = null;
        object postOnly = null;
        if (isTrue(isEqual(type, "limit_maker")))
        {
            type = "limit";
            postOnly = true;
            timeInForce = "PO";
        }
        if (isTrue(isEqual(type, "ioc")))
        {
            type = "limit";
            timeInForce = "IOC";
        }
        object priceString = this.safeString(order, "price");
        if (isTrue(isEqual(priceString, "market price")))
        {
            priceString = null;
        }
        object trailingActivationPrice = this.safeNumber(order, "activation_price");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", this.safeString(order, "client_order_id") },
            { "info", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", this.safeInteger(order, "update_time") },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "side", this.parseOrderSide(this.safeString(order, "side")) },
            { "price", this.omitZero(priceString) },
            { "stopPrice", trailingActivationPrice },
            { "triggerPrice", trailingActivationPrice },
            { "amount", this.omitZero(this.safeString(order, "size")) },
            { "cost", this.safeString2(order, "filled_notional", "filledNotional") },
            { "average", this.safeStringN(order, new List<object>() {"price_avg", "priceAvg", "deal_avg_price"}) },
            { "filled", this.safeStringN(order, new List<object>() {"filled_size", "filledSize", "deal_size"}) },
            { "remaining", null },
            { "status", this.parseOrderStatusByType(orderType, this.safeString2(order, "status", "state")) },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public virtual object parseOrderSide(object side)
    {
        object sides = new Dictionary<string, object>() {
            { "1", "buy" },
            { "2", "buy" },
            { "3", "sell" },
            { "4", "sell" },
        };
        return this.safeString(sides, side, side);
    }

    public virtual object parseOrderStatusByType(object type, object status)
    {
        object statusesByType = new Dictionary<string, object>() {
            { "spot", new Dictionary<string, object>() {
                { "1", "rejected" },
                { "2", "open" },
                { "3", "rejected" },
                { "4", "open" },
                { "5", "open" },
                { "6", "closed" },
                { "7", "canceled" },
                { "8", "canceled" },
                { "new", "open" },
                { "partially_filled", "open" },
                { "filled", "closed" },
                { "partially_canceled", "canceled" },
            } },
            { "swap", new Dictionary<string, object>() {
                { "1", "open" },
                { "2", "open" },
                { "4", "closed" },
            } },
        };
        object statuses = this.safeValue(statusesByType, type, new Dictionary<string, object>() {});
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#createMarketBuyOrderWithCost
        * @description create a market buy order by providing the symbol and cost
        * @see https://developer-pro.bitmart.com/en/spot/#new-order-v2-signed
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {float} cost how much you want to trade in units of the quote currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
        }
        ((IDictionary<string,object>)parameters)["createMarketBuyOrderRequiresPrice"] = false;
        return await this.createOrder(symbol, "market", "buy", cost, null, parameters);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#createOrder
        * @description create a trade order
        * @see https://developer-pro.bitmart.com/en/spot/#new-order-v2-signed
        * @see https://developer-pro.bitmart.com/en/spot/#place-margin-order
        * @see https://developer-pro.bitmart.com/en/futures/#submit-order-signed
        * @see https://developer-pro.bitmart.com/en/futures/#submit-plan-order-signed
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market', 'limit' or 'trailing' for swap markets only
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'cross' or 'isolated'
        * @param {string} [params.leverage] *swap only* leverage level
        * @param {string} [params.clientOrderId] client order id of the order
        * @param {boolean} [params.reduceOnly] *swap only* reduce only
        * @param {boolean} [params.postOnly] make sure the order is posted to the order book and not matched immediately
        * @param {string} [params.triggerPrice] *swap only* the price to trigger a stop order
        * @param {int} [params.price_type] *swap only* 1: last price, 2: fair price, default is 1
        * @param {int} [params.price_way] *swap only* 1: price way long, 2: price way short
        * @param {int} [params.activation_price_type] *swap trailing order only* 1: last price, 2: fair price, default is 1
        * @param {string} [params.trailingPercent] *swap only* the percent to trail away from the current market price, min 0.1 max 5
        * @param {string} [params.trailingTriggerPrice] *swap only* the price to trigger a trailing order, default uses the price argument
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object result = this.handleMarginModeAndParams("createOrder", parameters);
        object marginMode = this.safeString(result, 0);
        object triggerPrice = this.safeStringN(parameters, new List<object>() {"triggerPrice", "stopPrice", "trigger_price"});
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            object spotRequest = this.createSpotOrderRequest(symbol, type, side, amount, price, parameters);
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                response = await this.privatePostSpotV1MarginSubmitOrder(spotRequest);
            } else
            {
                response = await this.privatePostSpotV2SubmitOrder(spotRequest);
            }
        } else
        {
            object swapRequest = this.createSwapOrderRequest(symbol, type, side, amount, price, parameters);
            if (isTrue(isTriggerOrder))
            {
                response = await this.privatePostContractPrivateSubmitPlanOrder(swapRequest);
            } else
            {
                response = await this.privatePostContractPrivateSubmitOrder(swapRequest);
            }
        }
        //
        // spot and margin
        //
        //     {
        //         "code": 1000,
        //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
        //         "message": "OK",
        //         "data": {
        //             "order_id": 2707217580
        //         }
        //     }
        //
        // swap
        // {"code":1000,"message":"Ok","data":{"order_id":231116359426639,"price":"market price"},"trace":"7f9c94e10f9d4513bc08a7bfc2a5559a.62.16996369620521911"}
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object order = this.parseOrder(data, market);
        ((IDictionary<string,object>)order)["type"] = type;
        ((IDictionary<string,object>)order)["side"] = side;
        ((IDictionary<string,object>)order)["amount"] = amount;
        ((IDictionary<string,object>)order)["price"] = price;
        return order;
    }

    public virtual object createSwapOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#createSwapOrderRequest
        * @ignore
        * @description create a trade order
        * @see https://developer-pro.bitmart.com/en/futures/#submit-order-signed
        * @see https://developer-pro.bitmart.com/en/futures/#submit-plan-order-signed
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market', 'limit' or 'trailing'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.leverage] leverage level
        * @param {boolean} [params.reduceOnly] *swap only* reduce only
        * @param {string} [params.marginMode] 'cross' or 'isolated', default is 'cross'
        * @param {string} [params.clientOrderId] client order id of the order
        * @param {string} [params.triggerPrice] *swap only* the price to trigger a stop order
        * @param {int} [params.price_type] *swap only* 1: last price, 2: fair price, default is 1
        * @param {int} [params.price_way] *swap only* 1: price way long, 2: price way short
        * @param {int} [params.activation_price_type] *swap trailing order only* 1: last price, 2: fair price, default is 1
        * @param {string} [params.trailingPercent] *swap only* the percent to trail away from the current market price, min 0.1 max 5
        * @param {string} [params.trailingTriggerPrice] *swap only* the price to trigger a trailing order, default uses the price argument
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "type", type },
            { "size", parseInt(this.amountToPrecision(symbol, amount)) },
        };
        object timeInForce = this.safeString(parameters, "timeInForce");
        object mode = this.safeInteger(parameters, "mode"); // only for swap
        object isMarketOrder = isEqual(type, "market");
        object postOnly = null;
        object reduceOnly = this.safeValue(parameters, "reduceOnly");
        object isExchangeSpecificPo = (isEqual(mode, 4));
        var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, isExchangeSpecificPo, parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        object ioc = (isTrue((isEqual(timeInForce, "IOC"))) || isTrue((isEqual(mode, 3))));
        object isLimitOrder = isTrue(isTrue((isEqual(type, "limit"))) || isTrue(postOnly)) || isTrue(ioc);
        if (isTrue(isEqual(timeInForce, "GTC")))
        {
            ((IDictionary<string,object>)request)["mode"] = 1;
        } else if (isTrue(isEqual(timeInForce, "FOK")))
        {
            ((IDictionary<string,object>)request)["mode"] = 2;
        } else if (isTrue(isEqual(timeInForce, "IOC")))
        {
            ((IDictionary<string,object>)request)["mode"] = 3;
        }
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["mode"] = 4;
        }
        object triggerPrice = this.safeStringN(parameters, new List<object>() {"triggerPrice", "stopPrice", "trigger_price"});
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object trailingTriggerPrice = this.safeString2(parameters, "trailingTriggerPrice", "activation_price", this.numberToString(price));
        object trailingPercent = this.safeString2(parameters, "trailingPercent", "callback_rate");
        object isTrailingPercentOrder = !isEqual(trailingPercent, null);
        if (isTrue(isLimitOrder))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        } else if (isTrue(isTrue(isEqual(type, "trailing")) || isTrue(isTrailingPercentOrder)))
        {
            ((IDictionary<string,object>)request)["callback_rate"] = trailingPercent;
            ((IDictionary<string,object>)request)["activation_price"] = this.priceToPrecision(symbol, trailingTriggerPrice);
            ((IDictionary<string,object>)request)["activation_price_type"] = this.safeInteger(parameters, "activation_price_type", 1);
        }
        if (isTrue(isTriggerOrder))
        {
            ((IDictionary<string,object>)request)["executive_price"] = this.priceToPrecision(symbol, price);
            ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, triggerPrice);
            ((IDictionary<string,object>)request)["price_type"] = this.safeInteger(parameters, "price_type", 1);
            if (isTrue(isEqual(side, "buy")))
            {
                if (isTrue(reduceOnly))
                {
                    ((IDictionary<string,object>)request)["price_way"] = 2;
                } else
                {
                    ((IDictionary<string,object>)request)["price_way"] = 1;
                }
            } else if (isTrue(isEqual(side, "sell")))
            {
                if (isTrue(reduceOnly))
                {
                    ((IDictionary<string,object>)request)["price_way"] = 1;
                } else
                {
                    ((IDictionary<string,object>)request)["price_way"] = 2;
                }
            }
        }
        if (isTrue(isEqual(side, "buy")))
        {
            if (isTrue(reduceOnly))
            {
                ((IDictionary<string,object>)request)["side"] = 2; // buy close short
            } else
            {
                ((IDictionary<string,object>)request)["side"] = 1; // buy open long
            }
        } else if (isTrue(isEqual(side, "sell")))
        {
            if (isTrue(reduceOnly))
            {
                ((IDictionary<string,object>)request)["side"] = 3; // sell close long
            } else
            {
                ((IDictionary<string,object>)request)["side"] = 4; // sell open short
            }
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters, "cross");
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        ((IDictionary<string,object>)request)["open_type"] = marginMode;
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            parameters = this.omit(parameters, "clientOrderId");
            ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
        }
        object leverage = this.safeInteger(parameters, "leverage", 1);
        parameters = this.omit(parameters, new List<object>() {"timeInForce", "postOnly", "reduceOnly", "leverage", "trailingTriggerPrice", "trailingPercent", "triggerPrice", "stopPrice"});
        ((IDictionary<string,object>)request)["leverage"] = this.numberToString(leverage);
        return this.extend(request, parameters);
    }

    public virtual object createSpotOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#createSpotOrderRequest
        * @ignore
        * @description create a spot order request
        * @see https://developer-pro.bitmart.com/en/spot/#place-spot-order
        * @see https://developer-pro.bitmart.com/en/spot/#place-margin-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'cross' or 'isolated'
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", side },
            { "type", type },
        };
        object timeInForce = this.safeString(parameters, "timeInForce");
        if (isTrue(isEqual(timeInForce, "FOK")))
        {
            throw new InvalidOrder ((string)add(this.id, " createOrder() only accepts timeInForce parameter values of IOC or PO")) ;
        }
        object mode = this.safeInteger(parameters, "mode"); // only for swap
        object isMarketOrder = isEqual(type, "market");
        object postOnly = null;
        object isExchangeSpecificPo = isTrue((isEqual(type, "limit_maker"))) || isTrue((isEqual(mode, 4)));
        var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, isExchangeSpecificPo, parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        parameters = this.omit(parameters, new List<object>() {"timeInForce", "postOnly"});
        object ioc = (isTrue((isEqual(timeInForce, "IOC"))) || isTrue((isEqual(type, "ioc"))));
        object isLimitOrder = isTrue(isTrue((isEqual(type, "limit"))) || isTrue(postOnly)) || isTrue(ioc);
        // method = 'privatePostSpotV2SubmitOrder';
        if (isTrue(isLimitOrder))
        {
            ((IDictionary<string,object>)request)["size"] = this.amountToPrecision(symbol, amount);
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        } else if (isTrue(isMarketOrder))
        {
            // for market buy it requires the amount of quote currency to spend
            if (isTrue(isEqual(side, "buy")))
            {
                object notional = this.safeNumber2(parameters, "cost", "notional");
                parameters = this.omit(parameters, "cost");
                object createMarketBuyOrderRequiresPrice = true;
                var createMarketBuyOrderRequiresPriceparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                createMarketBuyOrderRequiresPrice = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[0];
                parameters = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[1];
                if (isTrue(createMarketBuyOrderRequiresPrice))
                {
                    if (isTrue(isTrue((isEqual(price, null))) && isTrue((isEqual(notional, null)))))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument or in the \"notional\" extra parameter (the exchange-specific behaviour)")) ;
                    } else
                    {
                        object amountString = this.numberToString(amount);
                        object priceString = this.numberToString(price);
                        notional = this.parseNumber(Precise.stringMul(amountString, priceString));
                    }
                } else
                {
                    notional = ((bool) isTrue((isEqual(notional, null)))) ? amount : notional;
                }
                ((IDictionary<string,object>)request)["notional"] = this.decimalToPrecision(notional, TRUNCATE, getValue(getValue(market, "precision"), "price"), this.precisionMode);
            } else if (isTrue(isEqual(side, "sell")))
            {
                ((IDictionary<string,object>)request)["size"] = this.amountToPrecision(symbol, amount);
            }
        }
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["type"] = "limit_maker";
        }
        if (isTrue(ioc))
        {
            ((IDictionary<string,object>)request)["type"] = "ioc";
        }
        return this.extend(request, parameters);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#cancelOrder
        * @description cancels an open order
        * @see https://developer-pro.bitmart.com/en/futures/#cancel-order-signed
        * @see https://developer-pro.bitmart.com/en/spot/#cancel-order-v3-signed
        * @see https://developer-pro.bitmart.com/en/futures/#cancel-plan-order-signed
        * @see https://developer-pro.bitmart.com/en/futures/#cancel-plan-order-signed
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.clientOrderId] *spot only* the client order id of the order to cancel
        * @param {boolean} [params.stop] *swap only* whether the order is a stop order
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "client_order_id");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["order_id"] = ((object)id).ToString();
        }
        parameters = this.omit(parameters, new List<object>() {"clientOrderId"});
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.privatePostSpotV3CancelOrder(this.extend(request, parameters));
        } else
        {
            object stop = this.safeValue2(parameters, "stop", "trigger");
            parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
            if (!isTrue(stop))
            {
                response = await this.privatePostContractPrivateCancelOrder(this.extend(request, parameters));
            } else
            {
                response = await this.privatePostContractPrivateCancelPlanOrder(this.extend(request, parameters));
            }
        }
        // swap
        // {"code":1000,"message":"Ok","trace":"7f9c94e10f9d4513bc08a7bfc2a5559a.55.16959817848001851"}
        //
        // spot
        //
        //     {
        //         "code": 1000,
        //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
        //         "message": "OK",
        //         "data": {
        //             "result": true
        //         }
        //     }
        //
        // spot alternative
        //
        //     {
        //         "code": 1000,
        //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
        //         "message": "OK",
        //         "data": true
        //     }
        //
        if (isTrue(getValue(market, "swap")))
        {
            return response;
        }
        object data = this.safeValue(response, "data");
        if (isTrue(isEqual(data, true)))
        {
            return this.parseOrder(id, market);
        }
        object succeeded = this.safeValue(data, "succeed");
        if (isTrue(!isEqual(succeeded, null)))
        {
            id = this.safeString(succeeded, 0);
            if (isTrue(isEqual(id, null)))
            {
                throw new InvalidOrder ((string)add(add(add(add(this.id, " cancelOrder() failed to cancel "), symbol), " order id "), id)) ;
            }
        } else
        {
            object result = this.safeValue(data, "result");
            if (!isTrue(result))
            {
                throw new InvalidOrder ((string)add(add(add(add(add(this.id, " cancelOrder() "), symbol), " order id "), id), " is filled or canceled")) ;
            }
        }
        object order = this.parseOrder(id, market);
        return this.extend(order, new Dictionary<string, object>() {
            { "id", id },
        });
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#cancelAllOrders
        * @description cancel all open orders in a market
        * @see https://developer-pro.bitmart.com/en/spot/#cancel-all-orders
        * @see https://developer-pro.bitmart.com/en/futures/#cancel-all-orders-signed
        * @param {string} symbol unified market symbol of the market to cancel orders in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.side] *spot only* 'buy' or 'sell'
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object response = null;
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("cancelAllOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            response = await this.privatePostSpotV1CancelOrders(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "swap")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
            }
            response = await this.privatePostContractPrivateCancelOrders(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "code": 1000,
        //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
        //         "message": "OK",
        //         "data": {}
        //     }
        //
        // swap
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "trace": "7f9c94e10f9d4513bc08a7bfc2a5559a.70.16954131323145323"
        //     }
        //
        return response;
    }

    public async virtual Task<object> fetchOrdersByStatus(object status, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrdersByStatus() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOrdersByStatus() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "offset", 1 },
            { "N", 100 },
        };
        if (isTrue(isEqual(status, "open")))
        {
            ((IDictionary<string,object>)request)["status"] = 9;
        } else if (isTrue(isEqual(status, "closed")))
        {
            ((IDictionary<string,object>)request)["status"] = 6;
        } else if (isTrue(isEqual(status, "canceled")))
        {
            ((IDictionary<string,object>)request)["status"] = 8;
        } else
        {
            ((IDictionary<string,object>)request)["status"] = status;
        }
        object response = await this.privateGetSpotV3Orders(this.extend(request, parameters));
        //
        // spot
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"70e7d427-7436-4fb8-8cdd-97e1f5eadbe9",
        //         "data":{
        //             "current_page":1,
        //             "orders":[
        //                 {
        //                     "order_id":2147601241,
        //                     "symbol":"BTC_USDT",
        //                     "create_time":1591099963000,
        //                     "side":"sell",
        //                     "type":"limit",
        //                     "price":"9000.00",
        //                     "price_avg":"0.00",
        //                     "size":"1.00000",
        //                     "notional":"9000.00000000",
        //                     "filled_notional":"0.00000000",
        //                     "filled_size":"0.00000",
        //                     "status":"4"
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeList(data, "orders", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchOpenOrders
        * @see https://developer-pro.bitmart.com/en/spot/#current-open-orders-v4-signed
        * @see https://developer-pro.bitmart.com/en/futures/#get-all-open-orders-keyed
        * @see https://developer-pro.bitmart.com/en/futures/#get-all-current-plan-orders-keyed
        * @description fetch all unfilled currently open orders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of open order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.marginMode] *spot* whether to fetch trades for margin orders or spot orders, defaults to spot orders (only isolated margin orders are supported)
        * @param {int} [params.until] *spot* the latest time in ms to fetch orders for
        * @param {string} [params.type] *swap* order type, 'limit' or 'market'
        * @param {string} [params.order_state] *swap* the order state, 'all' or 'partially_filled', default is 'all'
        * @param {string} [params.orderType] *swap only* 'limit', 'market', or 'trailing'
        * @param {boolean} [params.trailing] *swap only* set to true if you want to fetch trailing orders
        * @param {boolean} [params.trigger] *swap only* set to true if you want to fetch trigger orders
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object type = null;
        object response = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchOpenOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOpenOrders", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                ((IDictionary<string,object>)request)["orderMode"] = "iso_margin";
            }
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["startTime"] = since;
            }
            object until = this.safeInteger2(parameters, "until", "endTime");
            if (isTrue(!isEqual(until, null)))
            {
                parameters = this.omit(parameters, new List<object>() {"endTime"});
                ((IDictionary<string,object>)request)["endTime"] = until;
            }
            response = await this.privatePostSpotV4QueryOpenOrders(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "swap")))
        {
            object isStop = this.safeValue2(parameters, "stop", "trigger");
            parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
            if (isTrue(isStop))
            {
                response = await this.privateGetContractPrivateCurrentPlanOrder(this.extend(request, parameters));
            } else
            {
                object trailing = this.safeBool(parameters, "trailing", false);
                object orderType = this.safeString(parameters, "orderType");
                parameters = this.omit(parameters, new List<object>() {"orderType", "trailing"});
                if (isTrue(trailing))
                {
                    orderType = "trailing";
                }
                if (isTrue(!isEqual(orderType, null)))
                {
                    ((IDictionary<string,object>)request)["type"] = orderType;
                }
                response = await this.privateGetContractPrivateGetOpenOrders(this.extend(request, parameters));
            }
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOpenOrders() does not support "), type), " orders, only spot and swap orders are accepted")) ;
        }
        //
        // spot
        //
        //     {
        //         "code": 1000,
        //         "message": "success",
        //         "data": [
        //             {
        //                 "orderId": "183299373022163211",
        //                 "clientOrderId": "183299373022163211",
        //                 "symbol": "BTC_USDT",
        //                 "side": "buy",
        //                 "orderMode": "spot",
        //                 "type": "limit",
        //                 "state": "new",
        //                 "price": "25000.00",
        //                 "priceAvg": "0.00",
        //                 "size": "0.00020",
        //                 "filledSize": "0.00000",
        //                 "notional": "5.00000000",
        //                 "filledNotional": "0.00000000",
        //                 "createTime": 1695703703338,
        //                 "updateTime": 1695703703359
        //             }
        //         ],
        //         "trace": "15f11d48e3234c81a2e786cr2e7a38e6.71.16957022303515933"
        //     }
        //
        // swap
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": [
        //             {
        //                 "order_id": "230935812485489",
        //                 "client_order_id": "",
        //                 "price": "24000",
        //                 "size": "1",
        //                 "symbol": "BTCUSDT",
        //                 "state": 2,
        //                 "side": 1,
        //                 "type": "limit",
        //                 "leverage": "10",
        //                 "open_type": "isolated",
        //                 "deal_avg_price": "0",
        //                 "deal_size": "0",
        //                 "create_time": 1695702258629,
        //                 "update_time": 1695702258642
        //             }
        //         ],
        //         "trace": "7f9d94g10f9d4513bc08a7rfc3a5559a.71.16957022303515933"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchClosedOrders
        * @see https://developer-pro.bitmart.com/en/spot/#account-orders-v4-signed
        * @see https://developer-pro.bitmart.com/en/futures/#get-order-history-keyed
        * @description fetches information on multiple closed orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp in ms of the latest entry
        * @param {string} [params.marginMode] *spot only* 'cross' or 'isolated', for margin trading
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchClosedOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(!isEqual(type, "spot")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchClosedOrders() requires a symbol argument")) ;
            }
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchClosedOrders", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            ((IDictionary<string,object>)request)["orderMode"] = "iso_margin";
        }
        object startTimeKey = ((bool) isTrue((isEqual(type, "spot")))) ? "startTime" : "start_time";
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)[(string)startTimeKey] = since;
        }
        object endTimeKey = ((bool) isTrue((isEqual(type, "spot")))) ? "endTime" : "end_time";
        object until = this.safeInteger2(parameters, "until", endTimeKey);
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)[(string)endTimeKey] = until;
        }
        object response = null;
        if (isTrue(isEqual(type, "spot")))
        {
            response = await this.privatePostSpotV4QueryHistoryOrders(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetContractPrivateOrderHistory(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchCanceledOrders
        * @description fetches information on multiple canceled orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] timestamp in ms of the earliest order, default is undefined
        * @param {int} [limit] max number of orders to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("canceled", symbol, since, limit, parameters);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://developer-pro.bitmart.com/en/spot/#query-order-by-id-v4-signed
        * @see https://developer-pro.bitmart.com/en/spot/#query-order-by-clientorderid-v4-signed
        * @see https://developer-pro.bitmart.com/en/futures/#get-order-detail-keyed
        * @param {string} id the id of the order
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.clientOrderId] *spot* fetch the order by client order id instead of order id
        * @param {string} [params.orderType] *swap only* 'limit', 'market', 'liquidate', 'bankruptcy', 'adl' or 'trailing'
        * @param {boolean} [params.trailing] *swap only* set to true if you want to fetch a trailing order
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object type = null;
        object market = null;
        object response = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchOrder", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            object clientOrderId = this.safeString(parameters, "clientOrderId");
            if (!isTrue(clientOrderId))
            {
                ((IDictionary<string,object>)request)["orderId"] = id;
            }
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                response = await this.privatePostSpotV4QueryClientOrder(this.extend(request, parameters));
            } else
            {
                response = await this.privatePostSpotV4QueryOrder(this.extend(request, parameters));
            }
        } else if (isTrue(isEqual(type, "swap")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
            }
            object trailing = this.safeBool(parameters, "trailing", false);
            object orderType = this.safeString(parameters, "orderType");
            parameters = this.omit(parameters, new List<object>() {"orderType", "trailing"});
            if (isTrue(trailing))
            {
                orderType = "trailing";
            }
            if (isTrue(!isEqual(orderType, null)))
            {
                ((IDictionary<string,object>)request)["type"] = orderType;
            }
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            ((IDictionary<string,object>)request)["order_id"] = id;
            response = await this.privateGetContractPrivateOrder(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "code": 1000,
        //         "message": "success",
        //         "data": {
        //             "orderId": "183347420821295423",
        //             "clientOrderId": "183347420821295423",
        //             "symbol": "BTC_USDT",
        //             "side": "buy",
        //             "orderMode": "spot",
        //             "type": "limit",
        //             "state": "new",
        //             "price": "24000.00",
        //             "priceAvg": "0.00",
        //             "size": "0.00022",
        //             "filledSize": "0.00000",
        //             "notional": "5.28000000",
        //             "filledNotional": "0.00000000",
        //             "createTime": 1695783014734,
        //             "updateTime": 1695783014762
        //         },
        //         "trace": "ce3e6422c8b44d5fag855348a68693ed.63.14957831547451715"
        //     }
        //
        // swap
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": {
        //             "order_id": "230927283405028",
        //             "client_order_id": "",
        //             "price": "23000",
        //             "size": "1",
        //             "symbol": "BTCUSDT",
        //             "state": 2,
        //             "side": 1,
        //             "type": "limit",
        //             "leverage": "10",
        //             "open_type": "isolated",
        //             "deal_avg_price": "0",
        //             "deal_size": "0",
        //             "create_time": 1695783433600,
        //             "update_time": 1695783433613
        //         },
        //         "trace": "4cad855075664097af6ba5257c47605d.63.14957831547451715"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://developer-pro.bitmart.com/en/spot/#deposit-address-keyed
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        if (isTrue(isEqual(code, "USDT")))
        {
            object defaultNetworks = this.safeValue(this.options, "defaultNetworks");
            object defaultNetwork = this.safeStringUpper(defaultNetworks, code);
            object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
            object networkInner = this.safeStringUpper(parameters, "network", defaultNetwork); // this line allows the user to specify either ERC20 or ETH
            networkInner = this.safeString(networks, networkInner, networkInner); // handle ERC20>ETH alias
            if (isTrue(!isEqual(networkInner, null)))
            {
                ((IDictionary<string,object>)request)["currency"] = add(add(getValue(request, "currency"), "-"), networkInner); // when network the currency need to be changed to currency + '-' + network https://developer-pro.bitmart.com/en/account/withdraw_apply.html on the end of page
                parameters = this.omit(parameters, "network");
            }
        }
        object response = await this.privateGetAccountV1DepositAddress(this.extend(request, parameters));
        //
        //    {
        //        "message": "OK",
        //        "code": 1000,
        //        "trace": "0e6edd79-f77f-4251-abe5-83ba75d06c1a",
        //        "data": {
        //            currency: 'ETH',
        //            chain: 'Ethereum',
        //            address: '0x99B5EEc2C520f86F0F62F05820d28D05D36EccCf',
        //            address_memo: ''
        //        }
        //    }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseDepositAddress(data, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //    {
        //        currency: 'ETH',
        //        chain: 'Ethereum',
        //        address: '0x99B5EEc2C520f86F0F62F05820d28D05D36EccCf',
        //        address_memo: ''
        //    }
        //
        object currencyId = this.safeString(depositAddress, "currency");
        object address = this.safeString(depositAddress, "address");
        object chain = this.safeString(depositAddress, "chain");
        object network = null;
        currency = this.safeCurrency(currencyId, currency);
        if (isTrue(!isEqual(chain, null)))
        {
            object parts = ((string)chain).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            object partsLength = getArrayLength(parts);
            object networkId = this.safeString(parts, subtract(partsLength, 1));
            network = this.safeNetworkCode(networkId, currency);
        }
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", this.safeString(currency, "code") },
            { "address", address },
            { "tag", this.safeString(depositAddress, "address_memo") },
            { "network", network },
        };
    }

    public virtual object safeNetworkCode(object networkId, object currency = null)
    {
        object name = this.safeString(currency, "name");
        if (isTrue(isEqual(networkId, name)))
        {
            object code = this.safeString(currency, "code");
            return code;
        }
        return this.networkIdToCode(networkId);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", amount },
            { "destination", "To Digital Address" },
            { "address", address },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["address_memo"] = tag;
        }
        if (isTrue(isEqual(code, "USDT")))
        {
            object defaultNetworks = this.safeValue(this.options, "defaultNetworks");
            object defaultNetwork = this.safeStringUpper(defaultNetworks, code);
            object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
            object network = this.safeStringUpper(parameters, "network", defaultNetwork); // this line allows the user to specify either ERC20 or ETH
            network = this.safeString(networks, network, network); // handle ERC20>ETH alias
            if (isTrue(!isEqual(network, null)))
            {
                ((IDictionary<string,object>)request)["currency"] = add(add(getValue(request, "currency"), "-"), network); // when network the currency need to be changed to currency + '-' + network https://developer-pro.bitmart.com/en/account/withdraw_apply.html on the end of page
                parameters = this.omit(parameters, "network");
            }
        }
        object response = await this.privatePostAccountV1WithdrawApply(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
        //         "message": "OK",
        //         "data": {
        //             "withdraw_id": "121212"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data");
        object transaction = this.parseTransaction(data, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "code", code },
            { "address", address },
            { "tag", tag },
        });
    }

    public async virtual Task<object> fetchTransactionsByType(object type, object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(limit, null)))
        {
            limit = 50; // max 50
        }
        object request = new Dictionary<string, object>() {
            { "operation_type", type },
            { "offset", 1 },
            { "N", limit },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(isEqual(code, "USDT")))
        {
            object defaultNetworks = this.safeValue(this.options, "defaultNetworks");
            object defaultNetwork = this.safeStringUpper(defaultNetworks, code);
            object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
            object network = this.safeStringUpper(parameters, "network", defaultNetwork); // this line allows the user to specify either ERC20 or ETH
            network = this.safeString(networks, network, network); // handle ERC20>ETH alias
            if (isTrue(!isEqual(network, null)))
            {
                ((IDictionary<string,object>)request)["currency"] = add(((IDictionary<string,object>)request)["currency"], add("-", network)); // when network the currency need to be changed to currency + '-' + network https://developer-pro.bitmart.com/en/account/withdraw_apply.html on the end of page
                ((IDictionary<string,object>)currency)["code"] = getValue(request, "currency"); // update currency code to filter
                parameters = this.omit(parameters, "network");
            }
        }
        object response = await this.privateGetAccountV2DepositWithdrawHistory(this.extend(request, parameters));
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"142bf92a-fc50-4689-92b6-590886f90b97",
        //         "data":{
        //             "records":[
        //                 {
        //                     "withdraw_id":"1679952",
        //                     "deposit_id":"",
        //                     "operation_type":"withdraw",
        //                     "currency":"BMX",
        //                     "apply_time":1588867374000,
        //                     "arrival_amount":"59.000000000000",
        //                     "fee":"1.000000000000",
        //                     "status":0,
        //                     "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
        //                     "address_memo":"",
        //                     "tx_id":""
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object records = this.safeList(data, "records", new List<object>() {});
        return this.parseTransactions(records, currency, since, limit);
    }

    public async virtual Task<object> fetchDeposit(object id, object code = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchDeposit
        * @description fetch information on a deposit
        * @param {string} id deposit id
        * @param {string} code not used by bitmart fetchDeposit ()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object response = await this.privateGetAccountV1DepositWithdrawDetail(this.extend(request, parameters));
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"f7f74924-14da-42a6-b7f2-d3799dd9a612",
        //         "data":{
        //             "record":{
        //                 "withdraw_id":"",
        //                 "deposit_id":"1679952",
        //                 "operation_type":"deposit",
        //                 "currency":"BMX",
        //                 "apply_time":1588867374000,
        //                 "arrival_amount":"59.000000000000",
        //                 "fee":"1.000000000000",
        //                 "status":0,
        //                 "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
        //                 "address_memo":"",
        //                 "tx_id":""
        //             }
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object record = this.safeDict(data, "record", new Dictionary<string, object>() {});
        return this.parseTransaction(record);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsByType("deposit", code, since, limit, parameters);
    }

    public async virtual Task<object> fetchWithdrawal(object id, object code = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchWithdrawal
        * @description fetch data on a currency withdrawal via the withdrawal id
        * @param {string} id withdrawal id
        * @param {string} code not used by bitmart.fetchWithdrawal
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object response = await this.privateGetAccountV1DepositWithdrawDetail(this.extend(request, parameters));
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"f7f74924-14da-42a6-b7f2-d3799dd9a612",
        //         "data":{
        //             "record":{
        //                 "withdraw_id":"1679952",
        //                 "deposit_id":"",
        //                 "operation_type":"withdraw",
        //                 "currency":"BMX",
        //                 "apply_time":1588867374000,
        //                 "arrival_amount":"59.000000000000",
        //                 "fee":"1.000000000000",
        //                 "status":0,
        //                 "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
        //                 "address_memo":"",
        //                 "tx_id":""
        //             }
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object record = this.safeDict(data, "record", new Dictionary<string, object>() {});
        return this.parseTransaction(record);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsByType("withdraw", code, since, limit, parameters);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "0", "pending" },
            { "1", "pending" },
            { "2", "pending" },
            { "3", "ok" },
            { "4", "canceled" },
            { "5", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // withdraw
        //
        //     {
        //         "withdraw_id": "121212"
        //     }
        //
        // fetchDeposits, fetchWithdrawals, fetchWithdrawal
        //
        //     {
        //         "withdraw_id":"1679952",
        //         "deposit_id":"",
        //         "operation_type":"withdraw",
        //         "currency":"BMX",
        //         "apply_time":1588867374000,
        //         "arrival_amount":"59.000000000000",
        //         "fee":"1.000000000000",
        //         "status":0,
        //         "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
        //         "address_memo":"",
        //         "tx_id":""
        //     }
        //
        object id = null;
        object withdrawId = this.safeString(transaction, "withdraw_id");
        object depositId = this.safeString(transaction, "deposit_id");
        object type = null;
        if (isTrue(isTrue((!isEqual(withdrawId, null))) && isTrue((!isEqual(withdrawId, "")))))
        {
            type = "withdraw";
            id = withdrawId;
        } else if (isTrue(isTrue((!isEqual(depositId, null))) && isTrue((!isEqual(depositId, "")))))
        {
            type = "deposit";
            id = depositId;
        }
        object amount = this.safeNumber(transaction, "arrival_amount");
        object timestamp = this.safeInteger(transaction, "apply_time");
        object currencyId = this.safeString(transaction, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        object feeCost = this.safeNumber(transaction, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", code },
            };
        }
        object txid = this.safeString(transaction, "tx_id");
        object address = this.safeString(transaction, "address");
        object tag = this.safeString(transaction, "address_memo");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "currency", code },
            { "amount", amount },
            { "network", null },
            { "address", address },
            { "addressFrom", null },
            { "addressTo", null },
            { "tag", tag },
            { "tagFrom", null },
            { "tagTo", null },
            { "status", status },
            { "type", type },
            { "updated", null },
            { "txid", txid },
            { "internal", null },
            { "comment", null },
            { "timestamp", ((bool) isTrue((!isEqual(timestamp, 0)))) ? timestamp : null },
            { "datetime", ((bool) isTrue((!isEqual(timestamp, 0)))) ? this.iso8601(timestamp) : null },
            { "fee", fee },
        };
    }

    public async override Task<object> repayIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#repayIsolatedMargin
        * @description repay borrowed margin and interest
        * @see https://developer-pro.bitmart.com/en/spot/#margin-repay-isolated
        * @param {string} symbol unified market symbol
        * @param {string} code unified currency code of the currency to repay
        * @param {string} amount the amount to repay
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "currency", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.privatePostSpotV1MarginIsolatedRepay(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "b0a60b4c-e986-4b54-a190-8f7c05ddf685",
        //         "data": {
        //             "repay_id": "2afcc16d99bd4707818c5a355dc89bed"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object transaction = this.parseMarginLoan(data, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    public async override Task<object> borrowIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#borrowIsolatedMargin
        * @description create a loan to borrow margin
        * @see https://developer-pro.bitmart.com/en/spot/#margin-borrow-isolated
        * @param {string} symbol unified market symbol
        * @param {string} code unified currency code of the currency to borrow
        * @param {string} amount the amount to borrow
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "currency", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.privatePostSpotV1MarginIsolatedBorrow(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "e6fda683-181e-4e78-ac9c-b27c4c8ba035",
        //         "data": {
        //             "borrow_id": "629a7177a4ed4cf09869c6a4343b788c"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object transaction = this.parseMarginLoan(data, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        // borrowMargin
        //
        //     {
        //         "borrow_id": "629a7177a4ed4cf09869c6a4343b788c",
        //     }
        //
        // repayMargin
        //
        //     {
        //         "repay_id": "2afcc16d99bd4707818c5a355dc89bed",
        //     }
        //
        return new Dictionary<string, object>() {
            { "id", this.safeString2(info, "borrow_id", "repay_id") },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "amount", null },
            { "symbol", null },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    public async override Task<object> fetchIsolatedBorrowRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchIsolatedBorrowRate
        * @description fetch the rate of interest to borrow a currency for margin trading
        * @see https://developer-pro.bitmart.com/en/spot/#get-trading-pair-borrowing-rate-and-amount-keyed
        * @param {string} symbol unified symbol of the market to fetch the borrow rate for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [isolated borrow rate structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#isolated-borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateGetSpotV1MarginIsolatedPairs(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "0985a130-a5ae-4fc1-863f-4704e214f585",
        //         "data": {
        //             "symbols": [
        //                 {
        //                     "symbol": "BTC_USDT",
        //                     "max_leverage": "5",
        //                     "symbol_enabled": true,
        //                     "base": {
        //                         "currency": "BTC",
        //                         "daily_interest": "0.00055000",
        //                         "hourly_interest": "0.00002291",
        //                         "max_borrow_amount": "2.00000000",
        //                         "min_borrow_amount": "0.00000001",
        //                         "borrowable_amount": "0.00670810"
        //                     },
        //                     "quote": {
        //                         "currency": "USDT",
        //                         "daily_interest": "0.00055000",
        //                         "hourly_interest": "0.00002291",
        //                         "max_borrow_amount": "50000.00000000",
        //                         "min_borrow_amount": "0.00000001",
        //                         "borrowable_amount": "135.12575038"
        //                     }
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object symbols = this.safeValue(data, "symbols", new List<object>() {});
        object borrowRate = this.safeValue(symbols, 0);
        return this.parseIsolatedBorrowRate(borrowRate, market);
    }

    public override object parseIsolatedBorrowRate(object info, object market = null)
    {
        //
        //     {
        //         "symbol": "BTC_USDT",
        //         "max_leverage": "5",
        //         "symbol_enabled": true,
        //         "base": {
        //             "currency": "BTC",
        //             "daily_interest": "0.00055000",
        //             "hourly_interest": "0.00002291",
        //             "max_borrow_amount": "2.00000000",
        //             "min_borrow_amount": "0.00000001",
        //             "borrowable_amount": "0.00670810"
        //         },
        //         "quote": {
        //             "currency": "USDT",
        //             "daily_interest": "0.00055000",
        //             "hourly_interest": "0.00002291",
        //             "max_borrow_amount": "50000.00000000",
        //             "min_borrow_amount": "0.00000001",
        //             "borrowable_amount": "135.12575038"
        //         }
        //     }
        //
        object marketId = this.safeString(info, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object baseData = this.safeValue(info, "base", new Dictionary<string, object>() {});
        object quoteData = this.safeValue(info, "quote", new Dictionary<string, object>() {});
        object baseId = this.safeString(baseData, "currency");
        object quoteId = this.safeString(quoteData, "currency");
        return new Dictionary<string, object>() {
            { "symbol", symbol },
            { "base", this.safeCurrencyCode(baseId) },
            { "baseRate", this.safeNumber(baseData, "hourly_interest") },
            { "quote", this.safeCurrencyCode(quoteId) },
            { "quoteRate", this.safeNumber(quoteData, "hourly_interest") },
            { "period", 3600000 },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    public async override Task<object> fetchIsolatedBorrowRates(object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchIsolatedBorrowRates
        * @description fetch the borrow interest rates of all currencies, currently only works for isolated margin
        * @see https://developer-pro.bitmart.com/en/spot/#get-trading-pair-borrowing-rate-and-amount-keyed
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [isolated borrow rate structures]{@link https://docs.ccxt.com/#/?id=isolated-borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetSpotV1MarginIsolatedPairs(parameters);
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "0985a130-a5ae-4fc1-863f-4704e214f585",
        //         "data": {
        //             "symbols": [
        //                 {
        //                     "symbol": "BTC_USDT",
        //                     "max_leverage": "5",
        //                     "symbol_enabled": true,
        //                     "base": {
        //                         "currency": "BTC",
        //                         "daily_interest": "0.00055000",
        //                         "hourly_interest": "0.00002291",
        //                         "max_borrow_amount": "2.00000000",
        //                         "min_borrow_amount": "0.00000001",
        //                         "borrowable_amount": "0.00670810"
        //                     },
        //                     "quote": {
        //                         "currency": "USDT",
        //                         "daily_interest": "0.00055000",
        //                         "hourly_interest": "0.00002291",
        //                         "max_borrow_amount": "50000.00000000",
        //                         "min_borrow_amount": "0.00000001",
        //                         "borrowable_amount": "135.12575038"
        //                     }
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object symbols = this.safeValue(data, "symbols", new List<object>() {});
        return this.parseIsolatedBorrowRates(symbols);
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#transfer
        * @description transfer currency internally between wallets on the same account, currently only supports transfer between spot and margin
        * @see https://developer-pro.bitmart.com/en/spot/#margin-asset-transfer-signed
        * @see https://developer-pro.bitmart.com/en/futures/#transfer-signed
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object amountToPrecision = this.currencyToPrecision(code, amount);
        object request = new Dictionary<string, object>() {
            { "amount", amountToPrecision },
            { "currency", getValue(currency, "id") },
        };
        object fromId = this.convertTypeToAccount(fromAccount);
        object toId = this.convertTypeToAccount(toAccount);
        if (isTrue(isEqual(fromAccount, "spot")))
        {
            if (isTrue(isEqual(toAccount, "margin")))
            {
                ((IDictionary<string,object>)request)["side"] = "in";
                ((IDictionary<string,object>)request)["symbol"] = toId;
            } else if (isTrue(isEqual(toAccount, "swap")))
            {
                ((IDictionary<string,object>)request)["type"] = "spot_to_contract";
            }
        } else if (isTrue(isEqual(toAccount, "spot")))
        {
            if (isTrue(isEqual(fromAccount, "margin")))
            {
                ((IDictionary<string,object>)request)["side"] = "out";
                ((IDictionary<string,object>)request)["symbol"] = fromId;
            } else if (isTrue(isEqual(fromAccount, "swap")))
            {
                ((IDictionary<string,object>)request)["type"] = "contract_to_spot";
            }
        } else
        {
            throw new ArgumentsRequired ((string)add(this.id, " transfer() requires either fromAccount or toAccount to be spot")) ;
        }
        object response = null;
        if (isTrue(isTrue((isEqual(fromAccount, "margin"))) || isTrue((isEqual(toAccount, "margin")))))
        {
            response = await this.privatePostSpotV1MarginIsolatedTransfer(this.extend(request, parameters));
        } else if (isTrue(isTrue((isEqual(fromAccount, "swap"))) || isTrue((isEqual(toAccount, "swap")))))
        {
            response = await this.privatePostAccountV1TransferContract(this.extend(request, parameters));
        }
        //
        // margin
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "b26cecec-ef5a-47d9-9531-2bd3911d3d55",
        //         "data": {
        //             "transfer_id": "ca90d97a621e47d49774f19af6b029f5"
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "4cad858074667097ac6ba5257c57305d.68.16953302431189455",
        //         "data": {
        //             "currency": "USDT",
        //             "amount": "5"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.extend(this.parseTransfer(data, currency), new Dictionary<string, object>() {
            { "status", this.parseTransferStatus(this.safeString2(response, "code", "message")) },
        });
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "1000", "ok" },
            { "OK", "ok" },
            { "FINISHED", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseTransferToAccount(object type)
    {
        object types = new Dictionary<string, object>() {
            { "contract_to_spot", "spot" },
            { "spot_to_contract", "swap" },
        };
        return this.safeString(types, type, type);
    }

    public virtual object parseTransferFromAccount(object type)
    {
        object types = new Dictionary<string, object>() {
            { "contract_to_spot", "swap" },
            { "spot_to_contract", "spot" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // margin
        //
        //     {
        //         "transfer_id": "ca90d97a621e47d49774f19af6b029f5"
        //     }
        //
        // swap
        //
        //     {
        //         "currency": "USDT",
        //         "amount": "5"
        //     }
        //
        // fetchTransfers
        //
        //     {
        //         "transfer_id": "902463535961567232",
        //         "currency": "USDT",
        //         "amount": "5",
        //         "type": "contract_to_spot",
        //         "state": "FINISHED",
        //         "timestamp": 1695330539565
        //     }
        //
        object currencyId = this.safeString(transfer, "currency");
        object timestamp = this.safeInteger(transfer, "timestamp");
        return new Dictionary<string, object>() {
            { "id", this.safeString(transfer, "transfer_id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber(transfer, "amount") },
            { "fromAccount", this.parseTransferFromAccount(this.safeString(transfer, "type")) },
            { "toAccount", this.parseTransferToAccount(this.safeString(transfer, "type")) },
            { "status", this.parseTransferStatus(this.safeString(transfer, "state")) },
        };
    }

    public async virtual Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchTransfers
        * @description fetch a history of internal transfers made on an account, only transfers between spot and swap are supported
        * @see https://developer-pro.bitmart.com/en/futures/#get-transfer-list-signed
        * @param {string} code unified currency code of the currency transferred
        * @param {int} [since] the earliest time in ms to fetch transfers for
        * @param {int} [limit] the maximum number of transfer structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.page] the required number of pages, default is 1, max is 1000
        * @param {int} [params.until] the latest time in ms to fetch transfers for
        * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(limit, null)))
        {
            limit = 10;
        }
        object request = new Dictionary<string, object>() {
            { "page", this.safeInteger(parameters, "page", 1) },
            { "limit", limit },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["time_start"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = this.safeInteger(parameters, "until"); // unified in milliseconds
        object endTime = this.safeInteger(parameters, "time_end", until); // exchange-specific in milliseconds
        parameters = this.omit(parameters, new List<object>() {"until"});
        if (isTrue(!isEqual(endTime, null)))
        {
            ((IDictionary<string,object>)request)["time_end"] = endTime;
        }
        object response = await this.privatePostAccountV1TransferContractList(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "7f9d93e10f9g4513bc08a7btc2a5559a.69.16953325693032193",
        //         "data": {
        //             "records": [
        //                 {
        //                     "transfer_id": "902463535961567232",
        //                     "currency": "USDT",
        //                     "amount": "5",
        //                     "type": "contract_to_spot",
        //                     "state": "FINISHED",
        //                     "timestamp": 1695330539565
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object records = this.safeList(data, "records", new List<object>() {});
        return this.parseTransfers(records, currency, since, limit);
    }

    public async override Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchBorrowInterest
        * @description fetch the interest owed by the user for borrowing currency for margin trading
        * @see https://developer-pro.bitmart.com/en/spot/#get-borrow-record-isolated
        * @param {string} code unified currency code
        * @param {string} symbol unified market symbol when fetch interest in isolated markets
        * @param {int} [since] the earliest time in ms to fetch borrrow interest for
        * @param {int} [limit] the maximum number of structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchBorrowInterest() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["N"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        object response = await this.privateGetSpotV1MarginIsolatedBorrowRecord(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "8ea27a2a-4aba-49fa-961d-43a0137b0ef3",
        //         "data": {
        //             "records": [
        //                 {
        //                     "borrow_id": "1659045283903rNvJnuRTJNL5J53n",
        //                     "symbol": "BTC_USDT",
        //                     "currency": "USDT",
        //                     "borrow_amount": "100.00000000",
        //                     "daily_interest": "0.00055000",
        //                     "hourly_interest": "0.00002291",
        //                     "interest_amount": "0.00229166",
        //                     "create_time": 1659045284000
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeValue(data, "records", new List<object>() {});
        object interest = this.parseBorrowInterests(rows, market);
        return this.filterByCurrencySinceLimit(interest, code, since, limit);
    }

    public override object parseBorrowInterest(object info, object market = null)
    {
        //
        //     {
        //         "borrow_id": "1657664327844Lk5eJJugXmdHHZoe",
        //         "symbol": "BTC_USDT",
        //         "currency": "USDT",
        //         "borrow_amount": "20.00000000",
        //         "daily_interest": "0.00055000",
        //         "hourly_interest": "0.00002291",
        //         "interest_amount": "0.00045833",
        //         "create_time": 1657664329000
        //     }
        //
        object marketId = this.safeString(info, "symbol");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(info, "create_time");
        return new Dictionary<string, object>() {
            { "symbol", this.safeString(market, "symbol") },
            { "marginMode", "isolated" },
            { "currency", this.safeCurrencyCode(this.safeString(info, "currency")) },
            { "interest", this.safeNumber(info, "interest_amount") },
            { "interestRate", this.safeNumber(info, "hourly_interest") },
            { "amountBorrowed", this.safeNumber(info, "borrow_amount") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async override Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchOpenInterest
        * @description Retrieves the open interest of a currency
        * @see https://developer-pro.bitmart.com/en/futures/#get-futures-openinterest
        * @param {string} symbol Unified CCXT market symbol
        * @param {object} [params] exchange specific parameters
        * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "contract")))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterest() supports contract markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetContractPublicOpenInterest(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": {
        //             "timestamp": 1694657502415,
        //             "symbol": "BTCUSDT",
        //             "open_interest": "265231.721368593081729069",
        //             "open_interest_value": "7006353.83988919"
        //         },
        //         "trace": "7f9c94e10f9d4513bc08a7bfc2a5559a.72.16946575108274991"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOpenInterest(data, market);
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        //     {
        //         "timestamp": 1694657502415,
        //         "symbol": "BTCUSDT",
        //         "open_interest": "265231.721368593081729069",
        //         "open_interest_value": "7006353.83988919"
        //     }
        //
        object timestamp = this.safeInteger(interest, "timestamp");
        object id = this.safeString(interest, "symbol");
        return this.safeOpenInterest(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(id, market) },
            { "openInterestAmount", this.safeNumber(interest, "open_interest") },
            { "openInterestValue", this.safeNumber(interest, "open_interest_value") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", interest },
        }, market);
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#setLeverage
        * @description set the level of leverage for a market
        * @see https://developer-pro.bitmart.com/en/futures/#submit-leverage-signed
        * @param {float} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'isolated' or 'cross'
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("setLeverage", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        this.checkRequiredArgument("setLeverage", marginMode, "marginMode", new List<object>() {"isolated", "cross"});
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " setLeverage() supports swap contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "leverage", ((object)leverage).ToString() },
            { "open_type", marginMode },
        };
        return await this.privatePostContractPrivateSubmitLeverage(this.extend(request, parameters));
    }

    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchFundingRate
        * @description fetch the current funding rate
        * @see https://developer-pro.bitmart.com/en/futures/#get-current-funding-rate
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRate() supports swap contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetContractPublicFundingRate(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": {
        //             "timestamp": 1695184410697,
        //             "symbol": "BTCUSDT",
        //             "rate_value": "-0.00002614",
        //             "expected_rate": "-0.00002"
        //         },
        //         "trace": "4cad855074654097ac7ba5257c47305d.54.16951844206655589"
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseFundingRate(data, market);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //     {
        //         "timestamp": 1695184410697,
        //         "symbol": "BTCUSDT",
        //         "rate_value": "-0.00002614",
        //         "expected_rate": "-0.00002"
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        object timestamp = this.safeInteger(contract, "timestamp");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", this.safeSymbol(marketId, market) },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fundingRate", this.safeNumber(contract, "expected_rate") },
            { "fundingTimestamp", null },
            { "fundingDatetime", null },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", this.safeNumber(contract, "rate_value") },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchPosition
        * @description fetch data on a single open contract trade position
        * @see https://developer-pro.bitmart.com/en/futures/#get-current-position-keyed
        * @param {string} symbol unified market symbol of the market the position is held in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateGetContractPrivatePosition(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "leverage": "10",
        //                 "timestamp": 1696392515269,
        //                 "current_fee": "0.0014250028",
        //                 "open_timestamp": 1696392256998,
        //                 "current_value": "27.4039",
        //                 "mark_price": "27.4039",
        //                 "position_value": "27.4079",
        //                 "position_cross": "3.75723474",
        //                 "maintenance_margin": "0.1370395",
        //                 "close_vol": "0",
        //                 "close_avg_price": "0",
        //                 "open_avg_price": "27407.9",
        //                 "entry_price": "27407.9",
        //                 "current_amount": "1",
        //                 "unrealized_value": "-0.004",
        //                 "realized_value": "-0.01644474",
        //                 "position_type": 1
        //             }
        //         ],
        //         "trace":"4cad855074664097ac5ba5257c47305d.67.16963925142065945"
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parsePosition(first, market);
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchPositions
        * @description fetch all open contract positions
        * @see https://developer-pro.bitmart.com/en/futures/#get-current-position-keyed
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object symbolsLength = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            symbolsLength = getArrayLength(symbols);
            object first = this.safeString(symbols, 0);
            market = this.market(first);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(isEqual(symbolsLength, 1)))
        {
            // only supports symbols as undefined or sending one symbol
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object response = await this.privateGetContractPrivatePosition(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "leverage": "10",
        //                 "timestamp": 1696392515269,
        //                 "current_fee": "0.0014250028",
        //                 "open_timestamp": 1696392256998,
        //                 "current_value": "27.4039",
        //                 "mark_price": "27.4039",
        //                 "position_value": "27.4079",
        //                 "position_cross": "3.75723474",
        //                 "maintenance_margin": "0.1370395",
        //                 "close_vol": "0",
        //                 "close_avg_price": "0",
        //                 "open_avg_price": "27407.9",
        //                 "entry_price": "27407.9",
        //                 "current_amount": "1",
        //                 "unrealized_value": "-0.004",
        //                 "realized_value": "-0.01644474",
        //                 "position_type": 1
        //             },
        //         ],
        //         "trace":"4cad855074664097ac5ba5257c47305d.67.16963925142065945"
        //     }
        //
        object positions = this.safeValue(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parsePosition(getValue(positions, i)));
        }
        symbols = this.marketSymbols(symbols);
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "leverage": "10",
        //         "timestamp": 1696392515269,
        //         "current_fee": "0.0014250028",
        //         "open_timestamp": 1696392256998,
        //         "current_value": "27.4039",
        //         "mark_price": "27.4039",
        //         "position_value": "27.4079",
        //         "position_cross": "3.75723474",
        //         "maintenance_margin": "0.1370395",
        //         "close_vol": "0",
        //         "close_avg_price": "0",
        //         "open_avg_price": "27407.9",
        //         "entry_price": "27407.9",
        //         "current_amount": "1",
        //         "unrealized_value": "-0.004",
        //         "realized_value": "-0.01644474",
        //         "position_type": 1
        //     }
        //
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger(position, "timestamp");
        object side = this.safeInteger(position, "position_type");
        object maintenanceMargin = this.safeString(position, "maintenance_margin");
        object notional = this.safeString(position, "current_value");
        object collateral = this.safeString(position, "position_cross");
        object maintenanceMarginPercentage = Precise.stringDiv(maintenanceMargin, notional);
        object marginRatio = Precise.stringDiv(maintenanceMargin, collateral);
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", null },
            { "hedged", null },
            { "side", ((bool) isTrue((isEqual(side, 1)))) ? "long" : "short" },
            { "contracts", this.safeNumber(position, "current_amount") },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "entryPrice", this.safeNumber(position, "entry_price") },
            { "markPrice", this.safeNumber(position, "mark_price") },
            { "lastPrice", null },
            { "notional", this.parseNumber(notional) },
            { "leverage", this.safeNumber(position, "leverage") },
            { "collateral", this.parseNumber(collateral) },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "maintenanceMargin", this.parseNumber(maintenanceMargin) },
            { "maintenanceMarginPercentage", this.parseNumber(maintenanceMarginPercentage) },
            { "unrealizedPnl", this.safeNumber(position, "unrealized_value") },
            { "realizedPnl", this.safeNumber(position, "realized_value") },
            { "liquidationPrice", null },
            { "marginMode", null },
            { "percentage", null },
            { "marginRatio", this.parseNumber(marginRatio) },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    public async override Task<object> fetchMyLiquidations(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchMyLiquidations
        * @description retrieves the users liquidated positions
        * @see https://developer-pro.bitmart.com/en/futures/#get-order-history-keyed
        * @param {string} symbol unified CCXT market symbol
        * @param {int} [since] the earliest time in ms to fetch liquidations for
        * @param {int} [limit] the maximum number of liquidation structures to retrieve
        * @param {object} [params] exchange specific parameters for the bitmart api endpoint
        * @param {int} [params.until] timestamp in ms of the latest liquidation
        * @returns {object} an array of [liquidation structures]{@link https://docs.ccxt.com/#/?id=liquidation-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyLiquidations() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new NotSupported ((string)add(this.id, " fetchMyLiquidations() supports swap markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateGetContractPrivateOrderHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": [
        //             {
        //                 "order_id": "231007865458273",
        //                 "client_order_id": "",
        //                 "price": "27407.9",
        //                 "size": "1",
        //                 "symbol": "BTCUSDT",
        //                 "state": 4,
        //                 "side": 3,
        //                 "type": "liquidate",
        //                 "leverage": "10",
        //                 "open_type": "isolated",
        //                 "deal_avg_price": "27422.6",
        //                 "deal_size": "1",
        //                 "create_time": 1696405864011,
        //                 "update_time": 1696405864045
        //             },
        //         ],
        //         "trace": "4cad855074664097ac6ba4257c47305d.71.16965658195443021"
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object checkLiquidation = this.safeString(entry, "type");
            if (isTrue(isEqual(checkLiquidation, "liquidate")))
            {
                ((IList<object>)result).Add(entry);
            }
        }
        return this.parseLiquidations(result, market, since, limit);
    }

    public override object parseLiquidation(object liquidation, object market = null)
    {
        //
        //     {
        //         "order_id": "231007865458273",
        //         "client_order_id": "",
        //         "price": "27407.9",
        //         "size": "1",
        //         "symbol": "BTCUSDT",
        //         "state": 4,
        //         "side": 3,
        //         "type": "market",
        //         "leverage": "10",
        //         "open_type": "isolated",
        //         "deal_avg_price": "27422.6",
        //         "deal_size": "1",
        //         "create_time": 1696405864011,
        //         "update_time": 1696405864045
        //     }
        //
        object marketId = this.safeString(liquidation, "symbol");
        object timestamp = this.safeInteger(liquidation, "update_time");
        object contractsString = this.safeString(liquidation, "deal_size");
        object contractSizeString = this.safeString(market, "contractSize");
        object priceString = this.safeString(liquidation, "deal_avg_price");
        object baseValueString = Precise.stringMul(contractsString, contractSizeString);
        object quoteValueString = Precise.stringMul(baseValueString, priceString);
        return this.safeLiquidation(new Dictionary<string, object>() {
            { "info", liquidation },
            { "symbol", this.safeSymbol(marketId, market) },
            { "contracts", this.parseNumber(contractsString) },
            { "contractSize", this.parseNumber(contractSizeString) },
            { "price", this.parseNumber(priceString) },
            { "baseValue", this.parseNumber(baseValueString) },
            { "quoteValue", this.parseNumber(quoteValueString) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        });
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object baseUrl = this.implodeHostname(getValue(getValue(this.urls, "api"), "rest"));
        object url = add(add(baseUrl, "/"), this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        object queryString = "";
        object getOrDelete = isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE")));
        if (isTrue(getOrDelete))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                queryString = this.urlencode(query);
                url = add(url, add("?", queryString));
            }
        }
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object timestamp = ((object)this.milliseconds()).ToString();
            object brokerId = this.safeString(this.options, "brokerId", "CCXTxBitmart000");
            headers = new Dictionary<string, object>() {
                { "X-BM-KEY", this.apiKey },
                { "X-BM-TIMESTAMP", timestamp },
                { "X-BM-BROKER-ID", brokerId },
                { "Content-Type", "application/json" },
            };
            if (!isTrue(getOrDelete))
            {
                body = this.json(query);
                queryString = body;
            }
            object auth = add(add(add(add(timestamp, "#"), this.uid), "#"), queryString);
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
            ((IDictionary<string,object>)headers)["X-BM-SIGN"] = signature;
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        //
        // spot
        //
        //     {"message":"Bad Request [to is empty]","code":50000,"trace":"f9d46e1b-4edb-4d07-a06e-4895fb2fc8fc","data":{}}
        //     {"message":"Bad Request [from is empty]","code":50000,"trace":"579986f7-c93a-4559-926b-06ba9fa79d76","data":{}}
        //     {"message":"Kline size over 500","code":50004,"trace":"d625caa8-e8ca-4bd2-b77c-958776965819","data":{}}
        //     {"message":"Balance not enough","code":50020,"trace":"7c709d6a-3292-462c-98c5-32362540aeef","data":{}}
        //
        // contract
        //
        //     {"errno":"OK","message":"INVALID_PARAMETER","code":49998,"trace":"eb5ebb54-23cd-4de2-9064-e090b6c3b2e3","data":null}
        //
        object message = this.safeStringLower(response, "message");
        object isErrorMessage = isTrue(isTrue((!isEqual(message, null))) && isTrue((!isEqual(message, "ok")))) && isTrue((!isEqual(message, "success")));
        object errorCode = this.safeString(response, "code");
        object isErrorCode = isTrue((!isEqual(errorCode, null))) && isTrue((!isEqual(errorCode, "1000")));
        if (isTrue(isTrue(isErrorCode) || isTrue(isErrorMessage)))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), errorCode, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
