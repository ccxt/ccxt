namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class bitmex : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bitmex" },
            { "name", "BitMEX" },
            { "countries", new List<object>() {"SC"} },
            { "version", "v1" },
            { "userAgent", null },
            { "rateLimit", 100 },
            { "certified", true },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", true },
                { "future", true },
                { "option", false },
                { "addMargin", null },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "closeAllPositions", false },
                { "closePosition", true },
                { "createOrder", true },
                { "createReduceOnlyOrder", true },
                { "createTrailingAmountOrder", true },
                { "editOrder", true },
                { "fetchBalance", true },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDepositsWithdrawals", "emulated" },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", false },
                { "fetchLedger", true },
                { "fetchLeverage", true },
                { "fetchLeverages", true },
                { "fetchLeverageTiers", false },
                { "fetchLiquidations", true },
                { "fetchMarketLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyLiquidations", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchPosition", false },
                { "fetchPositions", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTrades", true },
                { "fetchTransactions", "emulated" },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "reduceMargin", null },
                { "setLeverage", true },
                { "setMargin", null },
                { "setMarginMode", true },
                { "setPositionMode", false },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "5m", "5m" },
                { "1h", "1h" },
                { "1d", "1d" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "test", new Dictionary<string, object>() {
                    { "public", "https://testnet.bitmex.com" },
                    { "private", "https://testnet.bitmex.com" },
                } },
                { "logo", "https://github.com/ccxt/ccxt/assets/43336371/cea9cfe5-c57e-4b84-b2ac-77b960b04445" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://www.bitmex.com" },
                    { "private", "https://www.bitmex.com" },
                } },
                { "www", "https://www.bitmex.com" },
                { "doc", new List<object>() {"https://www.bitmex.com/app/apiOverview", "https://github.com/BitMEX/api-connectors/tree/master/official-http"} },
                { "fees", "https://www.bitmex.com/app/fees" },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://www.bitmex.com/app/register/NZTR1q" },
                    { "discount", 0.1 },
                } },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "announcement", 5 },
                        { "announcement/urgent", 5 },
                        { "chat", 5 },
                        { "chat/channels", 5 },
                        { "chat/connected", 5 },
                        { "chat/pinned", 5 },
                        { "funding", 5 },
                        { "guild", 5 },
                        { "instrument", 5 },
                        { "instrument/active", 5 },
                        { "instrument/activeAndIndices", 5 },
                        { "instrument/activeIntervals", 5 },
                        { "instrument/compositeIndex", 5 },
                        { "instrument/indices", 5 },
                        { "instrument/usdVolume", 5 },
                        { "insurance", 5 },
                        { "leaderboard", 5 },
                        { "liquidation", 5 },
                        { "orderBook/L2", 5 },
                        { "porl/nonce", 5 },
                        { "quote", 5 },
                        { "quote/bucketed", 5 },
                        { "schema", 5 },
                        { "schema/websocketHelp", 5 },
                        { "settlement", 5 },
                        { "stats", 5 },
                        { "stats/history", 5 },
                        { "stats/historyUSD", 5 },
                        { "trade", 5 },
                        { "trade/bucketed", 5 },
                        { "wallet/assets", 5 },
                        { "wallet/networks", 5 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "address", 5 },
                        { "apiKey", 5 },
                        { "execution", 5 },
                        { "execution/tradeHistory", 5 },
                        { "globalNotification", 5 },
                        { "leaderboard/name", 5 },
                        { "order", 5 },
                        { "porl/snapshots", 5 },
                        { "position", 5 },
                        { "user", 5 },
                        { "user/affiliateStatus", 5 },
                        { "user/checkReferralCode", 5 },
                        { "user/commission", 5 },
                        { "user/csa", 5 },
                        { "user/depositAddress", 5 },
                        { "user/executionHistory", 5 },
                        { "user/getWalletTransferAccounts", 5 },
                        { "user/margin", 5 },
                        { "user/quoteFillRatio", 5 },
                        { "user/quoteValueRatio", 5 },
                        { "user/staking", 5 },
                        { "user/staking/instruments", 5 },
                        { "user/staking/tiers", 5 },
                        { "user/tradingVolume", 5 },
                        { "user/unstakingRequests", 5 },
                        { "user/wallet", 5 },
                        { "user/walletHistory", 5 },
                        { "user/walletSummary", 5 },
                        { "userAffiliates", 5 },
                        { "userEvent", 5 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "address", 5 },
                        { "chat", 5 },
                        { "guild", 5 },
                        { "guild/archive", 5 },
                        { "guild/join", 5 },
                        { "guild/kick", 5 },
                        { "guild/leave", 5 },
                        { "guild/sharesTrades", 5 },
                        { "order", 1 },
                        { "order/cancelAllAfter", 5 },
                        { "order/closePosition", 5 },
                        { "position/isolate", 1 },
                        { "position/leverage", 1 },
                        { "position/riskLimit", 5 },
                        { "position/transferMargin", 1 },
                        { "user/addSubaccount", 5 },
                        { "user/cancelWithdrawal", 5 },
                        { "user/communicationToken", 5 },
                        { "user/confirmEmail", 5 },
                        { "user/confirmWithdrawal", 5 },
                        { "user/logout", 5 },
                        { "user/preferences", 5 },
                        { "user/requestWithdrawal", 5 },
                        { "user/unstakingRequests", 5 },
                        { "user/updateSubaccount", 5 },
                        { "user/walletTransfer", 5 },
                    } },
                    { "put", new Dictionary<string, object>() {
                        { "guild", 5 },
                        { "order", 1 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "order", 1 },
                        { "order/all", 1 },
                        { "user/unstakingRequests", 5 },
                    } },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "Invalid API Key.", typeof(AuthenticationError) },
                    { "This key is disabled.", typeof(PermissionDenied) },
                    { "Access Denied", typeof(PermissionDenied) },
                    { "Duplicate clOrdID", typeof(InvalidOrder) },
                    { "orderQty is invalid", typeof(InvalidOrder) },
                    { "Invalid price", typeof(InvalidOrder) },
                    { "Invalid stopPx for ordType", typeof(InvalidOrder) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Signature not valid", typeof(AuthenticationError) },
                    { "overloaded", typeof(ExchangeNotAvailable) },
                    { "Account has insufficient Available Balance", typeof(InsufficientFunds) },
                    { "Service unavailable", typeof(ExchangeNotAvailable) },
                    { "Server Error", typeof(ExchangeError) },
                    { "Unable to cancel order due to existing state", typeof(InvalidOrder) },
                    { "We require all new traders to verify", typeof(PermissionDenied) },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "options", new Dictionary<string, object>() {
                { "api-expires", 5 },
                { "fetchOHLCVOpenTimestamp", true },
                { "oldPrecision", false },
                { "networks", new Dictionary<string, object>() {
                    { "BTC", "btc" },
                    { "ERC20", "eth" },
                    { "BEP20", "bsc" },
                    { "TRC20", "tron" },
                    { "AVAXC", "avax" },
                    { "NEAR", "near" },
                    { "XTZ", "xtz" },
                    { "DOT", "dot" },
                    { "SOL", "sol" },
                    { "ADA", "ada" },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "USDt", "USDT" },
                { "XBt", "BTC" },
                { "XBT", "BTC" },
                { "Gwei", "ETH" },
                { "GWEI", "ETH" },
                { "LAMP", "SOL" },
                { "LAMp", "SOL" },
            } },
        });
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://www.bitmex.com/api/explorer/#!/Wallet/Wallet_getAssetsConfig
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetWalletAssets(parameters);
        //
        //    {
        //        "XBt": {
        //            "asset": "XBT",
        //            "currency": "XBt",
        //            "majorCurrency": "XBT",
        //            "name": "Bitcoin",
        //            "currencyType": "Crypto",
        //            "scale": "8",
        //            // "mediumPrecision": "8",
        //            // "shorterPrecision": "4",
        //            // "symbol": "â‚¿",
        //            // "weight": "1",
        //            // "tickLog": "0",
        //            "enabled": true,
        //            "isMarginCurrency": true,
        //            "minDepositAmount": "10000",
        //            "minWithdrawalAmount": "1000",
        //            "maxWithdrawalAmount": "100000000000000",
        //            "networks": [
        //                {
        //                    "asset": "btc",
        //                    "tokenAddress": "",
        //                    "depositEnabled": true,
        //                    "withdrawalEnabled": true,
        //                    "withdrawalFee": "20000",
        //                    "minFee": "20000",
        //                    "maxFee": "10000000"
        //                }
        //            ]
        //        },
        //     }
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object currency = getValue(response, i);
            object asset = this.safeString(currency, "asset");
            object code = this.safeCurrencyCode(asset);
            object id = this.safeString(currency, "currency");
            object name = this.safeString(currency, "name");
            object chains = this.safeValue(currency, "networks", new List<object>() {});
            object depositEnabled = false;
            object withdrawEnabled = false;
            object networks = new Dictionary<string, object>() {};
            object scale = this.safeString(currency, "scale");
            object precisionString = this.parsePrecision(scale);
            object precision = this.parseNumber(precisionString);
            for (object j = 0; isLessThan(j, getArrayLength(chains)); postFixIncrement(ref j))
            {
                object chain = getValue(chains, j);
                object networkId = this.safeString(chain, "asset");
                object network = this.networkIdToCode(networkId);
                object withdrawalFeeRaw = this.safeString(chain, "withdrawalFee");
                object withdrawalFee = this.parseNumber(Precise.stringMul(withdrawalFeeRaw, precisionString));
                object isDepositEnabled = this.safeBool(chain, "depositEnabled", false);
                object isWithdrawEnabled = this.safeBool(chain, "withdrawalEnabled", false);
                object active = (isTrue(isDepositEnabled) && isTrue(isWithdrawEnabled));
                if (isTrue(isDepositEnabled))
                {
                    depositEnabled = true;
                }
                if (isTrue(isWithdrawEnabled))
                {
                    withdrawEnabled = true;
                }
                ((IDictionary<string,object>)networks)[(string)network] = new Dictionary<string, object>() {
                    { "info", chain },
                    { "id", networkId },
                    { "network", network },
                    { "active", active },
                    { "deposit", isDepositEnabled },
                    { "withdraw", isWithdrawEnabled },
                    { "fee", withdrawalFee },
                    { "precision", null },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                    } },
                };
            }
            object currencyEnabled = this.safeValue(currency, "enabled");
            object currencyActive = isTrue(currencyEnabled) || isTrue((isTrue(depositEnabled) || isTrue(withdrawEnabled)));
            object minWithdrawalString = this.safeString(currency, "minWithdrawalAmount");
            object minWithdrawal = this.parseNumber(Precise.stringMul(minWithdrawalString, precisionString));
            object maxWithdrawalString = this.safeString(currency, "maxWithdrawalAmount");
            object maxWithdrawal = this.parseNumber(Precise.stringMul(maxWithdrawalString, precisionString));
            object minDepositString = this.safeString(currency, "minDepositAmount");
            object minDeposit = this.parseNumber(Precise.stringMul(minDepositString, precisionString));
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "code", code },
                { "info", currency },
                { "name", name },
                { "active", currencyActive },
                { "deposit", depositEnabled },
                { "withdraw", withdrawEnabled },
                { "fee", null },
                { "precision", precision },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", minWithdrawal },
                        { "max", maxWithdrawal },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", minDeposit },
                        { "max", null },
                    } },
                } },
                { "networks", networks },
            };
        }
        return result;
    }

    public virtual object convertFromRealAmount(object code, object amount)
    {
        object currency = this.currency(code);
        object precision = this.safeString(currency, "precision");
        object amountString = this.numberToString(amount);
        object finalAmount = Precise.stringDiv(amountString, precision);
        return this.parseNumber(finalAmount);
    }

    public virtual object convertToRealAmount(object code, object amount)
    {
        if (isTrue(isEqual(code, null)))
        {
            return amount;
        } else if (isTrue(isEqual(amount, null)))
        {
            return null;
        }
        object currency = this.currency(code);
        object precision = this.safeString(currency, "precision");
        return Precise.stringMul(amount, precision);
    }

    public override object amountToPrecision(object symbol, object amount)
    {
        symbol = this.safeSymbol(symbol);
        object market = this.market(symbol);
        object oldPrecision = this.safeValue(this.options, "oldPrecision");
        if (isTrue(isTrue(getValue(market, "spot")) && !isTrue(oldPrecision)))
        {
            amount = this.convertFromRealAmount(getValue(market, "base"), amount);
        }
        return base.amountToPrecision(symbol, amount);
    }

    public virtual object convertFromRawQuantity(object symbol, object rawQuantity, object currencySide = null)
    {
        currencySide ??= "base";
        if (isTrue(this.safeValue(this.options, "oldPrecision")))
        {
            return this.parseNumber(rawQuantity);
        }
        symbol = this.safeSymbol(symbol);
        object marketExists = this.inArray(symbol, this.symbols);
        if (!isTrue(marketExists))
        {
            return this.parseNumber(rawQuantity);
        }
        object market = this.market(symbol);
        if (isTrue(getValue(market, "spot")))
        {
            return this.parseNumber(this.convertToRealAmount(getValue(market, currencySide), rawQuantity));
        }
        return this.parseNumber(rawQuantity);
    }

    public virtual object convertFromRawCost(object symbol, object rawQuantity)
    {
        return this.convertFromRawQuantity(symbol, rawQuantity, "quote");
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchMarkets
        * @description retrieves data on all markets for bitmex
        * @see https://www.bitmex.com/api/explorer/#!/Instrument/Instrument_getActive
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetInstrumentActive(parameters);
        //
        //  [
        //    {
        //        "symbol": "LTCUSDT",
        //        "rootSymbol": "LTC",
        //        "state": "Open",
        //        "typ": "FFWCSX",
        //        "listing": "2021-11-10T04:00:00.000Z",
        //        "front": "2021-11-10T04:00:00.000Z",
        //        "expiry": null,
        //        "settle": null,
        //        "listedSettle": null,
        //        "relistInterval": null,
        //        "inverseLeg": "",
        //        "sellLeg": "",
        //        "buyLeg": "",
        //        "optionStrikePcnt": null,
        //        "optionStrikeRound": null,
        //        "optionStrikePrice": null,
        //        "optionMultiplier": null,
        //        "positionCurrency": "LTC", // can be empty for spot markets
        //        "underlying": "LTC",
        //        "quoteCurrency": "USDT",
        //        "underlyingSymbol": "LTCT=", // can be empty for spot markets
        //        "reference": "BMEX",
        //        "referenceSymbol": ".BLTCT", // can be empty for spot markets
        //        "calcInterval": null,
        //        "publishInterval": null,
        //        "publishTime": null,
        //        "maxOrderQty": 1000000000,
        //        "maxPrice": 1000000,
        //        "lotSize": 1000,
        //        "tickSize": 0.01,
        //        "multiplier": 100,
        //        "settlCurrency": "USDt", // can be empty for spot markets
        //        "underlyingToPositionMultiplier": 10000,
        //        "underlyingToSettleMultiplier": null,
        //        "quoteToSettleMultiplier": 1000000,
        //        "isQuanto": false,
        //        "isInverse": false,
        //        "initMargin": 0.03,
        //        "maintMargin": 0.015,
        //        "riskLimit": 1000000000000, // can be null for spot markets
        //        "riskStep": 1000000000000, // can be null for spot markets
        //        "limit": null,
        //        "capped": false,
        //        "taxed": true,
        //        "deleverage": true,
        //        "makerFee": -0.0001,
        //        "takerFee": 0.0005,
        //        "settlementFee": 0,
        //        "insuranceFee": 0,
        //        "fundingBaseSymbol": ".LTCBON8H", // can be empty for spot markets
        //        "fundingQuoteSymbol": ".USDTBON8H", // can be empty for spot markets
        //        "fundingPremiumSymbol": ".LTCUSDTPI8H", // can be empty for spot markets
        //        "fundingTimestamp": "2022-01-14T20:00:00.000Z",
        //        "fundingInterval": "2000-01-01T08:00:00.000Z",
        //        "fundingRate": 0.0001,
        //        "indicativeFundingRate": 0.0001,
        //        "rebalanceTimestamp": null,
        //        "rebalanceInterval": null,
        //        "openingTimestamp": "2022-01-14T17:00:00.000Z",
        //        "closingTimestamp": "2022-01-14T18:00:00.000Z",
        //        "sessionInterval": "2000-01-01T01:00:00.000Z",
        //        "prevClosePrice": 138.511,
        //        "limitDownPrice": null,
        //        "limitUpPrice": null,
        //        "bankruptLimitDownPrice": null,
        //        "bankruptLimitUpPrice": null,
        //        "prevTotalVolume": 12699024000,
        //        "totalVolume": 12702160000,
        //        "volume": 3136000,
        //        "volume24h": 114251000,
        //        "prevTotalTurnover": 232418052349000,
        //        "totalTurnover": 232463353260000,
        //        "turnover": 45300911000,
        //        "turnover24h": 1604331340000,
        //        "homeNotional24h": 11425.1,
        //        "foreignNotional24h": 1604331.3400000003,
        //        "prevPrice24h": 135.48,
        //        "vwap": 140.42165,
        //        "highPrice": 146.42,
        //        "lowPrice": 135.08,
        //        "lastPrice": 144.36,
        //        "lastPriceProtected": 144.36,
        //        "lastTickDirection": "MinusTick",
        //        "lastChangePcnt": 0.0655,
        //        "bidPrice": 143.75,
        //        "midPrice": 143.855,
        //        "askPrice": 143.96,
        //        "impactBidPrice": 143.75,
        //        "impactMidPrice": 143.855,
        //        "impactAskPrice": 143.96,
        //        "hasLiquidity": true,
        //        "openInterest": 38103000,
        //        "openValue": 547963053300,
        //        "fairMethod": "FundingRate",
        //        "fairBasisRate": 0.1095,
        //        "fairBasis": 0.004,
        //        "fairPrice": 143.811,
        //        "markMethod": "FairPrice",
        //        "markPrice": 143.811,
        //        "indicativeTaxRate": null,
        //        "indicativeSettlePrice": 143.807,
        //        "optionUnderlyingPrice": null,
        //        "settledPriceAdjustmentRate": null,
        //        "settledPrice": null,
        //        "timestamp": "2022-01-14T17:49:55.000Z"
        //    }
        //  ]
        //
        return this.parseMarkets(response);
    }

    public override object parseMarket(object market)
    {
        object id = this.safeString(market, "symbol");
        object baseId = this.safeString(market, "underlying");
        object quoteId = this.safeString(market, "quoteCurrency");
        object settleId = this.safeString(market, "settlCurrency");
        object settle = this.safeCurrencyCode(settleId);
        // 'positionCurrency' may be empty ("", as Bitmex currently returns for ETHUSD)
        // so let's take the settlCurrency first and then adjust if needed
        object typ = this.safeString(market, "typ"); // type definitions at: https://www.bitmex.com/api/explorer/#!/Instrument/Instrument_get
        object type = null;
        object swap = false;
        object spot = false;
        object future = false;
        if (isTrue(isEqual(typ, "FFWCSX")))
        {
            type = "swap";
            swap = true;
        } else if (isTrue(isEqual(typ, "IFXXXP")))
        {
            type = "spot";
            spot = true;
        } else if (isTrue(isEqual(typ, "FFCCSX")))
        {
            type = "future";
            future = true;
        } else if (isTrue(isEqual(typ, "FFICSX")))
        {
            // prediction markets (without any volume)
            quoteId = baseId;
            baseId = this.safeString(market, "rootSymbol");
            type = "future";
            future = true;
        }
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object contract = isTrue(swap) || isTrue(future);
        object contractSize = null;
        object isInverse = this.safeValue(market, "isInverse"); // this is true when BASE and SETTLE are same, i.e. BTC/XXX:BTC
        object isQuanto = this.safeValue(market, "isQuanto"); // this is true when BASE and SETTLE are different, i.e. AXS/XXX:BTC
        object linear = ((bool) isTrue(contract)) ? (!isTrue(isInverse) && !isTrue(isQuanto)) : null;
        object status = this.safeString(market, "state");
        object active = !isEqual(status, "Unlisted");
        object expiry = null;
        object expiryDatetime = null;
        object symbol = null;
        if (isTrue(spot))
        {
            symbol = add(add(bs, "/"), quote);
        } else if (isTrue(contract))
        {
            symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
            if (isTrue(linear))
            {
                object multiplierString = this.safeString2(market, "underlyingToPositionMultiplier", "underlyingToSettleMultiplier");
                contractSize = this.parseNumber(Precise.stringDiv("1", multiplierString));
            } else
            {
                object multiplierString = Precise.stringAbs(this.safeString(market, "multiplier"));
                contractSize = this.parseNumber(multiplierString);
            }
            if (isTrue(future))
            {
                expiryDatetime = this.safeString(market, "expiry");
                expiry = this.parse8601(expiryDatetime);
                symbol = add(add(symbol, "-"), this.yymmdd(expiry));
            }
        } else
        {
            // for index/exotic markets, default to id
            symbol = id;
        }
        object positionId = this.safeString2(market, "positionCurrency", "underlying");
        object position = this.safeCurrencyCode(positionId);
        object positionIsQuote = (isEqual(position, quote));
        object maxOrderQty = this.safeNumber(market, "maxOrderQty");
        object initMargin = this.safeString(market, "initMargin", "1");
        object maxLeverage = this.parseNumber(Precise.stringDiv("1", initMargin));
        return new Dictionary<string, object>() {
            { "id", id },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", type },
            { "spot", spot },
            { "margin", false },
            { "swap", swap },
            { "future", future },
            { "option", false },
            { "active", active },
            { "contract", contract },
            { "linear", linear },
            { "inverse", isInverse },
            { "quanto", isQuanto },
            { "taker", this.safeNumber(market, "takerFee") },
            { "maker", this.safeNumber(market, "makerFee") },
            { "contractSize", contractSize },
            { "expiry", expiry },
            { "expiryDatetime", expiryDatetime },
            { "strike", this.safeNumber(market, "optionStrikePrice") },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber(market, "lotSize") },
                { "price", this.safeNumber(market, "tickSize") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", ((bool) isTrue(contract)) ? this.parseNumber("1") : null },
                    { "max", ((bool) isTrue(contract)) ? maxLeverage : null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", ((bool) isTrue(positionIsQuote)) ? null : maxOrderQty },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", this.safeNumber(market, "maxPrice") },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", ((bool) isTrue(positionIsQuote)) ? maxOrderQty : null },
                } },
            } },
            { "created", this.parse8601(this.safeString(market, "listing")) },
            { "info", market },
        };
    }

    public override object parseBalance(object response)
    {
        //
        //     [
        //         {
        //             "account":1455728,
        //             "currency":"XBt",
        //             "riskLimit":1000000000000,
        //             "prevState":"",
        //             "state":"",
        //             "action":"",
        //             "amount":263542,
        //             "pendingCredit":0,
        //             "pendingDebit":0,
        //             "confirmedDebit":0,
        //             "prevRealisedPnl":0,
        //             "prevUnrealisedPnl":0,
        //             "grossComm":0,
        //             "grossOpenCost":0,
        //             "grossOpenPremium":0,
        //             "grossExecCost":0,
        //             "grossMarkValue":0,
        //             "riskValue":0,
        //             "taxableMargin":0,
        //             "initMargin":0,
        //             "maintMargin":0,
        //             "sessionMargin":0,
        //             "targetExcessMargin":0,
        //             "varMargin":0,
        //             "realisedPnl":0,
        //             "unrealisedPnl":0,
        //             "indicativeTax":0,
        //             "unrealisedProfit":0,
        //             "syntheticMargin":null,
        //             "walletBalance":263542,
        //             "marginBalance":263542,
        //             "marginBalancePcnt":1,
        //             "marginLeverage":0,
        //             "marginUsedPcnt":0,
        //             "excessMargin":263542,
        //             "excessMarginPcnt":1,
        //             "availableMargin":263542,
        //             "withdrawableMargin":263542,
        //             "timestamp":"2020-08-03T12:01:01.246Z",
        //             "grossLastValue":0,
        //             "commission":null
        //         }
        //     ]
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object balance = getValue(response, i);
            object currencyId = this.safeString(balance, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            object free = this.safeString(balance, "availableMargin");
            object total = this.safeString(balance, "marginBalance");
            ((IDictionary<string,object>)account)["free"] = this.convertToRealAmount(code, free);
            ((IDictionary<string,object>)account)["total"] = this.convertToRealAmount(code, total);
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://www.bitmex.com/api/explorer/#!/User/User_getMargin
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "currency", "all" },
        };
        object response = await this.privateGetUserMargin(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "account":1455728,
        //             "currency":"XBt",
        //             "riskLimit":1000000000000,
        //             "prevState":"",
        //             "state":"",
        //             "action":"",
        //             "amount":263542,
        //             "pendingCredit":0,
        //             "pendingDebit":0,
        //             "confirmedDebit":0,
        //             "prevRealisedPnl":0,
        //             "prevUnrealisedPnl":0,
        //             "grossComm":0,
        //             "grossOpenCost":0,
        //             "grossOpenPremium":0,
        //             "grossExecCost":0,
        //             "grossMarkValue":0,
        //             "riskValue":0,
        //             "taxableMargin":0,
        //             "initMargin":0,
        //             "maintMargin":0,
        //             "sessionMargin":0,
        //             "targetExcessMargin":0,
        //             "varMargin":0,
        //             "realisedPnl":0,
        //             "unrealisedPnl":0,
        //             "indicativeTax":0,
        //             "unrealisedProfit":0,
        //             "syntheticMargin":null,
        //             "walletBalance":263542,
        //             "marginBalance":263542,
        //             "marginBalancePcnt":1,
        //             "marginLeverage":0,
        //             "marginUsedPcnt":0,
        //             "excessMargin":263542,
        //             "excessMarginPcnt":1,
        //             "availableMargin":263542,
        //             "withdrawableMargin":263542,
        //             "timestamp":"2020-08-03T12:01:01.246Z",
        //             "grossLastValue":0,
        //             "commission":null
        //         }
        //     ]
        //
        return this.parseBalance(response);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://www.bitmex.com/api/explorer/#!/OrderBook/OrderBook_getL2
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["depth"] = limit;
        }
        object response = await this.publicGetOrderBookL2(this.extend(request, parameters));
        object result = new Dictionary<string, object>() {
            { "symbol", symbol },
            { "bids", new List<object>() {} },
            { "asks", new List<object>() {} },
            { "timestamp", null },
            { "datetime", null },
            { "nonce", null },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object order = getValue(response, i);
            object side = ((bool) isTrue((isEqual(getValue(order, "side"), "Sell")))) ? "asks" : "bids";
            object amount = this.convertFromRawQuantity(symbol, this.safeString(order, "size"));
            object price = this.safeNumber(order, "price");
            // https://github.com/ccxt/ccxt/issues/4926
            // https://github.com/ccxt/ccxt/issues/4927
            // the exchange sometimes returns null price in the orderbook
            if (isTrue(!isEqual(price, null)))
            {
                ((IList<object>)getValue(result, side)).Add(new List<object>() {price, amount});
            }
        }
        ((IDictionary<string,object>)result)["bids"] = this.sortBy(getValue(result, "bids"), 0, true);
        ((IDictionary<string,object>)result)["asks"] = this.sortBy(getValue(result, "asks"), 0);
        return result;
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://www.bitmex.com/api/explorer/#!/Order/Order_getOrders
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object filter = new Dictionary<string, object>() {
            { "filter", new Dictionary<string, object>() {
                { "orderID", id },
            } },
        };
        object response = await this.fetchOrders(symbol, null, null, this.deepExtend(filter, parameters));
        object numResults = getArrayLength(response);
        if (isTrue(isEqual(numResults, 1)))
        {
            return getValue(response, 0);
        }
        throw new OrderNotFound ((string)add(add(add(this.id, ": The order "), id), " not found.")) ;
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchOrders
        * @see https://www.bitmex.com/api/explorer/#!/Order/Order_getOrders
        * @description fetches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the earliest time in ms to fetch orders for
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchOrders", symbol, since, limit, parameters, 100);
        }
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["count"] = limit;
        }
        object until = this.safeInteger2(parameters, "until", "endTime");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)["endTime"] = this.iso8601(until);
        }
        request = this.deepExtend(request, parameters);
        // why the hassle? urlencode in python is kinda broken for nested dicts.
        // E.g. self.urlencode({"filter": {"open": True}}) will return "filter={'open':+True}"
        // Bitmex doesn't like that. Hence resorting to this hack.
        if (isTrue(inOp(request, "filter")))
        {
            ((IDictionary<string,object>)request)["filter"] = this.json(getValue(request, "filter"));
        }
        object response = await this.privateGetOrder(request);
        return this.parseOrders(response, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://www.bitmex.com/api/explorer/#!/Order/Order_getOrders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "filter", new Dictionary<string, object>() {
                { "open", true },
            } },
        };
        return await this.fetchOrders(symbol, since, limit, this.deepExtend(request, parameters));
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://www.bitmex.com/api/explorer/#!/Order/Order_getOrders
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        // Bitmex barfs if you set 'open': false in the filter...
        parameters ??= new Dictionary<string, object>();
        object orders = await this.fetchOrders(symbol, since, limit, parameters);
        return this.filterByArray(orders, "status", new List<object>() {"closed", "canceled"}, false);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://www.bitmex.com/api/explorer/#!/Execution/Execution_getTradeHistory
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, parameters, 100);
        }
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["count"] = limit;
        }
        object until = this.safeInteger2(parameters, "until", "endTime");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)["endTime"] = this.iso8601(until);
        }
        request = this.deepExtend(request, parameters);
        // why the hassle? urlencode in python is kinda broken for nested dicts.
        // E.g. self.urlencode({"filter": {"open": True}}) will return "filter={'open':+True}"
        // Bitmex doesn't like that. Hence resorting to this hack.
        if (isTrue(inOp(request, "filter")))
        {
            ((IDictionary<string,object>)request)["filter"] = this.json(getValue(request, "filter"));
        }
        object response = await this.privateGetExecutionTradeHistory(request);
        //
        //     [
        //         {
        //             "execID": "string",
        //             "orderID": "string",
        //             "clOrdID": "string",
        //             "clOrdLinkID": "string",
        //             "account": 0,
        //             "symbol": "string",
        //             "side": "string",
        //             "lastQty": 0,
        //             "lastPx": 0,
        //             "underlyingLastPx": 0,
        //             "lastMkt": "string",
        //             "lastLiquidityInd": "string",
        //             "simpleOrderQty": 0,
        //             "orderQty": 0,
        //             "price": 0,
        //             "displayQty": 0,
        //             "stopPx": 0,
        //             "pegOffsetValue": 0,
        //             "pegPriceType": "string",
        //             "currency": "string",
        //             "settlCurrency": "string",
        //             "execType": "string",
        //             "ordType": "string",
        //             "timeInForce": "string",
        //             "execInst": "string",
        //             "contingencyType": "string",
        //             "exDestination": "string",
        //             "ordStatus": "string",
        //             "triggered": "string",
        //             "workingIndicator": true,
        //             "ordRejReason": "string",
        //             "simpleLeavesQty": 0,
        //             "leavesQty": 0,
        //             "simpleCumQty": 0,
        //             "cumQty": 0,
        //             "avgPx": 0,
        //             "commission": 0,
        //             "tradePublishIndicator": "string",
        //             "multiLegReportingType": "string",
        //             "text": "string",
        //             "trdMatchID": "string",
        //             "execCost": 0,
        //             "execComm": 0,
        //             "homeNotional": 0,
        //             "foreignNotional": 0,
        //             "transactTime": "2019-03-05T12:47:02.762Z",
        //             "timestamp": "2019-03-05T12:47:02.762Z"
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "Withdrawal", "transaction" },
            { "RealisedPNL", "margin" },
            { "UnrealisedPNL", "margin" },
            { "Deposit", "transaction" },
            { "Transfer", "transfer" },
            { "AffiliatePayout", "referral" },
            { "SpotTrade", "trade" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //         "transactID": "69573da3-7744-5467-3207-89fd6efe7a47",
        //         "account":  24321,
        //         "currency": "XBt",
        //         "transactType": "Withdrawal", // "AffiliatePayout", "Transfer", "Deposit", "RealisedPNL", ...
        //         "amount":  -1000000,
        //         "fee":  300000,
        //         "transactStatus": "Completed", // "Canceled", ...
        //         "address": "1Ex4fkF4NhQaQdRWNoYpqiPbDBbq18Kdd9",
        //         "tx": "3BMEX91ZhhKoWtsH9QRb5dNXnmnGpiEetA",
        //         "text": "",
        //         "transactTime": "2017-03-21T20:05:14.388Z",
        //         "walletBalance":  0, // balance after
        //         "marginBalance":  null,
        //         "timestamp": "2017-03-22T13:09:23.514Z"
        //     }
        //
        // ButMEX returns the unrealized pnl from the wallet history endpoint.
        // The unrealized pnl transaction has an empty timestamp.
        // It is not related to historical pnl it has status set to "Pending".
        // Therefore it's not a part of the history at all.
        // https://github.com/ccxt/ccxt/issues/6047
        //
        //     {
        //         "transactID":"00000000-0000-0000-0000-000000000000",
        //         "account":121210,
        //         "currency":"XBt",
        //         "transactType":"UnrealisedPNL",
        //         "amount":-5508,
        //         "fee":0,
        //         "transactStatus":"Pending",
        //         "address":"XBTUSD",
        //         "tx":"",
        //         "text":"",
        //         "transactTime":null,  # â†---------------------------- null
        //         "walletBalance":139198767,
        //         "marginBalance":139193259,
        //         "timestamp":null  # â†---------------------------- null
        //     }
        //
        object id = this.safeString(item, "transactID");
        object account = this.safeString(item, "account");
        object referenceId = this.safeString(item, "tx");
        object referenceAccount = null;
        object type = this.parseLedgerEntryType(this.safeString(item, "transactType"));
        object currencyId = this.safeString(item, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object amountString = this.safeString(item, "amount");
        object amount = this.convertToRealAmount(code, amountString);
        object timestamp = this.parse8601(this.safeString(item, "transactTime"));
        if (isTrue(isEqual(timestamp, null)))
        {
            // https://github.com/ccxt/ccxt/issues/6047
            // set the timestamp to zero, 1970 Jan 1 00:00:00
            // for unrealized pnl and other transactions without a timestamp
            timestamp = 0; // see comments above
        }
        object feeCost = this.safeString(item, "fee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            feeCost = this.convertToRealAmount(code, feeCost);
        }
        object fee = new Dictionary<string, object>() {
            { "cost", this.parseNumber(feeCost) },
            { "currency", code },
        };
        object after = this.safeString(item, "walletBalance");
        if (isTrue(!isEqual(after, null)))
        {
            after = this.convertToRealAmount(code, after);
        }
        object before = this.parseNumber(Precise.stringSub(this.numberToString(after), this.numberToString(amount)));
        object direction = null;
        if (isTrue(Precise.stringLt(amountString, "0")))
        {
            direction = "out";
            amount = this.convertToRealAmount(code, Precise.stringAbs(amountString));
        } else
        {
            direction = "in";
        }
        object status = this.parseTransactionStatus(this.safeString(item, "transactStatus"));
        return new Dictionary<string, object>() {
            { "id", id },
            { "info", item },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "direction", direction },
            { "account", account },
            { "referenceId", referenceId },
            { "referenceAccount", referenceAccount },
            { "type", type },
            { "currency", code },
            { "amount", amount },
            { "before", before },
            { "after", this.parseNumber(after) },
            { "status", status },
            { "fee", fee },
        };
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @see https://www.bitmex.com/api/explorer/#!/User/User_getWalletHistory
        * @param {string} code unified currency code, default is undefined
        * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int} [limit] max number of ledger entrys to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        //
        //     if (since !== undefined) {
        //         // date-based pagination not supported
        //     }
        //
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["count"] = limit;
        }
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        object response = await this.privateGetUserWalletHistory(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "transactID": "69573da3-7744-5467-3207-89fd6efe7a47",
        //             "account":  24321,
        //             "currency": "XBt",
        //             "transactType": "Withdrawal", // "AffiliatePayout", "Transfer", "Deposit", "RealisedPNL", ...
        //             "amount":  -1000000,
        //             "fee":  300000,
        //             "transactStatus": "Completed", // "Canceled", ...
        //             "address": "1Ex4fkF4NhQaQdRWNoYpqiPbDBbq18Kdd9",
        //             "tx": "3BMEX91ZhhKoWtsH9QRb5dNXnmnGpiEetA",
        //             "text": "",
        //             "transactTime": "2017-03-21T20:05:14.388Z",
        //             "walletBalance":  0, // balance after
        //             "marginBalance":  null,
        //             "timestamp": "2017-03-22T13:09:23.514Z"
        //         }
        //     ]
        //
        return this.parseLedger(response, currency, since, limit);
    }

    public async override Task<object> fetchDepositsWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchDepositsWithdrawals
        * @description fetch history of deposits and withdrawals
        * @see https://www.bitmex.com/api/explorer/#!/User/User_getWalletHistory
        * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
        * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
        * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "currency", "all" },
        };
        //
        //     if (since !== undefined) {
        //         // date-based pagination not supported
        //     }
        //
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["count"] = limit;
        }
        object response = await this.privateGetUserWalletHistory(this.extend(request, parameters));
        object transactions = this.filterByArray(response, "transactType", new List<object>() {"Withdrawal", "Deposit"}, false);
        return this.parseTransactions(transactions, currency, since, limit);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "Confirmed", "pending" },
            { "Canceled", "canceled" },
            { "Completed", "ok" },
            { "Pending", "pending" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        //    {
        //        "transactID": "ffe699c2-95ee-4c13-91f9-0faf41daec25",
        //        "account": 123456,
        //        "currency": "XBt",
        //        "network":'', // "tron" for USDt, etc...
        //        "transactType": "Withdrawal",
        //        "amount": -100100000,
        //        "fee": 100000,
        //        "transactStatus": "Completed",
        //        "address": "385cR5DM96n1HvBDMzLHPYcw89fZAXULJP",
        //        "tx": "3BMEXabcdefghijklmnopqrstuvwxyz123",
        //        "text": '',
        //        "transactTime": "2019-01-02T01:00:00.000Z",
        //        "walletBalance": 99900000, // this field might be inexistent
        //        "marginBalance": None, // this field might be inexistent
        //        "timestamp": "2019-01-02T13:00:00.000Z"
        //    }
        //
        object currencyId = this.safeString(transaction, "currency");
        currency = this.safeCurrency(currencyId, currency);
        // For deposits, transactTime == timestamp
        // For withdrawals, transactTime is submission, timestamp is processed
        object transactTime = this.parse8601(this.safeString(transaction, "transactTime"));
        object timestamp = this.parse8601(this.safeString(transaction, "timestamp"));
        object type = this.safeStringLower(transaction, "transactType");
        // Deposits have no from address or to address, withdrawals have both
        object address = null;
        object addressFrom = null;
        object addressTo = null;
        if (isTrue(isEqual(type, "withdrawal")))
        {
            address = this.safeString(transaction, "address");
            addressFrom = this.safeString(transaction, "tx");
            addressTo = address;
        } else if (isTrue(isEqual(type, "deposit")))
        {
            addressTo = this.safeString(transaction, "address");
            addressFrom = this.safeString(transaction, "tx");
        }
        object amountString = this.safeString(transaction, "amount");
        object amountStringAbs = Precise.stringAbs(amountString);
        object amount = this.convertToRealAmount(getValue(currency, "code"), amountStringAbs);
        object feeCostString = this.safeString(transaction, "fee");
        object feeCost = this.convertToRealAmount(getValue(currency, "code"), feeCostString);
        object status = this.safeString(transaction, "transactStatus");
        if (isTrue(!isEqual(status, null)))
        {
            status = this.parseTransactionStatus(status);
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString(transaction, "transactID") },
            { "txid", this.safeString(transaction, "tx") },
            { "type", type },
            { "currency", getValue(currency, "code") },
            { "network", this.networkIdToCode(this.safeString(transaction, "network"), getValue(currency, "code")) },
            { "amount", this.parseNumber(amount) },
            { "status", status },
            { "timestamp", transactTime },
            { "datetime", this.iso8601(transactTime) },
            { "address", address },
            { "addressFrom", addressFrom },
            { "addressTo", addressTo },
            { "tag", null },
            { "tagFrom", null },
            { "tagTo", null },
            { "updated", timestamp },
            { "internal", null },
            { "comment", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", getValue(currency, "code") },
                { "cost", this.parseNumber(feeCost) },
                { "rate", null },
            } },
        };
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://www.bitmex.com/api/explorer/#!/Instrument/Instrument_get
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetInstrument(this.extend(request, parameters));
        object ticker = this.safeValue(response, 0);
        if (isTrue(isEqual(ticker, null)))
        {
            throw new BadSymbol ((string)add(add(add(this.id, " fetchTicker() symbol "), symbol), " not found")) ;
        }
        return this.parseTicker(ticker, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://www.bitmex.com/api/explorer/#!/Instrument/Instrument_getActiveAndIndices
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.publicGetInstrumentActiveAndIndices(parameters);
        // same response as under "fetchMarkets"
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object ticker = this.parseTicker(getValue(response, i));
            object symbol = this.safeString(ticker, "symbol");
            if (isTrue(!isEqual(symbol, null)))
            {
                ((IDictionary<string,object>)result)[(string)symbol] = ticker;
            }
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        // see response sample under "fetchMarkets" because same endpoint is being used here
        object marketId = this.safeString(ticker, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object timestamp = this.parse8601(this.safeString(ticker, "timestamp"));
        object open = this.safeString(ticker, "prevPrice24h");
        object last = this.safeString(ticker, "lastPrice");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "highPrice") },
            { "low", this.safeString(ticker, "lowPrice") },
            { "bid", this.safeString(ticker, "bidPrice") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "askPrice") },
            { "askVolume", null },
            { "vwap", this.safeString(ticker, "vwap") },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "homeNotional24h") },
            { "quoteVolume", this.safeString(ticker, "foreignNotional24h") },
            { "info", ticker },
        }, market);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "timestamp":"2015-09-25T13:38:00.000Z",
        //         "symbol":"XBTUSD",
        //         "open":237.45,
        //         "high":237.45,
        //         "low":237.45,
        //         "close":237.45,
        //         "trades":0,
        //         "volume":0,
        //         "vwap":null,
        //         "lastSize":null,
        //         "turnover":0,
        //         "homeNotional":0,
        //         "foreignNotional":0
        //     }
        //
        object marketId = this.safeString(ohlcv, "symbol");
        market = this.safeMarket(marketId, market);
        object volume = this.convertFromRawQuantity(getValue(market, "symbol"), this.safeString(ohlcv, "volume"));
        return new List<object> {this.parse8601(this.safeString(ohlcv, "timestamp")), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), volume};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://www.bitmex.com/api/explorer/#!/Trade/Trade_getBucketed
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters);
        }
        // send JSON key/value pairs, such as {"key": "value"}
        // filter by individual fields and do advanced queries on timestamps
        // let filter = { 'key': 'value' };
        // send a bare series (e.g. XBU) to nearest expiring contract in that series
        // you can also send a timeframe, e.g. XBU:monthly
        // timeframes: daily, weekly, monthly, quarterly, and biquarterly
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "binSize", this.safeString(this.timeframes, timeframe, timeframe) },
            { "partial", true },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["count"] = limit; // default 100, max 500
        }
        object until = this.safeInteger2(parameters, "until", "endTime");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)["endTime"] = this.iso8601(until);
        }
        object duration = multiply(this.parseTimeframe(timeframe), 1000);
        object fetchOHLCVOpenTimestamp = this.safeValue(this.options, "fetchOHLCVOpenTimestamp", true);
        // if since is not set, they will return candles starting from 2017-01-01
        if (isTrue(!isEqual(since, null)))
        {
            object timestamp = since;
            if (isTrue(fetchOHLCVOpenTimestamp))
            {
                timestamp = this.sum(timestamp, duration);
            }
            object startTime = this.iso8601(timestamp);
            ((IDictionary<string,object>)request)["startTime"] = startTime; // starting date filter for results
        } else
        {
            ((IDictionary<string,object>)request)["reverse"] = true;
        }
        object response = await this.publicGetTradeBucketed(this.extend(request, parameters));
        //
        //     [
        //         {"timestamp":"2015-09-25T13:38:00.000Z","symbol":"XBTUSD","open":237.45,"high":237.45,"low":237.45,"close":237.45,"trades":0,"volume":0,"vwap":null,"lastSize":null,"turnover":0,"homeNotional":0,"foreignNotional":0},
        //         {"timestamp":"2015-09-25T13:39:00.000Z","symbol":"XBTUSD","open":237.45,"high":237.45,"low":237.45,"close":237.45,"trades":0,"volume":0,"vwap":null,"lastSize":null,"turnover":0,"homeNotional":0,"foreignNotional":0},
        //         {"timestamp":"2015-09-25T13:40:00.000Z","symbol":"XBTUSD","open":237.45,"high":237.45,"low":237.45,"close":237.45,"trades":0,"volume":0,"vwap":null,"lastSize":null,"turnover":0,"homeNotional":0,"foreignNotional":0}
        //     ]
        //
        object result = this.parseOHLCVs(response, market, timeframe, since, limit);
        if (isTrue(fetchOHLCVOpenTimestamp))
        {
            // bitmex returns the candle's close timestamp - https://github.com/ccxt/ccxt/issues/4446
            // we can emulate the open timestamp by shifting all the timestamps one place
            // so the previous close becomes the current open, and we drop the first candle
            for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
            {
                ((List<object>)getValue(result, i))[Convert.ToInt32(0)] = subtract(getValue(getValue(result, i), 0), duration);
            }
        }
        return result;
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //     {
        //         "timestamp": "2018-08-28T00:00:02.735Z",
        //         "symbol": "XBTUSD",
        //         "side": "Buy",
        //         "size": 2000,
        //         "price": 6906.5,
        //         "tickDirection": "PlusTick",
        //         "trdMatchID": "b9a42432-0a46-6a2f-5ecc-c32e9ca4baf8",
        //         "grossValue": 28958000,
        //         "homeNotional": 0.28958,
        //         "foreignNotional": 2000
        //     }
        //
        // fetchMyTrades (private)
        //
        //     {
        //         "execID": "string",
        //         "orderID": "string",
        //         "clOrdID": "string",
        //         "clOrdLinkID": "string",
        //         "account": 0,
        //         "symbol": "string",
        //         "side": "string",
        //         "lastQty": 0,
        //         "lastPx": 0,
        //         "underlyingLastPx": 0,
        //         "lastMkt": "string",
        //         "lastLiquidityInd": "string",
        //         "simpleOrderQty": 0,
        //         "orderQty": 0,
        //         "price": 0,
        //         "displayQty": 0,
        //         "stopPx": 0,
        //         "pegOffsetValue": 0,
        //         "pegPriceType": "string",
        //         "currency": "string",
        //         "settlCurrency": "string",
        //         "execType": "string",
        //         "ordType": "string",
        //         "timeInForce": "string",
        //         "execInst": "string",
        //         "contingencyType": "string",
        //         "exDestination": "string",
        //         "ordStatus": "string",
        //         "triggered": "string",
        //         "workingIndicator": true,
        //         "ordRejReason": "string",
        //         "simpleLeavesQty": 0,
        //         "leavesQty": 0,
        //         "simpleCumQty": 0,
        //         "cumQty": 0,
        //         "avgPx": 0,
        //         "commission": 0,
        //         "tradePublishIndicator": "string",
        //         "multiLegReportingType": "string",
        //         "text": "string",
        //         "trdMatchID": "string",
        //         "execCost": 0,
        //         "execComm": 0,
        //         "homeNotional": 0,
        //         "foreignNotional": 0,
        //         "transactTime": "2019-03-05T12:47:02.762Z",
        //         "timestamp": "2019-03-05T12:47:02.762Z"
        //     }
        //
        object marketId = this.safeString(trade, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object timestamp = this.parse8601(this.safeString(trade, "timestamp"));
        object priceString = this.safeString2(trade, "avgPx", "price");
        object amountString = this.convertFromRawQuantity(symbol, this.safeString2(trade, "size", "lastQty"));
        object execCost = this.numberToString(this.convertFromRawCost(symbol, this.safeString(trade, "execCost")));
        object id = this.safeString(trade, "trdMatchID");
        object order = this.safeString(trade, "orderID");
        object side = this.safeStringLower(trade, "side");
        // price * amount doesn't work for all symbols (e.g. XBT, ETH)
        object fee = null;
        object feeCostString = this.numberToString(this.convertFromRawCost(symbol, this.safeString(trade, "execComm")));
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object currencyId = this.safeString2(trade, "settlCurrency", "currency");
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", this.safeCurrencyCode(currencyId) },
                { "rate", this.safeString(trade, "commission") },
            };
        }
        // Trade or Funding
        object execType = this.safeString(trade, "execType");
        object takerOrMaker = null;
        if (isTrue(isTrue(!isEqual(feeCostString, null)) && isTrue(isEqual(execType, "Trade"))))
        {
            takerOrMaker = ((bool) isTrue(Precise.stringLt(feeCostString, "0"))) ? "maker" : "taker";
        }
        object type = this.safeStringLower(trade, "ordType");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", id },
            { "order", order },
            { "type", type },
            { "takerOrMaker", takerOrMaker },
            { "side", side },
            { "price", priceString },
            { "cost", Precise.stringAbs(execCost) },
            { "amount", amountString },
            { "fee", fee },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "New", "open" },
            { "PartiallyFilled", "open" },
            { "Filled", "closed" },
            { "DoneForDay", "open" },
            { "Canceled", "canceled" },
            { "PendingCancel", "open" },
            { "PendingNew", "open" },
            { "Rejected", "rejected" },
            { "Expired", "expired" },
            { "Stopped", "open" },
            { "Untriggered", "open" },
            { "Triggered", "open" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseTimeInForce(object timeInForce)
    {
        object timeInForces = new Dictionary<string, object>() {
            { "Day", "Day" },
            { "GoodTillCancel", "GTC" },
            { "ImmediateOrCancel", "IOC" },
            { "FillOrKill", "FOK" },
        };
        return this.safeString(timeInForces, timeInForce, timeInForce);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        //     {
        //         "orderID":"56222c7a-9956-413a-82cf-99f4812c214b",
        //         "clOrdID":"",
        //         "clOrdLinkID":"",
        //         "account":1455728,
        //         "symbol":"XBTUSD",
        //         "side":"Sell",
        //         "simpleOrderQty":null,
        //         "orderQty":1,
        //         "price":40000,
        //         "displayQty":null,
        //         "stopPx":null,
        //         "pegOffsetValue":null,
        //         "pegPriceType":"",
        //         "currency":"USD",
        //         "settlCurrency":"XBt",
        //         "ordType":"Limit",
        //         "timeInForce":"GoodTillCancel",
        //         "execInst":"",
        //         "contingencyType":"",
        //         "exDestination":"XBME",
        //         "ordStatus":"New",
        //         "triggered":"",
        //         "workingIndicator":true,
        //         "ordRejReason":"",
        //         "simpleLeavesQty":null,
        //         "leavesQty":1,
        //         "simpleCumQty":null,
        //         "cumQty":0,
        //         "avgPx":null,
        //         "multiLegReportingType":"SingleSecurity",
        //         "text":"Submitted via API.",
        //         "transactTime":"2021-01-02T21:38:49.246Z",
        //         "timestamp":"2021-01-02T21:38:49.246Z"
        //     }
        //
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object qty = this.safeString(order, "orderQty");
        object cost = null;
        object amount = null;
        object isInverse = false;
        if (isTrue(isEqual(marketId, null)))
        {
            object defaultSubType = this.safeString(this.options, "defaultSubType", "linear");
            isInverse = (isEqual(defaultSubType, "inverse"));
        } else
        {
            isInverse = this.safeBool(market, "inverse", false);
        }
        if (isTrue(isInverse))
        {
            cost = this.convertFromRawQuantity(symbol, qty);
        } else
        {
            amount = this.convertFromRawQuantity(symbol, qty);
        }
        object average = this.safeString(order, "avgPx");
        object filled = null;
        object cumQty = this.numberToString(this.convertFromRawQuantity(symbol, this.safeString(order, "cumQty")));
        if (isTrue(isInverse))
        {
            filled = Precise.stringDiv(cumQty, average);
        } else
        {
            filled = cumQty;
        }
        object execInst = this.safeString(order, "execInst");
        object postOnly = null;
        if (isTrue(!isEqual(execInst, null)))
        {
            postOnly = (isEqual(execInst, "ParticipateDoNotInitiate"));
        }
        object timestamp = this.parse8601(this.safeString(order, "timestamp"));
        object stopPrice = this.safeNumber(order, "stopPx");
        object remaining = this.safeString(order, "leavesQty");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString(order, "orderID") },
            { "clientOrderId", this.safeString(order, "clOrdID") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", this.parse8601(this.safeString(order, "transactTime")) },
            { "symbol", symbol },
            { "type", this.safeStringLower(order, "ordType") },
            { "timeInForce", this.parseTimeInForce(this.safeString(order, "timeInForce")) },
            { "postOnly", postOnly },
            { "side", this.safeStringLower(order, "side") },
            { "price", this.safeString(order, "price") },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "amount", amount },
            { "cost", cost },
            { "average", average },
            { "filled", filled },
            { "remaining", this.convertFromRawQuantity(symbol, remaining) },
            { "status", this.parseOrderStatus(this.safeString(order, "ordStatus")) },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://www.bitmex.com/api/explorer/#!/Trade/Trade_get
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchTrades", symbol, since, limit, parameters);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = this.iso8601(since);
        } else
        {
            // by default reverse=false, i.e. trades are fetched since the time of market inception (year 2015 for XBTUSD)
            ((IDictionary<string,object>)request)["reverse"] = true;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["count"] = mathMin(limit, 1000); // api maximum 1000
        }
        object until = this.safeInteger2(parameters, "until", "endTime");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)["endTime"] = this.iso8601(until);
        }
        object response = await this.publicGetTrade(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "timestamp": "2018-08-28T00:00:02.735Z",
        //             "symbol": "XBTUSD",
        //             "side": "Buy",
        //             "size": 2000,
        //             "price": 6906.5,
        //             "tickDirection": "PlusTick",
        //             "trdMatchID": "b9a42432-0a46-6a2f-5ecc-c32e9ca4baf8",
        //             "grossValue": 28958000,
        //             "homeNotional": 0.28958,
        //             "foreignNotional": 2000
        //         },
        //         {
        //             "timestamp": "2018-08-28T00:00:03.778Z",
        //             "symbol": "XBTUSD",
        //             "side": "Sell",
        //             "size": 1000,
        //             "price": 6906,
        //             "tickDirection": "MinusTick",
        //             "trdMatchID": "0d4f1682-5270-a800-569b-4a0eb92db97c",
        //             "grossValue": 14480000,
        //             "homeNotional": 0.1448,
        //             "foreignNotional": 1000
        //         },
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#createOrder
        * @description create a trade order
        * @see https://www.bitmex.com/api/explorer/#!/Order/Order_new
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {object} [params.triggerPrice] the price at which a trigger order is triggered at
        * @param {object} [params.triggerDirection] the direction whenever the trigger happens with relation to price - 'above' or 'below'
        * @param {float} [params.trailingAmount] the quote amount to trail away from the current market price
        * @returns {object} an [order structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object orderType = this.capitalize(type);
        object reduceOnly = this.safeValue(parameters, "reduceOnly");
        if (isTrue(!isEqual(reduceOnly, null)))
        {
            if (isTrue(isTrue((!isTrue(getValue(market, "swap")))) && isTrue((!isTrue(getValue(market, "future"))))))
            {
                throw new InvalidOrder ((string)add(add(add(this.id, " createOrder() does not support reduceOnly for "), getValue(market, "type")), " orders, reduceOnly orders are supported for swap and future markets only")) ;
            }
        }
        object brokerId = this.safeString(this.options, "brokerId", "CCXT");
        object qty = this.parseToInt(this.amountToPrecision(symbol, amount));
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", this.capitalize(side) },
            { "orderQty", qty },
            { "ordType", orderType },
            { "text", brokerId },
        };
        // support for unified trigger format
        object triggerPrice = this.safeNumberN(parameters, new List<object>() {"triggerPrice", "stopPx", "stopPrice"});
        object trailingAmount = this.safeString2(parameters, "trailingAmount", "pegOffsetValue");
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object isTrailingAmountOrder = !isEqual(trailingAmount, null);
        if (isTrue(isTrue(isTriggerOrder) || isTrue(isTrailingAmountOrder)))
        {
            object triggerDirection = this.safeString(parameters, "triggerDirection");
            object triggerAbove = (isEqual(triggerDirection, "above"));
            if (isTrue(isTrue((isEqual(type, "limit"))) || isTrue((isEqual(type, "market")))))
            {
                this.checkRequiredArgument("createOrder", triggerDirection, "triggerDirection", new List<object>() {"above", "below"});
            }
            if (isTrue(isEqual(type, "limit")))
            {
                if (isTrue(isEqual(side, "buy")))
                {
                    orderType = ((bool) isTrue(triggerAbove)) ? "StopLimit" : "LimitIfTouched";
                } else
                {
                    orderType = ((bool) isTrue(triggerAbove)) ? "LimitIfTouched" : "StopLimit";
                }
            } else if (isTrue(isEqual(type, "market")))
            {
                if (isTrue(isEqual(side, "buy")))
                {
                    orderType = ((bool) isTrue(triggerAbove)) ? "Stop" : "MarketIfTouched";
                } else
                {
                    orderType = ((bool) isTrue(triggerAbove)) ? "MarketIfTouched" : "Stop";
                }
            }
            if (isTrue(isTrailingAmountOrder))
            {
                object isStopSellOrder = isTrue((isEqual(side, "sell"))) && isTrue((isTrue((isEqual(orderType, "Stop"))) || isTrue((isEqual(orderType, "StopLimit")))));
                object isBuyIfTouchedOrder = isTrue((isEqual(side, "buy"))) && isTrue((isTrue((isEqual(orderType, "MarketIfTouched"))) || isTrue((isEqual(orderType, "LimitIfTouched")))));
                if (isTrue(isTrue(isStopSellOrder) || isTrue(isBuyIfTouchedOrder)))
                {
                    trailingAmount = add("-", trailingAmount);
                }
                ((IDictionary<string,object>)request)["pegOffsetValue"] = this.parseToNumeric(trailingAmount);
                ((IDictionary<string,object>)request)["pegPriceType"] = "TrailingStopPeg";
            } else
            {
                if (isTrue(isEqual(triggerPrice, null)))
                {
                    throw new ArgumentsRequired ((string)add(add(add(this.id, " createOrder() requires a triggerPrice (stopPx|stopPrice) parameter for the "), orderType), " order type")) ;
                }
                ((IDictionary<string,object>)request)["stopPx"] = this.parseToNumeric(this.priceToPrecision(symbol, triggerPrice));
            }
            ((IDictionary<string,object>)request)["ordType"] = orderType;
            parameters = this.omit(parameters, new List<object>() {"triggerPrice", "stopPrice", "stopPx", "triggerDirection", "trailingAmount"});
        }
        if (isTrue(isTrue(isTrue((isEqual(orderType, "Limit"))) || isTrue((isEqual(orderType, "StopLimit")))) || isTrue((isEqual(orderType, "LimitIfTouched")))))
        {
            ((IDictionary<string,object>)request)["price"] = this.parseToNumeric(this.priceToPrecision(symbol, price));
        }
        object clientOrderId = this.safeString2(parameters, "clOrdID", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clOrdID"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId"});
        }
        object response = await this.privatePostOrder(this.extend(request, parameters));
        return this.parseOrder(response, market);
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object trailingAmount = this.safeString2(parameters, "trailingAmount", "pegOffsetValue");
        object isTrailingAmountOrder = !isEqual(trailingAmount, null);
        if (isTrue(isTrailingAmountOrder))
        {
            object triggerDirection = this.safeString(parameters, "triggerDirection");
            object triggerAbove = (isEqual(triggerDirection, "above"));
            if (isTrue(isTrue((isEqual(type, "limit"))) || isTrue((isEqual(type, "market")))))
            {
                this.checkRequiredArgument("createOrder", triggerDirection, "triggerDirection", new List<object>() {"above", "below"});
            }
            object orderType = null;
            if (isTrue(isEqual(type, "limit")))
            {
                if (isTrue(isEqual(side, "buy")))
                {
                    orderType = ((bool) isTrue(triggerAbove)) ? "StopLimit" : "LimitIfTouched";
                } else
                {
                    orderType = ((bool) isTrue(triggerAbove)) ? "LimitIfTouched" : "StopLimit";
                }
            } else if (isTrue(isEqual(type, "market")))
            {
                if (isTrue(isEqual(side, "buy")))
                {
                    orderType = ((bool) isTrue(triggerAbove)) ? "Stop" : "MarketIfTouched";
                } else
                {
                    orderType = ((bool) isTrue(triggerAbove)) ? "MarketIfTouched" : "Stop";
                }
            }
            object isStopSellOrder = isTrue((isEqual(side, "sell"))) && isTrue((isTrue((isEqual(orderType, "Stop"))) || isTrue((isEqual(orderType, "StopLimit")))));
            object isBuyIfTouchedOrder = isTrue((isEqual(side, "buy"))) && isTrue((isTrue((isEqual(orderType, "MarketIfTouched"))) || isTrue((isEqual(orderType, "LimitIfTouched")))));
            if (isTrue(isTrue(isStopSellOrder) || isTrue(isBuyIfTouchedOrder)))
            {
                trailingAmount = add("-", trailingAmount);
            }
            ((IDictionary<string,object>)request)["pegOffsetValue"] = this.parseToNumeric(trailingAmount);
            parameters = this.omit(parameters, new List<object>() {"triggerDirection", "trailingAmount"});
        }
        object origClOrdID = this.safeString2(parameters, "origClOrdID", "clientOrderId");
        if (isTrue(!isEqual(origClOrdID, null)))
        {
            ((IDictionary<string,object>)request)["origClOrdID"] = origClOrdID;
            object clientOrderId = this.safeString(parameters, "clOrdID", "clientOrderId");
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["clOrdID"] = clientOrderId;
            }
            parameters = this.omit(parameters, new List<object>() {"origClOrdID", "clOrdID", "clientOrderId"});
        } else
        {
            ((IDictionary<string,object>)request)["orderID"] = id;
        }
        if (isTrue(!isEqual(amount, null)))
        {
            object qty = this.parseToInt(this.amountToPrecision(symbol, amount));
            ((IDictionary<string,object>)request)["orderQty"] = qty;
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = price;
        }
        object brokerId = this.safeString(this.options, "brokerId", "CCXT");
        ((IDictionary<string,object>)request)["text"] = brokerId;
        object response = await this.privatePutOrder(this.extend(request, parameters));
        return this.parseOrder(response);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#cancelOrder
        * @description cancels an open order
        * @see https://www.bitmex.com/api/explorer/#!/Order/Order_cancel
        * @param {string} id order id
        * @param {string} symbol not used by bitmex cancelOrder ()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        // https://github.com/ccxt/ccxt/issues/6507
        object clientOrderId = this.safeValue2(parameters, "clOrdID", "clientOrderId");
        object request = new Dictionary<string, object>() {};
        if (isTrue(isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["orderID"] = id;
        } else
        {
            ((IDictionary<string,object>)request)["clOrdID"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId"});
        }
        object response = await this.privateDeleteOrder(this.extend(request, parameters));
        object order = this.safeValue(response, 0, new Dictionary<string, object>() {});
        object error = this.safeString(order, "error");
        if (isTrue(!isEqual(error, null)))
        {
            if (isTrue(isGreaterThanOrEqual(getIndexOf(error, "Unable to cancel order due to existing state"), 0)))
            {
                throw new OrderNotFound ((string)add(add(this.id, " cancelOrder() failed: "), error)) ;
            }
        }
        return this.parseOrder(order);
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#cancelOrders
        * @description cancel multiple orders
        * @see https://www.bitmex.com/api/explorer/#!/Order/Order_cancel
        * @param {string[]} ids order ids
        * @param {string} symbol not used by bitmex cancelOrders ()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        // return await this.cancelOrder (ids, symbol, params);
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        // https://github.com/ccxt/ccxt/issues/6507
        object clientOrderId = this.safeValue2(parameters, "clOrdID", "clientOrderId");
        object request = new Dictionary<string, object>() {};
        if (isTrue(isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["orderID"] = ids;
        } else
        {
            ((IDictionary<string,object>)request)["clOrdID"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId"});
        }
        object response = await this.privateDeleteOrder(this.extend(request, parameters));
        return this.parseOrders(response);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#cancelAllOrders
        * @description cancel all open orders
        * @see https://www.bitmex.com/api/explorer/#!/Order/Order_cancelAll
        * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object response = await this.privateDeleteOrderAll(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "orderID": "string",
        //             "clOrdID": "string",
        //             "clOrdLinkID": "string",
        //             "account": 0,
        //             "symbol": "string",
        //             "side": "string",
        //             "simpleOrderQty": 0,
        //             "orderQty": 0,
        //             "price": 0,
        //             "displayQty": 0,
        //             "stopPx": 0,
        //             "pegOffsetValue": 0,
        //             "pegPriceType": "string",
        //             "currency": "string",
        //             "settlCurrency": "string",
        //             "ordType": "string",
        //             "timeInForce": "string",
        //             "execInst": "string",
        //             "contingencyType": "string",
        //             "exDestination": "string",
        //             "ordStatus": "string",
        //             "triggered": "string",
        //             "workingIndicator": true,
        //             "ordRejReason": "string",
        //             "simpleLeavesQty": 0,
        //             "leavesQty": 0,
        //             "simpleCumQty": 0,
        //             "cumQty": 0,
        //             "avgPx": 0,
        //             "multiLegReportingType": "string",
        //             "text": "string",
        //             "transactTime": "2020-06-01T09:36:35.290Z",
        //             "timestamp": "2020-06-01T09:36:35.290Z"
        //         }
        //     ]
        //
        return this.parseOrders(response, market);
    }

    public async override Task<object> fetchLeverages(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchLeverages
        * @description fetch the set leverage for all contract markets
        * @see https://www.bitmex.com/api/explorer/#!/Position/Position_get
        * @param {string[]} [symbols] a list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [leverage structures]{@link https://docs.ccxt.com/#/?id=leverage-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object positions = await this.fetchPositions(symbols, parameters);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object entry = getValue(positions, i);
            object marketId = this.safeString(entry, "symbol");
            object market = this.safeMarket(marketId, null, null, "contract");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", getValue(market, "symbol") },
                { "leverage", this.safeInteger(entry, "leverage") },
                { "marginMode", this.safeString(entry, "marginMode") },
            });
        }
        return result;
    }

    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchLeverage
        * @description fetch the set leverage for a market
        * @see https://www.bitmex.com/api/explorer/#!/Position/Position_get
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object leverage = await this.fetchLeverages(new List<object>() {symbol}, parameters);
        return leverage;
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchPositions
        * @description fetch all open positions
        * @see https://www.bitmex.com/api/explorer/#!/Position/Position_get
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetPosition(parameters);
        //
        //     [
        //         {
        //             "account": 0,
        //             "symbol": "string",
        //             "currency": "string",
        //             "underlying": "string",
        //             "quoteCurrency": "string",
        //             "commission": 0,
        //             "initMarginReq": 0,
        //             "maintMarginReq": 0,
        //             "riskLimit": 0,
        //             "leverage": 0,
        //             "crossMargin": true,
        //             "deleveragePercentile": 0,
        //             "rebalancedPnl": 0,
        //             "prevRealisedPnl": 0,
        //             "prevUnrealisedPnl": 0,
        //             "prevClosePrice": 0,
        //             "openingTimestamp": "2020-11-09T06:53:59.892Z",
        //             "openingQty": 0,
        //             "openingCost": 0,
        //             "openingComm": 0,
        //             "openOrderBuyQty": 0,
        //             "openOrderBuyCost": 0,
        //             "openOrderBuyPremium": 0,
        //             "openOrderSellQty": 0,
        //             "openOrderSellCost": 0,
        //             "openOrderSellPremium": 0,
        //             "execBuyQty": 0,
        //             "execBuyCost": 0,
        //             "execSellQty": 0,
        //             "execSellCost": 0,
        //             "execQty": 0,
        //             "execCost": 0,
        //             "execComm": 0,
        //             "currentTimestamp": "2020-11-09T06:53:59.893Z",
        //             "currentQty": 0,
        //             "currentCost": 0,
        //             "currentComm": 0,
        //             "realisedCost": 0,
        //             "unrealisedCost": 0,
        //             "grossOpenCost": 0,
        //             "grossOpenPremium": 0,
        //             "grossExecCost": 0,
        //             "isOpen": true,
        //             "markPrice": 0,
        //             "markValue": 0,
        //             "riskValue": 0,
        //             "homeNotional": 0,
        //             "foreignNotional": 0,
        //             "posState": "string",
        //             "posCost": 0,
        //             "posCost2": 0,
        //             "posCross": 0,
        //             "posInit": 0,
        //             "posComm": 0,
        //             "posLoss": 0,
        //             "posMargin": 0,
        //             "posMaint": 0,
        //             "posAllowance": 0,
        //             "taxableMargin": 0,
        //             "initMargin": 0,
        //             "maintMargin": 0,
        //             "sessionMargin": 0,
        //             "targetExcessMargin": 0,
        //             "varMargin": 0,
        //             "realisedGrossPnl": 0,
        //             "realisedTax": 0,
        //             "realisedPnl": 0,
        //             "unrealisedGrossPnl": 0,
        //             "longBankrupt": 0,
        //             "shortBankrupt": 0,
        //             "taxBase": 0,
        //             "indicativeTaxRate": 0,
        //             "indicativeTax": 0,
        //             "unrealisedTax": 0,
        //             "unrealisedPnl": 0,
        //             "unrealisedPnlPcnt": 0,
        //             "unrealisedRoePcnt": 0,
        //             "simpleQty": 0,
        //             "simpleCost": 0,
        //             "simpleValue": 0,
        //             "simplePnl": 0,
        //             "simplePnlPcnt": 0,
        //             "avgCostPrice": 0,
        //             "avgEntryPrice": 0,
        //             "breakEvenPrice": 0,
        //             "marginCallPrice": 0,
        //             "liquidationPrice": 0,
        //             "bankruptPrice": 0,
        //             "timestamp": "2020-11-09T06:53:59.894Z",
        //             "lastPrice": 0,
        //             "lastValue": 0
        //         }
        //     ]
        //
        object results = this.parsePositions(response, symbols);
        return this.filterByArrayPositions(results, "symbol", symbols, false);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         "account": 9371654,
        //         "symbol": "ETHUSDT",
        //         "currency": "USDt",
        //         "underlying": "ETH",
        //         "quoteCurrency": "USDT",
        //         "commission": 0.00075,
        //         "initMarginReq": 0.3333333333333333,
        //         "maintMarginReq": 0.01,
        //         "riskLimit": 1000000000000,
        //         "leverage": 3,
        //         "crossMargin": false,
        //         "deleveragePercentile": 1,
        //         "rebalancedPnl": 0,
        //         "prevRealisedPnl": 0,
        //         "prevUnrealisedPnl": 0,
        //         "prevClosePrice": 2053.738,
        //         "openingTimestamp": "2022-05-21T04:00:00.000Z",
        //         "openingQty": 0,
        //         "openingCost": 0,
        //         "openingComm": 0,
        //         "openOrderBuyQty": 0,
        //         "openOrderBuyCost": 0,
        //         "openOrderBuyPremium": 0,
        //         "openOrderSellQty": 0,
        //         "openOrderSellCost": 0,
        //         "openOrderSellPremium": 0,
        //         "execBuyQty": 2000,
        //         "execBuyCost": 39260000,
        //         "execSellQty": 0,
        //         "execSellCost": 0,
        //         "execQty": 2000,
        //         "execCost": 39260000,
        //         "execComm": 26500,
        //         "currentTimestamp": "2022-05-21T04:35:16.397Z",
        //         "currentQty": 2000,
        //         "currentCost": 39260000,
        //         "currentComm": 26500,
        //         "realisedCost": 0,
        //         "unrealisedCost": 39260000,
        //         "grossOpenCost": 0,
        //         "grossOpenPremium": 0,
        //         "grossExecCost": 39260000,
        //         "isOpen": true,
        //         "markPrice": 1964.195,
        //         "markValue": 39283900,
        //         "riskValue": 39283900,
        //         "homeNotional": 0.02,
        //         "foreignNotional": -39.2839,
        //         "posState": "",
        //         "posCost": 39260000,
        //         "posCost2": 39260000,
        //         "posCross": 0,
        //         "posInit": 13086667,
        //         "posComm": 39261,
        //         "posLoss": 0,
        //         "posMargin": 13125928,
        //         "posMaint": 435787,
        //         "posAllowance": 0,
        //         "taxableMargin": 0,
        //         "initMargin": 0,
        //         "maintMargin": 13149828,
        //         "sessionMargin": 0,
        //         "targetExcessMargin": 0,
        //         "varMargin": 0,
        //         "realisedGrossPnl": 0,
        //         "realisedTax": 0,
        //         "realisedPnl": -26500,
        //         "unrealisedGrossPnl": 23900,
        //         "longBankrupt": 0,
        //         "shortBankrupt": 0,
        //         "taxBase": 0,
        //         "indicativeTaxRate": null,
        //         "indicativeTax": 0,
        //         "unrealisedTax": 0,
        //         "unrealisedPnl": 23900,
        //         "unrealisedPnlPcnt": 0.0006,
        //         "unrealisedRoePcnt": 0.0018,
        //         "simpleQty": null,
        //         "simpleCost": null,
        //         "simpleValue": null,
        //         "simplePnl": null,
        //         "simplePnlPcnt": null,
        //         "avgCostPrice": 1963,
        //         "avgEntryPrice": 1963,
        //         "breakEvenPrice": 1964.35,
        //         "marginCallPrice": 1328.5,
        //         "liquidationPrice": 1328.5,
        //         "bankruptPrice": 1308.7,
        //         "timestamp": "2022-05-21T04:35:16.397Z",
        //         "lastPrice": 1964.195,
        //         "lastValue": 39283900
        //     }
        //
        market = this.safeMarket(this.safeString(position, "symbol"), market);
        object symbol = getValue(market, "symbol");
        object datetime = this.safeString(position, "timestamp");
        object crossMargin = this.safeValue(position, "crossMargin");
        object marginMode = ((bool) isTrue((isEqual(crossMargin, true)))) ? "cross" : "isolated";
        object notionalString = Precise.stringAbs(this.safeString2(position, "foreignNotional", "homeNotional"));
        object settleCurrencyCode = this.safeString(market, "settle");
        object maintenanceMargin = this.convertToRealAmount(settleCurrencyCode, this.safeString(position, "maintMargin"));
        object unrealisedPnl = this.convertToRealAmount(settleCurrencyCode, this.safeString(position, "unrealisedPnl"));
        object contracts = this.parseNumber(Precise.stringAbs(this.safeString(position, "currentQty")));
        object contractSize = this.safeNumber(market, "contractSize");
        object side = null;
        object homeNotional = this.safeString(position, "homeNotional");
        if (isTrue(!isEqual(homeNotional, null)))
        {
            if (isTrue(isEqual(getValue(homeNotional, 0), "-")))
            {
                side = "short";
            } else
            {
                side = "long";
            }
        }
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", this.safeString(position, "account") },
            { "symbol", symbol },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "lastUpdateTimestamp", null },
            { "hedged", null },
            { "side", side },
            { "contracts", contracts },
            { "contractSize", contractSize },
            { "entryPrice", this.safeNumber(position, "avgEntryPrice") },
            { "markPrice", this.safeNumber(position, "markPrice") },
            { "lastPrice", null },
            { "notional", this.parseNumber(notionalString) },
            { "leverage", this.safeNumber(position, "leverage") },
            { "collateral", null },
            { "initialMargin", this.safeNumber(position, "initMargin") },
            { "initialMarginPercentage", this.safeNumber(position, "initMarginReq") },
            { "maintenanceMargin", maintenanceMargin },
            { "maintenanceMarginPercentage", this.safeNumber(position, "maintMarginReq") },
            { "unrealizedPnl", unrealisedPnl },
            { "liquidationPrice", this.safeNumber(position, "liquidationPrice") },
            { "marginMode", marginMode },
            { "marginRatio", null },
            { "percentage", this.safeNumber(position, "unrealisedPnlPcnt") },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#withdraw
        * @description make a withdrawal
        * @see https://www.bitmex.com/api/explorer/#!/User/User_requestWithdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object qty = this.convertFromRealAmount(code, amount);
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", qty },
            { "address", address },
            { "network", this.networkCodeToId(networkCode, getValue(currency, "code")) },
        };
        object response = await this.privatePostUserRequestWithdrawal(this.extend(request, parameters));
        //
        //     {
        //         "transactID": "3aece414-bb29-76c8-6c6d-16a477a51a1e",
        //         "account": 1403035,
        //         "currency": "USDt",
        //         "network": "tron",
        //         "transactType": "Withdrawal",
        //         "amount": -11000000,
        //         "fee": 1000000,
        //         "transactStatus": "Pending",
        //         "address": "TAf5JxcAQQsC2Nm2zu21XE2iDtnisxPo1x",
        //         "tx": "",
        //         "text": "",
        //         "transactTime": "2022-12-16T07:37:06.500Z",
        //         "timestamp": "2022-12-16T07:37:06.500Z",
        //     }
        //
        return this.parseTransaction(response, currency);
    }

    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchFundingRates
        * @description fetch the funding rate for multiple markets
        * @see https://www.bitmex.com/api/explorer/#!/Instrument/Instrument_getActiveAndIndices
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [funding rates structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexe by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetInstrumentActiveAndIndices(parameters);
        // same response as under "fetchMarkets"
        object filteredResponse = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object item = getValue(response, i);
            object marketId = this.safeString(item, "symbol");
            object market = this.safeMarket(marketId);
            object swap = this.safeBool(market, "swap", false);
            if (isTrue(swap))
            {
                ((IList<object>)filteredResponse).Add(item);
            }
        }
        symbols = this.marketSymbols(symbols);
        object result = this.parseFundingRates(filteredResponse);
        return this.filterByArray(result, "symbol", symbols);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        // see response sample under "fetchMarkets" because same endpoint is being used here
        object datetime = this.safeString(contract, "timestamp");
        object marketId = this.safeString(contract, "symbol");
        object fundingDatetime = this.safeString(contract, "fundingTimestamp");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", this.safeSymbol(marketId, market) },
            { "markPrice", this.safeNumber(contract, "markPrice") },
            { "indexPrice", null },
            { "interestRate", null },
            { "estimatedSettlePrice", this.safeNumber(contract, "indicativeSettlePrice") },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "fundingRate", this.safeNumber(contract, "fundingRate") },
            { "fundingTimestamp", this.iso8601(fundingDatetime) },
            { "fundingDatetime", fundingDatetime },
            { "nextFundingRate", this.safeNumber(contract, "indicativeFundingRate") },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchFundingRateHistory
        * @description Fetches the history of funding rates
        * @see https://www.bitmex.com/api/explorer/#!/Funding/Funding_get
        * @param {string} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
        * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp in ms for ending date filter
        * @param {bool} [params.reverse] if true, will sort results newest first
        * @param {int} [params.start] starting point for results
        * @param {string} [params.columns] array of column names to fetch in info, if omitted, will return all columns
        * @param {string} [params.filter] generic table filter, send json key/value pairs, such as {"key": "value"}, you can key on individual fields, and do more advanced querying on timestamps, see the [timestamp docs]{@link https://www.bitmex.com/app/restAPI#Timestamp-Filters} for more details
        * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(inOp(this.currencies, symbol)))
        {
            object code = this.currency(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(code, "id");
        } else if (isTrue(!isEqual(symbol, null)))
        {
            object splitSymbol = ((string)symbol).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
            object splitSymbolLength = getArrayLength(splitSymbol);
            object timeframes = new List<object>() {"nearest", "daily", "weekly", "monthly", "quarterly", "biquarterly", "perpetual"};
            if (isTrue(isTrue((isGreaterThan(splitSymbolLength, 1))) && isTrue(this.inArray(getValue(splitSymbol, 1), timeframes))))
            {
                object code = this.currency(getValue(splitSymbol, 0));
                symbol = add(add(getValue(code, "id"), ":"), getValue(splitSymbol, 1));
                ((IDictionary<string,object>)request)["symbol"] = symbol;
            } else
            {
                market = this.market(symbol);
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["count"] = limit;
        }
        object until = this.safeInteger2(parameters, "until", "till");
        parameters = this.omit(parameters, new List<object>() {"until", "till"});
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = this.iso8601(until);
        }
        ((IDictionary<string,object>)request)["reverse"] = true;
        object response = await this.publicGetFunding(this.extend(request, parameters));
        //
        //    [
        //        {
        //            "timestamp": "2016-05-07T12:00:00.000Z",
        //            "symbol": "ETHXBT",
        //            "fundingInterval": "2000-01-02T00:00:00.000Z",
        //            "fundingRate": 0.0010890000000000001,
        //            "fundingRateDaily": 0.0010890000000000001
        //        }
        //    ]
        //
        return this.parseFundingRateHistories(response, market, since, limit);
    }

    public override object parseFundingRateHistory(object info, object market = null)
    {
        //
        //    {
        //        "timestamp": "2016-05-07T12:00:00.000Z",
        //        "symbol": "ETHXBT",
        //        "fundingInterval": "2000-01-02T00:00:00.000Z",
        //        "fundingRate": 0.0010890000000000001,
        //        "fundingRateDaily": 0.0010890000000000001
        //    }
        //
        object marketId = this.safeString(info, "symbol");
        object datetime = this.safeString(info, "timestamp");
        return new Dictionary<string, object>() {
            { "info", info },
            { "symbol", this.safeSymbol(marketId, market) },
            { "fundingRate", this.safeNumber(info, "fundingRate") },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
        };
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#setLeverage
        * @description set the level of leverage for a market
        * @see https://www.bitmex.com/api/explorer/#!/Position/Position_updateLeverage
        * @param {float} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        if (isTrue(isTrue((isLessThan(leverage, 0.01))) || isTrue((isGreaterThan(leverage, 100)))))
        {
            throw new BadRequest ((string)add(this.id, " leverage should be between 0.01 and 100")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(isTrue(!isEqual(getValue(market, "type"), "swap")) && isTrue(!isEqual(getValue(market, "type"), "future"))))
        {
            throw new BadSymbol ((string)add(this.id, " setLeverage() supports future and swap contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "leverage", leverage },
        };
        return await this.privatePostPositionLeverage(this.extend(request, parameters));
    }

    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#setMarginMode
        * @description set margin mode to 'cross' or 'isolated'
        * @see https://www.bitmex.com/api/explorer/#!/Position/Position_isolateMargin
        * @param {string} marginMode 'cross' or 'isolated'
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        marginMode = ((string)marginMode).ToLower();
        if (isTrue(isTrue(!isEqual(marginMode, "isolated")) && isTrue(!isEqual(marginMode, "cross"))))
        {
            throw new BadRequest ((string)add(this.id, " setMarginMode() marginMode argument should be isolated or cross")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(isTrue((!isEqual(getValue(market, "type"), "swap"))) && isTrue((!isEqual(getValue(market, "type"), "future")))))
        {
            throw new BadSymbol ((string)add(this.id, " setMarginMode() supports swap and future contracts only")) ;
        }
        object enabled = ((bool) isTrue((isEqual(marginMode, "cross")))) ? false : true;
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "enabled", enabled },
        };
        return await this.privatePostPositionIsolate(this.extend(request, parameters));
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://www.bitmex.com/api/explorer/#!/User/User_getDepositAddress
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.network] deposit chain, can view all chains via this.publicGetWalletAssets, default is eth, unless the currency has a default chain within this.options['networks']
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(isEqual(networkCode, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDepositAddress requires params[\"network\"]")) ;
        }
        object currency = this.currency(code);
        parameters = this.omit(parameters, "network");
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "network", this.networkCodeToId(networkCode, getValue(currency, "code")) },
        };
        object response = await this.privateGetUserDepositAddress(this.extend(request, parameters));
        //
        //    '"bc1qmex3puyrzn2gduqcnlu70c2uscpyaa9nm2l2j9le2lt2wkgmw33sy7ndjg"'
        //
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", ((string)((string)response).Replace((string)"\"", (string)"")).Replace((string)"\"", (string)"") },
            { "tag", null },
            { "network", networkCode },
            { "info", response },
        };
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //    {
        //        "asset": "XBT",
        //        "currency": "XBt",
        //        "majorCurrency": "XBT",
        //        "name": "Bitcoin",
        //        "currencyType": "Crypto",
        //        "scale": "8",
        //        "enabled": true,
        //        "isMarginCurrency": true,
        //        "minDepositAmount": "10000",
        //        "minWithdrawalAmount": "1000",
        //        "maxWithdrawalAmount": "100000000000000",
        //        "networks": [
        //            {
        //                "asset": "btc",
        //                "tokenAddress": '',
        //                "depositEnabled": true,
        //                "withdrawalEnabled": true,
        //                "withdrawalFee": "20000",
        //                "minFee": "20000",
        //                "maxFee": "10000000"
        //            }
        //        ]
        //    }
        //
        object networks = this.safeValue(fee, "networks", new List<object>() {});
        object networksLength = getArrayLength(networks);
        object result = new Dictionary<string, object>() {
            { "info", fee },
            { "withdraw", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
        if (isTrue(!isEqual(networksLength, 0)))
        {
            object scale = this.safeString(fee, "scale");
            object precision = this.parsePrecision(scale);
            for (object i = 0; isLessThan(i, networksLength); postFixIncrement(ref i))
            {
                object network = getValue(networks, i);
                object networkId = this.safeString(network, "asset");
                object currencyCode = this.safeString(currency, "code");
                object networkCode = this.networkIdToCode(networkId, currencyCode);
                object withdrawalFeeId = this.safeString(network, "withdrawalFee");
                object withdrawalFee = this.parseNumber(Precise.stringMul(withdrawalFeeId, precision));
                ((IDictionary<string,object>)getValue(result, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                    { "deposit", new Dictionary<string, object>() {
                        { "fee", null },
                        { "percentage", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "fee", withdrawalFee },
                        { "percentage", false },
                    } },
                };
                if (isTrue(isEqual(networksLength, 1)))
                {
                    ((IDictionary<string,object>)getValue(result, "withdraw"))["fee"] = withdrawalFee;
                    ((IDictionary<string,object>)getValue(result, "withdraw"))["percentage"] = false;
                }
            }
        }
        return result;
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://www.bitmex.com/api/explorer/#!/Wallet/Wallet_getAssetsConfig
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object assets = await this.publicGetWalletAssets(parameters);
        //
        //    [
        //        {
        //            "asset": "XBT",
        //            "currency": "XBt",
        //            "majorCurrency": "XBT",
        //            "name": "Bitcoin",
        //            "currencyType": "Crypto",
        //            "scale": "8",
        //            "enabled": true,
        //            "isMarginCurrency": true,
        //            "minDepositAmount": "10000",
        //            "minWithdrawalAmount": "1000",
        //            "maxWithdrawalAmount": "100000000000000",
        //            "networks": [
        //                {
        //                    "asset": "btc",
        //                    "tokenAddress": '',
        //                    "depositEnabled": true,
        //                    "withdrawalEnabled": true,
        //                    "withdrawalFee": "20000",
        //                    "minFee": "20000",
        //                    "maxFee": "10000000"
        //                }
        //            ]
        //        },
        //        ...
        //    ]
        //
        return this.parseDepositWithdrawFees(assets, codes, "asset");
    }

    public override object calculateRateLimiterCost(object api, object method, object path, object parameters, object config = null)
    {
        config ??= new Dictionary<string, object>();
        object isAuthenticated = this.checkRequiredCredentials(false);
        object cost = this.safeValue(config, "cost", 1);
        if (isTrue(!isEqual(cost, 1)))
        {
            if (isTrue(isAuthenticated))
            {
                return cost;
            } else
            {
                return 20;
            }
        }
        return cost;
    }

    public async override Task<object> fetchLiquidations(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmex#fetchLiquidations
        * @description retrieves the public liquidations of a trading pair
        * @see https://www.bitmex.com/api/explorer/#!/Liquidation/Liquidation_get
        * @param {string} symbol unified CCXT market symbol
        * @param {int} [since] the earliest time in ms to fetch liquidations for
        * @param {int} [limit] the maximum number of liquidation structures to retrieve
        * @param {object} [params] exchange specific parameters for the bitmex api endpoint
        * @param {int} [params.until] timestamp in ms of the latest liquidation
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object} an array of [liquidation structures]{@link https://docs.ccxt.com/#/?id=liquidation-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchLiquidations", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchLiquidations", symbol, since, limit, parameters);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["count"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.publicGetLiquidation(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "orderID": "string",
        //             "symbol": "string",
        //             "side": "string",
        //             "price": 0,
        //             "leavesQty": 0
        //         }
        //     ]
        //
        return this.parseLiquidations(response, market, since, limit);
    }

    public override object parseLiquidation(object liquidation, object market = null)
    {
        //
        //     {
        //         "orderID": "string",
        //         "symbol": "string",
        //         "side": "string",
        //         "price": 0,
        //         "leavesQty": 0
        //     }
        //
        object marketId = this.safeString(liquidation, "symbol");
        return this.safeLiquidation(new Dictionary<string, object>() {
            { "info", liquidation },
            { "symbol", this.safeSymbol(marketId, market) },
            { "contracts", null },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "price", this.safeNumber(liquidation, "price") },
            { "baseValue", null },
            { "quoteValue", null },
            { "timestamp", null },
            { "datetime", null },
        });
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        if (isTrue(isEqual(code, 429)))
        {
            throw new DDoSProtection ((string)add(add(this.id, " "), body)) ;
        }
        if (isTrue(isGreaterThanOrEqual(code, 400)))
        {
            object error = this.safeValue(response, "error", new Dictionary<string, object>() {});
            object message = this.safeString(error, "message");
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            if (isTrue(isEqual(code, 400)))
            {
                throw new BadRequest ((string)feedback) ;
            }
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object query = add(add(add("/api/", this.version), "/"), path);
        if (isTrue(isEqual(method, "GET")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                query = add(query, add("?", this.urlencode(parameters)));
            }
        } else
        {
            object format = this.safeString(parameters, "_format");
            if (isTrue(!isEqual(format, null)))
            {
                query = add(query, add("?", this.urlencode(new Dictionary<string, object>() {
    { "_format", format },
})));
                parameters = this.omit(parameters, "_format");
            }
        }
        object url = add(getValue(getValue(this.urls, "api"), api), query);
        object isAuthenticated = this.checkRequiredCredentials(false);
        if (isTrue(isTrue(isEqual(api, "private")) || isTrue((isTrue(isEqual(api, "public")) && isTrue(isAuthenticated)))))
        {
            this.checkRequiredCredentials();
            object auth = add(method, query);
            object expires = this.safeInteger(this.options, "api-expires");
            headers = new Dictionary<string, object>() {
                { "Content-Type", "application/json" },
                { "api-key", this.apiKey },
            };
            expires = this.sum(this.seconds(), expires);
            object stringExpires = ((object)expires).ToString();
            auth = add(auth, stringExpires);
            ((IDictionary<string,object>)headers)["api-expires"] = stringExpires;
            if (isTrue(isTrue(isTrue(isEqual(method, "POST")) || isTrue(isEqual(method, "PUT"))) || isTrue(isEqual(method, "DELETE"))))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
                {
                    body = this.json(parameters);
                    auth = add(auth, body);
                }
            }
            ((IDictionary<string,object>)headers)["api-signature"] = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }
}
