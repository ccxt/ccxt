namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class kraken : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "kraken" },
            { "name", "Kraken" },
            { "countries", new List<object>() {"US"} },
            { "version", "0" },
            { "rateLimit", 1000 },
            { "certified", false },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", true },
                { "cancelAllOrdersAfter", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "createDepositAddress", true },
                { "createOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "createTrailingAmountOrder", true },
                { "editOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLedger", true },
                { "fetchLedgerEntry", true },
                { "fetchLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderTrades", "emulated" },
                { "fetchPositions", true },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchWithdrawals", true },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", 1 },
                { "5m", 5 },
                { "15m", 15 },
                { "30m", 30 },
                { "1h", 60 },
                { "4h", 240 },
                { "1d", 1440 },
                { "1w", 10080 },
                { "2w", 21600 },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/51840849/76173629-fc67fb00-61b1-11ea-84fe-f2de582f58a3.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.kraken.com" },
                    { "private", "https://api.kraken.com" },
                    { "zendesk", "https://kraken.zendesk.com/api/v2/help_center/en-us/articles" },
                } },
                { "www", "https://www.kraken.com" },
                { "doc", "https://docs.kraken.com/rest/" },
                { "fees", "https://www.kraken.com/en-us/features/fee-schedule" },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.0026") },
                    { "maker", this.parseNumber("0.0016") },
                    { "tiers", new Dictionary<string, object>() {
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0026")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.0024")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.0022")}, new List<object> {this.parseNumber("250000"), this.parseNumber("0.0020")}, new List<object> {this.parseNumber("500000"), this.parseNumber("0.0018")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.0016")}, new List<object> {this.parseNumber("2500000"), this.parseNumber("0.0014")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0.0001")}} },
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0016")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.0014")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("250000"), this.parseNumber("0.0010")}, new List<object> {this.parseNumber("500000"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("2500000"), this.parseNumber("0.0004")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.0002")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0.0")}} },
                    } },
                } },
            } },
            { "handleContentTypeApplicationZip", true },
            { "api", new Dictionary<string, object>() {
                { "zendesk", new Dictionary<string, object>() {
                    { "get", new List<object>() {"360000292886", "201893608"} },
                } },
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "Assets", 1 },
                        { "AssetPairs", 1 },
                        { "Depth", 1 },
                        { "OHLC", 1 },
                        { "Spread", 1 },
                        { "SystemStatus", 1 },
                        { "Ticker", 1 },
                        { "Time", 1 },
                        { "Trades", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "post", new Dictionary<string, object>() {
                        { "AddOrder", 0 },
                        { "AddOrderBatch", 0 },
                        { "AddExport", 3 },
                        { "Balance", 3 },
                        { "CancelAll", 3 },
                        { "CancelAllOrdersAfter", 3 },
                        { "CancelOrder", 0 },
                        { "CancelOrderBatch", 0 },
                        { "ClosedOrders", 3 },
                        { "DepositAddresses", 3 },
                        { "DepositMethods", 3 },
                        { "DepositStatus", 3 },
                        { "EditOrder", 0 },
                        { "ExportStatus", 3 },
                        { "GetWebSocketsToken", 3 },
                        { "Ledgers", 6 },
                        { "OpenOrders", 3 },
                        { "OpenPositions", 3 },
                        { "QueryLedgers", 3 },
                        { "QueryOrders", 3 },
                        { "QueryTrades", 3 },
                        { "RetrieveExport", 3 },
                        { "RemoveExport", 3 },
                        { "BalanceEx", 3 },
                        { "TradeBalance", 3 },
                        { "TradesHistory", 6 },
                        { "TradeVolume", 3 },
                        { "Withdraw", 3 },
                        { "WithdrawCancel", 3 },
                        { "WithdrawInfo", 3 },
                        { "WithdrawMethods", 3 },
                        { "WithdrawAddresses", 3 },
                        { "WithdrawStatus", 3 },
                        { "WalletTransfer", 3 },
                        { "CreateSubaccount", 3 },
                        { "AccountTransfer", 3 },
                        { "Earn/Allocate", 3 },
                        { "Earn/Deallocate", 3 },
                        { "Earn/AllocateStatus", 3 },
                        { "Earn/DeallocateStatus", 3 },
                        { "Earn/Strategies", 3 },
                        { "Earn/Allocations", 3 },
                    } },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "LUNA", "LUNC" },
                { "LUNA2", "LUNA" },
                { "REPV2", "REP" },
                { "REP", "REPV1" },
                { "UST", "USTC" },
                { "XBT", "BTC" },
                { "XBT.M", "BTC.M" },
                { "XDG", "DOGE" },
            } },
            { "options", new Dictionary<string, object>() {
                { "marketsByAltname", new Dictionary<string, object>() {} },
                { "delistedMarketsById", new Dictionary<string, object>() {} },
                { "inactiveCurrencies", new List<object>() {"CAD", "USD", "JPY", "GBP"} },
                { "networks", new Dictionary<string, object>() {
                    { "ETH", "ERC20" },
                    { "TRX", "TRC20" },
                } },
                { "depositMethods", new Dictionary<string, object>() {
                    { "1INCH", "1inch (1INCH)" },
                    { "AAVE", "Aave" },
                    { "ADA", "ADA" },
                    { "ALGO", "Algorand" },
                    { "ANKR", "ANKR (ANKR)" },
                    { "ANT", "Aragon (ANT)" },
                    { "ATOM", "Cosmos" },
                    { "AXS", "Axie Infinity Shards (AXS)" },
                    { "BADGER", "Bager DAO (BADGER)" },
                    { "BAL", "Balancer (BAL)" },
                    { "BAND", "Band Protocol (BAND)" },
                    { "BAT", "BAT" },
                    { "BCH", "Bitcoin Cash" },
                    { "BNC", "Bifrost (BNC)" },
                    { "BNT", "Bancor (BNT)" },
                    { "BTC", "Bitcoin" },
                    { "CHZ", "Chiliz (CHZ)" },
                    { "COMP", "Compound (COMP)" },
                    { "CQT", "	Covalent Query Token (CQT)" },
                    { "CRV", "Curve DAO Token (CRV)" },
                    { "CTSI", "Cartesi (CTSI)" },
                    { "DAI", "Dai" },
                    { "DASH", "Dash" },
                    { "DOGE", "Dogecoin" },
                    { "DOT", "Polkadot" },
                    { "DYDX", "dYdX (DYDX)" },
                    { "ENJ", "Enjin Coin (ENJ)" },
                    { "EOS", "EOS" },
                    { "ETC", "Ether Classic (Hex)" },
                    { "ETH", "Ether (Hex)" },
                    { "EWT", "Energy Web Token" },
                    { "FEE", "Kraken Fee Credit" },
                    { "FIL", "Filecoin" },
                    { "FLOW", "Flow" },
                    { "GHST", "Aavegotchi (GHST)" },
                    { "GNO", "GNO" },
                    { "GRT", "GRT" },
                    { "ICX", "Icon" },
                    { "INJ", "Injective Protocol (INJ)" },
                    { "KAR", "Karura (KAR)" },
                    { "KAVA", "Kava" },
                    { "KEEP", "Keep Token (KEEP)" },
                    { "KNC", "Kyber Network (KNC)" },
                    { "KSM", "Kusama" },
                    { "LINK", "Link" },
                    { "LPT", "Livepeer Token (LPT)" },
                    { "LRC", "Loopring (LRC)" },
                    { "LSK", "Lisk" },
                    { "LTC", "Litecoin" },
                    { "MANA", "MANA" },
                    { "MATIC", "Polygon (MATIC)" },
                    { "MINA", "Mina" },
                    { "MIR", "Mirror Protocol (MIR)" },
                    { "MKR", "Maker (MKR)" },
                    { "MLN", "MLN" },
                    { "MOVR", "Moonriver (MOVR)" },
                    { "NANO", "NANO" },
                    { "OCEAN", "OCEAN" },
                    { "OGN", "Origin Protocol (OGN)" },
                    { "OMG", "OMG" },
                    { "OXT", "Orchid (OXT)" },
                    { "OXY", "Oxygen (OXY)" },
                    { "PAXG", "PAX (Gold)" },
                    { "PERP", "Perpetual Protocol (PERP)" },
                    { "PHA", "Phala (PHA)" },
                    { "QTUM", "QTUM" },
                    { "RARI", "Rarible (RARI)" },
                    { "RAY", "Raydium (RAY)" },
                    { "REN", "Ren Protocol (REN)" },
                    { "REP", "REPv2" },
                    { "REPV1", "REP" },
                    { "SAND", "The Sandbox (SAND)" },
                    { "SC", "Siacoin" },
                    { "SDN", "Shiden (SDN)" },
                    { "SOL", "Solana" },
                    { "SNX", "Synthetix  Network (SNX)" },
                    { "SRM", "Serum" },
                    { "STORJ", "Storj (STORJ)" },
                    { "SUSHI", "Sushiswap (SUSHI)" },
                    { "TBTC", "tBTC" },
                    { "TRX", "Tron" },
                    { "UNI", "UNI" },
                    { "USDC", "USDC" },
                    { "USDT", "Tether USD (ERC20)" },
                    { "USDT-TRC20", "Tether USD (TRC20)" },
                    { "WAVES", "Waves" },
                    { "WBTC", "Wrapped Bitcoin (WBTC)" },
                    { "XLM", "Stellar XLM" },
                    { "XMR", "Monero" },
                    { "XRP", "Ripple XRP" },
                    { "XTZ", "XTZ" },
                    { "YFI", "YFI" },
                    { "ZEC", "Zcash (Transparent)" },
                    { "ZRX", "0x (ZRX)" },
                } },
                { "withdrawMethods", new Dictionary<string, object>() {
                    { "Lightning", "Lightning" },
                    { "Bitcoin", "BTC" },
                    { "Ripple", "XRP" },
                    { "Litecoin", "LTC" },
                    { "Dogecoin", "DOGE" },
                    { "Stellar", "XLM" },
                    { "Ethereum", "ERC20" },
                    { "Arbitrum One", "Arbitrum" },
                    { "Polygon", "MATIC" },
                    { "Arbitrum Nova", "Arbitrum" },
                    { "Optimism", "Optimism" },
                    { "zkSync Era", "zkSync" },
                    { "Ethereum Classic", "ETC" },
                    { "Zcash", "ZEC" },
                    { "Monero", "XMR" },
                    { "Tron", "TRC20" },
                    { "Solana", "SOL" },
                    { "EOS", "EOS" },
                    { "Bitcoin Cash", "BCH" },
                    { "Cardano", "ADA" },
                    { "Qtum", "QTUM" },
                    { "Tezos", "XTZ" },
                    { "Cosmos", "ATOM" },
                    { "Nano", "NANO" },
                    { "Siacoin", "SC" },
                    { "Lisk", "LSK" },
                    { "Waves", "WAVES" },
                    { "ICON", "ICX" },
                    { "Algorand", "ALGO" },
                    { "Polygon - USDC.e", "MATIC" },
                    { "Arbitrum One - USDC.e", "Arbitrum" },
                    { "Polkadot", "DOT" },
                    { "Kava", "KAVA" },
                    { "Filecoin", "FIL" },
                    { "Kusama", "KSM" },
                    { "Flow", "FLOW" },
                    { "Energy Web", "EW" },
                    { "Mina", "MINA" },
                    { "Centrifuge", "CFG" },
                    { "Karura", "KAR" },
                    { "Moonriver", "MOVR" },
                    { "Shiden", "SDN" },
                    { "Khala", "PHA" },
                    { "Bifrost Kusama", "BNC" },
                    { "Songbird", "SGB" },
                    { "Terra classic", "LUNC" },
                    { "KILT", "KILT" },
                    { "Basilisk", "BSX" },
                    { "Flare", "FLR" },
                    { "Avalanche C-Chain", "AVAX" },
                    { "Kintsugi", "KINT" },
                    { "Altair", "AIR" },
                    { "Moonbeam", "GLMR" },
                    { "Acala", "ACA" },
                    { "Astar", "ASTR" },
                    { "Akash", "AKT" },
                    { "Robonomics", "XRT" },
                    { "Fantom", "FTM" },
                    { "Elrond", "EGLD" },
                    { "THORchain", "RUNE" },
                    { "Secret", "SCRT" },
                    { "Near", "NEAR" },
                    { "Internet Computer Protocol", "ICP" },
                    { "Picasso", "PICA" },
                    { "Crust Shadow", "CSM" },
                    { "Integritee", "TEER" },
                    { "Parallel Finance", "PARA" },
                    { "HydraDX", "HDX" },
                    { "Interlay", "INTR" },
                    { "Fetch.ai", "FET" },
                    { "NYM", "NYM" },
                    { "Terra 2.0", "LUNA2" },
                    { "Juno", "JUNO" },
                    { "Nodle", "NODL" },
                    { "Stacks", "STX" },
                    { "Ethereum PoW", "ETHW" },
                    { "Aptos", "APT" },
                    { "Sui", "SUI" },
                    { "Genshiro", "GENS" },
                    { "Aventus", "AVT" },
                    { "Sei", "SEI" },
                    { "OriginTrail", "OTP" },
                    { "Celestia", "TIA" },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "EQuery:Invalid asset pair", typeof(BadSymbol) },
                { "EAPI:Invalid key", typeof(AuthenticationError) },
                { "EFunding:Unknown withdraw key", typeof(InvalidAddress) },
                { "EFunding:Invalid amount", typeof(InsufficientFunds) },
                { "EService:Unavailable", typeof(ExchangeNotAvailable) },
                { "EDatabase:Internal error", typeof(ExchangeNotAvailable) },
                { "EService:Busy", typeof(ExchangeNotAvailable) },
                { "EQuery:Unknown asset", typeof(BadSymbol) },
                { "EAPI:Rate limit exceeded", typeof(DDoSProtection) },
                { "EOrder:Rate limit exceeded", typeof(DDoSProtection) },
                { "EGeneral:Internal error", typeof(ExchangeNotAvailable) },
                { "EGeneral:Temporary lockout", typeof(DDoSProtection) },
                { "EGeneral:Permission denied", typeof(PermissionDenied) },
                { "EOrder:Unknown order", typeof(InvalidOrder) },
                { "EOrder:Order minimum not met", typeof(InvalidOrder) },
                { "EGeneral:Invalid arguments", typeof(BadRequest) },
                { "ESession:Invalid session", typeof(AuthenticationError) },
                { "EAPI:Invalid nonce", typeof(InvalidNonce) },
                { "EFunding:No funding method", typeof(BadRequest) },
                { "EFunding:Unknown asset", typeof(BadSymbol) },
                { "EService:Market in post_only mode", typeof(OnMaintenance) },
                { "EGeneral:Too many requests", typeof(DDoSProtection) },
                { "ETrade:User Locked", typeof(AccountSuspended) },
            } },
        });
    }

    public override object feeToPrecision(object symbol, object fee)
    {
        return this.decimalToPrecision(fee, TRUNCATE, getValue(getValue(getValue(this.markets, symbol), "precision"), "amount"), this.precisionMode);
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchMarkets
        * @description retrieves data on all markets for kraken
        * @see https://docs.kraken.com/rest/#tag/Spot-Market-Data/operation/getTradableAssetPairs
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetAssetPairs(parameters);
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "ADAETH": {
        //                 "altname": "ADAETH",
        //                 "wsname": "ADA\/ETH",
        //                 "aclass_base": "currency",
        //                 "base": "ADA",
        //                 "aclass_quote": "currency",
        //                 "quote": "XETH",
        //                 "lot": "unit",
        //                 "pair_decimals": 7,
        //                 "lot_decimals": 8,
        //                 "lot_multiplier": 1,
        //                 "leverage_buy": [],
        //                 "leverage_sell": [],
        //                 "fees": [
        //                     [0, 0.26],
        //                     [50000, 0.24],
        //                     [100000, 0.22],
        //                     [250000, 0.2],
        //                     [500000, 0.18],
        //                     [1000000, 0.16],
        //                     [2500000, 0.14],
        //                     [5000000, 0.12],
        //                     [10000000, 0.1]
        //                 ],
        //                 "fees_maker": [
        //                     [0, 0.16],
        //                     [50000, 0.14],
        //                     [100000, 0.12],
        //                     [250000, 0.1],
        //                     [500000, 0.08],
        //                     [1000000, 0.06],
        //                     [2500000, 0.04],
        //                     [5000000, 0.02],
        //                     [10000000, 0]
        //                 ],
        //                 "fee_volume_currency": "ZUSD",
        //                 "margin_call": 80,
        //                 "margin_stop": 40,
        //                 "ordermin": "1"
        //             },
        //         }
        //     }
        //
        object markets = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object keys = new List<object>(((IDictionary<string,object>)markets).Keys);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object id = getValue(keys, i);
            object market = getValue(markets, id);
            object baseId = this.safeString(market, "base");
            object quoteId = this.safeString(market, "quote");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object darkpool = isGreaterThanOrEqual(getIndexOf(id, ".d"), 0);
            object altname = this.safeString(market, "altname");
            object makerFees = this.safeValue(market, "fees_maker", new List<object>() {});
            object firstMakerFee = this.safeValue(makerFees, 0, new List<object>() {});
            object firstMakerFeeRate = this.safeString(firstMakerFee, 1);
            object maker = null;
            if (isTrue(!isEqual(firstMakerFeeRate, null)))
            {
                maker = this.parseNumber(Precise.stringDiv(firstMakerFeeRate, "100"));
            }
            object takerFees = this.safeValue(market, "fees", new List<object>() {});
            object firstTakerFee = this.safeValue(takerFees, 0, new List<object>() {});
            object firstTakerFeeRate = this.safeString(firstTakerFee, 1);
            object taker = null;
            if (isTrue(!isEqual(firstTakerFeeRate, null)))
            {
                taker = this.parseNumber(Precise.stringDiv(firstTakerFeeRate, "100"));
            }
            object leverageBuy = this.safeValue(market, "leverage_buy", new List<object>() {});
            object leverageBuyLength = getArrayLength(leverageBuy);
            object precisionPrice = this.parseNumber(this.parsePrecision(this.safeString(market, "pair_decimals")));
            object status = this.safeString(market, "status");
            object isActive = isEqual(status, "online");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "wsId", this.safeString(market, "wsname") },
                { "symbol", ((bool) isTrue(darkpool)) ? altname : (add(add(bs, "/"), quote)) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "darkpool", darkpool },
                { "altname", getValue(market, "altname") },
                { "type", "spot" },
                { "spot", true },
                { "margin", (isGreaterThan(leverageBuyLength, 0)) },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", isActive },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", taker },
                { "maker", maker },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "lot_decimals"))) },
                    { "price", precisionPrice },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.parseNumber("1") },
                        { "max", this.safeNumber(leverageBuy, subtract(leverageBuyLength, 1), 1) },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "ordermin") },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", precisionPrice },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "costmin") },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", market },
            });
        }
        result = this.appendInactiveMarkets(result);
        ((IDictionary<string,object>)this.options)["marketsByAltname"] = this.indexBy(result, "altname");
        return result;
    }

    public override object safeCurrency(object currencyId, object currency = null)
    {
        if (isTrue(!isEqual(currencyId, null)))
        {
            if (isTrue(isGreaterThan(getArrayLength(currencyId), 3)))
            {
                if (isTrue(isTrue((isEqual(getIndexOf(currencyId, "X"), 0))) || isTrue((isEqual(getIndexOf(currencyId, "Z"), 0)))))
                {
                    if (!isTrue((isGreaterThan(getIndexOf(currencyId, "."), 0))))
                    {
                        currencyId = slice(currencyId, 1, null);
                    }
                }
            }
        }
        return base.safeCurrency(currencyId, currency);
    }

    public virtual object appendInactiveMarkets(object result)
    {
        // result should be an array to append to
        object precision = new Dictionary<string, object>() {
            { "amount", this.parseNumber("1e-8") },
            { "price", this.parseNumber("1e-8") },
        };
        object costLimits = new Dictionary<string, object>() {
            { "min", null },
            { "max", null },
        };
        object priceLimits = new Dictionary<string, object>() {
            { "min", getValue(precision, "price") },
            { "max", null },
        };
        object amountLimits = new Dictionary<string, object>() {
            { "min", getValue(precision, "amount") },
            { "max", null },
        };
        object limits = new Dictionary<string, object>() {
            { "amount", amountLimits },
            { "price", priceLimits },
            { "cost", costLimits },
        };
        object defaults = new Dictionary<string, object>() {
            { "darkpool", false },
            { "info", null },
            { "maker", null },
            { "taker", null },
            { "active", false },
            { "precision", precision },
            { "limits", limits },
        };
        object markets = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.extend(defaults, getValue(markets, i)));
        }
        return result;
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://docs.kraken.com/rest/#tag/Spot-Market-Data/operation/getAssetInfo
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetAssets(parameters);
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "BCH": {
        //                 "aclass": "currency",
        //                 "altname": "BCH",
        //                 "decimals": 10,
        //                 "display_decimals": 5
        //                 "status": "enabled",
        //             },
        //             ...
        //         },
        //     }
        //
        object currencies = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object ids = new List<object>(((IDictionary<string,object>)currencies).Keys);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object id = getValue(ids, i);
            object currency = getValue(currencies, id);
            // todo: will need to rethink the fees
            // see: https://support.kraken.com/hc/en-us/articles/201893608-What-are-the-withdrawal-fees-
            // to add support for multiple withdrawal/deposit methods and
            // differentiated fees for each particular method
            object code = this.safeCurrencyCode(id);
            object precision = this.parseNumber(this.parsePrecision(this.safeString(currency, "decimals")));
            // assumes all currencies are active except those listed above
            object active = isEqual(this.safeString(currency, "status"), "enabled");
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "code", code },
                { "info", currency },
                { "name", this.safeString(currency, "altname") },
                { "active", active },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "precision", precision },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", precision },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "networks", new Dictionary<string, object>() {} },
            };
        }
        return result;
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchTradingFee
        * @description fetch the trading fees for a market
        * @see https://docs.kraken.com/rest/#tag/Account-Data/operation/getTradeVolume
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
            { "fee-info", true },
        };
        object response = await this.privatePostTradeVolume(this.extend(request, parameters));
        //
        //     {
        //        "error": [],
        //        "result": {
        //          "currency": 'ZUSD',
        //          "volume": '0.0000',
        //          "fees": {
        //            "XXBTZUSD": {
        //              "fee": '0.2600',
        //              "minfee": '0.1000',
        //              "maxfee": '0.2600',
        //              "nextfee": '0.2400',
        //              "tiervolume": '0.0000',
        //              "nextvolume": '50000.0000'
        //            }
        //          },
        //          "fees_maker": {
        //            "XXBTZUSD": {
        //              "fee": '0.1600',
        //              "minfee": '0.0000',
        //              "maxfee": '0.1600',
        //              "nextfee": '0.1400',
        //              "tiervolume": '0.0000',
        //              "nextvolume": '50000.0000'
        //            }
        //          }
        //        }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseTradingFee(result, market);
    }

    public virtual object parseTradingFee(object response, object market)
    {
        object makerFees = this.safeValue(response, "fees_maker", new Dictionary<string, object>() {});
        object takerFees = this.safeValue(response, "fees", new Dictionary<string, object>() {});
        object symbolMakerFee = this.safeValue(makerFees, getValue(market, "id"), new Dictionary<string, object>() {});
        object symbolTakerFee = this.safeValue(takerFees, getValue(market, "id"), new Dictionary<string, object>() {});
        return new Dictionary<string, object>() {
            { "info", response },
            { "symbol", getValue(market, "symbol") },
            { "maker", this.safeNumber(symbolMakerFee, "fee") },
            { "taker", this.safeNumber(symbolTakerFee, "fee") },
            { "percentage", true },
            { "tierBased", true },
        };
    }

    public override object parseBidAsk(object bidask, object priceKey = null, object amountKey = null, object countOrIdKey = null)
    {
        priceKey ??= 0;
        amountKey ??= 1;
        countOrIdKey ??= 2;
        object price = this.safeNumber(bidask, priceKey);
        object amount = this.safeNumber(bidask, amountKey);
        object timestamp = this.safeInteger(bidask, 2);
        return new List<object>() {price, amount, timestamp};
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://docs.kraken.com/rest/#tag/Spot-Market-Data/operation/getOrderBook
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(getValue(market, "darkpool")))
        {
            throw new ExchangeError ((string)add(add(this.id, " fetchOrderBook() does not provide an order book for darkpool symbol "), symbol)) ;
        }
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["count"] = limit; // 100
        }
        object response = await this.publicGetDepth(this.extend(request, parameters));
        //
        //     {
        //         "error":[],
        //         "result":{
        //             "XETHXXBT":{
        //                 "asks":[
        //                     ["0.023480","4.000",1586321307],
        //                     ["0.023490","50.095",1586321306],
        //                     ["0.023500","28.535",1586321302],
        //                 ],
        //                 "bids":[
        //                     ["0.023470","59.580",1586321307],
        //                     ["0.023460","20.000",1586321301],
        //                     ["0.023440","67.832",1586321306],
        //                 ]
        //             }
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object orderbook = this.safeValue(result, getValue(market, "id"));
        // sometimes kraken returns wsname instead of market id
        // https://github.com/ccxt/ccxt/issues/8662
        object marketInfo = this.safeValue(market, "info", new Dictionary<string, object>() {});
        object wsName = this.safeValue(marketInfo, "wsname");
        if (isTrue(!isEqual(wsName, null)))
        {
            orderbook = this.safeValue(result, wsName, orderbook);
        }
        return this.parseOrderBook(orderbook, symbol);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "a":["2432.77000","1","1.000"],
        //         "b":["2431.37000","2","2.000"],
        //         "c":["2430.58000","0.04408910"],
        //         "v":["4147.94474901","8896.96086304"],
        //         "p":["2456.22239","2568.63032"],
        //         "t":[3907,10056],
        //         "l":["2302.18000","2302.18000"],
        //         "h":["2621.14000","2860.01000"],
        //         "o":"2571.56000"
        //     }
        //
        object symbol = this.safeSymbol(null, market);
        object v = this.safeValue(ticker, "v", new List<object>() {});
        object baseVolume = this.safeString(v, 1);
        object p = this.safeValue(ticker, "p", new List<object>() {});
        object vwap = this.safeString(p, 1);
        object quoteVolume = Precise.stringMul(baseVolume, vwap);
        object c = this.safeValue(ticker, "c", new List<object>() {});
        object last = this.safeString(c, 0);
        object high = this.safeValue(ticker, "h", new List<object>() {});
        object low = this.safeValue(ticker, "l", new List<object>() {});
        object bid = this.safeValue(ticker, "b", new List<object>() {});
        object ask = this.safeValue(ticker, "a", new List<object>() {});
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "high", this.safeString(high, 1) },
            { "low", this.safeString(low, 1) },
            { "bid", this.safeString(bid, 0) },
            { "bidVolume", null },
            { "ask", this.safeString(ask, 0) },
            { "askVolume", null },
            { "vwap", vwap },
            { "open", this.safeString(ticker, "o") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://docs.kraken.com/rest/#tag/Spot-Market-Data/operation/getTickerInformation
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            symbols = this.marketSymbols(symbols);
            object marketIds = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                object market = getValue(this.markets, symbol);
                if (isTrue(isTrue(getValue(market, "active")) && !isTrue(getValue(market, "darkpool"))))
                {
                    ((IList<object>)marketIds).Add(getValue(market, "id"));
                }
            }
            ((IDictionary<string,object>)request)["pair"] = String.Join(",", ((IList<object>)marketIds).ToArray());
        }
        object response = await this.publicGetTicker(this.extend(request, parameters));
        object tickers = getValue(response, "result");
        object ids = new List<object>(((IDictionary<string,object>)tickers).Keys);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object id = getValue(ids, i);
            object market = this.safeMarket(id);
            object symbol = getValue(market, "symbol");
            object ticker = getValue(tickers, id);
            ((IDictionary<string,object>)result)[(string)symbol] = this.parseTicker(ticker, market);
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://docs.kraken.com/rest/#tag/Spot-Market-Data/operation/getTickerInformation
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object darkpool = isGreaterThanOrEqual(getIndexOf(symbol, ".d"), 0);
        if (isTrue(darkpool))
        {
            throw new ExchangeError ((string)add(add(this.id, " fetchTicker() does not provide a ticker for darkpool symbol "), symbol)) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        object response = await this.publicGetTicker(this.extend(request, parameters));
        object ticker = getValue(getValue(response, "result"), getValue(market, "id"));
        return this.parseTicker(ticker, market);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         1591475640,
        //         "0.02500",
        //         "0.02500",
        //         "0.02500",
        //         "0.02500",
        //         "0.02500",
        //         "9.12201000",
        //         5
        //     ]
        //
        return new List<object> {this.safeTimestamp(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 6)};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://docs.kraken.com/rest/#tag/Spot-Market-Data/operation/getOHLCData
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, 720);
        }
        object market = this.market(symbol);
        object parsedTimeframe = this.safeInteger(this.timeframes, timeframe);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        if (isTrue(!isEqual(parsedTimeframe, null)))
        {
            ((IDictionary<string,object>)request)["interval"] = parsedTimeframe;
        } else
        {
            ((IDictionary<string,object>)request)["interval"] = timeframe;
        }
        if (isTrue(!isEqual(since, null)))
        {
            // contrary to kraken's api documentation, the since parameter must be passed in nanoseconds
            // the adding of '000000' is copied from the fetchTrades function
            ((IDictionary<string,object>)request)["since"] = add(this.numberToString(since), "000000"); // expected to be in nanoseconds
        }
        object response = await this.publicGetOHLC(this.extend(request, parameters));
        //
        //     {
        //         "error":[],
        //         "result":{
        //             "XETHXXBT":[
        //                 [1591475580,"0.02499","0.02499","0.02499","0.02499","0.00000","0.00000000",0],
        //                 [1591475640,"0.02500","0.02500","0.02500","0.02500","0.02500","9.12201000",5],
        //                 [1591475700,"0.02499","0.02499","0.02499","0.02499","0.02499","1.28681415",2],
        //                 [1591475760,"0.02499","0.02499","0.02499","0.02499","0.02499","0.08800000",1],
        //             ],
        //             "last":1591517580
        //         }
        //     }
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object ohlcvs = this.safeList(result, getValue(market, "id"), new List<object>() {});
        return this.parseOHLCVs(ohlcvs, market, timeframe, since, limit);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "trade", "trade" },
            { "withdrawal", "transaction" },
            { "deposit", "transaction" },
            { "transfer", "transfer" },
            { "margin", "margin" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //         'LTFK7F-N2CUX-PNY4SX': {
        //             "refid": "TSJTGT-DT7WN-GPPQMJ",
        //             "time":  1520102320.555,
        //             "type": "trade",
        //             "aclass": "currency",
        //             "asset": "XETH",
        //             "amount": "0.1087194600",
        //             "fee": "0.0000000000",
        //             "balance": "0.2855851000"
        //         },
        //         ...
        //     }
        //
        object id = this.safeString(item, "id");
        object direction = null;
        object account = null;
        object referenceId = this.safeString(item, "refid");
        object referenceAccount = null;
        object type = this.parseLedgerEntryType(this.safeString(item, "type"));
        object code = this.safeCurrencyCode(this.safeString(item, "asset"), currency);
        object amount = this.safeString(item, "amount");
        if (isTrue(Precise.stringLt(amount, "0")))
        {
            direction = "out";
            amount = Precise.stringAbs(amount);
        } else
        {
            direction = "in";
        }
        object timestamp = this.safeTimestamp(item, "time");
        return new Dictionary<string, object>() {
            { "info", item },
            { "id", id },
            { "direction", direction },
            { "account", account },
            { "referenceId", referenceId },
            { "referenceAccount", referenceAccount },
            { "type", type },
            { "currency", code },
            { "amount", this.parseNumber(amount) },
            { "before", null },
            { "after", this.safeNumber(item, "balance") },
            { "status", "ok" },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fee", new Dictionary<string, object>() {
                { "cost", this.safeNumber(item, "fee") },
                { "currency", code },
            } },
        };
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @see https://docs.kraken.com/rest/#tag/Account-Data/operation/getLedgers
        * @param {string} code unified currency code, default is undefined
        * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int} [limit] max number of ledger entrys to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp in ms of the latest ledger entry
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        // https://www.kraken.com/features/api#get-ledgers-info
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["asset"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = this.parseToInt(divide(since, 1000));
        }
        var requestparametersVariable = this.handleUntilOption("end", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privatePostLedgers(this.extend(request, parameters));
        // {  error: [],
        //   "result": { ledger: { 'LPUAIB-TS774-UKHP7X': {   refid: "A2B4HBV-L4MDIE-JU4N3N",
        //                                                   "time":  1520103488.314,
        //                                                   "type": "withdrawal",
        //                                                 "aclass": "currency",
        //                                                  "asset": "XETH",
        //                                                 "amount": "-0.2805800000",
        //                                                    "fee": "0.0050000000",
        //                                                "balance": "0.0000051000"           },
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object ledger = this.safeValue(result, "ledger", new Dictionary<string, object>() {});
        object keys = new List<object>(((IDictionary<string,object>)ledger).Keys);
        object items = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object value = getValue(ledger, key);
            ((IDictionary<string,object>)value)["id"] = key;
            ((IList<object>)items).Add(value);
        }
        return this.parseLedger(items, currency, since, limit);
    }

    public async virtual Task<object> fetchLedgerEntriesByIds(object ids, object code = null, object parameters = null)
    {
        // https://www.kraken.com/features/api#query-ledgers
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        ids = String.Join(",", ((IList<object>)ids).ToArray());
        object request = this.extend(new Dictionary<string, object>() {
            { "id", ids },
        }, parameters);
        object response = await this.privatePostQueryLedgers(request);
        // {  error: [],
        //   "result": { 'LPUAIB-TS774-UKHP7X': {   refid: "A2B4HBV-L4MDIE-JU4N3N",
        //                                         "time":  1520103488.314,
        //                                         "type": "withdrawal",
        //                                       "aclass": "currency",
        //                                        "asset": "XETH",
        //                                       "amount": "-0.2805800000",
        //                                          "fee": "0.0050000000",
        //                                      "balance": "0.0000051000"           } } }
        object result = getValue(response, "result");
        object keys = new List<object>(((IDictionary<string,object>)result).Keys);
        object items = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object value = getValue(result, key);
            ((IDictionary<string,object>)value)["id"] = key;
            ((IList<object>)items).Add(value);
        }
        return this.parseLedger(items);
    }

    public async override Task<object> fetchLedgerEntry(object id, object code = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object items = await this.fetchLedgerEntriesByIds(new List<object>() {id}, code, parameters);
        return getValue(items, 0);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //     [
        //         "0.032310", // price
        //         "4.28169434", // amount
        //         1541390792.763, // timestamp
        //         "s", // sell or buy
        //         "l", // limit or market
        //         ""
        //     ]
        //
        // fetchOrderTrades (private)
        //
        //     {
        //         "id": 'TIMIRG-WUNNE-RRJ6GT', // injected from outside
        //         "ordertxid": 'OQRPN2-LRHFY-HIFA7D',
        //         "postxid": 'TKH2SE-M7IF5-CFI7LT',
        //         "pair": 'USDCUSDT',
        //         "time": 1586340086.457,
        //         "type": 'sell',
        //         "ordertype": 'market',
        //         "price": '0.99860000',
        //         "cost": '22.16892001',
        //         "fee": '0.04433784',
        //         "vol": '22.20000000',
        //         "margin": '0.00000000',
        //         "misc": ''
        //     }
        //
        object timestamp = null;
        object side = null;
        object type = null;
        object price = null;
        object amount = null;
        object id = null;
        object orderId = null;
        object fee = null;
        object symbol = null;
        if (isTrue(((trade is IList<object>) || (trade.GetType().IsGenericType && trade.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            timestamp = this.safeTimestamp(trade, 2);
            side = ((bool) isTrue((isEqual(getValue(trade, 3), "s")))) ? "sell" : "buy";
            type = ((bool) isTrue((isEqual(getValue(trade, 4), "l")))) ? "limit" : "market";
            price = this.safeString(trade, 0);
            amount = this.safeString(trade, 1);
            object tradeLength = getArrayLength(trade);
            if (isTrue(isGreaterThan(tradeLength, 6)))
            {
                id = this.safeString(trade, 6); // artificially added as per #1794
            }
        } else if (isTrue((trade is string)))
        {
            id = trade;
        } else if (isTrue(inOp(trade, "ordertxid")))
        {
            object marketId = this.safeString(trade, "pair");
            object foundMarket = this.findMarketByAltnameOrId(marketId);
            if (isTrue(!isEqual(foundMarket, null)))
            {
                market = foundMarket;
            } else if (isTrue(!isEqual(marketId, null)))
            {
                // delisted market ids go here
                market = this.getDelistedMarketById(marketId);
            }
            orderId = this.safeString(trade, "ordertxid");
            id = this.safeString2(trade, "id", "postxid");
            timestamp = this.safeTimestamp(trade, "time");
            side = this.safeString(trade, "type");
            type = this.safeString(trade, "ordertype");
            price = this.safeString(trade, "price");
            amount = this.safeString(trade, "vol");
            if (isTrue(inOp(trade, "fee")))
            {
                object currency = null;
                if (isTrue(!isEqual(market, null)))
                {
                    currency = getValue(market, "quote");
                }
                fee = new Dictionary<string, object>() {
                    { "cost", this.safeString(trade, "fee") },
                    { "currency", currency },
                };
            }
        }
        if (isTrue(!isEqual(market, null)))
        {
            symbol = getValue(market, "symbol");
        }
        object cost = this.safeString(trade, "cost");
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "order", orderId },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", type },
            { "side", side },
            { "takerOrMaker", null },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://docs.kraken.com/rest/#tag/Spot-Market-Data/operation/getRecentTrades
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object id = getValue(market, "id");
        object request = new Dictionary<string, object>() {
            { "pair", id },
        };
        // https://support.kraken.com/hc/en-us/articles/218198197-How-to-pull-all-trade-data-using-the-Kraken-REST-API
        // https://github.com/ccxt/ccxt/issues/5677
        if (isTrue(!isEqual(since, null)))
        {
            // php does not format it properly
            // therefore we use string concatenation here
            ((IDictionary<string,object>)request)["since"] = multiply(since, 1000000);
            ((IDictionary<string,object>)request)["since"] = add(((object)since).ToString(), "000000"); // expected to be in nanoseconds
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["count"] = limit;
        }
        object response = await this.publicGetTrades(this.extend(request, parameters));
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "XETHXXBT": [
        //                 ["0.032310","4.28169434",1541390792.763,"s","l",""]
        //             ],
        //             "last": "1541439421200678657"
        //         }
        //     }
        //
        object result = getValue(response, "result");
        object trades = getValue(result, id);
        // trades is a sorted array: last (most recent trade) goes last
        object length = getArrayLength(trades);
        if (isTrue(isLessThanOrEqual(length, 0)))
        {
            return new List<object>() {};
        }
        object lastTrade = getValue(trades, subtract(length, 1));
        object lastTradeId = this.safeString(result, "last");
        ((IList<object>)lastTrade).Add(lastTradeId);
        ((List<object>)trades)[Convert.ToInt32(subtract(length, 1))] = lastTrade;
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseBalance(object response)
    {
        object balances = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        object currencyIds = new List<object>(((IDictionary<string,object>)balances).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencyIds, i);
            object code = this.safeCurrencyCode(currencyId);
            object balance = this.safeValue(balances, currencyId, new Dictionary<string, object>() {});
            object account = this.account();
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "hold_trade");
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "balance");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://docs.kraken.com/rest/#tag/Account-Data/operation/getExtendedBalance
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostBalanceEx(parameters);
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "ZUSD": {
        //                 "balance": 25435.21,
        //                 "hold_trade": 8249.76
        //             },
        //             "XXBT": {
        //                 "balance": 1.2435,
        //                 "hold_trade": 0.8423
        //             }
        //         }
        //     }
        //
        return this.parseBalance(response);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#createOrder
        * @see https://docs.kraken.com/rest/#tag/Trading/operation/addOrder
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
        * @param {bool} [params.reduceOnly] *margin only* indicates if this order is to reduce the size of a position
        * @param {float} [params.stopLossPrice] *margin only* the price that a stop loss order is triggered at
        * @param {float} [params.takeProfitPrice] *margin only* the price that a take profit order is triggered at
        * @param {string} [params.trailingAmount] *margin only* the quote amount to trail away from the current market price
        * @param {string} [params.trailingLimitAmount] *margin only* the quote amount away from the trailingAmount
        * @param {string} [params.offset] *margin only* '+' or '-' whether you want the trailingLimitAmount value to be positive or negative, default is negative '-'
        * @param {string} [params.trigger] *margin only* the activation price type, 'last' or 'index', default is 'last'
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
            { "type", side },
            { "ordertype", type },
            { "volume", this.amountToPrecision(symbol, amount) },
        };
        object orderRequest = this.orderRequest("createOrder", symbol, type, request, price, parameters);
        object response = await this.privatePostAddOrder(this.extend(getValue(orderRequest, 0), getValue(orderRequest, 1)));
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "descr": { order: 'buy 0.02100000 ETHUSDT @ limit 330.00' },
        //             "txid": [ 'OEKVV2-IH52O-TPL6GZ' ]
        //         }
        //     }
        //
        object result = this.safeDict(response, "result");
        return this.parseOrder(result);
    }

    public virtual object findMarketByAltnameOrId(object id)
    {
        object marketsByAltname = this.safeValue(this.options, "marketsByAltname", new Dictionary<string, object>() {});
        if (isTrue(inOp(marketsByAltname, id)))
        {
            return getValue(marketsByAltname, id);
        } else
        {
            return this.safeMarket(id);
        }
    }

    public virtual object getDelistedMarketById(object id)
    {
        if (isTrue(isEqual(id, null)))
        {
            return id;
        }
        object market = this.safeValue(getValue(this.options, "delistedMarketsById"), id);
        if (isTrue(!isEqual(market, null)))
        {
            return market;
        }
        object baseIdStart = 0;
        object baseIdEnd = 3;
        object quoteIdStart = 3;
        object quoteIdEnd = 6;
        if (isTrue(isEqual(getArrayLength(id), 8)))
        {
            baseIdEnd = 4;
            quoteIdStart = 4;
            quoteIdEnd = 8;
        } else if (isTrue(isEqual(getArrayLength(id), 7)))
        {
            baseIdEnd = 4;
            quoteIdStart = 4;
            quoteIdEnd = 7;
        }
        object baseId = slice(id, baseIdStart, baseIdEnd);
        object quoteId = slice(id, quoteIdStart, quoteIdEnd);
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(bs, "/"), quote);
        market = new Dictionary<string, object>() {
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "baseId", baseId },
            { "quoteId", quoteId },
        };
        ((IDictionary<string,object>)getValue(this.options, "delistedMarketsById"))[(string)id] = market;
        return market;
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "pending", "open" },
            { "open", "open" },
            { "closed", "closed" },
            { "canceled", "canceled" },
            { "expired", "expired" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderType(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "take-profit", "market" },
            { "stop-loss-limit", "limit" },
            { "stop-loss", "market" },
            { "take-profit-limit", "limit" },
            { "trailing-stop-limit", "limit" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder for regular orders
        //
        //     {
        //         "descr": { order: 'buy 0.02100000 ETHUSDT @ limit 330.00' },
        //         "txid": [ 'OEKVV2-IH52O-TPL6GZ' ]
        //     }
        //     {
        //         "txid": [ "TX_ID_HERE" ],
        //         "descr": { "order":"buy 0.12345678 ETHEUR @ market" },
        //     }
        //
        //
        // createOrder for stop orders
        //
        //     {
        //         "txid":["OSILNC-VQI5Q-775ZDQ"],
        //         "descr":{"order":"sell 167.28002676 ADAXBT @ stop loss 0.00003280 -> limit 0.00003212"}
        //     }
        //
        //
        //     {
        //         "txid":["OVHMJV-BZW2V-6NZFWF"],
        //         "descr":{"order":"sell 0.00100000 ETHUSD @ stop loss 2677.00 -> limit 2577.00 with 5:1 leverage"}
        //     }
        //
        // editOrder
        //
        //     {
        //         "status": "ok",
        //         "txid": "OAW2BO-7RWEK-PZY5UO",
        //         "originaltxid": "OXL6SS-UPNMC-26WBE7",
        //         "volume": "0.00075000",
        //         "price": "13500.0",
        //         "orders_cancelled": 1,
        //         "descr": {
        //             "order": "buy 0.00075000 XBTUSDT @ limit 13500.0"
        //         }
        //     }
        //  ws - createOrder
        //    {
        //        "descr": 'sell 0.00010000 XBTUSDT @ market',
        //        "event": 'addOrderStatus',
        //        "reqid": 1,
        //        "status": 'ok',
        //        "txid": 'OAVXZH-XIE54-JCYYDG'
        //    }
        //  ws - editOrder
        //    {
        //        "descr": "order edited price = 9000.00000000",
        //        "event": "editOrderStatus",
        //        "originaltxid": "O65KZW-J4AW3-VFS74A",
        //        "reqid": 3,
        //        "status": "ok",
        //        "txid": "OTI672-HJFAO-XOIPPK"
        //    }
        //
        //  {
        //      "error": [],
        //      "result": {
        //          "open": {
        //              "OXVPSU-Q726F-L3SDEP": {
        //                  "refid": null,
        //                  "userref": 0,
        //                  "status": "open",
        //                  "opentm": 1706893367.4656649,
        //                  "starttm": 0,
        //                  "expiretm": 0,
        //                  "descr": {
        //                      "pair": "XRPEUR",
        //                      "type": "sell",
        //                      "ordertype": "trailing-stop",
        //                      "price": "+50.0000%",
        //                      "price2": "0",
        //                      "leverage": "none",
        //                      "order": "sell 10.00000000 XRPEUR @ trailing stop +50.0000%",
        //                      "close": ""
        //                  },
        //                  "vol": "10.00000000",
        //                  "vol_exec": "0.00000000",
        //                  "cost": "0.00000000",
        //                  "fee": "0.00000000",
        //                  "price": "0.00000000",
        //                  "stopprice": "0.23424000",
        //                  "limitprice": "0.46847000",
        //                  "misc": "",
        //                  "oflags": "fciq",
        //                  "trigger": "index"
        //              }
        //      }
        //  }
        //
        object description = this.safeDict(order, "descr", new Dictionary<string, object>() {});
        object orderDescriptionObj = this.safeDict(order, "descr"); // can be null
        object orderDescription = null;
        if (isTrue(!isEqual(orderDescriptionObj, null)))
        {
            orderDescription = this.safeString(orderDescriptionObj, "order");
        } else
        {
            orderDescription = this.safeString(order, "descr");
        }
        object side = null;
        object type = null;
        object marketId = null;
        object price = null;
        object amount = null;
        object stopPrice = null;
        if (isTrue(!isEqual(orderDescription, null)))
        {
            object parts = ((string)orderDescription).Split(new [] {((string)" ")}, StringSplitOptions.None).ToList<object>();
            side = this.safeString(parts, 0);
            amount = this.safeString(parts, 1);
            marketId = this.safeString(parts, 2);
            type = this.safeString(parts, 4);
            if (isTrue(isEqual(type, "stop")))
            {
                stopPrice = this.safeString(parts, 6);
                price = this.safeString(parts, 9);
            } else if (isTrue(isEqual(type, "limit")))
            {
                price = this.safeString(parts, 5);
            }
        }
        side = this.safeString(description, "type", side);
        type = this.safeString(description, "ordertype", type);
        marketId = this.safeString(description, "pair", marketId);
        object foundMarket = this.findMarketByAltnameOrId(marketId);
        object symbol = null;
        if (isTrue(!isEqual(foundMarket, null)))
        {
            market = foundMarket;
        } else if (isTrue(!isEqual(marketId, null)))
        {
            // delisted market ids go here
            market = this.getDelistedMarketById(marketId);
        }
        object timestamp = this.safeTimestamp(order, "opentm");
        amount = this.safeString(order, "vol", amount);
        object filled = this.safeString(order, "vol_exec");
        object fee = null;
        // kraken truncates the cost in the api response so we will ignore it and calculate it from average & filled
        // const cost = this.safeString (order, 'cost');
        price = this.safeString(description, "price", price);
        // when type = trailling stop returns price = '+50.0000%'
        if (isTrue(isTrue((!isEqual(price, null))) && isTrue(((string)price).EndsWith(((string)"%")))))
        {
            price = null; // this is not the price we want
        }
        if (isTrue(isTrue((isEqual(price, null))) || isTrue(Precise.stringEquals(price, "0"))))
        {
            price = this.safeString(description, "price2");
        }
        if (isTrue(isTrue((isEqual(price, null))) || isTrue(Precise.stringEquals(price, "0"))))
        {
            price = this.safeString(order, "price", price);
        }
        object flags = this.safeString(order, "oflags", "");
        object isPostOnly = isGreaterThan(getIndexOf(flags, "post"), -1);
        object average = this.safeNumber(order, "price");
        if (isTrue(!isEqual(market, null)))
        {
            symbol = getValue(market, "symbol");
            if (isTrue(inOp(order, "fee")))
            {
                object feeCost = this.safeString(order, "fee");
                fee = new Dictionary<string, object>() {
                    { "cost", feeCost },
                    { "rate", null },
                };
                if (isTrue(isGreaterThanOrEqual(getIndexOf(flags, "fciq"), 0)))
                {
                    ((IDictionary<string,object>)fee)["currency"] = getValue(market, "quote");
                } else if (isTrue(isGreaterThanOrEqual(getIndexOf(flags, "fcib"), 0)))
                {
                    ((IDictionary<string,object>)fee)["currency"] = getValue(market, "base");
                }
            }
        }
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object id = this.safeString2(order, "id", "txid");
        if (isTrue(isTrue((isEqual(id, null))) || isTrue((((string)id).StartsWith(((string)"["))))))
        {
            object txid = this.safeList(order, "txid");
            id = this.safeString(txid, 0);
        }
        object clientOrderId = this.safeString(order, "userref");
        object rawTrades = this.safeValue(order, "trades", new List<object>() {});
        object trades = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rawTrades)); postFixIncrement(ref i))
        {
            object rawTrade = getValue(rawTrades, i);
            if (isTrue((rawTrade is string)))
            {
                ((IList<object>)trades).Add(this.safeTrade(new Dictionary<string, object>() {
                    { "id", rawTrade },
                    { "orderId", id },
                    { "symbol", symbol },
                    { "info", new Dictionary<string, object>() {} },
                }));
            } else
            {
                ((IList<object>)trades).Add(rawTrade);
            }
        }
        stopPrice = this.omitZero(this.safeString(order, "stopprice", stopPrice));
        object stopLossPrice = null;
        object takeProfitPrice = null;
        if (isTrue(((string)type).StartsWith(((string)"take-profit"))))
        {
            takeProfitPrice = this.safeString(description, "price");
            price = this.omitZero(this.safeString(description, "price2"));
        } else if (isTrue(((string)type).StartsWith(((string)"stop-loss"))))
        {
            stopLossPrice = this.safeString(description, "price");
            price = this.omitZero(this.safeString(description, "price2"));
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "info", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "status", status },
            { "symbol", symbol },
            { "type", this.parseOrderType(type) },
            { "timeInForce", null },
            { "postOnly", isPostOnly },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "takeProfitPrice", takeProfitPrice },
            { "stopLossPrice", stopLossPrice },
            { "cost", null },
            { "amount", amount },
            { "filled", filled },
            { "average", average },
            { "remaining", null },
            { "fee", fee },
            { "trades", trades },
        }, market);
    }

    public virtual object orderRequest(object method, object symbol, object type, object request, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object clientOrderId = this.safeString2(parameters, "userref", "clientOrderId");
        parameters = this.omit(parameters, new List<object>() {"userref", "clientOrderId"});
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["userref"] = clientOrderId;
        }
        object stopLossTriggerPrice = this.safeString(parameters, "stopLossPrice");
        object takeProfitTriggerPrice = this.safeString(parameters, "takeProfitPrice");
        object isStopLossTriggerOrder = !isEqual(stopLossTriggerPrice, null);
        object isTakeProfitTriggerOrder = !isEqual(takeProfitTriggerPrice, null);
        object isStopLossOrTakeProfitTrigger = isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder);
        object trailingAmount = this.safeString(parameters, "trailingAmount");
        object trailingLimitAmount = this.safeString(parameters, "trailingLimitAmount");
        object isTrailingAmountOrder = !isEqual(trailingAmount, null);
        object isLimitOrder = ((string)type).EndsWith(((string)"limit")); // supporting limit, stop-loss-limit, take-profit-limit, etc
        if (isTrue(isTrue(isLimitOrder) && !isTrue(isTrailingAmountOrder)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object reduceOnly = this.safeValue2(parameters, "reduceOnly", "reduce_only");
        if (isTrue(isStopLossOrTakeProfitTrigger))
        {
            if (isTrue(isStopLossTriggerOrder))
            {
                ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, stopLossTriggerPrice);
                if (isTrue(isLimitOrder))
                {
                    ((IDictionary<string,object>)request)["ordertype"] = "stop-loss-limit";
                } else
                {
                    ((IDictionary<string,object>)request)["ordertype"] = "stop-loss";
                }
            } else if (isTrue(isTakeProfitTriggerOrder))
            {
                ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, takeProfitTriggerPrice);
                if (isTrue(isLimitOrder))
                {
                    ((IDictionary<string,object>)request)["ordertype"] = "take-profit-limit";
                } else
                {
                    ((IDictionary<string,object>)request)["ordertype"] = "take-profit";
                }
            }
            if (isTrue(isLimitOrder))
            {
                ((IDictionary<string,object>)request)["price2"] = this.priceToPrecision(symbol, price);
            }
        } else if (isTrue(isTrailingAmountOrder))
        {
            object trailingActivationPriceType = this.safeString(parameters, "trigger", "last");
            object trailingAmountString = add("+", trailingAmount);
            ((IDictionary<string,object>)request)["trigger"] = trailingActivationPriceType;
            if (isTrue(isTrue(isLimitOrder) || isTrue((!isEqual(trailingLimitAmount, null)))))
            {
                object offset = this.safeString(parameters, "offset", "-");
                object trailingLimitAmountString = add(offset, this.numberToString(trailingLimitAmount));
                ((IDictionary<string,object>)request)["price"] = trailingAmountString;
                ((IDictionary<string,object>)request)["price2"] = trailingLimitAmountString;
                ((IDictionary<string,object>)request)["ordertype"] = "trailing-stop-limit";
            } else
            {
                ((IDictionary<string,object>)request)["price"] = trailingAmountString;
                ((IDictionary<string,object>)request)["ordertype"] = "trailing-stop";
            }
        }
        if (isTrue(reduceOnly))
        {
            if (isTrue(isEqual(method, "createOrderWs")))
            {
                ((IDictionary<string,object>)request)["reduce_only"] = true; // ws request can't have stringified bool
            } else
            {
                ((IDictionary<string,object>)request)["reduce_only"] = "true"; // not using boolean in this case, because the urlencodedNested transforms it into 'True' string
            }
        }
        object close = this.safeValue(parameters, "close");
        if (isTrue(!isEqual(close, null)))
        {
            close = this.extend(new Dictionary<string, object>() {}, close);
            object closePrice = this.safeValue(close, "price");
            if (isTrue(!isEqual(closePrice, null)))
            {
                ((IDictionary<string,object>)close)["price"] = this.priceToPrecision(symbol, closePrice);
            }
            object closePrice2 = this.safeValue(close, "price2"); // stopPrice
            if (isTrue(!isEqual(closePrice2, null)))
            {
                ((IDictionary<string,object>)close)["price2"] = this.priceToPrecision(symbol, closePrice2);
            }
            ((IDictionary<string,object>)request)["close"] = close;
        }
        object timeInForce = this.safeString2(parameters, "timeInForce", "timeinforce");
        if (isTrue(!isEqual(timeInForce, null)))
        {
            ((IDictionary<string,object>)request)["timeinforce"] = timeInForce;
        }
        object isMarket = (isEqual(type, "market"));
        object postOnly = null;
        var postOnlyparametersVariable = this.handlePostOnly(isMarket, false, parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["oflags"] = "post";
        }
        parameters = this.omit(parameters, new List<object>() {"timeInForce", "reduceOnly", "stopLossPrice", "takeProfitPrice", "trailingAmount", "trailingLimitAmount", "offset"});
        return new List<object>() {request, parameters};
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#editOrder
        * @description edit a trade order
        * @see https://docs.kraken.com/rest/#tag/Trading/operation/editOrder
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of the currency you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.stopLossPrice] *margin only* the price that a stop loss order is triggered at
        * @param {float} [params.takeProfitPrice] *margin only* the price that a take profit order is triggered at
        * @param {string} [params.trailingAmount] *margin only* the quote price away from the current market price
        * @param {string} [params.trailingLimitAmount] *margin only* the quote amount away from the trailingAmount
        * @param {string} [params.offset] *margin only* '+' or '-' whether you want the trailingLimitAmount value to be positive or negative, default is negative '-'
        * @param {string} [params.trigger] *margin only* the activation price type, 'last' or 'index', default is 'last'
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " editOrder() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "txid", id },
            { "pair", getValue(market, "id") },
        };
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["volume"] = this.amountToPrecision(symbol, amount);
        }
        object orderRequest = this.orderRequest("editOrder", symbol, type, request, price, parameters);
        object response = await this.privatePostEditOrder(this.extend(getValue(orderRequest, 0), getValue(orderRequest, 1)));
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "status": "ok",
        //             "txid": "OAW2BO-7RWEK-PZY5UO",
        //             "originaltxid": "OXL6SS-UPNMC-26WBE7",
        //             "volume": "0.00075000",
        //             "price": "13500.0",
        //             "orders_cancelled": 1,
        //             "descr": {
        //                 "order": "buy 0.00075000 XBTUSDT @ limit 13500.0"
        //             }
        //         }
        //     }
        //
        object data = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://docs.kraken.com/rest/#tag/Account-Data/operation/getOrdersInfo
        * @param {string} symbol not used by kraken fetchOrder
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object clientOrderId = this.safeValue2(parameters, "userref", "clientOrderId");
        object request = new Dictionary<string, object>() {
            { "trades", true },
        };
        object query = parameters;
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["userref"] = clientOrderId;
            query = this.omit(parameters, new List<object>() {"userref", "clientOrderId"});
        } else
        {
            ((IDictionary<string,object>)request)["txid"] = id;
        }
        object response = await this.privatePostQueryOrders(this.extend(request, query));
        //
        //     {
        //         "error":[],
        //         "result":{
        //             "OTLAS3-RRHUF-NDWH5A":{
        //                 "refid":null,
        //                 "userref":null,
        //                 "status":"closed",
        //                 "reason":null,
        //                 "opentm":1586822919.3342,
        //                 "closetm":1586822919.365,
        //                 "starttm":0,
        //                 "expiretm":0,
        //                 "descr":{
        //                     "pair":"XBTUSDT",
        //                     "type":"sell",
        //                     "ordertype":"market",
        //                     "price":"0",
        //                     "price2":"0",
        //                     "leverage":"none",
        //                     "order":"sell 0.21804000 XBTUSDT @ market",
        //                     "close":""
        //                 },
        //                 "vol":"0.21804000",
        //                 "vol_exec":"0.21804000",
        //                 "cost":"1493.9",
        //                 "fee":"3.8",
        //                 "price":"6851.5",
        //                 "stopprice":"0.00000",
        //                 "limitprice":"0.00000",
        //                 "misc":"",
        //                 "oflags":"fciq",
        //                 "trades":["TT5UC3-GOIRW-6AZZ6R"]
        //             }
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new List<object>() {});
        if (!isTrue((inOp(result, id))))
        {
            throw new OrderNotFound ((string)add(add(this.id, " fetchOrder() could not find order id "), id)) ;
        }
        return this.parseOrder(this.extend(new Dictionary<string, object>() {
            { "id", id },
        }, getValue(result, id)));
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @see https://docs.kraken.com/rest/#tag/Account-Data/operation/getTradesInfo
        * @param {string} id order id
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object orderTrades = this.safeValue(parameters, "trades");
        object tradeIds = new List<object>() {};
        if (isTrue(isEqual(orderTrades, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrderTrades() requires a unified order structure in the params argument or a \'trades\' param (an array of trade id strings)")) ;
        } else
        {
            for (object i = 0; isLessThan(i, getArrayLength(orderTrades)); postFixIncrement(ref i))
            {
                object orderTrade = getValue(orderTrades, i);
                if (isTrue((orderTrade is string)))
                {
                    ((IList<object>)tradeIds).Add(orderTrade);
                } else
                {
                    ((IList<object>)tradeIds).Add(getValue(orderTrade, "id"));
                }
            }
        }
        await this.loadMarkets();
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
        }
        object options = this.safeValue(this.options, "fetchOrderTrades", new Dictionary<string, object>() {});
        object batchSize = this.safeInteger(options, "batchSize", 20);
        object numTradeIds = getArrayLength(tradeIds);
        object numBatches = this.parseToInt(divide(numTradeIds, batchSize));
        numBatches = this.sum(numBatches, 1);
        object result = new List<object>() {};
        for (object j = 0; isLessThan(j, numBatches); postFixIncrement(ref j))
        {
            object requestIds = new List<object>() {};
            for (object k = 0; isLessThan(k, batchSize); postFixIncrement(ref k))
            {
                object index = this.sum(multiply(j, batchSize), k);
                if (isTrue(isLessThan(index, numTradeIds)))
                {
                    ((IList<object>)requestIds).Add(getValue(tradeIds, index));
                }
            }
            object request = new Dictionary<string, object>() {
                { "txid", String.Join(",", ((IList<object>)requestIds).ToArray()) },
            };
            object response = await this.privatePostQueryTrades(request);
            //
            //     {
            //         "error": [],
            //         "result": {
            //             'TIMIRG-WUNNE-RRJ6GT': {
            //                 "ordertxid": 'OQRPN2-LRHFY-HIFA7D',
            //                 "postxid": 'TKH2SE-M7IF5-CFI7LT',
            //                 "pair": 'USDCUSDT',
            //                 "time": 1586340086.457,
            //                 "type": 'sell',
            //                 "ordertype": 'market',
            //                 "price": '0.99860000',
            //                 "cost": '22.16892001',
            //                 "fee": '0.04433784',
            //                 "vol": '22.20000000',
            //                 "margin": '0.00000000',
            //                 "misc": ''
            //             }
            //         }
            //     }
            //
            object rawTrades = this.safeValue(response, "result");
            object ids = new List<object>(((IDictionary<string,object>)rawTrades).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
            {
                ((IDictionary<string,object>)getValue(rawTrades, getValue(ids, i)))["id"] = getValue(ids, i);
            }
            object trades = this.parseTrades(rawTrades, null, since, limit);
            object tradesFilteredBySymbol = this.filterBySymbol(trades, symbol);
            result = this.arrayConcat(result, tradesFilteredBySymbol);
        }
        return result;
    }

    public async virtual Task<object> fetchOrdersByIds(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchOrdersByIds
        * @description fetch orders by the list of order id
        * @see https://docs.kraken.com/rest/#tag/Account-Data/operation/getClosedOrders
        * @param {string[]|undefined} ids list of order id
        * @param {object} [params] extra parameters specific to the kraken api endpoint
        * @returns {object[]} a list of [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostQueryOrders(this.extend(new Dictionary<string, object>() {
            { "trades", true },
            { "txid", String.Join(",", ((IList<object>)ids).ToArray()) },
        }, parameters));
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object orders = new List<object>() {};
        object orderIds = new List<object>(((IDictionary<string,object>)result).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(orderIds)); postFixIncrement(ref i))
        {
            object id = getValue(orderIds, i);
            object item = getValue(result, id);
            object order = this.parseOrder(this.extend(new Dictionary<string, object>() {
                { "id", id },
            }, item));
            ((IList<object>)orders).Add(order);
        }
        return orders;
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://docs.kraken.com/rest/#tag/Account-Data/operation/getTradeHistory
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = this.parseToInt(divide(since, 1000));
        }
        object response = await this.privatePostTradesHistory(this.extend(request, parameters));
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "trades": {
        //                 "GJ3NYQ-XJRTF-THZABF": {
        //                     "ordertxid": "TKH2SE-ZIF5E-CFI7LT",
        //                     "postxid": "OEN3VX-M7IF5-JNBJAM",
        //                     "pair": "XICNXETH",
        //                     "time": 1527213229.4491,
        //                     "type": "sell",
        //                     "ordertype": "limit",
        //                     "price": "0.001612",
        //                     "cost": "0.025792",
        //                     "fee": "0.000026",
        //                     "vol": "16.00000000",
        //                     "margin": "0.000000",
        //                     "misc": ""
        //                 },
        //                 ...
        //             },
        //             "count": 9760,
        //         },
        //     }
        //
        object trades = getValue(getValue(response, "result"), "trades");
        object ids = new List<object>(((IDictionary<string,object>)trades).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            ((IDictionary<string,object>)getValue(trades, getValue(ids, i)))["id"] = getValue(ids, i);
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#cancelOrder
        * @description cancels an open order
        * @see https://docs.kraken.com/rest/#tag/Trading/operation/cancelOrder
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = null;
        object clientOrderId = this.safeValue2(parameters, "userref", "clientOrderId", id);
        object request = new Dictionary<string, object>() {
            { "txid", clientOrderId },
        };
        parameters = this.omit(parameters, new List<object>() {"userref", "clientOrderId"});
        try
        {
            response = await this.privatePostCancelOrder(this.extend(request, parameters));
        } catch(Exception e)
        {
            if (isTrue(this.last_http_response))
            {
                if (isTrue(isGreaterThanOrEqual(getIndexOf(this.last_http_response, "EOrder:Unknown order"), 0)))
                {
                    throw new OrderNotFound ((string)add(add(this.id, " cancelOrder() error "), this.last_http_response)) ;
                }
            }
            throw e;
        }
        return response;
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#cancelOrders
        * @description cancel multiple orders
        * @see https://docs.kraken.com/rest/#tag/Trading/operation/cancelOrderBatch
        * @param {string[]} ids open orders transaction ID (txid) or user reference (userref)
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "orders", ids },
        };
        object response = await this.privatePostCancelOrderBatch(this.extend(request, parameters));
        //
        //     {
        //         "error": [],
        //         "result": {
        //           "count": 2
        //         }
        //     }
        //
        return response;
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#cancelAllOrders
        * @description cancel all open orders
        * @see https://docs.kraken.com/rest/#tag/Trading/operation/cancelAllOrders
        * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        return await this.privatePostCancelAll(parameters);
    }

    public async override Task<object> cancelAllOrdersAfter(object timeout, object parameters = null)
    {
        /**
        * @method
        * @name kraken#cancelAllOrdersAfter
        * @description dead man's switch, cancel all orders after the given timeout
        * @see https://docs.kraken.com/rest/#tag/Spot-Trading/operation/cancelAllOrdersAfter
        * @param {number} timeout time in milliseconds, 0 represents cancel the timer
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} the api result
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isGreaterThan(timeout, 86400000)))
        {
            throw new BadRequest ((string)add(this.id, "cancelAllOrdersAfter timeout should be less than 86400000 milliseconds")) ;
        }
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "timeout", ((bool) isTrue((isGreaterThan(timeout, 0)))) ? (this.parseToInt(divide(timeout, 1000))) : 0 },
        };
        object response = await this.privatePostCancelAllOrdersAfter(this.extend(request, parameters));
        //
        //     {
        //         "error": [ ],
        //         "result": {
        //             "currentTime": "2023-03-24T17:41:56Z",
        //             "triggerTime": "2023-03-24T17:42:56Z"
        //         }
        //     }
        //
        return response;
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://docs.kraken.com/rest/#tag/Account-Data/operation/getOpenOrders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = this.parseToInt(divide(since, 1000));
        }
        object query = parameters;
        object clientOrderId = this.safeValue2(parameters, "userref", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["userref"] = clientOrderId;
            query = this.omit(parameters, new List<object>() {"userref", "clientOrderId"});
        }
        object response = await this.privatePostOpenOrders(this.extend(request, query));
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        object orders = this.safeDict(result, "open", new Dictionary<string, object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://docs.kraken.com/rest/#tag/Account-Data/operation/getClosedOrders
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp in ms of the latest entry
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = this.parseToInt(divide(since, 1000));
        }
        object query = parameters;
        object clientOrderId = this.safeValue2(parameters, "userref", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["userref"] = clientOrderId;
            query = this.omit(parameters, new List<object>() {"userref", "clientOrderId"});
        }
        var requestparametersVariable = this.handleUntilOption("end", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privatePostClosedOrders(this.extend(request, query));
        //
        //     {
        //         "error":[],
        //         "result":{
        //             "closed":{
        //                 "OETZYO-UL524-QJMXCT":{
        //                     "refid":null,
        //                     "userref":null,
        //                     "status":"canceled",
        //                     "reason":"User requested",
        //                     "opentm":1601489313.3898,
        //                     "closetm":1601489346.5507,
        //                     "starttm":0,
        //                     "expiretm":0,
        //                     "descr":{
        //                         "pair":"ETHUSDT",
        //                         "type":"buy",
        //                         "ordertype":"limit",
        //                         "price":"330.00",
        //                         "price2":"0",
        //                         "leverage":"none",
        //                         "order":"buy 0.02100000 ETHUSDT @ limit 330.00",
        //                         "close":""
        //                     },
        //                     "vol":"0.02100000",
        //                     "vol_exec":"0.00000000",
        //                     "cost":"0.00000",
        //                     "fee":"0.00000",
        //                     "price":"0.00000",
        //                     "stopprice":"0.00000",
        //                     "limitprice":"0.00000",
        //                     "misc":"",
        //                     "oflags":"fciq"
        //                 },
        //             },
        //             "count":16
        //         }
        //     }
        //
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        object orders = this.safeDict(result, "closed", new Dictionary<string, object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public virtual object parseTransactionStatus(object status)
    {
        // IFEX transaction states
        object statuses = new Dictionary<string, object>() {
            { "Initial", "pending" },
            { "Pending", "pending" },
            { "Success", "ok" },
            { "Settled", "pending" },
            { "Failure", "failed" },
            { "Partial", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseNetwork(object network)
    {
        object withdrawMethods = this.safeValue(this.options, "withdrawMethods", new Dictionary<string, object>() {});
        return this.safeString(withdrawMethods, network, network);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //     {
        //         "method": "Ether (Hex)",
        //         "aclass": "currency",
        //         "asset": "XETH",
        //         "refid": "Q2CANKL-LBFVEE-U4Y2WQ",
        //         "txid": "0x57fd704dab1a73c20e24c8696099b695d596924b401b261513cfdab23…",
        //         "info": "0x615f9ba7a9575b0ab4d571b2b36b1b324bd83290",
        //         "amount": "7.9999257900",
        //         "fee": "0.0000000000",
        //         "time":  1529223212,
        //         "status": "Success"
        //     }
        //
        // there can be an additional 'status-prop' field present
        // deposit pending review by exchange => 'on-hold'
        // the deposit is initiated by the exchange => 'return'
        //
        //      {
        //          "type": 'deposit',
        //          "method": 'Fidor Bank AG (Wire Transfer)',
        //          "aclass": 'currency',
        //          "asset": 'ZEUR',
        //          "refid": 'xxx-xxx-xxx',
        //          "txid": '12341234',
        //          "info": 'BANKCODEXXX',
        //          "amount": '38769.08',
        //          "fee": '0.0000',
        //          "time": 1644306552,
        //          "status": 'Success',
        //          status-prop: 'on-hold'
        //      }
        //
        //
        // fetchWithdrawals
        //
        //     {
        //         "method": "Ether",
        //         "aclass": "currency",
        //         "asset": "XETH",
        //         "refid": "A2BF34S-O7LBNQ-UE4Y4O",
        //         "txid": "0x288b83c6b0904d8400ef44e1c9e2187b5c8f7ea3d838222d53f701a15b5c274d",
        //         "info": "0x7cb275a5e07ba943fee972e165d80daa67cb2dd0",
        //         "amount": "9.9950000000",
        //         "fee": "0.0050000000",
        //         "time":  1530481750,
        //         "status": "Success"
        //         "key":"Huobi wallet",
        //         "network":"Tron"
        //         status-prop: 'on-hold' // this field might not be present in some cases
        //     }
        //
        // withdraw
        //
        //     {
        //         "refid": "AGBSO6T-UFMTTQ-I7KGS6"
        //     }
        //
        object id = this.safeString(transaction, "refid");
        object txid = this.safeString(transaction, "txid");
        object timestamp = this.safeTimestamp(transaction, "time");
        object currencyId = this.safeString(transaction, "asset");
        object code = this.safeCurrencyCode(currencyId, currency);
        object address = this.safeString(transaction, "info");
        object amount = this.safeNumber(transaction, "amount");
        object status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        object statusProp = this.safeString(transaction, "status-prop");
        object isOnHoldDeposit = isEqual(statusProp, "on-hold");
        object isCancellationRequest = isEqual(statusProp, "cancel-pending");
        object isOnHoldWithdrawal = isEqual(statusProp, "onhold");
        if (isTrue(isTrue(isTrue(isOnHoldDeposit) || isTrue(isCancellationRequest)) || isTrue(isOnHoldWithdrawal)))
        {
            status = "pending";
        }
        object type = this.safeString(transaction, "type"); // injected from the outside
        object feeCost = this.safeNumber(transaction, "fee");
        if (isTrue(isEqual(feeCost, null)))
        {
            if (isTrue(isEqual(type, "deposit")))
            {
                feeCost = 0;
            }
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "currency", code },
            { "amount", amount },
            { "network", this.parseNetwork(this.safeString(transaction, "network")) },
            { "address", address },
            { "addressTo", null },
            { "addressFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "status", status },
            { "type", type },
            { "updated", null },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "comment", null },
            { "internal", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", feeCost },
            } },
        };
    }

    public virtual object parseTransactionsByType(object type, object transactions, object code = null, object since = null, object limit = null)
    {
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(transactions)); postFixIncrement(ref i))
        {
            object transaction = this.parseTransaction(this.extend(new Dictionary<string, object>() {
                { "type", type },
            }, getValue(transactions, i)));
            ((IList<object>)result).Add(transaction);
        }
        return this.filterByCurrencySinceLimit(result, code, since, limit);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://docs.kraken.com/rest/#tag/Funding/operation/getStatusRecentDeposits
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        // https://www.kraken.com/en-us/help/api#deposit-status
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDeposits() requires a currency code argument")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = since;
        }
        object response = await this.privatePostDepositStatus(this.extend(request, parameters));
        //
        //     {  error: [],
        //       "result": [ { "method": "Ether (Hex)",
        //                     "aclass": "currency",
        //                      "asset": "XETH",
        //                      "refid": "Q2CANKL-LBFVEE-U4Y2WQ",
        //                       "txid": "0x57fd704dab1a73c20e24c8696099b695d596924b401b261513cfdab23…",
        //                       "info": "0x615f9ba7a9575b0ab4d571b2b36b1b324bd83290",
        //                     "amount": "7.9999257900",
        //                        "fee": "0.0000000000",
        //                       "time":  1529223212,
        //                     "status": "Success"                                                       } ] }
        //
        return this.parseTransactionsByType("deposit", getValue(response, "result"), code, since, limit);
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @see https://docs.kraken.com/rest/#tag/Spot-Market-Data/operation/getServerTime
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        // https://www.kraken.com/en-us/features/api#get-server-time
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetTime(parameters);
        //
        //    {
        //        "error": [],
        //        "result": {
        //            "unixtime": 1591502873,
        //            "rfc1123": "Sun,  7 Jun 20 04:07:53 +0000"
        //        }
        //    }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.safeTimestamp(result, "unixtime");
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://docs.kraken.com/rest/#tag/Funding/operation/getStatusRecentWithdrawals
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {object} [params.end] End timestamp, withdrawals created strictly after will be not be included in the response
        * @param {boolean} [params.paginate]  default false, when true will automatically paginate by calling this endpoint multiple times
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchWithdrawals", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            ((IDictionary<string,object>)parameters)["cursor"] = true;
            return await this.fetchPaginatedCallCursor("fetchWithdrawals", code, since, limit, parameters, "next_cursor", "cursor");
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(code, null)))
        {
            object currency = this.currency(code);
            ((IDictionary<string,object>)request)["asset"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["since"] = ((object)since).ToString();
        }
        object response = await this.privatePostWithdrawStatus(this.extend(request, parameters));
        //
        // with no pagination
        //     {  error: [],
        //       "result": [ { "method": "Ether",
        //                     "aclass": "currency",
        //                      "asset": "XETH",
        //                      "refid": "A2BF34S-O7LBNQ-UE4Y4O",
        //                       "txid": "0x298c83c7b0904d8400ef43e1c9e2287b518f7ea3d838822d53f704a1565c274d",
        //                       "info": "0x7cb275a5e07ba943fee972e165d80daa67cb2dd0",
        //                     "amount": "9.9950000000",
        //                        "fee": "0.0050000000",
        //                       "time":  1530481750,
        //                     "status": "Success"                                                             } ] }
        // with pagination
        //    {
        //        "error":[],
        //        "result":{
        //           "withdrawals":[
        //              {
        //                 "method":"Tether USD (TRC20)",
        //                 "aclass":"currency",
        //                 "asset":"USDT",
        //                 "refid":"BSNFZU2-MEFN4G-J3NEZV",
        //                 "txid":"1c7a642fb7387bbc2c6a2c509fd1ae146937f4cf793b4079a4f0715e3a02615a",
        //                 "info":"TQmdxSuC16EhFg8FZWtYgrfFRosoRF7bCp",
        //                 "amount":"1996.50000000",
        //                 "fee":"2.50000000",
        //                 "time":1669126657,
        //                 "status":"Success",
        //                 "key":"poloniex",
        //                 "network":"Tron"
        //              },
        //             ...
        //           ],
        //           "next_cursor":"HgAAAAAAAABGVFRSd3k1LVF4Y0JQY05Gd0xRY0NxenFndHpybkwBAQH2AwEBAAAAAQAAAAAAAAABAAAAAAAZAAAAAAAAAA=="
        //        }
        //     }
        //
        object rawWithdrawals = null;
        object result = this.safeValue(response, "result");
        if (!isTrue(((result is IList<object>) || (result.GetType().IsGenericType && result.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            rawWithdrawals = this.addPaginationCursorToResult(result);
        } else
        {
            rawWithdrawals = result;
        }
        return this.parseTransactionsByType("withdrawal", rawWithdrawals, code, since, limit);
    }

    public virtual object addPaginationCursorToResult(object result)
    {
        object cursor = this.safeString(result, "next_cursor");
        object data = this.safeValue(result, "withdrawals");
        object dataLength = getArrayLength(data);
        if (isTrue(isTrue(!isEqual(cursor, null)) && isTrue(isGreaterThan(dataLength, 0))))
        {
            object last = getValue(data, subtract(dataLength, 1));
            ((IDictionary<string,object>)last)["next_cursor"] = cursor;
            ((List<object>)data)[Convert.ToInt32(subtract(dataLength, 1))] = last;
        }
        return data;
    }

    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name kraken#createDepositAddress
        * @description create a currency deposit address
        * @see https://docs.kraken.com/rest/#tag/Funding/operation/getDepositAddresses
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "new", "true" },
        };
        return await this.fetchDepositAddress(code, this.extend(request, parameters));
    }

    public async virtual Task<object> fetchDepositMethods(object code, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchDepositMethods
        * @description fetch deposit methods for a currency associated with this account
        * @see https://docs.kraken.com/rest/#tag/Funding/operation/getDepositMethods
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the kraken api endpoint
        * @returns {object} of deposit methods
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
        };
        object response = await this.privatePostDepositMethods(this.extend(request, parameters));
        //
        //     {
        //         "error":[],
        //         "result":[
        //             {"method":"Ether (Hex)","limit":false,"gen-address":true}
        //         ]
        //     }
        //
        //     {
        //         "error":[],
        //         "result":[
        //             {"method":"Tether USD (ERC20)","limit":false,"address-setup-fee":"0.00000000","gen-address":true},
        //             {"method":"Tether USD (TRC20)","limit":false,"address-setup-fee":"0.00000000","gen-address":true}
        //         ]
        //     }
        //
        //     {
        //         "error":[],
        //         "result":[
        //             {"method":"Bitcoin","limit":false,"fee":"0.0000000000","gen-address":true}
        //         ]
        //     }
        //
        return this.safeValue(response, "result");
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://docs.kraken.com/rest/#tag/Funding/operation/getDepositAddresses
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object network = this.safeStringUpper(parameters, "network");
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        network = this.safeString(networks, network, network); // support ETH > ERC20 aliases
        parameters = this.omit(parameters, "network");
        if (isTrue(isTrue((isEqual(code, "USDT"))) && isTrue((isEqual(network, "TRC20")))))
        {
            code = add(add(code, "-"), network);
        }
        object defaultDepositMethods = this.safeValue(this.options, "depositMethods", new Dictionary<string, object>() {});
        object defaultDepositMethod = this.safeString(defaultDepositMethods, code);
        object depositMethod = this.safeString(parameters, "method", defaultDepositMethod);
        // if the user has specified an exchange-specific method in params
        // we pass it as is, otherwise we take the 'network' unified param
        if (isTrue(isEqual(depositMethod, null)))
        {
            object depositMethods = await this.fetchDepositMethods(code);
            if (isTrue(!isEqual(network, null)))
            {
                // find best matching deposit method, or fallback to the first one
                for (object i = 0; isLessThan(i, getArrayLength(depositMethods)); postFixIncrement(ref i))
                {
                    object entry = this.safeString(getValue(depositMethods, i), "method");
                    if (isTrue(isGreaterThanOrEqual(getIndexOf(entry, network), 0)))
                    {
                        depositMethod = entry;
                        break;
                    }
                }
            }
            // if depositMethod was not specified, fallback to the first available deposit method
            if (isTrue(isEqual(depositMethod, null)))
            {
                object firstDepositMethod = this.safeValue(depositMethods, 0, new Dictionary<string, object>() {});
                depositMethod = this.safeString(firstDepositMethod, "method");
            }
        }
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "method", depositMethod },
        };
        object response = await this.privatePostDepositAddresses(this.extend(request, parameters));
        //
        //     {
        //         "error":[],
        //         "result":[
        //             {"address":"0x77b5051f97efa9cc52c9ad5b023a53fc15c200d3","expiretm":"0"}
        //         ]
        //     }
        //
        object result = this.safeValue(response, "result", new List<object>() {});
        object firstResult = this.safeValue(result, 0, new Dictionary<string, object>() {});
        if (isTrue(isEqual(firstResult, null)))
        {
            throw new InvalidAddress ((string)add(add(this.id, " privatePostDepositAddresses() returned no addresses for "), code)) ;
        }
        return this.parseDepositAddress(firstResult, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "address":"0x77b5051f97efa9cc52c9ad5b023a53fc15c200d3",
        //         "expiretm":"0"
        //     }
        //
        object address = this.safeString(depositAddress, "address");
        object tag = this.safeString(depositAddress, "tag");
        currency = this.safeCurrency(null, currency);
        object code = getValue(currency, "code");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", null },
            { "info", depositAddress },
        };
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#withdraw
        * @description make a withdrawal
        * @see https://docs.kraken.com/rest/#tag/Funding/operation/withdrawFunds
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        if (isTrue(inOp(parameters, "key")))
        {
            await this.loadMarkets();
            object currency = this.currency(code);
            object request = new Dictionary<string, object>() {
                { "asset", getValue(currency, "id") },
                { "amount", amount },
                { "address", address },
            };
            object response = await this.privatePostWithdraw(this.extend(request, parameters));
            //
            //     {
            //         "error": [],
            //         "result": {
            //             "refid": "AGBSO6T-UFMTTQ-I7KGS6"
            //         }
            //     }
            //
            object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
            return this.parseTransaction(result, currency);
        }
        throw new ExchangeError ((string)add(this.id, " withdraw() requires a \'key\' parameter (withdrawal key name, as set up on your account)")) ;
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchPositions
        * @description fetch all open positions
        * @see https://docs.kraken.com/rest/#tag/Account-Data/operation/getOpenPositions
        * @param {string[]} [symbols] not used by kraken fetchPositions ()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "docalcs", "true" },
            { "consolidation", "market" },
        };
        object response = await this.privatePostOpenPositions(this.extend(request, parameters));
        //
        // no consolidation
        //
        //     {
        //         "error": [],
        //         "result": {
        //             'TGUFMY-FLESJ-VYIX3J': {
        //                 "ordertxid": "O3LRNU-ZKDG5-XNCDFR",
        //                 "posstatus": "open",
        //                 "pair": "ETHUSDT",
        //                 "time":  1611557231.4584,
        //                 "type": "buy",
        //                 "ordertype": "market",
        //                 "cost": "28.49800",
        //                 "fee": "0.07979",
        //                 "vol": "0.02000000",
        //                 "vol_closed": "0.00000000",
        //                 "margin": "14.24900",
        //                 "terms": "0.0200% per 4 hours",
        //                 "rollovertm": "1611571631",
        //                 "misc": "",
        //                 "oflags": ""
        //             }
        //         }
        //     }
        //
        // consolidation by market
        //
        //     {
        //         "error": [],
        //         "result": [
        //             {
        //                 "pair": "ETHUSDT",
        //                 "positions": "1",
        //                 "type": "buy",
        //                 "leverage": "2.00000",
        //                 "cost": "28.49800",
        //                 "fee": "0.07979",
        //                 "vol": "0.02000000",
        //                 "vol_closed": "0.00000000",
        //                 "margin": "14.24900"
        //             }
        //         ]
        //     }
        //
        symbols = this.marketSymbols(symbols);
        object result = this.safeList(response, "result");
        object results = this.parsePositions(result, symbols);
        return this.filterByArrayPositions(results, "symbol", symbols, false);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //             {
        //                 "pair": "ETHUSDT",
        //                 "positions": "1",
        //                 "type": "buy",
        //                 "leverage": "2.00000",
        //                 "cost": "28.49800",
        //                 "fee": "0.07979",
        //                 "vol": "0.02000000",
        //                 "vol_closed": "0.00000000",
        //                 "margin": "14.24900"
        //             }
        //
        object marketId = this.safeString(position, "pair");
        object rawSide = this.safeString(position, "type");
        object side = ((bool) isTrue((isEqual(rawSide, "buy")))) ? "long" : "short";
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", this.safeSymbol(marketId, market) },
            { "notional", null },
            { "marginMode", null },
            { "liquidationPrice", null },
            { "entryPrice", null },
            { "unrealizedPnl", this.safeNumber(position, "net") },
            { "realizedPnl", null },
            { "percentage", null },
            { "contracts", this.safeNumber(position, "vol") },
            { "contractSize", null },
            { "markPrice", null },
            { "lastPrice", null },
            { "side", side },
            { "hedged", null },
            { "timestamp", null },
            { "datetime", null },
            { "lastUpdateTimestamp", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "collateral", null },
            { "initialMargin", this.safeNumber(position, "margin") },
            { "initialMarginPercentage", null },
            { "leverage", this.safeNumber(position, "leverage") },
            { "marginRatio", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    public virtual object parseAccountType(object account)
    {
        object accountByType = new Dictionary<string, object>() {
            { "spot", "Spot Wallet" },
            { "swap", "Futures Wallet" },
            { "future", "Futures Wallet" },
        };
        return this.safeString(accountByType, account, account);
    }

    public async virtual Task<object> transferOut(object code, object amount, object parameters = null)
    {
        /**
        * @description transfer from spot wallet to futures wallet
        * @see https://docs.kraken.com/rest/#tag/User-Funding/operation/walletTransfer
        * @param {str} code Unified currency code
        * @param {float} amount Size of the transfer
        * @param {dict} [params] Exchange specific parameters
        * @returns a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.transfer(code, amount, "spot", "swap", parameters);
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name kraken#transfer
        * @see https://docs.kraken.com/rest/#tag/User-Funding/operation/walletTransfer
        * @description transfers currencies between sub-accounts (only spot->swap direction is supported)
        * @param {string} code Unified currency code
        * @param {float} amount Size of the transfer
        * @param {string} fromAccount 'spot' or 'Spot Wallet'
        * @param {string} toAccount 'swap' or 'Futures Wallet'
        * @param {object} [params] Exchange specific parameters
        * @returns a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        fromAccount = this.parseAccountType(fromAccount);
        toAccount = this.parseAccountType(toAccount);
        object request = new Dictionary<string, object>() {
            { "amount", this.currencyToPrecision(code, amount) },
            { "from", fromAccount },
            { "to", toAccount },
            { "asset", getValue(currency, "id") },
        };
        if (isTrue(!isEqual(fromAccount, "Spot Wallet")))
        {
            throw new BadRequest ((string)add(add(add(add(add(this.id, " transfer cannot transfer from "), fromAccount), " to "), toAccount), ". Use krakenfutures instead to transfer from the futures account.")) ;
        }
        object response = await this.privatePostWalletTransfer(this.extend(request, parameters));
        //
        //   {
        //       "error":[
        //       ],
        //       "result":{
        //          "refid":"BOIUSIF-M7DLMN-UXZ3P5"
        //       }
        //   }
        //
        object transfer = this.parseTransfer(response, currency);
        return this.extend(transfer, new Dictionary<string, object>() {
            { "amount", amount },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
        });
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer
        //
        //    {
        //        "error":[
        //        ],
        //        "result":{
        //           "refid":"BOIUSIF-M7DLMN-UXZ3P5"
        //        }
        //    }
        //
        object result = this.safeValue(transfer, "result", new Dictionary<string, object>() {});
        object refid = this.safeString(result, "refid");
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", refid },
            { "timestamp", null },
            { "datetime", null },
            { "currency", this.safeString(currency, "code") },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", "sucess" },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(add(add(add("/", this.version), "/"), api), "/"), path);
        if (isTrue(isEqual(api, "public")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                // urlencodeNested is used to address https://github.com/ccxt/ccxt/issues/12872
                url = add(url, add("?", this.urlencodeNested(parameters)));
            }
        } else if (isTrue(isEqual(api, "private")))
        {
            object isCancelOrderBatch = (isEqual(path, "CancelOrderBatch"));
            this.checkRequiredCredentials();
            object nonce = ((object)this.nonce()).ToString();
            // urlencodeNested is used to address https://github.com/ccxt/ccxt/issues/12872
            if (isTrue(isCancelOrderBatch))
            {
                body = this.json(this.extend(new Dictionary<string, object>() {
                    { "nonce", nonce },
                }, parameters));
            } else
            {
                body = this.urlencodeNested(this.extend(new Dictionary<string, object>() {
                    { "nonce", nonce },
                }, parameters));
            }
            object auth = this.encode(add(nonce, body));
            object hash = this.hash(auth, sha256, "binary");
            object binary = this.encode(url);
            object binhash = this.binaryConcat(binary, hash);
            object secret = this.base64ToBinary(this.secret);
            object signature = this.hmac(binhash, secret, sha512, "base64");
            headers = new Dictionary<string, object>() {
                { "API-Key", this.apiKey },
                { "API-Sign", signature },
            };
            if (isTrue(isCancelOrderBatch))
            {
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
            } else
            {
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/x-www-form-urlencoded";
            }
        } else
        {
            url = add("/", path);
        }
        url = add(getValue(getValue(this.urls, "api"), api), url);
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(code, 520)))
        {
            throw new ExchangeNotAvailable ((string)add(add(add(add(this.id, " "), ((object)code).ToString()), " "), reason)) ;
        }
        // todo: rewrite this for "broad" exceptions matching
        if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "Invalid order"), 0)))
        {
            throw new InvalidOrder ((string)add(add(this.id, " "), body)) ;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "Invalid nonce"), 0)))
        {
            throw new InvalidNonce ((string)add(add(this.id, " "), body)) ;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "Insufficient funds"), 0)))
        {
            throw new InsufficientFunds ((string)add(add(this.id, " "), body)) ;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "Cancel pending"), 0)))
        {
            throw new CancelPending ((string)add(add(this.id, " "), body)) ;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "Invalid arguments:volume"), 0)))
        {
            throw new InvalidOrder ((string)add(add(this.id, " "), body)) ;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "Rate limit exceeded"), 0)))
        {
            throw new RateLimitExceeded ((string)add(add(this.id, " "), body)) ;
        }
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        if (isTrue(isEqual(getValue(body, 0), "{")))
        {
            if (isTrue(!(response is string)))
            {
                if (isTrue(inOp(response, "error")))
                {
                    object numErrors = getArrayLength(getValue(response, "error"));
                    if (isTrue(numErrors))
                    {
                        object message = add(add(this.id, " "), body);
                        for (object i = 0; isLessThan(i, getArrayLength(getValue(response, "error"))); postFixIncrement(ref i))
                        {
                            object error = getValue(getValue(response, "error"), i);
                            this.throwExactlyMatchedException(this.exceptions, error, message);
                        }
                        throw new ExchangeError ((string)message) ;
                    }
                }
            }
        }
        return null;
    }
}
