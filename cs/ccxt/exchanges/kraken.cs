namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class kraken : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "kraken" },
            { "name", "Kraken" },
            { "countries", new List<object>() {"US"} },
            { "version", "0" },
            { "rateLimit", 1000 },
            { "certified", false },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", true },
                { "cancelAllOrdersAfter", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "createDepositAddress", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "createTrailingAmountOrder", true },
                { "createTrailingPercentOrder", true },
                { "editOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLedger", true },
                { "fetchLedgerEntry", true },
                { "fetchLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderTrades", "emulated" },
                { "fetchPositions", true },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchWithdrawals", true },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", 1 },
                { "5m", 5 },
                { "15m", 15 },
                { "30m", 30 },
                { "1h", 60 },
                { "4h", 240 },
                { "1d", 1440 },
                { "1w", 10080 },
                { "2w", 21600 },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/51840849/76173629-fc67fb00-61b1-11ea-84fe-f2de582f58a3.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.kraken.com" },
                    { "private", "https://api.kraken.com" },
                    { "zendesk", "https://kraken.zendesk.com/api/v2/help_center/en-us/articles" },
                } },
                { "www", "https://www.kraken.com" },
                { "doc", "https://docs.kraken.com/rest/" },
                { "fees", "https://www.kraken.com/en-us/features/fee-schedule" },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.0026") },
                    { "maker", this.parseNumber("0.0016") },
                    { "tiers", new Dictionary<string, object>() {
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0026")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.0024")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.0022")}, new List<object> {this.parseNumber("250000"), this.parseNumber("0.0020")}, new List<object> {this.parseNumber("500000"), this.parseNumber("0.0018")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.0016")}, new List<object> {this.parseNumber("2500000"), this.parseNumber("0.0014")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0.0001")}} },
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0016")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.0014")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("250000"), this.parseNumber("0.0010")}, new List<object> {this.parseNumber("500000"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("2500000"), this.parseNumber("0.0004")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.0002")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0.0")}} },
                    } },
                } },
            } },
            { "handleContentTypeApplicationZip", true },
            { "api", new Dictionary<string, object>() {
                { "zendesk", new Dictionary<string, object>() {
                    { "get", new List<object>() {"360000292886", "201893608"} },
                } },
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "Assets", 1 },
                        { "AssetPairs", 1 },
                        { "Depth", 1.2 },
                        { "OHLC", 1.2 },
                        { "Spread", 1 },
                        { "SystemStatus", 1 },
                        { "Ticker", 1 },
                        { "Time", 1 },
                        { "Trades", 1.2 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "post", new Dictionary<string, object>() {
                        { "AddOrder", 0 },
                        { "AddOrderBatch", 0 },
                        { "AddExport", 3 },
                        { "AmendOrder", 0 },
                        { "Balance", 3 },
                        { "CancelAll", 3 },
                        { "CancelAllOrdersAfter", 3 },
                        { "CancelOrder", 0 },
                        { "CancelOrderBatch", 0 },
                        { "ClosedOrders", 3 },
                        { "DepositAddresses", 3 },
                        { "DepositMethods", 3 },
                        { "DepositStatus", 3 },
                        { "EditOrder", 0 },
                        { "ExportStatus", 3 },
                        { "GetWebSocketsToken", 3 },
                        { "Ledgers", 6 },
                        { "OpenOrders", 3 },
                        { "OpenPositions", 3 },
                        { "QueryLedgers", 3 },
                        { "QueryOrders", 3 },
                        { "QueryTrades", 3 },
                        { "RetrieveExport", 3 },
                        { "RemoveExport", 3 },
                        { "BalanceEx", 3 },
                        { "TradeBalance", 3 },
                        { "TradesHistory", 6 },
                        { "TradeVolume", 3 },
                        { "Withdraw", 3 },
                        { "WithdrawCancel", 3 },
                        { "WithdrawInfo", 3 },
                        { "WithdrawMethods", 3 },
                        { "WithdrawAddresses", 3 },
                        { "WithdrawStatus", 3 },
                        { "WalletTransfer", 3 },
                        { "CreateSubaccount", 3 },
                        { "AccountTransfer", 3 },
                        { "Earn/Allocate", 3 },
                        { "Earn/Deallocate", 3 },
                        { "Earn/AllocateStatus", 3 },
                        { "Earn/DeallocateStatus", 3 },
                        { "Earn/Strategies", 3 },
                        { "Earn/Allocations", 3 },
                    } },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "LUNA", "LUNC" },
                { "LUNA2", "LUNA" },
                { "REPV2", "REP" },
                { "REP", "REPV1" },
                { "UST", "USTC" },
                { "XBT", "BTC" },
                { "XBT.M", "BTC.M" },
                { "XDG", "DOGE" },
            } },
            { "options", new Dictionary<string, object>() {
                { "timeDifference", 0 },
                { "adjustForTimeDifference", false },
                { "marketsByAltname", new Dictionary<string, object>() {} },
                { "delistedMarketsById", new Dictionary<string, object>() {} },
                { "inactiveCurrencies", new List<object>() {"CAD", "USD", "JPY", "GBP"} },
                { "networks", new Dictionary<string, object>() {
                    { "ETH", "ERC20" },
                    { "TRX", "TRC20" },
                } },
                { "depositMethods", new Dictionary<string, object>() {
                    { "1INCH", add(add("1inch", " "), "(1INCH)") },
                    { "AAVE", "Aave" },
                    { "ADA", "ADA" },
                    { "ALGO", "Algorand" },
                    { "ANKR", add(add("ANKR", " "), "(ANKR)") },
                    { "ANT", add(add("Aragon", " "), "(ANT)") },
                    { "ATOM", "Cosmos" },
                    { "AXS", add(add("Axie Infinity Shards", " "), "(AXS)") },
                    { "BADGER", add(add("Bager DAO", " "), "(BADGER)") },
                    { "BAL", add(add("Balancer", " "), "(BAL)") },
                    { "BAND", add(add("Band Protocol", " "), "(BAND)") },
                    { "BAT", "BAT" },
                    { "BCH", "Bitcoin Cash" },
                    { "BNC", add(add("Bifrost", " "), "(BNC)") },
                    { "BNT", add(add("Bancor", " "), "(BNT)") },
                    { "BTC", "Bitcoin" },
                    { "CHZ", add(add("Chiliz", " "), "(CHZ)") },
                    { "COMP", add(add("Compound", " "), "(COMP)") },
                    { "CQT", add(add("\tCovalent Query Token", " "), "(CQT)") },
                    { "CRV", add(add("Curve DAO Token", " "), "(CRV)") },
                    { "CTSI", add(add("Cartesi", " "), "(CTSI)") },
                    { "DAI", "Dai" },
                    { "DASH", "Dash" },
                    { "DOGE", "Dogecoin" },
                    { "DOT", "Polkadot" },
                    { "DYDX", add(add("dYdX", " "), "(DYDX)") },
                    { "ENJ", add(add("Enjin Coin", " "), "(ENJ)") },
                    { "EOS", "EOS" },
                    { "ETC", add(add("Ether Classic", " "), "(Hex)") },
                    { "ETH", add(add("Ether", " "), "(Hex)") },
                    { "EWT", "Energy Web Token" },
                    { "FEE", "Kraken Fee Credit" },
                    { "FIL", "Filecoin" },
                    { "FLOW", "Flow" },
                    { "GHST", add(add("Aavegotchi", " "), "(GHST)") },
                    { "GNO", "GNO" },
                    { "GRT", "GRT" },
                    { "ICX", "Icon" },
                    { "INJ", add(add("Injective Protocol", " "), "(INJ)") },
                    { "KAR", add(add("Karura", " "), "(KAR)") },
                    { "KAVA", "Kava" },
                    { "KEEP", add(add("Keep Token", " "), "(KEEP)") },
                    { "KNC", add(add("Kyber Network", " "), "(KNC)") },
                    { "KSM", "Kusama" },
                    { "LINK", "Link" },
                    { "LPT", add(add("Livepeer Token", " "), "(LPT)") },
                    { "LRC", add(add("Loopring", " "), "(LRC)") },
                    { "LSK", "Lisk" },
                    { "LTC", "Litecoin" },
                    { "MANA", "MANA" },
                    { "MATIC", add(add("Polygon", " "), "(MATIC)") },
                    { "MINA", "Mina" },
                    { "MIR", add(add("Mirror Protocol", " "), "(MIR)") },
                    { "MKR", add(add("Maker", " "), "(MKR)") },
                    { "MLN", "MLN" },
                    { "MOVR", add(add("Moonriver", " "), "(MOVR)") },
                    { "NANO", "NANO" },
                    { "OCEAN", "OCEAN" },
                    { "OGN", add(add("Origin Protocol", " "), "(OGN)") },
                    { "OMG", "OMG" },
                    { "OXT", add(add("Orchid", " "), "(OXT)") },
                    { "OXY", add(add("Oxygen", " "), "(OXY)") },
                    { "PAXG", add(add("PAX", " "), "(Gold)") },
                    { "PERP", add(add("Perpetual Protocol", " "), "(PERP)") },
                    { "PHA", add(add("Phala", " "), "(PHA)") },
                    { "QTUM", "QTUM" },
                    { "RARI", add(add("Rarible", " "), "(RARI)") },
                    { "RAY", add(add("Raydium", " "), "(RAY)") },
                    { "REN", add(add("Ren Protocol", " "), "(REN)") },
                    { "REP", "REPv2" },
                    { "REPV1", "REP" },
                    { "SAND", add(add("The Sandbox", " "), "(SAND)") },
                    { "SC", "Siacoin" },
                    { "SDN", add(add("Shiden", " "), "(SDN)") },
                    { "SOL", "Solana" },
                    { "SNX", add(add("Synthetix  Network", " "), "(SNX)") },
                    { "SRM", "Serum" },
                    { "STORJ", add(add("Storj", " "), "(STORJ)") },
                    { "SUSHI", add(add("Sushiswap", " "), "(SUSHI)") },
                    { "TBTC", "tBTC" },
                    { "TRX", "Tron" },
                    { "UNI", "UNI" },
                    { "USDC", "USDC" },
                    { "USDT", add(add("Tether USD", " "), "(ERC20)") },
                    { "USDT-TRC20", add(add("Tether USD", " "), "(TRC20)") },
                    { "WAVES", "Waves" },
                    { "WBTC", add(add("Wrapped Bitcoin", " "), "(WBTC)") },
                    { "XLM", "Stellar XLM" },
                    { "XMR", "Monero" },
                    { "XRP", "Ripple XRP" },
                    { "XTZ", "XTZ" },
                    { "YFI", "YFI" },
                    { "ZEC", add(add("Zcash", " "), "(Transparent)") },
                    { "ZRX", add(add("0x", " "), "(ZRX)") },
                } },
                { "withdrawMethods", new Dictionary<string, object>() {
                    { "Lightning", "Lightning" },
                    { "Bitcoin", "BTC" },
                    { "Ripple", "XRP" },
                    { "Litecoin", "LTC" },
                    { "Dogecoin", "DOGE" },
                    { "Stellar", "XLM" },
                    { "Ethereum", "ERC20" },
                    { "Arbitrum One", "Arbitrum" },
                    { "Polygon", "MATIC" },
                    { "Arbitrum Nova", "Arbitrum" },
                    { "Optimism", "Optimism" },
                    { "zkSync Era", "zkSync" },
                    { "Ethereum Classic", "ETC" },
                    { "Zcash", "ZEC" },
                    { "Monero", "XMR" },
                    { "Tron", "TRC20" },
                    { "Solana", "SOL" },
                    { "EOS", "EOS" },
                    { "Bitcoin Cash", "BCH" },
                    { "Cardano", "ADA" },
                    { "Qtum", "QTUM" },
                    { "Tezos", "XTZ" },
                    { "Cosmos", "ATOM" },
                    { "Nano", "NANO" },
                    { "Siacoin", "SC" },
                    { "Lisk", "LSK" },
                    { "Waves", "WAVES" },
                    { "ICON", "ICX" },
                    { "Algorand", "ALGO" },
                    { "Polygon - USDC.e", "MATIC" },
                    { "Arbitrum One - USDC.e", "Arbitrum" },
                    { "Polkadot", "DOT" },
                    { "Kava", "KAVA" },
                    { "Filecoin", "FIL" },
                    { "Kusama", "KSM" },
                    { "Flow", "FLOW" },
                    { "Energy Web", "EW" },
                    { "Mina", "MINA" },
                    { "Centrifuge", "CFG" },
                    { "Karura", "KAR" },
                    { "Moonriver", "MOVR" },
                    { "Shiden", "SDN" },
                    { "Khala", "PHA" },
                    { "Bifrost Kusama", "BNC" },
                    { "Songbird", "SGB" },
                    { "Terra classic", "LUNC" },
                    { "KILT", "KILT" },
                    { "Basilisk", "BSX" },
                    { "Flare", "FLR" },
                    { "Avalanche C-Chain", "AVAX" },
                    { "Kintsugi", "KINT" },
                    { "Altair", "AIR" },
                    { "Moonbeam", "GLMR" },
                    { "Acala", "ACA" },
                    { "Astar", "ASTR" },
                    { "Akash", "AKT" },
                    { "Robonomics", "XRT" },
                    { "Fantom", "FTM" },
                    { "Elrond", "EGLD" },
                    { "THORchain", "RUNE" },
                    { "Secret", "SCRT" },
                    { "Near", "NEAR" },
                    { "Internet Computer Protocol", "ICP" },
                    { "Picasso", "PICA" },
                    { "Crust Shadow", "CSM" },
                    { "Integritee", "TEER" },
                    { "Parallel Finance", "PARA" },
                    { "HydraDX", "HDX" },
                    { "Interlay", "INTR" },
                    { "Fetch.ai", "FET" },
                    { "NYM", "NYM" },
                    { "Terra 2.0", "LUNA2" },
                    { "Juno", "JUNO" },
                    { "Nodle", "NODL" },
                    { "Stacks", "STX" },
                    { "Ethereum PoW", "ETHW" },
                    { "Aptos", "APT" },
                    { "Sui", "SUI" },
                    { "Genshiro", "GENS" },
                    { "Aventus", "AVT" },
                    { "Sei", "SEI" },
                    { "OriginTrail", "OTP" },
                    { "Celestia", "TIA" },
                } },
            } },
            { "features", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "sandbox", false },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", false },
                        { "triggerPriceType", null },
                        { "triggerDirection", false },
                        { "stopLossPrice", true },
                        { "takeProfitPrice", true },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "trailing", true },
                        { "leverage", false },
                        { "marketBuyByCost", true },
                        { "marketBuyRequiresPrice", false },
                        { "selfTradePrevention", true },
                        { "iceberg", true },
                    } },
                    { "createOrders", null },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", null },
                        { "daysBack", null },
                        { "untilDays", null },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", null },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", null },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", null },
                        { "daysBack", null },
                        { "daysBackCanceled", null },
                        { "untilDays", 100000 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 720 },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "EQuery:Invalid asset pair", typeof(BadSymbol) },
                    { "EAPI:Invalid key", typeof(AuthenticationError) },
                    { "EFunding:Unknown withdraw key", typeof(InvalidAddress) },
                    { "EFunding:Invalid amount", typeof(InsufficientFunds) },
                    { "EService:Unavailable", typeof(ExchangeNotAvailable) },
                    { "EDatabase:Internal error", typeof(ExchangeNotAvailable) },
                    { "EService:Busy", typeof(ExchangeNotAvailable) },
                    { "EQuery:Unknown asset", typeof(BadSymbol) },
                    { "EAPI:Rate limit exceeded", typeof(DDoSProtection) },
                    { "EOrder:Rate limit exceeded", typeof(DDoSProtection) },
                    { "EGeneral:Internal error", typeof(ExchangeNotAvailable) },
                    { "EGeneral:Temporary lockout", typeof(DDoSProtection) },
                    { "EGeneral:Permission denied", typeof(PermissionDenied) },
                    { "EGeneral:Invalid arguments:price", typeof(InvalidOrder) },
                    { "EOrder:Unknown order", typeof(InvalidOrder) },
                    { "EOrder:Invalid price:Invalid price argument", typeof(InvalidOrder) },
                    { "EOrder:Order minimum not met", typeof(InvalidOrder) },
                    { "EOrder:Insufficient funds", typeof(InsufficientFunds) },
                    { "EGeneral:Invalid arguments", typeof(BadRequest) },
                    { "ESession:Invalid session", typeof(AuthenticationError) },
                    { "EAPI:Invalid nonce", typeof(InvalidNonce) },
                    { "EFunding:No funding method", typeof(BadRequest) },
                    { "EFunding:Unknown asset", typeof(BadSymbol) },
                    { "EService:Market in post_only mode", typeof(OnMaintenance) },
                    { "EGeneral:Too many requests", typeof(DDoSProtection) },
                    { "ETrade:User Locked", typeof(AccountSuspended) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { ":Invalid order", typeof(InvalidOrder) },
                    { ":Invalid arguments:volume", typeof(InvalidOrder) },
                    { ":Invalid arguments:viqc", typeof(InvalidOrder) },
                    { ":Invalid nonce", typeof(InvalidNonce) },
                    { ":IInsufficient funds", typeof(InsufficientFunds) },
                    { ":Cancel pending", typeof(CancelPending) },
                    { ":Rate limit exceeded", typeof(RateLimitExceeded) },
                } },
            } },
        });
    }

    public override object feeToPrecision(object symbol, object fee)
    {
        return this.decimalToPrecision(fee, TRUNCATE, getValue(getValue(getValue(this.markets, symbol), "precision"), "amount"), this.precisionMode);
    }

    /**
     * @method
     * @name kraken#fetchMarkets
     * @description retrieves data on all markets for kraken
     * @see https://docs.kraken.com/rest/#tag/Spot-Market-Data/operation/getTradableAssetPairs
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.options, "adjustForTimeDifference")))
        {
            await this.loadTimeDifference();
        }
        object response = await this.publicGetAssetPairs(parameters);
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "ADAETH": {
        //                 "altname": "ADAETH",
        //                 "wsname": "ADA\/ETH",
        //                 "aclass_base": "currency",
        //                 "base": "ADA",
        //                 "aclass_quote": "currency",
        //                 "quote": "XETH",
        //                 "lot": "unit",
        //                 "pair_decimals": 7,
        //                 "lot_decimals": 8,
        //                 "lot_multiplier": 1,
        //                 "leverage_buy": [],
        //                 "leverage_sell": [],
        //                 "fees": [
        //                     [0, 0.26],
        //                     [50000, 0.24],
        //                     [100000, 0.22],
        //                     [250000, 0.2],
        //                     [500000, 0.18],
        //                     [1000000, 0.16],
        //                     [2500000, 0.14],
        //                     [5000000, 0.12],
        //                     [10000000, 0.1]
        //                 ],
        //                 "fees_maker": [
        //                     [0, 0.16],
        //                     [50000, 0.14],
        //                     [100000, 0.12],
        //                     [250000, 0.1],
        //                     [500000, 0.08],
        //                     [1000000, 0.06],
        //                     [2500000, 0.04],
        //                     [5000000, 0.02],
        //                     [10000000, 0]
        //                 ],
        //                 "fee_volume_currency": "ZUSD",
        //                 "margin_call": 80,
        //                 "margin_stop": 40,
        //                 "ordermin": "1"
        //             },
        //         }
        //     }
        //
        object markets = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object keys = new List<object>(((IDictionary<string,object>)markets).Keys);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object id = getValue(keys, i);
            object market = getValue(markets, id);
            object baseId = this.safeString(market, "base");
            object quoteId = this.safeString(market, "quote");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object darkpool = isGreaterThanOrEqual(getIndexOf(id, ".d"), 0);
            object altname = this.safeString(market, "altname");
            object makerFees = this.safeValue(market, "fees_maker", new List<object>() {});
            object firstMakerFee = this.safeValue(makerFees, 0, new List<object>() {});
            object firstMakerFeeRate = this.safeString(firstMakerFee, 1);
            object maker = null;
            if (isTrue(!isEqual(firstMakerFeeRate, null)))
            {
                maker = this.parseNumber(Precise.stringDiv(firstMakerFeeRate, "100"));
            }
            object takerFees = this.safeValue(market, "fees", new List<object>() {});
            object firstTakerFee = this.safeValue(takerFees, 0, new List<object>() {});
            object firstTakerFeeRate = this.safeString(firstTakerFee, 1);
            object taker = null;
            if (isTrue(!isEqual(firstTakerFeeRate, null)))
            {
                taker = this.parseNumber(Precise.stringDiv(firstTakerFeeRate, "100"));
            }
            object leverageBuy = this.safeValue(market, "leverage_buy", new List<object>() {});
            object leverageBuyLength = getArrayLength(leverageBuy);
            object precisionPrice = this.parseNumber(this.parsePrecision(this.safeString(market, "pair_decimals")));
            object status = this.safeString(market, "status");
            object isActive = isEqual(status, "online");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "wsId", this.safeString(market, "wsname") },
                { "symbol", ((bool) isTrue(darkpool)) ? altname : (add(add(bs, "/"), quote)) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "darkpool", darkpool },
                { "altname", getValue(market, "altname") },
                { "type", "spot" },
                { "spot", true },
                { "margin", (isGreaterThan(leverageBuyLength, 0)) },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", isActive },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", taker },
                { "maker", maker },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "lot_decimals"))) },
                    { "price", precisionPrice },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.parseNumber("1") },
                        { "max", this.safeNumber(leverageBuy, subtract(leverageBuyLength, 1), 1) },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "ordermin") },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", precisionPrice },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "costmin") },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", market },
            });
        }
        result = this.appendInactiveMarkets(result);
        ((IDictionary<string,object>)this.options)["marketsByAltname"] = this.indexBy(result, "altname");
        return result;
    }

    public override object safeCurrency(object currencyId, object currency = null)
    {
        if (isTrue(!isEqual(currencyId, null)))
        {
            if (isTrue(isGreaterThan(getArrayLength(currencyId), 3)))
            {
                if (isTrue(isTrue((isEqual(getIndexOf(currencyId, "X"), 0))) || isTrue((isEqual(getIndexOf(currencyId, "Z"), 0)))))
                {
                    if (isTrue(!isTrue((isGreaterThan(getIndexOf(currencyId, "."), 0))) && isTrue((!isEqual(currencyId, "ZEUS")))))
                    {
                        currencyId = slice(currencyId, 1, null);
                    }
                }
            }
        }
        return base.safeCurrency(currencyId, currency);
    }

    public virtual object appendInactiveMarkets(object result)
    {
        // result should be an array to append to
        object precision = new Dictionary<string, object>() {
            { "amount", this.parseNumber("1e-8") },
            { "price", this.parseNumber("1e-8") },
        };
        object costLimits = new Dictionary<string, object>() {
            { "min", null },
            { "max", null },
        };
        object priceLimits = new Dictionary<string, object>() {
            { "min", getValue(precision, "price") },
            { "max", null },
        };
        object amountLimits = new Dictionary<string, object>() {
            { "min", getValue(precision, "amount") },
            { "max", null },
        };
        object limits = new Dictionary<string, object>() {
            { "amount", amountLimits },
            { "price", priceLimits },
            { "cost", costLimits },
        };
        object defaults = new Dictionary<string, object>() {
            { "darkpool", false },
            { "info", null },
            { "maker", null },
            { "taker", null },
            { "active", false },
            { "precision", precision },
            { "limits", limits },
        };
        object markets = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.extend(defaults, getValue(markets, i)));
        }
        return result;
    }

    /**
     * @method
     * @name kraken#fetchStatus
     * @description the latest known information on the availability of the exchange API
     * @see https://docs.kraken.com/api/docs/rest-api/get-system-status/
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
     */
    public async override Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetSystemStatus(parameters);
        //
        // {
        //     error: [],
        //     result: { status: 'online', timestamp: '2024-07-22T16:34:44Z' }
        // }
        //
        object result = this.safeDict(response, "result");
        object statusRaw = this.safeString(result, "status");
        return new Dictionary<string, object>() {
            { "status", ((bool) isTrue((isEqual(statusRaw, "online")))) ? "ok" : "maintenance" },
            { "updated", null },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    /**
     * @method
     * @name kraken#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://docs.kraken.com/rest/#tag/Spot-Market-Data/operation/getAssetInfo
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetAssets(parameters);
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "BCH": {
        //                 "aclass": "currency",
        //                 "altname": "BCH",
        //                 "decimals": 10,
        //                 "display_decimals": 5
        //                 "status": "enabled",
        //             },
        //             ...
        //         },
        //     }
        //
        object currencies = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object ids = new List<object>(((IDictionary<string,object>)currencies).Keys);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object id = getValue(ids, i);
            object currency = getValue(currencies, id);
            // todo: will need to rethink the fees
            // see: https://support.kraken.com/hc/en-us/articles/201893608-What-are-the-withdrawal-fees-
            // to add support for multiple withdrawal/deposit methods and
            // differentiated fees for each particular method
            object code = this.safeCurrencyCode(id);
            object precision = this.parseNumber(this.parsePrecision(this.safeString(currency, "decimals")));
            // assumes all currencies are active except those listed above
            object active = isEqual(this.safeString(currency, "status"), "enabled");
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "code", code },
                { "info", currency },
                { "name", this.safeString(currency, "altname") },
                { "active", active },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "precision", precision },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", precision },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "networks", new Dictionary<string, object>() {} },
            };
        }
        return result;
    }

    /**
     * @method
     * @name kraken#fetchTradingFee
     * @description fetch the trading fees for a market
     * @see https://docs.kraken.com/rest/#tag/Account-Data/operation/getTradeVolume
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
            { "fee-info", true },
        };
        object response = await this.privatePostTradeVolume(this.extend(request, parameters));
        //
        //     {
        //        "error": [],
        //        "result": {
        //          "currency": 'ZUSD',
        //          "volume": '0.0000',
        //          "fees": {
        //            "XXBTZUSD": {
        //              "fee": '0.2600',
        //              "minfee": '0.1000',
        //              "maxfee": '0.2600',
        //              "nextfee": '0.2400',
        //              "tiervolume": '0.0000',
        //              "nextvolume": '50000.0000'
        //            }
        //          },
        //          "fees_maker": {
        //            "XXBTZUSD": {
        //              "fee": '0.1600',
        //              "minfee": '0.0000',
        //              "maxfee": '0.1600',
        //              "nextfee": '0.1400',
        //              "tiervolume": '0.0000',
        //              "nextvolume": '50000.0000'
        //            }
        //          }
        //        }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseTradingFee(result, market);
    }

    public virtual object parseTradingFee(object response, object market)
    {
        object makerFees = this.safeValue(response, "fees_maker", new Dictionary<string, object>() {});
        object takerFees = this.safeValue(response, "fees", new Dictionary<string, object>() {});
        object symbolMakerFee = this.safeValue(makerFees, getValue(market, "id"), new Dictionary<string, object>() {});
        object symbolTakerFee = this.safeValue(takerFees, getValue(market, "id"), new Dictionary<string, object>() {});
        return new Dictionary<string, object>() {
            { "info", response },
            { "symbol", getValue(market, "symbol") },
            { "maker", this.parseNumber(Precise.stringDiv(this.safeString(symbolMakerFee, "fee"), "100")) },
            { "taker", this.parseNumber(Precise.stringDiv(this.safeString(symbolTakerFee, "fee"), "100")) },
            { "percentage", true },
            { "tierBased", true },
        };
    }

    public override object parseBidAsk(object bidask, object priceKey = null, object amountKey = null, object countOrIdKey = null)
    {
        priceKey ??= 0;
        amountKey ??= 1;
        countOrIdKey ??= 2;
        object price = this.safeNumber(bidask, priceKey);
        object amount = this.safeNumber(bidask, amountKey);
        object timestamp = this.safeInteger(bidask, 2);
        return new List<object>() {price, amount, timestamp};
    }

    /**
     * @method
     * @name kraken#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://docs.kraken.com/rest/#tag/Spot-Market-Data/operation/getOrderBook
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(getValue(market, "darkpool")))
        {
            throw new ExchangeError ((string)add(add(this.id, " fetchOrderBook() does not provide an order book for darkpool symbol "), symbol)) ;
        }
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["count"] = limit; // 100
        }
        object response = await this.publicGetDepth(this.extend(request, parameters));
        //
        //     {
        //         "error":[],
        //         "result":{
        //             "XETHXXBT":{
        //                 "asks":[
        //                     ["0.023480","4.000",1586321307],
        //                     ["0.023490","50.095",1586321306],
        //                     ["0.023500","28.535",1586321302],
        //                 ],
        //                 "bids":[
        //                     ["0.023470","59.580",1586321307],
        //                     ["0.023460","20.000",1586321301],
        //                     ["0.023440","67.832",1586321306],
        //                 ]
        //             }
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object orderbook = this.safeValue(result, getValue(market, "id"));
        // sometimes kraken returns wsname instead of market id
        // https://github.com/ccxt/ccxt/issues/8662
        object marketInfo = this.safeValue(market, "info", new Dictionary<string, object>() {});
        object wsName = this.safeValue(marketInfo, "wsname");
        if (isTrue(!isEqual(wsName, null)))
        {
            orderbook = this.safeValue(result, wsName, orderbook);
        }
        return this.parseOrderBook(orderbook, symbol);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "a":["2432.77000","1","1.000"],
        //         "b":["2431.37000","2","2.000"],
        //         "c":["2430.58000","0.04408910"],
        //         "v":["4147.94474901","8896.96086304"],
        //         "p":["2456.22239","2568.63032"],
        //         "t":[3907,10056],
        //         "l":["2302.18000","2302.18000"],
        //         "h":["2621.14000","2860.01000"],
        //         "o":"2571.56000"
        //     }
        //
        object symbol = this.safeSymbol(null, market);
        object v = this.safeValue(ticker, "v", new List<object>() {});
        object baseVolume = this.safeString(v, 1);
        object p = this.safeValue(ticker, "p", new List<object>() {});
        object vwap = this.safeString(p, 1);
        object quoteVolume = Precise.stringMul(baseVolume, vwap);
        object c = this.safeValue(ticker, "c", new List<object>() {});
        object last = this.safeString(c, 0);
        object high = this.safeValue(ticker, "h", new List<object>() {});
        object low = this.safeValue(ticker, "l", new List<object>() {});
        object bid = this.safeValue(ticker, "b", new List<object>() {});
        object ask = this.safeValue(ticker, "a", new List<object>() {});
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "high", this.safeString(high, 1) },
            { "low", this.safeString(low, 1) },
            { "bid", this.safeString(bid, 0) },
            { "bidVolume", this.safeString(bid, 2) },
            { "ask", this.safeString(ask, 0) },
            { "askVolume", this.safeString(ask, 2) },
            { "vwap", vwap },
            { "open", this.safeString(ticker, "o") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name kraken#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://docs.kraken.com/rest/#tag/Spot-Market-Data/operation/getTickerInformation
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            symbols = this.marketSymbols(symbols);
            object marketIds = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                object market = getValue(this.markets, symbol);
                if (isTrue(isTrue(getValue(market, "active")) && !isTrue(getValue(market, "darkpool"))))
                {
                    ((IList<object>)marketIds).Add(getValue(market, "id"));
                }
            }
            ((IDictionary<string,object>)request)["pair"] = String.Join(",", ((IList<object>)marketIds).ToArray());
        }
        object response = await this.publicGetTicker(this.extend(request, parameters));
        object tickers = getValue(response, "result");
        object ids = new List<object>(((IDictionary<string,object>)tickers).Keys);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object id = getValue(ids, i);
            object market = this.safeMarket(id);
            object symbol = getValue(market, "symbol");
            object ticker = getValue(tickers, id);
            ((IDictionary<string,object>)result)[(string)symbol] = this.parseTicker(ticker, market);
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    /**
     * @method
     * @name kraken#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://docs.kraken.com/rest/#tag/Spot-Market-Data/operation/getTickerInformation
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object darkpool = isGreaterThanOrEqual(getIndexOf(symbol, ".d"), 0);
        if (isTrue(darkpool))
        {
            throw new ExchangeError ((string)add(add(this.id, " fetchTicker() does not provide a ticker for darkpool symbol "), symbol)) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        object response = await this.publicGetTicker(this.extend(request, parameters));
        object ticker = getValue(getValue(response, "result"), getValue(market, "id"));
        return this.parseTicker(ticker, market);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         1591475640,
        //         "0.02500",
        //         "0.02500",
        //         "0.02500",
        //         "0.02500",
        //         "0.02500",
        //         "9.12201000",
        //         5
        //     ]
        //
        return new List<object> {this.safeTimestamp(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 6)};
    }

    /**
     * @method
     * @name kraken#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://docs.kraken.com/api/docs/rest-api/get-ohlc-data
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, 720);
        }
        object market = this.market(symbol);
        object parsedTimeframe = this.safeInteger(this.timeframes, timeframe);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        if (isTrue(!isEqual(parsedTimeframe, null)))
        {
            ((IDictionary<string,object>)request)["interval"] = parsedTimeframe;
        } else
        {
            ((IDictionary<string,object>)request)["interval"] = timeframe;
        }
        if (isTrue(!isEqual(since, null)))
        {
            object scaledSince = this.parseToInt(divide(since, 1000));
            object timeFrameInSeconds = multiply(parsedTimeframe, 60);
            ((IDictionary<string,object>)request)["since"] = this.numberToString(subtract(scaledSince, timeFrameInSeconds)); // expected to be in seconds
        }
        object response = await this.publicGetOHLC(this.extend(request, parameters));
        //
        //     {
        //         "error":[],
        //         "result":{
        //             "XETHXXBT":[
        //                 [1591475580,"0.02499","0.02499","0.02499","0.02499","0.00000","0.00000000",0],
        //                 [1591475640,"0.02500","0.02500","0.02500","0.02500","0.02500","9.12201000",5],
        //                 [1591475700,"0.02499","0.02499","0.02499","0.02499","0.02499","1.28681415",2],
        //                 [1591475760,"0.02499","0.02499","0.02499","0.02499","0.02499","0.08800000",1],
        //             ],
        //             "last":1591517580
        //         }
        //     }
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object ohlcvs = this.safeList(result, getValue(market, "id"), new List<object>() {});
        return this.parseOHLCVs(ohlcvs, market, timeframe, since, limit);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "trade", "trade" },
            { "withdrawal", "transaction" },
            { "deposit", "transaction" },
            { "transfer", "transfer" },
            { "margin", "margin" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //         'LTFK7F-N2CUX-PNY4SX': {
        //             "refid": "TSJTGT-DT7WN-GPPQMJ",
        //             "time":  1520102320.555,
        //             "type": "trade",
        //             "aclass": "currency",
        //             "asset": "XETH",
        //             "amount": "0.1087194600",
        //             "fee": "0.0000000000",
        //             "balance": "0.2855851000"
        //         },
        //         ...
        //     }
        //
        object id = this.safeString(item, "id");
        object direction = null;
        object account = null;
        object referenceId = this.safeString(item, "refid");
        object referenceAccount = null;
        object type = this.parseLedgerEntryType(this.safeString(item, "type"));
        object currencyId = this.safeString(item, "asset");
        object code = this.safeCurrencyCode(currencyId, currency);
        currency = this.safeCurrency(currencyId, currency);
        object amount = this.safeString(item, "amount");
        if (isTrue(Precise.stringLt(amount, "0")))
        {
            direction = "out";
            amount = Precise.stringAbs(amount);
        } else
        {
            direction = "in";
        }
        object timestamp = this.safeIntegerProduct(item, "time", 1000);
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", id },
            { "direction", direction },
            { "account", account },
            { "referenceId", referenceId },
            { "referenceAccount", referenceAccount },
            { "type", type },
            { "currency", code },
            { "amount", this.parseNumber(amount) },
            { "before", null },
            { "after", this.safeNumber(item, "balance") },
            { "status", "ok" },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fee", new Dictionary<string, object>() {
                { "cost", this.safeNumber(item, "fee") },
                { "currency", code },
            } },
        }, currency);
    }

    /**
     * @method
     * @name kraken#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
     * @see https://docs.kraken.com/rest/#tag/Account-Data/operation/getLedgers
     * @param {string} [code] unified currency code, default is undefined
     * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
     * @param {int} [limit] max number of ledger entries to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest ledger entry
     * @param {int} [params.end] timestamp in seconds of the latest ledger entry
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        // https://www.kraken.com/features/api#get-ledgers-info
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["asset"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = this.parseToInt(divide(since, 1000));
        }
        object until = this.safeStringN(parameters, new List<object>() {"until", "till"});
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until", "till"});
            object untilDivided = Precise.stringDiv(until, "1000");
            ((IDictionary<string,object>)request)["end"] = this.parseToInt(Precise.stringAdd(untilDivided, "1"));
        }
        object response = await this.privatePostLedgers(this.extend(request, parameters));
        // {  error: [],
        //   "result": { ledger: { 'LPUAIB-TS774-UKHP7X': {   refid: "A2B4HBV-L4MDIE-JU4N3N",
        //                                                   "time":  1520103488.314,
        //                                                   "type": "withdrawal",
        //                                                 "aclass": "currency",
        //                                                  "asset": "XETH",
        //                                                 "amount": "-0.2805800000",
        //                                                    "fee": "0.0050000000",
        //                                                "balance": "0.0000051000"           },
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object ledger = this.safeValue(result, "ledger", new Dictionary<string, object>() {});
        object keys = new List<object>(((IDictionary<string,object>)ledger).Keys);
        object items = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object value = getValue(ledger, key);
            ((IDictionary<string,object>)value)["id"] = key;
            ((IList<object>)items).Add(value);
        }
        return this.parseLedger(items, currency, since, limit);
    }

    public async virtual Task<object> fetchLedgerEntriesByIds(object ids, object code = null, object parameters = null)
    {
        // https://www.kraken.com/features/api#query-ledgers
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        ids = String.Join(",", ((IList<object>)ids).ToArray());
        object request = this.extend(new Dictionary<string, object>() {
            { "id", ids },
        }, parameters);
        object response = await this.privatePostQueryLedgers(request);
        // {  error: [],
        //   "result": { 'LPUAIB-TS774-UKHP7X': {   refid: "A2B4HBV-L4MDIE-JU4N3N",
        //                                         "time":  1520103488.314,
        //                                         "type": "withdrawal",
        //                                       "aclass": "currency",
        //                                        "asset": "XETH",
        //                                       "amount": "-0.2805800000",
        //                                          "fee": "0.0050000000",
        //                                      "balance": "0.0000051000"           } } }
        object result = getValue(response, "result");
        object keys = new List<object>(((IDictionary<string,object>)result).Keys);
        object items = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object value = getValue(result, key);
            ((IDictionary<string,object>)value)["id"] = key;
            ((IList<object>)items).Add(value);
        }
        return this.parseLedger(items);
    }

    public async override Task<object> fetchLedgerEntry(object id, object code = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object items = await this.fetchLedgerEntriesByIds(new List<object>() {id}, code, parameters);
        return getValue(items, 0);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //     [
        //         "0.032310", // price
        //         "4.28169434", // amount
        //         1541390792.763, // timestamp
        //         "s", // sell or buy
        //         "l", // limit or market
        //         ""
        //     ]
        //
        // fetchOrderTrades (private)
        //
        //     {
        //         "id": 'TIMIRG-WUNNE-RRJ6GT', // injected from outside
        //         "ordertxid": 'OQRPN2-LRHFY-HIFA7D',
        //         "postxid": 'TKH2SE-M7IF5-CFI7LT',
        //         "pair": 'USDCUSDT',
        //         "time": 1586340086.457,
        //         "type": 'sell',
        //         "ordertype": 'market',
        //         "price": '0.99860000',
        //         "cost": '22.16892001',
        //         "fee": '0.04433784',
        //         "vol": '22.20000000',
        //         "margin": '0.00000000',
        //         "misc": ''
        //     }
        //
        // fetchMyTrades
        //
        //     {
        //         "ordertxid": "OSJVN7-A2AE-63WZV",
        //         "postxid": "TBP7O6-PNXI-CONU",
        //         "pair": "XXBTZUSD",
        //         "time": 1710429248.3052235,
        //         "type": "sell",
        //         "ordertype": "liquidation market",
        //         "price": "72026.50000",
        //         "cost": "7.20265",
        //         "fee": "0.01873",
        //         "vol": "0.00010000",
        //         "margin": "1.44053",
        //         "leverage": "5",
        //         "misc": "closing",
        //         "trade_id": 68230622,
        //         "maker": false
        //     }
        //
        object timestamp = null;
        object side = null;
        object type = null;
        object price = null;
        object amount = null;
        object id = null;
        object orderId = null;
        object fee = null;
        object symbol = null;
        if (isTrue(((trade is IList<object>) || (trade.GetType().IsGenericType && trade.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            timestamp = this.safeTimestamp(trade, 2);
            side = ((bool) isTrue((isEqual(getValue(trade, 3), "s")))) ? "sell" : "buy";
            type = ((bool) isTrue((isEqual(getValue(trade, 4), "l")))) ? "limit" : "market";
            price = this.safeString(trade, 0);
            amount = this.safeString(trade, 1);
            object tradeLength = getArrayLength(trade);
            if (isTrue(isGreaterThan(tradeLength, 6)))
            {
                id = this.safeString(trade, 6); // artificially added as per #1794
            }
        } else if (isTrue((trade is string)))
        {
            id = trade;
        } else if (isTrue(inOp(trade, "ordertxid")))
        {
            object marketId = this.safeString(trade, "pair");
            object foundMarket = this.findMarketByAltnameOrId(marketId);
            if (isTrue(!isEqual(foundMarket, null)))
            {
                market = foundMarket;
            } else if (isTrue(!isEqual(marketId, null)))
            {
                // delisted market ids go here
                market = this.getDelistedMarketById(marketId);
            }
            orderId = this.safeString(trade, "ordertxid");
            id = this.safeString2(trade, "id", "postxid");
            timestamp = this.safeTimestamp(trade, "time");
            side = this.safeString(trade, "type");
            type = this.safeString(trade, "ordertype");
            price = this.safeString(trade, "price");
            amount = this.safeString(trade, "vol");
            if (isTrue(inOp(trade, "fee")))
            {
                object currency = null;
                if (isTrue(!isEqual(market, null)))
                {
                    currency = getValue(market, "quote");
                }
                fee = new Dictionary<string, object>() {
                    { "cost", this.safeString(trade, "fee") },
                    { "currency", currency },
                };
            }
        }
        if (isTrue(!isEqual(market, null)))
        {
            symbol = getValue(market, "symbol");
        }
        object cost = this.safeString(trade, "cost");
        object maker = this.safeBool(trade, "maker");
        object takerOrMaker = null;
        if (isTrue(!isEqual(maker, null)))
        {
            takerOrMaker = ((bool) isTrue(maker)) ? "maker" : "taker";
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "order", orderId },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", type },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "fee", fee },
        }, market);
    }

    /**
     * @method
     * @name kraken#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://docs.kraken.com/rest/#tag/Spot-Market-Data/operation/getRecentTrades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object id = getValue(market, "id");
        object request = new Dictionary<string, object>() {
            { "pair", id },
        };
        // https://support.kraken.com/hc/en-us/articles/218198197-How-to-pull-all-trade-data-using-the-Kraken-REST-API
        // https://github.com/ccxt/ccxt/issues/5677
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["since"] = this.numberToString(this.parseToInt(divide(since, 1000))); // expected to be in seconds
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["count"] = limit;
        }
        object response = await this.publicGetTrades(this.extend(request, parameters));
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "XETHXXBT": [
        //                 ["0.032310","4.28169434",1541390792.763,"s","l",""]
        //             ],
        //             "last": "1541439421200678657"
        //         }
        //     }
        //
        object result = getValue(response, "result");
        object trades = getValue(result, id);
        // trades is a sorted array: last (most recent trade) goes last
        object length = getArrayLength(trades);
        if (isTrue(isLessThanOrEqual(length, 0)))
        {
            return new List<object>() {};
        }
        object lastTrade = getValue(trades, subtract(length, 1));
        object lastTradeId = this.safeString(result, "last");
        ((IList<object>)lastTrade).Add(lastTradeId);
        ((List<object>)trades)[Convert.ToInt32(subtract(length, 1))] = lastTrade;
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseBalance(object response)
    {
        object balances = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        object currencyIds = new List<object>(((IDictionary<string,object>)balances).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencyIds, i);
            object code = this.safeCurrencyCode(currencyId);
            object balance = this.safeValue(balances, currencyId, new Dictionary<string, object>() {});
            object account = this.account();
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "hold_trade");
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "balance");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name kraken#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://docs.kraken.com/rest/#tag/Account-Data/operation/getExtendedBalance
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostBalanceEx(parameters);
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "ZUSD": {
        //                 "balance": 25435.21,
        //                 "hold_trade": 8249.76
        //             },
        //             "XXBT": {
        //                 "balance": 1.2435,
        //                 "hold_trade": 0.8423
        //             }
        //         }
        //     }
        //
        return this.parseBalance(response);
    }

    /**
     * @method
     * @name kraken#createMarketOrderWithCost
     * @description create a market order by providing the symbol, side and cost
     * @see https://docs.kraken.com/rest/#tag/Spot-Trading/operation/addOrder
     * @param {string} symbol unified symbol of the market to create an order in (only USD markets are supported)
     * @param {string} side 'buy' or 'sell'
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketOrderWithCost(object symbol, object side, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        // only buy orders are supported by the endpoint
        ((IDictionary<string,object>)parameters)["cost"] = cost;
        return await this.createOrder(symbol, "market", side, cost, null, parameters);
    }

    /**
     * @method
     * @name kraken#createMarketBuyOrderWithCost
     * @description create a market buy order by providing the symbol, side and cost
     * @see https://docs.kraken.com/rest/#tag/Spot-Trading/operation/addOrder
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        return await this.createMarketOrderWithCost(symbol, "buy", cost, parameters);
    }

    /**
     * @method
     * @name kraken#createOrder
     * @description create a trade order
     * @see https://docs.kraken.com/api/docs/rest-api/add-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
     * @param {bool} [params.reduceOnly] *margin only* indicates if this order is to reduce the size of a position
     * @param {float} [params.stopLossPrice] *margin only* the price that a stop loss order is triggered at
     * @param {float} [params.takeProfitPrice] *margin only* the price that a take profit order is triggered at
     * @param {string} [params.trailingAmount] *margin only* the quote amount to trail away from the current market price
     * @param {string} [params.trailingPercent] *margin only* the percent to trail away from the current market price
     * @param {string} [params.trailingLimitAmount] *margin only* the quote amount away from the trailingAmount
     * @param {string} [params.trailingLimitPercent] *margin only* the percent away from the trailingAmount
     * @param {string} [params.offset] *margin only* '+' or '-' whether you want the trailingLimitAmount value to be positive or negative, default is negative '-'
     * @param {string} [params.trigger] *margin only* the activation price type, 'last' or 'index', default is 'last'
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
            { "type", side },
            { "ordertype", type },
            { "volume", this.amountToPrecision(symbol, amount) },
        };
        object orderRequest = this.orderRequest("createOrder", symbol, type, request, amount, price, parameters);
        object response = await this.privatePostAddOrder(this.extend(getValue(orderRequest, 0), getValue(orderRequest, 1)));
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "descr": { order: 'buy 0.02100000 ETHUSDT @ limit 330.00' }, // see more examples in "parseOrder"
        //             "txid": [ 'OEKVV2-IH52O-TPL6GZ' ]
        //         }
        //     }
        //
        object result = this.safeDict(response, "result");
        return this.parseOrder(result);
    }

    public virtual object findMarketByAltnameOrId(object id)
    {
        object marketsByAltname = this.safeValue(this.options, "marketsByAltname", new Dictionary<string, object>() {});
        if (isTrue(inOp(marketsByAltname, id)))
        {
            return getValue(marketsByAltname, id);
        } else
        {
            return this.safeMarket(id);
        }
    }

    public virtual object getDelistedMarketById(object id)
    {
        if (isTrue(isEqual(id, null)))
        {
            return id;
        }
        object market = this.safeValue(getValue(this.options, "delistedMarketsById"), id);
        if (isTrue(!isEqual(market, null)))
        {
            return market;
        }
        object baseIdStart = 0;
        object baseIdEnd = 3;
        object quoteIdStart = 3;
        object quoteIdEnd = 6;
        if (isTrue(isEqual(getArrayLength(id), 8)))
        {
            baseIdEnd = 4;
            quoteIdStart = 4;
            quoteIdEnd = 8;
        } else if (isTrue(isEqual(getArrayLength(id), 7)))
        {
            baseIdEnd = 4;
            quoteIdStart = 4;
            quoteIdEnd = 7;
        }
        object baseId = slice(id, baseIdStart, baseIdEnd);
        object quoteId = slice(id, quoteIdStart, quoteIdEnd);
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(bs, "/"), quote);
        market = new Dictionary<string, object>() {
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "baseId", baseId },
            { "quoteId", quoteId },
        };
        ((IDictionary<string,object>)getValue(this.options, "delistedMarketsById"))[(string)id] = market;
        return market;
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "pending", "open" },
            { "open", "open" },
            { "closed", "closed" },
            { "canceled", "canceled" },
            { "expired", "expired" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderType(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "take-profit", "market" },
            { "stop-loss", "market" },
            { "stop-loss-limit", "limit" },
            { "take-profit-limit", "limit" },
            { "trailing-stop-limit", "limit" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //
        //     {
        //         "descr": {
        //            "order": "buy 0.02100000 ETHUSDT @ limit 330.00" // limit orders
        //                     "buy 0.12345678 ETHUSDT @ market" // market order
        //                     "sell 0.28002676 ETHUSDT @ stop loss 0.0123 -> limit 0.0.1222" // stop order
        //                     "sell 0.00100000 ETHUSDT @ stop loss 2677.00 -> limit 2577.00 with 5:1 leverage"
        //                     "buy 0.10000000 LTCUSDT @ take profit 75.00000 -> limit 74.00000"
        //                     "sell 10.00000000 XRPEUR @ trailing stop +50.0000%" // trailing stop
        //         },
        //         "txid": [ 'OEKVV2-IH52O-TPL6GZ' ]
        //     }
        //
        // editOrder
        //
        //     {
        //         "amend_id": "TJSMEH-AA67V-YUSQ6O"
        //     }
        //
        //  ws - createOrder
        //    {
        //        "descr": 'sell 0.00010000 XBTUSDT @ market',
        //        "event": 'addOrderStatus',
        //        "reqid": 1,
        //        "status": 'ok',
        //        "txid": 'OAVXZH-XIE54-JCYYDG'
        //    }
        //  ws - editOrder
        //    {
        //        "descr": "order edited price = 9000.00000000",
        //        "event": "editOrderStatus",
        //        "originaltxid": "O65KZW-J4AW3-VFS74A",
        //        "reqid": 3,
        //        "status": "ok",
        //        "txid": "OTI672-HJFAO-XOIPPK"
        //    }
        //
        //  {
        //      "error": [],
        //      "result": {
        //          "open": {
        //              "OXVPSU-Q726F-L3SDEP": {
        //                  "refid": null,
        //                  "userref": 0,
        //                  "status": "open",
        //                  "opentm": 1706893367.4656649,
        //                  "starttm": 0,
        //                  "expiretm": 0,
        //                  "descr": {
        //                      "pair": "XRPEUR",
        //                      "type": "sell",
        //                      "ordertype": "trailing-stop",
        //                      "price": "+50.0000%",
        //                      "price2": "0",
        //                      "leverage": "none",
        //                      "order": "sell 10.00000000 XRPEUR @ trailing stop +50.0000%",
        //                      "close": ""
        //                  },
        //                  "vol": "10.00000000",
        //                  "vol_exec": "0.00000000",
        //                  "cost": "0.00000000",
        //                  "fee": "0.00000000",
        //                  "price": "0.00000000",
        //                  "stopprice": "0.23424000",
        //                  "limitprice": "0.46847000",
        //                  "misc": "",
        //                  "oflags": "fciq",
        //                  "trigger": "index"
        //              }
        //      }
        //  }
        //
        // fetchOpenOrders
        //
        //      {
        //         "refid": null,
        //         "userref": null,
        //         "cl_ord_id": "1234",
        //         "status": "open",
        //         "opentm": 1733815269.370054,
        //         "starttm": 0,
        //         "expiretm": 0,
        //         "descr": {
        //             "pair": "XBTUSD",
        //             "type": "buy",
        //             "ordertype": "limit",
        //             "price": "70000.0",
        //             "price2": "0",
        //             "leverage": "none",
        //             "order": "buy 0.00010000 XBTUSD @ limit 70000.0",
        //             "close": ""
        //         },
        //         "vol": "0.00010000",
        //         "vol_exec": "0.00000000",
        //         "cost": "0.00000",
        //         "fee": "0.00000",
        //         "price": "0.00000",
        //         "stopprice": "0.00000",
        //         "limitprice": "0.00000",
        //         "misc": "",
        //         "oflags": "fciq"
        //     }
        //
        object description = this.safeDict(order, "descr", new Dictionary<string, object>() {});
        object orderDescriptionObj = this.safeDict(order, "descr"); // can be null
        object orderDescription = null;
        if (isTrue(!isEqual(orderDescriptionObj, null)))
        {
            orderDescription = this.safeString(orderDescriptionObj, "order");
        } else
        {
            orderDescription = this.safeString(order, "descr");
        }
        object side = null;
        object rawType = null;
        object marketId = null;
        object price = null;
        object amount = null;
        object triggerPrice = null;
        if (isTrue(!isEqual(orderDescription, null)))
        {
            object parts = ((string)orderDescription).Split(new [] {((string)" ")}, StringSplitOptions.None).ToList<object>();
            side = this.safeString(parts, 0);
            amount = this.safeString(parts, 1);
            marketId = this.safeString(parts, 2);
            object part4 = this.safeString(parts, 4);
            object part5 = this.safeString(parts, 5);
            if (isTrue(isTrue(isEqual(part4, "limit")) || isTrue(isEqual(part4, "market"))))
            {
                rawType = part4; // eg, limit, market
            } else
            {
                rawType = add(add(part4, " "), part5); // eg. stop loss, take profit, trailing stop
            }
            if (isTrue(isTrue(isEqual(rawType, "stop loss")) || isTrue(isEqual(rawType, "take profit"))))
            {
                triggerPrice = this.safeString(parts, 6);
                price = this.safeString(parts, 9);
            } else if (isTrue(isEqual(rawType, "limit")))
            {
                price = this.safeString(parts, 5);
            }
        }
        side = this.safeString(description, "type", side);
        rawType = this.safeString(description, "ordertype", rawType); // orderType has dash, e.g. trailing-stop
        marketId = this.safeString(description, "pair", marketId);
        object foundMarket = this.findMarketByAltnameOrId(marketId);
        object symbol = null;
        if (isTrue(!isEqual(foundMarket, null)))
        {
            market = foundMarket;
        } else if (isTrue(!isEqual(marketId, null)))
        {
            // delisted market ids go here
            market = this.getDelistedMarketById(marketId);
        }
        object timestamp = this.safeTimestamp(order, "opentm");
        amount = this.safeString(order, "vol", amount);
        object filled = this.safeString(order, "vol_exec");
        object fee = null;
        // kraken truncates the cost in the api response so we will ignore it and calculate it from average & filled
        // const cost = this.safeString (order, 'cost');
        price = this.safeString(description, "price", price);
        // when type = trailling stop returns price = '+50.0000%'
        if (isTrue(isTrue((!isEqual(price, null))) && isTrue(((string)price).EndsWith(((string)"%")))))
        {
            price = null; // this is not the price we want
        }
        if (isTrue(isTrue((isEqual(price, null))) || isTrue(Precise.stringEquals(price, "0"))))
        {
            price = this.safeString(description, "price2");
        }
        if (isTrue(isTrue((isEqual(price, null))) || isTrue(Precise.stringEquals(price, "0"))))
        {
            price = this.safeString(order, "price", price);
        }
        object flags = this.safeString(order, "oflags", "");
        object isPostOnly = isGreaterThan(getIndexOf(flags, "post"), -1);
        object average = this.safeNumber(order, "price");
        if (isTrue(!isEqual(market, null)))
        {
            symbol = getValue(market, "symbol");
            if (isTrue(inOp(order, "fee")))
            {
                object feeCost = this.safeString(order, "fee");
                fee = new Dictionary<string, object>() {
                    { "cost", feeCost },
                    { "rate", null },
                };
                if (isTrue(isGreaterThanOrEqual(getIndexOf(flags, "fciq"), 0)))
                {
                    ((IDictionary<string,object>)fee)["currency"] = getValue(market, "quote");
                } else if (isTrue(isGreaterThanOrEqual(getIndexOf(flags, "fcib"), 0)))
                {
                    ((IDictionary<string,object>)fee)["currency"] = getValue(market, "base");
                }
            }
        }
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object id = this.safeStringN(order, new List<object>() {"id", "txid", "amend_id"});
        if (isTrue(isTrue((isEqual(id, null))) || isTrue((((string)id).StartsWith(((string)"["))))))
        {
            object txid = this.safeList(order, "txid");
            id = this.safeString(txid, 0);
        }
        object userref = this.safeString(order, "userref");
        object clientOrderId = this.safeString(order, "cl_ord_id", userref);
        object rawTrades = this.safeValue(order, "trades", new List<object>() {});
        object trades = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rawTrades)); postFixIncrement(ref i))
        {
            object rawTrade = getValue(rawTrades, i);
            if (isTrue((rawTrade is string)))
            {
                ((IList<object>)trades).Add(this.safeTrade(new Dictionary<string, object>() {
                    { "id", rawTrade },
                    { "orderId", id },
                    { "symbol", symbol },
                    { "info", new Dictionary<string, object>() {} },
                }));
            } else
            {
                ((IList<object>)trades).Add(rawTrade);
            }
        }
        // as mentioned in #24192 PR, this field is not something consistent/actual
        // triggerPrice = this.omitZero (this.safeString (order, 'stopprice', triggerPrice));
        object stopLossPrice = null;
        object takeProfitPrice = null;
        // the dashed strings are not provided from fields (eg. fetch order)
        // while spaced strings from "order" sentence (when other fields not available)
        if (isTrue(!isEqual(rawType, null)))
        {
            if (isTrue(((string)rawType).StartsWith(((string)"take-profit"))))
            {
                takeProfitPrice = this.safeString(description, "price");
                price = this.omitZero(this.safeString(description, "price2"));
            } else if (isTrue(((string)rawType).StartsWith(((string)"stop-loss"))))
            {
                stopLossPrice = this.safeString(description, "price");
                price = this.omitZero(this.safeString(description, "price2"));
            } else if (isTrue(isEqual(rawType, "take profit")))
            {
                takeProfitPrice = triggerPrice;
            } else if (isTrue(isEqual(rawType, "stop loss")))
            {
                stopLossPrice = triggerPrice;
            }
        }
        object finalType = this.parseOrderType(rawType);
        // unlike from endpoints which provide eg: "take-profit-limit"
        // for "space-delimited" orders we dont have market/limit suffixes, their format is
        // eg: `stop loss > limit 123`, so we need to parse them manually
        if (isTrue(this.inArray(finalType, new List<object>() {"stop loss", "take profit"})))
        {
            finalType = ((bool) isTrue((isEqual(price, null)))) ? "market" : "limit";
        }
        object amendId = this.safeString(order, "amend_id");
        if (isTrue(!isEqual(amendId, null)))
        {
            isPostOnly = null;
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "info", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "status", status },
            { "symbol", symbol },
            { "type", finalType },
            { "timeInForce", null },
            { "postOnly", isPostOnly },
            { "side", side },
            { "price", price },
            { "triggerPrice", triggerPrice },
            { "takeProfitPrice", takeProfitPrice },
            { "stopLossPrice", stopLossPrice },
            { "cost", null },
            { "amount", amount },
            { "filled", filled },
            { "average", average },
            { "remaining", null },
            { "reduceOnly", this.safeBool2(order, "reduceOnly", "reduce_only") },
            { "fee", fee },
            { "trades", trades },
        }, market);
    }

    public virtual object orderRequest(object method, object symbol, object type, object request, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        parameters = this.omit(parameters, new List<object>() {"clientOrderId"});
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["cl_ord_id"] = clientOrderId;
        }
        object stopLossTriggerPrice = this.safeString(parameters, "stopLossPrice");
        object takeProfitTriggerPrice = this.safeString(parameters, "takeProfitPrice");
        object isStopLossTriggerOrder = !isEqual(stopLossTriggerPrice, null);
        object isTakeProfitTriggerOrder = !isEqual(takeProfitTriggerPrice, null);
        object isStopLossOrTakeProfitTrigger = isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder);
        object trailingAmount = this.safeString(parameters, "trailingAmount");
        object trailingPercent = this.safeString(parameters, "trailingPercent");
        object trailingLimitAmount = this.safeString(parameters, "trailingLimitAmount");
        object trailingLimitPercent = this.safeString(parameters, "trailingLimitPercent");
        object isTrailingAmountOrder = !isEqual(trailingAmount, null);
        object isTrailingPercentOrder = !isEqual(trailingPercent, null);
        object isLimitOrder = ((string)type).EndsWith(((string)"limit")); // supporting limit, stop-loss-limit, take-profit-limit, etc
        object isMarketOrder = isEqual(type, "market");
        object cost = this.safeString(parameters, "cost");
        object flags = this.safeString(parameters, "oflags");
        parameters = this.omit(parameters, new List<object>() {"cost", "oflags"});
        object isViqcOrder = isTrue((!isEqual(flags, null))) && isTrue((isGreaterThan(getIndexOf(flags, "viqc"), -1))); // volume in quote currency
        if (isTrue(isTrue(isMarketOrder) && isTrue((isTrue(!isEqual(cost, null)) || isTrue(isViqcOrder)))))
        {
            if (isTrue(isTrue(isEqual(cost, null)) && isTrue((!isEqual(amount, null)))))
            {
                ((IDictionary<string,object>)request)["volume"] = this.costToPrecision(symbol, this.numberToString(amount));
            } else
            {
                ((IDictionary<string,object>)request)["volume"] = this.costToPrecision(symbol, cost);
            }
            object extendedOflags = ((bool) isTrue((!isEqual(flags, null)))) ? add(flags, ",viqc") : "viqc";
            ((IDictionary<string,object>)request)["oflags"] = extendedOflags;
        } else if (isTrue(isTrue(isTrue(isLimitOrder) && !isTrue(isTrailingAmountOrder)) && !isTrue(isTrailingPercentOrder)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object reduceOnly = this.safeBool2(parameters, "reduceOnly", "reduce_only");
        if (isTrue(isStopLossOrTakeProfitTrigger))
        {
            if (isTrue(isStopLossTriggerOrder))
            {
                ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, stopLossTriggerPrice);
                if (isTrue(isLimitOrder))
                {
                    ((IDictionary<string,object>)request)["ordertype"] = "stop-loss-limit";
                } else
                {
                    ((IDictionary<string,object>)request)["ordertype"] = "stop-loss";
                }
            } else if (isTrue(isTakeProfitTriggerOrder))
            {
                ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, takeProfitTriggerPrice);
                if (isTrue(isLimitOrder))
                {
                    ((IDictionary<string,object>)request)["ordertype"] = "take-profit-limit";
                } else
                {
                    ((IDictionary<string,object>)request)["ordertype"] = "take-profit";
                }
            }
            if (isTrue(isLimitOrder))
            {
                ((IDictionary<string,object>)request)["price2"] = this.priceToPrecision(symbol, price);
            }
        } else if (isTrue(isTrue(isTrailingAmountOrder) || isTrue(isTrailingPercentOrder)))
        {
            object trailingPercentString = null;
            if (isTrue(!isEqual(trailingPercent, null)))
            {
                trailingPercentString = ((bool) isTrue((((string)trailingPercent).EndsWith(((string)"%"))))) ? (add("+", trailingPercent)) : (add(add("+", trailingPercent), "%"));
            }
            object trailingAmountString = ((bool) isTrue((!isEqual(trailingAmount, null)))) ? add("+", trailingAmount) : null; // must use + for this
            object offset = this.safeString(parameters, "offset", "-"); // can use + or - for this
            object trailingLimitAmountString = ((bool) isTrue((!isEqual(trailingLimitAmount, null)))) ? add(offset, this.numberToString(trailingLimitAmount)) : null;
            object trailingActivationPriceType = this.safeString(parameters, "trigger", "last");
            ((IDictionary<string,object>)request)["trigger"] = trailingActivationPriceType;
            if (isTrue(isTrue(isTrue(isLimitOrder) || isTrue((!isEqual(trailingLimitAmount, null)))) || isTrue((!isEqual(trailingLimitPercent, null)))))
            {
                ((IDictionary<string,object>)request)["ordertype"] = "trailing-stop-limit";
                if (isTrue(!isEqual(trailingLimitPercent, null)))
                {
                    object trailingLimitPercentString = ((bool) isTrue((((string)trailingLimitPercent).EndsWith(((string)"%"))))) ? (add(offset, trailingLimitPercent)) : (add(add(offset, trailingLimitPercent), "%"));
                    ((IDictionary<string,object>)request)["price"] = trailingPercentString;
                    ((IDictionary<string,object>)request)["price2"] = trailingLimitPercentString;
                } else if (isTrue(!isEqual(trailingLimitAmount, null)))
                {
                    ((IDictionary<string,object>)request)["price"] = trailingAmountString;
                    ((IDictionary<string,object>)request)["price2"] = trailingLimitAmountString;
                }
            } else
            {
                ((IDictionary<string,object>)request)["ordertype"] = "trailing-stop";
                if (isTrue(!isEqual(trailingPercent, null)))
                {
                    ((IDictionary<string,object>)request)["price"] = trailingPercentString;
                } else
                {
                    ((IDictionary<string,object>)request)["price"] = trailingAmountString;
                }
            }
        }
        if (isTrue(reduceOnly))
        {
            if (isTrue(isEqual(method, "createOrderWs")))
            {
                ((IDictionary<string,object>)request)["reduce_only"] = true; // ws request can't have stringified bool
            } else
            {
                ((IDictionary<string,object>)request)["reduce_only"] = "true"; // not using boolean in this case, because the urlencodedNested transforms it into 'True' string
            }
        }
        object close = this.safeDict(parameters, "close");
        if (isTrue(!isEqual(close, null)))
        {
            close = this.extend(new Dictionary<string, object>() {}, close);
            object closePrice = this.safeValue(close, "price");
            if (isTrue(!isEqual(closePrice, null)))
            {
                ((IDictionary<string,object>)close)["price"] = this.priceToPrecision(symbol, closePrice);
            }
            object closePrice2 = this.safeValue(close, "price2"); // stopPrice
            if (isTrue(!isEqual(closePrice2, null)))
            {
                ((IDictionary<string,object>)close)["price2"] = this.priceToPrecision(symbol, closePrice2);
            }
            ((IDictionary<string,object>)request)["close"] = close;
        }
        object timeInForce = this.safeString2(parameters, "timeInForce", "timeinforce");
        if (isTrue(!isEqual(timeInForce, null)))
        {
            ((IDictionary<string,object>)request)["timeinforce"] = timeInForce;
        }
        object isMarket = (isEqual(type, "market"));
        object postOnly = null;
        var postOnlyparametersVariable = this.handlePostOnly(isMarket, false, parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        if (isTrue(postOnly))
        {
            object extendedPostFlags = ((bool) isTrue((!isEqual(flags, null)))) ? add(flags, ",post") : "post";
            ((IDictionary<string,object>)request)["oflags"] = extendedPostFlags;
        }
        if (isTrue(isTrue((!isEqual(flags, null))) && !isTrue((inOp(request, "oflags")))))
        {
            ((IDictionary<string,object>)request)["oflags"] = flags;
        }
        parameters = this.omit(parameters, new List<object>() {"timeInForce", "reduceOnly", "stopLossPrice", "takeProfitPrice", "trailingAmount", "trailingPercent", "trailingLimitAmount", "trailingLimitPercent", "offset"});
        return new List<object>() {request, parameters};
    }

    /**
     * @method
     * @name kraken#editOrder
     * @description edit a trade order
     * @see https://docs.kraken.com/api/docs/rest-api/amend-order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} [amount] how much of the currency you want to trade in units of the base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.stopLossPrice] the price that a stop loss order is triggered at
     * @param {float} [params.takeProfitPrice] the price that a take profit order is triggered at
     * @param {string} [params.trailingAmount] the quote amount to trail away from the current market price
     * @param {string} [params.trailingPercent] the percent to trail away from the current market price
     * @param {string} [params.trailingLimitAmount] the quote amount away from the trailingAmount
     * @param {string} [params.trailingLimitPercent] the percent away from the trailingAmount
     * @param {string} [params.offset] '+' or '-' whether you want the trailingLimitAmount value to be positive or negative
     * @param {boolean} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
     * @param {string} [params.clientOrderId] the orders client order id
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " editOrder() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "txid", id },
        };
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "cl_ord_id");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["cl_ord_id"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"clientOrderId", "cl_ord_id"});
            request = this.omit(request, "txid");
        }
        object isMarket = (isEqual(type, "market"));
        object postOnly = null;
        var postOnlyparametersVariable = this.handlePostOnly(isMarket, false, parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["post_only"] = "true"; // not using boolean in this case, because the urlencodedNested transforms it into 'True' string
        }
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["order_qty"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["limit_price"] = this.priceToPrecision(symbol, price);
        }
        object allTriggerPrices = this.safeStringN(parameters, new List<object>() {"stopLossPrice", "takeProfitPrice", "trailingAmount", "trailingPercent", "trailingLimitAmount", "trailingLimitPercent"});
        if (isTrue(!isEqual(allTriggerPrices, null)))
        {
            object offset = this.safeString(parameters, "offset");
            parameters = this.omit(parameters, new List<object>() {"stopLossPrice", "takeProfitPrice", "trailingAmount", "trailingPercent", "trailingLimitAmount", "trailingLimitPercent", "offset"});
            if (isTrue(!isEqual(offset, null)))
            {
                allTriggerPrices = add(offset, allTriggerPrices);
                ((IDictionary<string,object>)request)["trigger_price"] = allTriggerPrices;
            } else
            {
                ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, allTriggerPrices);
            }
        }
        object response = await this.privatePostAmendOrder(this.extend(request, parameters));
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "amend_id": "TJSMEH-AA67V-YUSQ6O"
        //         }
        //     }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(result, market);
    }

    /**
     * @method
     * @name kraken#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://docs.kraken.com/rest/#tag/Account-Data/operation/getOrdersInfo
     * @param {string} id order id
     * @param {string} symbol not used by kraken fetchOrder
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object clientOrderId = this.safeValue2(parameters, "userref", "clientOrderId");
        object request = new Dictionary<string, object>() {
            { "trades", true },
            { "txid", id },
        };
        object query = parameters;
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["userref"] = clientOrderId;
            query = this.omit(parameters, new List<object>() {"userref", "clientOrderId"});
        }
        object response = await this.privatePostQueryOrders(this.extend(request, query));
        //
        //     {
        //         "error":[],
        //         "result":{
        //             "OTLAS3-RRHUF-NDWH5A":{
        //                 "refid":null,
        //                 "userref":null,
        //                 "status":"closed",
        //                 "reason":null,
        //                 "opentm":1586822919.3342,
        //                 "closetm":1586822919.365,
        //                 "starttm":0,
        //                 "expiretm":0,
        //                 "descr":{
        //                     "pair":"XBTUSDT",
        //                     "type":"sell",
        //                     "ordertype":"market",
        //                     "price":"0",
        //                     "price2":"0",
        //                     "leverage":"none",
        //                     "order":"sell 0.21804000 XBTUSDT @ market",
        //                     "close":""
        //                 },
        //                 "vol":"0.21804000",
        //                 "vol_exec":"0.21804000",
        //                 "cost":"1493.9",
        //                 "fee":"3.8",
        //                 "price":"6851.5",
        //                 "stopprice":"0.00000",
        //                 "limitprice":"0.00000",
        //                 "misc":"",
        //                 "oflags":"fciq",
        //                 "trades":["TT5UC3-GOIRW-6AZZ6R"]
        //             }
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new List<object>() {});
        if (!isTrue((inOp(result, id))))
        {
            throw new OrderNotFound ((string)add(add(this.id, " fetchOrder() could not find order id "), id)) ;
        }
        return this.parseOrder(this.extend(new Dictionary<string, object>() {
            { "id", id },
        }, getValue(result, id)));
    }

    /**
     * @method
     * @name kraken#fetchOrderTrades
     * @description fetch all the trades made from a single order
     * @see https://docs.kraken.com/rest/#tag/Account-Data/operation/getTradesInfo
     * @param {string} id order id
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object orderTrades = this.safeValue(parameters, "trades");
        object tradeIds = new List<object>() {};
        if (isTrue(isEqual(orderTrades, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrderTrades() requires a unified order structure in the params argument or a 'trades' param (an array of trade id strings)")) ;
        } else
        {
            for (object i = 0; isLessThan(i, getArrayLength(orderTrades)); postFixIncrement(ref i))
            {
                object orderTrade = getValue(orderTrades, i);
                if (isTrue((orderTrade is string)))
                {
                    ((IList<object>)tradeIds).Add(orderTrade);
                } else
                {
                    ((IList<object>)tradeIds).Add(getValue(orderTrade, "id"));
                }
            }
        }
        await this.loadMarkets();
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
        }
        object options = this.safeValue(this.options, "fetchOrderTrades", new Dictionary<string, object>() {});
        object batchSize = this.safeInteger(options, "batchSize", 20);
        object numTradeIds = getArrayLength(tradeIds);
        object numBatches = this.parseToInt(divide(numTradeIds, batchSize));
        numBatches = this.sum(numBatches, 1);
        object result = new List<object>() {};
        for (object j = 0; isLessThan(j, numBatches); postFixIncrement(ref j))
        {
            object requestIds = new List<object>() {};
            for (object k = 0; isLessThan(k, batchSize); postFixIncrement(ref k))
            {
                object index = this.sum(multiply(j, batchSize), k);
                if (isTrue(isLessThan(index, numTradeIds)))
                {
                    ((IList<object>)requestIds).Add(getValue(tradeIds, index));
                }
            }
            object request = new Dictionary<string, object>() {
                { "txid", String.Join(",", ((IList<object>)requestIds).ToArray()) },
            };
            object response = await this.privatePostQueryTrades(request);
            //
            //     {
            //         "error": [],
            //         "result": {
            //             'TIMIRG-WUNNE-RRJ6GT': {
            //                 "ordertxid": 'OQRPN2-LRHFY-HIFA7D',
            //                 "postxid": 'TKH2SE-M7IF5-CFI7LT',
            //                 "pair": 'USDCUSDT',
            //                 "time": 1586340086.457,
            //                 "type": 'sell',
            //                 "ordertype": 'market',
            //                 "price": '0.99860000',
            //                 "cost": '22.16892001',
            //                 "fee": '0.04433784',
            //                 "vol": '22.20000000',
            //                 "margin": '0.00000000',
            //                 "misc": ''
            //             }
            //         }
            //     }
            //
            object rawTrades = this.safeValue(response, "result");
            object ids = new List<object>(((IDictionary<string,object>)rawTrades).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
            {
                ((IDictionary<string,object>)getValue(rawTrades, getValue(ids, i)))["id"] = getValue(ids, i);
            }
            object trades = this.parseTrades(rawTrades, null, since, limit);
            object tradesFilteredBySymbol = this.filterBySymbol(trades, symbol);
            result = this.arrayConcat(result, tradesFilteredBySymbol);
        }
        return result;
    }

    /**
     * @method
     * @name kraken#fetchOrdersByIds
     * @description fetch orders by the list of order id
     * @see https://docs.kraken.com/rest/#tag/Account-Data/operation/getClosedOrders
     * @param {string[]} [ids] list of order id
     * @param {string} [symbol] unified ccxt market symbol
     * @param {object} [params] extra parameters specific to the kraken api endpoint
     * @returns {object[]} a list of [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchOrdersByIds(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostQueryOrders(this.extend(new Dictionary<string, object>() {
            { "trades", true },
            { "txid", String.Join(",", ((IList<object>)ids).ToArray()) },
        }, parameters));
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object orders = new List<object>() {};
        object orderIds = new List<object>(((IDictionary<string,object>)result).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(orderIds)); postFixIncrement(ref i))
        {
            object id = getValue(orderIds, i);
            object item = getValue(result, id);
            object order = this.parseOrder(this.extend(new Dictionary<string, object>() {
                { "id", id },
            }, item));
            ((IList<object>)orders).Add(order);
        }
        return orders;
    }

    /**
     * @method
     * @name kraken#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://docs.kraken.com/api/docs/rest-api/get-trade-history
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest trade entry
     * @param {int} [params.end] timestamp in seconds of the latest trade entry
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = this.parseToInt(divide(since, 1000));
        }
        object until = this.safeStringN(parameters, new List<object>() {"until", "till"});
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until", "till"});
            object untilDivided = Precise.stringDiv(until, "1000");
            ((IDictionary<string,object>)request)["end"] = this.parseToInt(Precise.stringAdd(untilDivided, "1"));
        }
        object response = await this.privatePostTradesHistory(this.extend(request, parameters));
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "trades": {
        //                 "GJ3NYQ-XJRTF-THZABF": {
        //                     "ordertxid": "TKH2SE-ZIF5E-CFI7LT",
        //                     "postxid": "OEN3VX-M7IF5-JNBJAM",
        //                     "pair": "XICNXETH",
        //                     "time": 1527213229.4491,
        //                     "type": "sell",
        //                     "ordertype": "limit",
        //                     "price": "0.001612",
        //                     "cost": "0.025792",
        //                     "fee": "0.000026",
        //                     "vol": "16.00000000",
        //                     "margin": "0.000000",
        //                     "leverage": "5",
        //                     "misc": ""
        //                     "trade_id": 68230622,
        //                     "maker": false
        //                 },
        //                 ...
        //             },
        //             "count": 9760,
        //         },
        //     }
        //
        object trades = getValue(getValue(response, "result"), "trades");
        object ids = new List<object>(((IDictionary<string,object>)trades).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            ((IDictionary<string,object>)getValue(trades, getValue(ids, i)))["id"] = getValue(ids, i);
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        return this.parseTrades(trades, market, since, limit);
    }

    /**
     * @method
     * @name kraken#cancelOrder
     * @description cancels an open order
     * @see https://docs.kraken.com/api/docs/rest-api/cancel-order
     * @param {string} id order id
     * @param {string} [symbol] unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] the orders client order id
     * @param {int} [params.userref] the orders user reference id
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = null;
        object requestId = this.safeValue(parameters, "userref", id); // string or integer
        parameters = this.omit(parameters, "userref");
        object request = new Dictionary<string, object>() {
            { "txid", requestId },
        };
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "cl_ord_id");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["cl_ord_id"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"clientOrderId", "cl_ord_id"});
            request = this.omit(request, "txid");
        }
        try
        {
            response = await this.privatePostCancelOrder(this.extend(request, parameters));
        } catch(Exception e)
        {
            if (isTrue(this.last_http_response))
            {
                if (isTrue(isGreaterThanOrEqual(getIndexOf(this.last_http_response, "EOrder:Unknown order"), 0)))
                {
                    throw new OrderNotFound ((string)add(add(this.id, " cancelOrder() error "), this.last_http_response)) ;
                }
            }
            throw e;
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", response },
        });
    }

    /**
     * @method
     * @name kraken#cancelOrders
     * @description cancel multiple orders
     * @see https://docs.kraken.com/rest/#tag/Spot-Trading/operation/cancelOrderBatch
     * @param {string[]} ids open orders transaction ID (txid) or user reference (userref)
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "orders", ids },
        };
        object response = await this.privatePostCancelOrderBatch(this.extend(request, parameters));
        //
        //     {
        //         "error": [],
        //         "result": {
        //           "count": 2
        //         }
        //     }
        //
        return new List<object> {this.safeOrder(new Dictionary<string, object>() {
    { "info", response },
})};
    }

    /**
     * @method
     * @name kraken#cancelAllOrders
     * @description cancel all open orders
     * @see https://docs.kraken.com/rest/#tag/Spot-Trading/operation/cancelAllOrders
     * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostCancelAll(parameters);
        //
        //    {
        //        error: [],
        //        result: {
        //            count: '1'
        //        }
        //    }
        //
        return new List<object> {this.safeOrder(new Dictionary<string, object>() {
    { "info", response },
})};
    }

    /**
     * @method
     * @name kraken#cancelAllOrdersAfter
     * @description dead man's switch, cancel all orders after the given timeout
     * @see https://docs.kraken.com/rest/#tag/Spot-Trading/operation/cancelAllOrdersAfter
     * @param {number} timeout time in milliseconds, 0 represents cancel the timer
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} the api result
     */
    public async override Task<object> cancelAllOrdersAfter(object timeout, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isGreaterThan(timeout, 86400000)))
        {
            throw new BadRequest ((string)add(this.id, " cancelAllOrdersAfter timeout should be less than 86400000 milliseconds")) ;
        }
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "timeout", ((bool) isTrue((isGreaterThan(timeout, 0)))) ? (this.parseToInt(divide(timeout, 1000))) : 0 },
        };
        object response = await this.privatePostCancelAllOrdersAfter(this.extend(request, parameters));
        //
        //     {
        //         "error": [ ],
        //         "result": {
        //             "currentTime": "2023-03-24T17:41:56Z",
        //             "triggerTime": "2023-03-24T17:42:56Z"
        //         }
        //     }
        //
        return response;
    }

    /**
     * @method
     * @name kraken#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://docs.kraken.com/api/docs/rest-api/get-open-orders
     * @param {string} [symbol] unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of  open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] the orders client order id
     * @param {int} [params.userref] the orders user reference id
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = this.parseToInt(divide(since, 1000));
        }
        object userref = this.safeInteger(parameters, "userref");
        if (isTrue(!isEqual(userref, null)))
        {
            ((IDictionary<string,object>)request)["userref"] = userref;
            parameters = this.omit(parameters, "userref");
        }
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["cl_ord_id"] = clientOrderId;
            parameters = this.omit(parameters, "clientOrderId");
        }
        object response = await this.privatePostOpenOrders(this.extend(request, parameters));
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "open": {
        //                 "O45M52-BFD5S-YXKQOU": {
        //                     "refid": null,
        //                     "userref": null,
        //                     "cl_ord_id": "1234",
        //                     "status": "open",
        //                     "opentm": 1733815269.370054,
        //                     "starttm": 0,
        //                     "expiretm": 0,
        //                     "descr": {
        //                         "pair": "XBTUSD",
        //                         "type": "buy",
        //                         "ordertype": "limit",
        //                         "price": "70000.0",
        //                         "price2": "0",
        //                         "leverage": "none",
        //                         "order": "buy 0.00010000 XBTUSD @ limit 70000.0",
        //                         "close": ""
        //                     },
        //                     "vol": "0.00010000",
        //                     "vol_exec": "0.00000000",
        //                     "cost": "0.00000",
        //                     "fee": "0.00000",
        //                     "price": "0.00000",
        //                     "stopprice": "0.00000",
        //                     "limitprice": "0.00000",
        //                     "misc": "",
        //                     "oflags": "fciq"
        //                 }
        //             }
        //         }
        //     }
        //
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        object open = this.safeDict(result, "open", new Dictionary<string, object>() {});
        object orders = new List<object>() {};
        object orderIds = new List<object>(((IDictionary<string,object>)open).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(orderIds)); postFixIncrement(ref i))
        {
            object id = getValue(orderIds, i);
            object item = getValue(open, id);
            ((IList<object>)orders).Add(this.extend(new Dictionary<string, object>() {
                { "id", id },
            }, item));
        }
        return this.parseOrders(orders, market, since, limit);
    }

    /**
     * @method
     * @name kraken#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://docs.kraken.com/api/docs/rest-api/get-closed-orders
     * @param {string} [symbol] unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest entry
     * @param {string} [params.clientOrderId] the orders client order id
     * @param {int} [params.userref] the orders user reference id
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = this.parseToInt(divide(since, 1000));
        }
        object userref = this.safeInteger(parameters, "userref");
        if (isTrue(!isEqual(userref, null)))
        {
            ((IDictionary<string,object>)request)["userref"] = userref;
            parameters = this.omit(parameters, "userref");
        }
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["cl_ord_id"] = clientOrderId;
            parameters = this.omit(parameters, "clientOrderId");
        }
        var requestparametersVariable = this.handleUntilOption("end", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privatePostClosedOrders(this.extend(request, parameters));
        //
        //     {
        //         "error":[],
        //         "result":{
        //             "closed":{
        //                 "OETZYO-UL524-QJMXCT":{
        //                     "refid":null,
        //                     "userref":null,
        //                     "status":"canceled",
        //                     "reason":"User requested",
        //                     "opentm":1601489313.3898,
        //                     "closetm":1601489346.5507,
        //                     "starttm":0,
        //                     "expiretm":0,
        //                     "descr":{
        //                         "pair":"ETHUSDT",
        //                         "type":"buy",
        //                         "ordertype":"limit",
        //                         "price":"330.00",
        //                         "price2":"0",
        //                         "leverage":"none",
        //                         "order":"buy 0.02100000 ETHUSDT @ limit 330.00",
        //                         "close":""
        //                     },
        //                     "vol":"0.02100000",
        //                     "vol_exec":"0.00000000",
        //                     "cost":"0.00000",
        //                     "fee":"0.00000",
        //                     "price":"0.00000",
        //                     "stopprice":"0.00000",
        //                     "limitprice":"0.00000",
        //                     "misc":"",
        //                     "oflags":"fciq"
        //                 },
        //             },
        //             "count":16
        //         }
        //     }
        //
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        object closed = this.safeDict(result, "closed", new Dictionary<string, object>() {});
        object orders = new List<object>() {};
        object orderIds = new List<object>(((IDictionary<string,object>)closed).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(orderIds)); postFixIncrement(ref i))
        {
            object id = getValue(orderIds, i);
            object item = getValue(closed, id);
            ((IList<object>)orders).Add(this.extend(new Dictionary<string, object>() {
                { "id", id },
            }, item));
        }
        return this.parseOrders(orders, market, since, limit);
    }

    public virtual object parseTransactionStatus(object status)
    {
        // IFEX transaction states
        object statuses = new Dictionary<string, object>() {
            { "Initial", "pending" },
            { "Pending", "pending" },
            { "Success", "ok" },
            { "Settled", "pending" },
            { "Failure", "failed" },
            { "Partial", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseNetwork(object network)
    {
        object withdrawMethods = this.safeValue(this.options, "withdrawMethods", new Dictionary<string, object>() {});
        return this.safeString(withdrawMethods, network, network);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //     {
        //         "method": "Ether (Hex)",
        //         "aclass": "currency",
        //         "asset": "XETH",
        //         "refid": "Q2CANKL-LBFVEE-U4Y2WQ",
        //         "txid": "0x57fd704dab1a73c20e24c8696099b695d596924b401b261513cfdab23",
        //         "info": "0x615f9ba7a9575b0ab4d571b2b36b1b324bd83290",
        //         "amount": "7.9999257900",
        //         "fee": "0.0000000000",
        //         "time":  1529223212,
        //         "status": "Success"
        //     }
        //
        // there can be an additional 'status-prop' field present
        // deposit pending review by exchange => 'on-hold'
        // the deposit is initiated by the exchange => 'return'
        //
        //      {
        //          "type": 'deposit',
        //          "method": 'Fidor Bank AG (Wire Transfer)',
        //          "aclass": 'currency',
        //          "asset": 'ZEUR',
        //          "refid": 'xxx-xxx-xxx',
        //          "txid": '12341234',
        //          "info": 'BANKCODEXXX',
        //          "amount": '38769.08',
        //          "fee": '0.0000',
        //          "time": 1644306552,
        //          "status": 'Success',
        //          status-prop: 'on-hold'
        //      }
        //
        //
        // fetchWithdrawals
        //
        //     {
        //         "method": "Ether",
        //         "aclass": "currency",
        //         "asset": "XETH",
        //         "refid": "A2BF34S-O7LBNQ-UE4Y4O",
        //         "txid": "0x288b83c6b0904d8400ef44e1c9e2187b5c8f7ea3d838222d53f701a15b5c274d",
        //         "info": "0x7cb275a5e07ba943fee972e165d80daa67cb2dd0",
        //         "amount": "9.9950000000",
        //         "fee": "0.0050000000",
        //         "time":  1530481750,
        //         "status": "Success"
        //         "key":"Huobi wallet",
        //         "network":"Tron"
        //         status-prop: 'on-hold' // this field might not be present in some cases
        //     }
        //
        // withdraw
        //
        //     {
        //         "refid": "AGBSO6T-UFMTTQ-I7KGS6"
        //     }
        //
        object id = this.safeString(transaction, "refid");
        object txid = this.safeString(transaction, "txid");
        object timestamp = this.safeTimestamp(transaction, "time");
        object currencyId = this.safeString(transaction, "asset");
        object code = this.safeCurrencyCode(currencyId, currency);
        object address = this.safeString(transaction, "info");
        object amount = this.safeNumber(transaction, "amount");
        object status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        object statusProp = this.safeString(transaction, "status-prop");
        object isOnHoldDeposit = isEqual(statusProp, "on-hold");
        object isCancellationRequest = isEqual(statusProp, "cancel-pending");
        object isOnHoldWithdrawal = isEqual(statusProp, "onhold");
        if (isTrue(isTrue(isTrue(isOnHoldDeposit) || isTrue(isCancellationRequest)) || isTrue(isOnHoldWithdrawal)))
        {
            status = "pending";
        }
        object type = this.safeString(transaction, "type"); // injected from the outside
        object feeCost = this.safeNumber(transaction, "fee");
        if (isTrue(isEqual(feeCost, null)))
        {
            if (isTrue(isEqual(type, "deposit")))
            {
                feeCost = 0;
            }
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "currency", code },
            { "amount", amount },
            { "network", this.parseNetwork(this.safeString(transaction, "network")) },
            { "address", address },
            { "addressTo", null },
            { "addressFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "status", status },
            { "type", type },
            { "updated", null },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "comment", null },
            { "internal", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", feeCost },
            } },
        };
    }

    public virtual object parseTransactionsByType(object type, object transactions, object code = null, object since = null, object limit = null)
    {
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(transactions)); postFixIncrement(ref i))
        {
            object transaction = this.parseTransaction(this.extend(new Dictionary<string, object>() {
                { "type", type },
            }, getValue(transactions, i)));
            ((IList<object>)result).Add(transaction);
        }
        return this.filterByCurrencySinceLimit(result, code, since, limit);
    }

    /**
     * @method
     * @name kraken#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://docs.kraken.com/rest/#tag/Funding/operation/getStatusRecentDeposits
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest transaction entry
     * @param {int} [params.end] timestamp in seconds of the latest transaction entry
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        // https://www.kraken.com/en-us/help/api#deposit-status
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(code, null)))
        {
            object currency = this.currency(code);
            ((IDictionary<string,object>)request)["asset"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            object sinceString = this.numberToString(since);
            ((IDictionary<string,object>)request)["start"] = Precise.stringDiv(sinceString, "1000");
        }
        object until = this.safeStringN(parameters, new List<object>() {"until", "till"});
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until", "till"});
            object untilDivided = Precise.stringDiv(until, "1000");
            ((IDictionary<string,object>)request)["end"] = Precise.stringAdd(untilDivided, "1");
        }
        object response = await this.privatePostDepositStatus(this.extend(request, parameters));
        //
        //     {  error: [],
        //       "result": [ { "method": "Ether (Hex)",
        //                     "aclass": "currency",
        //                      "asset": "XETH",
        //                      "refid": "Q2CANKL-LBFVEE-U4Y2WQ",
        //                       "txid": "0x57fd704dab1a73c20e24c8696099b695d596924b401b261513cfdab23",
        //                       "info": "0x615f9ba7a9575b0ab4d571b2b36b1b324bd83290",
        //                     "amount": "7.9999257900",
        //                        "fee": "0.0000000000",
        //                       "time":  1529223212,
        //                     "status": "Success"                                                       } ] }
        //
        return this.parseTransactionsByType("deposit", getValue(response, "result"), code, since, limit);
    }

    /**
     * @method
     * @name kraken#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://docs.kraken.com/rest/#tag/Spot-Market-Data/operation/getServerTime
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        // https://www.kraken.com/en-us/features/api#get-server-time
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetTime(parameters);
        //
        //    {
        //        "error": [],
        //        "result": {
        //            "unixtime": 1591502873,
        //            "rfc1123": "Sun,  7 Jun 20 04:07:53 +0000"
        //        }
        //    }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.safeTimestamp(result, "unixtime");
    }

    /**
     * @method
     * @name kraken#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://docs.kraken.com/rest/#tag/Funding/operation/getStatusRecentWithdrawals
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest transaction entry
     * @param {int} [params.end] timestamp in seconds of the latest transaction entry
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchWithdrawals", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            ((IDictionary<string,object>)parameters)["cursor"] = true;
            return await this.fetchPaginatedCallCursor("fetchWithdrawals", code, since, limit, parameters, "next_cursor", "cursor");
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(code, null)))
        {
            object currency = this.currency(code);
            ((IDictionary<string,object>)request)["asset"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            object sinceString = this.numberToString(since);
            ((IDictionary<string,object>)request)["start"] = Precise.stringDiv(sinceString, "1000");
        }
        object until = this.safeStringN(parameters, new List<object>() {"until", "till"});
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until", "till"});
            object untilDivided = Precise.stringDiv(until, "1000");
            ((IDictionary<string,object>)request)["end"] = Precise.stringAdd(untilDivided, "1");
        }
        object response = await this.privatePostWithdrawStatus(this.extend(request, parameters));
        //
        // with no pagination
        //     {  error: [],
        //       "result": [ { "method": "Ether",
        //                     "aclass": "currency",
        //                      "asset": "XETH",
        //                      "refid": "A2BF34S-O7LBNQ-UE4Y4O",
        //                       "txid": "0x298c83c7b0904d8400ef43e1c9e2287b518f7ea3d838822d53f704a1565c274d",
        //                       "info": "0x7cb275a5e07ba943fee972e165d80daa67cb2dd0",
        //                     "amount": "9.9950000000",
        //                        "fee": "0.0050000000",
        //                       "time":  1530481750,
        //                     "status": "Success"                                                             } ] }
        // with pagination
        //    {
        //        "error":[],
        //        "result":{
        //           "withdrawals":[
        //              {
        //                 "method":"Tether USD (TRC20)",
        //                 "aclass":"currency",
        //                 "asset":"USDT",
        //                 "refid":"BSNFZU2-MEFN4G-J3NEZV",
        //                 "txid":"1c7a642fb7387bbc2c6a2c509fd1ae146937f4cf793b4079a4f0715e3a02615a",
        //                 "info":"TQmdxSuC16EhFg8FZWtYgrfFRosoRF7bCp",
        //                 "amount":"1996.50000000",
        //                 "fee":"2.50000000",
        //                 "time":1669126657,
        //                 "status":"Success",
        //                 "key":"poloniex",
        //                 "network":"Tron"
        //              },
        //             ...
        //           ],
        //           "next_cursor":"HgAAAAAAAABGVFRSd3k1LVF4Y0JQY05Gd0xRY0NxenFndHpybkwBAQH2AwEBAAAAAQAAAAAAAAABAAAAAAAZAAAAAAAAAA=="
        //        }
        //     }
        //
        object rawWithdrawals = null;
        object result = this.safeValue(response, "result");
        if (!isTrue(((result is IList<object>) || (result.GetType().IsGenericType && result.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            rawWithdrawals = this.addPaginationCursorToResult(result);
        } else
        {
            rawWithdrawals = result;
        }
        return this.parseTransactionsByType("withdrawal", rawWithdrawals, code, since, limit);
    }

    public virtual object addPaginationCursorToResult(object result)
    {
        object cursor = this.safeString(result, "next_cursor");
        object data = this.safeValue(result, "withdrawals");
        object dataLength = getArrayLength(data);
        if (isTrue(isTrue(!isEqual(cursor, null)) && isTrue(isGreaterThan(dataLength, 0))))
        {
            object last = getValue(data, subtract(dataLength, 1));
            ((IDictionary<string,object>)last)["next_cursor"] = cursor;
            ((List<object>)data)[Convert.ToInt32(subtract(dataLength, 1))] = last;
        }
        return data;
    }

    /**
     * @method
     * @name kraken#createDepositAddress
     * @description create a currency deposit address
     * @see https://docs.kraken.com/rest/#tag/Funding/operation/getDepositAddresses
     * @param {string} code unified currency code of the currency for the deposit address
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "new", "true" },
        };
        return await this.fetchDepositAddress(code, this.extend(request, parameters));
    }

    /**
     * @method
     * @name kraken#fetchDepositMethods
     * @description fetch deposit methods for a currency associated with this account
     * @see https://docs.kraken.com/rest/#tag/Funding/operation/getDepositMethods
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the kraken api endpoint
     * @returns {object} of deposit methods
     */
    public async virtual Task<object> fetchDepositMethods(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
        };
        object response = await this.privatePostDepositMethods(this.extend(request, parameters));
        //
        //     {
        //         "error":[],
        //         "result":[
        //             {"method":"Ether (Hex)","limit":false,"gen-address":true}
        //         ]
        //     }
        //
        //     {
        //         "error":[],
        //         "result":[
        //             {"method":"Tether USD (ERC20)","limit":false,"address-setup-fee":"0.00000000","gen-address":true},
        //             {"method":"Tether USD (TRC20)","limit":false,"address-setup-fee":"0.00000000","gen-address":true}
        //         ]
        //     }
        //
        //     {
        //         "error":[],
        //         "result":[
        //             {"method":"Bitcoin","limit":false,"fee":"0.0000000000","gen-address":true}
        //         ]
        //     }
        //
        return this.safeValue(response, "result");
    }

    /**
     * @method
     * @name kraken#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://docs.kraken.com/rest/#tag/Funding/operation/getDepositAddresses
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object network = this.safeStringUpper(parameters, "network");
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        network = this.safeString(networks, network, network); // support ETH > ERC20 aliases
        parameters = this.omit(parameters, "network");
        if (isTrue(isTrue((isEqual(code, "USDT"))) && isTrue((isEqual(network, "TRC20")))))
        {
            code = add(add(code, "-"), network);
        }
        object defaultDepositMethods = this.safeValue(this.options, "depositMethods", new Dictionary<string, object>() {});
        object defaultDepositMethod = this.safeString(defaultDepositMethods, code);
        object depositMethod = this.safeString(parameters, "method", defaultDepositMethod);
        // if the user has specified an exchange-specific method in params
        // we pass it as is, otherwise we take the 'network' unified param
        if (isTrue(isEqual(depositMethod, null)))
        {
            object depositMethods = await this.fetchDepositMethods(code);
            if (isTrue(!isEqual(network, null)))
            {
                // find best matching deposit method, or fallback to the first one
                for (object i = 0; isLessThan(i, getArrayLength(depositMethods)); postFixIncrement(ref i))
                {
                    object entry = this.safeString(getValue(depositMethods, i), "method");
                    if (isTrue(isGreaterThanOrEqual(getIndexOf(entry, network), 0)))
                    {
                        depositMethod = entry;
                        break;
                    }
                }
            }
            // if depositMethod was not specified, fallback to the first available deposit method
            if (isTrue(isEqual(depositMethod, null)))
            {
                object firstDepositMethod = this.safeValue(depositMethods, 0, new Dictionary<string, object>() {});
                depositMethod = this.safeString(firstDepositMethod, "method");
            }
        }
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "method", depositMethod },
        };
        object response = await this.privatePostDepositAddresses(this.extend(request, parameters));
        //
        //     {
        //         "error":[],
        //         "result":[
        //             {"address":"0x77b5051f97efa9cc52c9ad5b023a53fc15c200d3","expiretm":"0"}
        //         ]
        //     }
        //
        object result = this.safeValue(response, "result", new List<object>() {});
        object firstResult = this.safeValue(result, 0, new Dictionary<string, object>() {});
        if (isTrue(isEqual(firstResult, null)))
        {
            throw new InvalidAddress ((string)add(add(this.id, " privatePostDepositAddresses() returned no addresses for "), code)) ;
        }
        return this.parseDepositAddress(firstResult, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "address":"0x77b5051f97efa9cc52c9ad5b023a53fc15c200d3",
        //         "expiretm":"0"
        //     }
        //
        object address = this.safeString(depositAddress, "address");
        object tag = this.safeString(depositAddress, "tag");
        currency = this.safeCurrency(null, currency);
        object code = getValue(currency, "code");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", code },
            { "network", null },
            { "address", address },
            { "tag", tag },
        };
    }

    /**
     * @method
     * @name kraken#withdraw
     * @description make a withdrawal
     * @see https://docs.kraken.com/rest/#tag/Funding/operation/withdrawFunds
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        if (isTrue(inOp(parameters, "key")))
        {
            await this.loadMarkets();
            object currency = this.currency(code);
            object request = new Dictionary<string, object>() {
                { "asset", getValue(currency, "id") },
                { "amount", amount },
                { "address", address },
            };
            object response = await this.privatePostWithdraw(this.extend(request, parameters));
            //
            //     {
            //         "error": [],
            //         "result": {
            //             "refid": "AGBSO6T-UFMTTQ-I7KGS6"
            //         }
            //     }
            //
            object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
            return this.parseTransaction(result, currency);
        }
        throw new ExchangeError ((string)add(this.id, " withdraw() requires a 'key' parameter (withdrawal key name, as set up on your account)")) ;
    }

    /**
     * @method
     * @name kraken#fetchPositions
     * @description fetch all open positions
     * @see https://docs.kraken.com/rest/#tag/Account-Data/operation/getOpenPositions
     * @param {string[]} [symbols] not used by kraken fetchPositions ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "docalcs", "true" },
            { "consolidation", "market" },
        };
        object response = await this.privatePostOpenPositions(this.extend(request, parameters));
        //
        // no consolidation
        //
        //     {
        //         "error": [],
        //         "result": {
        //             'TGUFMY-FLESJ-VYIX3J': {
        //                 "ordertxid": "O3LRNU-ZKDG5-XNCDFR",
        //                 "posstatus": "open",
        //                 "pair": "ETHUSDT",
        //                 "time":  1611557231.4584,
        //                 "type": "buy",
        //                 "ordertype": "market",
        //                 "cost": "28.49800",
        //                 "fee": "0.07979",
        //                 "vol": "0.02000000",
        //                 "vol_closed": "0.00000000",
        //                 "margin": "14.24900",
        //                 "terms": "0.0200% per 4 hours",
        //                 "rollovertm": "1611571631",
        //                 "misc": "",
        //                 "oflags": ""
        //             }
        //         }
        //     }
        //
        // consolidation by market
        //
        //     {
        //         "error": [],
        //         "result": [
        //             {
        //                 "pair": "ETHUSDT",
        //                 "positions": "1",
        //                 "type": "buy",
        //                 "leverage": "2.00000",
        //                 "cost": "28.49800",
        //                 "fee": "0.07979",
        //                 "vol": "0.02000000",
        //                 "vol_closed": "0.00000000",
        //                 "margin": "14.24900"
        //             }
        //         ]
        //     }
        //
        symbols = this.marketSymbols(symbols);
        object result = this.safeList(response, "result");
        object results = this.parsePositions(result, symbols);
        return this.filterByArrayPositions(results, "symbol", symbols, false);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //             {
        //                 "pair": "ETHUSDT",
        //                 "positions": "1",
        //                 "type": "buy",
        //                 "leverage": "2.00000",
        //                 "cost": "28.49800",
        //                 "fee": "0.07979",
        //                 "vol": "0.02000000",
        //                 "vol_closed": "0.00000000",
        //                 "margin": "14.24900"
        //             }
        //
        object marketId = this.safeString(position, "pair");
        object rawSide = this.safeString(position, "type");
        object side = ((bool) isTrue((isEqual(rawSide, "buy")))) ? "long" : "short";
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", this.safeSymbol(marketId, market) },
            { "notional", null },
            { "marginMode", null },
            { "liquidationPrice", null },
            { "entryPrice", null },
            { "unrealizedPnl", this.safeNumber(position, "net") },
            { "realizedPnl", null },
            { "percentage", null },
            { "contracts", this.safeNumber(position, "vol") },
            { "contractSize", null },
            { "markPrice", null },
            { "lastPrice", null },
            { "side", side },
            { "hedged", null },
            { "timestamp", null },
            { "datetime", null },
            { "lastUpdateTimestamp", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "collateral", null },
            { "initialMargin", this.safeNumber(position, "margin") },
            { "initialMarginPercentage", null },
            { "leverage", this.safeNumber(position, "leverage") },
            { "marginRatio", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    public virtual object parseAccountType(object account)
    {
        object accountByType = new Dictionary<string, object>() {
            { "spot", "Spot Wallet" },
            { "swap", "Futures Wallet" },
            { "future", "Futures Wallet" },
        };
        return this.safeString(accountByType, account, account);
    }

    /**
     * @method
     * @name kraken#transferOut
     * @description transfer from spot wallet to futures wallet
     * @see https://docs.kraken.com/rest/#tag/User-Funding/operation/walletTransfer
     * @param {str} code Unified currency code
     * @param {float} amount Size of the transfer
     * @param {dict} [params] Exchange specific parameters
     * @returns a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async virtual Task<object> transferOut(object code, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.transfer(code, amount, "spot", "swap", parameters);
    }

    /**
     * @method
     * @name kraken#transfer
     * @see https://docs.kraken.com/rest/#tag/User-Funding/operation/walletTransfer
     * @description transfers currencies between sub-accounts (only spot->swap direction is supported)
     * @param {string} code Unified currency code
     * @param {float} amount Size of the transfer
     * @param {string} fromAccount 'spot' or 'Spot Wallet'
     * @param {string} toAccount 'swap' or 'Futures Wallet'
     * @param {object} [params] Exchange specific parameters
     * @returns a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        fromAccount = this.parseAccountType(fromAccount);
        toAccount = this.parseAccountType(toAccount);
        object request = new Dictionary<string, object>() {
            { "amount", this.currencyToPrecision(code, amount) },
            { "from", fromAccount },
            { "to", toAccount },
            { "asset", getValue(currency, "id") },
        };
        if (isTrue(!isEqual(fromAccount, "Spot Wallet")))
        {
            throw new BadRequest ((string)add(add(add(add(add(this.id, " transfer cannot transfer from "), fromAccount), " to "), toAccount), ". Use krakenfutures instead to transfer from the futures account.")) ;
        }
        object response = await this.privatePostWalletTransfer(this.extend(request, parameters));
        //
        //   {
        //       "error":[
        //       ],
        //       "result":{
        //          "refid":"BOIUSIF-M7DLMN-UXZ3P5"
        //       }
        //   }
        //
        object transfer = this.parseTransfer(response, currency);
        return this.extend(transfer, new Dictionary<string, object>() {
            { "amount", amount },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
        });
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer
        //
        //    {
        //        "error":[
        //        ],
        //        "result":{
        //           "refid":"BOIUSIF-M7DLMN-UXZ3P5"
        //        }
        //    }
        //
        object result = this.safeValue(transfer, "result", new Dictionary<string, object>() {});
        object refid = this.safeString(result, "refid");
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", refid },
            { "timestamp", null },
            { "datetime", null },
            { "currency", this.safeString(currency, "code") },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", "sucess" },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(add(add(add("/", this.version), "/"), api), "/"), path);
        if (isTrue(isEqual(api, "public")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                // urlencodeNested is used to address https://github.com/ccxt/ccxt/issues/12872
                url = add(url, add("?", this.urlencodeNested(parameters)));
            }
        } else if (isTrue(isEqual(api, "private")))
        {
            object price = this.safeString(parameters, "price");
            object isTriggerPercent = false;
            if (isTrue(!isEqual(price, null)))
            {
                isTriggerPercent = ((bool) isTrue((((string)price).EndsWith(((string)"%"))))) ? true : false;
            }
            object isCancelOrderBatch = (isEqual(path, "CancelOrderBatch"));
            this.checkRequiredCredentials();
            object nonce = ((object)this.nonce()).ToString();
            // urlencodeNested is used to address https://github.com/ccxt/ccxt/issues/12872
            if (isTrue(isTrue(isCancelOrderBatch) || isTrue(isTriggerPercent)))
            {
                body = this.json(this.extend(new Dictionary<string, object>() {
                    { "nonce", nonce },
                }, parameters));
            } else
            {
                body = this.urlencodeNested(this.extend(new Dictionary<string, object>() {
                    { "nonce", nonce },
                }, parameters));
            }
            object auth = this.encode(add(nonce, body));
            object hash = this.hash(auth, sha256, "binary");
            object binary = this.encode(url);
            object binhash = this.binaryConcat(binary, hash);
            object secret = this.base64ToBinary(this.secret);
            object signature = this.hmac(binhash, secret, sha512, "base64");
            headers = new Dictionary<string, object>() {
                { "API-Key", this.apiKey },
                { "API-Sign", signature },
            };
            if (isTrue(isTrue(isCancelOrderBatch) || isTrue(isTriggerPercent)))
            {
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
            } else
            {
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/x-www-form-urlencoded";
            }
        } else
        {
            url = add("/", path);
        }
        url = add(getValue(getValue(this.urls, "api"), api), url);
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object nonce()
    {
        return subtract(this.milliseconds(), getValue(this.options, "timeDifference"));
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(code, 520)))
        {
            throw new ExchangeNotAvailable ((string)add(add(add(add(this.id, " "), ((object)code).ToString()), " "), reason)) ;
        }
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        if (isTrue(isEqual(getValue(body, 0), "{")))
        {
            if (isTrue(!(response is string)))
            {
                if (isTrue(inOp(response, "error")))
                {
                    object numErrors = getArrayLength(getValue(response, "error"));
                    if (isTrue(numErrors))
                    {
                        object message = add(add(this.id, " "), body);
                        for (object i = 0; isLessThan(i, getArrayLength(getValue(response, "error"))); postFixIncrement(ref i))
                        {
                            object error = getValue(getValue(response, "error"), i);
                            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), error, message);
                            this.throwExactlyMatchedException(getValue(this.exceptions, "broad"), error, message);
                        }
                        throw new ExchangeError ((string)message) ;
                    }
                }
            }
        }
        return null;
    }
}
