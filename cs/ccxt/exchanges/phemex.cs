namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class phemex : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "phemex" },
            { "name", "Phemex" },
            { "countries", new List<object>() {"CN"} },
            { "rateLimit", 120.5 },
            { "version", "v1" },
            { "certified", false },
            { "pro", true },
            { "hostname", "api.phemex.com" },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "closePosition", false },
                { "createOrder", true },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "editOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistories", false },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", true },
                { "fetchMarketLeverageTiers", "emulated" },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchPositions", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTransfers", true },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "sandbox", true },
                { "setLeverage", true },
                { "setMargin", true },
                { "setMarginMode", true },
                { "setPositionMode", true },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/85225056-221eb600-b3d7-11ea-930d-564d2690e3f6.jpg" },
                { "test", new Dictionary<string, object>() {
                    { "v1", "https://testnet-api.phemex.com/v1" },
                    { "v2", "https://testnet-api.phemex.com" },
                    { "public", "https://testnet-api.phemex.com/exchange/public" },
                    { "private", "https://testnet-api.phemex.com" },
                } },
                { "api", new Dictionary<string, object>() {
                    { "v1", "https://{hostname}/v1" },
                    { "v2", "https://{hostname}" },
                    { "public", "https://{hostname}/exchange/public" },
                    { "private", "https://{hostname}" },
                } },
                { "www", "https://phemex.com" },
                { "doc", "https://github.com/phemex/phemex-api-docs" },
                { "fees", "https://phemex.com/fees-conditions" },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://phemex.com/register?referralCode=EDNVJ" },
                    { "discount", 0.1 },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "60" },
                { "3m", "180" },
                { "5m", "300" },
                { "15m", "900" },
                { "30m", "1800" },
                { "1h", "3600" },
                { "2h", "7200" },
                { "3h", "10800" },
                { "4h", "14400" },
                { "6h", "21600" },
                { "12h", "43200" },
                { "1d", "86400" },
                { "1w", "604800" },
                { "1M", "2592000" },
                { "3M", "7776000" },
                { "1Y", "31104000" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "cfg/v2/products", 5 },
                        { "cfg/fundingRates", 5 },
                        { "products", 5 },
                        { "nomics/trades", 5 },
                        { "md/kline", 5 },
                        { "md/v2/kline/list", 5 },
                        { "md/v2/kline", 5 },
                        { "md/v2/kline/last", 5 },
                        { "md/orderbook", 5 },
                        { "md/trade", 5 },
                        { "md/spot/ticker/24hr", 5 },
                        { "exchange/public/cfg/chain-settings", 5 },
                    } },
                } },
                { "v1", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "md/fullbook", 5 },
                        { "md/orderbook", 5 },
                        { "md/trade", 5 },
                        { "md/ticker/24hr", 5 },
                        { "md/ticker/24hr/all", 5 },
                        { "md/spot/ticker/24hr", 5 },
                        { "md/spot/ticker/24hr/all", 5 },
                        { "exchange/public/products", 5 },
                        { "api-data/public/data/funding-rate-history", 5 },
                    } },
                } },
                { "v2", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "public/products", 5 },
                        { "md/v2/orderbook", 5 },
                        { "md/v2/trade", 5 },
                        { "md/v2/ticker/24hr", 5 },
                        { "md/v2/ticker/24hr/all", 5 },
                        { "api-data/public/data/funding-rate-history", 5 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "spot/orders/active", 1 },
                        { "spot/orders", 1 },
                        { "spot/wallets", 5 },
                        { "exchange/spot/order", 5 },
                        { "exchange/spot/order/trades", 5 },
                        { "exchange/order/v2/orderList", 5 },
                        { "exchange/order/v2/tradingList", 5 },
                        { "accounts/accountPositions", 1 },
                        { "g-accounts/accountPositions", 1 },
                        { "accounts/positions", 25 },
                        { "api-data/futures/funding-fees", 5 },
                        { "api-data/g-futures/funding-fees", 5 },
                        { "api-data/futures/orders", 5 },
                        { "api-data/g-futures/orders", 5 },
                        { "api-data/futures/orders/by-order-id", 5 },
                        { "api-data/g-futures/orders/by-order-id", 5 },
                        { "api-data/futures/trades", 5 },
                        { "api-data/g-futures/trades", 5 },
                        { "api-data/futures/trading-fees", 5 },
                        { "api-data/g-futures/trading-fees", 5 },
                        { "api-data/futures/v2/tradeAccountDetail", 5 },
                        { "g-orders/activeList", 1 },
                        { "orders/activeList", 1 },
                        { "exchange/order/list", 5 },
                        { "exchange/order", 5 },
                        { "exchange/order/trade", 5 },
                        { "phemex-user/users/children", 5 },
                        { "phemex-user/wallets/v2/depositAddress", 5 },
                        { "phemex-user/wallets/tradeAccountDetail", 5 },
                        { "phemex-deposit/wallets/api/depositAddress", 5 },
                        { "phemex-deposit/wallets/api/depositHist", 5 },
                        { "phemex-deposit/wallets/api/chainCfg", 5 },
                        { "phemex-withdraw/wallets/api/withdrawHist", 5 },
                        { "phemex-withdraw/wallets/api/asset/info", 5 },
                        { "phemex-user/order/closedPositionList", 5 },
                        { "exchange/margins/transfer", 5 },
                        { "exchange/wallets/confirm/withdraw", 5 },
                        { "exchange/wallets/withdrawList", 5 },
                        { "exchange/wallets/depositList", 5 },
                        { "exchange/wallets/v2/depositAddress", 5 },
                        { "api-data/spots/funds", 5 },
                        { "api-data/spots/orders", 5 },
                        { "api-data/spots/orders/by-order-id", 5 },
                        { "api-data/spots/pnls", 5 },
                        { "api-data/spots/trades", 5 },
                        { "api-data/spots/trades/by-order-id", 5 },
                        { "assets/convert", 5 },
                        { "assets/transfer", 5 },
                        { "assets/spots/sub-accounts/transfer", 5 },
                        { "assets/futures/sub-accounts/transfer", 5 },
                        { "assets/quote", 5 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "spot/orders", 1 },
                        { "orders", 1 },
                        { "g-orders", 1 },
                        { "positions/assign", 5 },
                        { "exchange/wallets/transferOut", 5 },
                        { "exchange/wallets/transferIn", 5 },
                        { "exchange/margins", 5 },
                        { "exchange/wallets/createWithdraw", 5 },
                        { "exchange/wallets/cancelWithdraw", 5 },
                        { "exchange/wallets/createWithdrawAddress", 5 },
                        { "assets/transfer", 5 },
                        { "assets/spots/sub-accounts/transfer", 5 },
                        { "assets/futures/sub-accounts/transfer", 5 },
                        { "assets/universal-transfer", 5 },
                        { "assets/convert", 5 },
                        { "phemex-withdraw/wallets/api/createWithdraw", 5 },
                        { "phemex-withdraw/wallets/api/cancelWithdraw", 5 },
                    } },
                    { "put", new Dictionary<string, object>() {
                        { "spot/orders/create", 1 },
                        { "spot/orders", 1 },
                        { "orders/replace", 1 },
                        { "g-orders/replace", 1 },
                        { "positions/leverage", 5 },
                        { "g-positions/leverage", 5 },
                        { "g-positions/switch-pos-mode-sync", 5 },
                        { "positions/riskLimit", 5 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "spot/orders", 2 },
                        { "spot/orders/all", 2 },
                        { "orders/cancel", 1 },
                        { "orders", 1 },
                        { "orders/all", 3 },
                        { "g-orders/cancel", 1 },
                        { "g-orders", 1 },
                        { "g-orders/all", 3 },
                    } },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.001") },
                    { "maker", this.parseNumber("0.001") },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "401", typeof(AuthenticationError) },
                    { "412", typeof(BadRequest) },
                    { "6001", typeof(BadRequest) },
                    { "19999", typeof(BadRequest) },
                    { "10001", typeof(DuplicateOrderId) },
                    { "10002", typeof(OrderNotFound) },
                    { "10003", typeof(CancelPending) },
                    { "10004", typeof(CancelPending) },
                    { "10005", typeof(CancelPending) },
                    { "11001", typeof(InsufficientFunds) },
                    { "11002", typeof(InvalidOrder) },
                    { "11003", typeof(InsufficientFunds) },
                    { "11004", typeof(InvalidOrder) },
                    { "11005", typeof(InsufficientFunds) },
                    { "11006", typeof(ExchangeError) },
                    { "11007", typeof(ExchangeError) },
                    { "11008", typeof(ExchangeError) },
                    { "11009", typeof(ExchangeError) },
                    { "11010", typeof(InsufficientFunds) },
                    { "11011", typeof(InvalidOrder) },
                    { "11012", typeof(InvalidOrder) },
                    { "11013", typeof(InvalidOrder) },
                    { "11014", typeof(InvalidOrder) },
                    { "11015", typeof(InvalidOrder) },
                    { "11016", typeof(BadRequest) },
                    { "11017", typeof(ExchangeError) },
                    { "11018", typeof(ExchangeError) },
                    { "11019", typeof(ExchangeError) },
                    { "11020", typeof(ExchangeError) },
                    { "11021", typeof(ExchangeError) },
                    { "11022", typeof(AccountSuspended) },
                    { "11023", typeof(ExchangeError) },
                    { "11024", typeof(ExchangeError) },
                    { "11025", typeof(BadRequest) },
                    { "11026", typeof(ExchangeError) },
                    { "11027", typeof(BadSymbol) },
                    { "11028", typeof(BadSymbol) },
                    { "11029", typeof(ExchangeError) },
                    { "11030", typeof(ExchangeError) },
                    { "11031", typeof(DDoSProtection) },
                    { "11032", typeof(DDoSProtection) },
                    { "11033", typeof(DuplicateOrderId) },
                    { "11034", typeof(InvalidOrder) },
                    { "11035", typeof(InvalidOrder) },
                    { "11036", typeof(InvalidOrder) },
                    { "11037", typeof(InvalidOrder) },
                    { "11038", typeof(InvalidOrder) },
                    { "11039", typeof(InvalidOrder) },
                    { "11040", typeof(InvalidOrder) },
                    { "11041", typeof(InvalidOrder) },
                    { "11042", typeof(InvalidOrder) },
                    { "11043", typeof(InvalidOrder) },
                    { "11044", typeof(InvalidOrder) },
                    { "11045", typeof(InvalidOrder) },
                    { "11046", typeof(InvalidOrder) },
                    { "11047", typeof(InvalidOrder) },
                    { "11048", typeof(InvalidOrder) },
                    { "11049", typeof(InvalidOrder) },
                    { "11050", typeof(InvalidOrder) },
                    { "11051", typeof(InvalidOrder) },
                    { "11052", typeof(InvalidOrder) },
                    { "11053", typeof(InvalidOrder) },
                    { "11054", typeof(InvalidOrder) },
                    { "11055", typeof(InvalidOrder) },
                    { "11056", typeof(InvalidOrder) },
                    { "11057", typeof(InvalidOrder) },
                    { "11058", typeof(InvalidOrder) },
                    { "11059", typeof(InvalidOrder) },
                    { "11060", typeof(InvalidOrder) },
                    { "11061", typeof(CancelPending) },
                    { "11062", typeof(InvalidOrder) },
                    { "11063", typeof(InvalidOrder) },
                    { "11064", typeof(InvalidOrder) },
                    { "11065", typeof(InvalidOrder) },
                    { "11066", typeof(InvalidOrder) },
                    { "11067", typeof(InvalidOrder) },
                    { "11068", typeof(InvalidOrder) },
                    { "11069", typeof(ExchangeError) },
                    { "11070", typeof(BadSymbol) },
                    { "11071", typeof(InvalidOrder) },
                    { "11072", typeof(InvalidOrder) },
                    { "11073", typeof(InvalidOrder) },
                    { "11074", typeof(InvalidOrder) },
                    { "11075", typeof(InvalidOrder) },
                    { "11076", typeof(InvalidOrder) },
                    { "11077", typeof(InvalidOrder) },
                    { "11078", typeof(InvalidOrder) },
                    { "11079", typeof(InvalidOrder) },
                    { "11080", typeof(InvalidOrder) },
                    { "11081", typeof(InvalidOrder) },
                    { "11082", typeof(InsufficientFunds) },
                    { "11083", typeof(InvalidOrder) },
                    { "11084", typeof(InvalidOrder) },
                    { "11085", typeof(DuplicateOrderId) },
                    { "11086", typeof(InvalidOrder) },
                    { "11087", typeof(InvalidOrder) },
                    { "11088", typeof(InvalidOrder) },
                    { "11089", typeof(InvalidOrder) },
                    { "11090", typeof(InvalidOrder) },
                    { "11091", typeof(InvalidOrder) },
                    { "11092", typeof(InvalidOrder) },
                    { "11093", typeof(InvalidOrder) },
                    { "11094", typeof(InvalidOrder) },
                    { "11095", typeof(InvalidOrder) },
                    { "11096", typeof(InvalidOrder) },
                    { "11097", typeof(BadRequest) },
                    { "11098", typeof(BadRequest) },
                    { "11099", typeof(ExchangeError) },
                    { "11100", typeof(InsufficientFunds) },
                    { "11101", typeof(InsufficientFunds) },
                    { "11102", typeof(BadRequest) },
                    { "11103", typeof(BadRequest) },
                    { "11104", typeof(BadRequest) },
                    { "11105", typeof(InsufficientFunds) },
                    { "11106", typeof(InsufficientFunds) },
                    { "11107", typeof(ExchangeError) },
                    { "11108", typeof(InvalidOrder) },
                    { "11109", typeof(InvalidOrder) },
                    { "11110", typeof(InvalidOrder) },
                    { "11111", typeof(InvalidOrder) },
                    { "11112", typeof(InvalidOrder) },
                    { "11113", typeof(BadRequest) },
                    { "11114", typeof(InvalidOrder) },
                    { "11115", typeof(InvalidOrder) },
                    { "11116", typeof(InvalidOrder) },
                    { "11117", typeof(InvalidOrder) },
                    { "11118", typeof(InvalidOrder) },
                    { "11119", typeof(InvalidOrder) },
                    { "11120", typeof(InvalidOrder) },
                    { "11121", typeof(InvalidOrder) },
                    { "11122", typeof(InvalidOrder) },
                    { "11123", typeof(InvalidOrder) },
                    { "11124", typeof(InvalidOrder) },
                    { "11125", typeof(InvalidOrder) },
                    { "11126", typeof(InvalidOrder) },
                    { "11128", typeof(InvalidOrder) },
                    { "11129", typeof(InvalidOrder) },
                    { "11130", typeof(InvalidOrder) },
                    { "11131", typeof(InvalidOrder) },
                    { "11132", typeof(InvalidOrder) },
                    { "11133", typeof(InvalidOrder) },
                    { "11134", typeof(InvalidOrder) },
                    { "30000", typeof(BadRequest) },
                    { "30018", typeof(BadRequest) },
                    { "34003", typeof(PermissionDenied) },
                    { "35104", typeof(InsufficientFunds) },
                    { "39995", typeof(RateLimitExceeded) },
                    { "39996", typeof(PermissionDenied) },
                    { "39997", typeof(BadSymbol) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "401 Insufficient privilege", typeof(PermissionDenied) },
                    { "401 Request IP mismatch", typeof(PermissionDenied) },
                    { "Failed to find api-key", typeof(AuthenticationError) },
                    { "Missing required parameter", typeof(BadRequest) },
                    { "API Signature verification failed", typeof(AuthenticationError) },
                    { "Api key not found", typeof(AuthenticationError) },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "brokerId", "CCXT123456" },
                { "x-phemex-request-expiry", 60 },
                { "createOrderByQuoteRequiresPrice", true },
                { "networks", new Dictionary<string, object>() {
                    { "TRC20", "TRX" },
                    { "ERC20", "ETH" },
                    { "BEP20", "BNB" },
                } },
                { "defaultNetworks", new Dictionary<string, object>() {
                    { "USDT", "ETH" },
                } },
                { "defaultSubType", "linear" },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "spot" },
                    { "swap", "future" },
                } },
                { "stableCoins", new List<object>() {"BUSD", "FEI", "TUSD", "USD", "USDC", "USDD", "USDP", "USDT"} },
                { "transfer", new Dictionary<string, object>() {
                    { "fillResponseFromRequest", true },
                } },
            } },
        });
    }

    public virtual object parseSafeNumber(object value = null)
    {
        if (isTrue(isEqual(value, null)))
        {
            return value;
        }
        object parts = ((string)value).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
        value = String.Join("", ((IList<object>)parts).ToArray());
        parts = ((string)value).Split(new [] {((string)" ")}, StringSplitOptions.None).ToList<object>();
        return this.safeNumber(parts, 0);
    }

    public virtual object parseSwapMarket(object market)
    {
        //
        //     {
        //         "symbol":"BTCUSD",
        //         "code":"1",
        //         "type":"Perpetual",
        //         "displaySymbol":"BTC / USD",
        //         "indexSymbol":".BTC",
        //         "markSymbol":".MBTC",
        //         "fundingRateSymbol":".BTCFR",
        //         "fundingRate8hSymbol":".BTCFR8H",
        //         "contractUnderlyingAssets":"USD",
        //         "settleCurrency":"BTC",
        //         "quoteCurrency":"USD",
        //         "contractSize":"1 USD",
        //         "lotSize":1,
        //         "tickSize":0.5,
        //         "priceScale":4,
        //         "ratioScale":8,
        //         "pricePrecision":1,
        //         "minPriceEp":5000,
        //         "maxPriceEp":10000000000,
        //         "maxOrderQty":1000000,
        //         "status":"Listed",
        //         "tipOrderQty":1000000,
        //         "listTime":"1574650800000",
        //         "majorSymbol":true,
        //         "steps":"50",
        //         "riskLimits":[
        //             {"limit":100,"initialMargin":"1.0%","initialMarginEr":1000000,"maintenanceMargin":"0.5%","maintenanceMarginEr":500000},
        //             {"limit":150,"initialMargin":"1.5%","initialMarginEr":1500000,"maintenanceMargin":"1.0%","maintenanceMarginEr":1000000},
        //             {"limit":200,"initialMargin":"2.0%","initialMarginEr":2000000,"maintenanceMargin":"1.5%","maintenanceMarginEr":1500000},
        //         ],
        //         "underlyingSymbol":".BTC",
        //         "baseCurrency":"BTC",
        //         "settlementCurrency":"BTC",
        //         "valueScale":8,
        //         "defaultLeverage":0,
        //         "maxLeverage":100,
        //         "initMarginEr":"1000000",
        //         "maintMarginEr":"500000",
        //         "defaultRiskLimitEv":10000000000,
        //         "deleverage":true,
        //         "makerFeeRateEr":-250000,
        //         "takerFeeRateEr":750000,
        //         "fundingInterval":8,
        //         "marketUrl":"https://phemex.com/trade/BTCUSD",
        //         "description":"BTCUSD is a BTC/USD perpetual contract priced on the .BTC Index. Each contract is worth 1 USD of Bitcoin. Funding is paid and received every 8 hours. At UTC time: 00:00, 08:00, 16:00.",
        //     }
        //
        object id = this.safeString(market, "symbol");
        object baseId = this.safeString2(market, "baseCurrency", "contractUnderlyingAssets");
        object quoteId = this.safeString(market, "quoteCurrency");
        object settleId = this.safeString(market, "settleCurrency");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object settle = this.safeCurrencyCode(settleId);
        object inverse = false;
        if (isTrue(!isEqual(settleId, quoteId)))
        {
            inverse = true;
        }
        object priceScale = this.safeInteger(market, "priceScale");
        object ratioScale = this.safeInteger(market, "ratioScale");
        object valueScale = this.safeInteger(market, "valueScale");
        object minPriceEp = this.safeString(market, "minPriceEp");
        object maxPriceEp = this.safeString(market, "maxPriceEp");
        object makerFeeRateEr = this.safeString(market, "makerFeeRateEr");
        object takerFeeRateEr = this.safeString(market, "takerFeeRateEr");
        object status = this.safeString(market, "status");
        object contractSizeString = this.safeString(market, "contractSize", " ");
        object contractSize = null;
        if (isTrue(isEqual(settle, "USDT")))
        {
            contractSize = this.parseNumber("1");
        } else if (isTrue(getIndexOf(contractSizeString, " ")))
        {
            // "1 USD"
            // "0.005 ETH"
            object parts = ((string)contractSizeString).Split(new [] {((string)" ")}, StringSplitOptions.None).ToList<object>();
            contractSize = this.parseNumber(getValue(parts, 0));
        } else
        {
            // "1.0"
            contractSize = this.parseNumber(contractSizeString);
        }
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", id },
            { "symbol", add(add(add(add(bs, "/"), quote), ":"), settle) },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", "swap" },
            { "spot", false },
            { "margin", false },
            { "swap", true },
            { "future", false },
            { "option", false },
            { "active", isEqual(status, "Listed") },
            { "contract", true },
            { "linear", !isTrue(inverse) },
            { "inverse", inverse },
            { "taker", this.parseNumber(this.fromEn(takerFeeRateEr, ratioScale)) },
            { "maker", this.parseNumber(this.fromEn(makerFeeRateEr, ratioScale)) },
            { "contractSize", contractSize },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "priceScale", priceScale },
            { "valueScale", valueScale },
            { "ratioScale", ratioScale },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber2(market, "lotSize", "qtyStepSize") },
                { "price", this.safeNumber(market, "tickSize") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", this.parseNumber("1") },
                    { "max", this.safeNumber(market, "maxLeverage") },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", this.parseNumber(this.fromEn(minPriceEp, priceScale)) },
                    { "max", this.parseNumber(this.fromEn(maxPriceEp, priceScale)) },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", this.parseNumber(this.safeString(market, "maxOrderQty")) },
                } },
            } },
            { "created", null },
            { "info", market },
        });
    }

    public virtual object parseSpotMarket(object market)
    {
        //
        //     {
        //         "symbol":"sBTCUSDT",
        //         "code":1001,
        //         "type":"Spot",
        //         "displaySymbol":"BTC / USDT",
        //         "quoteCurrency":"USDT",
        //         "priceScale":8,
        //         "ratioScale":8,
        //         "pricePrecision":2,
        //         "baseCurrency":"BTC",
        //         "baseTickSize":"0.000001 BTC",
        //         "baseTickSizeEv":100,
        //         "quoteTickSize":"0.01 USDT",
        //         "quoteTickSizeEv":1000000,
        //         "baseQtyPrecision":6,
        //         "quoteQtyPrecision":2,
        //         "minOrderValue":"10 USDT",
        //         "minOrderValueEv":1000000000,
        //         "maxBaseOrderSize":"1000 BTC",
        //         "maxBaseOrderSizeEv":100000000000,
        //         "maxOrderValue":"5,000,000 USDT",
        //         "maxOrderValueEv":500000000000000,
        //         "defaultTakerFee":"0.001",
        //         "defaultTakerFeeEr":100000,
        //         "defaultMakerFee":"0.001",
        //         "defaultMakerFeeEr":100000,
        //         "description":"BTCUSDT is a BTC/USDT spot trading pair. Minimum order value is 1 USDT",
        //         "status":"Listed",
        //         "tipOrderQty":2,
        //         "listTime":1589338800000,
        //         "buyPriceUpperLimitPct":110,
        //         "sellPriceLowerLimitPct":90,
        //         "leverage":5
        //     },
        //
        object type = this.safeStringLower(market, "type");
        object id = this.safeString(market, "symbol");
        object quoteId = this.safeString(market, "quoteCurrency");
        object baseId = this.safeString(market, "baseCurrency");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object status = this.safeString(market, "status");
        object precisionAmount = this.parseSafeNumber(this.safeString(market, "baseTickSize"));
        object precisionPrice = this.parseSafeNumber(this.safeString(market, "quoteTickSize"));
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", id },
            { "symbol", add(add(bs, "/"), quote) },
            { "base", bs },
            { "quote", quote },
            { "settle", null },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", null },
            { "type", type },
            { "spot", true },
            { "margin", false },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "active", isEqual(status, "Listed") },
            { "contract", false },
            { "linear", null },
            { "inverse", null },
            { "taker", this.safeNumber(market, "defaultTakerFee") },
            { "maker", this.safeNumber(market, "defaultMakerFee") },
            { "contractSize", null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "priceScale", this.safeInteger(market, "priceScale") },
            { "valueScale", this.safeInteger(market, "valueScale") },
            { "ratioScale", this.safeInteger(market, "ratioScale") },
            { "precision", new Dictionary<string, object>() {
                { "amount", precisionAmount },
                { "price", precisionPrice },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", precisionAmount },
                    { "max", this.parseSafeNumber(this.safeString(market, "maxBaseOrderSize")) },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", precisionPrice },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", this.parseSafeNumber(this.safeString(market, "minOrderValue")) },
                    { "max", this.parseSafeNumber(this.safeString(market, "maxOrderValue")) },
                } },
            } },
            { "created", null },
            { "info", market },
        });
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchMarkets
        * @description retrieves data on all markets for phemex
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object v2Products = await this.v2GetPublicProducts(parameters);
        //
        //     {
        //         "code":0,
        //         "msg":"",
        //         "data":{
        //             "currencies":[
        //                 {"currency":"BTC","name":"Bitcoin","code":1,"valueScale":8,"minValueEv":1,"maxValueEv":5000000000000000000,"needAddrTag":0,"status":"Listed","displayCurrency":"BTC","inAssetsDisplay":1,"perpetual":0,"stableCoin":0,"assetsPrecision":8},
        //                 {"currency":"USD","name":"USD","code":2,"valueScale":4,"minValueEv":1,"maxValueEv":5000000000000000000,"needAddrTag":0,"status":"Listed","displayCurrency":"USD","inAssetsDisplay":1,"perpetual":0,"stableCoin":0,"assetsPrecision":2},
        //                 {"currency":"USDT","name":"TetherUS","code":3,"valueScale":8,"minValueEv":1,"maxValueEv":5000000000000000000,"needAddrTag":0,"status":"Listed","displayCurrency":"USDT","inAssetsDisplay":1,"perpetual":2,"stableCoin":1,"assetsPrecision":8},
        //             ],
        //             "products":[
        //                 {
        //                     "symbol":"BTCUSD",
        //                     "code":1,
        //                     "type":"Perpetual"
        //                     "displaySymbol":"BTC / USD",
        //                     "indexSymbol":".BTC",
        //                     "markSymbol":".MBTC",
        //                     "fundingRateSymbol":".BTCFR",
        //                     "fundingRate8hSymbol":".BTCFR8H",
        //                     "contractUnderlyingAssets":"USD",
        //                     "settleCurrency":"BTC",
        //                     "quoteCurrency":"USD",
        //                     "contractSize":1.0,
        //                     "lotSize":1,
        //                     "tickSize":0.5,
        //                     "priceScale":4,
        //                     "ratioScale":8,
        //                     "pricePrecision":1,
        //                     "minPriceEp":5000,
        //                     "maxPriceEp":10000000000,
        //                     "maxOrderQty":1000000,
        //                     "description":"BTC/USD perpetual contracts are priced on the .BTC Index. Each contract is worth 1 USD. Funding fees are paid and received every 8 hours at UTC time: 00:00, 08:00 and 16:00.",
        //                     "status":"Listed",
        //                     "tipOrderQty":1000000,
        //                     "listTime":1574650800000,
        //                     "majorSymbol":true,
        //                     "defaultLeverage":"-10",
        //                     "fundingInterval":28800,
        //                     "maxLeverage":100
        //                 },
        //                 {
        //                     "symbol":"sBTCUSDT",
        //                     "code":1001,
        //                     "type":"Spot",
        //                     "displaySymbol":"BTC / USDT",
        //                     "quoteCurrency":"USDT",
        //                     "priceScale":8,
        //                     "ratioScale":8,
        //                     "pricePrecision":2,
        //                     "baseCurrency":"BTC",
        //                     "baseTickSize":"0.000001 BTC",
        //                     "baseTickSizeEv":100,
        //                     "quoteTickSize":"0.01 USDT",
        //                     "quoteTickSizeEv":1000000,
        //                     "baseQtyPrecision":6,
        //                     "quoteQtyPrecision":2,
        //                     "minOrderValue":"10 USDT",
        //                     "minOrderValueEv":1000000000,
        //                     "maxBaseOrderSize":"1000 BTC",
        //                     "maxBaseOrderSizeEv":100000000000,
        //                     "maxOrderValue":"5,000,000 USDT",
        //                     "maxOrderValueEv":500000000000000,
        //                     "defaultTakerFee":"0.001",
        //                     "defaultTakerFeeEr":100000,
        //                     "defaultMakerFee":"0.001",
        //                     "defaultMakerFeeEr":100000,
        //                     "description":"BTCUSDT is a BTC/USDT spot trading pair. Minimum order value is 1 USDT",
        //                     "status":"Listed",
        //                     "tipOrderQty":2,
        //                     "listTime":1589338800000,
        //                     "buyPriceUpperLimitPct":110,
        //                     "sellPriceLowerLimitPct":90,
        //                     "leverage":5
        //                 },
        //             ],
        //             "perpProductsV2":[
        //                 {
        //                     "symbol":"BTCUSDT",
        //                     "code":41541,
        //                     "type":"PerpetualV2",
        //                     "displaySymbol":"BTC / USDT",
        //                     "indexSymbol":".BTCUSDT",
        //                     "markSymbol":".MBTCUSDT",
        //                     "fundingRateSymbol":".BTCUSDTFR",
        //                     "fundingRate8hSymbol":".BTCUSDTFR8H",
        //                     "contractUnderlyingAssets":"BTC",
        //                     "settleCurrency":"USDT",
        //                     "quoteCurrency":"USDT",
        //                     "tickSize":"0.1",
        //                     "priceScale":0,
        //                     "ratioScale":0,
        //                     "pricePrecision":1,
        //                     "baseCurrency":"BTC",
        //                     "description":"BTC/USDT perpetual contracts are priced on the .BTCUSDT Index. Each contract is worth 1 BTC. Funding fees are paid and received every 8 hours at UTC time: 00:00, 08:00 and 16:00.",
        //                     "status":"Listed",
        //                     "tipOrderQty":0,
        //                     "listTime":1668225600000,
        //                     "majorSymbol":true,
        //                     "defaultLeverage":"-10",
        //                     "fundingInterval":28800,
        //                     "maxLeverage":100,
        //                     "maxOrderQtyRq":"1000",
        //                     "maxPriceRp":"2000000000",
        //                     "minOrderValueRv":"1",
        //                     "minPriceRp":"1000.0",
        //                     "qtyPrecision":3,
        //                     "qtyStepSize":"0.001",
        //                     "tipOrderQtyRq":"200",
        //                     "maxOpenPosLeverage":100.0
        //                 },
        //             ],
        //             "riskLimits":[
        //                 {
        //                     "symbol":"BTCUSD",
        //                     "steps":"50",
        //                     "riskLimits":[
        //                         {"limit":100,"initialMargin":"1.0%","initialMarginEr":1000000,"maintenanceMargin":"0.5%","maintenanceMarginEr":500000},
        //                         {"limit":150,"initialMargin":"1.5%","initialMarginEr":1500000,"maintenanceMargin":"1.0%","maintenanceMarginEr":1000000},
        //                         {"limit":200,"initialMargin":"2.0%","initialMarginEr":2000000,"maintenanceMargin":"1.5%","maintenanceMarginEr":1500000},
        //                     ]
        //                 },
        //             ],
        //             "leverages":[
        //                 {"initialMargin":"1.0%","initialMarginEr":1000000,"options":[1,2,3,5,10,25,50,100]},
        //                 {"initialMargin":"1.5%","initialMarginEr":1500000,"options":[1,2,3,5,10,25,50,66]},
        //                 {"initialMargin":"2.0%","initialMarginEr":2000000,"options":[1,2,3,5,10,25,33,50]},
        //             ],
        //             "riskLimitsV2":[
        //                 {
        //                     "symbol":"BTCUSDT",
        //                     "steps":"2000K",
        //                     "riskLimits":[
        //                         {"limit":2000000,"initialMarginRr":"0.01","maintenanceMarginRr":"0.005"},,
        //                         {"limit":4000000,"initialMarginRr":"0.015","maintenanceMarginRr":"0.0075"},
        //                         {"limit":6000000,"initialMarginRr":"0.02","maintenanceMarginRr":"0.01"},
        //                     ]
        //                 },
        //             ],
        //             "leveragesV2":[
        //                 {"options":[1.0,2.0,3.0,5.0,10.0,25.0,50.0,100.0],"initialMarginRr":"0.01"},
        //                 {"options":[1.0,2.0,3.0,5.0,10.0,25.0,50.0,66.67],"initialMarginRr":"0.015"},
        //                 {"options":[1.0,2.0,3.0,5.0,10.0,25.0,33.0,50.0],"initialMarginRr":"0.02"},
        //             ],
        //             "ratioScale":8,
        //             "md5Checksum":"5c6604814d3c1bafbe602c3d11a7e8bf",
        //         }
        //     }
        //
        object v1Products = await this.v1GetExchangePublicProducts(parameters);
        object v1ProductsData = this.safeValue(v1Products, "data", new List<object>() {});
        //
        //     {
        //         "code":0,
        //         "msg":"OK",
        //         "data":[
        //             {
        //                 "symbol":"BTCUSD",
        //                 "underlyingSymbol":".BTC",
        //                 "quoteCurrency":"USD",
        //                 "baseCurrency":"BTC",
        //                 "settlementCurrency":"BTC",
        //                 "maxOrderQty":1000000,
        //                 "maxPriceEp":100000000000000,
        //                 "lotSize":1,
        //                 "tickSize":"0.5",
        //                 "contractSize":"1 USD",
        //                 "priceScale":4,
        //                 "ratioScale":8,
        //                 "valueScale":8,
        //                 "defaultLeverage":0,
        //                 "maxLeverage":100,
        //                 "initMarginEr":"1000000",
        //                 "maintMarginEr":"500000",
        //                 "defaultRiskLimitEv":10000000000,
        //                 "deleverage":true,
        //                 "makerFeeRateEr":-250000,
        //                 "takerFeeRateEr":750000,
        //                 "fundingInterval":8,
        //                 "marketUrl":"https://phemex.com/trade/BTCUSD",
        //                 "description":"BTCUSD is a BTC/USD perpetual contract priced on the .BTC Index. Each contract is worth 1 USD of Bitcoin. Funding is paid and received every 8 hours. At UTC time: 00:00, 08:00, 16:00.",
        //                 "type":"Perpetual"
        //             },
        //         ]
        //     }
        //
        object v2ProductsData = this.safeValue(v2Products, "data", new Dictionary<string, object>() {});
        object products = this.safeValue(v2ProductsData, "products", new List<object>() {});
        object perpetualProductsV2 = this.safeValue(v2ProductsData, "perpProductsV2", new List<object>() {});
        products = this.arrayConcat(products, perpetualProductsV2);
        object riskLimits = this.safeValue(v2ProductsData, "riskLimits", new List<object>() {});
        object riskLimitsV2 = this.safeValue(v2ProductsData, "riskLimitsV2", new List<object>() {});
        riskLimits = this.arrayConcat(riskLimits, riskLimitsV2);
        object currencies = this.safeValue(v2ProductsData, "currencies", new List<object>() {});
        object riskLimitsById = this.indexBy(riskLimits, "symbol");
        object v1ProductsById = this.indexBy(v1ProductsData, "symbol");
        object currenciesByCode = this.indexBy(currencies, "currency");
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(products)); postFixIncrement(ref i))
        {
            object market = getValue(products, i);
            object type = this.safeStringLower(market, "type");
            if (isTrue(isTrue((isEqual(type, "perpetual"))) || isTrue((isEqual(type, "perpetualv2")))))
            {
                object id = this.safeString(market, "symbol");
                object riskLimitValues = this.safeValue(riskLimitsById, id, new Dictionary<string, object>() {});
                market = this.extend(market, riskLimitValues);
                object v1ProductsValues = this.safeValue(v1ProductsById, id, new Dictionary<string, object>() {});
                market = this.extend(market, v1ProductsValues);
                market = this.parseSwapMarket(market);
            } else
            {
                object baseCurrency = this.safeString(market, "baseCurrency");
                object currencyValues = this.safeValue(currenciesByCode, baseCurrency, new Dictionary<string, object>() {});
                object valueScale = this.safeString(currencyValues, "valueScale", "8");
                market = this.extend(market, new Dictionary<string, object>() {
                    { "valueScale", valueScale },
                });
                market = this.parseSpotMarket(market);
            }
            ((IList<object>)result).Add(market);
        }
        return result;
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v2GetPublicProducts(parameters);
        //
        //     {
        //         "code":0,
        //         "msg":"OK",
        //         "data":{
        //             ...,
        //             "currencies":[
        //                 {"currency":"BTC","name":"Bitcoin","code":1,"valueScale":8,"minValueEv":1,"maxValueEv":5000000000000000000,"needAddrTag":0,"status":"Listed","displayCurrency":"BTC","inAssetsDisplay":1,"perpetual":0,"stableCoin":0,"assetsPrecision":8},
        //                 {"currency":"USD","name":"USD","code":2,"valueScale":4,"minValueEv":1,"maxValueEv":5000000000000000000,"needAddrTag":0,"status":"Listed","displayCurrency":"USD","inAssetsDisplay":1,"perpetual":0,"stableCoin":0,"assetsPrecision":2},
        //                 {"currency":"USDT","name":"TetherUS","code":3,"valueScale":8,"minValueEv":1,"maxValueEv":5000000000000000000,"needAddrTag":0,"status":"Listed","displayCurrency":"USDT","inAssetsDisplay":1,"perpetual":2,"stableCoin":1,"assetsPrecision":8},
        //             ],
        //             ...
        //         }
        //     }
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object currencies = this.safeValue(data, "currencies", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currency = getValue(currencies, i);
            object id = this.safeString(currency, "currency");
            object name = this.safeString(currency, "name");
            object code = this.safeCurrencyCode(id);
            object status = this.safeString(currency, "status");
            object valueScaleString = this.safeString(currency, "valueScale");
            object valueScale = parseInt(valueScaleString);
            object minValueEv = this.safeString(currency, "minValueEv");
            object maxValueEv = this.safeString(currency, "maxValueEv");
            object minAmount = null;
            object maxAmount = null;
            object precision = null;
            if (isTrue(!isEqual(valueScale, null)))
            {
                object precisionString = this.parsePrecision(valueScaleString);
                precision = this.parseNumber(precisionString);
                minAmount = this.parseNumber(Precise.stringMul(minValueEv, precisionString));
                maxAmount = this.parseNumber(Precise.stringMul(maxValueEv, precisionString));
            }
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "info", currency },
                { "code", code },
                { "name", name },
                { "active", isEqual(status, "Listed") },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "precision", precision },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", minAmount },
                        { "max", maxAmount },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "valueScale", valueScale },
                { "networks", new Dictionary<string, object>() {} },
            };
        }
        return result;
    }

    public virtual object customParseBidAsk(object bidask, object priceKey = null, object amountKey = null, object market = null)
    {
        priceKey ??= 0;
        amountKey ??= 1;
        if (isTrue(isEqual(market, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " customParseBidAsk() requires a market argument")) ;
        }
        object amount = this.safeString(bidask, amountKey);
        if (isTrue(getValue(market, "spot")))
        {
            amount = this.fromEv(amount, market);
        }
        return new List<object> {this.parseNumber(this.fromEp(this.safeString(bidask, priceKey), market)), this.parseNumber(amount)};
    }

    public virtual object customParseOrderBook(object orderbook, object symbol, object timestamp = null, object bidsKey = null, object asksKey = null, object priceKey = null, object amountKey = null, object market = null)
    {
        bidsKey ??= "bids";
        asksKey ??= "asks";
        priceKey ??= 0;
        amountKey ??= 1;
        object result = new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "nonce", null },
        };
        object sides = new List<object>() {bidsKey, asksKey};
        for (object i = 0; isLessThan(i, getArrayLength(sides)); postFixIncrement(ref i))
        {
            object side = getValue(sides, i);
            object orders = new List<object>() {};
            object bidasks = this.safeValue(orderbook, side);
            for (object k = 0; isLessThan(k, getArrayLength(bidasks)); postFixIncrement(ref k))
            {
                ((IList<object>)orders).Add(this.customParseBidAsk(getValue(bidasks, k), priceKey, amountKey, market));
            }
            ((IDictionary<string,object>)result)[(string)side] = orders;
        }
        ((IDictionary<string,object>)result)[(string)bidsKey] = this.sortBy(getValue(result, bidsKey), 0, true);
        ((IDictionary<string,object>)result)[(string)asksKey] = this.sortBy(getValue(result, asksKey), 0);
        return ((object)result);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#queryorderbook
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(isTrue(getValue(market, "linear")) && isTrue(isEqual(getValue(market, "settle"), "USDT"))))
        {
            response = await this.v2GetMdV2Orderbook(this.extend(request, parameters));
        } else
        {
            if (isTrue(isTrue((!isEqual(limit, null))) && isTrue((isLessThanOrEqual(limit, 30)))))
            {
                response = await this.v1GetMdOrderbook(this.extend(request, parameters));
            } else
            {
                response = await this.v1GetMdFullbook(this.extend(request, parameters));
            }
        }
        //
        //     {
        //         "error": null,
        //         "id": 0,
        //         "result": {
        //             "book": {
        //                 "asks": [
        //                     [ 23415000000, 105262000 ],
        //                     [ 23416000000, 147914000 ],
        //                     [ 23419000000, 160914000 ],
        //                 ],
        //                 "bids": [
        //                     [ 23360000000, 32995000 ],
        //                     [ 23359000000, 221887000 ],
        //                     [ 23356000000, 284599000 ],
        //                 ],
        //             },
        //             "depth": 30,
        //             "sequence": 1592059928,
        //             "symbol": "sETHUSDT",
        //             "timestamp": 1592387340020000955,
        //             "type": "snapshot"
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object book = this.safeValue2(result, "book", "orderbook_p", new Dictionary<string, object>() {});
        object timestamp = this.safeIntegerProduct(result, "timestamp", 0.000001);
        object orderbook = this.customParseOrderBook(book, symbol, timestamp, "bids", "asks", 0, 1, market);
        ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger(result, "sequence");
        return orderbook;
    }

    public virtual object toEn(object n, object scale)
    {
        object stringN = this.numberToString(n);
        var precise = new Precise(stringN);
        precise.decimals = subtract(precise.decimals, scale);
        precise.reduce();
        object preciseString = ((object)precise).ToString();
        return this.parseToInt(preciseString);
    }

    public virtual object toEv(object amount, object market = null)
    {
        if (isTrue(isTrue((isEqual(amount, null))) || isTrue((isEqual(market, null)))))
        {
            return amount;
        }
        return this.toEn(amount, getValue(market, "valueScale"));
    }

    public virtual object toEp(object price, object market = null)
    {
        if (isTrue(isTrue((isEqual(price, null))) || isTrue((isEqual(market, null)))))
        {
            return price;
        }
        return this.toEn(price, getValue(market, "priceScale"));
    }

    public virtual object fromEn(object en, object scale)
    {
        if (isTrue(isEqual(en, null)))
        {
            return null;
        }
        var precise = new Precise(en);
        precise.decimals = this.sum(precise.decimals, scale);
        precise.reduce();
        return ((object)precise).ToString();
    }

    public virtual object fromEp(object ep, object market = null)
    {
        if (isTrue(isTrue((isEqual(ep, null))) || isTrue((isEqual(market, null)))))
        {
            return ep;
        }
        return this.fromEn(ep, this.safeInteger(market, "priceScale"));
    }

    public virtual object fromEv(object ev, object market = null)
    {
        if (isTrue(isTrue((isEqual(ev, null))) || isTrue((isEqual(market, null)))))
        {
            return ev;
        }
        return this.fromEn(ev, this.safeInteger(market, "valueScale"));
    }

    public virtual object fromEr(object er, object market = null)
    {
        if (isTrue(isTrue((isEqual(er, null))) || isTrue((isEqual(market, null)))))
        {
            return er;
        }
        return this.fromEn(er, this.safeInteger(market, "ratioScale"));
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         1592467200, // timestamp
        //         300, // interval
        //         23376000000, // last
        //         23322000000, // open
        //         23381000000, // high
        //         23315000000, // low
        //         23367000000, // close
        //         208671000, // base volume
        //         48759063370, // quote volume
        //     ]
        //
        object baseVolume = null;
        if (isTrue(isTrue((!isEqual(market, null))) && isTrue(getValue(market, "spot"))))
        {
            baseVolume = this.parseNumber(this.fromEv(this.safeString(ohlcv, 7), market));
        } else
        {
            baseVolume = this.safeNumber(ohlcv, 7);
        }
        return new List<object> {this.safeTimestamp(ohlcv, 0), this.parseNumber(this.fromEp(this.safeString(ohlcv, 3), market)), this.parseNumber(this.fromEp(this.safeString(ohlcv, 4), market)), this.parseNumber(this.fromEp(this.safeString(ohlcv, 5), market)), this.parseNumber(this.fromEp(this.safeString(ohlcv, 6), market)), baseVolume};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#querykline
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Contract-API-en.md#query-kline
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] *only used for USDT settled contracts, otherwise is emulated and not supported by the exchange* timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] *USDT settled/ linear swaps only* end time in ms
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object userLimit = limit;
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "resolution", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        object until = this.safeInteger2(parameters, "until", "to");
        parameters = this.omit(parameters, new List<object>() {"until"});
        object usesSpecialFromToEndpoint = isTrue(((isTrue(getValue(market, "linear")) || isTrue(isEqual(getValue(market, "settle"), "USDT"))))) && isTrue((isTrue((!isEqual(since, null))) || isTrue((!isEqual(until, null)))));
        object maxLimit = 1000;
        if (isTrue(usesSpecialFromToEndpoint))
        {
            maxLimit = 2000;
        }
        if (isTrue(isEqual(limit, null)))
        {
            limit = maxLimit;
        }
        ((IDictionary<string,object>)request)["limit"] = mathMin(limit, maxLimit);
        object response = null;
        if (isTrue(isTrue(getValue(market, "linear")) || isTrue(isEqual(getValue(market, "settle"), "USDT"))))
        {
            if (isTrue(isTrue((!isEqual(until, null))) || isTrue((!isEqual(since, null)))))
            {
                object candleDuration = this.parseTimeframe(timeframe);
                if (isTrue(!isEqual(since, null)))
                {
                    since = Math.Round(Convert.ToDouble(divide(since, 1000)));
                    ((IDictionary<string,object>)request)["from"] = since;
                } else
                {
                    // when 'to' is defined since is mandatory
                    since = subtract((divide(until, 100)), (multiply(maxLimit, candleDuration)));
                }
                if (isTrue(!isEqual(until, null)))
                {
                    ((IDictionary<string,object>)request)["to"] = Math.Round(Convert.ToDouble(divide(until, 1000)));
                } else
                {
                    // when since is defined 'to' is mandatory
                    object to = add(since, (multiply(maxLimit, candleDuration)));
                    object now = this.seconds();
                    if (isTrue(isGreaterThan(to, now)))
                    {
                        to = now;
                    }
                    ((IDictionary<string,object>)request)["to"] = to;
                }
                response = await this.publicGetMdV2KlineList(this.extend(request, parameters));
            } else
            {
                response = await this.publicGetMdV2KlineLast(this.extend(request, parameters));
            }
        } else
        {
            if (isTrue(!isEqual(since, null)))
            {
                // phemex also provides kline query with from/to, however, this interface is NOT recommended and does not work properly.
                // we do not send since param to the exchange, instead we calculate appropriate limit param
                object duration = multiply(this.parseTimeframe(timeframe), 1000);
                object timeDelta = subtract(this.milliseconds(), since);
                limit = this.parseToInt(divide(timeDelta, duration)); // setting limit to the number of candles after since
            }
            response = await this.publicGetMdV2Kline(this.extend(request, parameters));
        }
        //
        //     {
        //         "code":0,
        //         "msg":"OK",
        //         "data":{
        //             "total":-1,
        //             "rows":[
        //                 [1592467200,300,23376000000,23322000000,23381000000,23315000000,23367000000,208671000,48759063370],
        //                 [1592467500,300,23367000000,23314000000,23390000000,23311000000,23331000000,234820000,54848948710],
        //                 [1592467800,300,23331000000,23385000000,23391000000,23326000000,23387000000,152931000,35747882250],
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeList(data, "rows", new List<object>() {});
        return this.parseOHLCVs(rows, market, timeframe, since, userLimit);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // spot
        //
        //     {
        //         "askEp": 943836000000,
        //         "bidEp": 943601000000,
        //         "highEp": 955946000000,
        //         "lastEp": 943803000000,
        //         "lowEp": 924973000000,
        //         "openEp": 948693000000,
        //         "symbol": "sBTCUSDT",
        //         "timestamp": 1592471203505728630,
        //         "turnoverEv": 111822826123103,
        //         "volumeEv": 11880532281
        //     }
        //
        // swap
        //
        //     {
        //         "askEp": 2332500,
        //         "bidEp": 2331000,
        //         "fundingRateEr": 10000,
        //         "highEp": 2380000,
        //         "indexEp": 2329057,
        //         "lastEp": 2331500,
        //         "lowEp": 2274000,
        //         "markEp": 2329232,
        //         "openEp": 2337500,
        //         "openInterest": 1298050,
        //         "predFundingRateEr": 19921,
        //         "symbol": "ETHUSD",
        //         "timestamp": 1592474241582701416,
        //         "turnoverEv": 47228362330,
        //         "volume": 4053863
        //     }
        // linear swap v2
        //
        //     {
        //         "closeRp":"16820.5",
        //         "fundingRateRr":"0.0001",
        //         "highRp":"16962.1",
        //         "indexPriceRp":"16830.15651565",
        //         "lowRp":"16785",
        //         "markPriceRp":"16830.97534951",
        //         "openInterestRv":"1323.596",
        //         "openRp":"16851.7",
        //         "predFundingRateRr":"0.0001",
        //         "symbol":"BTCUSDT",
        //         "timestamp":"1672142789065593096",
        //         "turnoverRv":"124835296.0538",
        //         "volumeRq":"7406.95"
        //     }
        //
        object marketId = this.safeString(ticker, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeIntegerProduct(ticker, "timestamp", 0.000001);
        object last = this.fromEp(this.safeString2(ticker, "lastEp", "closeRp"), market);
        object quoteVolume = this.fromEr(this.safeString2(ticker, "turnoverEv", "turnoverRv"), market);
        object baseVolume = this.safeString(ticker, "volume");
        if (isTrue(isEqual(baseVolume, null)))
        {
            baseVolume = this.fromEv(this.safeString2(ticker, "volumeEv", "volumeRq"), market);
        }
        object open = this.fromEp(this.safeString(ticker, "openEp"), market);
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.fromEp(this.safeString2(ticker, "highEp", "highRp"), market) },
            { "low", this.fromEp(this.safeString2(ticker, "lowEp", "lowRp"), market) },
            { "bid", this.fromEp(this.safeString(ticker, "bidEp"), market) },
            { "bidVolume", null },
            { "ask", this.fromEp(this.safeString(ticker, "askEp"), market) },
            { "askVolume", null },
            { "vwap", null },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#query24hrsticker
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            if (isTrue(isTrue(getValue(market, "inverse")) || isTrue(isEqual(getValue(market, "settle"), "USD"))))
            {
                response = await this.v1GetMdTicker24hr(this.extend(request, parameters));
            } else
            {
                response = await this.v2GetMdV2Ticker24hr(this.extend(request, parameters));
            }
        } else
        {
            response = await this.v1GetMdSpotTicker24hr(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "error": null,
        //         "id": 0,
        //         "result": {
        //             "askEp": 943836000000,
        //             "bidEp": 943601000000,
        //             "highEp": 955946000000,
        //             "lastEp": 943803000000,
        //             "lowEp": 924973000000,
        //             "openEp": 948693000000,
        //             "symbol": "sBTCUSDT",
        //             "timestamp": 1592471203505728630,
        //             "turnoverEv": 111822826123103,
        //             "volumeEv": 11880532281
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         "error": null,
        //         "id": 0,
        //         "result": {
        //             "askEp": 2332500,
        //             "bidEp": 2331000,
        //             "fundingRateEr": 10000,
        //             "highEp": 2380000,
        //             "indexEp": 2329057,
        //             "lastEp": 2331500,
        //             "lowEp": 2274000,
        //             "markEp": 2329232,
        //             "openEp": 2337500,
        //             "openInterest": 1298050,
        //             "predFundingRateEr": 19921,
        //             "symbol": "ETHUSD",
        //             "timestamp": 1592474241582701416,
        //             "turnoverEv": 47228362330,
        //             "volume": 4053863
        //         }
        //     }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parseTicker(result, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://phemex-docs.github.io/#query-24-hours-ticker-for-all-symbols-2     // spot
        * @see https://phemex-docs.github.io/#query-24-ticker-for-all-symbols             // linear
        * @see https://phemex-docs.github.io/#query-24-hours-ticker-for-all-symbols       // inverse
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object first = this.safeValue(symbols, 0);
            market = this.market(first);
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchTickers", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object query = this.omit(parameters, "type");
        object response = null;
        if (isTrue(isEqual(type, "spot")))
        {
            response = await this.v1GetMdSpotTicker24hrAll(query);
        } else if (isTrue(isTrue(isEqual(subType, "inverse")) || isTrue(isEqual(this.safeString(market, "settle"), "USD"))))
        {
            response = await this.v1GetMdTicker24hrAll(query);
        } else
        {
            response = await this.v2GetMdV2Ticker24hrAll(query);
        }
        object result = this.safeList(response, "result", new List<object>() {});
        return this.parseTickers(result, symbols);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#querytrades
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(isTrue(getValue(market, "linear")) && isTrue(isEqual(getValue(market, "settle"), "USDT"))))
        {
            response = await this.v2GetMdV2Trade(this.extend(request, parameters));
        } else
        {
            response = await this.v1GetMdTrade(this.extend(request, parameters));
        }
        //
        //     {
        //         "error": null,
        //         "id": 0,
        //         "result": {
        //             "sequence": 1315644947,
        //             "symbol": "BTCUSD",
        //             "trades": [
        //                 [ 1592541746712239749, 13156448570000, "Buy", 93070000, 40173 ],
        //                 [ 1592541740434625085, 13156447110000, "Sell", 93065000, 5000 ],
        //                 [ 1592541732958241616, 13156441390000, "Buy", 93070000, 3460 ],
        //             ],
        //             "type": "snapshot"
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object trades = this.safeValue2(result, "trades", "trades_p", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public) spot & contract
        //
        //     [
        //         1592541746712239749,
        //         13156448570000,
        //         "Buy",
        //         93070000,
        //         40173
        //     ]
        //
        // fetchTrades (public) perp
        //
        //     [
        //         1675690986063435800,
        //         "Sell",
        //         "22857.4",
        //         "0.269"
        //     ]
        //
        // fetchMyTrades (private)
        //
        // spot
        //
        //     {
        //         "qtyType": "ByQuote",
        //         "transactTimeNs": 1589450974800550100,
        //         "clOrdID": "8ba59d40-df25-d4b0-14cf-0703f44e9690",
        //         "orderID": "b2b7018d-f02f-4c59-b4cf-051b9c2d2e83",
        //         "symbol": "sBTCUSDT",
        //         "side": "Buy",
        //         "priceEP": 970056000000,
        //         "baseQtyEv": 0,
        //         "quoteQtyEv": 1000000000,
        //         "action": "New",
        //         "execStatus": "MakerFill",
        //         "ordStatus": "Filled",
        //         "ordType": "Limit",
        //         "execInst": "None",
        //         "timeInForce": "GoodTillCancel",
        //         "stopDirection": "UNSPECIFIED",
        //         "tradeType": "Trade",
        //         "stopPxEp": 0,
        //         "execId": "c6bd8979-07ba-5946-b07e-f8b65135dbb1",
        //         "execPriceEp": 970056000000,
        //         "execBaseQtyEv": 103000,
        //         "execQuoteQtyEv": 999157680,
        //         "leavesBaseQtyEv": 0,
        //         "leavesQuoteQtyEv": 0,
        //         "execFeeEv": 0,
        //         "feeRateEr": 0
        //         "baseCurrency": "BTC",
        //         "quoteCurrency": "USDT",
        //         "feeCurrency": "BTC"
        //     }
        //
        // swap
        //
        //     {
        //         "transactTimeNs": 1578026629824704800,
        //         "symbol": "BTCUSD",
        //         "currency": "BTC",
        //         "action": "Replace",
        //         "side": "Sell",
        //         "tradeType": "Trade",
        //         "execQty": 700,
        //         "execPriceEp": 71500000,
        //         "orderQty": 700,
        //         "priceEp": 71500000,
        //         "execValueEv": 9790209,
        //         "feeRateEr": -25000,
        //         "execFeeEv": -2447,
        //         "ordType": "Limit",
        //         "execID": "b01671a1-5ddc-5def-b80a-5311522fd4bf",
        //         "orderID": "b63bc982-be3a-45e0-8974-43d6375fb626",
        //         "clOrdID": "uuid-1577463487504",
        //         "execStatus": "MakerFill"
        //     }
        // perpetual
        //     {
        //         "accountID": 9328670003,
        //         "action": "New",
        //         "actionBy": "ByUser",
        //         "actionTimeNs": 1666858780876924611,
        //         "addedSeq": 77751555,
        //         "apRp": "0",
        //         "bonusChangedAmountRv": "0",
        //         "bpRp": "0",
        //         "clOrdID": "c0327a7d-9064-62a9-28f6-2db9aaaa04e0",
        //         "closedPnlRv": "0",
        //         "closedSize": "0",
        //         "code": 0,
        //         "cumFeeRv": "0",
        //         "cumQty": "0",
        //         "cumValueRv": "0",
        //         "curAccBalanceRv": "1508.489893982237",
        //         "curAssignedPosBalanceRv": "24.62786650928",
        //         "curBonusBalanceRv": "0",
        //         "curLeverageRr": "-10",
        //         "curPosSide": "Buy",
        //         "curPosSize": "0.043",
        //         "curPosTerm": 1,
        //         "curPosValueRv": "894.0689",
        //         "curRiskLimitRv": "1000000",
        //         "currency": "USDT",
        //         "cxlRejReason": 0,
        //         "displayQty": "0.003",
        //         "execFeeRv": "0",
        //         "execID": "00000000-0000-0000-0000-000000000000",
        //         "execPriceRp": "20723.7",
        //         "execQty": "0",
        //         "execSeq": 77751555,
        //         "execStatus": "New",
        //         "execValueRv": "0",
        //         "feeRateRr": "0",
        //         "leavesQty": "0.003",
        //         "leavesValueRv": "63.4503",
        //         "message": "No error",
        //         "ordStatus": "New",
        //         "ordType": "Market",
        //         "orderID": "fa64c6f2-47a4-4929-aab4-b7fa9bbc4323",
        //         "orderQty": "0.003",
        //         "pegOffsetValueRp": "0",
        //         "posSide": "Long",
        //         "priceRp": "21150.1",
        //         "relatedPosTerm": 1,
        //         "relatedReqNum": 11,
        //         "side": "Buy",
        //         "slTrigger": "ByMarkPrice",
        //         "stopLossRp": "0",
        //         "stopPxRp": "0",
        //         "symbol": "BTCUSDT",
        //         "takeProfitRp": "0",
        //         "timeInForce": "ImmediateOrCancel",
        //         "tpTrigger": "ByLastPrice",
        //         "tradeType": "Amend",
        //         "transactTimeNs": 1666858780881545305,
        //         "userID": 932867
        //     }
        //
        // swap - USDT
        //
        //     {
        //         "createdAt": 1666226932259,
        //         "symbol": "ETHUSDT",
        //         "currency": "USDT",
        //         "action": 1,
        //         "tradeType": 1,
        //         "execQtyRq": "0.01",
        //         "execPriceRp": "1271.9",
        //         "side": 1,
        //         "orderQtyRq": "0.78",
        //         "priceRp": "1271.9",
        //         "execValueRv": "12.719",
        //         "feeRateRr": "0.0001",
        //         "execFeeRv": "0.0012719",
        //         "ordType": 2,
        //         "execId": "8718cae",
        //         "execStatus": 6
        //     }
        //
        object priceString = null;
        object amountString = null;
        object timestamp = null;
        object id = null;
        object side = null;
        object costString = null;
        object type = null;
        object fee = null;
        object feeCostString = null;
        object feeRateString = null;
        object feeCurrencyCode = null;
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object orderId = null;
        object takerOrMaker = null;
        if (isTrue(((trade is IList<object>) || (trade.GetType().IsGenericType && trade.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            object tradeLength = getArrayLength(trade);
            timestamp = this.safeIntegerProduct(trade, 0, 0.000001);
            if (isTrue(isGreaterThan(tradeLength, 4)))
            {
                id = this.safeString(trade, subtract(tradeLength, 4));
            }
            side = this.safeStringLower(trade, subtract(tradeLength, 3));
            priceString = this.safeString(trade, subtract(tradeLength, 2));
            amountString = this.safeString(trade, subtract(tradeLength, 1));
            if (isTrue((getValue(trade, subtract(tradeLength, 2)) is Int64 || getValue(trade, subtract(tradeLength, 2)) is int || getValue(trade, subtract(tradeLength, 2)) is float || getValue(trade, subtract(tradeLength, 2)) is double)))
            {
                priceString = this.fromEp(priceString, market);
                amountString = this.fromEv(amountString, market);
            }
        } else
        {
            timestamp = this.safeIntegerProduct(trade, "transactTimeNs", 0.000001);
            if (isTrue(isEqual(timestamp, null)))
            {
                timestamp = this.safeInteger(trade, "createdAt");
            }
            id = this.safeString2(trade, "execId", "execID");
            orderId = this.safeString(trade, "orderID");
            if (isTrue(isEqual(getValue(market, "settle"), "USDT")))
            {
                object sideId = this.safeStringLower(trade, "side");
                if (isTrue(isTrue((isEqual(sideId, "buy"))) || isTrue((isEqual(sideId, "sell")))))
                {
                    side = sideId;
                } else if (isTrue(!isEqual(sideId, null)))
                {
                    side = ((bool) isTrue((isEqual(sideId, "1")))) ? "buy" : "sell";
                }
                object ordType = this.safeString(trade, "ordType");
                if (isTrue(isEqual(ordType, "1")))
                {
                    type = "market";
                } else if (isTrue(isEqual(ordType, "2")))
                {
                    type = "limit";
                }
                priceString = this.safeString(trade, "execPriceRp");
                amountString = this.safeString(trade, "execQtyRq");
                costString = this.safeString(trade, "execValueRv");
                feeCostString = this.safeString(trade, "execFeeRv");
                feeRateString = this.safeString(trade, "feeRateRr");
                object currencyId = this.safeString(trade, "currency");
                feeCurrencyCode = this.safeCurrencyCode(currencyId);
            } else
            {
                side = this.safeStringLower(trade, "side");
                type = this.parseOrderType(this.safeString(trade, "ordType"));
                object execStatus = this.safeString(trade, "execStatus");
                if (isTrue(isEqual(execStatus, "MakerFill")))
                {
                    takerOrMaker = "maker";
                }
                priceString = this.fromEp(this.safeString(trade, "execPriceEp"), market);
                amountString = this.fromEv(this.safeString(trade, "execBaseQtyEv"), market);
                amountString = this.safeString(trade, "execQty", amountString);
                costString = this.fromEr(this.safeString2(trade, "execQuoteQtyEv", "execValueEv"), market);
                feeCostString = this.fromEr(this.safeString(trade, "execFeeEv"), market);
                if (isTrue(!isEqual(feeCostString, null)))
                {
                    feeRateString = this.fromEr(this.safeString(trade, "feeRateEr"), market);
                    if (isTrue(getValue(market, "spot")))
                    {
                        feeCurrencyCode = this.safeCurrencyCode(this.safeString(trade, "feeCurrency"));
                    } else
                    {
                        object info = this.safeValue(market, "info");
                        if (isTrue(!isEqual(info, null)))
                        {
                            object settlementCurrencyId = this.safeString(info, "settlementCurrency");
                            feeCurrencyCode = this.safeCurrencyCode(settlementCurrencyId);
                        }
                    }
                }
            }
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "rate", feeRateString },
                { "currency", feeCurrencyCode },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "order", orderId },
            { "type", type },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", priceString },
            { "amount", amountString },
            { "cost", costString },
            { "fee", fee },
        }, market);
    }

    public virtual object parseSpotBalance(object response)
    {
        //
        //     {
        //         "code":0,
        //         "msg":"",
        //         "data":[
        //             {
        //                 "currency":"USDT",
        //                 "balanceEv":0,
        //                 "lockedTradingBalanceEv":0,
        //                 "lockedWithdrawEv":0,
        //                 "lastUpdateTimeNs":1592065834511322514,
        //                 "walletVid":0
        //             },
        //             {
        //                 "currency":"ETH",
        //                 "balanceEv":0,
        //                 "lockedTradingBalanceEv":0,
        //                 "lockedWithdrawEv":0,
        //                 "lastUpdateTimeNs":1592065834511322514,
        //                 "walletVid":0
        //             }
        //         ]
        //     }
        //
        object timestamp = null;
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object data = this.safeValue(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object balance = getValue(data, i);
            object currencyId = this.safeString(balance, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object currency = this.safeValue(this.currencies, code, new Dictionary<string, object>() {});
            object scale = this.safeInteger(currency, "valueScale", 8);
            object account = this.account();
            object balanceEv = this.safeString(balance, "balanceEv");
            object lockedTradingBalanceEv = this.safeString(balance, "lockedTradingBalanceEv");
            object lockedWithdrawEv = this.safeString(balance, "lockedWithdrawEv");
            object total = this.fromEn(balanceEv, scale);
            object lockedTradingBalance = this.fromEn(lockedTradingBalanceEv, scale);
            object lockedWithdraw = this.fromEn(lockedWithdrawEv, scale);
            object used = Precise.stringAdd(lockedTradingBalance, lockedWithdraw);
            object lastUpdateTimeNs = this.safeIntegerProduct(balance, "lastUpdateTimeNs", 0.000001);
            timestamp = ((bool) isTrue((isEqual(timestamp, null)))) ? lastUpdateTimeNs : mathMax(timestamp, lastUpdateTimeNs);
            ((IDictionary<string,object>)account)["total"] = total;
            ((IDictionary<string,object>)account)["used"] = used;
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        ((IDictionary<string,object>)result)["timestamp"] = timestamp;
        ((IDictionary<string,object>)result)["datetime"] = this.iso8601(timestamp);
        return this.safeBalance(result);
    }

    public virtual object parseSwapBalance(object response)
    {
        // usdt
        //   {
        //       "info": {
        //         "code": "0",
        //         "msg": '',
        //         "data": {
        //           "account": {
        //             "userID": "940666",
        //             "accountId": "9406660003",
        //             "currency": "USDT",
        //             "accountBalanceRv": "99.93143972",
        //             "totalUsedBalanceRv": "0.40456",
        //             "bonusBalanceRv": "0"
        //           },
        //   }
        //
        //     {
        //         "code":0,
        //         "msg":"",
        //         "data":{
        //             "account":{
        //                 "accountId":6192120001,
        //                 "currency":"BTC",
        //                 "accountBalanceEv":1254744,
        //                 "totalUsedBalanceEv":0,
        //                 "bonusBalanceEv":1254744
        //             }
        //         }
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object balance = this.safeValue(data, "account", new Dictionary<string, object>() {});
        object currencyId = this.safeString(balance, "currency");
        object code = this.safeCurrencyCode(currencyId);
        object currency = this.currency(code);
        object valueScale = this.safeInteger(currency, "valueScale", 8);
        object account = this.account();
        object accountBalanceEv = this.safeString2(balance, "accountBalanceEv", "accountBalanceRv");
        object totalUsedBalanceEv = this.safeString2(balance, "totalUsedBalanceEv", "totalUsedBalanceRv");
        object needsConversion = (!isEqual(code, "USDT"));
        ((IDictionary<string,object>)account)["total"] = ((bool) isTrue(needsConversion)) ? this.fromEn(accountBalanceEv, valueScale) : accountBalanceEv;
        ((IDictionary<string,object>)account)["used"] = ((bool) isTrue(needsConversion)) ? this.fromEn(totalUsedBalanceEv, valueScale) : totalUsedBalanceEv;
        ((IDictionary<string,object>)result)[(string)code] = account;
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://phemex-docs.github.io/#query-wallets
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#query-account-positions
        * @see https://phemex-docs.github.io/#query-trading-account-and-positions
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.type] spot or swap
        * @param {string} [params.code] *swap only* currency code of the balance to query (USD, USDT, etc), default is USDT
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object code = this.safeString(parameters, "code");
        parameters = this.omit(parameters, new List<object>() {"code"});
        object response = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(isTrue((!isEqual(type, "spot"))) && isTrue((!isEqual(type, "swap")))))
        {
            throw new BadRequest ((string)add(add(add(this.id, " does not support "), type), " markets, only spot and swap")) ;
        }
        if (isTrue(isEqual(type, "swap")))
        {
            object settle = null;
            var settleparametersVariable = this.handleOptionAndParams(parameters, "fetchBalance", "settle", "USDT");
            settle = ((IList<object>)settleparametersVariable)[0];
            parameters = ((IList<object>)settleparametersVariable)[1];
            if (isTrue(isTrue(!isEqual(code, null)) || isTrue(!isEqual(settle, null))))
            {
                object coin = null;
                if (isTrue(!isEqual(code, null)))
                {
                    coin = code;
                } else
                {
                    coin = settle;
                }
                object currency = this.currency(coin);
                ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
                if (isTrue(isEqual(getValue(currency, "id"), "USDT")))
                {
                    response = await this.privateGetGAccountsAccountPositions(this.extend(request, parameters));
                } else
                {
                    response = await this.privateGetAccountsAccountPositions(this.extend(request, parameters));
                }
            } else
            {
                object currency = this.safeString(parameters, "currency");
                if (isTrue(isEqual(currency, null)))
                {
                    throw new ArgumentsRequired ((string)add(add(add(this.id, " fetchBalance() requires a code parameter or a currency or settle parameter for "), type), " type")) ;
                }
                response = await this.privateGetSpotWallets(this.extend(request, parameters));
            }
        } else
        {
            response = await this.privateGetSpotWallets(this.extend(request, parameters));
        }
        //
        // usdt
        //   {
        //       "info": {
        //         "code": "0",
        //         "msg": '',
        //         "data": {
        //           "account": {
        //             "userID": "940666",
        //             "accountId": "9406660003",
        //             "currency": "USDT",
        //             "accountBalanceRv": "99.93143972",
        //             "totalUsedBalanceRv": "0.40456",
        //             "bonusBalanceRv": "0"
        //           },
        //   }
        //
        // spot
        //
        //     {
        //         "code":0,
        //         "msg":"",
        //         "data":[
        //             {
        //                 "currency":"USDT",
        //                 "balanceEv":0,
        //                 "lockedTradingBalanceEv":0,
        //                 "lockedWithdrawEv":0,
        //                 "lastUpdateTimeNs":1592065834511322514,
        //                 "walletVid":0
        //             },
        //             {
        //                 "currency":"ETH",
        //                 "balanceEv":0,
        //                 "lockedTradingBalanceEv":0,
        //                 "lockedWithdrawEv":0,
        //                 "lastUpdateTimeNs":1592065834511322514,
        //                 "walletVid":0
        //             }
        //         ]
        //     }
        //
        // swap
        //
        //     {
        //         "code":0,
        //         "msg":"",
        //         "data":{
        //             "account":{
        //                 "accountId":6192120001,
        //                 "currency":"BTC",
        //                 "accountBalanceEv":1254744,
        //                 "totalUsedBalanceEv":0,
        //                 "bonusBalanceEv":1254744
        //             },
        //             "positions":[
        //                 {
        //                     "accountID":6192120001,
        //                     "symbol":"BTCUSD",
        //                     "currency":"BTC",
        //                     "side":"None",
        //                     "positionStatus":"Normal",
        //                     "crossMargin":false,
        //                     "leverageEr":0,
        //                     "leverage":0E-8,
        //                     "initMarginReqEr":1000000,
        //                     "initMarginReq":0.01000000,
        //                     "maintMarginReqEr":500000,
        //                     "maintMarginReq":0.00500000,
        //                     "riskLimitEv":10000000000,
        //                     "riskLimit":100.00000000,
        //                     "size":0,
        //                     "value":0E-8,
        //                     "valueEv":0,
        //                     "avgEntryPriceEp":0,
        //                     "avgEntryPrice":0E-8,
        //                     "posCostEv":0,
        //                     "posCost":0E-8,
        //                     "assignedPosBalanceEv":0,
        //                     "assignedPosBalance":0E-8,
        //                     "bankruptCommEv":0,
        //                     "bankruptComm":0E-8,
        //                     "bankruptPriceEp":0,
        //                     "bankruptPrice":0E-8,
        //                     "positionMarginEv":0,
        //                     "positionMargin":0E-8,
        //                     "liquidationPriceEp":0,
        //                     "liquidationPrice":0E-8,
        //                     "deleveragePercentileEr":0,
        //                     "deleveragePercentile":0E-8,
        //                     "buyValueToCostEr":1150750,
        //                     "buyValueToCost":0.01150750,
        //                     "sellValueToCostEr":1149250,
        //                     "sellValueToCost":0.01149250,
        //                     "markPriceEp":96359083,
        //                     "markPrice":9635.90830000,
        //                     "markValueEv":0,
        //                     "markValue":null,
        //                     "unRealisedPosLossEv":0,
        //                     "unRealisedPosLoss":null,
        //                     "estimatedOrdLossEv":0,
        //                     "estimatedOrdLoss":0E-8,
        //                     "usedBalanceEv":0,
        //                     "usedBalance":0E-8,
        //                     "takeProfitEp":0,
        //                     "takeProfit":null,
        //                     "stopLossEp":0,
        //                     "stopLoss":null,
        //                     "realisedPnlEv":0,
        //                     "realisedPnl":null,
        //                     "cumRealisedPnlEv":0,
        //                     "cumRealisedPnl":null
        //                 }
        //             ]
        //         }
        //     }
        //
        object result = ((bool) isTrue((isEqual(type, "swap")))) ? this.parseSwapBalance(response) : this.parseSpotBalance(response);
        return result;
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "Created", "open" },
            { "Untriggered", "open" },
            { "Deactivated", "closed" },
            { "Triggered", "open" },
            { "Rejected", "rejected" },
            { "New", "open" },
            { "PartiallyFilled", "open" },
            { "Filled", "closed" },
            { "Canceled", "canceled" },
            { "1", "open" },
            { "2", "canceled" },
            { "3", "closed" },
            { "4", "canceled" },
            { "5", "open" },
            { "6", "open" },
            { "7", "closed" },
            { "8", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "1", "market" },
            { "2", "limit" },
            { "3", "stop" },
            { "4", "stopLimit" },
            { "5", "market" },
            { "6", "limit" },
            { "7", "market" },
            { "8", "market" },
            { "9", "stopLimit" },
            { "10", "market" },
            { "Limit", "limit" },
            { "Market", "market" },
        };
        return this.safeString(types, type, type);
    }

    public virtual object parseTimeInForce(object timeInForce)
    {
        object timeInForces = new Dictionary<string, object>() {
            { "GoodTillCancel", "GTC" },
            { "PostOnly", "PO" },
            { "ImmediateOrCancel", "IOC" },
            { "FillOrKill", "FOK" },
        };
        return this.safeString(timeInForces, timeInForce, timeInForce);
    }

    public virtual object parseSpotOrder(object order, object market = null)
    {
        //
        // spot
        //
        //     {
        //         "orderID": "d1d09454-cabc-4a23-89a7-59d43363f16d",
        //         "clOrdID": "309bcd5c-9f6e-4a68-b775-4494542eb5cb",
        //         "priceEp": 0,
        //         "action": "New",
        //         "trigger": "UNSPECIFIED",
        //         "pegPriceType": "UNSPECIFIED",
        //         "stopDirection": "UNSPECIFIED",
        //         "bizError": 0,
        //         "symbol": "sBTCUSDT",
        //         "side": "Buy",
        //         "baseQtyEv": 0,
        //         "ordType": "Limit",
        //         "timeInForce": "GoodTillCancel",
        //         "ordStatus": "Created",
        //         "cumFeeEv": 0,
        //         "cumBaseQtyEv": 0,
        //         "cumQuoteQtyEv": 0,
        //         "leavesBaseQtyEv": 0,
        //         "leavesQuoteQtyEv": 0,
        //         "avgPriceEp": 0,
        //         "cumBaseAmountEv": 0,
        //         "cumQuoteAmountEv": 0,
        //         "quoteQtyEv": 0,
        //         "qtyType": "ByBase",
        //         "stopPxEp": 0,
        //         "pegOffsetValueEp": 0
        //     }
        //
        //     {
        //         "orderID":"99232c3e-3d6a-455f-98cc-2061cdfe91bc",
        //         "stopPxEp":0,
        //         "avgPriceEp":0,
        //         "qtyType":"ByBase",
        //         "leavesBaseQtyEv":0,
        //         "leavesQuoteQtyEv":0,
        //         "baseQtyEv":"1000000000",
        //         "feeCurrency":"4",
        //         "stopDirection":"UNSPECIFIED",
        //         "symbol":"sETHUSDT",
        //         "side":"Buy",
        //         "quoteQtyEv":250000000000,
        //         "priceEp":25000000000,
        //         "ordType":"Limit",
        //         "timeInForce":"GoodTillCancel",
        //         "ordStatus":"Rejected",
        //         "execStatus":"NewRejected",
        //         "createTimeNs":1592675305266037130,
        //         "cumFeeEv":0,
        //         "cumBaseValueEv":0,
        //         "cumQuoteValueEv":0
        //     }
        //
        object id = this.safeString(order, "orderID");
        object clientOrderId = this.safeString(order, "clOrdID");
        if (isTrue(isTrue((!isEqual(clientOrderId, null))) && isTrue((isLessThan(((string)clientOrderId).Length, 1)))))
        {
            clientOrderId = null;
        }
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object price = this.fromEp(this.safeString(order, "priceEp"), market);
        object amount = this.fromEv(this.safeString(order, "baseQtyEv"), market);
        object remaining = this.omitZero(this.fromEv(this.safeString(order, "leavesBaseQtyEv"), market));
        object filled = this.fromEv(this.safeString2(order, "cumBaseQtyEv", "cumBaseValueEv"), market);
        object cost = this.fromEr(this.safeString2(order, "cumQuoteValueEv", "quoteQtyEv"), market);
        object average = this.fromEp(this.safeString(order, "avgPriceEp"), market);
        object status = this.parseOrderStatus(this.safeString(order, "ordStatus"));
        object side = this.safeStringLower(order, "side");
        object type = this.parseOrderType(this.safeString(order, "ordType"));
        object timestamp = this.safeIntegerProduct2(order, "actionTimeNs", "createTimeNs", 0.000001);
        object fee = null;
        object feeCost = this.fromEv(this.safeString(order, "cumFeeEv"), market);
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", null },
            };
        }
        object timeInForce = this.parseTimeInForce(this.safeString(order, "timeInForce"));
        object stopPrice = this.parseNumber(this.omitZero(this.fromEp(this.safeString(order, "stopPxEp"))));
        object postOnly = (isEqual(timeInForce, "PO"));
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "amount", amount },
            { "cost", cost },
            { "average", average },
            { "filled", filled },
            { "remaining", remaining },
            { "status", status },
            { "fee", fee },
            { "trades", null },
        }, market);
    }

    public virtual object parseOrderSide(object side)
    {
        object sides = new Dictionary<string, object>() {
            { "1", "buy" },
            { "2", "sell" },
        };
        return this.safeString(sides, side, side);
    }

    public virtual object parseSwapOrder(object order, object market = null)
    {
        //
        //     {
        //         "bizError":0,
        //         "orderID":"7a1ad384-44a3-4e54-a102-de4195a29e32",
        //         "clOrdID":"",
        //         "symbol":"ETHUSD",
        //         "side":"Buy",
        //         "actionTimeNs":1592668973945065381,
        //         "transactTimeNs":0,
        //         "orderType":"Market",
        //         "priceEp":2267500,
        //         "price":226.75000000,
        //         "orderQty":1,
        //         "displayQty":0,
        //         "timeInForce":"ImmediateOrCancel",
        //         "reduceOnly":false,
        //         "closedPnlEv":0,
        //         "closedPnl":0E-8,
        //         "closedSize":0,
        //         "cumQty":0,
        //         "cumValueEv":0,
        //         "cumValue":0E-8,
        //         "leavesQty":1,
        //         "leavesValueEv":11337,
        //         "leavesValue":1.13370000,
        //         "stopDirection":"UNSPECIFIED",
        //         "stopPxEp":0,
        //         "stopPx":0E-8,
        //         "trigger":"UNSPECIFIED",
        //         "pegOffsetValueEp":0,
        //         "execStatus":"PendingNew",
        //         "pegPriceType":"UNSPECIFIED",
        //         "ordStatus":"Created",
        //         "execInst": "ReduceOnly"
        //     }
        //
        // usdt
        // {
        //        "bizError":"0",
        //        "orderID":"bd720dff-5647-4596-aa4e-656bac87aaad",
        //        "clOrdID":"ccxt2022843dffac9477b497",
        //        "symbol":"LTCUSDT",
        //        "side":"Buy",
        //        "actionTimeNs":"1677667878751724052",
        //        "transactTimeNs":"1677667878754017434",
        //        "orderType":"Limit",
        //        "priceRp":"40",
        //        "orderQtyRq":"0.1",
        //        "displayQtyRq":"0.1",
        //        "timeInForce":"GoodTillCancel",
        //        "reduceOnly":false,
        //        "closedPnlRv":"0",
        //        "closedSizeRq":"0",
        //        "cumQtyRq":"0",
        //        "cumValueRv":"0",
        //        "leavesQtyRq":"0.1",
        //        "leavesValueRv":"4",
        //        "stopDirection":"UNSPECIFIED",
        //        "stopPxRp":"0",
        //        "trigger":"UNSPECIFIED",
        //        "pegOffsetValueRp":"0",
        //        "pegOffsetProportionRr":"0",
        //        "execStatus":"New",
        //        "pegPriceType":"UNSPECIFIED",
        //        "ordStatus":"New",
        //        "execInst":"None",
        //        "takeProfitRp":"0",
        //        "stopLossRp":"0"
        //     }
        //
        // v2 orderList
        //    {
        //        "createdAt":"1677686231301",
        //        "symbol":"LTCUSDT",
        //        "orderQtyRq":"0.2",
        //        "side":"1",
        //        "posSide":"3",
        //        "priceRp":"50",
        //        "execQtyRq":"0",
        //        "leavesQtyRq":"0.2",
        //        "execPriceRp":"0",
        //        "orderValueRv":"10",
        //        "leavesValueRv":"10",
        //        "cumValueRv":"0",
        //        "stopDirection":"0",
        //        "stopPxRp":"0",
        //        "trigger":"0",
        //        "actionBy":"1",
        //        "execFeeRv":"0",
        //        "ordType":"2",
        //        "ordStatus":"5",
        //        "clOrdId":"4b3b188",
        //        "orderId":"4b3b1884-87cf-4897-b596-6693b7ed84d1",
        //        "execStatus":"5",
        //        "bizError":"0",
        //        "totalPnlRv":null,
        //        "avgTransactPriceRp":null,
        //        "orderDetailsVos":null,
        //        "tradeType":"0"
        //    }
        //
        object id = this.safeString2(order, "orderID", "orderId");
        object clientOrderId = this.safeString2(order, "clOrdID", "clOrdId");
        if (isTrue(isTrue((!isEqual(clientOrderId, null))) && isTrue((isLessThan(((string)clientOrderId).Length, 1)))))
        {
            clientOrderId = null;
        }
        object marketId = this.safeString(order, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object status = this.parseOrderStatus(this.safeString(order, "ordStatus"));
        object side = this.parseOrderSide(this.safeStringLower(order, "side"));
        object type = this.parseOrderType(this.safeString(order, "orderType"));
        object price = this.safeString(order, "priceRp");
        if (isTrue(isEqual(price, null)))
        {
            price = this.fromEp(this.safeString(order, "priceEp"), market);
        }
        object amount = this.safeNumber2(order, "orderQty", "orderQtyRq");
        object filled = this.safeNumber2(order, "cumQty", "cumQtyRq");
        object remaining = this.safeNumber2(order, "leavesQty", "leavesQtyRq");
        object timestamp = this.safeIntegerProduct(order, "actionTimeNs", 0.000001);
        if (isTrue(isEqual(timestamp, null)))
        {
            timestamp = this.safeInteger(order, "createdAt");
        }
        object cost = this.safeNumber2(order, "cumValue", "cumValueRv");
        object lastTradeTimestamp = this.safeIntegerProduct(order, "transactTimeNs", 0.000001);
        if (isTrue(isEqual(lastTradeTimestamp, 0)))
        {
            lastTradeTimestamp = null;
        }
        object timeInForce = this.parseTimeInForce(this.safeString(order, "timeInForce"));
        object stopPrice = this.omitZero(this.safeString2(order, "stopPx", "stopPxRp"));
        object postOnly = (isEqual(timeInForce, "PO"));
        object reduceOnly = this.safeValue(order, "reduceOnly");
        object execInst = this.safeString(order, "execInst");
        if (isTrue(isEqual(execInst, "ReduceOnly")))
        {
            reduceOnly = true;
        }
        object takeProfit = this.safeString(order, "takeProfitRp");
        object stopLoss = this.safeString(order, "stopLossRp");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "datetime", this.iso8601(timestamp) },
            { "timestamp", timestamp },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "reduceOnly", reduceOnly },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "takeProfitPrice", takeProfit },
            { "stopLossPrice", stopLoss },
            { "amount", amount },
            { "filled", filled },
            { "remaining", remaining },
            { "cost", cost },
            { "average", null },
            { "status", status },
            { "fee", null },
            { "trades", null },
        });
    }

    public override object parseOrder(object order, object market = null)
    {
        object isSwap = this.safeBool(market, "swap", false);
        object hasPnl = isTrue(isTrue((inOp(order, "closedPnl"))) || isTrue((inOp(order, "closedPnlRv")))) || isTrue((inOp(order, "totalPnlRv")));
        if (isTrue(isTrue(isSwap) || isTrue(hasPnl)))
        {
            return this.parseSwapOrder(order, market);
        }
        return this.parseSpotOrder(order, market);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#createOrder
        * @description create a trade order
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#place-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {object} [params.takeProfit] *swap only* *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
        * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
        * @param {object} [params.stopLoss] *swap only* *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
        * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object requestSide = this.capitalize(side);
        type = this.capitalize(type);
        object reduceOnly = this.safeValue(parameters, "reduceOnly");
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", requestSide },
            { "ordType", type },
        };
        object clientOrderId = this.safeString2(parameters, "clOrdID", "clientOrderId");
        object stopLoss = this.safeValue(parameters, "stopLoss");
        object stopLossDefined = (!isEqual(stopLoss, null));
        object takeProfit = this.safeValue(parameters, "takeProfit");
        object takeProfitDefined = (!isEqual(takeProfit, null));
        if (isTrue(isEqual(clientOrderId, null)))
        {
            object brokerId = this.safeString(this.options, "brokerId", "CCXT123456");
            if (isTrue(!isEqual(brokerId, null)))
            {
                ((IDictionary<string,object>)request)["clOrdID"] = add(brokerId, this.uuid16());
            }
        } else
        {
            ((IDictionary<string,object>)request)["clOrdID"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId"});
        }
        object stopPrice = this.safeStringN(parameters, new List<object>() {"stopPx", "stopPrice", "triggerPrice"});
        if (isTrue(!isEqual(stopPrice, null)))
        {
            if (isTrue(isEqual(getValue(market, "settle"), "USDT")))
            {
                ((IDictionary<string,object>)request)["stopPxRp"] = this.priceToPrecision(symbol, stopPrice);
            } else
            {
                ((IDictionary<string,object>)request)["stopPxEp"] = this.toEp(stopPrice, market);
            }
        }
        parameters = this.omit(parameters, new List<object>() {"stopPx", "stopPrice", "stopLoss", "takeProfit", "triggerPrice"});
        if (isTrue(getValue(market, "spot")))
        {
            object qtyType = this.safeValue(parameters, "qtyType", "ByBase");
            if (isTrue(isTrue(isTrue((isEqual(type, "Market"))) || isTrue((isEqual(type, "Stop")))) || isTrue((isEqual(type, "MarketIfTouched")))))
            {
                if (isTrue(!isEqual(price, null)))
                {
                    qtyType = "ByQuote";
                }
            }
            ((IDictionary<string,object>)request)["qtyType"] = qtyType;
            if (isTrue(isEqual(qtyType, "ByQuote")))
            {
                object cost = this.safeNumber(parameters, "cost");
                parameters = this.omit(parameters, "cost");
                if (isTrue(getValue(this.options, "createOrderByQuoteRequiresPrice")))
                {
                    if (isTrue(!isEqual(price, null)))
                    {
                        object amountString = this.numberToString(amount);
                        object priceString = this.numberToString(price);
                        object quoteAmount = Precise.stringMul(amountString, priceString);
                        cost = this.parseNumber(quoteAmount);
                    } else if (isTrue(isEqual(cost, null)))
                    {
                        throw new ArgumentsRequired ((string)add(add(add(this.id, " createOrder() "), qtyType), " requires a price argument or a cost parameter")) ;
                    }
                }
                cost = ((bool) isTrue((isEqual(cost, null)))) ? amount : cost;
                object costString = this.numberToString(cost);
                ((IDictionary<string,object>)request)["quoteQtyEv"] = this.toEv(costString, market);
            } else
            {
                object amountString = this.numberToString(amount);
                ((IDictionary<string,object>)request)["baseQtyEv"] = this.toEv(amountString, market);
            }
        } else if (isTrue(getValue(market, "swap")))
        {
            object posSide = this.safeStringLower(parameters, "posSide");
            if (isTrue(isEqual(posSide, null)))
            {
                posSide = "Merged";
            }
            posSide = this.capitalize(posSide);
            ((IDictionary<string,object>)request)["posSide"] = posSide;
            if (isTrue(!isEqual(reduceOnly, null)))
            {
                ((IDictionary<string,object>)request)["reduceOnly"] = reduceOnly;
            }
            if (isTrue(isEqual(getValue(market, "settle"), "USDT")))
            {
                ((IDictionary<string,object>)request)["orderQtyRq"] = amount;
            } else
            {
                ((IDictionary<string,object>)request)["orderQty"] = this.parseToInt(amount);
            }
            if (isTrue(!isEqual(stopPrice, null)))
            {
                object triggerType = this.safeString(parameters, "triggerType", "ByMarkPrice");
                ((IDictionary<string,object>)request)["triggerType"] = triggerType;
            }
            if (isTrue(isTrue(stopLossDefined) || isTrue(takeProfitDefined)))
            {
                if (isTrue(stopLossDefined))
                {
                    object stopLossTriggerPrice = this.safeValue2(stopLoss, "triggerPrice", "stopPrice");
                    if (isTrue(isEqual(stopLossTriggerPrice, null)))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() requires a trigger price in params[\"stopLoss\"][\"triggerPrice\"], or params[\"stopLoss\"][\"stopPrice\"] for a stop loss order")) ;
                    }
                    if (isTrue(isEqual(getValue(market, "settle"), "USDT")))
                    {
                        ((IDictionary<string,object>)request)["stopLossRp"] = this.priceToPrecision(symbol, stopLossTriggerPrice);
                    } else
                    {
                        ((IDictionary<string,object>)request)["stopLossEp"] = this.toEp(stopLossTriggerPrice, market);
                    }
                    object stopLossTriggerPriceType = this.safeString2(stopLoss, "triggerPriceType", "slTrigger");
                    if (isTrue(!isEqual(stopLossTriggerPriceType, null)))
                    {
                        if (isTrue(isEqual(getValue(market, "settle"), "USDT")))
                        {
                            if (isTrue(isTrue(isTrue(isTrue(isTrue(isTrue(isTrue((!isEqual(stopLossTriggerPriceType, "ByMarkPrice"))) && isTrue((!isEqual(stopLossTriggerPriceType, "ByLastPrice")))) && isTrue((!isEqual(stopLossTriggerPriceType, "ByIndexPrice")))) && isTrue((!isEqual(stopLossTriggerPriceType, "ByAskPrice")))) && isTrue((!isEqual(stopLossTriggerPriceType, "ByBidPrice")))) && isTrue((!isEqual(stopLossTriggerPriceType, "ByMarkPriceLimit")))) && isTrue((!isEqual(stopLossTriggerPriceType, "ByLastPriceLimit")))))
                            {
                                throw new InvalidOrder ((string)add(this.id, " createOrder() take profit trigger price type must be one of \"ByMarkPrice\", \"ByIndexPrice\", \"ByAskPrice\", \"ByBidPrice\", \"ByMarkPriceLimit\", \"ByLastPriceLimit\" or \"ByLastPrice\"")) ;
                            }
                        } else
                        {
                            if (isTrue(isTrue((!isEqual(stopLossTriggerPriceType, "ByMarkPrice"))) && isTrue((!isEqual(stopLossTriggerPriceType, "ByLastPrice")))))
                            {
                                throw new InvalidOrder ((string)add(this.id, " createOrder() take profit trigger price type must be one of \"ByMarkPrice\", or \"ByLastPrice\"")) ;
                            }
                        }
                        ((IDictionary<string,object>)request)["slTrigger"] = stopLossTriggerPriceType;
                    }
                }
                if (isTrue(takeProfitDefined))
                {
                    object takeProfitTriggerPrice = this.safeValue2(takeProfit, "triggerPrice", "stopPrice");
                    if (isTrue(isEqual(takeProfitTriggerPrice, null)))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() requires a trigger price in params[\"takeProfit\"][\"triggerPrice\"], or params[\"takeProfit\"][\"stopPrice\"] for a take profit order")) ;
                    }
                    if (isTrue(isEqual(getValue(market, "settle"), "USDT")))
                    {
                        ((IDictionary<string,object>)request)["takeProfitRp"] = this.priceToPrecision(symbol, takeProfitTriggerPrice);
                    } else
                    {
                        ((IDictionary<string,object>)request)["takeProfitEp"] = this.toEp(takeProfitTriggerPrice, market);
                    }
                    object takeProfitTriggerPriceType = this.safeString2(stopLoss, "triggerPriceType", "tpTrigger");
                    if (isTrue(!isEqual(takeProfitTriggerPriceType, null)))
                    {
                        if (isTrue(isEqual(getValue(market, "settle"), "USDT")))
                        {
                            if (isTrue(isTrue(isTrue(isTrue(isTrue(isTrue(isTrue((!isEqual(takeProfitTriggerPriceType, "ByMarkPrice"))) && isTrue((!isEqual(takeProfitTriggerPriceType, "ByLastPrice")))) && isTrue((!isEqual(takeProfitTriggerPriceType, "ByIndexPrice")))) && isTrue((!isEqual(takeProfitTriggerPriceType, "ByAskPrice")))) && isTrue((!isEqual(takeProfitTriggerPriceType, "ByBidPrice")))) && isTrue((!isEqual(takeProfitTriggerPriceType, "ByMarkPriceLimit")))) && isTrue((!isEqual(takeProfitTriggerPriceType, "ByLastPriceLimit")))))
                            {
                                throw new InvalidOrder ((string)add(this.id, " createOrder() take profit trigger price type must be one of \"ByMarkPrice\", \"ByIndexPrice\", \"ByAskPrice\", \"ByBidPrice\", \"ByMarkPriceLimit\", \"ByLastPriceLimit\" or \"ByLastPrice\"")) ;
                            }
                        } else
                        {
                            if (isTrue(isTrue((!isEqual(takeProfitTriggerPriceType, "ByMarkPrice"))) && isTrue((!isEqual(takeProfitTriggerPriceType, "ByLastPrice")))))
                            {
                                throw new InvalidOrder ((string)add(this.id, " createOrder() take profit trigger price type must be one of \"ByMarkPrice\", or \"ByLastPrice\"")) ;
                            }
                        }
                        ((IDictionary<string,object>)request)["tpTrigger"] = takeProfitTriggerPriceType;
                    }
                }
            }
        }
        if (isTrue(isTrue(isTrue((isEqual(type, "Limit"))) || isTrue((isEqual(type, "StopLimit")))) || isTrue((isEqual(type, "LimitIfTouched")))))
        {
            if (isTrue(isEqual(getValue(market, "settle"), "USDT")))
            {
                ((IDictionary<string,object>)request)["priceRp"] = this.priceToPrecision(symbol, price);
            } else
            {
                object priceString = this.numberToString(price);
                ((IDictionary<string,object>)request)["priceEp"] = this.toEp(priceString, market);
            }
        }
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        if (isTrue(!isEqual(takeProfitPrice, null)))
        {
            if (isTrue(isEqual(getValue(market, "settle"), "USDT")))
            {
                ((IDictionary<string,object>)request)["takeProfitRp"] = this.priceToPrecision(symbol, takeProfitPrice);
            } else
            {
                ((IDictionary<string,object>)request)["takeProfitEp"] = this.toEp(takeProfitPrice, market);
            }
            parameters = this.omit(parameters, "takeProfitPrice");
        }
        object stopLossPrice = this.safeString(parameters, "stopLossPrice");
        if (isTrue(!isEqual(stopLossPrice, null)))
        {
            if (isTrue(isEqual(getValue(market, "settle"), "USDT")))
            {
                ((IDictionary<string,object>)request)["stopLossRp"] = this.priceToPrecision(symbol, stopLossPrice);
            } else
            {
                ((IDictionary<string,object>)request)["stopLossEp"] = this.toEp(stopLossPrice, market);
            }
            parameters = this.omit(parameters, "stopLossPrice");
        }
        parameters = this.omit(parameters, "reduceOnly");
        object response = null;
        if (isTrue(isEqual(getValue(market, "settle"), "USDT")))
        {
            response = await this.privatePostGOrders(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "contract")))
        {
            response = await this.privatePostOrders(this.extend(request, parameters));
        } else
        {
            response = await this.privatePostSpotOrders(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": {
        //             "orderID": "d1d09454-cabc-4a23-89a7-59d43363f16d",
        //             "clOrdID": "309bcd5c-9f6e-4a68-b775-4494542eb5cb",
        //             "priceEp": 0,
        //             "action": "New",
        //             "trigger": "UNSPECIFIED",
        //             "pegPriceType": "UNSPECIFIED",
        //             "stopDirection": "UNSPECIFIED",
        //             "bizError": 0,
        //             "symbol": "sBTCUSDT",
        //             "side": "Buy",
        //             "baseQtyEv": 0,
        //             "ordType": "Limit",
        //             "timeInForce": "GoodTillCancel",
        //             "ordStatus": "Created",
        //             "cumFeeEv": 0,
        //             "cumBaseQtyEv": 0,
        //             "cumQuoteQtyEv": 0,
        //             "leavesBaseQtyEv": 0,
        //             "leavesQuoteQtyEv": 0,
        //             "avgPriceEp": 0,
        //             "cumBaseAmountEv": 0,
        //             "cumQuoteAmountEv": 0,
        //             "quoteQtyEv": 0,
        //             "qtyType": "ByBase",
        //             "stopPxEp": 0,
        //             "pegOffsetValueEp": 0
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         "code":0,
        //         "msg":"",
        //         "data":{
        //             "bizError":0,
        //             "orderID":"7a1ad384-44a3-4e54-a102-de4195a29e32",
        //             "clOrdID":"",
        //             "symbol":"ETHUSD",
        //             "side":"Buy",
        //             "actionTimeNs":1592668973945065381,
        //             "transactTimeNs":0,
        //             "orderType":"Market",
        //             "priceEp":2267500,
        //             "price":226.75000000,
        //             "orderQty":1,
        //             "displayQty":0,
        //             "timeInForce":"ImmediateOrCancel",
        //             "reduceOnly":false,
        //             "closedPnlEv":0,
        //             "closedPnl":0E-8,
        //             "closedSize":0,
        //             "cumQty":0,
        //             "cumValueEv":0,
        //             "cumValue":0E-8,
        //             "leavesQty":1,
        //             "leavesValueEv":11337,
        //             "leavesValue":1.13370000,
        //             "stopDirection":"UNSPECIFIED",
        //             "stopPxEp":0,
        //             "stopPx":0E-8,
        //             "trigger":"UNSPECIFIED",
        //             "pegOffsetValueEp":0,
        //             "execStatus":"PendingNew",
        //             "pegPriceType":"UNSPECIFIED",
        //             "ordStatus":"Created"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> editOrder(object id, object symbol, object type = null, object side = null, object amount = null, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#editOrder
        * @description edit a trade order
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#amend-order-by-orderid
        * @param {string} id cancel order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the base currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.posSide] either 'Merged' or 'Long' or 'Short'
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "clOrdID");
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "clOrdID"});
        object isUSDTSettled = (isEqual(getValue(market, "settle"), "USDT"));
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clOrdID"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["orderID"] = id;
        }
        if (isTrue(!isEqual(price, null)))
        {
            if (isTrue(isUSDTSettled))
            {
                ((IDictionary<string,object>)request)["priceRp"] = this.priceToPrecision(getValue(market, "symbol"), price);
            } else
            {
                ((IDictionary<string,object>)request)["priceEp"] = this.toEp(price, market);
            }
        }
        // Note the uppercase 'V' in 'baseQtyEV' request. that is exchange's requirement at this moment. However, to avoid mistakes from user side, let's support lowercased 'baseQtyEv' too
        object finalQty = this.safeString(parameters, "baseQtyEv");
        parameters = this.omit(parameters, new List<object>() {"baseQtyEv"});
        if (isTrue(!isEqual(finalQty, null)))
        {
            ((IDictionary<string,object>)request)["baseQtyEV"] = finalQty;
        } else if (isTrue(!isEqual(amount, null)))
        {
            if (isTrue(isUSDTSettled))
            {
                ((IDictionary<string,object>)request)["orderQtyRq"] = this.amountToPrecision(getValue(market, "symbol"), amount);
            } else
            {
                ((IDictionary<string,object>)request)["baseQtyEV"] = this.toEv(amount, market);
            }
        }
        object stopPrice = this.safeString2(parameters, "stopPx", "stopPrice");
        if (isTrue(!isEqual(stopPrice, null)))
        {
            if (isTrue(isUSDTSettled))
            {
                ((IDictionary<string,object>)request)["stopPxRp"] = this.priceToPrecision(symbol, stopPrice);
            } else
            {
                ((IDictionary<string,object>)request)["stopPxEp"] = this.toEp(stopPrice, market);
            }
        }
        parameters = this.omit(parameters, new List<object>() {"stopPx", "stopPrice"});
        object response = null;
        if (isTrue(isUSDTSettled))
        {
            object posSide = this.safeString(parameters, "posSide");
            if (isTrue(isEqual(posSide, null)))
            {
                ((IDictionary<string,object>)request)["posSide"] = "Merged";
            }
            response = await this.privatePutGOrdersReplace(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "swap")))
        {
            response = await this.privatePutOrdersReplace(this.extend(request, parameters));
        } else
        {
            response = await this.privatePutSpotOrders(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#cancelOrder
        * @description cancels an open order
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#cancel-single-order-by-orderid
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.posSide] either 'Merged' or 'Long' or 'Short'
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "clOrdID");
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "clOrdID"});
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clOrdID"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["orderID"] = id;
        }
        object response = null;
        if (isTrue(isEqual(getValue(market, "settle"), "USDT")))
        {
            object posSide = this.safeString(parameters, "posSide");
            if (isTrue(isEqual(posSide, null)))
            {
                ((IDictionary<string,object>)request)["posSide"] = "Merged";
            }
            response = await this.privateDeleteGOrdersCancel(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "swap")))
        {
            response = await this.privateDeleteOrdersCancel(this.extend(request, parameters));
        } else
        {
            response = await this.privateDeleteSpotOrders(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#cancelAllOrders
        * @description cancel all open orders in a market
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#cancelall
        * @param {string} symbol unified market symbol of the market to cancel orders in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object stop = this.safeValue2(parameters, "stop", "trigger", false);
        parameters = this.omit(parameters, "stop", "trigger");
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(stop))
        {
            ((IDictionary<string,object>)request)["untriggerred"] = stop;
        }
        object response = null;
        if (isTrue(isEqual(getValue(market, "settle"), "USDT")))
        {
            response = await this.privateDeleteGOrdersAll(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "swap")))
        {
            response = await this.privateDeleteOrdersAll(this.extend(request, parameters));
        } else
        {
            response = await this.privateDeleteSpotOrdersAll(this.extend(request, parameters));
        }
        return response;
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchOrder
        * @description fetches information on an order made by the user
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(isEqual(getValue(market, "settle"), "USDT")))
        {
            throw new NotSupported ((string)add(this.id, "fetchOrder() is not supported yet for USDT settled swap markets")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "clOrdID");
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "clOrdID"});
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clOrdID"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["orderID"] = id;
        }
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.privateGetSpotOrdersActive(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetExchangeOrder(this.extend(request, parameters));
        }
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object order = data;
        if (isTrue(((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            object numOrders = getArrayLength(data);
            if (isTrue(isLessThan(numOrders, 1)))
            {
                if (isTrue(!isEqual(clientOrderId, null)))
                {
                    throw new OrderNotFound ((string)add(add(add(add(add(this.id, " fetchOrder() "), symbol), " order with clientOrderId "), clientOrderId), " not found")) ;
                } else
                {
                    throw new OrderNotFound ((string)add(add(add(add(add(this.id, " fetchOrder() "), symbol), " order with id "), id), " not found")) ;
                }
            }
            order = this.safeValue(data, 0, new Dictionary<string, object>() {});
        }
        return this.parseOrder(order, market);
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchOrders
        * @description fetches information on multiple orders made by the user
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#queryorder
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(isEqual(getValue(market, "settle"), "USDT")))
        {
            ((IDictionary<string,object>)request)["currency"] = getValue(market, "settle");
            response = await this.privateGetExchangeOrderV2OrderList(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "swap")))
        {
            response = await this.privateGetExchangeOrderList(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetSpotOrders(this.extend(request, parameters));
        }
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeList(data, "rows", data);
        return this.parseOrders(rows, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#queryopenorder
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Contract-API-en.md
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Spot-API-en.md#spotListAllOpenOrder
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of open order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOpenOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        try
        {
            if (isTrue(isEqual(getValue(market, "settle"), "USDT")))
            {
                response = await this.privateGetGOrdersActiveList(this.extend(request, parameters));
            } else if (isTrue(getValue(market, "swap")))
            {
                response = await this.privateGetOrdersActiveList(this.extend(request, parameters));
            } else
            {
                response = await this.privateGetSpotOrders(this.extend(request, parameters));
            }
        } catch(Exception e)
        {
            if (isTrue(e is OrderNotFound))
            {
                return new List<object>() {};
            }
            throw e;
        }
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        if (isTrue(((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            return this.parseOrders(data, market, since, limit);
        } else
        {
            object rows = this.safeList(data, "rows", new List<object>() {});
            return this.parseOrders(rows, market, since, limit);
        }
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#queryorder
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Contract-API-en.md#queryorder
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedgedd-Perpetual-API.md#query-closed-orders-by-symbol
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Spot-API-en.md#spotDataOrdersByIds
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.settle] the settlement currency to fetch orders for
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(market, null)))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(isTrue((isEqual(symbol, null))) || isTrue((isEqual(this.safeString(market, "settle"), "USDT")))))
        {
            ((IDictionary<string,object>)request)["currency"] = this.safeString(parameters, "settle", "USDT");
            response = await this.privateGetExchangeOrderV2OrderList(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "swap")))
        {
            response = await this.privateGetExchangeOrderList(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetExchangeSpotOrder(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "code":0,
        //         "msg":"OK",
        //         "data":{
        //             "total":8,
        //             "rows":[
        //                 {
        //                     "orderID":"99232c3e-3d6a-455f-98cc-2061cdfe91bc",
        //                     "stopPxEp":0,
        //                     "avgPriceEp":0,
        //                     "qtyType":"ByBase",
        //                     "leavesBaseQtyEv":0,
        //                     "leavesQuoteQtyEv":0,
        //                     "baseQtyEv":"1000000000",
        //                     "feeCurrency":"4",
        //                     "stopDirection":"UNSPECIFIED",
        //                     "symbol":"sETHUSDT",
        //                     "side":"Buy",
        //                     "quoteQtyEv":250000000000,
        //                     "priceEp":25000000000,
        //                     "ordType":"Limit",
        //                     "timeInForce":"GoodTillCancel",
        //                     "ordStatus":"Rejected",
        //                     "execStatus":"NewRejected",
        //                     "createTimeNs":1592675305266037130,
        //                     "cumFeeEv":0,
        //                     "cumBaseValueEv":0,
        //                     "cumQuoteValueEv":0
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        if (isTrue(((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            return this.parseOrders(data, market, since, limit);
        } else
        {
            object rows = this.safeList(data, "rows", new List<object>() {});
            return this.parseOrders(rows, market, since, limit);
        }
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Contract-API-en.md#query-user-trade
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#query-user-trade
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Spot-API-en.md#spotDataTradesHist
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            limit = mathMin(200, limit);
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object isUSDTSettled = isTrue((isEqual(symbol, null))) || isTrue((isEqual(this.safeString(market, "settle"), "USDT")));
        if (isTrue(isUSDTSettled))
        {
            ((IDictionary<string,object>)request)["currency"] = "USDT";
            ((IDictionary<string,object>)request)["offset"] = 0;
            if (isTrue(isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = 200;
            }
        } else
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = since;
        }
        object response = null;
        if (isTrue(isUSDTSettled))
        {
            response = await this.privateGetExchangeOrderV2TradingList(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "swap")))
        {
            response = await this.privateGetExchangeOrderTrade(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetExchangeSpotOrderTrades(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "code": 0,
        //         "msg": "OK",
        //         "data": {
        //             "total": 1,
        //             "rows": [
        //                 {
        //                     "qtyType": "ByQuote",
        //                     "transactTimeNs": 1589450974800550100,
        //                     "clOrdID": "8ba59d40-df25-d4b0-14cf-0703f44e9690",
        //                     "orderID": "b2b7018d-f02f-4c59-b4cf-051b9c2d2e83",
        //                     "symbol": "sBTCUSDT",
        //                     "side": "Buy",
        //                     "priceEP": 970056000000,
        //                     "baseQtyEv": 0,
        //                     "quoteQtyEv": 1000000000,
        //                     "action": "New",
        //                     "execStatus": "MakerFill",
        //                     "ordStatus": "Filled",
        //                     "ordType": "Limit",
        //                     "execInst": "None",
        //                     "timeInForce": "GoodTillCancel",
        //                     "stopDirection": "UNSPECIFIED",
        //                     "tradeType": "Trade",
        //                     "stopPxEp": 0,
        //                     "execId": "c6bd8979-07ba-5946-b07e-f8b65135dbb1",
        //                     "execPriceEp": 970056000000,
        //                     "execBaseQtyEv": 103000,
        //                     "execQuoteQtyEv": 999157680,
        //                     "leavesBaseQtyEv": 0,
        //                     "leavesQuoteQtyEv": 0,
        //                     "execFeeEv": 0,
        //                     "feeRateEr": 0
        //                 }
        //             ]
        //         }
        //     }
        //
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "msg": "OK",
        //         "data": {
        //             "total": 79,
        //             "rows": [
        //                 {
        //                     "transactTimeNs": 1606054879331565300,
        //                     "symbol": "BTCUSD",
        //                     "currency": "BTC",
        //                     "action": "New",
        //                     "side": "Buy",
        //                     "tradeType": "Trade",
        //                     "execQty": 5,
        //                     "execPriceEp": 182990000,
        //                     "orderQty": 5,
        //                     "priceEp": 183870000,
        //                     "execValueEv": 27323,
        //                     "feeRateEr": 75000,
        //                     "execFeeEv": 21,
        //                     "ordType": "Market",
        //                     "execID": "5eee56a4-04a9-5677-8eb0-c2fe22ae3645",
        //                     "orderID": "ee0acb82-f712-4543-a11d-d23efca73197",
        //                     "clOrdID": "",
        //                     "execStatus": "TakerFill"
        //                 },
        //             ]
        //         }
        //     }
        //
        // swap - usdt
        //
        // {
        //     "code": 0,
        //     "msg": "OK",
        //     "data": {
        //         "total": 4,
        //         "rows": [
        //             {
        //                 "createdAt": 1666226932259,
        //                 "symbol": "ETHUSDT",
        //                 "currency": "USDT",
        //                 "action": 1,
        //                 "tradeType": 1,
        //                 "execQtyRq": "0.01",
        //                 "execPriceRp": "1271.9",
        //                 "side": 1,
        //                 "orderQtyRq": "0.78",
        //                 "priceRp": "1271.9",
        //                 "execValueRv": "12.719",
        //                 "feeRateRr": "0.0001",
        //                 "execFeeRv": "0.0012719",
        //                 "ordType": 2,
        //                 "execId": "8718cae",
        //                 "execStatus": 6
        //             },
        //         ]
        //     }
        // }
        //
        object data = null;
        if (isTrue(isUSDTSettled))
        {
            data = this.safeValue(response, "data", new List<object>() {});
        } else
        {
            data = this.safeValue(response, "data", new Dictionary<string, object>() {});
            data = this.safeValue(data, "rows", new List<object>() {});
        }
        return this.parseTrades(data, market, since, limit);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object defaultNetworks = this.safeValue(this.options, "defaultNetworks");
        object defaultNetwork = this.safeStringUpper(defaultNetworks, code);
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object network = this.safeStringUpper(parameters, "network", defaultNetwork);
        network = this.safeString(networks, network, network);
        if (isTrue(isEqual(network, null)))
        {
            ((IDictionary<string,object>)request)["chainName"] = getValue(currency, "id");
        } else
        {
            ((IDictionary<string,object>)request)["chainName"] = network;
            parameters = this.omit(parameters, "network");
        }
        object response = await this.privateGetPhemexUserWalletsV2DepositAddress(this.extend(request, parameters));
        //     {
        //         "code":0,
        //         "msg":"OK",
        //         "data":{
        //             "address":"0x5bfbf60e0fa7f63598e6cfd8a7fd3ffac4ccc6ad",
        //             "tag":null
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object address = this.safeString(data, "address");
        object tag = this.safeString(data, "tag");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", null },
            { "info", response },
        };
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object response = await this.privateGetExchangeWalletsDepositList(parameters);
        //
        //     {
        //         "code":0,
        //         "msg":"OK",
        //         "data":[
        //             {
        //                 "id":29200,
        //                 "currency":"USDT",
        //                 "currencyCode":3,
        //                 "txHash":"0x0bdbdc47807769a03b158d5753f54dfc58b92993d2f5e818db21863e01238e5d",
        //                 "address":"0x5bfbf60e0fa7f63598e6cfd8a7fd3ffac4ccc6ad",
        //                 "amountEv":3000000000,
        //                 "confirmations":13,
        //                 "type":"Deposit",
        //                 "status":"Success",
        //                 "createdAt":1592722565000
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object response = await this.privateGetExchangeWalletsWithdrawList(parameters);
        //
        //     {
        //         "code":0,
        //         "msg":"OK",
        //         "data":[
        //             {
        //                 "address": "1Lxxxxxxxxxxx"
        //                 "amountEv": 200000
        //                 "currency": "BTC"
        //                 "currencyCode": 1
        //                 "expiredTime": 0
        //                 "feeEv": 50000
        //                 "rejectReason": null
        //                 "status": "Succeed"
        //                 "txHash": "44exxxxxxxxxxxxxxxxxxxxxx"
        //                 "withdrawStatus: ""
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "Success", "ok" },
            { "Succeed", "ok" },
            { "Rejected", "failed" },
            { "Security check failed", "failed" },
            { "SecurityCheckFailed", "failed" },
            { "Expired", "failed" },
            { "Address Risk", "failed" },
            { "Security Checking", "pending" },
            { "SecurityChecking", "pending" },
            { "Pending Review", "pending" },
            { "Pending Transfer", "pending" },
            { "AmlCsApporve", "pending" },
            { "New", "pending" },
            { "Confirmed", "pending" },
            { "Cancelled", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // withdraw
        //
        //     {
        //         "id": "10000001",
        //         "freezeId": null,
        //         "address": "44exxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
        //         "amountRv": "100",
        //         "chainCode": "11",
        //         "chainName": "TRX",
        //         "currency": "USDT",
        //         "currencyCode": 3,
        //         "email": "abc@gmail.com",
        //         "expiredTime": "0",
        //         "feeRv": "1",
        //         "nickName": null,
        //         "phone": null,
        //         "rejectReason": "",
        //         "submitedAt": "1670000000000",
        //         "submittedAt": "1670000000000",
        //         "txHash": null,
        //         "userId": "10000001",
        //         "status": "Success"
        //
        // fetchDeposits
        //
        //     {
        //         "id": "29200",
        //         "currency": "USDT",
        //         "currencyCode": "3",
        //         "chainName": "ETH",
        //         "chainCode": "4",
        //         "txHash": "0x0bdbdc47807769a03b158d5753f54dfc58b92993d2f5e818db21863e01238e5d",
        //         "address": "0x5bfbf60e0fa7f63598e6cfd8a7fd3ffac4ccc6ad",
        //         "amountEv": "3000000000",
        //         "confirmations": "13",
        //         "type": "Deposit",
        //         "status": "Success",
        //         "createdAt": "1592722565000",
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "id": "10000001",
        //         "userId": "10000001",
        //         "freezeId": "10000002",
        //         "phone": null,
        //         "email": "abc@gmail.com",
        //         "nickName": null,
        //         "currency": "USDT",
        //         "currencyCode": "3",
        //         "status": "Succeed",
        //         "withdrawStatus": "Succeed",
        //         "amountEv": "8800000000",
        //         "feeEv": "1200000000",
        //         "address": "0x5xxxad",
        //         "txHash: "0x0xxxx5d",
        //         "submitedAt": "1702571922000",
        //         "submittedAt": "1702571922000",
        //         "expiredTime": "0",
        //         "rejectReason": null,
        //         "chainName": "ETH",
        //         "chainCode": "4",
        //         "proxyAddress": null
        //     }
        //
        object id = this.safeString(transaction, "id");
        object address = this.safeString(transaction, "address");
        object tag = null;
        object txid = this.safeString(transaction, "txHash");
        object currencyId = this.safeString(transaction, "currency");
        currency = this.safeCurrency(currencyId, currency);
        object code = getValue(currency, "code");
        object networkId = this.safeString(transaction, "chainName");
        object timestamp = this.safeIntegerN(transaction, new List<object>() {"createdAt", "submitedAt", "submittedAt"});
        object type = this.safeStringLower(transaction, "type");
        object feeCost = this.parseNumber(this.fromEn(this.safeString(transaction, "feeEv"), getValue(currency, "valueScale")));
        if (isTrue(isEqual(feeCost, null)))
        {
            feeCost = this.safeNumber(transaction, "feeRv");
        }
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            type = "withdrawal";
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", code },
            };
        }
        object status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        object amount = this.parseNumber(this.fromEn(this.safeString(transaction, "amountEv"), getValue(currency, "valueScale")));
        if (isTrue(isEqual(amount, null)))
        {
            amount = this.safeNumber(transaction, "amountRv");
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", this.networkIdToCode(networkId) },
            { "address", address },
            { "addressTo", address },
            { "addressFrom", null },
            { "tag", tag },
            { "tagTo", tag },
            { "tagFrom", null },
            { "type", type },
            { "amount", amount },
            { "currency", code },
            { "status", status },
            { "updated", null },
            { "comment", null },
            { "internal", null },
            { "fee", fee },
        };
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchPositions
        * @description fetch all open positions
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Contract-API-en.md#query-trading-account-and-positions
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#query-account-positions
        * @see https://phemex-docs.github.io/#query-account-positions-with-unrealized-pnl
        * @param {string[]} [symbols] list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [param.method] *USDT contracts only* 'privateGetGAccountsAccountPositions' or 'privateGetAccountsPositions' default is 'privateGetGAccountsAccountPositions'
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object subType = null;
        object code = this.safeString(parameters, "currency");
        object settle = null;
        object market = null;
        object firstSymbol = this.safeString(symbols, 0);
        if (isTrue(!isEqual(firstSymbol, null)))
        {
            market = this.market(firstSymbol);
            settle = getValue(market, "settle");
            code = getValue(market, "settle");
        } else
        {
            var settleparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "settle", "USD");
            settle = ((IList<object>)settleparametersVariable)[0];
            parameters = ((IList<object>)settleparametersVariable)[1];
        }
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchPositions", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object isUSDTSettled = isEqual(settle, "USDT");
        if (isTrue(isUSDTSettled))
        {
            code = "USDT";
        } else if (isTrue(isEqual(code, null)))
        {
            code = ((bool) isTrue((isEqual(subType, "linear")))) ? "USD" : "BTC";
        } else
        {
            parameters = this.omit(parameters, "code");
        }
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = null;
        if (isTrue(isUSDTSettled))
        {
            object method = null;
            var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "method", "privateGetGAccountsAccountPositions");
            method = ((IList<object>)methodparametersVariable)[0];
            parameters = ((IList<object>)methodparametersVariable)[1];
            if (isTrue(isEqual(method, "privateGetGAccountsAccountPositions")))
            {
                response = await this.privateGetGAccountsAccountPositions(this.extend(request, parameters));
            } else
            {
                response = await this.privateGetAccountsPositions(this.extend(request, parameters));
            }
        } else
        {
            response = await this.privateGetAccountsAccountPositions(this.extend(request, parameters));
        }
        //
        //     {
        //         "code":0,"msg":"",
        //         "data":{
        //             "account":{
        //                 "accountId":6192120001,
        //                 "currency":"BTC",
        //                 "accountBalanceEv":1254744,
        //                 "totalUsedBalanceEv":0,
        //                 "bonusBalanceEv":1254744
        //             },
        //             "positions":[
        //                 {
        //                     "accountID":6192120001,
        //                     "symbol":"BTCUSD",
        //                     "currency":"BTC",
        //                     "side":"None",
        //                     "positionStatus":"Normal",
        //                     "crossMargin":false,
        //                     "leverageEr":100000000,
        //                     "leverage":1.00000000,
        //                     "initMarginReqEr":100000000,
        //                     "initMarginReq":1.00000000,
        //                     "maintMarginReqEr":500000,
        //                     "maintMarginReq":0.00500000,
        //                     "riskLimitEv":10000000000,
        //                     "riskLimit":100.00000000,
        //                     "size":0,
        //                     "value":0E-8,
        //                     "valueEv":0,
        //                     "avgEntryPriceEp":0,
        //                     "avgEntryPrice":0E-8,
        //                     "posCostEv":0,
        //                     "posCost":0E-8,
        //                     "assignedPosBalanceEv":0,
        //                     "assignedPosBalance":0E-8,
        //                     "bankruptCommEv":0,
        //                     "bankruptComm":0E-8,
        //                     "bankruptPriceEp":0,
        //                     "bankruptPrice":0E-8,
        //                     "positionMarginEv":0,
        //                     "positionMargin":0E-8,
        //                     "liquidationPriceEp":0,
        //                     "liquidationPrice":0E-8,
        //                     "deleveragePercentileEr":0,
        //                     "deleveragePercentile":0E-8,
        //                     "buyValueToCostEr":100225000,
        //                     "buyValueToCost":1.00225000,
        //                     "sellValueToCostEr":100075000,
        //                     "sellValueToCost":1.00075000,
        //                     "markPriceEp":135736070,
        //                     "markPrice":13573.60700000,
        //                     "markValueEv":0,
        //                     "markValue":null,
        //                     "unRealisedPosLossEv":0,
        //                     "unRealisedPosLoss":null,
        //                     "estimatedOrdLossEv":0,
        //                     "estimatedOrdLoss":0E-8,
        //                     "usedBalanceEv":0,
        //                     "usedBalance":0E-8,
        //                     "takeProfitEp":0,
        //                     "takeProfit":null,
        //                     "stopLossEp":0,
        //                     "stopLoss":null,
        //                     "cumClosedPnlEv":0,
        //                     "cumFundingFeeEv":0,
        //                     "cumTransactFeeEv":0,
        //                     "realisedPnlEv":0,
        //                     "realisedPnl":null,
        //                     "cumRealisedPnlEv":0,
        //                     "cumRealisedPnl":null
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object positions = this.safeValue(data, "positions", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object position = getValue(positions, i);
            ((IList<object>)result).Add(this.parsePosition(position));
        }
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //    {
        //        "userID": "811370",
        //        "accountID": "8113700002",
        //        "symbol": "ETHUSD",
        //        "currency": "USD",
        //        "side": "Buy",
        //        "positionStatus": "Normal",
        //        "crossMargin": false,
        //        "leverageEr": "200000000",
        //        "leverage": "2.00000000",
        //        "initMarginReqEr": "50000000",
        //        "initMarginReq": "0.50000000",
        //        "maintMarginReqEr": "1000000",
        //        "maintMarginReq": "0.01000000",
        //        "riskLimitEv": "5000000000",
        //        "riskLimit": "500000.00000000",
        //        "size": "1",
        //        "value": "22.22370000",
        //        "valueEv": "222237",
        //        "avgEntryPriceEp": "44447400",
        //        "avgEntryPrice": "4444.74000000",
        //        "posCostEv": "111202",
        //        "posCost": "11.12020000",
        //        "assignedPosBalanceEv": "111202",
        //        "assignedPosBalance": "11.12020000",
        //        "bankruptCommEv": "84",
        //        "bankruptComm": "0.00840000",
        //        "bankruptPriceEp": "22224000",
        //        "bankruptPrice": "2222.40000000",
        //        "positionMarginEv": "111118",
        //        "positionMargin": "11.11180000",
        //        "liquidationPriceEp": "22669000",
        //        "liquidationPrice": "2266.90000000",
        //        "deleveragePercentileEr": "0",
        //        "deleveragePercentile": "0E-8",
        //        "buyValueToCostEr": "50112500",
        //        "buyValueToCost": "0.50112500",
        //        "sellValueToCostEr": "50187500",
        //        "sellValueToCost": "0.50187500",
        //        "markPriceEp": "31332499",
        //        "markPrice": "3133.24990000",
        //        "markValueEv": "0",
        //        "markValue": null,
        //        "unRealisedPosLossEv": "0",
        //        "unRealisedPosLoss": null,
        //        "estimatedOrdLossEv": "0",
        //        "estimatedOrdLoss": "0E-8",
        //        "usedBalanceEv": "111202",
        //        "usedBalance": "11.12020000",
        //        "takeProfitEp": "0",
        //        "takeProfit": null,
        //        "stopLossEp": "0",
        //        "stopLoss": null,
        //        "cumClosedPnlEv": "-1546",
        //        "cumFundingFeeEv": "1605",
        //        "cumTransactFeeEv": "8438",
        //        "realisedPnlEv": "0",
        //        "realisedPnl": null,
        //        "cumRealisedPnlEv": "0",
        //        "cumRealisedPnl": null,
        //        "transactTimeNs": "1641571200001885324",
        //        "takerFeeRateEr": "0",
        //        "makerFeeRateEr": "0",
        //        "term": "6",
        //        "lastTermEndTimeNs": "1607711882505745356",
        //        "lastFundingTimeNs": "1641571200000000000",
        //        "curTermRealisedPnlEv": "-1567",
        //        "execSeq": "12112761561"
        //    }
        //
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object collateral = this.safeString2(position, "positionMargin", "positionMarginRv");
        object notionalString = this.safeString2(position, "value", "valueRv");
        object maintenanceMarginPercentageString = this.safeString2(position, "maintMarginReq", "maintMarginReqRr");
        object maintenanceMarginString = Precise.stringMul(notionalString, maintenanceMarginPercentageString);
        object initialMarginString = this.safeString2(position, "assignedPosBalance", "assignedPosBalanceRv");
        object initialMarginPercentageString = Precise.stringDiv(initialMarginString, notionalString);
        object liquidationPrice = this.safeNumber2(position, "liquidationPrice", "liquidationPriceRp");
        object markPriceString = this.safeString2(position, "markPrice", "markPriceRp");
        object contracts = this.safeString(position, "size");
        object contractSize = this.safeValue(market, "contractSize");
        object contractSizeString = this.numberToString(contractSize);
        object leverage = this.parseNumber(Precise.stringAbs((this.safeString2(position, "leverage", "leverageRr"))));
        object entryPriceString = this.safeString2(position, "avgEntryPrice", "avgEntryPriceRp");
        object rawSide = this.safeString(position, "side");
        object side = null;
        if (isTrue(!isEqual(rawSide, null)))
        {
            side = ((bool) isTrue((isEqual(rawSide, "Buy")))) ? "long" : "short";
        }
        object priceDiff = null;
        object currency = this.safeString(position, "currency");
        if (isTrue(isEqual(currency, "USD")))
        {
            if (isTrue(isEqual(side, "long")))
            {
                priceDiff = Precise.stringSub(markPriceString, entryPriceString);
            } else
            {
                priceDiff = Precise.stringSub(entryPriceString, markPriceString);
            }
        } else
        {
            // inverse
            if (isTrue(isEqual(side, "long")))
            {
                priceDiff = Precise.stringSub(Precise.stringDiv("1", entryPriceString), Precise.stringDiv("1", markPriceString));
            } else
            {
                priceDiff = Precise.stringSub(Precise.stringDiv("1", markPriceString), Precise.stringDiv("1", entryPriceString));
            }
        }
        object unrealizedPnl = Precise.stringMul(Precise.stringMul(priceDiff, contracts), contractSizeString);
        object marginRatio = Precise.stringDiv(maintenanceMarginString, collateral);
        object isCross = this.safeValue(position, "crossMargin");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "contracts", this.parseNumber(contracts) },
            { "contractSize", contractSize },
            { "unrealizedPnl", this.parseNumber(unrealizedPnl) },
            { "leverage", leverage },
            { "liquidationPrice", liquidationPrice },
            { "collateral", this.parseNumber(collateral) },
            { "notional", this.parseNumber(notionalString) },
            { "markPrice", this.parseNumber(markPriceString) },
            { "lastPrice", null },
            { "entryPrice", this.parseNumber(entryPriceString) },
            { "timestamp", null },
            { "lastUpdateTimestamp", null },
            { "initialMargin", this.parseNumber(initialMarginString) },
            { "initialMarginPercentage", this.parseNumber(initialMarginPercentageString) },
            { "maintenanceMargin", this.parseNumber(maintenanceMarginString) },
            { "maintenanceMarginPercentage", this.parseNumber(maintenanceMarginPercentageString) },
            { "marginRatio", this.parseNumber(marginRatio) },
            { "datetime", null },
            { "marginMode", ((bool) isTrue(isCross)) ? "cross" : "isolated" },
            { "side", side },
            { "hedged", false },
            { "percentage", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchFundingHistory
        * @description fetch the history of funding payments paid and received on this account
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#futureDataFundingFeesHist
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch funding history for
        * @param {int} [limit] the maximum number of funding history structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(isGreaterThan(limit, 200)))
            {
                throw new BadRequest ((string)add(this.id, " fetchFundingHistory() limit argument cannot exceed 200")) ;
            }
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(isEqual(getValue(market, "settle"), "USDT")))
        {
            response = await this.privateGetApiDataGFuturesFundingFees(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetApiDataFuturesFundingFees(this.extend(request, parameters));
        }
        //
        //     {
        //         "code": 0,
        //         "msg": "OK",
        //         "data": {
        //             "rows": [
        //                 {
        //                     "symbol": "BTCUSD",
        //                     "currency": "BTC",
        //                     "execQty": 18,
        //                     "side": "Buy",
        //                     "execPriceEp": 360086455,
        //                     "execValueEv": 49987,
        //                     "fundingRateEr": 10000,
        //                     "feeRateEr": 10000,
        //                     "execFeeEv": 5,
        //                     "createTime": 1651881600000
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeValue(data, "rows", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rows)); postFixIncrement(ref i))
        {
            object entry = getValue(rows, i);
            object timestamp = this.safeInteger(entry, "createTime");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", this.safeString(entry, "symbol") },
                { "code", this.safeCurrencyCode(this.safeString(entry, "currency")) },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
                { "id", null },
                { "amount", this.fromEv(this.safeString(entry, "execFeeEv"), market) },
            });
        }
        return result;
    }

    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchFundingRate
        * @description fetch the current funding rate
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRate() supports swap contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = new Dictionary<string, object>() {};
        if (!isTrue(getValue(market, "linear")))
        {
            response = await this.v1GetMdTicker24hr(this.extend(request, parameters));
        } else
        {
            response = await this.v2GetMdV2Ticker24hr(this.extend(request, parameters));
        }
        //
        //     {
        //         "error": null,
        //         "id": 0,
        //         "result": {
        //             "askEp": 2332500,
        //             "bidEp": 2331000,
        //             "fundingRateEr": 10000,
        //             "highEp": 2380000,
        //             "indexEp": 2329057,
        //             "lastEp": 2331500,
        //             "lowEp": 2274000,
        //             "markEp": 2329232,
        //             "openEp": 2337500,
        //             "openInterest": 1298050,
        //             "predFundingRateEr": 19921,
        //             "symbol": "ETHUSD",
        //             "timestamp": 1592474241582701416,
        //             "turnoverEv": 47228362330,
        //             "volume": 4053863
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseFundingRate(result, market);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //     {
        //         "askEp": 2332500,
        //         "bidEp": 2331000,
        //         "fundingRateEr": 10000,
        //         "highEp": 2380000,
        //         "indexEp": 2329057,
        //         "lastEp": 2331500,
        //         "lowEp": 2274000,
        //         "markEp": 2329232,
        //         "openEp": 2337500,
        //         "openInterest": 1298050,
        //         "predFundingRateEr": 19921,
        //         "symbol": "ETHUSD",
        //         "timestamp": 1592474241582701416,
        //         "turnoverEv": 47228362330,
        //         "volume": 4053863
        //     }
        //
        // linear swap v2
        //
        //     {
        //         "closeRp":"16820.5",
        //         "fundingRateRr":"0.0001",
        //         "highRp":"16962.1",
        //         "indexPriceRp":"16830.15651565",
        //         "lowRp":"16785",
        //         "markPriceRp":"16830.97534951",
        //         "openInterestRv":"1323.596",
        //         "openRp":"16851.7",
        //         "predFundingRateRr":"0.0001",
        //         "symbol":"BTCUSDT",
        //         "timestamp":"1672142789065593096",
        //         "turnoverRv":"124835296.0538",
        //         "volumeRq":"7406.95"
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object timestamp = this.safeIntegerProduct(contract, "timestamp", 0.000001);
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", this.fromEp(this.safeString2(contract, "markEp", "markPriceRp"), market) },
            { "indexPrice", this.fromEp(this.safeString2(contract, "indexEp", "indexPriceRp"), market) },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fundingRate", this.fromEr(this.safeString(contract, "fundingRateEr"), market) },
            { "fundingTimestamp", null },
            { "fundingDatetime", null },
            { "nextFundingRate", this.fromEr(this.safeString2(contract, "predFundingRateEr", "predFundingRateRr"), market) },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public async override Task<object> setMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name phemex#setMargin
        * @description Either adds or reduces margin in an isolated position in order to set the margin to a specific value
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Contract-API-en.md#assign-position-balance-in-isolated-marign-mode
        * @param {string} symbol unified market symbol of the market to set margin in
        * @param {float} amount the amount to set the margin to
        * @param {object} [params] parameters specific to the exchange API endpoint
        * @returns {object} A [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "posBalanceEv", this.toEv(amount, market) },
        };
        object response = await this.privatePostPositionsAssign(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": "OK"
        //     }
        //
        return this.extend(this.parseMarginModification(response, market), new Dictionary<string, object>() {
            { "amount", amount },
        });
    }

    public virtual object parseMarginStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "0", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseMarginModification(object data, object market = null)
    {
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": "OK"
        //     }
        //
        market = this.safeMarket(null, market);
        object inverse = this.safeValue(market, "inverse");
        object codeCurrency = ((bool) isTrue(inverse)) ? "base" : "quote";
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", this.safeSymbol(null, market) },
            { "type", "set" },
            { "marginMode", "isolated" },
            { "amount", null },
            { "total", null },
            { "code", getValue(market, codeCurrency) },
            { "status", this.parseMarginStatus(this.safeString(data, "code")) },
            { "timestamp", null },
            { "datetime", null },
        };
    }

    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#setMarginMode
        * @description set margin mode to 'cross' or 'isolated'
        * @param {string} marginMode 'cross' or 'isolated'
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(!isTrue(getValue(market, "swap")) || isTrue(isEqual(getValue(market, "settle"), "USDT"))))
        {
            throw new BadSymbol ((string)add(this.id, " setMarginMode() supports swap (non USDT based) contracts only")) ;
        }
        marginMode = ((string)marginMode).ToLower();
        if (isTrue(isTrue(!isEqual(marginMode, "isolated")) && isTrue(!isEqual(marginMode, "cross"))))
        {
            throw new BadRequest ((string)add(this.id, " setMarginMode() marginMode argument should be isolated or cross")) ;
        }
        object leverage = this.safeInteger(parameters, "leverage");
        if (isTrue(isEqual(marginMode, "cross")))
        {
            leverage = 0;
        }
        if (isTrue(isEqual(leverage, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a leverage parameter")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "leverage", leverage },
        };
        return await this.privatePutPositionsLeverage(this.extend(request, parameters));
    }

    public async override Task<object> setPositionMode(object hedged, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#setPositionMode
        * @description set hedged to true or false for a market
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#switch-position-mode-synchronously
        * @param {bool} hedged set to true to use dualSidePosition
        * @param {string} symbol not used by binance setPositionMode ()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredArgument("setPositionMode", symbol, "symbol");
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(!isEqual(getValue(market, "settle"), "USDT")))
        {
            throw new BadSymbol ((string)add(this.id, " setPositionMode() supports USDT settled markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(hedged))
        {
            ((IDictionary<string,object>)request)["targetPosMode"] = "Hedged";
        } else
        {
            ((IDictionary<string,object>)request)["targetPosMode"] = "OneWay";
        }
        return await this.privatePutGPositionsSwitchPosModeSync(this.extend(request, parameters));
    }

    public async override Task<object> fetchLeverageTiers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchLeverageTiers
        * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(!isEqual(symbols, null)))
        {
            object first = this.safeValue(symbols, 0);
            object market = this.market(first);
            if (isTrue(!isEqual(getValue(market, "settle"), "USD")))
            {
                throw new BadSymbol ((string)add(this.id, " fetchLeverageTiers() supports USD settled markets only")) ;
            }
        }
        object response = await this.publicGetCfgV2Products(parameters);
        //
        //     {
        //         "code":0,
        //         "msg":"OK",
        //         "data":{
        //             "ratioScale":8,
        //             "currencies":[
        //                 {"currency":"BTC","valueScale":8,"minValueEv":1,"maxValueEv":5000000000000000000,"name":"Bitcoin"},
        //                 {"currency":"USD","valueScale":4,"minValueEv":1,"maxValueEv":500000000000000,"name":"USD"},
        //                 {"currency":"USDT","valueScale":8,"minValueEv":1,"maxValueEv":5000000000000000000,"name":"TetherUS"},
        //             ],
        //             "products":[
        //                 {
        //                     "symbol":"BTCUSD",
        //                     "displaySymbol":"BTC / USD",
        //                     "indexSymbol":".BTC",
        //                     "markSymbol":".MBTC",
        //                     "fundingRateSymbol":".BTCFR",
        //                     "fundingRate8hSymbol":".BTCFR8H",
        //                     "contractUnderlyingAssets":"USD",
        //                     "settleCurrency":"BTC",
        //                     "quoteCurrency":"USD",
        //                     "contractSize":1.0,
        //                     "lotSize":1,
        //                     "tickSize":0.5,
        //                     "priceScale":4,
        //                     "ratioScale":8,
        //                     "pricePrecision":1,
        //                     "minPriceEp":5000,
        //                     "maxPriceEp":10000000000,
        //                     "maxOrderQty":1000000,
        //                     "type":"Perpetual"
        //                 },
        //                 {
        //                     "symbol":"sBTCUSDT",
        //                     "displaySymbol":"BTC / USDT",
        //                     "quoteCurrency":"USDT",
        //                     "pricePrecision":2,
        //                     "type":"Spot",
        //                     "baseCurrency":"BTC",
        //                     "baseTickSize":"0.000001 BTC",
        //                     "baseTickSizeEv":100,
        //                     "quoteTickSize":"0.01 USDT",
        //                     "quoteTickSizeEv":1000000,
        //                     "minOrderValue":"10 USDT",
        //                     "minOrderValueEv":1000000000,
        //                     "maxBaseOrderSize":"1000 BTC",
        //                     "maxBaseOrderSizeEv":100000000000,
        //                     "maxOrderValue":"5,000,000 USDT",
        //                     "maxOrderValueEv":500000000000000,
        //                     "defaultTakerFee":"0.001",
        //                     "defaultTakerFeeEr":100000,
        //                     "defaultMakerFee":"0.001",
        //                     "defaultMakerFeeEr":100000,
        //                     "baseQtyPrecision":6,
        //                     "quoteQtyPrecision":2
        //                 },
        //             ],
        //             "riskLimits":[
        //                 {
        //                     "symbol":"BTCUSD",
        //                     "steps":"50",
        //                     "riskLimits":[
        //                         {"limit":100,"initialMargin":"1.0%","initialMarginEr":1000000,"maintenanceMargin":"0.5%","maintenanceMarginEr":500000},
        //                         {"limit":150,"initialMargin":"1.5%","initialMarginEr":1500000,"maintenanceMargin":"1.0%","maintenanceMarginEr":1000000},
        //                         {"limit":200,"initialMargin":"2.0%","initialMarginEr":2000000,"maintenanceMargin":"1.5%","maintenanceMarginEr":1500000},
        //                     ]
        //                 },
        //             ],
        //             "leverages":[
        //                 {"initialMargin":"1.0%","initialMarginEr":1000000,"options":[1,2,3,5,10,25,50,100]},
        //                 {"initialMargin":"1.5%","initialMarginEr":1500000,"options":[1,2,3,5,10,25,50,66]},
        //                 {"initialMargin":"2.0%","initialMarginEr":2000000,"options":[1,2,3,5,10,25,33,50]},
        //             ]
        //         }
        //     }
        //
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object riskLimits = this.safeList(data, "riskLimits");
        return this.parseLeverageTiers(riskLimits, symbols, "symbol");
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        /**
         * @param {object} info Exchange market response for 1 market
         * @param {object} market CCXT market
         */
        //
        //     {
        //         "symbol":"BTCUSD",
        //         "steps":"50",
        //         "riskLimits":[
        //             {"limit":100,"initialMargin":"1.0%","initialMarginEr":1000000,"maintenanceMargin":"0.5%","maintenanceMarginEr":500000},
        //             {"limit":150,"initialMargin":"1.5%","initialMarginEr":1500000,"maintenanceMargin":"1.0%","maintenanceMarginEr":1000000},
        //             {"limit":200,"initialMargin":"2.0%","initialMarginEr":2000000,"maintenanceMargin":"1.5%","maintenanceMarginEr":1500000},
        //         ]
        //     },
        //
        market = this.safeMarket(null, market);
        object riskLimits = (getValue(getValue(market, "info"), "riskLimits"));
        object tiers = new List<object>() {};
        object minNotional = 0;
        for (object i = 0; isLessThan(i, getArrayLength(riskLimits)); postFixIncrement(ref i))
        {
            object tier = getValue(riskLimits, i);
            object maxNotional = this.safeInteger(tier, "limit");
            ((IList<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.sum(i, 1) },
                { "currency", getValue(market, "settle") },
                { "minNotional", minNotional },
                { "maxNotional", maxNotional },
                { "maintenanceMarginRate", this.safeString(tier, "maintenanceMargin") },
                { "maxLeverage", null },
                { "info", tier },
            });
            minNotional = maxNotional;
        }
        return tiers;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object query = this.omit(parameters, this.extractParams(path));
        object requestPath = add("/", this.implodeParams(path, parameters));
        object url = requestPath;
        object queryString = "";
        if (isTrue(isTrue(isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE")))) || isTrue((isEqual(method, "PUT")))) || isTrue((isEqual(url, "/positions/assign")))))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                queryString = this.urlencodeWithArrayRepeat(query);
                url = add(url, add("?", queryString));
            }
        }
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object timestamp = this.seconds();
            object xPhemexRequestExpiry = this.safeInteger(this.options, "x-phemex-request-expiry", 60);
            object expiry = this.sum(timestamp, xPhemexRequestExpiry);
            object expiryString = ((object)expiry).ToString();
            headers = new Dictionary<string, object>() {
                { "x-phemex-access-token", this.apiKey },
                { "x-phemex-request-expiry", expiryString },
            };
            object payload = "";
            if (isTrue(isEqual(method, "POST")))
            {
                object isOrderPlacement = isTrue(isTrue((isEqual(path, "g-orders"))) || isTrue((isEqual(path, "spot/orders")))) || isTrue((isEqual(path, "orders")));
                if (isTrue(isOrderPlacement))
                {
                    if (isTrue(isEqual(this.safeString(parameters, "clOrdID"), null)))
                    {
                        object id = this.safeString(this.options, "brokerId", "CCXT123456");
                        ((IDictionary<string,object>)parameters)["clOrdID"] = add(id, this.uuid16());
                    }
                }
                payload = this.json(parameters);
                body = payload;
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
            }
            object auth = add(add(add(requestPath, queryString), expiryString), payload);
            ((IDictionary<string,object>)headers)["x-phemex-request-signature"] = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
        }
        url = add(this.implodeHostname(getValue(getValue(this.urls, "api"), api)), url);
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#setLeverage
        * @description set the level of leverage for a market
        * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#set-leverage
        * @param {float} leverage the rate of leverage, 100 > leverage > -100 excluding numbers between -1 to 1
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {bool} [params.hedged] set to true if hedged position mode is enabled (by default long and short leverage are set to the same value)
        * @param {float} [params.longLeverageRr] *hedged mode only* set the leverage for long positions
        * @param {float} [params.shortLeverageRr] *hedged mode only* set the leverage for short positions
        * @returns {object} response from the exchange
        */
        // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        if (isTrue(isTrue((isLessThan(leverage, -100))) || isTrue((isGreaterThan(leverage, 100)))))
        {
            throw new BadRequest ((string)add(this.id, " setLeverage() leverage should be between -100 and 100")) ;
        }
        await this.loadMarkets();
        object isHedged = this.safeBool(parameters, "hedged", false);
        object longLeverageRr = this.safeInteger(parameters, "longLeverageRr");
        object shortLeverageRr = this.safeInteger(parameters, "shortLeverageRr");
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(isEqual(getValue(market, "settle"), "USDT")))
        {
            if (isTrue(isTrue(!isTrue(isHedged) && isTrue(isEqual(longLeverageRr, null))) && isTrue(isEqual(shortLeverageRr, null))))
            {
                ((IDictionary<string,object>)request)["leverageRr"] = leverage;
            } else
            {
                object longVar = ((bool) isTrue((!isEqual(longLeverageRr, null)))) ? longLeverageRr : leverage;
                object shortVar = ((bool) isTrue((!isEqual(shortLeverageRr, null)))) ? shortLeverageRr : leverage;
                ((IDictionary<string,object>)request)["longLeverageRr"] = longVar;
                ((IDictionary<string,object>)request)["shortLeverageRr"] = shortVar;
            }
            response = await this.privatePutGPositionsLeverage(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["leverage"] = leverage;
            response = await this.privatePutPositionsLeverage(this.extend(request, parameters));
        }
        return response;
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name phemex#transfer
        * @description transfer currency internally between wallets on the same account
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.bizType] for transferring between main and sub-acounts either 'SPOT' or 'PERPETUAL' default is 'SPOT'
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, toAccount);
        object scaledAmmount = this.toEv(amount, currency);
        object direction = null;
        object transfer = null;
        if (isTrue(isTrue(isEqual(fromId, "spot")) && isTrue(isEqual(toId, "future"))))
        {
            direction = 2;
        } else if (isTrue(isTrue(isEqual(fromId, "future")) && isTrue(isEqual(toId, "spot"))))
        {
            direction = 1;
        }
        if (isTrue(!isEqual(direction, null)))
        {
            object request = new Dictionary<string, object>() {
                { "currency", getValue(currency, "id") },
                { "moveOp", direction },
                { "amountEv", scaledAmmount },
            };
            object response = await this.privatePostAssetsTransfer(this.extend(request, parameters));
            //
            //     {
            //         "code": "0",
            //         "msg": "OK",
            //         "data": {
            //             "linkKey": "8564eba4-c9ec-49d6-9b8c-2ec5001a0fb9",
            //             "userId": "4018340",
            //             "currency": "USD",
            //             "amountEv": "10",
            //             "side": "2",
            //             "status": "10"
            //         }
            //     }
            //
            object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
            transfer = this.parseTransfer(data, currency);
        } else
        {
            object request = new Dictionary<string, object>() {
                { "fromUserId", fromId },
                { "toUserId", toId },
                { "amountEv", scaledAmmount },
                { "currency", getValue(currency, "id") },
                { "bizType", this.safeString(parameters, "bizType", "SPOT") },
            };
            object response = await this.privatePostAssetsUniversalTransfer(this.extend(request, parameters));
            //
            //     {
            //         "code": "0",
            //         "msg": "OK",
            //         "data": "API-923db826-aaaa-aaaa-aaaa-4d98c3a7c9fd"
            //     }
            //
            transfer = this.parseTransfer(response);
        }
        object transferOptions = this.safeValue(this.options, "transfer", new Dictionary<string, object>() {});
        object fillResponseFromRequest = this.safeBool(transferOptions, "fillResponseFromRequest", true);
        if (isTrue(fillResponseFromRequest))
        {
            if (isTrue(isEqual(getValue(transfer, "fromAccount"), null)))
            {
                ((IDictionary<string,object>)transfer)["fromAccount"] = fromAccount;
            }
            if (isTrue(isEqual(getValue(transfer, "toAccount"), null)))
            {
                ((IDictionary<string,object>)transfer)["toAccount"] = toAccount;
            }
            if (isTrue(isEqual(getValue(transfer, "amount"), null)))
            {
                ((IDictionary<string,object>)transfer)["amount"] = amount;
            }
            if (isTrue(isEqual(getValue(transfer, "currency"), null)))
            {
                ((IDictionary<string,object>)transfer)["currency"] = code;
            }
        }
        return transfer;
    }

    public async virtual Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchTransfers
        * @description fetch a history of internal transfers made on an account
        * @param {string} code unified currency code of the currency transferred
        * @param {int} [since] the earliest time in ms to fetch transfers for
        * @param {int} [limit] the maximum number of  transfers structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchTransfers() requires a code argument")) ;
        }
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetAssetsTransfer(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "msg": "OK",
        //         "data": {
        //             "rows": [
        //                 {
        //                     "linkKey": "87c071a3-8628-4ac2-aca1-6ce0d1fad66c",
        //                     "userId": 4148428,
        //                     "currency": "BTC",
        //                     "amountEv": 67932,
        //                     "side": 2,
        //                     "status": 10,
        //                     "createTime": 1652832467000,
        //                     "bizType": 10
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object transfers = this.safeList(data, "rows", new List<object>() {});
        return this.parseTransfers(transfers, currency, since, limit);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer
        //
        //     {
        //         "linkKey": "8564eba4-c9ec-49d6-9b8c-2ec5001a0fb9",
        //         "userId": "4018340",
        //         "currency": "USD",
        //         "amountEv": "10",
        //         "side": "2",
        //         "status": "10"
        //     }
        //
        // fetchTransfers
        //
        //     {
        //         "linkKey": "87c071a3-8628-4ac2-aca1-6ce0d1fad66c",
        //         "userId": 4148428,
        //         "currency": "BTC",
        //         "amountEv": 67932,
        //         "side": 2,
        //         "status": 10,
        //         "createTime": 1652832467000,
        //         "bizType": 10
        //     }
        //
        object id = this.safeString(transfer, "linkKey");
        object status = this.safeString(transfer, "status");
        object amountEv = this.safeString(transfer, "amountEv");
        object amountTransfered = this.fromEv(amountEv);
        object currencyId = this.safeString(transfer, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object side = this.safeInteger(transfer, "side");
        object fromId = null;
        object toId = null;
        if (isTrue(isEqual(side, 1)))
        {
            fromId = "swap";
            toId = "spot";
        } else if (isTrue(isEqual(side, 2)))
        {
            fromId = "spot";
            toId = "swap";
        }
        object timestamp = this.safeInteger(transfer, "createTime");
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", code },
            { "amount", amountTransfered },
            { "fromAccount", fromId },
            { "toAccount", toId },
            { "status", this.parseTransferStatus(status) },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "3", "rejected" },
            { "6", "canceled" },
            { "10", "ok" },
            { "11", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#fetchFundingRateHistory
        * @description fetches historical funding rate prices
        * @see https://phemex-docs.github.io/#query-funding-rate-history-2
        * @param {string} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
        * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @param {int} [params.until] timestamp in ms of the latest funding rate
        * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object isUsdtSettled = isEqual(getValue(market, "settle"), "USDT");
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadRequest ((string)add(this.id, " fetchFundingRateHistory() supports swap contracts only")) ;
        }
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory", symbol, since, limit, "8h", parameters, 100);
        }
        object customSymbol = null;
        if (isTrue(isUsdtSettled))
        {
            customSymbol = add(add(".", getValue(market, "id")), "FR8H"); // phemex requires a custom symbol for funding rate history
        } else
        {
            customSymbol = add(add(".", getValue(market, "baseId")), "FR8H");
        }
        object request = new Dictionary<string, object>() {
            { "symbol", customSymbol },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("end", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = null;
        if (isTrue(isUsdtSettled))
        {
            response = await this.v2GetApiDataPublicDataFundingRateHistory(this.extend(request, parameters));
        } else
        {
            response = await this.v1GetApiDataPublicDataFundingRateHistory(this.extend(request, parameters));
        }
        //
        //    {
        //        "code":"0",
        //        "msg":"OK",
        //        "data":{
        //           "rows":[
        //              {
        //                 "symbol":".BTCUSDTFR8H",
        //                 "fundingRate":"0.0001",
        //                 "fundingTime":"1682064000000",
        //                 "intervalSeconds":"28800"
        //              }
        //           ]
        //        }
        //    }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object rates = this.safeValue(data, "rows");
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rates)); postFixIncrement(ref i))
        {
            object item = getValue(rates, i);
            object timestamp = this.safeInteger(item, "fundingTime");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "info", item },
                { "symbol", symbol },
                { "fundingRate", this.safeNumber(item, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(result, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name phemex#withdraw
        * @description make a withdrawal
        * @see https://phemex-docs.github.io/#create-withdraw-request
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the phemex api endpoint
        * @param {string} [params.network] unified network code
        * @returns {object} a [transaction structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        this.checkAddress(address);
        object currency = this.currency(code);
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        object networkId = null;
        if (isTrue(!isEqual(networkCode, null)))
        {
            networkId = this.networkCodeToId(networkCode);
        }
        object stableCoins = this.safeValue(this.options, "stableCoins");
        if (isTrue(isEqual(networkId, null)))
        {
            if (!isTrue((this.inArray(code, stableCoins))))
            {
                networkId = getValue(currency, "id");
            } else
            {
                throw new ArgumentsRequired ((string)add(this.id, " withdraw () requires an extra argument params[\"network\"]")) ;
            }
        }
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "address", address },
            { "amount", amount },
            { "chainName", ((string)networkId).ToUpper() },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["addressTag"] = tag;
        }
        object response = await this.privatePostPhemexWithdrawWalletsApiCreateWithdraw(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "msg": "OK",
        //         "data": {
        //             "id": "10000001",
        //             "freezeId": null,
        //             "address": "44exxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
        //             "amountRv": "100",
        //             "chainCode": "11",
        //             "chainName": "TRX",
        //             "currency": "USDT",
        //             "currencyCode": 3,
        //             "email": "abc@gmail.com",
        //             "expiredTime": "0",
        //             "feeRv": "1",
        //             "nickName": null,
        //             "phone": null,
        //             "rejectReason": "",
        //             "submitedAt": "1670000000000",
        //             "submittedAt": "1670000000000",
        //             "txHash": null,
        //             "userId": "10000001",
        //             "status": "Success"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTransaction(data, currency);
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        //
        //     {"code":30018,"msg":"phemex.data.size.uplimt","data":null}
        //     {"code":412,"msg":"Missing parameter - resolution","data":null}
        //     {"code":412,"msg":"Missing parameter - to","data":null}
        //     {"error":{"code":6001,"message":"invalid argument"},"id":null,"result":null}
        //
        object error = this.safeValue(response, "error", response);
        object errorCode = this.safeString(error, "code");
        object message = this.safeString(error, "msg");
        if (isTrue(isTrue((!isEqual(errorCode, null))) && isTrue((!isEqual(errorCode, "0")))))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
