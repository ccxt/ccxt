namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class hashkey : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "hashkey" },
            { "name", "HashKey Global" },
            { "countries", new List<object>() {"BM"} },
            { "rateLimit", 100 },
            { "version", "v1" },
            { "certified", true },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", true },
                { "cancelAllOrdersAfter", false },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "cancelWithdraw", false },
                { "closePosition", false },
                { "createConvertTrade", false },
                { "createDepositAddress", false },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrder", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrderWithTakeProfitAndStopLoss", false },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", true },
                { "createStopLossOrder", false },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "createTakeProfitOrder", false },
                { "createTrailingAmountOrder", false },
                { "createTrailingPercentOrder", false },
                { "createTriggerOrder", true },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchCanceledAndClosedOrders", true },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrder", true },
                { "fetchClosedOrders", false },
                { "fetchConvertCurrencies", false },
                { "fetchConvertQuote", false },
                { "fetchConvertTrade", false },
                { "fetchConvertTradeHistory", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", false },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", false },
                { "fetchLedger", true },
                { "fetchLeverage", true },
                { "fetchLeverageTiers", true },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", false },
                { "fetchMarketLeverageTiers", "emulated" },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", false },
                { "fetchOrderTrades", false },
                { "fetchPosition", false },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsForSymbol", true },
                { "fetchPositionsHistory", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", true },
                { "fetchTransactions", false },
                { "fetchTransfers", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "sandbox", false },
                { "setLeverage", true },
                { "setMargin", false },
                { "setPositionMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "8h", "8h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "1w", "1w" },
                { "1M", "1M" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/6dd6127b-cc19-4a13-9b29-a98d81f80e98" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api-glb.hashkey.com" },
                    { "private", "https://api-glb.hashkey.com" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "public", "https://api-glb.sim.hashkeydev.com" },
                    { "private", "https://api-glb.sim.hashkeydev.com" },
                } },
                { "www", "https://global.hashkey.com/" },
                { "doc", "https://hashkeyglobal-apidoc.readme.io/" },
                { "fees", "https://support.global.hashkey.com/hc/en-us/articles/13199900083612-HashKey-Global-Fee-Structure" },
                { "referral", "https://global.hashkey.com/en-US/register/invite?invite_code=82FQUN" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "api/v1/exchangeInfo", 5 },
                        { "quote/v1/depth", 1 },
                        { "quote/v1/trades", 1 },
                        { "quote/v1/klines", 1 },
                        { "quote/v1/ticker/24hr", 1 },
                        { "quote/v1/ticker/price", 1 },
                        { "quote/v1/ticker/bookTicker", 1 },
                        { "quote/v1/depth/merged", 1 },
                        { "quote/v1/markPrice", 1 },
                        { "quote/v1/index", 1 },
                        { "api/v1/futures/fundingRate", 1 },
                        { "api/v1/futures/historyFundingRate", 1 },
                        { "api/v1/ping", 1 },
                        { "api/v1/time", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "api/v1/spot/order", 1 },
                        { "api/v1/spot/openOrders", 1 },
                        { "api/v1/spot/tradeOrders", 5 },
                        { "api/v1/futures/leverage", 1 },
                        { "api/v1/futures/order", 1 },
                        { "api/v1/futures/openOrders", 1 },
                        { "api/v1/futures/userTrades", 1 },
                        { "api/v1/futures/positions", 1 },
                        { "api/v1/futures/historyOrders", 1 },
                        { "api/v1/futures/balance", 1 },
                        { "api/v1/futures/liquidationAssignStatus", 1 },
                        { "api/v1/futures/riskLimit", 1 },
                        { "api/v1/futures/commissionRate", 1 },
                        { "api/v1/futures/getBestOrder", 1 },
                        { "api/v1/account/vipInfo", 1 },
                        { "api/v1/account", 1 },
                        { "api/v1/account/trades", 5 },
                        { "api/v1/account/type", 5 },
                        { "api/v1/account/checkApiKey", 1 },
                        { "api/v1/account/balanceFlow", 5 },
                        { "api/v1/spot/subAccount/openOrders", 1 },
                        { "api/v1/spot/subAccount/tradeOrders", 1 },
                        { "api/v1/subAccount/trades", 1 },
                        { "api/v1/futures/subAccount/openOrders", 1 },
                        { "api/v1/futures/subAccount/historyOrders", 1 },
                        { "api/v1/futures/subAccount/userTrades", 1 },
                        { "api/v1/account/deposit/address", 1 },
                        { "api/v1/account/depositOrders", 1 },
                        { "api/v1/account/withdrawOrders", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "api/v1/userDataStream", 1 },
                        { "api/v1/spot/orderTest", 1 },
                        { "api/v1/spot/order", 1 },
                        { "api/v1.1/spot/order", 1 },
                        { "api/v1/spot/batchOrders", 5 },
                        { "api/v1/futures/leverage", 1 },
                        { "api/v1/futures/order", 1 },
                        { "api/v1/futures/position/trading-stop", 3 },
                        { "api/v1/futures/batchOrders", 5 },
                        { "api/v1/account/assetTransfer", 1 },
                        { "api/v1/account/authAddress", 1 },
                        { "api/v1/account/withdraw", 1 },
                    } },
                    { "put", new Dictionary<string, object>() {
                        { "api/v1/userDataStream", 1 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "api/v1/spot/order", 1 },
                        { "api/v1/spot/openOrders", 5 },
                        { "api/v1/spot/cancelOrderByIds", 5 },
                        { "api/v1/futures/order", 1 },
                        { "api/v1/futures/batchOrders", 1 },
                        { "api/v1/futures/cancelOrderByIds", 1 },
                        { "api/v1/userDataStream", 1 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "tierBased", true },
                        { "percentage", true },
                        { "feeSide", "get" },
                        { "maker", this.parseNumber("0.0012") },
                        { "taker", this.parseNumber("0.0012") },
                        { "tiers", new Dictionary<string, object>() {
                            { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.00080")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.00070")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0.00060")}, new List<object> {this.parseNumber("50000000"), this.parseNumber("0.00040")}, new List<object> {this.parseNumber("200000000"), this.parseNumber("0.00030")}, new List<object> {this.parseNumber("400000000"), this.parseNumber("0.00010")}, new List<object> {this.parseNumber("800000000"), this.parseNumber("0.00")}} },
                            { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.00090")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.00085")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0.00075")}, new List<object> {this.parseNumber("50000000"), this.parseNumber("0.00065")}, new List<object> {this.parseNumber("200000000"), this.parseNumber("0.00045")}, new List<object> {this.parseNumber("400000000"), this.parseNumber("0.00040")}, new List<object> {this.parseNumber("800000000"), this.parseNumber("0.00035")}} },
                        } },
                    } },
                    { "swap", new Dictionary<string, object>() {
                        { "tierBased", true },
                        { "percentage", true },
                        { "feeSide", "get" },
                        { "maker", this.parseNumber("0.00025") },
                        { "taker", this.parseNumber("0.00060") },
                        { "tiers", new Dictionary<string, object>() {
                            { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.00025")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.00016")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.00014")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0.00012")}, new List<object> {this.parseNumber("50000000"), this.parseNumber("0.000080")}, new List<object> {this.parseNumber("200000000"), this.parseNumber("0.000060")}, new List<object> {this.parseNumber("400000000"), this.parseNumber("0.000020")}, new List<object> {this.parseNumber("800000000"), this.parseNumber("0.00")}} },
                            { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.00060")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.00050")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.00045")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0.00040")}, new List<object> {this.parseNumber("50000000"), this.parseNumber("0.00035")}, new List<object> {this.parseNumber("200000000"), this.parseNumber("0.00030")}, new List<object> {this.parseNumber("400000000"), this.parseNumber("0.00025")}, new List<object> {this.parseNumber("800000000"), this.parseNumber("0.00020")}} },
                        } },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "broker", "10000700011" },
                { "recvWindow", null },
                { "sandboxMode", false },
                { "networks", new Dictionary<string, object>() {
                    { "BTC", "BTC" },
                    { "ERC20", "ETH" },
                    { "AVAX", "AvalancheC" },
                    { "SOL", "Solana" },
                    { "MATIC", "Polygon" },
                    { "ATOM", "Cosmos" },
                    { "DOT", "Polkadot" },
                    { "LTC", "LTC" },
                    { "OPTIMISM", "Optimism" },
                    { "ARB", "Arbitrum" },
                    { "DOGE", "Dogecoin" },
                    { "TRC20", "Tron" },
                    { "ZKSYNC", "zkSync" },
                    { "TON", "TON" },
                    { "KLAYTN", "Klaytn" },
                    { "MERLINCHAIN", "Merlin Chain" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "BTC", "BTC" },
                    { "Bitcoin", "BTC" },
                    { "ETH", "ERC20" },
                    { "ERC20", "ERC20" },
                    { "AvalancheC", "AVAX" },
                    { "AVAX C-Chain", "AVAX" },
                    { "Solana", "SOL" },
                    { "Cosmos", "ATOM" },
                    { "Arbitrum", "ARB" },
                    { "Polygon", "MATIC" },
                    { "Optimism", "OPTIMISM" },
                    { "Polkadot", "DOT" },
                    { "LTC", "LTC" },
                    { "Litecoin", "LTC" },
                    { "Dogecoin", "DOGE" },
                    { "Merlin Chain", "MERLINCHAIN" },
                    { "zkSync", "ZKSYNC" },
                    { "TRC20", "TRC20" },
                    { "Tron", "TRC20" },
                    { "TON", "TON" },
                    { "BSC(BEP20)", "BSC" },
                    { "Klaytn", "KLAYTN" },
                } },
                { "defaultNetwork", "ERC20" },
            } },
            { "features", new Dictionary<string, object>() {
                { "default", new Dictionary<string, object>() {
                    { "sandbox", true },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", false },
                        { "triggerPriceType", null },
                        { "triggerDirection", false },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "trailing", false },
                        { "leverage", false },
                        { "marketBuyByCost", true },
                        { "marketBuyRequiresPrice", true },
                        { "selfTradePrevention", true },
                        { "iceberg", false },
                    } },
                    { "createOrders", new Dictionary<string, object>() {
                        { "max", 20 },
                    } },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 1000 },
                        { "daysBack", 30 },
                        { "untilDays", 30 },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 1000 },
                        { "trigger", false },
                        { "trailing", false },
                    } },
                    { "fetchOrders", null },
                    { "fetchClosedOrders", null },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 1000 },
                    } },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "extends", "default" },
                } },
                { "forDerivatives", new Dictionary<string, object>() {
                    { "extends", "default" },
                    { "createOrder", new Dictionary<string, object>() {
                        { "triggerPrice", true },
                        { "selfTradePrevention", true },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "trigger", true },
                        { "limit", 500 },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "forDerivatives" },
                    } },
                    { "inverse", null },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "0001", typeof(BadRequest) },
                    { "0002", typeof(AuthenticationError) },
                    { "0003", typeof(RateLimitExceeded) },
                    { "0102", typeof(AuthenticationError) },
                    { "0103", typeof(AuthenticationError) },
                    { "0104", typeof(PermissionDenied) },
                    { "0201", typeof(ExchangeError) },
                    { "0202", typeof(PermissionDenied) },
                    { "0206", typeof(BadRequest) },
                    { "0207", typeof(BadRequest) },
                    { "0209", typeof(BadRequest) },
                    { "0210", typeof(BadRequest) },
                    { "0211", typeof(OrderNotFound) },
                    { "0401", typeof(InsufficientFunds) },
                    { "0402", typeof(BadRequest) },
                    { "-1000", typeof(ExchangeError) },
                    { "-1001", typeof(ExchangeError) },
                    { "-100010", typeof(BadSymbol) },
                    { "-100012", typeof(BadSymbol) },
                    { "-1002", typeof(AuthenticationError) },
                    { "-1004", typeof(BadRequest) },
                    { "-1005", typeof(PermissionDenied) },
                    { "-1006", typeof(ExchangeError) },
                    { "-1007", typeof(RequestTimeout) },
                    { "-1014", typeof(InvalidOrder) },
                    { "-1015", typeof(InvalidOrder) },
                    { "-1020", typeof(OperationRejected) },
                    { "-1021", typeof(InvalidNonce) },
                    { "-1024", typeof(BadRequest) },
                    { "-1101", typeof(ExchangeNotAvailable) },
                    { "-1115", typeof(InvalidOrder) },
                    { "-1117", typeof(InvalidOrder) },
                    { "-1123", typeof(InvalidOrder) },
                    { "-1124", typeof(InvalidOrder) },
                    { "-1126", typeof(InvalidOrder) },
                    { "-1129", typeof(BadRequest) },
                    { "-1130", typeof(BadRequest) },
                    { "-1132", typeof(BadRequest) },
                    { "-1133", typeof(BadRequest) },
                    { "-1135", typeof(BadRequest) },
                    { "-1136", typeof(BadRequest) },
                    { "-1138", typeof(InvalidOrder) },
                    { "-1137", typeof(InvalidOrder) },
                    { "-1139", typeof(OrderImmediatelyFillable) },
                    { "-1140", typeof(InvalidOrder) },
                    { "-1141", typeof(DuplicateOrderId) },
                    { "-1142", typeof(OrderNotFillable) },
                    { "-1143", typeof(OrderNotFound) },
                    { "-1144", typeof(OperationRejected) },
                    { "-1145", typeof(NotSupported) },
                    { "-1146", typeof(RequestTimeout) },
                    { "-1147", typeof(RequestTimeout) },
                    { "-1148", typeof(InvalidOrder) },
                    { "-1149", typeof(OperationRejected) },
                    { "-1150", typeof(OperationFailed) },
                    { "-1151", typeof(OperationRejected) },
                    { "-1152", typeof(AccountNotEnabled) },
                    { "-1153", typeof(InvalidOrder) },
                    { "-1154", typeof(InvalidOrder) },
                    { "-1155", typeof(OperationRejected) },
                    { "-1156", typeof(OperationFailed) },
                    { "-1157", typeof(OperationFailed) },
                    { "-1158", typeof(OperationFailed) },
                    { "-1159", typeof(AccountNotEnabled) },
                    { "-1160", typeof(AccountNotEnabled) },
                    { "-1161", typeof(OperationFailed) },
                    { "-1162", typeof(ContractUnavailable) },
                    { "-1163", typeof(InvalidAddress) },
                    { "-1164", typeof(OperationFailed) },
                    { "-1165", typeof(ArgumentsRequired) },
                    { "-1166", typeof(OperationRejected) },
                    { "-1167", typeof(BadRequest) },
                    { "-1168", typeof(BadRequest) },
                    { "-1169", typeof(PermissionDenied) },
                    { "-1170", typeof(PermissionDenied) },
                    { "-1171", typeof(PermissionDenied) },
                    { "-1172", typeof(BadRequest) },
                    { "-1173", typeof(BadRequest) },
                    { "-1174", typeof(PermissionDenied) },
                    { "-1175", typeof(BadRequest) },
                    { "-1176", typeof(BadRequest) },
                    { "-1177", typeof(InvalidOrder) },
                    { "-1178", typeof(AccountNotEnabled) },
                    { "-1179", typeof(AccountSuspended) },
                    { "-1181", typeof(ExchangeError) },
                    { "-1193", typeof(OperationRejected) },
                    { "-1194", typeof(OperationRejected) },
                    { "-1195", typeof(BadRequest) },
                    { "-1196", typeof(BadRequest) },
                    { "-1200", typeof(BadRequest) },
                    { "-1201", typeof(BadRequest) },
                    { "-1202", typeof(BadRequest) },
                    { "-1203", typeof(BadRequest) },
                    { "-1204", typeof(BadRequest) },
                    { "-1205", typeof(AccountNotEnabled) },
                    { "-1206", typeof(BadRequest) },
                    { "-1207", typeof(BadRequest) },
                    { "-1208", typeof(BadRequest) },
                    { "-1209", typeof(BadRequest) },
                    { "-2001", typeof(ExchangeNotAvailable) },
                    { "-2002", typeof(OperationFailed) },
                    { "-2003", typeof(OperationFailed) },
                    { "-2004", typeof(OperationFailed) },
                    { "-2005", typeof(RequestTimeout) },
                    { "-2010", typeof(OperationRejected) },
                    { "-2011", typeof(OperationRejected) },
                    { "-2016", typeof(OperationRejected) },
                    { "-2017", typeof(OperationRejected) },
                    { "-2018", typeof(OperationRejected) },
                    { "-2019", typeof(PermissionDenied) },
                    { "-2020", typeof(PermissionDenied) },
                    { "-2021", typeof(PermissionDenied) },
                    { "-2022", typeof(OperationRejected) },
                    { "-2023", typeof(AuthenticationError) },
                    { "-2024", typeof(AccountNotEnabled) },
                    { "-2025", typeof(AccountNotEnabled) },
                    { "-2026", typeof(BadRequest) },
                    { "-2027", typeof(OperationRejected) },
                    { "-2028", typeof(OperationRejected) },
                    { "-2029", typeof(OperationRejected) },
                    { "-2030", typeof(InsufficientFunds) },
                    { "-2031", typeof(NotSupported) },
                    { "-2032", typeof(OperationRejected) },
                    { "-2033", typeof(OperationFailed) },
                    { "-2034", typeof(InsufficientFunds) },
                    { "-2035", typeof(OperationRejected) },
                    { "-2036", typeof(NotSupported) },
                    { "-2037", typeof(ExchangeError) },
                    { "-2038", typeof(InsufficientFunds) },
                    { "-2039", typeof(NotSupported) },
                    { "-2040", typeof(ExchangeNotAvailable) },
                    { "-2041", typeof(BadRequest) },
                    { "-2042", typeof(OperationRejected) },
                    { "-2043", typeof(OperationRejected) },
                    { "-2044", typeof(BadRequest) },
                    { "-2045", typeof(BadRequest) },
                    { "-2046", typeof(BadRequest) },
                    { "-2048", typeof(BadRequest) },
                    { "-2049", typeof(BadRequest) },
                    { "-2050", typeof(BadRequest) },
                    { "-2051", typeof(OperationRejected) },
                    { "-2052", typeof(OperationRejected) },
                    { "-2053", typeof(OperationRejected) },
                    { "-2054", typeof(BadRequest) },
                    { "-2055", typeof(BadRequest) },
                    { "-2056", typeof(BadRequest) },
                    { "-2057", typeof(BadRequest) },
                    { "-3117", typeof(PermissionDenied) },
                    { "-3143", typeof(PermissionDenied) },
                    { "-3144", typeof(PermissionDenied) },
                    { "-3145", typeof(DDoSProtection) },
                    { "-4001", typeof(BadRequest) },
                    { "-4002", typeof(BadRequest) },
                    { "-4003", typeof(InsufficientFunds) },
                    { "-4004", typeof(BadRequest) },
                    { "-4005", typeof(BadRequest) },
                    { "-4006", typeof(AccountNotEnabled) },
                    { "-4007", typeof(NotSupported) },
                    { "-4008", typeof(AccountNotEnabled) },
                    { "-4009", typeof(PermissionDenied) },
                    { "-4010", typeof(PermissionDenied) },
                    { "-4011", typeof(ExchangeError) },
                    { "-4012", typeof(ExchangeError) },
                    { "-4013", typeof(OperationFailed) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "precisionMode", TICK_SIZE },
        });
    }

    /**
     * @method
     * @name hashkey#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://hashkeyglobal-apidoc.readme.io/reference/check-server-time
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetApiV1Time(parameters);
        //
        //     {
        //         "serverTime": 1721661553214
        //     }
        //
        return this.safeInteger(response, "serverTime");
    }

    /**
     * @method
     * @name hashkey#fetchStatus
     * @description the latest known information on the availability of the exchange API
     * @see https://hashkeyglobal-apidoc.readme.io/reference/test-connectivity
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
     */
    public async override Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetApiV1Ping(parameters);
        //
        // {}
        //
        return new Dictionary<string, object>() {
            { "status", "ok" },
            { "updated", null },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    /**
     * @method
     * @name hashkey#fetchMarkets
     * @description retrieves data on all markets for the exchange
     * @see https://hashkeyglobal-apidoc.readme.io/reference/exchangeinfo
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.symbol] the id of the market to fetch
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        object response = await this.publicGetApiV1ExchangeInfo(this.extend(request, parameters));
        //
        //     {
        //         "timezone": "UTC",
        //         "serverTime": "1721661653952",
        //         "brokerFilters": [],
        //         "symbols": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "symbolName": "BTCUSDT",
        //                 "status": "TRADING",
        //                 "baseAsset": "BTC",
        //                 "baseAssetName": "BTC",
        //                 "baseAssetPrecision": "0.00001",
        //                 "quoteAsset": "USDT",
        //                 "quoteAssetName": "USDT",
        //                 "quotePrecision": "0.0000001",
        //                 "retailAllowed": true,
        //                 "piAllowed": true,
        //                 "corporateAllowed": true,
        //                 "omnibusAllowed": true,
        //                 "icebergAllowed": false,
        //                 "isAggregate": false,
        //                 "allowMargin": false,
        //                 "filters": [
        //                     {
        //                         "minPrice": "0.01",
        //                         "maxPrice": "100000.00000000",
        //                         "tickSize": "0.01",
        //                         "filterType": "PRICE_FILTER"
        //                     },
        //                     {
        //                         "minQty": "0.00001",
        //                         "maxQty": "8",
        //                         "stepSize": "0.00001",
        //                         "marketOrderMinQty": "0.00001",
        //                         "marketOrderMaxQty": "4",
        //                         "filterType": "LOT_SIZE"
        //                     },
        //                     {
        //                         "minNotional": "1",
        //                         "filterType": "MIN_NOTIONAL"
        //                     },
        //                     {
        //                         "minAmount": "1",
        //                         "maxAmount": "400000",
        //                         "minBuyPrice": "0",
        //                         "marketOrderMinAmount": "1",
        //                         "marketOrderMaxAmount": "200000",
        //                         "filterType": "TRADE_AMOUNT"
        //                     },
        //                     {
        //                         "maxSellPrice": "0",
        //                         "buyPriceUpRate": "0.1",
        //                         "sellPriceDownRate": "0.1",
        //                         "filterType": "LIMIT_TRADING"
        //                     },
        //                     {
        //                         "buyPriceUpRate": "0.1",
        //                         "sellPriceDownRate": "0.1",
        //                         "filterType": "MARKET_TRADING"
        //                     },
        //                     {
        //                         "noAllowMarketStartTime": "1710485700000",
        //                         "noAllowMarketEndTime": "1710486000000",
        //                         "limitOrderStartTime": "0",
        //                         "limitOrderEndTime": "0",
        //                         "limitMinPrice": "0",
        //                         "limitMaxPrice": "0",
        //                         "filterType": "OPEN_QUOTE"
        //                     }
        //                 ]
        //             }
        //         ],
        //         "options": [ ],
        //         "contracts": [
        //             {
        //                 "filters": [
        //                     {
        //                         "minPrice": "0.1",
        //                         "maxPrice": "100000.00000000",
        //                         "tickSize": "0.1",
        //                         "filterType": "PRICE_FILTER"
        //                     },
        //                     {
        //                         "minQty": "0.001",
        //                         "maxQty": "10",
        //                         "stepSize": "0.001",
        //                         "marketOrderMinQty": "0",
        //                         "marketOrderMaxQty": "0",
        //                         "filterType": "LOT_SIZE"
        //                     },
        //                     {
        //                         "minNotional": "0",
        //                         "filterType": "MIN_NOTIONAL"
        //                     },
        //                     {
        //                         "maxSellPrice": "999999",
        //                         "buyPriceUpRate": "0.05",
        //                         "sellPriceDownRate": "0.05",
        //                         "maxEntrustNum": 200,
        //                         "maxConditionNum": 200,
        //                         "filterType": "LIMIT_TRADING"
        //                     },
        //                     {
        //                         "buyPriceUpRate": "0.05",
        //                         "sellPriceDownRate": "0.05",
        //                         "filterType": "MARKET_TRADING"
        //                     },
        //                     {
        //                         "noAllowMarketStartTime": "0",
        //                         "noAllowMarketEndTime": "0",
        //                         "limitOrderStartTime": "0",
        //                         "limitOrderEndTime": "0",
        //                         "limitMinPrice": "0",
        //                         "limitMaxPrice": "0",
        //                         "filterType": "OPEN_QUOTE"
        //                     }
        //                 ],
        //                 "exchangeId": "301",
        //                 "symbol": "BTCUSDT-PERPETUAL",
        //                 "symbolName": "BTCUSDT-PERPETUAL",
        //                 "status": "TRADING",
        //                 "baseAsset": "BTCUSDT-PERPETUAL",
        //                 "baseAssetPrecision": "0.001",
        //                 "quoteAsset": "USDT",
        //                 "quoteAssetPrecision": "0.1",
        //                 "icebergAllowed": false,
        //                 "inverse": false,
        //                 "index": "USDT",
        //                 "marginToken": "USDT",
        //                 "marginPrecision": "0.0001",
        //                 "contractMultiplier": "0.001",
        //                 "underlying": "BTC",
        //                 "riskLimits": [
        //                     {
        //                         "riskLimitId": "200000722",
        //                         "quantity": "1000.00",
        //                         "initialMargin": "0.10",
        //                         "maintMargin": "0.005",
        //                         "isWhite": false
        //                     },
        //                     {
        //                         "riskLimitId": "200000723",
        //                         "quantity": "2000.00",
        //                         "initialMargin": "0.10",
        //                         "maintMargin": "0.01",
        //                         "isWhite": false
        //                     }
        //                 ]
        //             }
        //         ],
        //         "coins": [
        //            {
        //                 "orgId": "9001",
        //                 "coinId": "BTC",
        //                 "coinName": "BTC",
        //                 "coinFullName": "Bitcoin",
        //                 "allowWithdraw": true,
        //                 "allowDeposit": true,
        //                 "tokenType": "CHAIN_TOKEN",
        //                 "chainTypes": [
        //                     {
        //                         "chainType": "Bitcoin",
        //                         "withdrawFee": "0",
        //                         "minWithdrawQuantity": "0.002",
        //                         "maxWithdrawQuantity": "0",
        //                         "minDepositQuantity": "0.0005",
        //                         "allowDeposit": true,
        //                         "allowWithdraw": true
        //                     }
        //                 ]
        //             }
        //         ]
        //     }
        //
        object spotMarkets = this.safeList(response, "symbols", new List<object>() {});
        object swapMarkets = this.safeList(response, "contracts", new List<object>() {});
        object markets = this.arrayConcat(spotMarkets, swapMarkets);
        if (isTrue(this.isEmpty(markets)))
        {
            markets = new List<object>() {response}; // if user provides params.symbol the exchange returns a single object insted of list of objects
        }
        return this.parseMarkets(markets);
    }

    public override object parseMarket(object market)
    {
        // spot
        //     {
        //         "symbol": "BTCUSDT",
        //         "symbolName": "BTCUSDT",
        //         "status": "TRADING",
        //         "baseAsset": "BTC",
        //         "baseAssetName": "BTC",
        //         "baseAssetPrecision": "0.00001",
        //         "quoteAsset": "USDT",
        //         "quoteAssetName": "USDT",
        //         "quotePrecision": "0.0000001",
        //         "retailAllowed": true,
        //         "piAllowed": true,
        //         "corporateAllowed": true,
        //         "omnibusAllowed": true,
        //         "icebergAllowed": false,
        //         "isAggregate": false,
        //         "allowMargin": false,
        //         "filters": [
        //             {
        //                 "minPrice": "0.01",
        //                 "maxPrice": "100000.00000000",
        //                 "tickSize": "0.01",
        //                 "filterType": "PRICE_FILTER"
        //             },
        //             {
        //                 "minQty": "0.00001",
        //                 "maxQty": "8",
        //                 "stepSize": "0.00001",
        //                 "marketOrderMinQty": "0.00001",
        //                 "marketOrderMaxQty": "4",
        //                 "filterType": "LOT_SIZE"
        //             },
        //             {
        //                 "minNotional": "1",
        //                 "filterType": "MIN_NOTIONAL"
        //             },
        //             {
        //                 "minAmount": "1",
        //                 "maxAmount": "400000",
        //                 "minBuyPrice": "0",
        //                 "marketOrderMinAmount": "1",
        //                 "marketOrderMaxAmount": "200000",
        //                 "filterType": "TRADE_AMOUNT"
        //             },
        //             {
        //                 "maxSellPrice": "0",
        //                 "buyPriceUpRate": "0.1",
        //                 "sellPriceDownRate": "0.1",
        //                 "filterType": "LIMIT_TRADING"
        //             },
        //             {
        //                 "buyPriceUpRate": "0.1",
        //                 "sellPriceDownRate": "0.1",
        //                 "filterType": "MARKET_TRADING"
        //             },
        //             {
        //                 "noAllowMarketStartTime": "1710485700000",
        //                 "noAllowMarketEndTime": "1710486000000",
        //                 "limitOrderStartTime": "0",
        //                 "limitOrderEndTime": "0",
        //                 "limitMinPrice": "0",
        //                 "limitMaxPrice": "0",
        //                 "filterType": "OPEN_QUOTE"
        //             }
        //         ]
        //     }
        //
        // swap
        //     {
        //         "filters": [
        //             {
        //                 "minPrice": "0.1",
        //                 "maxPrice": "100000.00000000",
        //                 "tickSize": "0.1",
        //                 "filterType": "PRICE_FILTER"
        //             },
        //             {
        //                 "minQty": "0.001",
        //                 "maxQty": "10",
        //                 "stepSize": "0.001",
        //                 "marketOrderMinQty": "0",
        //                 "marketOrderMaxQty": "0",
        //                 "filterType": "LOT_SIZE"
        //             },
        //             {
        //                 "minNotional": "0",
        //                 "filterType": "MIN_NOTIONAL"
        //             },
        //             {
        //                 "maxSellPrice": "999999",
        //                 "buyPriceUpRate": "0.05",
        //                 "sellPriceDownRate": "0.05",
        //                 "maxEntrustNum": 200,
        //                 "maxConditionNum": 200,
        //                 "filterType": "LIMIT_TRADING"
        //             },
        //             {
        //                 "buyPriceUpRate": "0.05",
        //                 "sellPriceDownRate": "0.05",
        //                 "filterType": "MARKET_TRADING"
        //             },
        //             {
        //                 "noAllowMarketStartTime": "0",
        //                 "noAllowMarketEndTime": "0",
        //                 "limitOrderStartTime": "0",
        //                 "limitOrderEndTime": "0",
        //                 "limitMinPrice": "0",
        //                 "limitMaxPrice": "0",
        //                 "filterType": "OPEN_QUOTE"
        //             }
        //         ],
        //         "exchangeId": "301",
        //         "symbol": "BTCUSDT-PERPETUAL",
        //         "symbolName": "BTCUSDT-PERPETUAL",
        //         "status": "TRADING",
        //         "baseAsset": "BTCUSDT-PERPETUAL",
        //         "baseAssetPrecision": "0.001",
        //         "quoteAsset": "USDT",
        //         "quoteAssetPrecision": "0.1",
        //         "icebergAllowed": false,
        //         "inverse": false,
        //         "index": "USDT",
        //         "marginToken": "USDT",
        //         "marginPrecision": "0.0001",
        //         "contractMultiplier": "0.001",
        //         "underlying": "BTC",
        //         "riskLimits": [
        //             {
        //                 "riskLimitId": "200000722",
        //                 "quantity": "1000.00",
        //                 "initialMargin": "0.10",
        //                 "maintMargin": "0.005",
        //                 "isWhite": false
        //             },
        //             {
        //                 "riskLimitId": "200000723",
        //                 "quantity": "2000.00",
        //                 "initialMargin": "0.10",
        //                 "maintMargin": "0.01",
        //                 "isWhite": false
        //             }
        //         ]
        //     }
        //
        object marketId = this.safeString(market, "symbol");
        object quoteId = this.safeString(market, "quoteAsset");
        object quote = this.safeCurrencyCode(quoteId);
        object settleId = this.safeString(market, "marginToken");
        object settle = this.safeCurrencyCode(settleId);
        object baseId = this.safeString(market, "baseAsset");
        object marketType = ((object)"spot");
        object isSpot = true;
        object isSwap = false;
        object suffix = "";
        object parts = ((string)marketId).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
        object secondPart = this.safeString(parts, 1);
        if (isTrue(isEqual(secondPart, "PERPETUAL")))
        {
            marketType = "swap";
            isSpot = false;
            isSwap = true;
            baseId = this.safeString(market, "underlying");
            suffix = add(suffix, add(":", settleId));
        }
        object bs = this.safeCurrencyCode(baseId);
        object symbol = add(add(add(bs, "/"), quote), suffix);
        object status = this.safeString(market, "status");
        object active = isEqual(status, "TRADING");
        object isLinear = null;
        object subType = null;
        object isInverse = this.safeBool(market, "inverse");
        if (isTrue(!isEqual(isInverse, null)))
        {
            if (isTrue(isInverse))
            {
                isLinear = false;
                subType = "inverse";
            } else
            {
                isLinear = true;
                subType = "linear";
            }
        }
        object filtersList = this.safeList(market, "filters", new List<object>() {});
        object filters = this.indexBy(filtersList, "filterType");
        object priceFilter = this.safeDict(filters, "PRICE_FILTER", new Dictionary<string, object>() {});
        object amountFilter = this.safeDict(filters, "LOT_SIZE", new Dictionary<string, object>() {});
        object costFilter = this.safeDict(filters, "MIN_NOTIONAL", new Dictionary<string, object>() {});
        object minCostString = this.omitZero(this.safeString(costFilter, "min_notional"));
        object contractSizeString = this.safeString(market, "contractMultiplier");
        object amountPrecisionString = this.safeString(amountFilter, "stepSize");
        object amountMinLimitString = this.safeString(amountFilter, "minQty");
        object amountMaxLimitString = this.safeString(amountFilter, "maxQty");
        object minLeverage = null;
        object maxLeverage = null;
        if (isTrue(isSwap))
        {
            amountPrecisionString = Precise.stringDiv(amountPrecisionString, contractSizeString);
            amountMinLimitString = Precise.stringDiv(amountMinLimitString, contractSizeString);
            amountMaxLimitString = Precise.stringDiv(amountMaxLimitString, contractSizeString);
            object riskLimits = this.safeList(market, "riskLimits");
            if (isTrue(!isEqual(riskLimits, null)))
            {
                object first = this.safeDict(riskLimits, 0);
                object arrayLength = getArrayLength(riskLimits);
                object last = this.safeDict(riskLimits, subtract(arrayLength, 1));
                object minInitialMargin = this.safeString(first, "initialMargin");
                object maxInitialMargin = this.safeString(last, "initialMargin");
                if (isTrue(Precise.stringGt(minInitialMargin, maxInitialMargin)))
                {
                    var minInitialMarginmaxInitialMarginVariable = new List<object>() {maxInitialMargin, minInitialMargin};
                    minInitialMargin = ((IList<object>)minInitialMarginmaxInitialMarginVariable)[0];
                    maxInitialMargin = ((IList<object>)minInitialMarginmaxInitialMarginVariable)[1];
                }
                minLeverage = this.parseToInt(Precise.stringDiv("1", maxInitialMargin));
                maxLeverage = this.parseToInt(Precise.stringDiv("1", minInitialMargin));
            }
        }
        object tradingFees = this.safeDict(this.fees, "trading");
        object fees = ((bool) isTrue(isSpot)) ? this.safeDict(tradingFees, "spot") : this.safeDict(tradingFees, "swap");
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", marketId },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "active", active },
            { "type", marketType },
            { "subType", subType },
            { "spot", isSpot },
            { "margin", this.safeBool(market, "allowMargin") },
            { "swap", isSwap },
            { "future", false },
            { "option", false },
            { "contract", isSwap },
            { "settle", settle },
            { "settleId", settleId },
            { "contractSize", this.parseNumber(contractSizeString) },
            { "linear", isLinear },
            { "inverse", isInverse },
            { "taker", this.safeNumber(fees, "taker") },
            { "maker", this.safeNumber(fees, "maker") },
            { "percentage", this.safeBool(fees, "percentage") },
            { "tierBased", this.safeBool(fees, "tierBased") },
            { "feeSide", this.safeString(fees, "feeSide") },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.parseNumber(amountPrecisionString) },
                { "price", this.safeNumber(priceFilter, "tickSize") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", this.parseNumber(amountMinLimitString) },
                    { "max", this.parseNumber(amountMaxLimitString) },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", this.safeNumber(priceFilter, "minPrice") },
                    { "max", this.safeNumber(priceFilter, "maxPrice") },
                } },
                { "leverage", new Dictionary<string, object>() {
                    { "min", minLeverage },
                    { "max", maxLeverage },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", this.parseNumber(minCostString) },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        });
    }

    /**
     * @method
     * @name hashkey#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://hashkeyglobal-apidoc.readme.io/reference/exchangeinfo
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetApiV1ExchangeInfo(parameters);
        object coins = this.safeList(response, "coins");
        //
        //     {
        //         ...
        //         "coins": [
        //             {
        //                 "orgId": "9001",
        //                 "coinId": "BTC",
        //                 "coinName": "BTC",
        //                 "coinFullName": "Bitcoin",
        //                 "allowWithdraw": true,
        //                 "allowDeposit": true,
        //                 "tokenType": "CHAIN_TOKEN",
        //                 "chainTypes": [
        //                     {
        //                         "chainType": "Bitcoin",
        //                         "withdrawFee": "0",
        //                         "minWithdrawQuantity": "0.002",
        //                         "maxWithdrawQuantity": "0",
        //                         "minDepositQuantity": "0.0005",
        //                         "allowDeposit": true,
        //                         "allowWithdraw": true
        //                     }
        //                 ]
        //             }
        //         ]
        //     }
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(coins)); postFixIncrement(ref i))
        {
            object currecy = getValue(coins, i);
            object currencyId = this.safeString(currecy, "coinId");
            object code = this.safeCurrencyCode(currencyId);
            object allowWithdraw = this.safeBool(currecy, "allowWithdraw");
            object allowDeposit = this.safeBool(currecy, "allowDeposit");
            object networks = this.safeList(currecy, "chainTypes");
            object networksById = this.safeDict(this.options, "networksById");
            object parsedNetworks = new Dictionary<string, object>() {};
            for (object j = 0; isLessThan(j, getArrayLength(networks)); postFixIncrement(ref j))
            {
                object network = getValue(networks, j);
                object networkId = this.safeString(network, "chainType");
                object networkName = this.safeString(networksById, networkId, networkId);
                object maxWithdrawQuantity = this.omitZero(this.safeString(network, "maxWithdrawQuantity"));
                object networkDeposit = this.safeBool(network, "allowDeposit");
                object networkWithdraw = this.safeBool(network, "allowWithdraw");
                ((IDictionary<string,object>)parsedNetworks)[(string)networkName] = new Dictionary<string, object>() {
                    { "id", networkId },
                    { "network", networkName },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", this.safeNumber(network, "minWithdrawQuantity") },
                            { "max", this.parseNumber(maxWithdrawQuantity) },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", this.safeNumber(network, "minDepositQuantity") },
                            { "max", null },
                        } },
                    } },
                    { "active", isTrue(networkDeposit) && isTrue(networkWithdraw) },
                    { "deposit", networkDeposit },
                    { "withdraw", networkWithdraw },
                    { "fee", this.safeNumber(network, "withdrawFee") },
                    { "precision", null },
                    { "info", network },
                };
            }
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", currencyId },
                { "code", code },
                { "precision", null },
                { "type", this.parseCurrencyType(this.safeString(currecy, "tokenType")) },
                { "name", this.safeString(currecy, "coinFullName") },
                { "active", isTrue(allowWithdraw) && isTrue(allowDeposit) },
                { "deposit", allowDeposit },
                { "withdraw", allowWithdraw },
                { "fee", null },
                { "limits", new Dictionary<string, object>() {
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "networks", parsedNetworks },
                { "info", currecy },
            };
        }
        return result;
    }

    public virtual object parseCurrencyType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "CHAIN_TOKEN", "crypto" },
            { "ERC20_TOKEN", "crypto" },
            { "BSC_TOKEN", "crypto" },
            { "REAL_MONEY", "fiat" },
        };
        return this.safeString(types, type);
    }

    /**
     * @method
     * @name hashkey#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-order-book
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return (maximum value is 200)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.publicGetQuoteV1Depth(this.extend(request, parameters));
        //
        //     {
        //         "t": 1721681436393,
        //         "b": [
        //             ["67902.49", "0.00112"],
        //             ["67901.08", "0.01014"]
        //             ...
        //         ],
        //         "a": [
        //             ["67905.99", "0.87134"],
        //             ["67906", "0.57361"]
        //             ...
        //         ]
        //     }
        //
        object timestamp = this.safeInteger(response, "t");
        return this.parseOrderBook(response, symbol, timestamp, "b", "a");
    }

    /**
     * @method
     * @name hashkey#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-recent-trade-list
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch (maximum value is 100)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.publicGetQuoteV1Trades(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "t": 1721682745779,
        //             "p": "67835.99",
        //             "q": "0.00017",
        //             "ibm": true
        //         },
        //         ...
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    /**
     * @method
     * @name hashkey#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-account-trade-list
     * @see https://hashkeyglobal-apidoc.readme.io/reference/query-futures-trades
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-sub-account-user
     * @param {string} symbol *is mandatory for swap markets* unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum amount of trades to fetch (default 200, max 500)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch trades for (default 'spot')
     * @param {int} [params.until] the latest time in ms to fetch trades for, only supports the last 30 days timeframe
     * @param {string} [params.fromId] srarting trade id
     * @param {string} [params.toId] ending trade id
     * @param {string} [params.clientOrderId] *spot markets only* filter trades by orderId
     * @param {string} [params.accountId] account id to fetch the orders from
     * @returns {Trade[]} a list of [trade structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchMyTrades";
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = "spot";
        var marketTypeparametersVariable = this.handleMarketTypeAndParams(methodName, market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, methodName, "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object accountId = null;
        var accountIdparametersVariable = this.handleOptionAndParams(parameters, methodName, "accountId");
        accountId = ((IList<object>)accountIdparametersVariable)[0];
        parameters = ((IList<object>)accountIdparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(!isEqual(market, null)))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
            if (isTrue(!isEqual(accountId, null)))
            {
                ((IDictionary<string,object>)request)["accountId"] = accountId;
            }
            response = await this.privateGetApiV1AccountTrades(this.extend(request, parameters));
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a symbol argument for swap markets")) ;
            }
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            if (isTrue(!isEqual(accountId, null)))
            {
                ((IDictionary<string,object>)request)["subAccountId"] = accountId;
                response = await this.privateGetApiV1FuturesSubAccountUserTrades(this.extend(request, parameters));
            } else
            {
                response = await this.privateGetApiV1FuturesUserTrades(this.extend(request, parameters));
            }
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), marketType), " type of markets")) ;
        }
        return this.parseTrades(response, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades
        //
        //     {
        //         "t": 1721682745779,
        //         "p": "67835.99",
        //         "q": "0.00017",
        //         "ibm": true
        //     }
        //
        // fetchMyTrades spot
        //
        //     {
        //         "id": "1739352552862964736",
        //         "clientOrderId": "1722082982086472",
        //         "ticketId": "1739352552795029504",
        //         "symbol": "ETHUSDT",
        //         "symbolName": "ETHUSDT",
        //         "orderId": "1739352552762301440",
        //         "matchOrderId": "0",
        //         "price": "3289.96",
        //         "qty": "0.001",
        //         "commission": "0.0000012",
        //         "commissionAsset": "ETH",
        //         "time": "1722082982097",
        //         "isBuyer": true,
        //         "isMaker": false,
        //         "fee": {
        //             "feeCoinId": "ETH",
        //             "feeCoinName": "ETH",
        //             "fee": "0.0000012"
        //         },
        //         "feeCoinId": "ETH",
        //         "feeAmount": "0.0000012",
        //         "makerRebate": "0"
        //     }
        //
        // fetchMyTrades swap
        //     {
        //         "time": "1722429951648",
        //         "tradeId": "1742263144691139328",
        //         "orderId": "1742263144028363776",
        //         "symbol": "ETHUSDT-PERPETUAL",
        //         "price": "3327.54",
        //         "quantity": "4",
        //         "commissionAsset": "USDT",
        //         "commission": "0.00798609",
        //         "makerRebate": "0",
        //         "type": "LIMIT",
        //         "side": "BUY_OPEN",
        //         "realizedPnl": "0",
        //         "isMarker": false
        //     }
        object timestamp = this.safeInteger2(trade, "t", "time");
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market);
        object side = this.safeStringLower(trade, "side"); // swap trades have side param
        if (isTrue(!isEqual(side, null)))
        {
            side = this.safeString(((string)side).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>(), 0);
        }
        object isBuyer = this.safeBool(trade, "isBuyer");
        if (isTrue(!isEqual(isBuyer, null)))
        {
            side = ((bool) isTrue(isBuyer)) ? "buy" : "sell";
        }
        object takerOrMaker = null;
        object isMaker = this.safeBoolN(trade, new List<object>() {"isMaker", "isMarker"});
        if (isTrue(!isEqual(isMaker, null)))
        {
            takerOrMaker = ((bool) isTrue(isMaker)) ? "maker" : "taker";
        }
        object isBuyerMaker = this.safeBool(trade, "ibm");
        // if public trade
        if (isTrue(!isEqual(isBuyerMaker, null)))
        {
            takerOrMaker = "taker";
            side = ((bool) isTrue(isBuyerMaker)) ? "sell" : "buy";
        }
        object feeCost = this.safeString(trade, "commission");
        object feeCurrncyId = this.safeString(trade, "commissionAsset");
        object feeInfo = this.safeDict(trade, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeInfo, null)))
        {
            feeCost = this.safeString(feeInfo, "fee");
            feeCurrncyId = this.safeString(feeInfo, "feeCoinId");
        }
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(feeCost) },
                { "currency", this.safeCurrencyCode(feeCurrncyId) },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", this.safeString2(trade, "id", "tradeId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "side", side },
            { "price", this.safeString2(trade, "p", "price") },
            { "amount", this.safeStringN(trade, new List<object>() {"q", "qty", "quantity"}) },
            { "cost", null },
            { "takerOrMaker", takerOrMaker },
            { "type", null },
            { "order", this.safeString(trade, "orderId") },
            { "fee", fee },
            { "info", trade },
        }, market);
    }

    /**
     * @method
     * @name hashkey#fetchOHLCV
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-kline
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchOHLCV";
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, methodName, "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, 1000);
        }
        object market = this.market(symbol);
        timeframe = this.safeString(this.timeframes, timeframe, timeframe);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "interval", timeframe },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, methodName, "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.publicGetQuoteV1Klines(this.extend(request, parameters));
        //
        //     [
        //         [
        //             1721684280000,
        //             "67832.49",
        //             "67862.5",
        //             "67832.49",
        //             "67861.44",
        //             "0.01122",0,
        //             "761.2763533",68,
        //             "0.00561",
        //             "380.640643"
        //         ],
        //         ...
        //     ]
        //
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         1721684280000,
        //         "67832.49",
        //         "67862.5",
        //         "67832.49",
        //         "67861.44",
        //         "0.01122",0,
        //         "761.2763533",68,
        //         "0.00561",
        //         "380.640643"
        //     ]
        //
        return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
    }

    /**
     * @method
     * @name hashkey#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-24hr-ticker-price-change
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetQuoteV1Ticker24hr(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "t": 1721685896846,
        //             "s": "BTCUSDT-PERPETUAL",
        //             "c": "67756.7",
        //             "h": "68479.9",
        //             "l": "66594.3",
        //             "o": "68279.7",
        //             "b": "67756.6",
        //             "a": "67756.7",
        //             "v": "1604722",
        //             "qv": "108827258.7761"
        //         }
        //     ]
        //
        object ticker = this.safeDict(response, 0, new Dictionary<string, object>() {});
        return this.parseTicker(ticker, market);
    }

    /**
     * @method
     * @name hashkey#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-24hr-ticker-price-change
     * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.publicGetQuoteV1Ticker24hr(parameters);
        return this.parseTickers(response, symbols);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "t": 1721685896846,
        //         "s": "BTCUSDT-PERPETUAL",
        //         "c": "67756.7",
        //         "h": "68479.9",
        //         "l": "66594.3",
        //         "o": "68279.7",
        //         "b": "67756.6",
        //         "a": "67756.7",
        //         "v": "1604722",
        //         "qv": "108827258.7761"
        //     }
        //
        object timestamp = this.safeInteger(ticker, "t");
        object marketId = this.safeString(ticker, "s");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object last = this.safeString(ticker, "c");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "h") },
            { "low", this.safeString(ticker, "l") },
            { "bid", this.safeString(ticker, "b") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "a") },
            { "askVolume", null },
            { "vwap", null },
            { "open", this.safeString(ticker, "o") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "v") },
            { "quoteVolume", this.safeString(ticker, "qv") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name hashkey#fetchLastPrices
     * @description fetches the last price for multiple markets
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-symbol-price-ticker
     * @param {string[]} [symbols] unified symbols of the markets to fetch the last prices
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.symbol] the id of the market to fetch last price for
     * @returns {object} a dictionary of lastprices structures
     */
    public async override Task<object> fetchLastPrices(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {};
        object response = await this.publicGetQuoteV1TickerPrice(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "s": "BTCUSDT-PERPETUAL",
        //             "p": "64871"
        //         },
        //         ...
        //     ]
        //
        return this.parseLastPrices(response, symbols);
    }

    public override object parseLastPrice(object entry, object market = null)
    {
        object marketId = this.safeString(entry, "s");
        market = this.safeMarket(marketId, market);
        return new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", null },
            { "datetime", null },
            { "price", this.safeNumber(entry, "p") },
            { "side", null },
            { "info", entry },
        };
    }

    /**
     * @method
     * @name hashkey#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-account-information
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.accountId] account ID, for Master Key only
     * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch balance for (default 'spot')
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object methodName = "fetchBalance";
        object marketType = "spot";
        var marketTypeparametersVariable = this.handleMarketTypeAndParams(methodName, null, parameters, marketType);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "swap")))
        {
            object response = await this.privateGetApiV1FuturesBalance(parameters);
            //
            //     [
            //         {
            //             "balance": "30.63364672",
            //             "availableBalance": "28.85635534",
            //             "positionMargin": "4.3421",
            //             "orderMargin": "0",
            //             "asset": "USDT",
            //             "crossUnRealizedPnl": "2.5649"
            //         }
            //     ]
            //
            object balance = this.safeDict(response, 0, new Dictionary<string, object>() {});
            return this.parseSwapBalance(balance);
        } else if (isTrue(isEqual(marketType, "spot")))
        {
            object response = await this.privateGetApiV1Account(this.extend(request, parameters));
            //
            //     {
            //         "balances": [
            //             {
            //                 "asset":"USDT",
            //                 "assetId":"USDT",
            //                 "assetName":"USDT",
            //                 "total":"40",
            //                 "free":"40",
            //                 "locked":"0"
            //             },
            //             ...
            //         ],
            //         "userId": "1732885739572845312"
            //     }
            //
            return this.parseBalance(response);
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), marketType), " type of markets")) ;
        }
    }

    public override object parseBalance(object balance)
    {
        //
        //     {
        //         "balances": [
        //             {
        //                 "asset":"USDT",
        //                 "assetId":"USDT",
        //                 "assetName":"USDT",
        //                 "total":"40",
        //                 "free":"40",
        //                 "locked":"0"
        //             },
        //             ...
        //         ],
        //         "userId": "1732885739572845312"
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", balance },
        };
        object balances = this.safeList(balance, "balances", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balanceEntry = getValue(balances, i);
            object currencyId = this.safeString(balanceEntry, "asset");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(balanceEntry, "total");
            ((IDictionary<string,object>)account)["free"] = this.safeString(balanceEntry, "free");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balanceEntry, "locked");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public virtual object parseSwapBalance(object balance)
    {
        //
        //     {
        //         "balance": "30.63364672",
        //         "availableBalance": "28.85635534",
        //         "positionMargin": "4.3421",
        //         "orderMargin": "0",
        //         "asset": "USDT",
        //         "crossUnRealizedPnl": "2.5649"
        //     }
        //
        object currencyId = this.safeString(balance, "asset");
        object code = this.safeCurrencyCode(currencyId);
        object account = this.account();
        ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "balance");
        object positionMargin = this.safeString(balance, "positionMargin");
        object orderMargin = this.safeString(balance, "orderMargin");
        ((IDictionary<string,object>)account)["used"] = Precise.stringAdd(positionMargin, orderMargin);
        object result = new Dictionary<string, object>() {
            { "info", balance },
        };
        ((IDictionary<string,object>)result)[(string)code] = account;
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name hashkey#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-deposit-address
     * @param {string} code unified currency code (default is 'USDT')
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network] network for fetch deposit address (default is 'ETH')
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
        };
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(isEqual(networkCode, null)))
        {
            networkCode = this.defaultNetworkCode(code);
        }
        ((IDictionary<string,object>)request)["chainType"] = this.networkCodeToId(networkCode, code);
        object response = await this.privateGetApiV1AccountDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         "canDeposit": true,
        //         "address": "0x61AAd7F763e2C7fF1CC996918740F67f9dC8BF4e",
        //         "addressExt": "",
        //         "minQuantity": "1",
        //         "needAddressTag": false,
        //         "requiredConfirmTimes": 64,
        //         "canWithdrawConfirmTimes": 64,
        //         "coinType": "ERC20_TOKEN"
        //     }
        //
        object depositAddress = this.parseDepositAddress(response, currency);
        ((IDictionary<string,object>)depositAddress)["network"] = networkCode;
        return depositAddress;
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "canDeposit": true,
        //         "address": "0x61AAd7F763e2C7fF1CC996918740F67f9dC8BF4e",
        //         "addressExt": "",
        //         "minQuantity": "1",
        //         "needAddressTag": false,
        //         "requiredConfirmTimes": 64,
        //         "canWithdrawConfirmTimes": 64,
        //         "coinType": "ERC20_TOKEN"
        //     }
        //
        object address = this.safeString(depositAddress, "address");
        this.checkAddress(address);
        object tag = this.safeString(depositAddress, "addressExt");
        if (isTrue(isEqual(tag, "")))
        {
            tag = null;
        }
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", getValue(currency, "code") },
            { "network", null },
            { "address", address },
            { "tag", tag },
        };
    }

    /**
     * @method
     * @name hashkey#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-deposit-history
     * @param {string} code unified currency code of the currency transferred
     * @param {int} [since] the earliest time in ms to fetch transfers for (default 24 hours ago)
     * @param {int} [limit] the maximum number of transfer structures to retrieve (default 50, max 200)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch transfers for (default time now)
     * @param {int} [params.fromId] starting ID (To be released)
     * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchDeposits";
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, methodName, "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.privateGetApiV1AccountDepositOrders(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "time": "1721641082163",
        //             "coin": "TRXUSDT",
        //             "coinName": "TRXUSDT",
        //             "address": "TBA6CypYJizwA9XdC7Ubgc5F1bxrQ7SqPt",
        //             "quantity": "86.00000000000000000000",
        //             "status": 4,
        //             "statusCode": "4",
        //             "txId": "0970c14da4d7412295fa7b21c03a08da319e746a0d59ef14462a74183d118da4"
        //         }
        //     ]
        //
        return this.parseTransactions(response, currency, since, limit, new Dictionary<string, object>() {
            { "type", "deposit" },
        });
    }

    /**
     * @method
     * @name hashkey#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://hashkeyglobal-apidoc.readme.io/reference/withdrawal-records
     * @param {string} code unified currency code of the currency transferred
     * @param {int} [since] the earliest time in ms to fetch transfers for (default 24 hours ago)
     * @param {int} [limit] the maximum number of transfer structures to retrieve (default 50, max 200)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch transfers for (default time now)
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchWithdrawals";
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, methodName, "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.privateGetApiV1AccountWithdrawOrders(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "time": "1723545505366",
        //             "id": "W611267400947572736",
        //             "coin": "USDT",
        //             "coinId": "USDT",
        //             "coinName": "USDT",
        //             "address": "TQbkBMnWnJNGTAUpFS4kvv4NRLzUAnGAes",
        //             "quantity": "2.00000000",
        //             "arriveQuantity": "2.00000000",
        //             "txId": "f83f94e7d2e81fbec98c66c25d6615872cc2d426145629b6cf22e5e0a0753715",
        //             "addressUrl": "TQbkBMnWnJNGTAUpFS4kvv4NRLzUAnGAes",
        //             "feeCoinId": "USDT",
        //             "feeCoinName": "USDT",
        //             "fee": "1.00000000",
        //             "remark": "",
        //             "platform": ""
        //         }
        //     ]
        //
        return this.parseTransactions(response, currency, since, limit, new Dictionary<string, object>() {
            { "type", "withdrawal" },
        });
    }

    /**
     * @method
     * @name hashkey#withdraw
     * @description make a withdrawal
     * @see https://hashkeyglobal-apidoc.readme.io/reference/withdraw
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network] network for withdraw
     * @param {string} [params.clientOrderId] client order id
     * @param {string} [params.platform] the platform to withdraw to (hashkey, HashKey HK)
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "address", address },
            { "quantity", amount },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["addressExt"] = tag;
        }
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["chainType"] = this.networkCodeToId(networkCode);
        }
        object response = await this.privatePostApiV1AccountWithdraw(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "id": "0",
        //         "orderId": "W611267400947572736",
        //         "accountId": "1732885739589466115"
        //     }
        //
        return this.parseTransaction(response, currency);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        //  fetchDeposits
        //     {
        //         "time": "1721641082163",
        //         "coin": "TRXUSDT", // todo how to parse it?
        //         "coinName": "TRXUSDT",
        //         "address": "TBA6CypYJizwA9XdC7Ubgc5F1bxrQ7SqPt",
        //         "quantity": "86.00000000000000000000",
        //         "status": 4,
        //         "statusCode": "4",
        //         "txId": "0970c14da4d7412295fa7b21c03a08da319e746a0d59ef14462a74183d118da4"
        //     }
        //
        // fetchWithdrawals
        //     {
        //         "time": "1723545505366",
        //         "id": "W611267400947572736",
        //         "coin": "USDT",
        //         "coinId": "USDT",
        //         "coinName": "USDT",
        //         "address": "TQbkBMnWnJNGTAUpFS4kvv4NRLzUAnGAes",
        //         "quantity": "2.00000000",
        //         "arriveQuantity": "2.00000000",
        //         "txId": "f83f94e7d2e81fbec98c66c25d6615872cc2d426145629b6cf22e5e0a0753715",
        //         "addressUrl": "TQbkBMnWnJNGTAUpFS4kvv4NRLzUAnGAes",
        //         "feeCoinId": "USDT",
        //         "feeCoinName": "USDT",
        //         "fee": "1.00000000",
        //         "remark": "",
        //         "platform": ""
        //     }
        //
        // withdraw
        //     {
        //         "success": true,
        //         "id": "0",
        //         "orderId": "W611267400947572736",
        //         "accountId": "1732885739589466115"
        //     }
        //
        object id = this.safeString2(transaction, "id", "orderId");
        object address = this.safeString(transaction, "address");
        object status = this.safeString(transaction, "status"); // for fetchDeposits
        if (isTrue(isEqual(status, null)))
        {
            object success = this.safeBool(transaction, "success", false); // for withdraw
            if (isTrue(success))
            {
                status = "ok";
            } else
            {
                object addressUrl = this.safeString(transaction, "addressUrl"); // for fetchWithdrawals
                if (isTrue(!isEqual(addressUrl, null)))
                {
                    status = "ok";
                }
            }
        }
        object txid = this.safeString(transaction, "txId");
        object coin = this.safeString(transaction, "coin");
        object code = this.safeCurrencyCode(coin, currency);
        object timestamp = this.safeInteger(transaction, "time");
        object amount = this.safeNumber(transaction, "quantity");
        object feeCost = this.safeNumber(transaction, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", code },
            };
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", null },
            { "address", address },
            { "addressTo", null },
            { "addressFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", null },
            { "amount", amount },
            { "currency", code },
            { "status", this.parseTransactionStatus(status) },
            { "updated", null },
            { "internal", null },
            { "comment", null },
            { "fee", fee },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "1", "pending" },
            { "2", "pending" },
            { "3", "failed" },
            { "4", "ok" },
            { "5", "pending" },
            { "6", "ok" },
            { "7", "failed" },
            { "8", "cancelled" },
            { "9", "failed" },
            { "10", "failed" },
            { "successful", "ok" },
            { "success", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name hashkey#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://hashkeyglobal-apidoc.readme.io/reference/new-account-transfer
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account id to transfer from
     * @param {string} toAccount account id to transfer to
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] a unique id for the transfer
     * @param {string} [params.remark] a note for the transfer
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "quantity", this.currencyToPrecision(code, amount) },
            { "fromAccountId", fromAccount },
            { "toAccountId", toAccount },
        };
        object response = await this.privatePostApiV1AccountAssetTransfer(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "timestamp": 1722260230773,
        //         "clientOrderId": "",
        //         "orderId": "1740839420695806720"
        //     }
        //
        return this.parseTransfer(response, currency);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        object timestamp = this.safeInteger(transfer, "timestamp");
        object currencyId = this.safeString(currency, "id");
        object status = null;
        object success = this.safeBool(transfer, "success", false);
        if (isTrue(success))
        {
            status = "ok";
        }
        return new Dictionary<string, object>() {
            { "id", this.safeString(transfer, "orderId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", status },
            { "info", transfer },
        };
    }

    /**
     * @method
     * @name hashkey#fetchAccounts
     * @description fetch all the accounts associated with a profile
     * @see https://hashkeyglobal-apidoc.readme.io/reference/query-sub-account
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
     */
    public async override Task<object> fetchAccounts(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetApiV1AccountType(parameters);
        //
        //     [
        //         {
        //             "accountId": "1732885739589466112",
        //             "accountLabel": "Main Trading Account",
        //             "accountType": 1,
        //             "accountIndex": 0
        //         },
        //         ...
        //     ]
        //
        return this.parseAccounts(response, parameters);
    }

    public override object parseAccount(object account)
    {
        object accountLabel = this.safeString(account, "accountLabel");
        object label = "";
        if (isTrue(isTrue(isEqual(accountLabel, "Main Trading Account")) || isTrue(isEqual(accountLabel, "Main Future Account"))))
        {
            label = "main";
        } else if (isTrue(isTrue(isEqual(accountLabel, "Sub Main Trading Account")) || isTrue(isEqual(accountLabel, "Sub Main Future Account"))))
        {
            label = "sub";
        }
        object accountType = this.parseAccountType(this.safeString(account, "accountType"));
        object type = add(add(label, " "), accountType);
        return new Dictionary<string, object>() {
            { "id", this.safeString(account, "accountId") },
            { "type", type },
            { "code", null },
            { "info", account },
        };
    }

    public virtual object parseAccountType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "1", "spot account" },
            { "3", "swap account" },
            { "5", "custody account" },
            { "6", "fiat account" },
        };
        return this.safeString(types, type, type);
    }

    public virtual object encodeAccountType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "spot", "1" },
            { "swap", "3" },
            { "custody", "5" },
        };
        return this.safeInteger(types, type, type);
    }

    public virtual object encodeFlowType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "trade", "1" },
            { "fee", "3" },
            { "transfer", "51" },
            { "deposit", "900" },
            { "withdraw", "904" },
        };
        return this.safeInteger(types, type, type);
    }

    /**
     * @method
     * @name hashkey#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-account-transaction-list
     * @param {string} [code] unified currency code, default is undefined (not used)
     * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
     * @param {int} [limit] max number of ledger entries to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {int} [params.flowType] trade, fee, transfer, deposit, withdrawal
     * @param {int} [params.accountType] spot, swap, custody
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchLedger";
        if (isTrue(isEqual(since, null)))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a since argument")) ;
        }
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, methodName, "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        if (isTrue(isEqual(until, null)))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires an until argument")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {};
        ((IDictionary<string,object>)request)["startTime"] = since;
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        ((IDictionary<string,object>)request)["endTime"] = until;
        object flowType = null;
        var flowTypeparametersVariable = this.handleOptionAndParams(parameters, methodName, "flowType");
        flowType = ((IList<object>)flowTypeparametersVariable)[0];
        parameters = ((IList<object>)flowTypeparametersVariable)[1];
        if (isTrue(!isEqual(flowType, null)))
        {
            ((IDictionary<string,object>)request)["flowType"] = this.encodeFlowType(flowType);
        }
        object accountType = null;
        var accountTypeparametersVariable = this.handleOptionAndParams(parameters, methodName, "accountType");
        accountType = ((IList<object>)accountTypeparametersVariable)[0];
        parameters = ((IList<object>)accountTypeparametersVariable)[1];
        if (isTrue(!isEqual(accountType, null)))
        {
            ((IDictionary<string,object>)request)["accountType"] = this.encodeAccountType(accountType);
        }
        object response = await this.privateGetApiV1AccountBalanceFlow(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "id": "1740844413612065537",
        //             "accountId": "1732885739589466112",
        //             "coin": "USDT",
        //             "coinId": "USDT",
        //             "coinName": "USDT",
        //             "flowTypeValue": 51,
        //             "flowType": "USER_ACCOUNT_TRANSFER",
        //             "flowName": "",
        //             "change": "-1",
        //             "total": "8.015680088",
        //             "created": "1722260825765"
        //         },
        //         ...
        //     ]
        //
        return this.parseLedger(response, currency, since, limit);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "1", "trade" },
            { "2", "fee" },
            { "51", "transfer" },
            { "900", "deposit" },
            { "904", "withdraw" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //         "id": "1740844413612065537",
        //         "accountId": "1732885739589466112",
        //         "coin": "USDT",
        //         "coinId": "USDT",
        //         "coinName": "USDT",
        //         "flowTypeValue": 51,
        //         "flowType": "USER_ACCOUNT_TRANSFER",
        //         "flowName": "",
        //         "change": "-1",
        //         "total": "8.015680088",
        //         "created": "1722260825765"
        //     }
        //
        object id = this.safeString(item, "id");
        object account = this.safeString(item, "accountId");
        object timestamp = this.safeInteger(item, "created");
        object type = this.parseLedgerEntryType(this.safeString(item, "flowTypeValue"));
        object currencyId = this.safeString(item, "coin");
        object code = this.safeCurrencyCode(currencyId, currency);
        currency = this.safeCurrency(currencyId, currency);
        object amountString = this.safeString(item, "change");
        object amount = this.parseNumber(amountString);
        object direction = "in";
        if (isTrue(isGreaterThanOrEqual(getIndexOf(amountString, "-"), 0)))
        {
            direction = "out";
        }
        object afterString = this.safeString(item, "total");
        object after = this.parseNumber(afterString);
        object status = "ok";
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "account", account },
            { "direction", direction },
            { "referenceId", null },
            { "referenceAccount", null },
            { "type", type },
            { "currency", code },
            { "symbol", null },
            { "amount", amount },
            { "before", null },
            { "after", after },
            { "status", status },
            { "fee", null },
        }, currency);
    }

    /**
     * @method
     * @name hashkey#createOrder
     * @description create a trade order
     * @see https://hashkeyglobal-apidoc.readme.io/reference/test-new-order
     * @see https://hashkeyglobal-apidoc.readme.io/reference/create-order
     * @see https://hashkeyglobal-apidoc.readme.io/reference/create-new-futures-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit' or 'LIMIT_MAKER' for spot, 'market' or 'limit' or 'STOP' for swap
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of you want to trade in units of the base currency
     * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
     * @param {boolean} [params.test] *spot markets only* whether to use the test endpoint or not, default is false
     * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
     * @param {string} [params.timeInForce] "GTC" or "IOC" or "PO" for spot, 'GTC' or 'FOK' or 'IOC' or 'LIMIT_MAKER' or 'PO' for swap
     * @param {string} [params.clientOrderId] a unique id for the order - is mandatory for swap
     * @param {float} [params.triggerPrice] *swap markets only* The price at which a trigger order is triggered at
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(getValue(market, "spot")))
        {
            return await this.createSpotOrder(symbol, type, side, amount, price, parameters);
        } else if (isTrue(getValue(market, "swap")))
        {
            return await this.createSwapOrder(symbol, type, side, amount, price, parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " createOrder() is not supported for "), getValue(market, "type")), " type of markets")) ;
        }
    }

    /**
     * @method
     * @name hashkey#createMarketBuyOrderWithCost
     * @description create a market buy order by providing the symbol and cost
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() is supported for spot markets only")) ;
        }
        object req = new Dictionary<string, object>() {
            { "cost", cost },
        };
        return await this.createOrder(symbol, "market", "buy", cost, null, this.extend(req, parameters));
    }

    /**
     * @method
     * @name hashkey#createSpotOrder
     * @description create a trade order on spot market
     * @see https://hashkeyglobal-apidoc.readme.io/reference/test-new-order
     * @see https://hashkeyglobal-apidoc.readme.io/reference/create-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit' or 'LIMIT_MAKER'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of you want to trade in units of the base currency
     * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.cost] *market buy only* the quote quantity that can be used as an alternative for the amount
     * @param {bool} [params.test] whether to use the test endpoint or not, default is false
     * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
     * @param {string} [params.timeInForce] 'GTC', 'IOC', or 'PO'
     * @param {string} [params.clientOrderId] a unique id for the order
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> createSpotOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object triggerPrice = this.safeString2(parameters, "stopPrice", "triggerPrice");
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            throw new NotSupported ((string)add(this.id, " trigger orders are not supported for spot markets")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object isMarketBuy = isTrue((isEqual(type, "market"))) && isTrue((isEqual(side, "buy")));
        object cost = this.safeString(parameters, "cost");
        if (isTrue(isTrue((!isTrue(isMarketBuy))) && isTrue((!isEqual(cost, null)))))
        {
            throw new NotSupported ((string)add(this.id, " createOrder() supports cost parameter for spot market buy orders only")) ;
        }
        object request = this.createSpotOrderRequest(symbol, type, side, amount, price, parameters);
        object response = new Dictionary<string, object>() {};
        object test = this.safeBool(parameters, "test");
        if (isTrue(test))
        {
            parameters = this.omit(parameters, "test");
            response = await this.privatePostApiV1SpotOrderTest(request);
        } else if (isTrue(isTrue(isMarketBuy) && isTrue((isEqual(cost, null)))))
        {
            response = await this.privatePostApiV11SpotOrder(request); // the endpoint for market buy orders by amount
        } else
        {
            response = await this.privatePostApiV1SpotOrder(request); // the endpoint for market buy orders by cost and other orders
        }
        return this.parseOrder(response, market);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        if (isTrue(getValue(market, "spot")))
        {
            return this.createSpotOrderRequest(symbol, type, side, amount, price, parameters);
        } else if (isTrue(getValue(market, "swap")))
        {
            return this.createSwapOrderRequest(symbol, type, side, amount, price, parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(add(this.id, " "), "createOrderRequest() is not supported for "), getValue(market, "type")), " type of markets")) ;
        }
    }

    public virtual object createSpotOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @ignore
        * @name hashkey#createSpotOrderRequest
        * @description helper function to build request
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit' or 'LIMIT_MAKER'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of you want to trade in units of the base currency
        * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.cost] *market buy only* the quote quantity that can be used as an alternative for the amount
        * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
        * @param {string} [params.timeInForce] "GTC", "IOC", or "PO"
        * @param {string} [params.clientOrderId] a unique id for the order
        * @returns {object} request to be sent to the exchange
        */
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        type = ((string)type).ToUpper();
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", ((string)side).ToUpper() },
            { "type", type },
        };
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
        }
        object cost = null;
        var costparametersVariable = this.handleParamString(parameters, "cost");
        cost = ((IList<object>)costparametersVariable)[0];
        parameters = ((IList<object>)costparametersVariable)[1];
        if (isTrue(!isEqual(cost, null)))
        {
            ((IDictionary<string,object>)request)["quantity"] = this.costToPrecision(symbol, cost);
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object isMarketOrder = isEqual(type, "MARKET");
        object postOnly = false;
        var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, isEqual(type, "LIMIT_MAKER"), parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        if (isTrue(isTrue(postOnly) && isTrue((isEqual(type, "LIMIT")))))
        {
            ((IDictionary<string,object>)request)["type"] = "LIMIT_MAKER";
        }
        object clientOrderId = null;
        var clientOrderIdparametersVariable = this.handleParamString(parameters, "clientOrderId");
        clientOrderId = ((IList<object>)clientOrderIdparametersVariable)[0];
        parameters = ((IList<object>)clientOrderIdparametersVariable)[1];
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)parameters)["newClientOrderId"] = clientOrderId;
        }
        return this.extend(request, parameters);
    }

    public virtual object createSwapOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @ignore
        * @name hashkey#createSwapOrderRequest
        * @description helper function to build request
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit' or 'STOP'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of you want to trade in units of the base currency
        * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
        * @param {bool} [params.reduceOnly] true or false whether the order is reduce only
        * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
        * @param {string} [params.timeInForce] 'GTC', 'FOK', 'IOC', 'LIMIT_MAKER' or 'PO'
        * @param {string} [params.clientOrderId] a unique id for the order
        * @returns {object} request to be sent to the exchange
        */
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "type", "LIMIT" },
            { "quantity", this.amountToPrecision(symbol, amount) },
        };
        object isMarketOrder = isEqual(type, "market");
        if (isTrue(isMarketOrder))
        {
            ((IDictionary<string,object>)request)["priceType"] = "MARKET";
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            ((IDictionary<string,object>)request)["priceType"] = "INPUT";
        }
        object reduceOnly = false;
        var reduceOnlyparametersVariable = this.handleParamBool(parameters, "reduceOnly", reduceOnly);
        reduceOnly = ((IList<object>)reduceOnlyparametersVariable)[0];
        parameters = ((IList<object>)reduceOnlyparametersVariable)[1];
        object suffix = "_OPEN";
        if (isTrue(reduceOnly))
        {
            suffix = "_CLOSE";
        }
        ((IDictionary<string,object>)request)["side"] = add(((string)side).ToUpper(), suffix);
        object timeInForce = null;
        var timeInForceparametersVariable = this.handleParamString(parameters, "timeInForce");
        timeInForce = ((IList<object>)timeInForceparametersVariable)[0];
        parameters = ((IList<object>)timeInForceparametersVariable)[1];
        object postOnly = false;
        var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, isEqual(timeInForce, "LIMIT_MAKER"), parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        if (isTrue(postOnly))
        {
            timeInForce = "LIMIT_MAKER";
        }
        if (isTrue(!isEqual(timeInForce, null)))
        {
            ((IDictionary<string,object>)request)["timeInForce"] = timeInForce;
        }
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientOrderId"] = this.uuid();
        }
        object triggerPrice = this.safeString(parameters, "triggerPrice");
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, triggerPrice);
            ((IDictionary<string,object>)request)["type"] = "STOP";
            parameters = this.omit(parameters, "triggerPrice");
        }
        return this.extend(request, parameters);
    }

    /**
     * @method
     * @name hashkey#createSwapOrder
     * @description create a trade order on swap market
     * @see https://hashkeyglobal-apidoc.readme.io/reference/create-new-futures-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit' or 'STOP'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of you want to trade in units of the base currency
     * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
     * @param {bool} [params.reduceOnly] true or false whether the order is reduce only
     * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
     * @param {string} [params.timeInForce] 'GTC', 'FOK', 'IOC', 'LIMIT_MAKER' or 'PO'
     * @param {string} [params.clientOrderId] a unique id for the order
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> createSwapOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = this.createSwapOrderRequest(symbol, type, side, amount, price, parameters);
        object response = await this.privatePostApiV1FuturesOrder(this.extend(request, parameters));
        //
        //     {
        //         "time": "1722429951611",
        //         "updateTime": "1722429951648",
        //         "orderId": "1742263144028363776",
        //         "clientOrderId": "1722429950315",
        //         "symbol": "ETHUSDT-PERPETUAL",
        //         "price": "3460.62",
        //         "leverage": "5",
        //         "origQty": "10",
        //         "executedQty": "10",
        //         "avgPrice": "0",
        //         "marginLocked": "6.9212",
        //         "type": "LIMIT",
        //         "side": "BUY_OPEN",
        //         "timeInForce": "IOC",
        //         "status": "FILLED",
        //         "priceType": "MARKET",
        //         "contractMultiplier": "0.00100000"
        //     }
        //
        return this.parseOrder(response, market);
    }

    /**
     * @method
     * @name hashkey#createOrders
     * @description create a list of trade orders (all orders should be of the same symbol)
     * @see https://hashkeyglobal-apidoc.readme.io/reference/create-multiple-orders
     * @see https://hashkeyglobal-apidoc.readme.io/reference/batch-create-new-futures-order
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the api endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object symbol = this.safeString(rawOrder, "symbol");
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeNumber(rawOrder, "amount");
            object price = this.safeNumber(rawOrder, "price");
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object orderRequest = this.createOrderRequest(symbol, type, side, amount, price, orderParams);
            object clientOrderId = this.safeString(orderRequest, "clientOrderId");
            if (isTrue(isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)orderRequest)["clientOrderId"] = this.uuid(); // both spot and swap endpoints require clientOrderId
            }
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object firstOrder = getValue(ordersRequests, 0);
        object firstSymbol = this.safeString(firstOrder, "symbol");
        object market = this.market(firstSymbol);
        object request = new Dictionary<string, object>() {
            { "orders", ordersRequests },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.privatePostApiV1SpotBatchOrders(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "swap")))
        {
            response = await this.privatePostApiV1FuturesBatchOrders(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(add(this.id, " "), "createOrderRequest() is not supported for "), getValue(market, "type")), " type of markets")) ;
        }
        object result = this.safeList(response, "result", new List<object>() {});
        object responseOrders = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
        {
            object responseEntry = this.safeDict(result, i, new Dictionary<string, object>() {});
            object responseOrder = this.safeDict(responseEntry, "order", new Dictionary<string, object>() {});
            ((IList<object>)responseOrders).Add(responseOrder);
        }
        return this.parseOrders(responseOrders);
    }

    /**
     * @method
     * @name hashkey#cancelOrder
     * @description cancels an open order
     * @see https://hashkeyglobal-apidoc.readme.io/reference/cancel-order
     * @see https://hashkeyglobal-apidoc.readme.io/reference/cancel-futures-order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch entry for (default 'spot')
     * @param {string} [params.clientOrderId] a unique id for the order that can be used as an alternative for the id
     * @param {bool} [params.trigger] *swap markets only* true for canceling a trigger order (default false)
     * @param {bool} [params.stop] *swap markets only* an alternative for trigger param
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "cancelOrder";
        this.checkTypeParam(methodName, parameters);
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = "spot";
        var marketTypeparametersVariable = this.handleMarketTypeAndParams(methodName, market, parameters, marketType);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.privateDeleteApiV1SpotOrder(this.extend(request, parameters));
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            object isTrigger = false;
            var isTriggerparametersVariable = this.handleTriggerOptionAndParams(parameters, methodName, isTrigger);
            isTrigger = ((IList<object>)isTriggerparametersVariable)[0];
            parameters = ((IList<object>)isTriggerparametersVariable)[1];
            if (isTrue(isTrigger))
            {
                ((IDictionary<string,object>)request)["type"] = "STOP";
            } else
            {
                ((IDictionary<string,object>)request)["type"] = "LIMIT";
            }
            if (isTrue(!isEqual(market, null)))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
            response = await this.privateDeleteApiV1FuturesOrder(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), marketType), " type of markets")) ;
        }
        return this.parseOrder(response);
    }

    /**
     * @method
     * @name hashkey#cancelAllOrders
     * @description cancel all open orders
     * @see https://hashkeyglobal-apidoc.readme.io/reference/cancel-all-open-orders
     * @see https://hashkeyglobal-apidoc.readme.io/reference/batch-cancel-futures-order
     * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.side] 'buy' or 'sell'
     * @returns {object} response from exchange
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        // Does not cancel trigger orders. For canceling trigger order use cancelOrder() or cancelOrders()
        parameters ??= new Dictionary<string, object>();
        object methodName = "cancelAllOrders";
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object side = this.safeString(parameters, "side");
        if (isTrue(!isEqual(side, null)))
        {
            ((IDictionary<string,object>)request)["side"] = side;
        }
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.privateDeleteApiV1SpotOpenOrders(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "swap")))
        {
            response = await this.privateDeleteApiV1FuturesBatchOrders(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), getValue(market, "type")), " type of markets")) ;
        }
        object order = this.safeOrder(response);
        ((IDictionary<string,object>)order)["info"] = response;
        return new List<object>() {order};
    }

    /**
     * @method
     * @name hashkey#cancelOrders
     * @description cancel multiple orders
     * @see https://hashkeyglobal-apidoc.readme.io/reference/cancel-multiple-orders
     * @see https://hashkeyglobal-apidoc.readme.io/reference/batch-cancel-futures-order-by-order-id
     * @param {string[]} ids order ids
     * @param {string} [symbol] unified market symbol (not used by hashkey)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch entry for (default 'spot')
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "cancelOrders";
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object orderIds = String.Join(",", ((IList<object>)ids).ToArray());
        ((IDictionary<string,object>)request)["ids"] = orderIds;
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = "spot";
        var marketTypeparametersVariable = this.handleMarketTypeAndParams(methodName, market, parameters, marketType);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.privateDeleteApiV1SpotCancelOrderByIds(this.extend(request));
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            response = this.privateDeleteApiV1FuturesCancelOrderByIds(this.extend(request));
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), marketType), " type of markets")) ;
        }
        object order = this.safeOrder(response);
        ((IDictionary<string,object>)order)["info"] = response;
        return new List<object>() {order};
    }

    /**
     * @method
     * @name hashkey#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://hashkeyglobal-apidoc.readme.io/reference/query-order
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-futures-order
     * @param {string} id the order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch entry for (default 'spot')
     * @param {string} [params.clientOrderId] a unique id for the order that can be used as an alternative for the id
     * @param {string} [params.accountId] *spot markets only* account id to fetch the order from
     * @param {bool} [params.trigger] *swap markets only* true for fetching a trigger order (default false)
     * @param {bool} [params.stop] *swap markets only* an alternative for trigger param
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchOrder";
        this.checkTypeParam(methodName, parameters);
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object clientOrderId = null;
        var clientOrderIdparametersVariable = this.handleParamString(parameters, "clientOrderId");
        clientOrderId = ((IList<object>)clientOrderIdparametersVariable)[0];
        parameters = ((IList<object>)clientOrderIdparametersVariable)[1];
        if (isTrue(isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = "spot";
        var marketTypeparametersVariable = this.handleMarketTypeAndParams(methodName, market, parameters, marketType);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["origClientOrderId"] = clientOrderId;
            }
            response = await this.privateGetApiV1SpotOrder(this.extend(request, parameters));
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            object isTrigger = false;
            var isTriggerparametersVariable = this.handleTriggerOptionAndParams(parameters, methodName, isTrigger);
            isTrigger = ((IList<object>)isTriggerparametersVariable)[0];
            parameters = ((IList<object>)isTriggerparametersVariable)[1];
            if (isTrue(isTrigger))
            {
                ((IDictionary<string,object>)request)["type"] = "STOP";
            }
            response = await this.privateGetApiV1FuturesOrder(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), marketType), " type of markets")) ;
        }
        return this.parseOrder(response);
    }

    /**
     * @method
     * @name hashkey#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-current-open-orders
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-sub-account-open-orders
     * @see https://hashkeyglobal-apidoc.readme.io/reference/sub
     * @see https://hashkeyglobal-apidoc.readme.io/reference/query-open-futures-orders
     * @param {string} [symbol] unified market symbol of the market orders were made in - is mandatory for swap markets
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve - default 500, maximum 1000
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch entries for (default 'spot')
     * @param {string} [params.orderId] *spot markets only* the id of the order to fetch
     * @param {string} [params.side] *spot markets only* 'buy' or 'sell' - the side of the orders to fetch
     * @param {string} [params.fromOrderId] *swap markets only* the id of the order to start from
     * @param {bool} [params.trigger] *swap markets only* true for fetching trigger orders (default false)
     * @param {bool} [params.stop] *swap markets only* an alternative for trigger param
     * @param {string} [params.accountId] account id to fetch the orders from
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchOpenOrders";
        this.checkTypeParam(methodName, parameters);
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = "spot";
        var marketTypeparametersVariable = this.handleMarketTypeAndParams(methodName, market, parameters, marketType);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        parameters = this.extend(new Dictionary<string, object>() {
            { "methodName", methodName },
        }, parameters);
        if (isTrue(isEqual(marketType, "spot")))
        {
            return await this.fetchOpenSpotOrders(symbol, since, limit, parameters);
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            return await this.fetchOpenSwapOrders(symbol, since, limit, parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), marketType), " type of markets")) ;
        }
    }

    /**
     * @method
     * @ignore
     * @name hashkey#fetchOpenSpotOrders
     * @description fetch all unfilled currently open orders for spot markets
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-current-open-orders
     * @see https://hashkeyglobal-apidoc.readme.io/reference/sub
     * @param {string} [symbol] unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve - default 500, maximum 1000
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.orderId] the id of the order to fetch
     * @param {string} [params.side] 'buy' or 'sell' - the side of the orders to fetch
     * @param {string} [params.accountId] account id to fetch the orders from
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchOpenSpotOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object methodName = "fetchOpenSpotOrders";
        var methodNameparametersVariable = this.handleParamString(parameters, "methodName", methodName);
        methodName = ((IList<object>)methodNameparametersVariable)[0];
        parameters = ((IList<object>)methodNameparametersVariable)[1];
        object market = null;
        object request = new Dictionary<string, object>() {};
        object response = null;
        object accountId = null;
        var accountIdparametersVariable = this.handleOptionAndParams(parameters, methodName, "accountId");
        accountId = ((IList<object>)accountIdparametersVariable)[0];
        parameters = ((IList<object>)accountIdparametersVariable)[1];
        if (isTrue(!isEqual(accountId, null)))
        {
            ((IDictionary<string,object>)request)["subAccountId"] = accountId;
            response = await this.privateGetApiV1SpotSubAccountOpenOrders(this.extend(request, parameters));
        } else
        {
            if (isTrue(!isEqual(symbol, null)))
            {
                market = this.market(symbol);
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            response = await this.privateGetApiV1SpotOpenOrders(this.extend(request, parameters));
        }
        return this.parseOrders(response, market, since, limit);
    }

    /**
     * @method
     * @ignore
     * @name hashkey#fetchOpenSwapOrders
     * @description fetch all unfilled currently open orders for swap markets
     * @see https://hashkeyglobal-apidoc.readme.io/reference/query-open-futures-orders
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-sub-account-open-orders
     * @param {string} symbol *is mandatory* unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve - maximum 500
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.fromOrderId] the id of the order to start from
     * @param {bool} [params.trigger] true for fetching trigger orders (default false)
     * @param {bool} [params.stop] an alternative for trigger param
     * @param {string} [params.accountId] account id to fetch the orders from
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchOpenSwapOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchOpenSwapOrders";
        var methodNameparametersVariable = this.handleParamString(parameters, "methodName", methodName);
        methodName = ((IList<object>)methodNameparametersVariable)[0];
        parameters = ((IList<object>)methodNameparametersVariable)[1];
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a symbol argument for swap market orders")) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object isTrigger = false;
        var isTriggerparametersVariable = this.handleTriggerOptionAndParams(parameters, methodName, isTrigger);
        isTrigger = ((IList<object>)isTriggerparametersVariable)[0];
        parameters = ((IList<object>)isTriggerparametersVariable)[1];
        if (isTrue(isTrigger))
        {
            ((IDictionary<string,object>)request)["type"] = "STOP";
        } else
        {
            ((IDictionary<string,object>)request)["type"] = "LIMIT";
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        object accountId = null;
        var accountIdparametersVariable = this.handleOptionAndParams(parameters, methodName, "accountId");
        accountId = ((IList<object>)accountIdparametersVariable)[0];
        parameters = ((IList<object>)accountIdparametersVariable)[1];
        if (isTrue(!isEqual(accountId, null)))
        {
            ((IDictionary<string,object>)request)["subAccountId"] = accountId;
            response = await this.privateGetApiV1FuturesSubAccountOpenOrders(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetApiV1FuturesOpenOrders(this.extend(request, parameters));
        }
        return this.parseOrders(response, market, since, limit);
    }

    /**
     * @method
     * @name hashkey#fetchCanceledAndClosedOrders
     * @description fetches information on multiple canceled and closed orders made by the user
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-all-orders
     * @see https://hashkeyglobal-apidoc.readme.io/reference/query-futures-history-orders
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-sub-account-history-orders
     * @param {string} symbol *is mandatory for swap markets* unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve - default 500, maximum 1000
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for - only supports the last 90 days timeframe
     * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch entries for (default 'spot')
     * @param {string} [params.orderId] *spot markets only* the id of the order to fetch
     * @param {string} [params.side] *spot markets only* 'buy' or 'sell' - the side of the orders to fetch
     * @param {string} [params.fromOrderId] *swap markets only* the id of the order to start from
     * @param {bool} [params.trigger] *swap markets only* the id of the order to start from true for fetching trigger orders (default false)
     * @param {bool} [params.stop] *swap markets only* the id of the order to start from an alternative for trigger param
     * @param {string} [params.accountId] account id to fetch the orders from
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchCanceledAndClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchCanceledAndClosedOrders";
        this.checkTypeParam(methodName, parameters);
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, methodName, "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object accountId = null;
        var accountIdparametersVariable = this.handleOptionAndParams(parameters, methodName, "accountId");
        accountId = ((IList<object>)accountIdparametersVariable)[0];
        parameters = ((IList<object>)accountIdparametersVariable)[1];
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = "spot";
        var marketTypeparametersVariable = this.handleMarketTypeAndParams(methodName, market, parameters, marketType);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(!isEqual(market, null)))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
            if (isTrue(!isEqual(accountId, null)))
            {
                ((IDictionary<string,object>)request)["accountId"] = accountId;
            }
            response = await this.privateGetApiV1SpotTradeOrders(this.extend(request, parameters));
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a symbol argument for swap markets")) ;
            }
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            object isTrigger = false;
            var isTriggerparametersVariable = this.handleTriggerOptionAndParams(parameters, methodName, isTrigger);
            isTrigger = ((IList<object>)isTriggerparametersVariable)[0];
            parameters = ((IList<object>)isTriggerparametersVariable)[1];
            if (isTrue(isTrigger))
            {
                ((IDictionary<string,object>)request)["type"] = "STOP";
            } else
            {
                ((IDictionary<string,object>)request)["type"] = "LIMIT";
            }
            if (isTrue(!isEqual(accountId, null)))
            {
                ((IDictionary<string,object>)request)["subAccountId"] = accountId;
                response = await this.privateGetApiV1FuturesSubAccountHistoryOrders(this.extend(request, parameters));
            } else
            {
                response = await this.privateGetApiV1FuturesHistoryOrders(this.extend(request, parameters));
            }
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), marketType), " type of markets")) ;
        }
        return this.parseOrders(response, market, since, limit);
    }

    public virtual void checkTypeParam(object methodName, object parameters)
    {
        // some hashkey endpoints have a type param for swap markets that defines the type of an order
        // type param is reserved in ccxt for defining the type of the market
        // current method warns user if he provides the exchange specific value in type parameter
        object paramsType = this.safeString(parameters, "type");
        if (isTrue(isTrue(isTrue((!isEqual(paramsType, null))) && isTrue((!isEqual(paramsType, "spot")))) && isTrue((!isEqual(paramsType, "swap")))))
        {
            throw new BadRequest ((string)add(add(add(add(add(this.id, " "), methodName), " () type parameter can not be \""), paramsType), "\". It should define the type of the market (\"spot\" or \"swap\"). To define the type of an order use the trigger parameter (true for trigger orders)")) ;
        }
    }

    public virtual object handleTriggerOptionAndParams(object parameters, object methodName, object defaultValue = null)
    {
        object isTrigger = defaultValue;
        var isTriggerparametersVariable = this.handleOptionAndParams2(parameters, methodName, "stop", "trigger", isTrigger);
        isTrigger = ((IList<object>)isTriggerparametersVariable)[0];
        parameters = ((IList<object>)isTriggerparametersVariable)[1];
        return new List<object>() {isTrigger, parameters};
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder spot
        //     {
        //         "accountId": "1732885739589466112",
        //         "symbol": "ETHUSDT",
        //         "symbolName": "ETHUSDT",
        //         "clientOrderId": "1722004623170558",
        //         "orderId": "1738695230608169984",
        //         "transactTime": "1722004623186",
        //         "price": "0",
        //         "origQty": "0",
        //         "executedQty": "0.0061",
        //         "status": "FILLED",
        //         "timeInForce": "IOC",
        //         "type": "MARKET",
        //         "side": "BUY",
        //         "reqAmount": "20",
        //         "concentration": ""
        //     }
        //
        // fetchOrder spot
        //     {
        //         "accountId": "1732885739589466112",
        //         "exchangeId": "301",
        //         "symbol": "ETHUSDT",
        //         "symbolName": "ETHUSDT",
        //         "clientOrderId": "1722004623170558",
        //         "orderId": "1738695230608169984",
        //         "price": "0",
        //         "origQty": "0",
        //         "executedQty": "0.0061",
        //         "cummulativeQuoteQty": "19.736489",
        //         "cumulativeQuoteQty": "19.736489",
        //         "avgPrice": "3235.49",
        //         "status": "FILLED",
        //         "timeInForce": "IOC",
        //         "type": "MARKET",
        //         "side": "BUY",
        //         "stopPrice": "0.0",
        //         "icebergQty": "0.0",
        //         "time": "1722004623186",
        //         "updateTime": "1722004623406",
        //         "isWorking": true,
        //         "reqAmount": "20",
        //         "feeCoin": "",
        //         "feeAmount": "0",
        //         "sumFeeAmount": "0"
        //     }
        //
        // cancelOrder
        //     {
        //         "accountId": "1732885739589466112",
        //         "symbol": "ETHUSDT",
        //         "clientOrderId": "1722006209978370",
        //         "orderId": "1738708541676585728",
        //         "transactTime": "1722006209989",
        //         "price": "5000",
        //         "origQty": "0.005",
        //         "executedQty": "0",
        //         "status": "NEW",
        //         "timeInForce": "GTC",
        //         "type": "LIMIT_MAKER",
        //         "side": "SELL"
        //     }
        //
        // createOrder swap
        //     {
        //         "time": "1722429951611",
        //         "updateTime": "1722429951648",
        //         "orderId": "1742263144028363776",
        //         "clientOrderId": "1722429950315",
        //         "symbol": "ETHUSDT-PERPETUAL",
        //         "price": "3460.62",
        //         "leverage": "5",
        //         "origQty": "10",
        //         "executedQty": "10",
        //         "avgPrice": "0",
        //         "marginLocked": "6.9212",
        //         "type": "LIMIT",
        //         "side": "BUY_OPEN",
        //         "timeInForce": "IOC",
        //         "status": "FILLED",
        //         "priceType": "MARKET",
        //         "contractMultiplier": "0.00100000"
        //     }
        //
        // fetchOrder swap
        //     {
        //         "time": "1722429951611",
        //         "updateTime": "1722429951700",
        //         "orderId": "1742263144028363776",
        //         "clientOrderId": "1722429950315",
        //         "symbol": "ETHUSDT-PERPETUAL",
        //         "price": "3460.62",
        //         "leverage": "5",
        //         "origQty": "10",
        //         "executedQty": "10",
        //         "avgPrice": "3327.52",
        //         "marginLocked": "0",
        //         "type": "LIMIT",
        //         "side": "BUY_OPEN",
        //         "timeInForce": "IOC",
        //         "status": "FILLED",
        //         "priceType": "MARKET",
        //         "isLiquidationOrder": false,
        //         "indexPrice": "0",
        //         "liquidationType": ""
        //     }
        //
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger2(order, "transactTime", "time");
        object status = this.safeString(order, "status");
        object type = this.safeString(order, "type");
        object priceType = this.safeString(order, "priceType");
        if (isTrue(isEqual(priceType, "MARKET")))
        {
            type = "market";
        }
        object price = this.omitZero(this.safeString(order, "price"));
        if (isTrue(isEqual(type, "STOP")))
        {
            if (isTrue(isEqual(price, null)))
            {
                type = "market";
            } else
            {
                type = "limit";
            }
        }
        object timeInForce = this.safeString(order, "timeInForce");
        object postOnly = null;
        var typetimeInForcepostOnlyVariable = this.parseOrderTypeTimeInForceAndPostOnly(type, timeInForce);
        type = ((IList<object>)typetimeInForcepostOnlyVariable)[0];
        timeInForce = ((IList<object>)typetimeInForcepostOnlyVariable)[1];
        postOnly = ((IList<object>)typetimeInForcepostOnlyVariable)[2];
        object average = this.omitZero(this.safeString(order, "avgPrice"));
        if (isTrue(isEqual(price, null)))
        {
            price = average;
        }
        object side = this.safeStringLower(order, "side");
        object reduceOnly = null;
        var sidereduceOnlyVariable = this.parseOrderSideAndReduceOnly(side);
        side = ((IList<object>)sidereduceOnlyVariable)[0];
        reduceOnly = ((IList<object>)sidereduceOnlyVariable)[1];
        object feeCurrncyId = this.safeString(order, "feeCoin");
        if (isTrue(isEqual(feeCurrncyId, "")))
        {
            feeCurrncyId = null;
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(order, "orderId") },
            { "clientOrderId", this.safeString(order, "clientOrderId") },
            { "datetime", this.iso8601(timestamp) },
            { "timestamp", timestamp },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", this.safeInteger(order, "updateTime") },
            { "status", this.parseOrderStatus(status) },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "timeInForce", timeInForce },
            { "side", side },
            { "price", price },
            { "average", average },
            { "amount", this.omitZero(this.safeString(order, "origQty")) },
            { "filled", this.safeString(order, "executedQty") },
            { "remaining", null },
            { "triggerPrice", this.omitZero(this.safeString(order, "stopPrice")) },
            { "takeProfitPrice", null },
            { "stopLossPrice", null },
            { "cost", this.omitZero(this.safeString2(order, "cumulativeQuoteQty", "cummulativeQuoteQty")) },
            { "trades", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(feeCurrncyId) },
                { "amount", this.omitZero(this.safeString(order, "feeAmount")) },
            } },
            { "reduceOnly", reduceOnly },
            { "postOnly", postOnly },
            { "info", order },
        }, market);
    }

    public virtual object parseOrderSideAndReduceOnly(object unparsed)
    {
        object parts = ((string)unparsed).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
        object side = getValue(parts, 0);
        object reduceOnly = null;
        object secondPart = this.safeString(parts, 1);
        if (isTrue(!isEqual(secondPart, null)))
        {
            if (isTrue(isEqual(secondPart, "open")))
            {
                reduceOnly = false;
            } else if (isTrue((isEqual(secondPart, "close"))))
            {
                reduceOnly = true;
            }
        }
        return new List<object>() {side, reduceOnly};
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "open" },
            { "PARTIALLY_FILLED", "open" },
            { "PARTIALLY_CANCELED", "canceled" },
            { "FILLED", "closed" },
            { "CANCELED", "canceled" },
            { "ORDER_CANCELED", "canceled" },
            { "PENDING_CANCEL", "canceled" },
            { "REJECTED", "rejected" },
            { "ORDER_NEW", "open" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderTypeTimeInForceAndPostOnly(object type, object timeInForce)
    {
        object postOnly = null;
        if (isTrue(isEqual(type, "LIMIT_MAKER")))
        {
            postOnly = true;
        } else if (isTrue(isTrue((isEqual(timeInForce, "LIMIT_MAKER"))) || isTrue((isEqual(timeInForce, "MAKER")))))
        {
            postOnly = true;
            timeInForce = "PO";
        }
        type = this.parseOrderType(type);
        return new List<object>() {type, timeInForce, postOnly};
    }

    public virtual object parseOrderType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "MARKET", "market" },
            { "LIMIT", "limit" },
            { "LIMIT_MAKER", "limit" },
            { "MARKET_OF_BASE", "market" },
        };
        return this.safeString(types, type, type);
    }

    /**
     * @method
     * @name hashkey#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-futures-funding-rate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "timestamp", this.milliseconds() },
        };
        object response = await this.publicGetApiV1FuturesFundingRate(this.extend(request, parameters));
        //
        //     [
        //         { "symbol": "ETHUSDT-PERPETUAL", "rate": "0.0001", "nextSettleTime": "1722297600000" }
        //     ]
        //
        object rate = this.safeDict(response, 0, new Dictionary<string, object>() {});
        return this.parseFundingRate(rate, market);
    }

    /**
     * @method
     * @name hashkey#fetchFundingRates
     * @description fetch the funding rate for multiple markets
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-futures-funding-rate
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexed by market symbols
     */
    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {
            { "timestamp", this.milliseconds() },
        };
        object response = await this.publicGetApiV1FuturesFundingRate(this.extend(request, parameters));
        //
        //     [
        //         { "symbol": "BTCUSDT-PERPETUAL", "rate": "0.0001", "nextSettleTime": "1722297600000" },
        //         { "symbol": "ETHUSDT-PERPETUAL", "rate": "0.0001", "nextSettleTime": "1722297600000" }
        //     ]
        //
        return this.parseFundingRates(response, symbols);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //     {
        //         "symbol": "ETHUSDT-PERPETUAL",
        //         "rate": "0.0001",
        //         "nextSettleTime": "1722297600000"
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        market = this.safeMarket(marketId, market, null, "swap");
        object fundingRate = this.safeNumber(contract, "rate");
        object fundingTimestamp = this.safeInteger(contract, "nextSettleTime");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", getValue(market, "symbol") },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", fundingRate },
            { "fundingTimestamp", null },
            { "fundingDatetime", null },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", fundingTimestamp },
            { "nextFundingDatetime", this.iso8601(fundingTimestamp) },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", null },
        };
    }

    /**
     * @method
     * @name hashkey#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-futures-history-funding-rate
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.fromId] the id of the entry to start from
     * @param {int} [params.endId] the id of the entry to end with
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.publicGetApiV1FuturesHistoryFundingRate(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "id": "10698",
        //             "symbol": "ETHUSDT-PERPETUAL",
        //             "settleTime": "1722268800000",
        //             "settleRate": "0.0001"
        //         },
        //         ...
        //     ]
        //
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object timestamp = this.safeInteger(entry, "settleTime");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", this.safeSymbol(this.safeString(entry, "symbol"), market, null, "swap") },
                { "fundingRate", this.safeNumber(entry, "settleRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySinceLimit(sorted, since, limit);
    }

    /**
     * @method
     * @description fetch open positions for a market
     * @name hashkey#fetchPositions
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-futures-positions
     * @description fetch all open positions
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.side] 'LONG' or 'SHORT' - the direction of the position (if not provided, positions for both sides will be returned)
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchPositions";
        if (isTrue((isEqual(symbols, null))))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a symbol argument with one single market symbol")) ;
        } else
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(!isEqual(symbolsLength, 1)))
            {
                throw new NotSupported ((string)add(add(add(this.id, " "), methodName), "() is supported for a symbol argument with one single market symbol only")) ;
            }
        }
        await this.loadMarkets();
        return await this.fetchPositionsForSymbol(getValue(symbols, 0), this.extend(new Dictionary<string, object>() {
            { "methodName", "fetchPositions" },
        }, parameters));
    }

    /**
     * @method
     * @description fetch open positions for a single market
     * @name hashkey#fetchPositionsForSymbol
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-futures-positions
     * @description fetch all open positions for specific symbol
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.side] 'LONG' or 'SHORT' - the direction of the position (if not provided, positions for both sides will be returned)
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositionsForSymbol(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object methodName = "fetchPosition";
        var methodNameparametersVariable = this.handleParamString(parameters, "methodName", methodName);
        methodName = ((IList<object>)methodNameparametersVariable)[0];
        parameters = ((IList<object>)methodNameparametersVariable)[1];
        if (!isTrue(getValue(market, "swap")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " "), methodName), "() supports swap markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateGetApiV1FuturesPositions(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "symbol": "ETHUSDT-PERPETUAL",
        //             "side": "LONG",
        //             "avgPrice": "3327.52",
        //             "position": "10",
        //             "available": "0",
        //             "leverage": "5",
        //             "lastPrice": "3324.44",
        //             "positionValue": "33.2752",
        //             "liquidationPrice": "-953.83",
        //             "margin": "6.9012",
        //             "marginRate": "",
        //             "unrealizedPnL": "-0.0288",
        //             "profitRate": "-0.0041",
        //             "realizedPnL": "-0.0199",
        //             "minMargin": "0.2173"
        //         }
        //     ]
        //
        return this.parsePositions(response, new List<object>() {symbol});
    }

    public override object parsePosition(object position, object market = null)
    {
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        return this.safePosition(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "id", null },
            { "timestamp", null },
            { "datetime", null },
            { "contracts", this.safeNumber(position, "position") },
            { "contractSize", null },
            { "side", this.safeStringLower(position, "side") },
            { "notional", this.safeNumber(position, "positionValue") },
            { "leverage", this.safeInteger(position, "leverage") },
            { "unrealizedPnl", this.safeNumber(position, "unrealizedPnL") },
            { "realizedPnl", this.safeNumber(position, "realizedPnL") },
            { "collateral", null },
            { "entryPrice", this.safeNumber(position, "avgPrice") },
            { "markPrice", null },
            { "liquidationPrice", this.safeNumber(position, "liquidationPrice") },
            { "marginMode", "cross" },
            { "hedged", true },
            { "maintenanceMargin", this.safeNumber(position, "minMargin") },
            { "maintenanceMarginPercentage", null },
            { "initialMargin", this.safeNumber(position, "margin") },
            { "initialMarginPercentage", null },
            { "marginRatio", null },
            { "lastUpdateTimestamp", null },
            { "lastPrice", this.safeNumber(position, "lastPrice") },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
            { "percentage", null },
            { "info", position },
        });
    }

    /**
     * @method
     * @name hashkey#fetchLeverage
     * @description fetch the set leverage for a market
     * @see https://hashkeyglobal-apidoc.readme.io/reference/query-futures-leverage-trade
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
     */
    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateGetApiV1FuturesLeverage(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "symbolId": "ETHUSDT-PERPETUAL",
        //             "leverage": "5",
        //             "marginType": "CROSS"
        //         }
        //     ]
        //
        object leverage = this.safeDict(response, 0, new Dictionary<string, object>() {});
        return this.parseLeverage(leverage, market);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        object marginMode = this.safeStringLower(leverage, "marginType");
        object leverageValue = this.safeNumber(leverage, "leverage");
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", getValue(market, "symbol") },
            { "marginMode", marginMode },
            { "longLeverage", leverageValue },
            { "shortLeverage", leverageValue },
        };
    }

    /**
     * @method
     * @name hashkey#setLeverage
     * @description set the level of leverage for a market
     * @see https://hashkeyglobal-apidoc.readme.io/reference/change-futures-leverage-trade
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "leverage", leverage },
        };
        object market = this.market(symbol);
        ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        object response = await this.privatePostApiV1FuturesLeverage(this.extend(request, parameters));
        //
        //     {
        //         "code": "0000",
        //         "symbolId": "ETHUSDT-PERPETUAL",
        //         "leverage": "3"
        //     }
        //
        return this.parseLeverage(response, market);
    }

    /**
     * @method
     * @name hashkey#fetchLeverageTiers
     * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
     * @see https://hashkeyglobal-apidoc.readme.io/reference/exchangeinfo
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
     */
    public async override Task<object> fetchLeverageTiers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetApiV1ExchangeInfo(parameters);
        // response is the same as in fetchMarkets()
        object data = this.safeList(response, "contracts", new List<object>() {});
        symbols = this.marketSymbols(symbols);
        return this.parseLeverageTiers(data, symbols, "symbol");
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        //
        //     {
        //         "filters": [
        //             {
        //                 "minPrice": "0.1",
        //                 "maxPrice": "100000.00000000",
        //                 "tickSize": "0.1",
        //                 "filterType": "PRICE_FILTER"
        //             },
        //             {
        //                 "minQty": "0.001",
        //                 "maxQty": "10",
        //                 "stepSize": "0.001",
        //                 "marketOrderMinQty": "0",
        //                 "marketOrderMaxQty": "0",
        //                 "filterType": "LOT_SIZE"
        //             },
        //             {
        //                 "minNotional": "0",
        //                 "filterType": "MIN_NOTIONAL"
        //             },
        //             {
        //                 "maxSellPrice": "999999",
        //                 "buyPriceUpRate": "0.05",
        //                 "sellPriceDownRate": "0.05",
        //                 "maxEntrustNum": 200,
        //                 "maxConditionNum": 200,
        //                 "filterType": "LIMIT_TRADING"
        //             },
        //             {
        //                 "buyPriceUpRate": "0.05",
        //                 "sellPriceDownRate": "0.05",
        //                 "filterType": "MARKET_TRADING"
        //             },
        //             {
        //                 "noAllowMarketStartTime": "0",
        //                 "noAllowMarketEndTime": "0",
        //                 "limitOrderStartTime": "0",
        //                 "limitOrderEndTime": "0",
        //                 "limitMinPrice": "0",
        //                 "limitMaxPrice": "0",
        //                 "filterType": "OPEN_QUOTE"
        //             }
        //         ],
        //         "exchangeId": "301",
        //         "symbol": "BTCUSDT-PERPETUAL",
        //         "symbolName": "BTCUSDT-PERPETUAL",
        //         "status": "TRADING",
        //         "baseAsset": "BTCUSDT-PERPETUAL",
        //         "baseAssetPrecision": "0.001",
        //         "quoteAsset": "USDT",
        //         "quoteAssetPrecision": "0.1",
        //         "icebergAllowed": false,
        //         "inverse": false,
        //         "index": "USDT",
        //         "marginToken": "USDT",
        //         "marginPrecision": "0.0001",
        //         "contractMultiplier": "0.001",
        //         "underlying": "BTC",
        //         "riskLimits": [
        //             {
        //                 "riskLimitId": "200000722",
        //                 "quantity": "1000.00",
        //                 "initialMargin": "0.10",
        //                 "maintMargin": "0.005",
        //                 "isWhite": false
        //             },
        //             {
        //                 "riskLimitId": "200000723",
        //                 "quantity": "2000.00",
        //                 "initialMargin": "0.10",
        //                 "maintMargin": "0.01",
        //                 "isWhite": false
        //             }
        //         ]
        //     }
        //
        object riskLimits = this.safeList(info, "riskLimits", new List<object>() {});
        object marketId = this.safeString(info, "symbol");
        market = this.safeMarket(marketId, market);
        object tiers = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(riskLimits)); postFixIncrement(ref i))
        {
            object tier = getValue(riskLimits, i);
            object initialMarginRate = this.safeString(tier, "initialMargin");
            ((IList<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.sum(i, 1) },
                { "symbol", this.safeSymbol(marketId, market) },
                { "currency", getValue(market, "settle") },
                { "minNotional", null },
                { "maxNotional", this.safeNumber(tier, "quantity") },
                { "maintenanceMarginRate", this.safeNumber(tier, "maintMargin") },
                { "maxLeverage", this.parseNumber(Precise.stringDiv("1", initialMarginRate)) },
                { "info", tier },
            });
        }
        return tiers;
    }

    /**
     * @method
     * @name hashkey#fetchTradingFee
     * @description fetch the trading fees for a market
     * @see https://developers.binance.com/docs/wallet/asset/trade-fee // spot
     * @see https://hashkeyglobal-apidoc.readme.io/reference/get-futures-commission-rate-request-weight // swap
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object methodName = "fetchTradingFee";
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.fetchTradingFees(parameters);
            return this.safeDict(response, symbol);
        } else if (isTrue(getValue(market, "swap")))
        {
            response = await this.privateGetApiV1FuturesCommissionRate(this.extend(new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
            }, parameters));
            return this.parseTradingFee(response, market);
        } else
        {
            throw new NotSupported ((string)add(add(add(add(add(this.id, " "), methodName), "() is not supported for "), getValue(market, "type")), " type of markets")) ;
        }
    }

    /**
     * @method
     * @name hashkey#fetchTradingFees
     * @description *for spot markets only* fetch the trading fees for multiple markets
     * @see https://developers.binance.com/docs/wallet/asset/trade-fee
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
     */
    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetApiV1AccountVipInfo(parameters);
        //
        //     {
        //         "code": 0,
        //         "vipLevel": "0",
        //         "tradeVol30Day": "67",
        //         "totalAssetBal": "0",
        //         "data": [
        //             {
        //                 "symbol": "UXLINKUSDT",
        //                 "productType": "Token-Token",
        //                 "buyMakerFeeCurrency": "UXLINK",
        //                 "buyTakerFeeCurrency": "UXLINK",
        //                 "sellMakerFeeCurrency": "USDT",
        //                 "sellTakerFeeCurrency": "USDT",
        //                 "actualMakerRate": "0.0012",
        //                 "actualTakerRate": "0.0012"
        //             },
        //             ...
        //         ],
        //         "updateTimestamp": "1722320137809"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object fee = this.safeDict(data, i, new Dictionary<string, object>() {});
            object parsedFee = this.parseTradingFee(fee);
            ((IDictionary<string,object>)result)[(string)getValue(parsedFee, "symbol")] = parsedFee;
        }
        return result;
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        //
        // spot
        //     {
        //         "symbol": "UXLINKUSDT",
        //         "productType": "Token-Token",
        //         "buyMakerFeeCurrency": "UXLINK",
        //         "buyTakerFeeCurrency": "UXLINK",
        //         "sellMakerFeeCurrency": "USDT",
        //         "sellTakerFeeCurrency": "USDT",
        //         "actualMakerRate": "0.0012",
        //         "actualTakerRate": "0.0012"
        //     }
        //
        // swap
        //     {
        //         "openMakerFee": "0.00025",
        //         "openTakerFee": "0.0006",
        //         "closeMakerFee": "0.00025",
        //         "closeTakerFee": "0.0006"
        //     }
        //
        object marketId = this.safeString(fee, "symbol");
        market = this.safeMarket(marketId, market);
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", getValue(market, "symbol") },
            { "maker", this.safeNumber2(fee, "openMakerFee", "actualMakerRate") },
            { "taker", this.safeNumber2(fee, "openTakerFee", "actualTakerRate") },
            { "percentage", true },
            { "tierBased", true },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(getValue(getValue(this.urls, "api"), api), "/"), path);
        object query = null;
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object timestamp = this.milliseconds();
            object additionalParams = new Dictionary<string, object>() {
                { "timestamp", timestamp },
            };
            object recvWindow = this.safeInteger(this.options, "recvWindow");
            if (isTrue(!isEqual(recvWindow, null)))
            {
                ((IDictionary<string,object>)additionalParams)["recvWindow"] = recvWindow;
            }
            headers = new Dictionary<string, object>() {
                { "X-HK-APIKEY", this.apiKey },
                { "Content-Type", "application/x-www-form-urlencoded" },
            };
            object signature = null;
            if (isTrue(isTrue((isEqual(method, "POST"))) && isTrue((isTrue((isEqual(path, "api/v1/spot/batchOrders"))) || isTrue((isEqual(path, "api/v1/futures/batchOrders")))))))
            {
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
                body = this.json(this.safeList(parameters, "orders"));
                signature = this.hmac(this.encode(this.customUrlencode(additionalParams)), this.encode(this.secret), sha256);
                query = this.customUrlencode(this.extend(additionalParams, new Dictionary<string, object>() {
                    { "signature", signature },
                }));
                url = add(url, add("?", query));
            } else
            {
                object totalParams = this.extend(additionalParams, parameters);
                signature = this.hmac(this.encode(this.customUrlencode(totalParams)), this.encode(this.secret), sha256);
                ((IDictionary<string,object>)totalParams)["signature"] = signature;
                query = this.customUrlencode(totalParams);
                if (isTrue(isEqual(method, "GET")))
                {
                    url = add(url, add("?", query));
                } else
                {
                    body = query;
                }
            }
            ((IDictionary<string,object>)headers)["INPUT-SOURCE"] = this.safeString(this.options, "broker", "10000700011");
            ((IDictionary<string,object>)headers)["broker_sign"] = signature;
        } else
        {
            query = this.urlencode(parameters);
            if (isTrue(!isEqual(((string)query).Length, 0)))
            {
                url = add(url, add("?", query));
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public virtual object customUrlencode(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object result = this.urlencode(parameters);
        result = ((string)result).Replace((string)"%2C", (string)",");
        return result;
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        object errorInArray = false;
        object responseCodeString = this.safeString(response, "code", null);
        object responseCodeInteger = this.safeInteger(response, "code", null); // some codes in response are returned as '0000' others as 0
        if (isTrue(isEqual(responseCodeInteger, 0)))
        {
            object result = this.safeList(response, "result", new List<object>() {}); // for batch methods
            for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
            {
                object entry = this.safeDict(result, i);
                object entryCodeInteger = this.safeInteger(entry, "code");
                if (isTrue(!isEqual(entryCodeInteger, 0)))
                {
                    errorInArray = true;
                    responseCodeString = this.safeString(entry, "code");
                }
            }
        }
        if (isTrue(isTrue((!isEqual(code, 200))) || isTrue(errorInArray)))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), responseCodeString, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), responseCodeString, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
