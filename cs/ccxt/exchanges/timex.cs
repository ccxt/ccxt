namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class timex : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "timex" },
            { "name", "TimeX" },
            { "countries", new List<object>() {"AU"} },
            { "version", "v1" },
            { "rateLimit", 1500 },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "createOrder", true },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", false },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "editOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDeposit", false },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchPosition", false },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsForSymbol", false },
                { "fetchPositionsHistory", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "I1" },
                { "5m", "I5" },
                { "15m", "I15" },
                { "30m", "I30" },
                { "1h", "H1" },
                { "2h", "H2" },
                { "4h", "H4" },
                { "6h", "H6" },
                { "12h", "H12" },
                { "1d", "D1" },
                { "1w", "W1" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/70423869-6839ab00-1a7f-11ea-8f94-13ae72c31115.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "rest", "https://plasma-relay-backend.timex.io" },
                } },
                { "www", "https://timex.io" },
                { "doc", "https://plasma-relay-backend.timex.io/swagger-ui/index.html" },
                { "referral", "https://timex.io/?refcode=1x27vNkTbP1uwkCck" },
            } },
            { "api", new Dictionary<string, object>() {
                { "addressbook", new Dictionary<string, object>() {
                    { "get", new List<object>() {"me"} },
                    { "post", new List<object>() {"", "id/{id}", "id/{id}/remove"} },
                } },
                { "custody", new Dictionary<string, object>() {
                    { "get", new List<object>() {"credentials", "credentials/h/{hash}", "credentials/k/{key}", "credentials/me", "credentials/me/address", "deposit-addresses", "deposit-addresses/h/{hash}"} },
                } },
                { "history", new Dictionary<string, object>() {
                    { "get", new List<object>() {"orders", "orders/details", "orders/export/csv", "trades", "trades/export/csv"} },
                } },
                { "currencies", new Dictionary<string, object>() {
                    { "get", new List<object>() {"a/{address}", "i/{id}", "s/{symbol}"} },
                    { "post", new List<object>() {"perform", "prepare", "remove/perform", "s/{symbol}/remove/prepare", "s/{symbol}/update/perform", "s/{symbol}/update/prepare"} },
                } },
                { "manager", new Dictionary<string, object>() {
                    { "get", new List<object>() {"deposits", "transfers", "withdrawals"} },
                } },
                { "markets", new Dictionary<string, object>() {
                    { "get", new List<object>() {"i/{id}", "s/{symbol}"} },
                    { "post", new List<object>() {"perform", "prepare", "remove/perform", "s/{symbol}/remove/prepare", "s/{symbol}/update/perform", "s/{symbol}/update/prepare"} },
                } },
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"candles", "currencies", "markets", "orderbook", "orderbook/raw", "orderbook/v2", "tickers", "trades"} },
                } },
                { "statistics", new Dictionary<string, object>() {
                    { "get", new List<object>() {"address"} },
                } },
                { "trading", new Dictionary<string, object>() {
                    { "get", new List<object>() {"balances", "fees", "orders"} },
                    { "post", new List<object>() {"orders", "orders/json"} },
                    { "put", new List<object>() {"orders", "orders/json"} },
                    { "delete", new List<object>() {"orders", "orders/json"} },
                } },
                { "tradingview", new Dictionary<string, object>() {
                    { "get", new List<object>() {"config", "history", "symbol_info", "time"} },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "0", typeof(ExchangeError) },
                    { "1", typeof(NotSupported) },
                    { "4000", typeof(BadRequest) },
                    { "4001", typeof(BadRequest) },
                    { "4002", typeof(InsufficientFunds) },
                    { "4003", typeof(AuthenticationError) },
                    { "4004", typeof(AuthenticationError) },
                    { "4005", typeof(BadRequest) },
                    { "4006", typeof(BadRequest) },
                    { "4007", typeof(BadRequest) },
                    { "4300", typeof(PermissionDenied) },
                    { "4100", typeof(AuthenticationError) },
                    { "4400", typeof(OrderNotFound) },
                    { "5001", typeof(InvalidOrder) },
                    { "5002", typeof(ExchangeError) },
                    { "400", typeof(BadRequest) },
                    { "401", typeof(AuthenticationError) },
                    { "403", typeof(PermissionDenied) },
                    { "404", typeof(OrderNotFound) },
                    { "429", typeof(RateLimitExceeded) },
                    { "500", typeof(ExchangeError) },
                    { "503", typeof(ExchangeNotAvailable) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Insufficient", typeof(InsufficientFunds) },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "expireIn", 31536000 },
                { "fetchTickers", new Dictionary<string, object>() {
                    { "period", "1d" },
                } },
                { "fetchTrades", new Dictionary<string, object>() {
                    { "sort", "timestamp,asc" },
                } },
                { "fetchMyTrades", new Dictionary<string, object>() {
                    { "sort", "timestamp,asc" },
                } },
                { "fetchOpenOrders", new Dictionary<string, object>() {
                    { "sort", "createdAt,asc" },
                } },
                { "fetchClosedOrders", new Dictionary<string, object>() {
                    { "sort", "createdAt,asc" },
                } },
                { "defaultSort", "timestamp,asc" },
                { "defaultSortOrders", "createdAt,asc" },
            } },
        });
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name timex#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.tradingviewGetTime(parameters);
        //
        //     1708682617
        //
        return multiply(this.parseToInt(response), 1000);
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name timex#fetchMarkets
        * @description retrieves data on all markets for timex
        * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Public/listMarkets
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetMarkets(parameters);
        //
        //     [
        //         {
        //             "symbol": "ETHBTC",
        //             "name": "ETH/BTC",
        //             "baseCurrency": "ETH",
        //             "baseTokenAddress": "0x45932db54b38af1f5a57136302eeba66a5975c15",
        //             "quoteCurrency": "BTC",
        //             "quoteTokenAddress": "0x8370fbc6ddec1e18b4e41e72ed943e238458487c",
        //             "feeCurrency": "BTC",
        //             "feeTokenAddress": "0x8370fbc6ddec1e18b4e41e72ed943e238458487c",
        //             "quantityIncrement": "0.0000001",
        //             "takerFee": "0.005",
        //             "makerFee": "0.0025",
        //             "tickSize": "0.00000001",
        //             "baseMinSize": "0.0001",
        //             "quoteMinSize": "0.00001",
        //             "locked": false
        //         }
        //     ]
        //
        return this.parseMarkets(response);
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name timex#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Public/listCurrencies
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetCurrencies(parameters);
        //
        //     [
        //         {
        //             "symbol": "BTC",
        //             "name": "Bitcoin",
        //             "address": "0x8370fbc6ddec1e18b4e41e72ed943e238458487c",
        //             "icon": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggb3BhY2l0eT0iMC41IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTMwIDUzQzQyLjcwMjUgNTMgNTMgNDIuNzAyNSA1MyAzMEM1MyAxNy4yOTc1IDQyLjcwMjUgNyAzMCA3QzE3LjI5NzUgNyA3IDE3LjI5NzUgNyAzMEM3IDQyLjcwMjUgMTcuMjk3NSA1MyAzMCA1M1pNMzAgNTVDNDMuODA3MSA1NSA1NSA0My44MDcxIDU1IDMwQzU1IDE2LjE5MjkgNDMuODA3MSA1IDMwIDVDMTYuMTkyOSA1IDUgMTYuMTkyOSA1IDMwQzUgNDMuODA3MSAxNi4xOTI5IDU1IDMwIDU1WiIvPgo8cGF0aCBkPSJNNDAuOTQyNSAyNi42NTg1QzQxLjQwMDMgMjMuNjExMyAzOS4wNzA1IDIxLjk3MzIgMzUuODg0OCAyMC44ODA0TDM2LjkxODIgMTYuNzUyNkwzNC4zOTUxIDE2LjEyNjRMMzMuMzg5IDIwLjE0NTVDMzIuNzI1OCAxOS45ODA5IDMyLjA0NDUgMTkuODI1NiAzMS4zNjc1IDE5LjY3MTdMMzIuMzgwOCAxNS42MjYyTDI5Ljg1OTEgMTVMMjguODI1IDE5LjEyNjRDMjguMjc2IDE5LjAwMTkgMjcuNzM3IDE4Ljg3ODggMjcuMjEzOSAxOC43NDkzTDI3LjIxNjggMTguNzM2NEwyMy43MzcyIDE3Ljg3MTJMMjMuMDY2IDIwLjU1NDhDMjMuMDY2IDIwLjU1NDggMjQuOTM4IDIwLjk4MjEgMjQuODk4NSAyMS4wMDg1QzI1LjkyMDQgMjEuMjYyNiAyNi4xMDUgMjEuOTM2IDI2LjA3NDEgMjIuNDY5OUwyNC44OTcgMjcuMTcyNEMyNC45Njc1IDI3LjE5MDMgMjUuMDU4NyAyNy4yMTYgMjUuMTU5MyAyNy4yNTYxQzI1LjA3NTMgMjcuMjM1NCAyNC45ODU0IDI3LjIxMjQgMjQuODkyNyAyNy4xOTAzTDIzLjI0MjggMzMuNzc3OEMyMy4xMTc3IDM0LjA4NjkgMjIuODAwOCAzNC41NTA2IDIyLjA4NjUgMzQuMzc0NkMyMi4xMTE3IDM0LjQxMTEgMjAuMjUyNiAzMy45MTg3IDIwLjI1MjYgMzMuOTE4N0wxOSAzNi43OTQ5TDIyLjI4MzQgMzcuNjFDMjIuODk0MiAzNy43NjI0IDIzLjQ5MjggMzcuOTIyIDI0LjA4MjEgMzguMDcyM0wyMy4wMzggNDIuMjQ3NEwyNS41NTgyIDQyLjg3MzZMMjYuNTkyMyAzOC43NDI5QzI3LjI4MDcgMzguOTI5IDI3Ljk0OSAzOS4xMDA3IDI4LjYwMyAzOS4yNjI0TDI3LjU3MjUgNDMuMzczOEwzMC4wOTU2IDQ0TDMxLjEzOTcgMzkuODMyOEMzNS40NDIyIDQwLjY0MzYgMzguNjc3NCA0MC4zMTY2IDQwLjAzOTIgMzYuNDQxNEM0MS4xMzY1IDMzLjMyMTIgMzkuOTg0NiAzMS41MjEzIDM3LjcyMDkgMzAuMzQ3N0MzOS4zNjk0IDI5Ljk2OTEgNDAuNjExMiAyOC44ODkyIDQwLjk0MjUgMjYuNjU4NVYyNi42NTg1Wk0zNS4xNzc3IDM0LjcwODhDMzQuMzk4IDM3LjgyOSAyOS4xMjI2IDM2LjE0MjIgMjcuNDEyMiAzNS43MTkzTDI4Ljc5NzcgMzAuMTg4MUMzMC41MDgxIDMwLjYxMzIgMzUuOTkyNiAzMS40NTQ4IDM1LjE3NzcgMzQuNzA4OFpNMzUuOTU4MSAyNi42MTM0QzM1LjI0NjcgMjkuNDUxNyAzMC44NTU5IDI4LjAwOTcgMjkuNDMxNiAyNy42NTYxTDMwLjY4NzcgMjIuNjM5NUMzMi4xMTIgMjIuOTkzIDM2LjY5OSAyMy42NTI4IDM1Ljk1ODEgMjYuNjEzNFoiLz4KPC9zdmc+Cg==",
        //             "background": "transparent",
        //             "fiatSymbol": "BTC",
        //             "decimals": 8,
        //             "tradeDecimals": 20,
        //             "displayDecimals": 4,
        //             "crypto": true,
        //             "depositEnabled": true,
        //             "withdrawalEnabled": true,
        //             "transferEnabled": true,
        //             "buyEnabled": false,
        //             "purchaseEnabled": false,
        //             "redeemEnabled": false,
        //             "active": true,
        //             "withdrawalFee": "50000000000000000",
        //             "purchaseCommissions": []
        //         },
        //     ]
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object currency = getValue(response, i);
            ((IList<object>)result).Add(this.parseCurrency(currency));
        }
        return this.indexBy(result, "code");
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name timex#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Manager/getDeposits
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object address = this.safeString(parameters, "address");
        parameters = this.omit(parameters, "address");
        if (isTrue(isEqual(address, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDeposits() requires an address parameter")) ;
        }
        object request = new Dictionary<string, object>() {
            { "address", address },
        };
        object response = await this.managerGetDeposits(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "from": "0x1134cc86b45039cc211c6d1d2e4b3c77f60207ed",
        //             "timestamp": "2022-01-01T00:00:00Z",
        //             "to": "0x1134cc86b45039cc211c6d1d2e4b3c77f60207ed",
        //             "token": "0x6baad3fe5d0fd4be604420e728adbd68d67e119e",
        //             "transferHash": "0x5464cdff35448314e178b8677ea41e670ea0f2533f4e52bfbd4e4a6cfcdef4c2",
        //             "value": "100"
        //         }
        //     ]
        //
        object currency = this.safeCurrency(code);
        return this.parseTransactions(response, currency, since, limit);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name timex#fetchWithdrawals
        * @description fetch all withdrawals made to an account
        * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Manager/getWithdraws
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of transaction structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object address = this.safeString(parameters, "address");
        parameters = this.omit(parameters, "address");
        if (isTrue(isEqual(address, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDeposits() requires an address parameter")) ;
        }
        object request = new Dictionary<string, object>() {
            { "address", address },
        };
        object response = await this.managerGetWithdrawals(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "from": "0x1134cc86b45039cc211c6d1d2e4b3c77f60207ed",
        //             "timestamp": "2022-01-01T00:00:00Z",
        //             "to": "0x1134cc86b45039cc211c6d1d2e4b3c77f60207ed",
        //             "token": "0x6baad3fe5d0fd4be604420e728adbd68d67e119e",
        //             "transferHash": "0x5464cdff35448314e178b8677ea41e670ea0f2533f4e52bfbd4e4a6cfcdef4c2",
        //             "value": "100"
        //         }
        //     ]
        //
        object currency = this.safeCurrency(code);
        return this.parseTransactions(response, currency, since, limit);
    }

    public virtual object getCurrencyByAddress(object address)
    {
        object currencies = ((object)this.currencies);
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currency = getValue(currencies, i);
            object info = this.safeValue(currency, "info", new Dictionary<string, object>() {});
            object a = this.safeString(info, "address");
            if (isTrue(isEqual(a, address)))
            {
                return currency;
            }
        }
        return null;
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        //     {
        //         "from": "0x1134cc86b45039cc211c6d1d2e4b3c77f60207ed",
        //         "timestamp": "2022-01-01T00:00:00Z",
        //         "to": "0x1134cc86b45039cc211c6d1d2e4b3c77f60207ed",
        //         "token": "0x6baad3fe5d0fd4be604420e728adbd68d67e119e",
        //         "transferHash": "0x5464cdff35448314e178b8677ea41e670ea0f2533f4e52bfbd4e4a6cfcdef4c2",
        //         "value": "100"
        //     }
        //
        object datetime = this.safeString(transaction, "timestamp");
        object currencyAddresss = this.safeString(transaction, "token", "");
        currency = this.getCurrencyByAddress(currencyAddresss);
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString(transaction, "transferHash") },
            { "txid", this.safeString(transaction, "txid") },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "network", null },
            { "address", null },
            { "addressTo", this.safeString(transaction, "to") },
            { "addressFrom", this.safeString(transaction, "from") },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", null },
            { "amount", this.safeNumber(transaction, "value") },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "status", "ok" },
            { "updated", null },
            { "internal", null },
            { "comment", null },
            { "fee", null },
        };
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name timex#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Public/listTickers
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object period = this.safeString(getValue(this.options, "fetchTickers"), "period", "1d");
        object request = new Dictionary<string, object>() {
            { "period", getValue(this.timeframes, period) },
        };
        object response = await this.publicGetTickers(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "ask": 0.017,
        //             "bid": 0.016,
        //             "high": 0.019,
        //             "last": 0.017,
        //             "low": 0.015,
        //             "market": "TIME/ETH",
        //             "open": 0.016,
        //             "period": "H1",
        //             "timestamp": "2018-12-14T20:50:36.134Z",
        //             "volume": 4.57,
        //             "volumeQuote": 0.07312
        //         }
        //     ]
        //
        return this.parseTickers(response, symbols);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name timex#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Public/listTickers
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object period = this.safeString(getValue(this.options, "fetchTickers"), "period", "1d");
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "period", getValue(this.timeframes, period) },
        };
        object response = await this.publicGetTickers(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "ask": 0.017,
        //             "bid": 0.016,
        //             "high": 0.019,
        //             "last": 0.017,
        //             "low": 0.015,
        //             "market": "TIME/ETH",
        //             "open": 0.016,
        //             "period": "H1",
        //             "timestamp": "2018-12-14T20:50:36.134Z",
        //             "volume": 4.57,
        //             "volumeQuote": 0.07312
        //         }
        //     ]
        //
        object ticker = this.safeDict(response, 0);
        return this.parseTicker(ticker, market);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name timex#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Public/orderbookV2
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.publicGetOrderbookV2(this.extend(request, parameters));
        //
        //     {
        //         "timestamp":"2019-12-05T00:21:09.538",
        //         "bid":[
        //             {
        //                 "index":"2",
        //                 "price":"0.02024007",
        //                 "baseTokenAmount":"0.0096894",
        //                 "baseTokenCumulativeAmount":"0.0096894",
        //                 "quoteTokenAmount":"0.000196114134258",
        //                 "quoteTokenCumulativeAmount":"0.000196114134258"
        //             },
        //         "ask":[
        //             {
        //                 "index":"-3",
        //                 "price":"0.02024012",
        //                 "baseTokenAmount":"0.005",
        //                 "baseTokenCumulativeAmount":"0.005",
        //                 "quoteTokenAmount":"0.0001012006",
        //                 "quoteTokenCumulativeAmount":"0.0001012006"
        //             },
        //         ]
        //     }
        //
        object timestamp = this.parse8601(this.safeString(response, "timestamp"));
        return this.parseOrderBook(response, symbol, timestamp, "bid", "ask", "price", "baseTokenAmount");
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name timex#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Public/listTrades
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object options = this.safeValue(this.options, "fetchTrades", new Dictionary<string, object>() {});
        object defaultSort = this.safeValue(options, "sort", "timestamp,asc");
        object sort = this.safeString(parameters, "sort", defaultSort);
        object query = this.omit(parameters, "sort");
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "sort", sort },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit; // default is 100
        }
        object response = await this.publicGetTrades(this.extend(request, query));
        //
        //     [
        //         {
        //             "id":1,
        //             "timestamp":"2019-06-25T17:01:50.309",
        //             "direction":"BUY",
        //             "price":"0.027",
        //             "quantity":"0.001"
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name timex#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Public/listCandles
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "period", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        // if since and limit are not specified
        object duration = this.parseTimeframe(timeframe);
        if (isTrue(isEqual(limit, null)))
        {
            limit = 1000; // exchange provides tens of thousands of data, but we set generous default value
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = this.iso8601(since);
            ((IDictionary<string,object>)request)["till"] = this.iso8601(this.sum(since, multiply(multiply(this.sum(limit, 1), duration), 1000)));
        } else
        {
            object now = this.milliseconds();
            ((IDictionary<string,object>)request)["till"] = this.iso8601(now);
            ((IDictionary<string,object>)request)["from"] = this.iso8601(subtract(subtract(now, multiply(multiply(limit, duration), 1000)), 1));
        }
        object response = await this.publicGetCandles(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "timestamp":"2019-12-04T23:00:00",
        //             "open":"0.02024009",
        //             "high":"0.02024009",
        //             "low":"0.02024009",
        //             "close":"0.02024009",
        //             "volume":"0.00008096036",
        //             "volumeQuote":"0.004",
        //         },
        //     ]
        //
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object balance = getValue(response, i);
            object currencyId = this.safeString(balance, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "totalBalance");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "lockedBalance");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name timex#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Trading/getBalances
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.tradingGetBalances(parameters);
        //
        //     [
        //         {"currency":"BTC","totalBalance":"0","lockedBalance":"0"},
        //         {"currency":"AUDT","totalBalance":"0","lockedBalance":"0"},
        //         {"currency":"ETH","totalBalance":"0","lockedBalance":"0"},
        //         {"currency":"TIME","totalBalance":"0","lockedBalance":"0"},
        //         {"currency":"USDT","totalBalance":"0","lockedBalance":"0"}
        //     ]
        //
        return this.parseBalance(response);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name timex#createOrder
        * @description create a trade order
        * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Trading/createOrder
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object uppercaseSide = ((string)side).ToUpper();
        object uppercaseType = ((string)type).ToUpper();
        object postOnly = this.safeBool(parameters, "postOnly", false);
        if (isTrue(postOnly))
        {
            uppercaseType = "POST_ONLY";
            parameters = this.omit(parameters, new List<object>() {"postOnly"});
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "quantity", this.amountToPrecision(symbol, amount) },
            { "side", uppercaseSide },
            { "orderTypes", uppercaseType },
        };
        object query = parameters;
        if (isTrue(isTrue((isEqual(uppercaseType, "LIMIT"))) || isTrue((isEqual(uppercaseType, "POST_ONLY")))))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            object defaultExpireIn = this.safeInteger(this.options, "expireIn");
            object expireTime = this.safeValue(parameters, "expireTime");
            object expireIn = this.safeValue(parameters, "expireIn", defaultExpireIn);
            if (isTrue(!isEqual(expireTime, null)))
            {
                ((IDictionary<string,object>)request)["expireTime"] = expireTime;
            } else if (isTrue(!isEqual(expireIn, null)))
            {
                ((IDictionary<string,object>)request)["expireIn"] = expireIn;
            } else
            {
                throw new InvalidOrder ((string)add(add(add(this.id, " createOrder() method requires a expireTime or expireIn param for a "), type), " order, you can also set the expireIn exchange-wide option")) ;
            }
            query = this.omit(parameters, new List<object>() {"expireTime", "expireIn"});
        } else
        {
            ((IDictionary<string,object>)request)["price"] = 0;
        }
        object response = await this.tradingPostOrders(this.extend(request, query));
        //
        //     {
        //         "orders": [
        //             {
        //                 "cancelledQuantity": "0.3",
        //                 "clientOrderId": "my-order-1",
        //                 "createdAt": "1970-01-01T00:00:00",
        //                 "cursorId": 50,
        //                 "expireTime": "1970-01-01T00:00:00",
        //                 "filledQuantity": "0.3",
        //                 "id": "string",
        //                 "price": "0.017",
        //                 "quantity": "0.3",
        //                 "side": "BUY",
        //                 "symbol": "TIMEETH",
        //                 "type": "LIMIT",
        //                 "updatedAt": "1970-01-01T00:00:00"
        //             }
        //         ]
        //     }
        //
        object orders = this.safeValue(response, "orders", new List<object>() {});
        object order = this.safeDict(orders, 0, new Dictionary<string, object>() {});
        return this.parseOrder(order, market);
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object response = await this.tradingPutOrders(this.extend(request, parameters));
        //
        //     {
        //         "changedOrders": [
        //             {
        //                 "newOrder": {
        //                 "cancelledQuantity": "0.3",
        //                 "clientOrderId": "my-order-1",
        //                 "createdAt": "1970-01-01T00:00:00",
        //                 "cursorId": 50,
        //                 "expireTime": "1970-01-01T00:00:00",
        //                 "filledQuantity": "0.3",
        //                 "id": "string",
        //                 "price": "0.017",
        //                 "quantity": "0.3",
        //                 "side": "BUY",
        //                 "symbol": "TIMEETH",
        //                 "type": "LIMIT",
        //                 "updatedAt": "1970-01-01T00:00:00"
        //                 },
        //                 "oldId": "string",
        //             },
        //         ],
        //         "unchangedOrders": [ "string" ],
        //     }
        //
        if (isTrue(inOp(response, "unchangedOrders")))
        {
            object orderIds = this.safeValue(response, "unchangedOrders", new List<object>() {});
            object orderId = this.safeString(orderIds, 0);
            return this.safeOrder(new Dictionary<string, object>() {
                { "id", orderId },
                { "info", response },
            });
        }
        object orders = this.safeValue(response, "changedOrders", new List<object>() {});
        object firstOrder = this.safeValue(orders, 0, new Dictionary<string, object>() {});
        object order = this.safeDict(firstOrder, "newOrder", new Dictionary<string, object>() {});
        return this.parseOrder(order, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name timex#cancelOrder
        * @description cancels an open order
        * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Trading/deleteOrders
        * @param {string} id order id
        * @param {string} symbol not used by timex cancelOrder ()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        return await this.cancelOrders(new List<object>() {id}, symbol, parameters);
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name timex#cancelOrders
        * @description cancel multiple orders
        * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Trading/deleteOrders
        * @param {string[]} ids order ids
        * @param {string} symbol unified market symbol, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", ids },
        };
        object response = await this.tradingDeleteOrders(this.extend(request, parameters));
        //
        //     {
        //         "changedOrders": [
        //             {
        //                 "newOrder": {
        //                     "cancelledQuantity": "0.3",
        //                     "clientOrderId": "my-order-1",
        //                     "createdAt": "1970-01-01T00:00:00",
        //                     "cursorId": 50,
        //                     "expireTime": "1970-01-01T00:00:00",
        //                     "filledQuantity": "0.3",
        //                     "id": "string",
        //                     "price": "0.017",
        //                     "quantity": "0.3",
        //                     "side": "BUY",
        //                     "symbol": "TIMEETH",
        //                     "type": "LIMIT",
        //                     "updatedAt": "1970-01-01T00:00:00"
        //                 },
        //                 "oldId": "string",
        //             },
        //         ],
        //         "unchangedOrders": [ "string" ],
        //     }
        return response;
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name timex#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/History/getOrderDetails
        * @param {string} symbol not used by timex fetchOrder
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderHash", id },
        };
        object response = await this.historyGetOrdersDetails(request);
        //
        //     {
        //         "order": {
        //             "cancelledQuantity": "0.3",
        //             "clientOrderId": "my-order-1",
        //             "createdAt": "1970-01-01T00:00:00",
        //             "cursorId": 50,
        //             "expireTime": "1970-01-01T00:00:00",
        //             "filledQuantity": "0.3",
        //             "id": "string",
        //             "price": "0.017",
        //             "quantity": "0.3",
        //             "side": "BUY",
        //             "symbol": "TIMEETH",
        //             "type": "LIMIT",
        //             "updatedAt": "1970-01-01T00:00:00"
        //         },
        //         "trades": [
        //             {
        //                 "fee": "0.3",
        //                 "id": 100,
        //                 "makerOrTaker": "MAKER",
        //                 "makerOrderId": "string",
        //                 "price": "0.017",
        //                 "quantity": "0.3",
        //                 "side": "BUY",
        //                 "symbol": "TIMEETH",
        //                 "takerOrderId": "string",
        //                 "timestamp": "2019-12-05T07:48:26.310Z"
        //             }
        //         ]
        //     }
        //
        object order = this.safeValue(response, "order", new Dictionary<string, object>() {});
        object trades = this.safeList(response, "trades", new List<object>() {});
        return this.parseOrder(this.extend(order, new Dictionary<string, object>() {
            { "trades", trades },
        }));
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name timex#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Trading/getOpenOrders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object options = this.safeValue(this.options, "fetchOpenOrders", new Dictionary<string, object>() {});
        object defaultSort = this.safeValue(options, "sort", "createdAt,asc");
        object sort = this.safeString(parameters, "sort", defaultSort);
        object query = this.omit(parameters, "sort");
        object request = new Dictionary<string, object>() {
            { "sort", sort },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        }
        object response = await this.tradingGetOrders(this.extend(request, query));
        //
        //     {
        //         "orders": [
        //             {
        //                 "cancelledQuantity": "0.3",
        //                 "clientOrderId": "my-order-1",
        //                 "createdAt": "1970-01-01T00:00:00",
        //                 "cursorId": 50,
        //                 "expireTime": "1970-01-01T00:00:00",
        //                 "filledQuantity": "0.3",
        //                 "id": "string",
        //                 "price": "0.017",
        //                 "quantity": "0.3",
        //                 "side": "BUY",
        //                 "symbol": "TIMEETH",
        //                 "type": "LIMIT",
        //                 "updatedAt": "1970-01-01T00:00:00"
        //             }
        //         ]
        //     }
        //
        object orders = this.safeList(response, "orders", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name timex#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/History/getOrders
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object options = this.safeValue(this.options, "fetchClosedOrders", new Dictionary<string, object>() {});
        object defaultSort = this.safeValue(options, "sort", "createdAt,asc");
        object sort = this.safeString(parameters, "sort", defaultSort);
        object query = this.omit(parameters, "sort");
        object request = new Dictionary<string, object>() {
            { "sort", sort },
            { "side", "BUY" },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        }
        object response = await this.historyGetOrders(this.extend(request, query));
        //
        //     {
        //         "orders": [
        //             {
        //                 "cancelledQuantity": "0.3",
        //                 "clientOrderId": "my-order-1",
        //                 "createdAt": "1970-01-01T00:00:00",
        //                 "cursorId": 50,
        //                 "expireTime": "1970-01-01T00:00:00",
        //                 "filledQuantity": "0.3",
        //                 "id": "string",
        //                 "price": "0.017",
        //                 "quantity": "0.3",
        //                 "side": "BUY",
        //                 "symbol": "TIMEETH",
        //                 "type": "LIMIT",
        //                 "updatedAt": "1970-01-01T00:00:00"
        //             }
        //         ]
        //     }
        //
        object orders = this.safeList(response, "orders", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name timex#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/History/getTrades_1
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object options = this.safeValue(this.options, "fetchMyTrades", new Dictionary<string, object>() {});
        object defaultSort = this.safeValue(options, "sort", "timestamp,asc");
        object sort = this.safeString(parameters, "sort", defaultSort);
        object query = this.omit(parameters, "sort");
        object request = new Dictionary<string, object>() {
            { "sort", sort },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        }
        object response = await this.historyGetTrades(this.extend(request, query));
        //
        //     {
        //         "trades": [
        //             {
        //                 "fee": "0.3",
        //                 "id": 100,
        //                 "makerOrTaker": "MAKER",
        //                 "makerOrderId": "string",
        //                 "price": "0.017",
        //                 "quantity": "0.3",
        //                 "side": "BUY",
        //                 "symbol": "TIMEETH",
        //                 "takerOrderId": "string",
        //                 "timestamp": "2019-12-08T04:54:11.171Z"
        //             }
        //         ]
        //     }
        //
        object trades = this.safeList(response, "trades", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        //
        //     {
        //         "fee": 0.0075,
        //         "market": "ETHBTC"
        //     }
        //
        object marketId = this.safeString(fee, "market");
        object rate = this.safeNumber(fee, "fee");
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", this.safeSymbol(marketId, market) },
            { "maker", rate },
            { "taker", rate },
            { "percentage", null },
            { "tierBased", null },
        };
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name timex#fetchTradingFee
        * @description fetch the trading fees for a market
        * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Trading/getFees
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "markets", getValue(market, "id") },
        };
        object response = await this.tradingGetFees(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "fee": 0.0075,
        //             "market": "ETHBTC"
        //         }
        //     ]
        //
        object result = this.safeValue(response, 0, new Dictionary<string, object>() {});
        return this.parseTradingFee(result, market);
    }

    public override object parseMarket(object market)
    {
        //
        //     {
        //         "symbol": "ETHBTC",
        //         "name": "ETH/BTC",
        //         "baseCurrency": "ETH",
        //         "baseTokenAddress": "0x45932db54b38af1f5a57136302eeba66a5975c15",
        //         "quoteCurrency": "BTC",
        //         "quoteTokenAddress": "0x8370fbc6ddec1e18b4e41e72ed943e238458487c",
        //         "feeCurrency": "BTC",
        //         "feeTokenAddress": "0x8370fbc6ddec1e18b4e41e72ed943e238458487c",
        //         "quantityIncrement": "0.0000001",
        //         "takerFee": "0.005",
        //         "makerFee": "0.0025",
        //         "tickSize": "0.00000001",
        //         "baseMinSize": "0.0001",
        //         "quoteMinSize": "0.00001",
        //         "locked": false
        //     }
        //
        object locked = this.safeValue(market, "locked");
        object id = this.safeString(market, "symbol");
        object baseId = this.safeString(market, "baseCurrency");
        object quoteId = this.safeString(market, "quoteCurrency");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object amountIncrement = this.safeString(market, "quantityIncrement");
        object minBase = this.safeString(market, "baseMinSize");
        object minAmount = Precise.stringMax(amountIncrement, minBase);
        object priceIncrement = this.safeString(market, "tickSize");
        object minCost = this.safeNumber(market, "quoteMinSize");
        return new Dictionary<string, object>() {
            { "id", id },
            { "symbol", add(add(bs, "/"), quote) },
            { "base", bs },
            { "quote", quote },
            { "settle", null },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", null },
            { "type", "spot" },
            { "spot", true },
            { "margin", false },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "active", !isTrue(locked) },
            { "contract", false },
            { "linear", null },
            { "inverse", null },
            { "taker", this.safeNumber(market, "takerFee") },
            { "maker", this.safeNumber(market, "makerFee") },
            { "contractSize", null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber(market, "quantityIncrement") },
                { "price", this.safeNumber(market, "tickSize") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.parseNumber(minAmount) },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", this.parseNumber(priceIncrement) },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", minCost },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        };
    }

    public virtual object parseCurrency(object currency)
    {
        //
        //     {
        //         "symbol": "BTC",
        //         "name": "Bitcoin",
        //         "address": "0x8370fbc6ddec1e18b4e41e72ed943e238458487c",
        //         "icon": "data:image/svg+xml;base64,PHN2ZyB3aWR...mc+Cg==",
        //         "background": "transparent",
        //         "fiatSymbol": "BTC",
        //         "decimals": 8,
        //         "tradeDecimals": 20,
        //         "displayDecimals": 4,
        //         "crypto": true,
        //         "depositEnabled": true,
        //         "withdrawalEnabled": true,
        //         "transferEnabled": true,
        //         "buyEnabled": false,
        //         "purchaseEnabled": false,
        //         "redeemEnabled": false,
        //         "active": true,
        //         "withdrawalFee": "50000000000000000",
        //         "purchaseCommissions": []
        //     }
        //
        // https://github.com/ccxt/ccxt/issues/6878
        //
        //     {
        //         "symbol":"XRP",
        //         "name":"Ripple",
        //         "address":"0x0dc8882914f3ddeebf4cec6dc20edb99df3def6c",
        //         "decimals":6,
        //         "tradeDecimals":16,
        //         "depositEnabled":true,
        //         "withdrawalEnabled":true,
        //         "transferEnabled":true,
        //         "active":true
        //     }
        //
        object id = this.safeString(currency, "symbol");
        object code = this.safeCurrencyCode(id);
        object name = this.safeString(currency, "name");
        object depositEnabled = this.safeValue(currency, "depositEnabled");
        object withdrawEnabled = this.safeValue(currency, "withdrawalEnabled");
        object isActive = this.safeValue(currency, "active");
        object active = isTrue(isTrue(depositEnabled) && isTrue(withdrawEnabled)) && isTrue(isActive);
        // const fee = this.safeNumber (currency, 'withdrawalFee');
        object feeString = this.safeString(currency, "withdrawalFee");
        object tradeDecimals = this.safeInteger(currency, "tradeDecimals");
        object fee = null;
        if (isTrue(isTrue((!isEqual(feeString, null))) && isTrue((!isEqual(tradeDecimals, null)))))
        {
            object feeStringLen = ((string)feeString).Length;
            object dotIndex = subtract(feeStringLen, tradeDecimals);
            if (isTrue(isGreaterThan(dotIndex, 0)))
            {
                object whole = slice(feeString, 0, dotIndex);
                object fraction = slice(feeString, prefixUnaryNeg(ref dotIndex), null);
                fee = this.parseNumber(add(add(whole, "."), fraction));
            } else
            {
                object fraction = ".";
                for (object i = 0; isLessThan(i, prefixUnaryNeg(ref dotIndex)); postFixIncrement(ref i))
                {
                    fraction = add(fraction, "0");
                }
                fee = this.parseNumber(add(fraction, feeString));
            }
        }
        return new Dictionary<string, object>() {
            { "id", code },
            { "code", code },
            { "info", currency },
            { "type", null },
            { "name", name },
            { "active", active },
            { "deposit", depositEnabled },
            { "withdraw", withdrawEnabled },
            { "fee", fee },
            { "precision", this.parseNumber(this.parsePrecision(this.safeString(currency, "decimals"))) },
            { "limits", new Dictionary<string, object>() {
                { "withdraw", new Dictionary<string, object>() {
                    { "min", fee },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "ask": 0.017,
        //         "bid": 0.016,
        //         "high": 0.019,
        //         "last": 0.017,
        //         "low": 0.015,
        //         "market": "TIME/ETH",
        //         "open": 0.016,
        //         "period": "H1",
        //         "timestamp": "2018-12-14T20:50:36.134Z",
        //         "volume": 4.57,
        //         "volumeQuote": 0.07312
        //     }
        //
        object marketId = this.safeString(ticker, "market");
        object symbol = this.safeSymbol(marketId, market, "/");
        object timestamp = this.parse8601(this.safeString(ticker, "timestamp"));
        object last = this.safeString(ticker, "last");
        object open = this.safeString(ticker, "open");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "info", ticker },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(ticker, "bid") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "ask") },
            { "askVolume", null },
            { "vwap", null },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "volume") },
            { "quoteVolume", this.safeString(ticker, "volumeQuote") },
        }, market);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //     {
        //         "id":1,
        //         "timestamp":"2019-06-25T17:01:50.309",
        //         "direction":"BUY",
        //         "price":"0.027",
        //         "quantity":"0.001"
        //     }
        //
        // fetchMyTrades, fetchOrder (private)
        //
        //     {
        //         "id": "7613414",
        //         "makerOrderId": "0x8420af060722f560098f786a2894d4358079b6ea5d14b395969ed77bc87a623a",
        //         "takerOrderId": "0x1235ef158a361815b54c9988b6241c85aedcbc1fe81caf8df8587d5ab0373d1a",
        //         "symbol": "LTCUSDT",
        //         "side": "BUY",
        //         "quantity": "0.2",
        //         "fee": "0.22685",
        //         "feeToken": "USDT",
        //         "price": "226.85",
        //         "makerOrTaker": "TAKER",
        //         "timestamp": "2021-04-09T15:39:45.608"
        //    }
        //
        object marketId = this.safeString(trade, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object timestamp = this.parse8601(this.safeString(trade, "timestamp"));
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString(trade, "quantity");
        object price = this.parseNumber(priceString);
        object amount = this.parseNumber(amountString);
        object cost = this.parseNumber(Precise.stringMul(priceString, amountString));
        object id = this.safeString(trade, "id");
        object side = this.safeStringLower2(trade, "direction", "side");
        object takerOrMaker = this.safeStringLower(trade, "makerOrTaker");
        object orderId = null;
        if (isTrue(!isEqual(takerOrMaker, null)))
        {
            orderId = this.safeString(trade, add(takerOrMaker, "OrderId"));
        }
        object fee = null;
        object feeCost = this.safeNumber(trade, "fee");
        object feeCurrency = this.safeCurrencyCode(this.safeString(trade, "feeToken"));
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrency },
            };
        }
        return new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "order", orderId },
            { "type", null },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "takerOrMaker", takerOrMaker },
            { "fee", fee },
        };
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "timestamp":"2019-12-04T23:00:00",
        //         "open":"0.02024009",
        //         "high":"0.02024009",
        //         "low":"0.02024009",
        //         "close":"0.02024009",
        //         "volume":"0.00008096036",
        //         "volumeQuote":"0.004",
        //     }
        //
        return new List<object> {this.parse8601(this.safeString(ohlcv, "timestamp")), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // fetchOrder, createOrder, cancelOrder, cancelOrders, fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "cancelledQuantity": "0.3",
        //         "clientOrderId": "my-order-1",
        //         "createdAt": "1970-01-01T00:00:00",
        //         "cursorId": 50,
        //         "expireTime": "1970-01-01T00:00:00",
        //         "filledQuantity": "0.3",
        //         "id": "string",
        //         "price": "0.017",
        //         "quantity": "0.3",
        //         "side": "BUY",
        //         "symbol": "TIMEETH",
        //         "type": "LIMIT",
        //         "updatedAt": "1970-01-01T00:00:00"
        //         "trades": [], // injected from the outside
        //     }
        //
        object id = this.safeString(order, "id");
        object type = this.safeStringLower(order, "type");
        object side = this.safeStringLower(order, "side");
        object marketId = this.safeString(order, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object timestamp = this.parse8601(this.safeString(order, "createdAt"));
        object price = this.safeString(order, "price");
        object amount = this.safeString(order, "quantity");
        object filled = this.safeString(order, "filledQuantity");
        object canceledQuantity = this.omitZero(this.safeString(order, "cancelledQuantity"));
        object status = null;
        if (isTrue(Precise.stringEquals(filled, amount)))
        {
            status = "closed";
        } else if (isTrue(!isEqual(canceledQuantity, null)))
        {
            status = "canceled";
        } else
        {
            status = "open";
        }
        object rawTrades = this.safeValue(order, "trades", new List<object>() {});
        object clientOrderId = this.safeString(order, "clientOrderId");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "amount", amount },
            { "cost", null },
            { "average", null },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", null },
            { "trades", rawTrades },
        }, market);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name timex#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account, does not accept params["network"]
        * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Currency/selectCurrencyBySymbol
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(currency, "code") },
        };
        object response = await this.currenciesGetSSymbol(this.extend(request, parameters));
        //
        //    {
        //        id: '1',
        //        currency: {
        //            symbol: 'BTC',
        //            name: 'Bitcoin',
        //            address: '0x8370fbc6ddec1e18b4e41e72ed943e238458487c',
        //            decimals: '8',
        //            tradeDecimals: '20',
        //            fiatSymbol: 'BTC',
        //            depositEnabled: true,
        //            withdrawalEnabled: true,
        //            transferEnabled: true,
        //            active: true
        //        }
        //    }
        //
        object data = this.safeDict(response, "currency", new Dictionary<string, object>() {});
        return this.parseDepositAddress(data, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //    {
        //        symbol: 'BTC',
        //        name: 'Bitcoin',
        //        address: '0x8370fbc6ddec1e18b4e41e72ed943e238458487c',
        //        decimals: '8',
        //        tradeDecimals: '20',
        //        fiatSymbol: 'BTC',
        //        depositEnabled: true,
        //        withdrawalEnabled: true,
        //        transferEnabled: true,
        //        active: true
        //    }
        //
        object currencyId = this.safeString(depositAddress, "symbol");
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "address", this.safeString(depositAddress, "address") },
            { "tag", null },
            { "network", null },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object paramsToExtract = this.extractParams(path);
        path = this.implodeParams(path, parameters);
        parameters = this.omit(parameters, paramsToExtract);
        object url = add(add(add(add(getValue(getValue(this.urls, "api"), "rest"), "/"), api), "/"), path);
        if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
        {
            url = add(url, add("?", this.urlencodeWithArrayRepeat(parameters)));
        }
        if (isTrue(isTrue(!isEqual(api, "public")) && isTrue(!isEqual(api, "tradingview"))))
        {
            this.checkRequiredCredentials();
            object auth = this.stringToBase64(add(add(this.apiKey, ":"), this.secret));
            object secret = add("Basic ", auth);
            headers = new Dictionary<string, object>() {
                { "authorization", secret },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object statusCode, object statusText, object url, object method, object responseHeaders, object responseBody, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        if (isTrue(isGreaterThanOrEqual(statusCode, 400)))
        {
            //
            //     {"error":{"timestamp":"05.12.2019T05:25:43.584+0000","status":"BAD_REQUEST","message":"Insufficient ETH balance. Required: 1, actual: 0.","code":4001}}
            //     {"error":{"timestamp":"05.12.2019T04:03:25.419+0000","status":"FORBIDDEN","message":"Access denied","code":4300}}
            //
            object feedback = add(add(this.id, " "), responseBody);
            object error = this.safeValue(response, "error");
            if (isTrue(isEqual(error, null)))
            {
                error = response;
            }
            object code = this.safeString2(error, "code", "status");
            object message = this.safeString2(error, "message", "debugMessage");
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
