namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class ellipx : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "ellipx" },
            { "name", "Ellipx" },
            { "countries", new List<object>() {"PL"} },
            { "rateLimit", 200 },
            { "version", "v1" },
            { "certified", false },
            { "pro", false },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", false },
                { "cancelAllOrdersAfter", false },
                { "cancelOrder", true },
                { "cancelOrders", false },
                { "cancelWithdraw", false },
                { "closePosition", false },
                { "createConvertTrade", false },
                { "createDepositAddress", false },
                { "createMarketBuyOrderWithCost", false },
                { "createMarketOrder", false },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrderWithTakeProfitAndStopLoss", false },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", false },
                { "createStopLossOrder", false },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "createTakeProfitOrder", false },
                { "createTrailingAmountOrder", false },
                { "createTrailingPercentOrder", false },
                { "createTriggerOrder", false },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchCanceledAndClosedOrders", false },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrder", false },
                { "fetchClosedOrders", false },
                { "fetchConvertCurrencies", false },
                { "fetchConvertQuote", false },
                { "fetchConvertTrade", false },
                { "fetchConvertTradeHistory", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", false },
                { "fetchDepositsWithdrawals", false },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchLedger", false },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", false },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchOrderTrades", true },
                { "fetchPosition", false },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsForSymbol", false },
                { "fetchPositionsHistory", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", false },
                { "fetchTicker", true },
                { "fetchTickers", false },
                { "fetchTime", false },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchTransactions", false },
                { "fetchTransfers", false },
                { "fetchWithdrawals", false },
                { "reduceMargin", false },
                { "sandbox", false },
                { "setLeverage", false },
                { "setMargin", false },
                { "setPositionMode", false },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "5m", "5m" },
                { "10m", "10m" },
                { "1h", "1h" },
                { "6h", "6h" },
                { "12h", "12h" },
                { "1d", "1d" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/e07c3f40-281c-4cdf-bacf-fa1c58218a2c" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://data.ellipx.com" },
                    { "private", "https://app.ellipx.com/_rest" },
                    { "_rest", "https://app.ellipx.com/_rest" },
                } },
                { "www", "https://www.ellipx.com" },
                { "doc", "https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM" },
                { "fees", "https://www.ellipx.com/pages/pricing" },
                { "referral", "" },
            } },
            { "api", new Dictionary<string, object>() {
                { "_rest", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "Market", 1 },
                        { "Market/{currencyPair}", 1 },
                        { "Crypto/Token/Info", 1 },
                    } },
                } },
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "Market/{currencyPair}:getDepth", 1 },
                        { "Market/{currencyPair}:ticker", 1 },
                        { "Market/{currencyPair}:getTrades", 1 },
                        { "Market/{currencyPair}:getGraph", 1 },
                        { "CMC:summary", 1 },
                        { "CMC/{currencyPair}:ticker", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "User/Wallet", 1 },
                        { "Market/{currencyPair}/Order", 1 },
                        { "Market/Order/{orderUuid}", 1 },
                        { "Market/{currencyPair}/Trade", 1 },
                        { "Market/TradeFee:query", 1 },
                        { "Unit/{currency}", 1 },
                        { "Crypto/Token/{currency}", 1 },
                        { "Crypto/Token/{currency}:chains", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "Market/{currencyPair}/Order", 1 },
                        { "Crypto/Address:fetch", 1 },
                        { "Crypto/Disbursement:withdraw", 1 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "Market/Order/{orderUuid}", 1 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "feeSide", "get" },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.0025") },
                    { "taker", this.parseNumber("0.0030") },
                    { "tiers", new Dictionary<string, object>() {
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0025")}, new List<object> {this.parseNumber("10000"), this.parseNumber("0.0020")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.0015")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.0010")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.0003")}, new List<object> {this.parseNumber("15000000"), this.parseNumber("0.0000")}, new List<object> {this.parseNumber("75000000"), this.parseNumber("0.0000")}, new List<object> {this.parseNumber("100000000"), this.parseNumber("0.0000")}} },
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0030")}, new List<object> {this.parseNumber("10000"), this.parseNumber("0.0025")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.0020")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.0015")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.0010")}, new List<object> {this.parseNumber("15000000"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("75000000"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("100000000"), this.parseNumber("0.0003")}} },
                    } },
                } },
                { "stablecoin", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.0000") },
                    { "taker", this.parseNumber("0.000015") },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "defaultType", "spot" },
                { "recvWindow", multiply(5, 1000) },
                { "broker", "CCXT" },
                { "networks", new Dictionary<string, object>() {
                    { "Bitcoin", "Bitcoin" },
                    { "Ethereum", "ERC20" },
                } },
                { "defaultNetwork", "defaultNetwork" },
                { "defaultNetworkCodeReplacements", new Dictionary<string, object>() {
                    { "BTC", "Bitcoin" },
                    { "ETH", "Ethereum" },
                } },
            } },
            { "features", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "sandbox", false },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", false },
                        { "triggerPriceType", null },
                        { "triggerDirection", false },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", false },
                            { "FOK", false },
                            { "PO", false },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "selfTradePrevention", false },
                        { "trailing", false },
                        { "leverage", false },
                        { "marketBuyByCost", true },
                        { "marketBuyRequiresPrice", false },
                        { "iceberg", false },
                    } },
                    { "createOrders", null },
                    { "fetchMyTrades", null },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", null },
                        { "trigger", false },
                        { "trailing", false },
                    } },
                    { "fetchOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", null },
                        { "daysBack", null },
                        { "untilDays", null },
                        { "trigger", false },
                        { "trailing", false },
                    } },
                    { "fetchClosedOrders", null },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 100 },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "400", typeof(BadRequest) },
                    { "401", typeof(AuthenticationError) },
                    { "403", typeof(PermissionDenied) },
                    { "404", typeof(BadRequest) },
                    { "429", typeof(DDoSProtection) },
                    { "418", typeof(PermissionDenied) },
                    { "500", typeof(ExchangeError) },
                    { "504", typeof(ExchangeError) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "precisionMode", TICK_SIZE },
        });
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        path = this.implodeParams(path, parameters);
        object url = add(add(getValue(getValue(this.urls, "api"), api), "/"), path);
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object nonce = this.uuid();
            object timestamp = ((object)this.seconds()).ToString();
            if (isTrue(isEqual(method, "GET")))
            {
                body = "";
            } else
            {
                body = this.json(parameters);
            }
            parameters = this.extend(new Dictionary<string, object>() {
                { "_key", this.apiKey },
                { "_time", timestamp },
                { "_nonce", nonce },
            }, parameters);
            object query = this.urlencode(parameters);
            object bodyHash = this.hash(this.encode(body), sha256);
            // Create sign string components
            object bodyHashBytes = this.base16ToBinary(bodyHash);
            object nulByte = this.numberToBE(0, 1);
            object components = new List<object> {this.encode(method), nulByte, this.encode(path), nulByte, this.encode(query), nulByte, bodyHashBytes};
            // Join with null byte separator using encode
            object signString = this.binaryConcatArray(components);
            object sec = this.secret;
            object remainder = this.calculateMod(((string)sec).Length, 4);
            object paddingLength = ((bool) isTrue(remainder)) ? subtract(4, remainder) : 0;
            object secretWithPadding = ((string)this.secret).Replace((string)"-", (string)"+");
            secretWithPadding = ((string)secretWithPadding).Replace((string)"_", (string)"/");
            secretWithPadding = (secretWithPadding as String).PadRight(Convert.ToInt32(add(((string)this.secret).Length, paddingLength)), Convert.ToChar("="));
            object secretBytes = this.base64ToBinary(secretWithPadding);
            object seed = this.arraySlice(secretBytes, 0, 32); // Extract first 32 bytes as seed
            object signature = eddsa(signString, seed, ed25519);
            ((IDictionary<string,object>)parameters)["_sign"] = signature;
        }
        if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
        {
            url = add(url, add("?", this.urlencode(parameters)));
        }
        if (isTrue(isEqual(method, "GET")))
        {
            body = null;
        } else
        {
            headers = new Dictionary<string, object>() {
                { "Content-Type", "application/json" },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public virtual object calculateMod(object a, object b)
    {
        // trick to fix php transpiling error
        return mod(a, b);
    }

    /**
     * @method
     * @name ellipx#fetchMarkets
     * @description Fetches market information from the exchange.
     * @see https://docs.ccxt.com/en/latest/manual.html#markets
     * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.1a1t05wpgfof
     * @param {object} [params] - Extra parameters specific to the exchange API endpoint
     * @returns {Promise<Market[]>} An array of market structures.
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this._restGetMarket(parameters);
        // {
        //     Market__: "mkt-lrnp2e-eaor-eobj-ua73-75j6sjxe",
        //     Primary_Unit__: "unit-aebkye-u35b-e5zm-zt22-2qvwhsqa",
        //     Secondary_Unit__: "unit-jcevlk-soxf-fepb-yjwm-b32q5bom",
        //     Primary_Step: null,
        //     Secondary_Step: null,
        //     Status: "active",
        //     Default_Scale: "5",
        //     Priority: "100",
        //     Created: {
        //       unix: "1728113809",
        //       us: "0",
        //       iso: "2024-10-05 07:36:49.000000",
        //       tz: "UTC",
        //       full: "1728113809000000",
        //       unixms: "1728113809000",
        //     },
        //     Start: {
        //       unix: "1728295200",
        //       us: "0",
        //       iso: "2024-10-07 10:00:00.000000",
        //       tz: "UTC",
        //       full: "1728295200000000",
        //       unixms: "1728295200000",
        //     },
        //     Key: "BTC_USDC",
        //     Primary: {
        //       Unit__: "unit-aebkye-u35b-e5zm-zt22-2qvwhsqa",
        //       Currency__: "BTC",
        //       Crypto_Token__: "crtok-c5v3mh-grfn-hl5d-lmel-fvggbf4i",
        //       Key: "BTC",
        //       Symbol: "BTC",
        //       Symbol_Position: "after",
        //       Name: "Bitcoin",
        //       Decimals: "8",
        //       Display_Decimals: "8",
        //       Legacy_Decimals: null,
        //       Type: "crypto_token",
        //       Visible: "Y",
        //       Created: {
        //         unix: "1495247415",
        //         us: "0",
        //         iso: "2017-05-20 02:30:15.000000",
        //         tz: "UTC",
        //         full: "1495247415000000",
        //         unixms: "1495247415000",
        //       },
        //     },
        //     Secondary: {
        //       Unit__: "unit-jcevlk-soxf-fepb-yjwm-b32q5bom",
        //       Currency__: null,
        //       Crypto_Token__: "crtok-ptabkh-ra4r-anbd-cqra-bqfbtnba",
        //       Key: "USDC",
        //       Symbol: null,
        //       Symbol_Position: "before",
        //       Name: "Circle USD",
        //       Decimals: "6",
        //       Display_Decimals: "6",
        //       Legacy_Decimals: null,
        //       Type: "crypto_token",
        //       Visible: "Y",
        //       Created: {
        //         unix: "1694859829",
        //         us: "0",
        //         iso: "2023-09-16 10:23:49.000000",
        //         tz: "UTC",
        //         full: "1694859829000000",
        //         unixms: "1694859829000",
        //       },
        //     },
        //   }
        object markets = this.safeValue(response, "data", new List<object>() {});
        return this.parseMarkets(markets);
    }

    public override object parseMarket(object market)
    {
        object id = this.safeString(market, "Key");
        object bs = this.safeString(getValue(market, "Primary"), "Key");
        object quote = this.safeString(getValue(market, "Secondary"), "Key");
        object baseId = this.safeString(getValue(market, "Primary"), "Crypto_Token__");
        object quoteId = this.safeString(getValue(market, "Secondary"), "Crypto_Token__");
        object status = isEqual(this.safeString(market, "Status"), "active");
        object created = this.safeTimestamp(getValue(market, "Created"), "unix");
        object amountPrecision = this.parseNumber(this.parsePrecision(this.safeString(getValue(market, "Primary"), "Decimals")));
        object pricePrecision = this.parseNumber(this.parsePrecision(this.safeString(getValue(market, "Secondary"), "Decimals")));
        object fees = this.fees; // should use fetchTradingFees
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", id },
            { "symbol", add(add(bs, "/"), quote) },
            { "base", bs },
            { "quote", quote },
            { "settle", null },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", null },
            { "type", "spot" },
            { "spot", true },
            { "margin", false },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "active", status },
            { "contract", false },
            { "linear", null },
            { "inverse", null },
            { "taker", getValue(getValue(fees, "trading"), "taker") },
            { "maker", getValue(getValue(fees, "trading"), "maker") },
            { "contractSize", null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", amountPrecision },
                { "price", pricePrecision },
            } },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "info", market },
            { "created", created },
        });
    }

    /**
     * @method
     * @name ellipx#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.d2jylz4u6pmu
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = getValue(market, "id");
        object request = new Dictionary<string, object>() {
            { "currencyPair", marketId },
        };
        object response = await this.publicGetMarketCurrencyPairTicker(this.extend(request, parameters));
        //
        //     {
        //         "data": {
        //             "market": "BTC_USDC",
        //             "ticker": {
        //                 "time": 1730814600,
        //                 "count": 2135,
        //                 "high": {
        //                     "v": "74766990000",
        //                     "e": 6,
        //                     "f": 74766.99
        //                 },
        //                 "low": {
        //                     "v": "68734020000",
        //                     "e": 6,
        //                     "f": 68734.02
        //                 },
        //                 "avg": {
        //                     "v": "72347941430",
        //                     "e": 6,
        //                     "f": 72347.94143
        //                 },
        //                 "vwap": {
        //                     "v": "73050064447",
        //                     "e": 6,
        //                     "f": 73050.064447
        //                 },
        //                 "vol": {
        //                     "v": "4885361",
        //                     "e": 8,
        //                     "f": 0.04885361
        //                 },
        //                 "secvol": {
        //                     "v": "3568759346",
        //                     "e": 6,
        //                     "f": 3568.759346
        //                 },
        //                 "open": {
        //                     "v": "68784020000",
        //                     "e": 6,
        //                     "f": 68784.02
        //                 },
        //                 "close": {
        //                     "v": "73955570000",
        //                     "e": 6,
        //                     "f": 73955.57
        //                 }
        //             }
        //         },
        //         "request_id": "cbf183e0-7a62-4674-838c-6693031fa240",
        //         "result": "success",
        //         "time": 0.015463566
        //     }
        //
        object ticker = this.safeValue(getValue(response, "data"), "ticker", new Dictionary<string, object>() {});
        return this.parseTicker(ticker, market);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        object timestamp = this.safeIntegerProduct(ticker, "time", 1000);
        object open = this.parseAmount(this.safeValue(ticker, "open"));
        object high = this.parseAmount(this.safeValue(ticker, "high"));
        object low = this.parseAmount(this.safeValue(ticker, "low"));
        object close = this.parseAmount(this.safeValue(ticker, "close"));
        object avg = this.parseAmount(this.safeValue(ticker, "avg"));
        object vwap = this.parseAmount(this.safeValue(ticker, "vwap"));
        object baseVolume = this.parseAmount(this.safeValue(ticker, "vol"));
        object quoteVolume = this.parseAmount(this.safeValue(ticker, "secvol"));
        // const count = this.safeInteger(ticker, 'count'); not used
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(null, market) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", high },
            { "low", low },
            { "bid", null },
            { "bidVolume", null },
            { "ask", null },
            { "askVolume", null },
            { "vwap", vwap },
            { "open", open },
            { "close", close },
            { "last", close },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", avg },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name ellipx#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.bqmucewhkpdz
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return the exchange not supported yet.
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = getValue(market, "id");
        object request = new Dictionary<string, object>() {
            { "currencyPair", marketId },
        };
        object response = await this.publicGetMarketCurrencyPairGetDepth(this.extend(request, parameters));
        // {
        //     "data": {
        //         "asks": [
        //             {
        //                 "price": {
        //                     "v": "74941875231",
        //                     "e": 6,
        //                     "f": 74941.875231
        //                 },
        //                 "amount": {
        //                     "v": "149",
        //                     "e": 8,
        //                     "f": 0.00000149
        //                 }
        //             },
        //             {
        //                 "price": {
        //                     "v": "75063426037",
        //                     "e": 6,
        //                     "f": 75063.426037
        //                 },
        //                 "amount": {
        //                     "v": "335",
        //                     "e": 8,
        //                     "f": 0.00000335
        //                 }
        //             }
        //         ],
        //         "bids": [
        //             {
        //                 "price": {
        //                     "v": "64518711040",
        //                     "e": 6,
        //                     "f": 64518.71104
        //                 },
        //                 "amount": {
        //                     "v": "132",
        //                     "e": 8,
        //                     "f": 0.00000132
        //                 }
        //             },
        //             {
        //                 "price": {
        //                     "v": "64263569273",
        //                     "e": 6,
        //                     "f": 64263.569273
        //                 },
        //                 "amount": {
        //                     "v": "210",
        //                     "e": 8,
        //                     "f": 0.0000021
        //                 }
        //             }
        //         ],
        //         "market": "BTC_USDC"
        //     },
        //     "request_id": "71b7dffc-3120-4e46-a0bb-49ece5aea7e1",
        //     "result": "success",
        //     "time": 0.000074661
        // }
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {}); // exchange specific v e f params
        object timestamp = this.milliseconds(); // the exchange does not provide timestamp for this.
        object dataBidsLength = getArrayLength(getValue(data, "bids"));
        object dataAsksLength = getArrayLength(getValue(data, "asks"));
        for (object i = 0; isLessThan(i, dataBidsLength); postFixIncrement(ref i))
        {
            ((IDictionary<string,object>)getValue(getValue(data, "bids"), i))["price"] = this.parseAmount(getValue(getValue(getValue(data, "bids"), i), "price"));
            ((IDictionary<string,object>)getValue(getValue(data, "bids"), i))["amount"] = this.parseAmount(getValue(getValue(getValue(data, "bids"), i), "amount"));
        }
        for (object i = 0; isLessThan(i, dataAsksLength); postFixIncrement(ref i))
        {
            ((IDictionary<string,object>)getValue(getValue(data, "asks"), i))["price"] = this.parseAmount(getValue(getValue(getValue(data, "asks"), i), "price"));
            ((IDictionary<string,object>)getValue(getValue(data, "asks"), i))["amount"] = this.parseAmount(getValue(getValue(getValue(data, "asks"), i), "amount"));
        }
        return this.parseOrderBook(data, symbol, timestamp, "bids", "asks", "price", "amount");
    }

    /**
     * @method
     * @name ellipx#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market, default will return the last 24h period.
     * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.w65baeuhxwt8
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the API endpoint
     * @param {int} [params.until] timestamp in ms of the earliest candle to fetch
     * @returns {OHLCV[]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object methodName = "fetchOHLCV";
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, methodName, "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, 1000);
        }
        object market = this.market(symbol);
        object marketId = getValue(market, "id");
        object time_frame = this.safeString(this.timeframes, timeframe, null);
        object request = new Dictionary<string, object>() {
            { "currencyPair", marketId },
            { "interval", time_frame },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = (Math.Floor(Double.Parse((divide(since, 1000)).ToString())));
        }
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, methodName, "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["end"] = until;
        }
        // {
        //     "data": {
        //         "market": "BTC_USDC",
        //         "real_end": 1730970780,
        //         "requested_end": 1730970784,
        //         "start": 1730884200,
        //         "stats": [
        //             {
        //                 "time": 1730884200,
        //                 "count": 48,
        //                 "high": {"v": "73898950000", "e": 6, "f": 73898.95},
        //                 "low": {"v": "73642930000", "e": 6, "f": 73642.93},
        //                 "open": {"v": "73830990000", "e": 6, "f": 73830.99},
        //                 "close": {"v": "73682510000", "e": 6, "f": 73682.51},
        //                 "vol": {"v": "88159", "e": 8, "f": 0.00088159}
        //             }
        //         ]
        //     }
        // }
        // No limit parameter supported by the API
        object response = await this.publicGetMarketCurrencyPairGetGraph(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object ohlcv = this.safeList(data, "stats", new List<object>() {});
        return this.parseOHLCVs(ohlcv, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        return new List<object>() {multiply(this.safeInteger(ohlcv, "time"), 1000), this.parseNumber(this.parseAmount(this.safeDict(ohlcv, "open"))), this.parseNumber(this.parseAmount(this.safeDict(ohlcv, "high"))), this.parseNumber(this.parseAmount(this.safeDict(ohlcv, "low"))), this.parseNumber(this.parseAmount(this.safeDict(ohlcv, "close"))), this.parseNumber(this.parseAmount(this.safeDict(ohlcv, "vol")))};
    }

    /**
     * @method
     * @name ellipx#fetchCurrencies
     * @description fetches information on all currencies from the exchange, including deposit/withdrawal details and available chains
     * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.x65f9s9j74jf
     * @param {object} [params] extra parameters specific to the ellipx API endpoint
     * @param {string} [params.Can_Deposit] filter currencies by deposit availability, Y for available
     * @param {number} [params.results_per_page] number of results per page, default 100
     * @param {string} [params._expand] additional fields to expand in response, default '/Crypto_Token,/Crypto_Chain'
     * @returns {Promise<Currencies>} An object of currency structures indexed by currency codes
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this._restGetCryptoTokenInfo(this.extend(new Dictionary<string, object>() {
            { "Can_Deposit", "Y" },
            { "results_per_page", 100 },
            { "_expand", "/Crypto_Token,/Crypto_Chain" },
        }, parameters));
        object currencies = new Dictionary<string, object>() {};
        object data = this.safeValue(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object currency = this.parseCurrency(getValue(data, i));
            object code = this.safeString(currency, "code");
            if (isTrue(!isEqual(code, null)))
            {
                ((IDictionary<string,object>)currencies)[(string)code] = currency;
            }
        }
        return currencies;
    }

    public override object parseCurrency(object currency)
    {
        object id = this.safeString(currency, "Crypto_Token__");
        object token = this.safeValue(currency, "Crypto_Token", new Dictionary<string, object>() {});
        object code = this.safeCurrencyCode(this.safeString(token, "Symbol"));
        object name = this.safeString(token, "Name");
        object active = isEqual(this.safeString(currency, "Status"), "valid");
        object deposit = isEqual(this.safeString(currency, "Can_Deposit"), "Y");
        object withdraw = isEqual(this.safeString(currency, "Status"), "valid");
        object fee = null;
        if (isTrue(!isEqual(getValue(currency, "Withdraw_Fee"), null)))
        {
            fee = this.parseNumber(this.parseAmount(getValue(currency, "Withdraw_Fee")));
        }
        object precision = this.parseNumber(this.parsePrecision(this.safeString(token, "Decimals")));
        object minDeposit = null;
        if (isTrue(!isEqual(getValue(currency, "Minimum_Deposit"), null)))
        {
            minDeposit = this.parseAmount(getValue(currency, "Minimum_Deposit"));
        }
        object minWithdraw = null;
        if (isTrue(!isEqual(getValue(currency, "Minimum_Withdraw"), null)))
        {
            minWithdraw = this.parseAmount(getValue(currency, "Minimum_Withdraw"));
        }
        object networkId = this.safeString(currency, "Crypto_Chain__");
        object networkData = this.safeValue(currency, "Crypto_Chain", new Dictionary<string, object>() {});
        object networkCode = this.safeString(networkData, "Type", "default");
        object networks = new Dictionary<string, object>() {
            { "string", null },
            { "info", ((bool) isTrue(isEqual(networkCode, "default"))) ? new Dictionary<string, object>() {} : networkData },
            { "id", isTrue(isTrue(networkId) || isTrue(id)) || isTrue("") },
            { "network", networkCode },
            { "active", active },
            { "deposit", deposit },
            { "withdraw", withdraw },
            { "fee", fee },
            { "precision", precision },
            { "limits", new Dictionary<string, object>() {
                { "deposit", new Dictionary<string, object>() {
                    { "min", minDeposit },
                    { "max", null },
                } },
                { "withdraw", new Dictionary<string, object>() {
                    { "min", minWithdraw },
                    { "max", null },
                } },
            } },
        };
        object result = new Dictionary<string, object>() {
            { "info", currency },
            { "id", id },
            { "code", code },
            { "name", name },
            { "active", active },
            { "deposit", deposit },
            { "withdraw", withdraw },
            { "fee", fee },
            { "precision", precision },
            { "type", null },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "withdraw", new Dictionary<string, object>() {
                    { "min", minWithdraw },
                    { "max", null },
                } },
            } },
            { "networks", networks },
        };
        return result;
    }

    /**
     * @method
     * @name ellipx#fetchTrades
     * @description fetches all completed trades for a particular market/symbol
     * @param {string} symbol unified market symbol (e.g. 'BTC/USDT')
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the EllipX API endpoint
     * @param {string} [params.before] get trades before the given trade ID
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = getValue(market, "id");
        object request = new Dictionary<string, object>() {
            { "currencyPair", marketId },
        };
        // endpoint support before trade id.
        // The actual endpoint URL will be: https://data.ellipx.com/Market/{currencyPair}:getTrades
        // {
        //     "id": "BTC_USDC:1731053859:914141972:0",
        //     "pair": [
        //         "BTC",
        //         "USDC"
        //     ],
        //     "bid": {
        //         "id": "mktor-swishf-uv6n-hrzj-63ye-bdqnk33q",
        //         "iss": "ellipx:beta",
        //         "uniq": "order:1731053859:914141972:0"
        //     },
        //     "ask": {
        //         "id": "mktor-p3ozvt-qurz-gmzo-bf5n-g4rcuy6u",
        //         "iss": "ellipx:beta",
        //         "uniq": "order:1731053859:874659786:0"
        //     },
        //     "type": "bid",
        //     "amount": {
        //         "v": "412",
        //         "e": 8,
        //         "f": 0.00000412
        //     },
        //     "price": {
        //         "v": "75878090000",
        //         "e": 6,
        //         "f": 75878.09
        //     },
        //     "date": "2024-11-08T08:17:39.914141972Z"
        // }
        object response = await this.publicGetMarketCurrencyPairGetTrades(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object trades = this.safeList(data, "trades", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        // Format of trade ID: "BTC_USDC:1731053859:914141972:0"
        object id = this.safeString(trade, "id");
        // fetchTrades and fetchMyTrades return different trade structures
        object date = this.safeDict(trade, "date");
        object timestamp = null;
        if (isTrue(isEqual(date, null)))
        {
            timestamp = this.parse8601(this.safeString(trade, "date"));
        } else
        {
            timestamp = this.safeInteger(date, "unixms");
        }
        object type = this.safeString(trade, "type");
        object side = ((bool) isTrue((isEqual(type, "bid")))) ? "buy" : "sell";
        object amount = this.safeDict(trade, "amount");
        object price = this.safeDict(trade, "price");
        object amountFloat = this.parseAmount(amount);
        object priceFloat = this.parseAmount(price);
        // fetchTrades and fetchMyTrades return different trade structures
        object pair = this.safeList(trade, "pair");
        object marketSymbol = null;
        if (isTrue(isEqual(pair, null)))
        {
            object symbol = this.safeString(trade, "pair");
            var bsquoteVariable = ((string)symbol).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
            var bs = ((IList<object>) bsquoteVariable)[0];
            var quote = ((IList<object>) bsquoteVariable)[1];
            marketSymbol = add(add(bs, "/"), quote);
        } else
        {
            marketSymbol = add(add(this.safeString(pair, 0), "/"), this.safeString(pair, 1));
        }
        object bidOrder = this.safeDict(trade, "bid");
        object askOrder = this.safeDict(trade, "ask");
        object isBuy = (isEqual(side, "buy"));
        object orderId = ((bool) isTrue(isBuy)) ? this.safeString(bidOrder, "id") : this.safeString(askOrder, "id");
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", marketSymbol },
            { "type", null },
            { "side", side },
            { "order", orderId },
            { "takerOrMaker", null },
            { "price", priceFloat },
            { "amount", amountFloat },
            { "cost", null },
            { "fee", null },
        });
    }

    /**
     * @method
     * @name ellipx#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.ihrjov144txg
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetUserWallet(parameters);
        // {
        //     "User_Wallet__": "usw-vv7hzo-qel5-gupk-neqi-7f3wz5pq",
        //     "User__": "usr-...",
        //     "Realm__": "usrr-cb3c7n-qvxv-fdrb-uc2q-gpja2foi",
        //     "Unit__": "unit-aebkye-u35b-e5zm-zt22-2qvwhsqa",
        //     "Balance": {
        //         "value": "0.00006394",
        //         "value_int": "6394",
        //         "value_disp": "0.00006394",
        //         "value_xint": {
        //             "v": "6394",
        //             "e": 8,
        //             "f": 0.00006394
        //         },
        //         "display": "0.00006394BTC",
        //         "display_short": "0.00006394BTC",
        //         "currency": "BTC",
        //         "unit": "BTC",
        //         "has_vat": false,
        //         "tax_profile": null
        //     },
        //     "Balance_Date": {
        //         "unix": 1731128270,
        //         "us": 426208,
        //         "iso": "2024-11-09 04:57:50.426208",
        //         "tz": "UTC",
        //         "full": "1731128270426208",
        //         "unixms": "1731128270426"
        //     },
        //     "Liabilities": {
        //         "value": "0.00000000",
        //         "value_int": "0",
        //         "value_disp": "0.00000000",
        //         "value_xint": {
        //             "v": "0",
        //             "e": 8,
        //             "f": 0
        //         },
        //         "display": "0.00000000BTC",
        //         "display_short": "0.00000000BTC",
        //         "currency": "BTC",
        //         "unit": "BTC",
        //         "has_vat": false,
        //         "tax_profile": null
        //     },
        //     "Index": "5",
        //     "Backend": "virtual",
        //     "Disable_Limits": "N",
        //     "Unencumbered_Balance": {
        //         "value": "0.00006394",
        //         "value_int": "6394",
        //         "value_disp": "0.00006394",
        //         "value_xint": {
        //             "v": "6394",
        //             "e": 8,
        //             "f": 0.00006394
        //         },
        //         "display": "0.00006394BTC",
        //         "display_short": "0.00006394BTC",
        //         "currency": "BTC",
        //         "unit": "BTC",
        //         "has_vat": false,
        //         "tax_profile": null
        //     }
        // }
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        object dataArray = this.safeList(response, "data", new List<object>() {});
        // Use first item's timestamp if available
        object dataArrayLength = getArrayLength(dataArray);
        if (isTrue(isGreaterThan(dataArrayLength, 0)))
        {
            object firstItem = getValue(dataArray, 0);
            object balanceDate = this.safeDict(firstItem, "Balance_Date", new Dictionary<string, object>() {});
            ((IDictionary<string,object>)result)["timestamp"] = this.safeInteger(balanceDate, "unixms");
            ((IDictionary<string,object>)result)["datetime"] = this.iso8601(getValue(result, "timestamp"));
        }
        // Process each balance entry
        for (object i = 0; isLessThan(i, getArrayLength(dataArray)); postFixIncrement(ref i))
        {
            object entry = getValue(dataArray, i);
            object balance = this.safeDict(entry, "Balance", new Dictionary<string, object>() {});
            object currency = this.safeString(balance, "currency");
            if (isTrue(!isEqual(currency, null)))
            {
                object account = new Dictionary<string, object>() {
                    { "free", this.parseAmount(getValue(getValue(entry, "Unencumbered_Balance"), "value_xint")) },
                    { "used", this.parseAmount(getValue(getValue(entry, "Liabilities"), "value_xint")) },
                    { "total", this.parseAmount(getValue(balance, "value_xint")) },
                };
                ((IDictionary<string,object>)result)[(string)currency] = account;
            }
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name ellipx#createOrder
     * @description create a new order in a market
     * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.yzfak2n2bwpo
     * @param {string} symbol unified market symbol (e.g. 'BTC/USDT')
     * @param {string} type order type - the exchange automatically sets type to 'limit' if price defined, 'market' if undefined
     * @param {string} side 'buy' or 'sell'
     * @param {float} [amount] amount of base currency to trade (can be undefined if using Spend_Limit)
     * @param {float} [price] price per unit of base currency for limit orders
     * @param {object} [params] extra parameters specific to the EllipX API endpoint
     * @param {float} [params.cost] maximum amount to spend in quote currency (required for market orders if amount undefined)
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        // the exchange automatically sets the type to 'limit' if the price is defined and to 'market' if it is not
        object marketId = getValue(market, "id");
        object orderType = "bid";
        if (isTrue(isEqual(side, "buy")))
        {
            orderType = "bid";
        } else
        {
            orderType = "ask";
        }
        object request = new Dictionary<string, object>() {
            { "currencyPair", marketId },
            { "Type", orderType },
        };
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["Amount"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["Price"] = this.priceToPrecision(symbol, price);
        }
        object cost = this.safeString(parameters, "cost");
        if (isTrue(!isEqual(cost, null)))
        {
            parameters = this.omit(parameters, "cost");
            ((IDictionary<string,object>)request)["Spend_Limit"] = this.priceToPrecision(symbol, cost);
        }
        object response = await this.privatePostMarketCurrencyPairOrder(this.extend(request, parameters));
        // {
        //     "result": "success",
        //     "data": {
        //         "Market_Order__": "mktor-x2grmu-zwo5-fyxc-4gue-vd4ouvsa",
        //         "Market__": "mkt-lrnp2e-eaor-eobj-ua73-75j6sjxe",
        //         "User__": "usr-...",
        //         "Uniq": "order:1728719021:583795548:0",
        //         "Type": "bid",
        //         "Status": "pending",
        //         "Flags": {},
        //         "Amount": {
        //             "v": "100000000",
        //             "e": 8,
        //             "f": 1
        //         },
        //         "Price": null,
        //         "Spend_Limit": {
        //             "v": "1000000",
        //             "e": 6,
        //             "f": 1
        //         },
        //         "Executed": {
        //             "v": "0",
        //             "e": 0,
        //             "f": 0
        //         },
        //         "Secured": {
        //             "v": "1000000",
        //             "e": 6,
        //             "f": 1
        //         },
        //         "Version": "0",
        //         "Created": {
        //             "unix": 1728719020,
        //             "us": 315195,
        //             "iso": "2024-10-12 07:43:40.315195",
        //             "tz": "UTC",
        //             "full": "1728719020315195",
        //             "unixms": "1728719020315"
        //         },
        //         "Updated": {
        //             "unix": 1728719020,
        //             "us": 315195,
        //             "iso": "2024-10-12 07:43:40.315195",
        //             "tz": "UTC",
        //             "full": "1728719020315195",
        //             "unixms": "1728719020315"
        //         }
        //     }
        // }
        object order = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(order, market);
    }

    /**
     * @method
     * @name ellipx#fetchOrder
     * @description fetches information on an order made by the user
     * @param {string} id the order ID as returned by createOrder or fetchOrders
     * @param {string|undefined} symbol not used by ellipx.fetchOrder
     * @param {object} [params] extra parameters specific to the EllipX API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderUuid", id },
        };
        object response = await this.privateGetMarketOrderOrderUuid(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, null);
    }

    /**
     * @method
     * @name ellipx#fetchOrdersByStatus
     * @description fetches a list of orders placed on the exchange
     * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.5z2nh2b5s81n
     * @param {string} status 'open' or 'closed', omit for all orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] timestamp in ms of the earliest order
     * @param {int} [limit] the maximum amount of orders to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchOrdersByStatus(object status, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            object marketId = getValue(market, "id");
            ((IDictionary<string,object>)request)["currencyPair"] = marketId;
        }
        if (isTrue(!isEqual(status, null)))
        {
            ((IDictionary<string,object>)request)["Status"] = status;
        }
        object response = await this.privateGetMarketCurrencyPairOrder(this.extend(request, parameters));
        // {
        //     "result": "success",
        //     "data": [
        //         {
        //             "Market_Order__": "mktor-aglvd2-iy5v-enbj-nwrb-scqsnosa",
        //             "Market__": "mkt-lrnp2e-eaor-eobj-ua73-75j6sjxe",
        //             "User__": "usr-...",
        //             "Uniq": "order:1728712511:964332600:0",
        //             "Type": "ask",
        //             "Status": "open",
        //             "Flags": {},
        //             "Amount": {
        //                 "v": "1",
        //                 "e": 8,
        //                 "f": 1.0e-8
        //             },
        //             "Price": {
        //                 "v": "63041306872",
        //                 "e": 6,
        //                 "f": 63041.306872
        //             },
        //             "Spend_Limit": null,
        //             "Executed": {
        //                 "v": "892",
        //                 "e": 8,
        //                 "f": 8.92e-6
        //             },
        //             "Secured": null,
        //             "Version": "3",
        //             "Created": {
        //                 "unix": 1728712510,
        //                 "us": 669096,
        //                 "iso": "2024-10-12 05:55:10.669096",
        //                 "tz": "UTC",
        //                 "full": "1728712510669096",
        //                 "unixms": "1728712510669"
        //             },
        //             "Updated": {
        //                 "unix": 1728712510,
        //                 "us": 669096,
        //                 "iso": "2024-10-12 05:55:10.669096",
        //                 "tz": "UTC",
        //                 "full": "1728712510669096",
        //                 "unixms": "1728712510669"
        //             }
        //         }
        //     ],
        //     "paging": {
        //         "page_no": 1,
        //         "count": "1",
        //         "page_max": 1,
        //         "results_per_page": 20
        //     }
        // }
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    /**
     * @method
     * @name ellipx#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.5z2nh2b5s81n
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int|undefined} since timestamp in ms of the earliest order
     * @param {int|undefined} limit the maximum amount of orders to fetch
     * @param {object} params extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrders requires a symbol parameter")) ;
        }
        return await this.fetchOrdersByStatus(null, symbol, since, limit, parameters);
    }

    /**
     * @method
     * @name ellipx#fetchOpenOrders
     * @description fetches information on open orders made by the user
     * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.5z2nh2b5s81n
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int|undefined} since timestamp in ms of the earliest order
     * @param {int|undefined} limit the maximum amount of orders to fetch
     * @param {object} params extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOpenOrders requires a symbol parameter")) ;
        }
        return await this.fetchOrdersByStatus("open", symbol, since, limit, parameters);
    }

    public override object parseOrder(object order, object market = null)
    {
        object id = this.safeString(order, "Market_Order__");
        object timestamp = this.safeInteger(this.safeDict(order, "Created"), "unixms");
        object orderType = this.safeString(order, "Type");
        object side = "sell";
        if (isTrue(isEqual(orderType, "bid")))
        {
            side = "buy";
        }
        object status = this.parseOrderStatus(this.safeString(order, "Status"));
        object amount = this.parseNumber(this.parseAmount(this.safeDict(order, "Amount")));
        object price = this.parseNumber(this.parseAmount(this.safeDict(order, "Price")));
        object type = ((bool) isTrue((isEqual(price, null)))) ? "market" : "limit";
        object executed = this.parseNumber(this.parseAmount(this.safeDict(order, "Executed")));
        object filled = executed;
        object remaining = this.parseNumber(this.parseAmount(this.safeDict(order, "Secured")));
        object cost = this.parseNumber(this.parseAmount(this.safeDict(order, "Total_Spent")));
        object symbol = ((bool) isTrue(market)) ? getValue(market, "symbol") : null;
        object clientOrderId = null;
        object timeInForce = "GTC"; // default to Good Till Cancelled
        object postOnly = false;
        object updated = this.safeDict(order, "Updated", new Dictionary<string, object>() {});
        object lastTradeTimestamp = this.safeInteger(updated, "unixms", null);
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "info", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "status", this.parseOrderStatus(status) },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "side", side },
            { "price", price },
            { "triggerPrice", null },
            { "average", null },
            { "cost", cost },
            { "amount", amount },
            { "filled", filled },
            { "remaining", remaining },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    /**
     * @method
     * @name ellipx#cancelOrder
     * @description Cancels an open order on the exchange
     * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.f1qu1pb1rebn
     * @param {string} id - The order ID to cancel (format: mktor-xxxxx-xxxx-xxxx-xxxx-xxxxxxxx)
     * @param {string} [symbol] - ellipx.cancelOrder does not use the symbol parameter
     * @param {object} [params] - Extra parameters specific to the exchange API
     * @returns {Promise<object>} A Promise that resolves to the canceled order info
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderUuid", id },
        };
        object response = await this.privateDeleteMarketOrderOrderUuid(this.extend(request, parameters));
        // {
        //     result: "success",
        //     request_id: "887dba33-d11b-43f0-8034-dd7890882cc5",
        //     time: "0.8975801467895508",
        //     data: true,
        //     access: {
        //       "mktor-rf5k5b-5fhf-dmde-wxqj-3y23jeii": {
        //         required: "A",
        //         available: "O",
        //       },
        //     },
        //   }
        // this endpoint always returns true and a warning message if the order cancelled before.
        object warningResponse = this.safeValue(response, "warning", null);
        object statusResponse = this.safeBool(response, "data");
        object status = "canceled";
        if (isTrue(isTrue(!isEqual(statusResponse, true)) || isTrue(!isEqual(warningResponse, null))))
        {
            status = "closed";
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", null },
            { "info", this.json(response) },
            { "timestamp", null },
            { "datetime", null },
            { "lastTradeTimestamp", null },
            { "status", status },
            { "symbol", null },
            { "type", null },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", null },
            { "price", null },
            { "triggerPrice", null },
            { "average", null },
            { "cost", null },
            { "amount", null },
            { "filled", null },
            { "remaining", null },
            { "fee", null },
            { "trades", null },
        }, null);
    }

    /**
     * @method
     * @name ellipx#fetchOrderTrades
     * @description fetch all the trades made from a single order
     * @param {string} id order id
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)"fetchMyTrades requires a symbol parameter") ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object currencyPair = getValue(market, "id");
        object request = new Dictionary<string, object>() {
            { "Market_Order__", id },
            { "currencyPair", currencyPair },
        };
        object response = await this.privateGetMarketCurrencyPairTrade(this.extend(request, parameters));
        // {
        //     "result": "success",
        //     "request_id": "fc5be99d-d085-46f8-9228-e46d0996f112",
        //     "time": 0.030913114547729492,
        //     "data": [
        //         {
        //             "id": "DOGE_USDC:1731505789:911642994:0",
        //             "pair": "DOGE_USDC",
        //             "bid": {
        //                 "id": "mktor-xb3ne5-emm5-fx7e-xggk-fyfoiye4"
        //             },
        //             "ask": {
        //                 "id": "mktor-oxmac4-mtkf-gi3o-mamg-u2cboqe4"
        //             },
        //             "type": "bid",
        //             "amount": {
        //                 "v": "334609419",
        //                 "e": 8,
        //                 "f": 3.34609419
        //             },
        //             "price": {
        //                 "v": "410673",
        //                 "e": 6,
        //                 "f": 0.410673
        //             },
        //             "date": {
        //                 "unix": 1731505789,
        //                 "us": 911642,
        //                 "iso": "2024-11-13 13:49:49.911642",
        //                 "tz": "UTC",
        //                 "full": "1731505789911642",
        //                 "unixms": "1731505789911"
        //             }
        //         },
        //         {
        //             "id": "DOGE_USDC:1731505789:911642994:4",
        //             "pair": "DOGE_USDC",
        //             "bid": {
        //                 "id": "mktor-xb3ne5-emm5-fx7e-xggk-fyfoiye4"
        //             },
        //             "ask": {
        //                 "id": "mktor-cmtztk-3z3n-gupp-uqdg-74g4wjfq"
        //             },
        //             "type": "bid",
        //             "amount": {
        //                 "v": "145453950",
        //                 "e": 8,
        //                 "f": 1.4545395
        //             },
        //             "price": {
        //                 "v": "412589",
        //                 "e": 6,
        //                 "f": 0.412589
        //             },
        //             "date": {
        //                 "unix": 1731505789,
        //                 "us": 911642,
        //                 "iso": "2024-11-13 13:49:49.911642",
        //                 "tz": "UTC",
        //                 "full": "1731505789911642",
        //                 "unixms": "1731505789911"
        //             }
        //         },
        //         {
        //             "id": "DOGE_USDC:1731505789:911642994:2",
        //             "pair": "DOGE_USDC",
        //             "bid": {
        //                 "id": "mktor-xb3ne5-emm5-fx7e-xggk-fyfoiye4"
        //             },
        //             "ask": {
        //                 "id": "mktor-6tyslh-b33b-flnm-2ata-acjkco4y"
        //             },
        //             "type": "bid",
        //             "amount": {
        //                 "v": "587627076",
        //                 "e": 8,
        //                 "f": 5.87627076
        //             },
        //             "price": {
        //                 "v": "411005",
        //                 "e": 6,
        //                 "f": 0.411005
        //             },
        //             "date": {
        //                 "unix": 1731505789,
        //                 "us": 911642,
        //                 "iso": "2024-11-13 13:49:49.911642",
        //                 "tz": "UTC",
        //                 "full": "1731505789911642",
        //                 "unixms": "1731505789911"
        //             }
        //         },
        //         {
        //             "id": "DOGE_USDC:1731505789:911642994:1",
        //             "pair": "DOGE_USDC",
        //             "bid": {
        //                 "id": "mktor-xb3ne5-emm5-fx7e-xggk-fyfoiye4"
        //             },
        //             "ask": {
        //                 "id": "mktor-ihpjlj-5ufj-dm5l-fmud-oftkqcgu"
        //             },
        //             "type": "bid",
        //             "amount": {
        //                 "v": "475845734",
        //                 "e": 8,
        //                 "f": 4.75845734
        //             },
        //             "price": {
        //                 "v": "410830",
        //                 "e": 6,
        //                 "f": 0.41083
        //             },
        //             "date": {
        //                 "unix": 1731505789,
        //                 "us": 911642,
        //                 "iso": "2024-11-13 13:49:49.911642",
        //                 "tz": "UTC",
        //                 "full": "1731505789911642",
        //                 "unixms": "1731505789911"
        //             }
        //         },
        //         {
        //             "id": "DOGE_USDC:1731505789:911642994:3",
        //             "pair": "DOGE_USDC",
        //             "bid": {
        //                 "id": "mktor-xb3ne5-emm5-fx7e-xggk-fyfoiye4"
        //             },
        //             "ask": {
        //                 "id": "mktor-d2uyb3-nzsj-aevn-dikr-tq3sxhre"
        //             },
        //             "type": "bid",
        //             "amount": {
        //                 "v": "641013461",
        //                 "e": 8,
        //                 "f": 6.41013461
        //             },
        //             "price": {
        //                 "v": "411846",
        //                 "e": 6,
        //                 "f": 0.411846
        //             },
        //             "date": {
        //                 "unix": 1731505789,
        //                 "us": 911642,
        //                 "iso": "2024-11-13 13:49:49.911642",
        //                 "tz": "UTC",
        //                 "full": "1731505789911642",
        //                 "unixms": "1731505789911"
        //             }
        //         }
        //     ],
        //     "access": {
        //         "mkt-xrkg5l-akjz-cxxl-3a2e-mul5gfo4": {
        //             "required": "r",
        //             "available": "?"
        //         },
        //         "mktor-xb3ne5-emm5-fx7e-xggk-fyfoiye4": {
        //             "required": "R",
        //             "available": "O"
        //         }
        //     },
        //     "paging": {
        //         "page_no": 1,
        //         "count": "5",
        //         "page_max": 1,
        //         "results_per_page": 20
        //     }
        // }
        object data = this.safeList(response, "data");
        return this.parseTrades(data, market, since, limit);
    }

    /**
     * @method
     * @name ellipx#fetchDepositAddress
     * @description fetches a crypto deposit address for a specific currency
     * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.k7qe5aricayh
     * @param {string} code unified currency code (e.g. "BTC", "ETH", "USDT")
     * @param {object} [params] extra parameters specific to the EllipX API endpoint
     * @returns {object} an address structure {
     *     'currency': string, // unified currency code
     *     'address': string, // the address for deposits
     *     'tag': string|undefined, // tag/memo for deposits if needed
     *     'network': object, // network object from currency info
     *     'info': object // raw response from exchange
     * }
     * @throws {ExchangeError} if currency does not support deposits
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object network = this.safeValue(getValue(currency, "info"), "Crypto_Chain", null);
        object request = new Dictionary<string, object>() {
            { "Crypto_Token__", this.safeString(network, "Crypto_Token__") },
            { "Crypto_Chain__", this.safeString(network, "Crypto_Chain__") },
        };
        object response = await this.privatePostCryptoAddressFetch(this.extend(request, parameters));
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object address = this.safeString(data, "Address");
        object tag = this.safeString(data, "memo");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", network },
            { "info", response },
        };
    }

    /**
     * @method
     * @name ellipx#fetchTradingFee
     * @description Fetches the current trading fees (maker and taker) applicable to the user.
     * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.kki5jay2c8it
     * @param {string} [symbol] Not used by EllipX as fees are not symbol-specific.
     * @param {object} [params] Extra parameters specific to the EllipX API endpoint.
     * @returns {Promise<object>} A promise resolving to a unified trading fee structure:
     * {
     *     'info': object,        // the raw response from the exchange
     *     'symbol': undefined,   // symbol is not used for this exchange
     *     'maker': number,       // maker fee rate in decimal form
     *     'taker': number,       // taker fee rate in decimal form
     *     'percentage': true,    // indicates fees are in percentage
     *     'tierBased': false,    // indicates fees do not vary by volume tiers
     * }
     */
    public async override Task<object> fetchTradingFee(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetMarketTradeFeeQuery(parameters);
        //
        // Example response:
        // {
        //     "result": "success",
        //     "data": {
        //         "maker": 15.0,      // in basis points
        //         "taker": 25.0,      // in basis points
        //         "volume": 123456.78,
        //         "promo": {
        //             // promotional discounts if any
        //         }
        //     }
        // }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object maker = this.safeNumber(data, "maker"); // in basis points
        object taker = this.safeNumber(data, "taker"); // in basis points
        object makerFee = ((bool) isTrue((!isEqual(maker, null)))) ? divide(maker, 10000) : null;
        object takerFee = ((bool) isTrue((!isEqual(taker, null)))) ? divide(taker, 10000) : null;
        return new Dictionary<string, object>() {
            { "info", response },
            { "symbol", null },
            { "maker", makerFee },
            { "taker", takerFee },
            { "percentage", true },
            { "tierBased", true },
        };
    }

    /**
     * @method
     * @description Make a withdrawal request
     * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.zegupoa8g4t9
     * @param {string} code Currency code
     * @param {number} amount Amount to withdraw
     * @param {string} address Destination wallet address
     * @param {string} [tag] Additional tag/memo for currencies that require it
     * @param {object} params Extra parameters specific to the EllipX API endpoint (Crypto_Chain__, Unit__)
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object networks = this.safeValue(currency, "networks");
        if (isTrue(isEqual(networks, null)))
        {
            throw new NotSupported ((string)add(add(add(this.id, " withdraw() for "), code), " is not supported")) ;
        }
        object chainsResponse = await this.privateGetUnitCurrency(new Dictionary<string, object>() {
            { "currency", getValue(currency, "code") },
        }); // fetch Unit__ params for currency
        object chainsData = this.safeValue(chainsResponse, "data", new List<object>() {});
        object unit = this.safeString(chainsData, "Unit__");
        // check params again and omit params
        this.omit(parameters, "Unit__");
        this.omit(parameters, "Crypto_Chain__");
        object amountString = ((object)amount).ToString();
        object request = new Dictionary<string, object>() {
            { "Unit__", unit },
            { "amount", amountString },
            { "address", address },
            { "Crypto_Chain__", getValue(networks, "id") },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["memo"] = tag;
        }
        object response = await this.privatePostCryptoDisbursementWithdraw(this.extend(request, parameters));
        // {
        //     Crypto_Disbursement__: "crdsb-4pw3kg-ipn5-amvb-da4n-6xncy4r4",
        //     Crypto_Token__: "crtok-dnehz4-wbgv-bunf-iyd3-m7gtsz2q",
        //     Crypto_Chain__: "chain-kjfvwn-l2xn-eclc-ul5d-mb6fu5hm",
        //     User__: "usr-5oint6-ozpr-alfp-2wxi-zgbm4osy",
        //     Value: {
        //       v: "1000000000",
        //       e: "8",
        //       f: "10",
        //     },
        //     Value_USD: "4.08723",
        //     Address: "D6z62LUwyNBi3QbPkzW8C4m7VDAgu9wb2Z",
        //     Status: "pending",
        //     Transaction: null,
        //     Requested: {
        //       unix: "1731570982",
        //       us: "203569",
        //       iso: "2024-11-14 07:56:22.203569",
        //       tz: "UTC",
        //       full: "1731570982203569",
        //       unixms: "1731570982203",
        //     },
        //     Scheduled: null,
        //     Processed: null,
        //     Amount: {
        //       value: "10.00000000",
        //       value_int: "1000000000",
        //       value_disp: "10.00000000",
        //       value_xint: {
        //         v: "1000000000",
        //         e: "8",
        //         f: "10",
        //       },
        //       display: "10.00000000DOGE",
        //       display_short: "10.00000000DOGE",
        //       currency: "DOGE",
        //       unit: "DOGE",
        //       has_vat: false,
        //       tax_profile: null,
        //       raw: {
        //         value: "10.00000000",
        //         value_int: "1000000000",
        //         value_disp: "10.00000000",
        //         value_xint: {
        //           v: "1000000000",
        //           e: "8",
        //           f: "10",
        //         },
        //         display: "10.00000000DOGE",
        //         display_short: "10.00000000DOGE",
        //         currency: "DOGE",
        //         unit: "DOGE",
        //         has_vat: false,
        //         tax_profile: null,
        //       },
        //       tax: {
        //         value: "10.00000000",
        //         value_int: "1000000000",
        //         value_disp: "10.00000000",
        //         value_xint: {
        //           v: "1000000000",
        //           e: "8",
        //           f: "10",
        //         },
        //         display: "10.00000000DOGE",
        //         display_short: "10.00000000DOGE",
        //         currency: "DOGE",
        //         unit: "DOGE",
        //         has_vat: true,
        //         tax_profile: null,
        //       },
        //       tax_only: {
        //         value: "0.000",
        //         value_int: "0",
        //         value_disp: "0",
        //         value_xint: {
        //           v: "0",
        //           e: "3",
        //           f: "0",
        //         },
        //         display: "0",
        //         display_short: "0",
        //         currency: "JPY",
        //         unit: "JPY",
        //         has_vat: false,
        //         tax_profile: null,
        //       },
        //       tax_rate: "0",
        //     },
        //   }
        object data = this.safeDict(response, "data");
        object amountResponse = this.safeDict(data, "Amount");
        object requested = this.safeDict(data, "Requested");
        object processed = this.safeDict(data, "Processed");
        object withdrawId = this.safeString(data, "Crypto_Disbursement__");
        object timestamp = this.safeInteger(requested, "unixms");
        return new Dictionary<string, object>() {
            { "info", response },
            { "id", withdrawId },
            { "txid", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", this.safeString(data, "Crypto_Chain__") },
            { "address", this.safeString(data, "Address") },
            { "addressTo", this.safeString(data, "Address") },
            { "addressFrom", null },
            { "tag", tag },
            { "tagTo", tag },
            { "tagFrom", null },
            { "type", "withdrawal" },
            { "amount", this.safeNumber(amountResponse, "value") },
            { "currency", code },
            { "status", this.parseTransactionStatus(this.safeString(data, "Status")) },
            { "updated", this.safeTimestamp(processed, "unix") },
            { "internal", false },
            { "comment", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", null },
                { "rate", null },
            } },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "pending", "pending" },
            { "completed", "ok" },
            { "failed", "failed" },
            { "cancelled", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "pending", "open" },
            { "running", "open" },
            { "post-pending", "open" },
            { "open", "open" },
            { "stop", "open" },
            { "invalid", "rejected" },
            { "done", "closed" },
            { "cancel", "canceled" },
            { "canceled", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseAmount(object amount)
    {
        object v = this.safeString(amount, "v", null);
        object e = this.safeInteger(amount, "e", null);
        if (isTrue(isTrue(isEqual(v, null)) || isTrue(isEqual(e, null))))
        {
            return null;
        }
        var preciseAmount = new Precise(v);
        preciseAmount.decimals = e;
        preciseAmount.reduce();
        return ((object)preciseAmount).ToString();
    }

    public virtual object toAmount(object amount, object precision)
    {
        object v = ((object)amount).ToString();
        object e = precision;
        return new Dictionary<string, object>() {
            { "v", v },
            { "e", e },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        // {
        //     "code": 404,
        //     "error": "Not Found: Crypto\\Token(US)",
        //     "exception": "Exception\\NotFound",
        //     "message": "[I18N:error_not_found]",
        //     "request": "cc83738a-2438-4f53-ae44-f15306c07f32",
        //     "result": "error",
        //     "time": 0.0089569091796875,
        //     "token": "error_not_found"
        // }
        object errorCode = this.safeString(response, "code");
        object message = this.safeString(response, "message");
        if (isTrue(!isEqual(errorCode, null)))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, message);
            throw new ExchangeError ((string)add(add(this.id, " "), message)) ;
        }
        return null;
    }
}
