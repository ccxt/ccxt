namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class gemini : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "gemini" },
            { "name", "Gemini" },
            { "countries", new List<object>() {"US"} },
            { "rateLimit", 100 },
            { "version", "v1" },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelOrder", true },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createDepositAddress", true },
                { "createMarketOrder", false },
                { "createOrder", true },
                { "createReduceOnlyOrder", false },
                { "fetchBalance", true },
                { "fetchBidsAsks", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchClosedOrders", false },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", true },
                { "fetchDepositsWithdrawals", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", false },
                { "fetchPosition", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", true },
                { "fetchTransactions", "emulated" },
                { "postOnly", true },
                { "reduceMargin", false },
                { "sandbox", true },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "withdraw", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/27816857-ce7be644-6096-11e7-82d6-3c257263229c.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.gemini.com" },
                    { "private", "https://api.gemini.com" },
                    { "web", "https://docs.gemini.com" },
                    { "webExchange", "https://exchange.gemini.com" },
                } },
                { "www", "https://gemini.com/" },
                { "doc", new List<object>() {"https://docs.gemini.com/rest-api", "https://docs.sandbox.gemini.com"} },
                { "test", new Dictionary<string, object>() {
                    { "public", "https://api.sandbox.gemini.com" },
                    { "private", "https://api.sandbox.gemini.com" },
                    { "web", "https://docs.gemini.com" },
                    { "webExchange", "https://exchange.gemini.com" },
                } },
                { "fees", new List<object>() {"https://gemini.com/api-fee-schedule", "https://gemini.com/trading-fees", "https://gemini.com/transfer-fees"} },
            } },
            { "api", new Dictionary<string, object>() {
                { "webExchange", new Dictionary<string, object>() {
                    { "get", new List<object>() {""} },
                } },
                { "web", new Dictionary<string, object>() {
                    { "get", new List<object>() {"rest-api"} },
                } },
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "v1/symbols", 5 },
                        { "v1/symbols/details/{symbol}", 5 },
                        { "v1/staking/rates", 5 },
                        { "v1/pubticker/{symbol}", 5 },
                        { "v2/ticker/{symbol}", 5 },
                        { "v2/candles/{symbol}/{timeframe}", 5 },
                        { "v1/trades/{symbol}", 5 },
                        { "v1/auction/{symbol}", 5 },
                        { "v1/auction/{symbol}/history", 5 },
                        { "v1/pricefeed", 5 },
                        { "v1/book/{symbol}", 5 },
                        { "v1/earn/rates", 5 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "post", new Dictionary<string, object>() {
                        { "v1/staking/unstake", 1 },
                        { "v1/staking/stake", 1 },
                        { "v1/staking/rewards", 1 },
                        { "v1/staking/history", 1 },
                        { "v1/order/new", 1 },
                        { "v1/order/cancel", 1 },
                        { "v1/wrap/{symbol}", 1 },
                        { "v1/order/cancel/session", 1 },
                        { "v1/order/cancel/all", 1 },
                        { "v1/order/status", 1 },
                        { "v1/orders", 1 },
                        { "v1/mytrades", 1 },
                        { "v1/notionalvolume", 1 },
                        { "v1/tradevolume", 1 },
                        { "v1/clearing/new", 1 },
                        { "v1/clearing/status", 1 },
                        { "v1/clearing/cancel", 1 },
                        { "v1/clearing/confirm", 1 },
                        { "v1/balances", 1 },
                        { "v1/balances/staking", 1 },
                        { "v1/notionalbalances/{currency}", 1 },
                        { "v1/transfers", 1 },
                        { "v1/addresses/{network}", 1 },
                        { "v1/deposit/{network}/newAddress", 1 },
                        { "v1/deposit/{currency}/newAddress", 1 },
                        { "v1/withdraw/{currency}", 1 },
                        { "v1/account/transfer/{currency}", 1 },
                        { "v1/payments/addbank", 1 },
                        { "v1/payments/methods", 1 },
                        { "v1/payments/sen/withdraw", 1 },
                        { "v1/balances/earn", 1 },
                        { "v1/earn/interest", 1 },
                        { "v1/earn/history", 1 },
                        { "v1/approvedAddresses/{network}/request", 1 },
                        { "v1/approvedAddresses/account/{network}", 1 },
                        { "v1/approvedAddresses/{network}/remove", 1 },
                        { "v1/account", 1 },
                        { "v1/account/create", 1 },
                        { "v1/account/list", 1 },
                        { "v1/heartbeat", 1 },
                        { "v1/roles", 1 },
                    } },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "taker", 0.004 },
                    { "maker", 0.002 },
                } },
            } },
            { "httpExceptions", new Dictionary<string, object>() {
                { "400", typeof(BadRequest) },
                { "403", typeof(PermissionDenied) },
                { "404", typeof(OrderNotFound) },
                { "406", typeof(InsufficientFunds) },
                { "429", typeof(RateLimitExceeded) },
                { "500", typeof(ExchangeError) },
                { "502", typeof(ExchangeNotAvailable) },
                { "503", typeof(OnMaintenance) },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1hr" },
                { "6h", "6hr" },
                { "1d", "1day" },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "AuctionNotOpen", typeof(BadRequest) },
                    { "ClientOrderIdTooLong", typeof(BadRequest) },
                    { "ClientOrderIdMustBeString", typeof(BadRequest) },
                    { "ConflictingOptions", typeof(BadRequest) },
                    { "EndpointMismatch", typeof(BadRequest) },
                    { "EndpointNotFound", typeof(BadRequest) },
                    { "IneligibleTiming", typeof(BadRequest) },
                    { "InsufficientFunds", typeof(InsufficientFunds) },
                    { "InvalidJson", typeof(BadRequest) },
                    { "InvalidNonce", typeof(InvalidNonce) },
                    { "InvalidApiKey", typeof(AuthenticationError) },
                    { "InvalidOrderType", typeof(InvalidOrder) },
                    { "InvalidPrice", typeof(InvalidOrder) },
                    { "InvalidQuantity", typeof(InvalidOrder) },
                    { "InvalidSide", typeof(InvalidOrder) },
                    { "InvalidSignature", typeof(AuthenticationError) },
                    { "InvalidSymbol", typeof(BadRequest) },
                    { "InvalidTimestampInPayload", typeof(BadRequest) },
                    { "Maintenance", typeof(OnMaintenance) },
                    { "MarketNotOpen", typeof(InvalidOrder) },
                    { "MissingApikeyHeader", typeof(AuthenticationError) },
                    { "MissingOrderField", typeof(InvalidOrder) },
                    { "MissingRole", typeof(AuthenticationError) },
                    { "MissingPayloadHeader", typeof(AuthenticationError) },
                    { "MissingSignatureHeader", typeof(AuthenticationError) },
                    { "NoSSL", typeof(AuthenticationError) },
                    { "OptionsMustBeArray", typeof(BadRequest) },
                    { "OrderNotFound", typeof(OrderNotFound) },
                    { "RateLimit", typeof(RateLimitExceeded) },
                    { "System", typeof(ExchangeError) },
                    { "UnsupportedOption", typeof(BadRequest) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "The Gemini Exchange is currently undergoing maintenance.", typeof(OnMaintenance) },
                    { "We are investigating technical issues with the Gemini Exchange.", typeof(ExchangeNotAvailable) },
                    { "Internal Server Error", typeof(ExchangeNotAvailable) },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "fetchMarketsMethod", "fetch_markets_from_api" },
                { "fetchMarketFromWebRetries", 10 },
                { "fetchMarketsFromAPI", new Dictionary<string, object>() {
                    { "fetchDetailsForAllSymbols", false },
                    { "quoteCurrencies", new List<object>() {"USDT", "GUSD", "USD", "DAI", "EUR", "GBP", "SGD", "BTC", "ETH", "LTC", "BCH", "SOL", "USDC"} },
                } },
                { "fetchMarkets", new Dictionary<string, object>() {
                    { "webApiEnable", true },
                    { "webApiRetries", 10 },
                } },
                { "fetchUsdtMarkets", new List<object>() {"btcusdt", "ethusdt"} },
                { "fetchCurrencies", new Dictionary<string, object>() {
                    { "webApiEnable", true },
                    { "webApiRetries", 5 },
                    { "webApiMuteFailure", true },
                } },
                { "fetchTickerMethod", "fetchTickerV1" },
                { "networks", new Dictionary<string, object>() {
                    { "BTC", "bitcoin" },
                    { "ERC20", "ethereum" },
                    { "BCH", "bitcoincash" },
                    { "LTC", "litecoin" },
                    { "ZEC", "zcash" },
                    { "FIL", "filecoin" },
                    { "DOGE", "dogecoin" },
                    { "XTZ", "tezos" },
                    { "AVAXX", "avalanche" },
                    { "SOL", "solana" },
                    { "ATOM", "cosmos" },
                    { "DOT", "polkadot" },
                } },
                { "nonce", "milliseconds" },
                { "conflictingMarkets", new Dictionary<string, object>() {
                    { "paxgusd", new Dictionary<string, object>() {
                        { "base", "PAXG" },
                        { "quote", "USD" },
                    } },
                } },
                { "brokenPairs", new List<object>() {"efilusd", "maticrlusd", "maticusdc", "eurusdc", "maticgusd", "maticusd", "efilfil", "eurusd"} },
            } },
            { "features", new Dictionary<string, object>() {
                { "default", new Dictionary<string, object>() {
                    { "sandbox", true },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", true },
                        { "triggerPriceType", null },
                        { "triggerDirection", false },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "trailing", false },
                        { "leverage", false },
                        { "marketBuyByCost", true },
                        { "marketBuyRequiresPrice", false },
                        { "selfTradePrevention", false },
                        { "iceberg", false },
                    } },
                    { "createOrders", null },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 500 },
                        { "daysBack", null },
                        { "untilDays", null },
                        { "symbolRequired", true },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", null },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", null },
                    { "fetchClosedOrders", null },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", null },
                    } },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "extends", "default" },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "default" },
                    } },
                    { "inverse", null },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
            } },
        });
    }

    /**
     * @method
     * @name gemini#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @param {object} [params] extra parameters specific to the endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchCurrenciesFromWeb(parameters);
    }

    /**
     * @method
     * @name gemini#fetchCurrenciesFromWeb
     * @ignore
     * @description fetches all available currencies on an exchange
     * @param {object} [params] extra parameters specific to the endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async virtual Task<object> fetchCurrenciesFromWeb(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object data = await this.fetchWebEndpoint("fetchCurrencies", "webExchangeGet", true, "=\"currencyData\">", "</script>");
        if (isTrue(isEqual(data, null)))
        {
            return new Dictionary<string, object>() {};
        }
        //
        //    {
        //        "tradingPairs": [ [ 'BTCUSD', 2, 8, '0.00001', 10, true ],  ... ],
        //        "currencies": [
        //            [ "ORCA", "Orca", 204, 6, 0, 6, 8, false, null, "solana" ], // as confirmed, precisions seem to be the 5th index
        //            [ "ATOM", "Cosmos", 44, 6, 0, 6, 8, false, null, "cosmos" ],
        //            [ "ETH", "Ether", 2, 6, 0, 18, 8, false, null, "ethereum" ],
        //            [ "GBP", "Pound Sterling", 22, 2, 2, 2, 2, true, "Â£", null ],
        //            ...
        //        ],
        //        "networks": [
        //            [ "solana", "SOL", "Solana" ],
        //            [ "zcash", "ZEC", "Zcash" ],
        //            [ "tezos", "XTZ", "Tezos" ],
        //            [ "cosmos", "ATOM", "Cosmos" ],
        //            [ "ethereum", "ETH", "Ethereum" ],
        //            ...
        //        ]
        //    }
        //
        object result = new Dictionary<string, object>() {};
        ((IDictionary<string,object>)this.options)["tradingPairs"] = this.safeList(data, "tradingPairs");
        object currenciesArray = this.safeValue(data, "currencies", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(currenciesArray)); postFixIncrement(ref i))
        {
            object currency = getValue(currenciesArray, i);
            object id = this.safeString(currency, 0);
            object code = this.safeCurrencyCode(id);
            object type = ((bool) isTrue(this.safeString(currency, 7))) ? "fiat" : "crypto";
            object precision = this.parseNumber(this.parsePrecision(this.safeString(currency, 5)));
            object networks = new Dictionary<string, object>() {};
            object networkId = this.safeString(currency, 9);
            object networkCode = null;
            if (isTrue(!isEqual(networkId, null)))
            {
                networkCode = this.networkIdToCode(networkId);
                ((IDictionary<string,object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                    { "info", currency },
                    { "id", networkId },
                    { "network", networkCode },
                    { "active", null },
                    { "deposit", null },
                    { "withdraw", null },
                    { "fee", null },
                    { "precision", precision },
                    { "limits", new Dictionary<string, object>() {
                        { "deposit", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                    } },
                };
            }
            ((IDictionary<string,object>)result)[(string)code] = this.safeCurrencyStructure(new Dictionary<string, object>() {
                { "info", currency },
                { "id", id },
                { "code", code },
                { "name", this.safeString(currency, 1) },
                { "active", null },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "type", type },
                { "precision", precision },
                { "limits", new Dictionary<string, object>() {
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "networks", networks },
            });
        }
        return result;
    }

    /**
     * @method
     * @name gemini#fetchMarkets
     * @description retrieves data on all markets for gemini
     * @see https://docs.gemini.com/rest-api/#symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object method = this.safeValue(this.options, "fetchMarketsMethod", "fetch_markets_from_api");
        if (isTrue(isEqual(method, "fetch_markets_from_web")))
        {
            object promises = new List<object>() {};
            ((IList<object>)promises).Add(this.fetchMarketsFromWeb(parameters)); // get usd markets
            ((IList<object>)promises).Add(this.fetchUSDTMarkets(parameters)); // get usdt markets
            object promisesResult = await promiseAll(promises);
            return this.arrayConcat(getValue(promisesResult, 0), getValue(promisesResult, 1));
        }
        return await this.fetchMarketsFromAPI(parameters);
    }

    public async virtual Task<object> fetchMarketsFromWeb(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object data = await this.fetchWebEndpoint("fetchMarkets", "webGetRestApi", false, "<h1 id=\"symbols-and-minimums\">Symbols and minimums</h1>");
        object error = add(this.id, " fetchMarketsFromWeb() the API doc HTML markup has changed, breaking the parser of order limits and precision info for markets.");
        object tables = ((string)data).Split(new [] {((string)"tbody>")}, StringSplitOptions.None).ToList<object>();
        object numTables = getArrayLength(tables);
        if (isTrue(isLessThan(numTables, 2)))
        {
            throw new NotSupported ((string)error) ;
        }
        object rows = ((string)getValue(tables, 1)).Split(new [] {((string)"\n<tr>\n")}, StringSplitOptions.None).ToList<object>(); // eslint-disable-line quotes
        object numRows = getArrayLength(rows);
        if (isTrue(isLessThan(numRows, 2)))
        {
            throw new NotSupported ((string)error) ;
        }
        object result = new List<object>() {};
        // skip the first element (empty string)
        for (object i = 1; isLessThan(i, numRows); postFixIncrement(ref i))
        {
            object row = getValue(rows, i);
            object cells = ((string)row).Split(new [] {((string)"</td>\n")}, StringSplitOptions.None).ToList<object>(); // eslint-disable-line quotes
            object numCells = getArrayLength(cells);
            if (isTrue(isLessThan(numCells, 5)))
            {
                throw new NotSupported ((string)error) ;
            }
            //     [
            //         '<td>btcusd', // currency
            //         '<td>0.00001 BTC (1e-5)', // min order size
            //         '<td>0.00000001 BTC (1e-8)', // tick size
            //         '<td>0.01 USD', // quote currency price increment
            //         '</tr>'
            //     ]
            object marketId = ((string)getValue(cells, 0)).Replace((string)"<td>", (string)"");
            marketId = ((string)marketId).Replace((string)"*", (string)"");
            // const base = this.safeCurrencyCode (baseId);
            object minAmountString = ((string)getValue(cells, 1)).Replace((string)"<td>", (string)"");
            object minAmountParts = ((string)minAmountString).Split(new [] {((string)" ")}, StringSplitOptions.None).ToList<object>();
            object minAmount = this.safeNumber(minAmountParts, 0);
            object amountPrecisionString = ((string)getValue(cells, 2)).Replace((string)"<td>", (string)"");
            object amountPrecisionParts = ((string)amountPrecisionString).Split(new [] {((string)" ")}, StringSplitOptions.None).ToList<object>();
            object idLength = subtract(getArrayLength(marketId), 0);
            object startingIndex = subtract(idLength, 3);
            object pricePrecisionString = ((string)getValue(cells, 3)).Replace((string)"<td>", (string)"");
            object pricePrecisionParts = ((string)pricePrecisionString).Split(new [] {((string)" ")}, StringSplitOptions.None).ToList<object>();
            object quoteId = this.safeStringLower(pricePrecisionParts, 1, slice(marketId, startingIndex, idLength));
            object baseId = this.safeStringLower(amountPrecisionParts, 1, ((string)marketId).Replace((string)quoteId, (string)""));
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", marketId },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", null },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.safeNumber(amountPrecisionParts, 0) },
                    { "price", this.safeNumber(pricePrecisionParts, 0) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", minAmount },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", row },
            });
        }
        return result;
    }

    public virtual object parseMarketActive(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "open", true },
            { "closed", false },
            { "cancel_only", true },
            { "post_only", true },
            { "limit_only", true },
        };
        if (isTrue(isEqual(status, null)))
        {
            return true;  // as defaulted below
        }
        return this.safeBool(statuses, status, true);
    }

    public async virtual Task<object> fetchUSDTMarkets(object parameters = null)
    {
        // these markets can't be scrapped and fetchMarketsFrom api does an extra call
        // to load market ids which we don't need here
        parameters ??= new Dictionary<string, object>();
        if (isTrue(inOp(this.urls, "test")))
        {
            return new List<object>() {};  // sandbox does not have usdt markets
        }
        object fetchUsdtMarkets = this.safeValue(this.options, "fetchUsdtMarkets", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(fetchUsdtMarkets)); postFixIncrement(ref i))
        {
            object marketId = getValue(fetchUsdtMarkets, i);
            object request = new Dictionary<string, object>() {
                { "symbol", marketId },
            };
            // don't use Promise.all here, for some reason the exchange can't handle it and crashes
            object rawResponse = await this.publicGetV1SymbolsDetailsSymbol(this.extend(request, parameters));
            ((IList<object>)result).Add(this.parseMarket(rawResponse));
        }
        return result;
    }

    public async virtual Task<object> fetchMarketsFromAPI(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object marketIdsRaw = await this.publicGetV1Symbols(parameters);
        //
        //     [
        //         "btcusd",
        //         "linkusd",
        //         ...
        //     ]
        //
        object result = new List<object>() {};
        object options = this.safeDict(this.options, "fetchMarketsFromAPI", new Dictionary<string, object>() {});
        object brokenPairs = this.safeList(this.options, "brokenPairs", new List<object>() {});
        object marketIds = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(marketIdsRaw)); postFixIncrement(ref i))
        {
            if (!isTrue(this.inArray(getValue(marketIdsRaw, i), brokenPairs)))
            {
                ((IList<object>)marketIds).Add(getValue(marketIdsRaw, i));
            }
        }
        if (isTrue(this.safeBool(options, "fetchDetailsForAllSymbols", false)))
        {
            object promises = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
            {
                object marketId = getValue(marketIds, i);
                object request = new Dictionary<string, object>() {
                    { "symbol", marketId },
                };
                ((IList<object>)promises).Add(this.publicGetV1SymbolsDetailsSymbol(this.extend(request, parameters)));
            }
            object responses = await promiseAll(promises);
            for (object i = 0; isLessThan(i, getArrayLength(responses)); postFixIncrement(ref i))
            {
                ((IList<object>)result).Add(this.parseMarket(getValue(responses, i)));
            }
        } else
        {
            // use trading-pairs info, if it was fetched
            object tradingPairs = this.safeList(this.options, "tradingPairs");
            if (isTrue(!isEqual(tradingPairs, null)))
            {
                object indexedTradingPairs = this.indexBy(tradingPairs, 0);
                for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
                {
                    object marketId = getValue(marketIds, i);
                    object tradingPair = this.safeList(indexedTradingPairs, ((string)marketId).ToUpper());
                    if (isTrue(isTrue(!isEqual(tradingPair, null)) && !isTrue(this.inArray(tradingPair, brokenPairs))))
                    {
                        ((IList<object>)result).Add(this.parseMarket(tradingPair));
                    }
                }
            } else
            {
                for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
                {
                    if (!isTrue(this.inArray(getValue(marketIds, i), brokenPairs)))
                    {
                        ((IList<object>)result).Add(this.parseMarket(getValue(marketIds, i)));
                    }
                }
            }
        }
        return result;
    }

    public override object parseMarket(object response)
    {
        //
        // response might be:
        //
        //     btcusd
        //
        // or
        //
        //     [
        //         'BTCUSD',   // symbol
        //         2,          // tick precision (priceTickDecimalPlaces)
        //         8,          // amount precision (quantityTickDecimalPlaces)
        //         '0.00001',  // quantityMinimum
        //         10,         // quantityRoundDecimalPlaces
        //         true        // minimumsAreInclusive
        //     ],
        //
        // or
        //
        //     {
        //         "symbol": "BTCUSD", // perpetuals have 'PERP' suffix, i.e. DOGEUSDPERP
        //         "base_currency": "BTC",
        //         "quote_currency": "USD",
        //         "tick_size": 1E-8,
        //         "quote_increment": 0.01,
        //         "min_order_size": "0.00001",
        //         "status": "open",
        //         "wrap_enabled": false
        //         "product_type": "swap", // only in perps
        //         "contract_type": "linear", // only in perps
        //         "contract_price_currency": "GUSD"
        //     }
        //
        object marketId = null;
        object baseId = null;
        object quoteId = null;
        object settleId = null;
        object tickSize = null;
        object amountPrecision = null;
        object minSize = null;
        object status = null;
        object swap = false;
        object contractSize = null;
        object linear = null;
        object inverse = null;
        object isString = ((response is string));
        object isArray = (((response is IList<object>) || (response.GetType().IsGenericType && response.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))));
        if (isTrue(!isTrue(isString) && !isTrue(isArray)))
        {
            marketId = this.safeStringLower(response, "symbol");
            amountPrecision = this.safeNumber(response, "tick_size"); // right, exchange has an imperfect naming and this turns out to be an amount-precision
            tickSize = this.safeNumber(response, "quote_increment"); // this is tick-size actually
            minSize = this.safeNumber(response, "min_order_size");
            status = this.parseMarketActive(this.safeString(response, "status"));
            baseId = this.safeString(response, "base_currency");
            quoteId = this.safeString(response, "quote_currency");
            settleId = this.safeString(response, "contract_price_currency");
        } else
        {
            // if no detailed API was called, then parse either string or array
            if (isTrue(isString))
            {
                marketId = response;
            } else
            {
                marketId = this.safeStringLower(response, 0);
                tickSize = this.parseNumber(this.parsePrecision(this.safeString(response, 1))); // priceTickDecimalPlaces
                amountPrecision = this.parseNumber(this.parsePrecision(this.safeString(response, 2))); // quantityTickDecimalPlaces
                minSize = this.safeNumber(response, 3); // quantityMinimum
            }
            object marketIdUpper = ((string)marketId).ToUpper();
            object isPerp = (isGreaterThanOrEqual(getIndexOf(marketIdUpper, "PERP"), 0));
            object marketIdWithoutPerp = ((string)marketIdUpper).Replace((string)"PERP", (string)"");
            object conflictingMarkets = this.safeDict(this.options, "conflictingMarkets", new Dictionary<string, object>() {});
            object lowerCaseId = ((string)marketIdWithoutPerp).ToLower();
            if (isTrue(inOp(conflictingMarkets, lowerCaseId)))
            {
                object conflictingMarket = getValue(conflictingMarkets, lowerCaseId);
                baseId = getValue(conflictingMarket, "base");
                quoteId = getValue(conflictingMarket, "quote");
                if (isTrue(isPerp))
                {
                    settleId = getValue(conflictingMarket, "quote");
                }
            } else
            {
                object quoteCurrencies = this.handleOption("fetchMarketsFromAPI", "quoteCurrencies", new List<object>() {});
                for (object i = 0; isLessThan(i, getArrayLength(quoteCurrencies)); postFixIncrement(ref i))
                {
                    object quoteCurrency = getValue(quoteCurrencies, i);
                    if (isTrue(((string)marketIdWithoutPerp).EndsWith(((string)quoteCurrency))))
                    {
                        object quoteLength = this.parseToInt(multiply(-1, getArrayLength(quoteCurrency)));
                        baseId = slice(marketIdWithoutPerp, 0, quoteLength);
                        quoteId = quoteCurrency;
                        if (isTrue(isPerp))
                        {
                            settleId = quoteCurrency; // always same
                        }
                        break;
                    }
                }
            }
        }
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object settle = this.safeCurrencyCode(settleId);
        object symbol = add(add(bs, "/"), quote);
        if (isTrue(!isEqual(settleId, null)))
        {
            symbol = add(add(symbol, ":"), settle);
            swap = true;
            contractSize = tickSize; // always same
            linear = true; // always linear
            inverse = false;
        }
        object type = ((bool) isTrue(swap)) ? "swap" : "spot";
        return new Dictionary<string, object>() {
            { "id", marketId },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", type },
            { "spot", !isTrue(swap) },
            { "margin", false },
            { "swap", swap },
            { "future", false },
            { "option", false },
            { "active", status },
            { "contract", swap },
            { "linear", linear },
            { "inverse", inverse },
            { "contractSize", contractSize },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "price", tickSize },
                { "amount", amountPrecision },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", minSize },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", response },
        };
    }

    /**
     * @method
     * @name gemini#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://docs.gemini.com/rest-api/#current-order-book
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit_bids"] = limit;
            ((IDictionary<string,object>)request)["limit_asks"] = limit;
        }
        object response = await this.publicGetV1BookSymbol(this.extend(request, parameters));
        return this.parseOrderBook(response, getValue(market, "symbol"), null, "bids", "asks", "price", "amount");
    }

    public async virtual Task<object> fetchTickerV1(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetV1PubtickerSymbol(this.extend(request, parameters));
        //
        //     {
        //         "bid":"9117.95",
        //         "ask":"9117.96",
        //         "volume":{
        //             "BTC":"1615.46861748",
        //             "USD":"14727307.57545006088",
        //             "timestamp":1594982700000
        //         },
        //         "last":"9115.23"
        //     }
        //
        return this.parseTicker(response, market);
    }

    public async virtual Task<object> fetchTickerV2(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetV2TickerSymbol(this.extend(request, parameters));
        //
        //     {
        //         "symbol":"BTCUSD",
        //         "open":"9080.58",
        //         "high":"9184.53",
        //         "low":"9063.56",
        //         "close":"9116.08",
        //         // Hourly prices descending for past 24 hours
        //         "changes":["9117.33","9105.69","9106.23","9120.35","9098.57","9114.53","9113.55","9128.01","9113.63","9133.49","9133.49","9137.75","9126.73","9103.91","9119.33","9123.04","9124.44","9117.57","9114.22","9102.33","9076.67","9074.72","9074.97","9092.05"],
        //         "bid":"9115.86",
        //         "ask":"9115.87"
        //     }
        //
        return this.parseTicker(response, market);
    }

    public async virtual Task<object> fetchTickerV1AndV2(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object tickerPromiseA = this.fetchTickerV1(symbol, parameters);
        object tickerPromiseB = this.fetchTickerV2(symbol, parameters);
        var tickerAtickerBVariable = await promiseAll(new List<object>() {tickerPromiseA, tickerPromiseB});
        var tickerA = ((IList<object>) tickerAtickerBVariable)[0];
        var tickerB = ((IList<object>) tickerAtickerBVariable)[1];
        return this.deepExtend(tickerA, new Dictionary<string, object>() {
            { "open", getValue(tickerB, "open") },
            { "high", getValue(tickerB, "high") },
            { "low", getValue(tickerB, "low") },
            { "change", getValue(tickerB, "change") },
            { "percentage", getValue(tickerB, "percentage") },
            { "average", getValue(tickerB, "average") },
            { "info", getValue(tickerB, "info") },
        });
    }

    /**
     * @method
     * @name gemini#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://docs.gemini.com/rest-api/#ticker
     * @see https://docs.gemini.com/rest-api/#ticker-v2
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {object} [params.fetchTickerMethod] 'fetchTickerV2', 'fetchTickerV1' or 'fetchTickerV1AndV2' - 'fetchTickerV1' for original ccxt.gemini.fetchTicker - 'fetchTickerV1AndV2' for 2 api calls to get the result of both fetchTicker methods - default = 'fetchTickerV1'
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object method = this.safeValue(this.options, "fetchTickerMethod", "fetchTickerV1");
        if (isTrue(isEqual(method, "fetchTickerV1")))
        {
            return await this.fetchTickerV1(symbol, parameters);
        }
        if (isTrue(isEqual(method, "fetchTickerV2")))
        {
            return await this.fetchTickerV2(symbol, parameters);
        }
        return await this.fetchTickerV1AndV2(symbol, parameters);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // fetchTickers
        //
        //     {
        //         "pair": "BATUSD",
        //         "price": "0.20687",
        //         "percentChange24h": "0.0146"
        //     }
        //
        // fetchTickerV1
        //
        //     {
        //         "bid":"9117.95",
        //         "ask":"9117.96",
        //         "volume":{
        //             "BTC":"1615.46861748",
        //             "USD":"14727307.57545006088",
        //             "timestamp":1594982700000
        //         },
        //         "last":"9115.23"
        //     }
        //
        // fetchTickerV2
        //
        //     {
        //         "symbol":"BTCUSD",
        //         "open":"9080.58",
        //         "high":"9184.53",
        //         "low":"9063.56",
        //         "close":"9116.08",
        //         // Hourly prices descending for past 24 hours
        //         "changes":["9117.33","9105.69","9106.23","9120.35","9098.57","9114.53","9113.55","9128.01","9113.63","9133.49","9133.49","9137.75","9126.73","9103.91","9119.33","9123.04","9124.44","9117.57","9114.22","9102.33","9076.67","9074.72","9074.97","9092.05"],
        //         "bid":"9115.86",
        //         "ask":"9115.87"
        //     }
        //
        object volume = this.safeValue(ticker, "volume", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(volume, "timestamp");
        object symbol = null;
        object marketId = this.safeStringLower(ticker, "pair");
        market = this.safeMarket(marketId, market);
        object baseId = null;
        object quoteId = null;
        object bs = null;
        object quote = null;
        if (isTrue(isTrue((!isEqual(marketId, null))) && isTrue((isEqual(market, null)))))
        {
            object idLength = subtract(((string)marketId).Length, 0);
            if (isTrue(isEqual(idLength, 7)))
            {
                baseId = slice(marketId, 0, 4);
                quoteId = slice(marketId, 4, 7);
            } else
            {
                baseId = slice(marketId, 0, 3);
                quoteId = slice(marketId, 3, 6);
            }
            bs = this.safeCurrencyCode(baseId);
            quote = this.safeCurrencyCode(quoteId);
            symbol = add(add(bs, "/"), quote);
        }
        if (isTrue(isTrue((isEqual(symbol, null))) && isTrue((!isEqual(market, null)))))
        {
            symbol = getValue(market, "symbol");
            baseId = this.safeStringUpper(market, "baseId");
            quoteId = this.safeStringUpper(market, "quoteId");
        }
        object price = this.safeString(ticker, "price");
        object last = this.safeString2(ticker, "last", "close", price);
        object percentage = this.safeString(ticker, "percentChange24h");
        object open = this.safeString(ticker, "open");
        object baseVolume = this.safeString(volume, baseId);
        object quoteVolume = this.safeString(volume, quoteId);
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(ticker, "bid") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "ask") },
            { "askVolume", null },
            { "vwap", null },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name gemini#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://docs.gemini.com/rest-api/#price-feed
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetV1Pricefeed(parameters);
        //
        //     [
        //         {
        //             "pair": "BATUSD",
        //             "price": "0.20687",
        //             "percentChange24h": "0.0146"
        //         },
        //         {
        //             "pair": "LINKETH",
        //             "price": "0.018",
        //             "percentChange24h": "0.0000"
        //         },
        //     ]
        //
        object result = this.parseTickers(response, symbols);
        object brokenPairs = this.safeList(this.options, "brokenPairs", new List<object>() {});
        return this.removeKeysFromDict(result, brokenPairs);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public fetchTrades
        //
        //     {
        //         "timestamp":1601617445,
        //         "timestampms":1601617445144,
        //         "tid":14122489752,
        //         "price":"0.46476",
        //         "amount":"28.407209",
        //         "exchange":"gemini",
        //         "type":"buy"
        //     }
        //
        // private fetchTrades
        //
        //      {
        //          "price":"3900.00",
        //          "amount":"0.00996",
        //          "timestamp":1638891173,
        //          "timestampms":1638891173518,
        //          "type":"Sell",
        //          "aggressor":false,
        //          "fee_currency":"EUR",
        //          "fee_amount":"0.00",
        //          "tid":73621746145,
        //          "order_id":"73621746059",
        //          "exchange":"gemini",
        //          "is_auction_fill":false,
        //          "is_clearing_fill":false,
        //          "symbol":"ETHEUR",
        //          "client_order_id":"1638891171610"
        //      }
        //
        object timestamp = this.safeInteger(trade, "timestampms");
        object id = this.safeString(trade, "tid");
        object orderId = this.safeString(trade, "order_id");
        object feeCurrencyId = this.safeString(trade, "fee_currency");
        object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
        object fee = new Dictionary<string, object>() {
            { "cost", this.safeString(trade, "fee_amount") },
            { "currency", feeCurrencyCode },
        };
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString(trade, "amount");
        object side = this.safeStringLower(trade, "type");
        object symbol = this.safeSymbol(null, market);
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "order", orderId },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", null },
            { "side", side },
            { "takerOrMaker", null },
            { "price", priceString },
            { "cost", null },
            { "amount", amountString },
            { "fee", fee },
        }, market);
    }

    /**
     * @method
     * @name gemini#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://docs.gemini.com/rest-api/#trade-history
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit_trades"] = mathMin(limit, 500);
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["timestamp"] = since;
        }
        object response = await this.publicGetV1TradesSymbol(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "timestamp":1601617445,
        //             "timestampms":1601617445144,
        //             "tid":14122489752,
        //             "price":"0.46476",
        //             "amount":"28.407209",
        //             "exchange":"gemini",
        //             "type":"buy"
        //         },
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object balance = getValue(response, i);
            object currencyId = this.safeString(balance, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "available");
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "amount");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name gemini#fetchTradingFees
     * @description fetch the trading fees for multiple markets
     * @see https://docs.gemini.com/rest-api/#get-notional-volume
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
     */
    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostV1Notionalvolume(parameters);
        //
        //      {
        //          "web_maker_fee_bps": 25,
        //          "web_taker_fee_bps": 35,
        //          "web_auction_fee_bps": 25,
        //          "api_maker_fee_bps": 10,
        //          "api_taker_fee_bps": 35,
        //          "api_auction_fee_bps": 20,
        //          "fix_maker_fee_bps": 10,
        //          "fix_taker_fee_bps": 35,
        //          "fix_auction_fee_bps": 20,
        //          "block_maker_fee_bps": 0,
        //          "block_taker_fee_bps": 50,
        //          "notional_30d_volume": 150.00,
        //          "last_updated_ms": 1551371446000,
        //          "date": "2019-02-28",
        //          "notional_1d_volume": [
        //              {
        //                  "date": "2019-02-22",
        //                  "notional_volume": 75.00
        //              },
        //              {
        //                  "date": "2019-02-14",
        //                  "notional_volume": 75.00
        //              }
        //          ]
        //     }
        //
        object makerBps = this.safeString(response, "api_maker_fee_bps");
        object takerBps = this.safeString(response, "api_taker_fee_bps");
        object makerString = Precise.stringDiv(makerBps, "10000");
        object takerString = Precise.stringDiv(takerBps, "10000");
        object maker = this.parseNumber(makerString);
        object taker = this.parseNumber(takerString);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(this.symbols, i);
            ((IDictionary<string,object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "info", response },
                { "symbol", symbol },
                { "maker", maker },
                { "taker", taker },
                { "percentage", true },
                { "tierBased", true },
            };
        }
        return result;
    }

    /**
     * @method
     * @name gemini#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://docs.gemini.com/rest-api/#get-available-balances
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostV1Balances(parameters);
        return this.parseBalance(response);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder (private)
        //
        //      {
        //          "order_id":"106027397702",
        //          "id":"106027397702",
        //          "symbol":"etheur",
        //          "exchange":"gemini",
        //          "avg_execution_price":"2877.48",
        //          "side":"sell",
        //          "type":"exchange limit",
        //          "timestamp":"1650398122",
        //          "timestampms":1650398122308,
        //          "is_live":false,
        //          "is_cancelled":false,
        //          "is_hidden":false,
        //          "was_forced":false,
        //          "executed_amount":"0.014434",
        //          "client_order_id":"1650398121695",
        //          "options":[],
        //          "price":"2800.00",
        //          "original_amount":"0.014434",
        //          "remaining_amount":"0"
        //      }
        //
        // fetchOrder (private)
        //
        //      {
        //          "order_id":"106028543717",
        //          "id":"106028543717",
        //          "symbol":"etheur",
        //          "exchange":"gemini",
        //          "avg_execution_price":"0.00",
        //          "side":"buy",
        //          "type":"exchange limit",
        //          "timestamp":"1650398446",
        //          "timestampms":1650398446375,
        //          "is_live":true,
        //          "is_cancelled":false,
        //          "is_hidden":false,
        //          "was_forced":false,
        //          "executed_amount":"0",
        //          "client_order_id":"1650398445709",
        //          "options":[],
        //          "price":"2000.00",
        //          "original_amount":"0.01",
        //          "remaining_amount":"0.01"
        //      }
        //
        // fetchOpenOrders (private)
        //
        //      {
        //          "order_id":"106028543717",
        //          "id":"106028543717",
        //          "symbol":"etheur",
        //          "exchange":"gemini",
        //          "avg_execution_price":"0.00",
        //          "side":"buy",
        //          "type":"exchange limit",
        //          "timestamp":"1650398446",
        //          "timestampms":1650398446375,
        //          "is_live":true,
        //          "is_cancelled":false,
        //          "is_hidden":false,
        //          "was_forced":false,
        //          "executed_amount":"0",
        //          "client_order_id":"1650398445709",
        //          "options":[],
        //          "price":"2000.00",
        //          "original_amount":"0.01",
        //          "remaining_amount":"0.01"
        //      }
        //
        // cancelOrder (private)
        //
        //      {
        //          "order_id":"106028543717",
        //          "id":"106028543717",
        //          "symbol":"etheur",
        //          "exchange":"gemini",
        //          "avg_execution_price":"0.00",
        //          "side":"buy",
        //          "type":"exchange limit",
        //          "timestamp":"1650398446",
        //          "timestampms":1650398446375,
        //          "is_live":false,
        //          "is_cancelled":true,
        //          "is_hidden":false,
        //          "was_forced":false,
        //          "executed_amount":"0",
        //          "client_order_id":"1650398445709",
        //          "reason":"Requested",
        //          "options":[],
        //          "price":"2000.00",
        //          "original_amount":"0.01",
        //          "remaining_amount":"0.01"
        //      }
        //
        object timestamp = this.safeInteger(order, "timestampms");
        object amount = this.safeString(order, "original_amount");
        object remaining = this.safeString(order, "remaining_amount");
        object filled = this.safeString(order, "executed_amount");
        object status = "closed";
        if (isTrue(getValue(order, "is_live")))
        {
            status = "open";
        }
        if (isTrue(getValue(order, "is_cancelled")))
        {
            status = "canceled";
        }
        object price = this.safeString(order, "price");
        object average = this.safeString(order, "avg_execution_price");
        object type = this.safeString(order, "type");
        if (isTrue(isEqual(type, "exchange limit")))
        {
            type = "limit";
        } else if (isTrue(isTrue(isEqual(type, "market buy")) || isTrue(isEqual(type, "market sell"))))
        {
            type = "market";
        } else
        {
            type = getValue(order, "type");
        }
        object fee = null;
        object marketId = this.safeString(order, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object id = this.safeString(order, "order_id");
        object side = this.safeStringLower(order, "side");
        object clientOrderId = this.safeString(order, "client_order_id");
        object optionsArray = this.safeValue(order, "options", new List<object>() {});
        object option = this.safeString(optionsArray, 0);
        object timeInForce = "GTC";
        object postOnly = false;
        if (isTrue(!isEqual(option, null)))
        {
            if (isTrue(isEqual(option, "immediate-or-cancel")))
            {
                timeInForce = "IOC";
            } else if (isTrue(isEqual(option, "fill-or-kill")))
            {
                timeInForce = "FOK";
            } else if (isTrue(isEqual(option, "maker-or-cancel")))
            {
                timeInForce = "PO";
                postOnly = true;
            }
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "info", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "status", status },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "side", side },
            { "price", price },
            { "triggerPrice", null },
            { "average", average },
            { "cost", null },
            { "amount", amount },
            { "filled", filled },
            { "remaining", remaining },
            { "fee", fee },
            { "trades", null },
        }, market);
    }

    /**
     * @method
     * @name gemini#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://docs.gemini.com/rest-api/#order-status
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        object response = await this.privatePostV1OrderStatus(this.extend(request, parameters));
        //
        //      {
        //          "order_id":"106028543717",
        //          "id":"106028543717",
        //          "symbol":"etheur",
        //          "exchange":"gemini",
        //          "avg_execution_price":"0.00",
        //          "side":"buy",
        //          "type":"exchange limit",
        //          "timestamp":"1650398446",
        //          "timestampms":1650398446375,
        //          "is_live":true,
        //          "is_cancelled":false,
        //          "is_hidden":false,
        //          "was_forced":false,
        //          "executed_amount":"0",
        //          "client_order_id":"1650398445701",
        //          "options":[],
        //          "price":"2000.00",
        //          "original_amount":"0.01",
        //          "remaining_amount":"0.01"
        //      }
        //
        return this.parseOrder(response);
    }

    /**
     * @method
     * @name gemini#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://docs.gemini.com/rest-api/#get-active-orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of  open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostV1Orders(parameters);
        //
        //      [
        //          {
        //              "order_id":"106028543717",
        //              "id":"106028543717",
        //              "symbol":"etheur",
        //              "exchange":"gemini",
        //              "avg_execution_price":"0.00",
        //              "side":"buy",
        //              "type":"exchange limit",
        //              "timestamp":"1650398446",
        //              "timestampms":1650398446375,
        //              "is_live":true,
        //              "is_cancelled":false,
        //              "is_hidden":false,
        //              "was_forced":false,
        //              "executed_amount":"0",
        //              "client_order_id":"1650398445709",
        //              "options":[],
        //              "price":"2000.00",
        //              "original_amount":"0.01",
        //              "remaining_amount":"0.01"
        //          }
        //      ]
        //
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol); // throws on non-existent symbol
        }
        return this.parseOrders(response, market, since, limit);
    }

    /**
     * @method
     * @name gemini#createOrder
     * @description create a trade order
     * @see https://docs.gemini.com/rest-api/#new-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type must be 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(!isEqual(type, "limit")))
        {
            throw new ExchangeError ((string)add(this.id, " createOrder() allows limit orders only")) ;
        }
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "client_order_id");
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "client_order_id"});
        if (isTrue(isEqual(clientOrderId, null)))
        {
            clientOrderId = ((object)this.milliseconds()).ToString();
        }
        object market = this.market(symbol);
        object amountString = this.amountToPrecision(symbol, amount);
        object priceString = this.priceToPrecision(symbol, price);
        object request = new Dictionary<string, object>() {
            { "client_order_id", clientOrderId },
            { "symbol", getValue(market, "id") },
            { "amount", amountString },
            { "price", priceString },
            { "side", side },
            { "type", "exchange limit" },
        };
        type = this.safeString(parameters, "type", type);
        parameters = this.omit(parameters, "type");
        object triggerPrice = this.safeStringN(parameters, new List<object>() {"triggerPrice", "stop_price", "stopPrice"});
        parameters = this.omit(parameters, new List<object>() {"triggerPrice", "stop_price", "stopPrice", "type"});
        if (isTrue(isEqual(type, "stopLimit")))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " createOrder() requires a triggerPrice parameter or a stop_price parameter for "), type), " orders")) ;
        }
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((IDictionary<string,object>)request)["stop_price"] = this.priceToPrecision(symbol, triggerPrice);
            ((IDictionary<string,object>)request)["type"] = "exchange stop limit";
        } else
        {
            // No options can be applied to stop-limit orders at this time.
            object timeInForce = this.safeString(parameters, "timeInForce");
            parameters = this.omit(parameters, "timeInForce");
            if (isTrue(!isEqual(timeInForce, null)))
            {
                if (isTrue(isTrue((isEqual(timeInForce, "IOC"))) || isTrue((isEqual(timeInForce, "immediate-or-cancel")))))
                {
                    ((IDictionary<string,object>)request)["options"] = new List<object>() {"immediate-or-cancel"};
                } else if (isTrue(isTrue((isEqual(timeInForce, "FOK"))) || isTrue((isEqual(timeInForce, "fill-or-kill")))))
                {
                    ((IDictionary<string,object>)request)["options"] = new List<object>() {"fill-or-kill"};
                } else if (isTrue(isEqual(timeInForce, "PO")))
                {
                    ((IDictionary<string,object>)request)["options"] = new List<object>() {"maker-or-cancel"};
                }
            }
            object postOnly = this.safeBool(parameters, "postOnly", false);
            parameters = this.omit(parameters, "postOnly");
            if (isTrue(postOnly))
            {
                ((IDictionary<string,object>)request)["options"] = new List<object>() {"maker-or-cancel"};
            }
            // allowing override for auction-only and indication-of-interest order options
            object options = this.safeString(parameters, "options");
            if (isTrue(!isEqual(options, null)))
            {
                ((IDictionary<string,object>)request)["options"] = new List<object>() {options};
            }
        }
        object response = await this.privatePostV1OrderNew(this.extend(request, parameters));
        //
        //      {
        //          "order_id":"106027397702",
        //          "id":"106027397702",
        //          "symbol":"etheur",
        //          "exchange":"gemini",
        //          "avg_execution_price":"2877.48",
        //          "side":"sell",
        //          "type":"exchange limit",
        //          "timestamp":"1650398122",
        //          "timestampms":1650398122308,
        //          "is_live":false,
        //          "is_cancelled":false,
        //          "is_hidden":false,
        //          "was_forced":false,
        //          "executed_amount":"0.014434",
        //          "client_order_id":"1650398121695",
        //          "options":[],
        //          "price":"2800.00",
        //          "original_amount":"0.014434",
        //          "remaining_amount":"0"
        //      }
        //
        return this.parseOrder(response);
    }

    /**
     * @method
     * @name gemini#cancelOrder
     * @description cancels an open order
     * @see https://docs.gemini.com/rest-api/#cancel-order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        object response = await this.privatePostV1OrderCancel(this.extend(request, parameters));
        //
        //      {
        //          "order_id":"106028543717",
        //          "id":"106028543717",
        //          "symbol":"etheur",
        //          "exchange":"gemini",
        //          "avg_execution_price":"0.00",
        //          "side":"buy",
        //          "type":"exchange limit",
        //          "timestamp":"1650398446",
        //          "timestampms":1650398446375,
        //          "is_live":false,
        //          "is_cancelled":true,
        //          "is_hidden":false,
        //          "was_forced":false,
        //          "executed_amount":"0",
        //          "client_order_id":"1650398445709",
        //          "reason":"Requested",
        //          "options":[],
        //          "price":"2000.00",
        //          "original_amount":"0.01",
        //          "remaining_amount":"0.01"
        //      }
        //
        return this.parseOrder(response);
    }

    /**
     * @method
     * @name gemini#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://docs.gemini.com/rest-api/#get-past-trades
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit_trades"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["timestamp"] = this.parseToInt(divide(since, 1000));
        }
        object response = await this.privatePostV1Mytrades(this.extend(request, parameters));
        return this.parseTrades(response, market, since, limit);
    }

    /**
     * @method
     * @name gemini#withdraw
     * @description make a withdrawal
     * @see https://docs.gemini.com/rest-api/#withdraw-crypto-funds
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", amount },
            { "address", address },
        };
        object response = await this.privatePostV1WithdrawCurrency(this.extend(request, parameters));
        //
        //   for BTC
        //     {
        //         "address":"mi98Z9brJ3TgaKsmvXatuRahbFRUFKRUdR",
        //         "amount":"1",
        //         "withdrawalId":"02176a83-a6b1-4202-9b85-1c1c92dd25c4",
        //         "message":"You have requested a transfer of 1 BTC to mi98Z9brJ3TgaKsmvXatuRahbFRUFKRUdR. This withdrawal will be sent to the blockchain within the next 60 seconds."
        //     }
        //
        //   for ETH
        //     {
        //         "address":"0xA63123350Acc8F5ee1b1fBd1A6717135e82dBd28",
        //         "amount":"2.34567",
        //         "txHash":"0x28267179f92926d85c5516bqc063b2631935573d8915258e95d9572eedcc8cc"
        //     }
        //
        //   for error (other variations of error messages are also expected)
        //     {
        //         "result":"error",
        //         "reason":"CryptoAddressWhitelistsNotEnabled",
        //         "message":"Cryptocurrency withdrawal address whitelists are not enabled for account 24. Please contact support@gemini.com for information on setting up a withdrawal address whitelist."
        //     }
        //
        object result = this.safeString(response, "result");
        if (isTrue(isEqual(result, "error")))
        {
            throw new ExchangeError ((string)add(add(this.id, " withdraw() failed: "), this.json(response))) ;
        }
        return this.parseTransaction(response, currency);
    }

    public override object nonce()
    {
        object nonceMethod = this.safeString(this.options, "nonce", "milliseconds");
        if (isTrue(isEqual(nonceMethod, "milliseconds")))
        {
            return this.milliseconds();
        }
        return this.seconds();
    }

    /**
     * @method
     * @name gemini#fetchDepositsWithdrawals
     * @description fetch history of deposits and withdrawals
     * @see https://docs.gemini.com/rest-api/#transfers
     * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
     * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
     * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDepositsWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit_transfers"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["timestamp"] = since;
        }
        object response = await this.privatePostV1Transfers(this.extend(request, parameters));
        return this.parseTransactions(response);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // withdraw
        //
        //   for BTC
        //     {
        //         "address":"mi98Z9brJ3TgaKsmvXatuRahbFRUFKRUdR",
        //         "amount":"1",
        //         "withdrawalId":"02176a83-a6b1-4202-9b85-1c1c92dd25c4",
        //         "message":"You have requested a transfer of 1 BTC to mi98Z9brJ3TgaKsmvXatuRahbFRUFKRUdR. This withdrawal will be sent to the blockchain within the next 60 seconds."
        //     }
        //
        //   for ETH
        //     {
        //         "address":"0xA63123350Acc8F5ee1b1fBd1A6717135e82dBd28",
        //         "amount":"2.34567",
        //         "txHash":"0x28267179f92926d85c5516bqc063b2631935573d8915258e95d9572eedcc8cc"
        //     }
        //
        object timestamp = this.safeInteger(transaction, "timestampms");
        object currencyId = this.safeString(transaction, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object address = this.safeString(transaction, "destination");
        object type = this.safeStringLower(transaction, "type");
        // if status field is available, then it's complete
        object statusRaw = this.safeString(transaction, "status");
        object fee = null;
        object feeAmount = this.safeNumber(transaction, "feeAmount");
        if (isTrue(!isEqual(feeAmount, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeAmount },
                { "currency", code },
            };
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString2(transaction, "eid", "withdrawalId") },
            { "txid", this.safeString(transaction, "txHash") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", null },
            { "address", address },
            { "addressTo", null },
            { "addressFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", type },
            { "amount", this.safeNumber(transaction, "amount") },
            { "currency", code },
            { "status", this.parseTransactionStatus(statusRaw) },
            { "updated", null },
            { "internal", null },
            { "comment", this.safeString(transaction, "message") },
            { "fee", fee },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "Advanced", "ok" },
            { "Complete", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //      {
        //          "address": "0xed6494Fe7c1E56d1bd6136e89268C51E32d9708B",
        //          "timestamp": "1636813923098",
        //          "addressVersion": "eV1"                                         }
        //      }
        //
        object address = this.safeString(depositAddress, "address");
        object code = this.safeCurrencyCode(null, currency);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "network", null },
            { "address", address },
            { "tag", null },
            { "info", depositAddress },
        };
    }

    /**
     * @method
     * @name gemini#fetchDepositAddress
     * @see https://docs.gemini.com/rest-api/#get-deposit-addresses
     * @description fetch the deposit address for a currency associated with this account
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the endpoint
     * @param {string} [params.network]  *required* The chain of currency
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object groupedByNetwork = await this.fetchDepositAddressesByNetwork(code, parameters);
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        object networkGroup = this.indexBy(this.safeValue(groupedByNetwork, networkCode), "currency");
        return this.safeValue(networkGroup, code);
    }

    /**
     * @method
     * @name gemini#fetchDepositAddressesByNetwork
     * @description fetch a dictionary of addresses for a currency, indexed by network
     * @see https://docs.gemini.com/rest-api/#get-deposit-addresses
     * @param {string} code unified currency code of the currency for the deposit address
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network]  *required* The chain of currency
     * @returns {object} a dictionary of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure} indexed by the network
     */
    public async override Task<object> fetchDepositAddressesByNetwork(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        code = getValue(currency, "code");
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(isEqual(networkCode, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDepositAddresses() requires a network parameter")) ;
        }
        object networkId = this.networkCodeToId(networkCode);
        object request = new Dictionary<string, object>() {
            { "network", networkId },
        };
        object response = await this.privatePostV1AddressesNetwork(this.extend(request, parameters));
        object results = this.parseDepositAddresses(response, new List<object>() {code}, false, new Dictionary<string, object>() {
            { "network", networkCode },
            { "currency", code },
        });
        return this.groupBy(results, "network");
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add("/", this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object apiKey = this.apiKey;
            if (isTrue(isLessThan(getIndexOf(apiKey, "account"), 0)))
            {
                throw new AuthenticationError ((string)add(this.id, " sign() requires an account-key, master-keys are not-supported")) ;
            }
            object nonce = ((object)this.nonce()).ToString();
            object request = this.extend(new Dictionary<string, object>() {
                { "request", url },
                { "nonce", nonce },
            }, query);
            object payload = this.json(request);
            payload = this.stringToBase64(payload);
            object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha384);
            headers = new Dictionary<string, object>() {
                { "Content-Type", "text/plain" },
                { "X-GEMINI-APIKEY", this.apiKey },
                { "X-GEMINI-PAYLOAD", payload },
                { "X-GEMINI-SIGNATURE", signature },
            };
        } else
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        }
        url = add(getValue(getValue(this.urls, "api"), api), url);
        if (isTrue(isTrue((isEqual(method, "POST"))) || isTrue((isEqual(method, "DELETE")))))
        {
            body = this.json(query);
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            if (isTrue((body is string)))
            {
                object feedback = add(add(this.id, " "), body);
                this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
            }
            return null;  // fallback to default error handler
        }
        //
        //     {
        //         "result": "error",
        //         "reason": "BadNonce",
        //         "message": "Out-of-sequence nonce <1234> precedes previously used nonce <2345>"
        //     }
        //
        object result = this.safeString(response, "result");
        if (isTrue(isEqual(result, "error")))
        {
            object reasonInner = this.safeString(response, "reason");
            object message = this.safeString(response, "message");
            object feedback = add(add(this.id, " "), message);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), reasonInner, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }

    /**
     * @method
     * @name gemini#createDepositAddress
     * @description create a currency deposit address
     * @see https://docs.gemini.com/rest-api/#new-deposit-address
     * @param {string} code unified currency code of the currency for the deposit address
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.privatePostV1DepositCurrencyNewAddress(this.extend(request, parameters));
        object address = this.safeString(response, "address");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", null },
            { "network", null },
            { "info", response },
        };
    }

    /**
     * @method
     * @name gemini#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://docs.gemini.com/rest-api/#candles
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object timeframeId = this.safeString(this.timeframes, timeframe, timeframe);
        object request = new Dictionary<string, object>() {
            { "timeframe", timeframeId },
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetV2CandlesSymbolTimeframe(this.extend(request, parameters));
        //
        //     [
        //         [1591515000000,0.02509,0.02509,0.02509,0.02509,0],
        //         [1591514700000,0.02503,0.02509,0.02503,0.02509,44.6405],
        //         [1591514400000,0.02503,0.02503,0.02503,0.02503,0],
        //     ]
        //
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }
}
