namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class coinmetro : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "coinmetro" },
            { "name", "Coinmetro" },
            { "countries", new List<object>() {"EE"} },
            { "version", "v1" },
            { "rateLimit", 200 },
            { "certified", false },
            { "pro", false },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "borrowCrossMargin", true },
                { "borrowIsolatedMargin", false },
                { "cancelAllOrders", false },
                { "cancelOrder", true },
                { "cancelOrders", false },
                { "closeAllPositions", false },
                { "closePosition", true },
                { "createDepositAddress", false },
                { "createOrder", true },
                { "createPostOnlyOrder", false },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "deposit", false },
                { "editOrder", false },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchBidsAsks", true },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCanceledAndClosedOrders", true },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrder", false },
                { "fetchClosedOrders", false },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDeposit", false },
                { "fetchDepositAddress", false },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", false },
                { "fetchDepositsWithdrawals", false },
                { "fetchDepositWithdrawFee", false },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchL3OrderBook", false },
                { "fetchLedger", true },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchMarketLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", false },
                { "fetchOrders", false },
                { "fetchOrderTrades", false },
                { "fetchPosition", false },
                { "fetchPositions", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", false },
                { "fetchTicker", false },
                { "fetchTickers", true },
                { "fetchTime", false },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTradingLimits", false },
                { "fetchTransactionFee", false },
                { "fetchTransactionFees", false },
                { "fetchTransactions", false },
                { "fetchTransfers", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", false },
                { "fetchWithdrawalWhitelist", false },
                { "reduceMargin", false },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", false },
                { "sandbox", true },
                { "setLeverage", false },
                { "setMargin", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "signIn", false },
                { "transfer", false },
                { "withdraw", false },
                { "ws", false },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "60000" },
                { "5m", "300000" },
                { "30m", "1800000" },
                { "4h", "14400000" },
                { "1d", "86400000" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/ccxt/ccxt/assets/43336371/e86f87ec-6ba3-4410-962b-f7988c5db539" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.coinmetro.com" },
                    { "private", "https://api.coinmetro.com" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "public", "https://api.coinmetro.com/open" },
                    { "private", "https://api.coinmetro.com/open" },
                } },
                { "www", "https://coinmetro.com/" },
                { "doc", new List<object>() {"https://documenter.getpostman.com/view/3653795/SVfWN6KS"} },
                { "fees", "https://help.coinmetro.com/hc/en-gb/articles/6844007317789-What-are-the-fees-on-Coinmetro-" },
                { "referral", "https://go.coinmetro.com/?ref=crypto24" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "demo/temp", 1 },
                        { "exchange/candles/{pair}/{timeframe}/{from}/{to}", 3 },
                        { "exchange/prices", 1 },
                        { "exchange/ticks/{pair}/{from}", 3 },
                        { "assets", 1 },
                        { "markets", 1 },
                        { "exchange/book/{pair}", 3 },
                        { "exchange/bookUpdates/{pair}/{from}", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "users/balances", 1 },
                        { "users/wallets", 1 },
                        { "users/wallets/history/{since}", 1.67 },
                        { "exchange/orders/status/{orderID}", 1 },
                        { "exchange/orders/active", 1 },
                        { "exchange/orders/history/{since}", 1.67 },
                        { "exchange/fills/{since}", 1.67 },
                        { "exchange/margin", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "jwt", 1 },
                        { "jwtDevice", 1 },
                        { "devices", 1 },
                        { "jwt-read-only", 1 },
                        { "exchange/orders/create", 1 },
                        { "exchange/orders/modify/{orderID}", 1 },
                        { "exchange/swap", 1 },
                        { "exchange/swap/confirm/{swapId}", 1 },
                        { "exchange/orders/close/{orderID}", 1 },
                        { "exchange/orders/hedge", 1 },
                    } },
                    { "put", new Dictionary<string, object>() {
                        { "jwt", 1 },
                        { "exchange/orders/cancel/{orderID}", 1 },
                        { "users/margin/collateral", 1 },
                        { "users/margin/primary/{currency}", 1 },
                    } },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", false },
                { "secret", false },
                { "uid", true },
                { "token", true },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "feeSide", "get" },
                    { "tierBased", false },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.001") },
                    { "maker", this.parseNumber("0") },
                } },
            } },
            { "precisionMode", DECIMAL_PLACES },
            { "options", new Dictionary<string, object>() {
                { "currenciesByIdForParseMarket", null },
                { "currencyIdsListForParseMarket", null },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "Both buyingCurrency and sellingCurrency are required", typeof(InvalidOrder) },
                    { "One and only one of buyingQty and sellingQty is required", typeof(InvalidOrder) },
                    { "Invalid buyingCurrency", typeof(InvalidOrder) },
                    { "Invalid \'from\'", typeof(BadRequest) },
                    { "Invalid sellingCurrency", typeof(InvalidOrder) },
                    { "Invalid buyingQty", typeof(InvalidOrder) },
                    { "Invalid sellingQty", typeof(InvalidOrder) },
                    { "Insufficient balance", typeof(InsufficientFunds) },
                    { "Expiration date is in the past or too near in the future", typeof(InvalidOrder) },
                    { "Forbidden", typeof(PermissionDenied) },
                    { "Order Not Found", typeof(OrderNotFound) },
                    { "since must be a millisecond timestamp", typeof(BadRequest) },
                    { "This pair is disabled on margin", typeof(BadSymbol) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "accessing from a new IP", typeof(PermissionDenied) },
                    { "available to allocate as collateral", typeof(InsufficientFunds) },
                    { "At least", typeof(BadRequest) },
                    { "collateral is not allowed", typeof(BadRequest) },
                    { "Insufficient liquidity", typeof(InvalidOrder) },
                    { "Insufficient order size", typeof(InvalidOrder) },
                    { "Invalid quantity", typeof(InvalidOrder) },
                    { "Invalid Stop Loss", typeof(InvalidOrder) },
                    { "Invalid stop price!", typeof(InvalidOrder) },
                    { "Not enough balance", typeof(InsufficientFunds) },
                    { "Not enough margin", typeof(InsufficientFunds) },
                    { "orderType missing", typeof(BadRequest) },
                    { "Server Timeout", typeof(ExchangeError) },
                    { "Time in force has to be IOC or FOK for market orders", typeof(InvalidOrder) },
                    { "Too many attempts", typeof(RateLimitExceeded) },
                } },
            } },
        });
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name coinmetro#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#d5876d43-a3fe-4479-8c58-24d0f044edfb
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetAssets(parameters);
        //
        //     [
        //         {
        //             "symbol": "BTC",
        //             "name": "Bitcoin",
        //             "color": "#FFA500",
        //             "type": "coin",
        //             "canDeposit": true,
        //             "canWithdraw": true,
        //             "canTrade": true,
        //             "notabeneDecimals": 8,
        //             "canMarket": true,
        //             "maxSwap": 10000,
        //             "digits": 6,
        //             "multiplier": 1000000,
        //             "bookDigits": 8,
        //             "bookMultiplier": 100000000,
        //             "sentimentData": {
        //                 "sentiment": 51.59555555555555,
        //                 "interest": 1.127511216044664
        //             },
        //             "minQty": 0.0001
        //         },
        //         {
        //             "symbol": "EUR",
        //             "name": "Euro",
        //             "color": "#1246FF",
        //             "type": "fiat",
        //             "canDeposit": true,
        //             "canWithdraw": true,
        //             "canTrade": true,
        //             "canMarket": true,
        //             "maxSwap": 10000,
        //             "digits": 2,
        //             "multiplier": 100,
        //             "bookDigits": 3,
        //             "bookMultiplier": 1000,
        //             "minQty": 5
        //         }
        //         ...
        //     ]
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object currency = getValue(response, i);
            object id = this.safeString(currency, "symbol");
            object code = this.safeCurrencyCode(id);
            object withdraw = this.safeValue(currency, "canWithdraw");
            object deposit = this.safeValue(currency, "canDeposit");
            object canTrade = this.safeValue(currency, "canTrade");
            object active = ((bool) isTrue(canTrade)) ? withdraw : true;
            object precision = this.safeInteger(currency, "digits");
            object minAmount = this.safeNumber(currency, "minQty");
            ((IDictionary<string,object>)result)[(string)code] = this.safeCurrencyStructure(new Dictionary<string, object>() {
                { "id", id },
                { "code", code },
                { "name", code },
                { "info", currency },
                { "active", active },
                { "deposit", deposit },
                { "withdraw", withdraw },
                { "fee", null },
                { "precision", precision },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", minAmount },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "networks", new Dictionary<string, object>() {} },
            });
        }
        if (isTrue(isEqual(this.safeValue(this.options, "currenciesByIdForParseMarket"), null)))
        {
            object currenciesById = this.indexBy(result, "id");
            ((IDictionary<string,object>)this.options)["currenciesByIdForParseMarket"] = currenciesById;
            ((IDictionary<string,object>)this.options)["currencyIdsListForParseMarket"] = new List<object>(((IDictionary<string,object>)currenciesById).Keys);
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name coinmetro#fetchMarkets
        * @description retrieves data on all markets for coinmetro
        * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#9fd18008-338e-4863-b07d-722878a46832
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetMarkets(parameters);
        if (isTrue(isEqual(this.safeValue(this.options, "currenciesByIdForParseMarket"), null)))
        {
            await this.fetchCurrencies();
        }
        //
        //     [
        //         {
        //             "pair": "PERPEUR",
        //             "precision": 5,
        //             "margin": false
        //         },
        //         {
        //             "pair": "PERPUSD",
        //             "precision": 5,
        //             "margin": false
        //         },
        //         {
        //             "pair": "YFIEUR",
        //             "precision": 5,
        //             "margin": false
        //         },
        //         ...
        //     ]
        //
        return this.parseMarkets(response);
    }

    public override object parseMarket(object market)
    {
        object id = this.safeString(market, "pair");
        object parsedMarketId = this.parseMarketId(id);
        object baseId = this.safeString(parsedMarketId, "baseId");
        object quoteId = this.safeString(parsedMarketId, "quoteId");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object basePrecisionAndLimits = this.parseMarketPrecisionAndLimits(baseId);
        object quotePrecisionAndLimits = this.parseMarketPrecisionAndLimits(quoteId);
        object margin = this.safeBool(market, "margin", false);
        object tradingFees = this.safeValue(this.fees, "trading", new Dictionary<string, object>() {});
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", id },
            { "symbol", add(add(bs, "/"), quote) },
            { "base", bs },
            { "quote", quote },
            { "settle", null },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", null },
            { "type", "spot" },
            { "spot", true },
            { "margin", margin },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "active", true },
            { "contract", false },
            { "linear", null },
            { "inverse", null },
            { "taker", this.safeNumber(tradingFees, "taker") },
            { "maker", this.safeNumber(tradingFees, "maker") },
            { "contractSize", null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", getValue(basePrecisionAndLimits, "precision") },
                { "price", getValue(quotePrecisionAndLimits, "precision") },
                { "base", getValue(basePrecisionAndLimits, "precision") },
                { "quote", getValue(quotePrecisionAndLimits, "precision") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", getValue(basePrecisionAndLimits, "minLimit") },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", getValue(quotePrecisionAndLimits, "minLimit") },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        });
    }

    public virtual object parseMarketId(object marketId)
    {
        object baseId = null;
        object quoteId = null;
        object currencyIds = this.safeValue(this.options, "currencyIdsListForParseMarket", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencyIds, i);
            object entryIndex = getIndexOf(marketId, currencyId);
            if (isTrue(!isEqual(entryIndex, -1)))
            {
                object restId = ((string)marketId).Replace((string)currencyId, (string)"");
                if (isTrue(this.inArray(restId, currencyIds)))
                {
                    if (isTrue(isEqual(entryIndex, 0)))
                    {
                        baseId = currencyId;
                        quoteId = restId;
                    } else
                    {
                        baseId = restId;
                        quoteId = currencyId;
                    }
                    break;
                }
            }
        }
        object result = new Dictionary<string, object>() {
            { "baseId", baseId },
            { "quoteId", quoteId },
        };
        return result;
    }

    public virtual object parseMarketPrecisionAndLimits(object currencyId)
    {
        object currencies = this.safeValue(this.options, "currenciesByIdForParseMarket", new Dictionary<string, object>() {});
        object currency = this.safeValue(currencies, currencyId, new Dictionary<string, object>() {});
        object precision = this.safeInteger(currency, "precision");
        object limits = this.safeValue(currency, "limits", new Dictionary<string, object>() {});
        object amountLimits = this.safeValue(limits, "amount", new Dictionary<string, object>() {});
        object minLimit = this.safeNumber(amountLimits, "min");
        object result = new Dictionary<string, object>() {
            { "precision", precision },
            { "minLimit", minLimit },
        };
        return result;
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinmetro#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#13cfb5bc-7bfb-4847-85e1-e0f35dfb3573
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch entries for
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
            { "timeframe", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        object until = null;
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = since;
            if (isTrue(!isEqual(limit, null)))
            {
                object duration = multiply(this.parseTimeframe(timeframe), 1000);
                until = this.sum(since, multiply(duration, (limit)));
            }
        } else
        {
            ((IDictionary<string,object>)request)["from"] = ":from"; // this endpoint doesn't accept empty from and to params (setting them into the value described in the documentation)
        }
        until = this.safeInteger(parameters, "until", until);
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)["to"] = until;
        } else
        {
            ((IDictionary<string,object>)request)["to"] = ":to";
        }
        object response = await this.publicGetExchangeCandlesPairTimeframeFromTo(this.extend(request, parameters));
        //
        //     {
        //         "candleHistory": [
        //             {
        //                 "pair": "ETHUSDT",
        //                 "timeframe": 86400000,
        //                 "timestamp": 1697673600000,
        //                 "c": 1567.4409353098604,
        //                 "h": 1566.7514068472303,
        //                 "l": 1549.4563666936847,
        //                 "o": 1563.4490341395904,
        //                 "v": 0
        //             },
        //             {
        //                 "pair": "ETHUSDT",
        //                 "timeframe": 86400000,
        //                 "timestamp": 1697760000000,
        //                 "c": 1603.7831363339324,
        //                 "h": 1625.0356823666407,
        //                 "l": 1565.4629390011505,
        //                 "o": 1566.8387619426028,
        //                 "v": 0
        //             },
        //             ...
        //         ]
        //     }
        //
        object candleHistory = this.safeList(response, "candleHistory", new List<object>() {});
        return this.parseOHLCVs(candleHistory, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        return new List<object> {this.safeInteger(ohlcv, "timestamp"), this.safeNumber(ohlcv, "o"), this.safeNumber(ohlcv, "h"), this.safeNumber(ohlcv, "l"), this.safeNumber(ohlcv, "c"), this.safeNumber(ohlcv, "v")};
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinmetro#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#6ee5d698-06da-4570-8c84-914185e05065
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch (default 200, max 500)
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = since;
        } else
        {
            // this endpoint accepts empty from param
            ((IDictionary<string,object>)request)["from"] = "";
        }
        object response = await this.publicGetExchangeTicksPairFrom(this.extend(request, parameters));
        //
        //     {
        //         "tickHistory": [
        //             {
        //                 "pair": "ETHUSDT",
        //                 "price": 2077.5623,
        //                 "qty": 0.002888,
        //                 "timestamp": 1700684689420,
        //                 "seqNum": 10644554718
        //             },
        //             {
        //                 "pair": "ETHUSDT",
        //                 "price": 2078.3848,
        //                 "qty": 0.003368,
        //                 "timestamp": 1700684738410,
        //                 "seqNum": 10644559561
        //             },
        //             {
        //                 "pair": "ETHUSDT",
        //                 "price": 2077.1513,
        //                 "qty": 0.00337,
        //                 "timestamp": 1700684816853,
        //                 "seqNum": 10644567113
        //             },
        //             ...
        //         ]
        //     }
        //
        object tickHistory = this.safeList(response, "tickHistory", new List<object>() {});
        return this.parseTrades(tickHistory, market, since, limit);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinmetro#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#4d48ae69-8ee2-44d1-a268-71f84e557b7b
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve (default 500, max 1000)
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["since"] = since;
        } else
        {
            // the exchange requires a value for the since param
            ((IDictionary<string,object>)request)["since"] = 0;
        }
        object response = await this.privateGetExchangeFillsSince(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "pair": "ETHUSDC",
        //             "seqNumber": 10873722343,
        //             "timestamp": 1702570610747,
        //             "qty": 0.002,
        //             "price": 2282,
        //             "side": "buy",
        //             "orderID": "65671262d93d9525ac009e36170257061073952c6423a8c5b4d6c"
        //         },
        //         ...
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades
        //     {
        //         "pair": "ETHUSDT",
        //         "price": 2077.1513,
        //         "qty": 0.00337,
        //         "timestamp": 1700684816853,
        //         "seqNum": 10644567113
        //     },
        //
        // fetchMyTrades
        //     {
        //         "pair": "ETHUSDC",
        //         "seqNumber": 10873722343,
        //         "timestamp": 1702570610747,
        //         "qty": 0.002,
        //         "price": 2282,
        //         "side": "buy",
        //         "orderID": "65671262d93d9525ac009e36170257061073952c6423a8c5b4d6c"
        //     }
        //
        // fetchOrders
        //     {
        //         "_id": "657b31d360a9542449381bdc",
        //         "seqNumber": 10873722343,
        //         "timestamp": 1702570610747,
        //         "qty": 0.002,
        //         "price": 2282,
        //         "side": "buy"
        //     }
        //
        //    {
        //        "pair":"ETHUSDC",
        //        "seqNumber":"10873722343",
        //        "timestamp":"1702570610747",
        //        "qty":"0.002",
        //        "price":"2282",
        //        "side":"buy",
        //        "orderID":"65671262d93d9525ac009e36170257061073952c6423a8c5b4d6c",
        //        "userID":"65671262d93d9525ac009e36"
        //     }
        //
        object marketId = this.safeString2(trade, "symbol", "pair");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object id = this.safeStringN(trade, new List<object>() {"_id", "seqNum", "seqNumber"});
        object timestamp = this.safeInteger(trade, "timestamp");
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString(trade, "qty");
        object order = this.safeString(trade, "orderID");
        object side = this.safeString(trade, "side");
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "order", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", null },
            { "side", side },
            { "takerOrMaker", null },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "fee", null },
            { "info", trade },
        }, market);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinmetro#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#26ad80d7-8c46-41b5-9208-386f439a8b87
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return (default 100, max 200)
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        object response = await this.publicGetExchangeBookPair(this.extend(request, parameters));
        //
        //     {
        //         "book": {
        //             "pair": "ETHUSDT",
        //             "seqNumber": 10800409239,
        //             "ask": {
        //                 "2354.2861": 3.75,
        //                 "2354.3138": 19,
        //                 "2354.7538": 80,
        //                 "2355.5430": 260,
        //                 "2356.4611": 950,
        //                 "2361.7150": 1500,
        //                 "206194.0000": 0.01
        //             },
        //             "bid": {
        //                 "2352.6339": 3.75,
        //                 "2352.6002": 19,
        //                 "2352.2402": 80,
        //                 "2351.4582": 260,
        //                 "2349.3111": 950,
        //                 "2343.8601": 1500,
        //                 "1.0000": 5
        //             },
        //             "checksum": 2108177337
        //         }
        //     }
        //
        object book = this.safeValue(response, "book", new Dictionary<string, object>() {});
        object rawBids = this.safeValue(book, "bid", new Dictionary<string, object>() {});
        object rawAsks = this.safeValue(book, "ask", new Dictionary<string, object>() {});
        object rawOrderbook = new Dictionary<string, object>() {
            { "bids", rawBids },
            { "asks", rawAsks },
        };
        object orderbook = this.parseOrderBook(rawOrderbook, symbol);
        ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger(book, "seqNumber");
        return orderbook;
    }

    public override object parseBidsAsks(object bidasks, object priceKey = null, object amountKey = null, object countOrIdKey = null)
    {
        priceKey ??= 0;
        amountKey ??= 1;
        countOrIdKey ??= 2;
        object prices = new List<object>(((IDictionary<string,object>)bidasks).Keys);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(prices)); postFixIncrement(ref i))
        {
            object priceString = this.safeString(prices, i);
            object price = this.safeNumber(prices, i);
            object volume = this.safeNumber(bidasks, priceString);
            ((IList<object>)result).Add(new List<object>() {price, volume});
        }
        return result;
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinmetro#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#6ecd1cd1-f162-45a3-8b3b-de690332a485
        * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetExchangePrices(parameters);
        //
        //     {
        //         "latestPrices": [
        //             {
        //                 "pair": "PERPEUR",
        //                 "timestamp": 1702549840393,
        //                 "price": 0.7899997816001223,
        //                 "qty": 1e-12,
        //                 "ask": 0.8,
        //                 "bid": 0.7799995632002446
        //             },
        //             {
        //                 "pair": "PERPUSD",
        //                 "timestamp": 1702549841973,
        //                 "price": 0.8615317721366659,
        //                 "qty": 1e-12,
        //                 "ask": 0.8742333599999257,
        //                 "bid": 0.8490376365388491
        //             },
        //             ...
        //         ],
        //         "24hInfo": [
        //             {
        //                 "delta": 0.25396444229149906,
        //                 "h": 0.78999978160012,
        //                 "l": 0.630001740844,
        //                 "v": 54.910000002833996,
        //                 "pair": "PERPEUR",
        //                 "sentimentData": {
        //                     "sentiment": 36.71333333333333,
        //                     "interest": 0.47430830039525695
        //                     }
        //                 },
        //             {
        //                 "delta": 0.26915154078134096,
        //                 "h": 0.86220315458898,
        //                 "l": 0.67866757035154,
        //                 "v": 2.835000000000001e-9,
        //                 "pair": "PERPUSD",
        //                 "sentimentData": {
        //                     "sentiment": 36.71333333333333,
        //                     "interest": 0.47430830039525695
        //                 }
        //             },
        //             ...
        //         ]
        //     }
        //
        object latestPrices = this.safeValue(response, "latestPrices", new List<object>() {});
        object twentyFourHInfos = this.safeValue(response, "24hInfo", new List<object>() {});
        object tickersObject = new Dictionary<string, object>() {};
        // merging info from two lists into one
        for (object i = 0; isLessThan(i, getArrayLength(latestPrices)); postFixIncrement(ref i))
        {
            object latestPrice = getValue(latestPrices, i);
            object marketId = this.safeString(latestPrice, "pair");
            if (isTrue(!isEqual(marketId, null)))
            {
                ((IDictionary<string,object>)tickersObject)[(string)marketId] = latestPrice;
            }
        }
        for (object i = 0; isLessThan(i, getArrayLength(twentyFourHInfos)); postFixIncrement(ref i))
        {
            object twentyFourHInfo = getValue(twentyFourHInfos, i);
            object marketId = this.safeString(twentyFourHInfo, "pair");
            if (isTrue(!isEqual(marketId, null)))
            {
                object latestPrice = this.safeValue(tickersObject, marketId, new Dictionary<string, object>() {});
                ((IDictionary<string,object>)tickersObject)[(string)marketId] = this.extend(twentyFourHInfo, latestPrice);
            }
        }
        object tickers = new List<object>(((IDictionary<string,object>)tickersObject).Values);
        return this.parseTickers(tickers, symbols);
    }

    public async override Task<object> fetchBidsAsks(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinmetro#fetchBidsAsks
        * @description fetches the bid and ask price and volume for multiple markets
        * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#6ecd1cd1-f162-45a3-8b3b-de690332a485
        * @param {string[]} [symbols] unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetExchangePrices(parameters);
        object latestPrices = this.safeList(response, "latestPrices", new List<object>() {});
        return this.parseTickers(latestPrices, symbols);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "pair": "PERPUSD",
        //         "timestamp": 1702549841973,
        //         "price": 0.8615317721366659,
        //         "qty": 1e-12,
        //         "ask": 0.8742333599999257,
        //         "bid": 0.8490376365388491
        //         "delta": 0.26915154078134096,
        //         "h": 0.86220315458898,
        //         "l": 0.67866757035154,
        //         "v": 2.835000000000001e-9,
        //         "sentimentData": {
        //             "sentiment": 36.71333333333333,
        //             "interest": 0.47430830039525695
        //         }
        //     }
        //
        object marketId = this.safeString(ticker, "pair");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(ticker, "timestamp");
        object bid = this.safeString(ticker, "bid");
        object ask = this.safeString(ticker, "ask");
        object high = this.safeString(ticker, "h");
        object low = this.safeString(ticker, "l");
        object last = this.safeString(ticker, "price");
        object baseVolume = this.safeString(ticker, "v");
        object delta = this.safeString(ticker, "delta");
        object percentage = Precise.stringMul(delta, "100");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "open", null },
            { "high", high },
            { "low", low },
            { "close", null },
            { "last", last },
            { "bid", bid },
            { "bidVolume", null },
            { "ask", ask },
            { "askVolume", null },
            { "vwap", null },
            { "previousClose", null },
            { "change", null },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name coinmetro#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#741a1dcc-7307-40d0-acca-28d003d1506a
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetUsersWallets(parameters);
        object list = this.safeList(response, "list", new List<object>() {});
        return this.parseBalance(list);
    }

    public override object parseBalance(object balances)
    {
        //
        //     [
        //         {
        //             "xcmLocks": [],
        //             "xcmLockAmounts": [],
        //             "refList": [],
        //             "balanceHistory": [],
        //             "_id": "5fecd3c998e75c2e4d63f7c3",
        //             "currency": "BTC",
        //             "label": "BTC",
        //             "userId": "5fecd3c97fbfed1521db23bd",
        //             "__v": 0,
        //             "balance": 0.5,
        //             "createdAt": "2020-12-30T19:23:53.646Z",
        //             "disabled": false,
        //             "updatedAt": "2020-12-30T19:23:53.653Z",
        //             "reserved": 0,
        //             "id": "5fecd3c998e75c2e4d63f7c3"
        //         },
        //         ...
        //     ]
        //
        object result = new Dictionary<string, object>() {
            { "info", balances },
        };
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balanceEntry = this.safeDict(balances, i, new Dictionary<string, object>() {});
            object currencyId = this.safeString(balanceEntry, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(balanceEntry, "balance");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balanceEntry, "reserved");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinmetro#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#4e7831f7-a0e7-4c3e-9336-1d0e5dcb15cf
        * @param {string} code unified currency code, default is undefined
        * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int} [limit] max number of ledger entrys to return (default 200, max 500)
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch entries for
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["since"] = since;
        } else
        {
            // this endpoint accepts empty since param
            ((IDictionary<string,object>)request)["since"] = "";
        }
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object response = await this.privateGetUsersWalletsHistorySince(this.extend(request, parameters));
        //
        //     {
        //         "list": [
        //             {
        //                 "currency": "USDC",
        //                 "label": "USDC",
        //                 "userId": "65671262d93d9525ac009e36",
        //                 "balance": 0,
        //                 "disabled": false,
        //                 "balanceHistory": [
        //                     {
        //                         "description": "Deposit - 657973a9b6eadf0f33d70100",
        //                         "JSONdata": {
        //                             "fees": 0,
        //                             "notes": "Via Crypto",
        //                             "txHash": "0x2e4875185b0f312d8e24b2d26d46bf9877db798b608ad2ff97b2b8bc7d8134e5",
        //                             "last4Digits": null,
        //                             "IBAN": null,
        //                             "alternativeChain": "polygon",
        //                             "referenceId": "657973a9b6eadf0f33d70100",
        //                             "status": "completed",
        //                             "tracked": true
        //                         },
        //                         "amount": 99,
        //                         "timestamp": "2023-12-13T09:04:51.270Z",
        //                         "amountEUR": 91.79310117335974
        //                     },
        //                     {
        //                         "description": "Order 65671262d93d9525ac009e36170257061073952c6423a8c5b4d6c SeqNum 10873722342",
        //                         "JSONdata": {
        //                             "price": "2282.00 ETH/USDC",
        //                             "fees": 0,
        //                             "notes": "Order 3a8c5b4d6c"
        //                         },
        //                         "amount": -4.564,
        //                         "timestamp": "2023-12-14T16:16:50.760Z",
        //                         "amountEUR": -4.150043849187587
        //                     },
        //                     ...
        //                 ]
        //             },
        //             {
        //                 "currency": "ETH",
        //                 "label": "ETH",
        //                 "userId": "65671262d93d9525ac009e36",
        //                 "balance": 0,
        //                 "disabled": false,
        //                 "balanceHistory": [
        //                     {
        //                         "description": "Order 65671262d93d9525ac009e36170257061073952c6423a8c5b4d6c SeqNum 10873722342",
        //                         "JSONdata": {
        //                             "price": "2282.00 ETH/USDC",
        //                             "fees": 0.000002,
        //                             "notes": "Order 3a8c5b4d6c"
        //                         },
        //                         "amount": 0.001998,
        //                         "timestamp": "2023-12-14T16:16:50.761Z",
        //                         "amountEUR": 4.144849415806856
        //                     },
        //                     ...
        //                 ]
        //             },
        //             {
        //                 "currency": "DOGE",
        //                 "label": "DOGE",
        //                 "userId": "65671262d93d9525ac009e36",
        //                 "balance": 0,
        //                 "disabled": false,
        //                 "balanceHistory": [
        //                     {
        //                         "description": "Order 65671262d93d9525ac009e361702905785319b5d9016dc20736034d13ca6a - Swap",
        //                         "JSONdata": {
        //                             "swap": true,
        //                             "subtype": "swap",
        //                             "fees": 0,
        //                             "price": "0.0905469 DOGE/USDC",
        //                             "notes": "Swap 034d13ca6a"
        //                         },
        //                         "amount": 70,
        //                         "timestamp": "2023-12-18T13:23:05.836Z",
        //                         "amountEUR": 5.643627624549227
        //                     }
        //                 ]
        //             },
        //             ...
        //         ]
        //     }
        //
        object ledgerByCurrencies = this.safeValue(response, "list", new List<object>() {});
        object ledger = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ledgerByCurrencies)); postFixIncrement(ref i))
        {
            object currencyLedger = getValue(ledgerByCurrencies, i);
            object currencyId = this.safeString(currencyLedger, "currency");
            object balanceHistory = this.safeValue(currencyLedger, "balanceHistory", new List<object>() {});
            for (object j = 0; isLessThan(j, getArrayLength(balanceHistory)); postFixIncrement(ref j))
            {
                object rawLedgerEntry = getValue(balanceHistory, j);
                ((IDictionary<string,object>)rawLedgerEntry)["currencyId"] = currencyId;
                ((IList<object>)ledger).Add(rawLedgerEntry);
            }
        }
        return this.parseLedger(ledger, currency, since, limit);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        object datetime = this.safeString(item, "timestamp");
        object currencyId = this.safeString(item, "currencyId");
        item = this.omit(item, "currencyId");
        currency = this.safeCurrency(currencyId, currency);
        object description = this.safeString(item, "description", "");
        var typereferenceIdVariable = this.parseLedgerEntryDescription(description);
        var type = ((IList<object>) typereferenceIdVariable)[0];
        var referenceId = ((IList<object>) typereferenceIdVariable)[1];
        object JSONdata = this.safeValue(item, "JSONdata", new Dictionary<string, object>() {});
        object feeCost = this.safeString(JSONdata, "fees");
        object fee = new Dictionary<string, object>() {
            { "cost", feeCost },
            { "currency", null },
        };
        object amount = this.safeString(item, "amount");
        object direction = null;
        if (isTrue(!isEqual(amount, null)))
        {
            if (isTrue(Precise.stringLt(amount, "0")))
            {
                direction = "out";
                amount = Precise.stringAbs(amount);
            } else if (isTrue(Precise.stringGt(amount, "0")))
            {
                direction = "in";
            }
        }
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", null },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "direction", direction },
            { "account", null },
            { "referenceId", referenceId },
            { "referenceAccount", null },
            { "type", type },
            { "currency", currency },
            { "amount", amount },
            { "before", null },
            { "after", null },
            { "status", null },
            { "fee", fee },
        }, currency);
    }

    public virtual object parseLedgerEntryDescription(object description)
    {
        object descriptionArray = new List<object>() {};
        if (isTrue(!isEqual(description, null)))
        {
            descriptionArray = ((string)description).Split(new [] {((string)" ")}, StringSplitOptions.None).ToList<object>();
        }
        object type = null;
        object referenceId = null;
        object length = getArrayLength(descriptionArray);
        if (isTrue(isGreaterThan(length, 1)))
        {
            type = this.parseLedgerEntryType(getValue(descriptionArray, 0));
            if (isTrue(!isEqual(getValue(descriptionArray, 1), "-")))
            {
                referenceId = getValue(descriptionArray, 1);
            } else
            {
                referenceId = this.safeString(descriptionArray, 2);
            }
        }
        return new List<object>() {type, referenceId};
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "Deposit", "transaction" },
            { "Withdraw", "transaction" },
            { "Order", "trade" },
        };
        return this.safeString(types, type, type);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name coinmetro#createOrder
        * @description create a trade order
        * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#a4895a1d-3f50-40ae-8231-6962ef06c771
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.cost] the quote quantity that can be used as an alternative for the amount in market orders
        * @param {string} [params.timeInForce] "GTC", "IOC", "FOK", "GTD"
        * @param {number} [params.expirationTime] timestamp in millisecond, for GTD orders only
        * @param {float} [params.triggerPrice] the price at which a trigger order is triggered at
        * @param {float} [params.stopLossPrice] *margin only* The price at which a stop loss order is triggered at
        * @param {float} [params.takeProfitPrice] *margin only* The price at which a take profit order is triggered at
        * @param {bool} [params.margin] true for creating a margin order
        * @param {string} [params.fillStyle] fill style of the limit order: "sell" fulfills selling quantity "buy" fulfills buying quantity "base" fulfills base currency quantity "quote" fulfills quote currency quantity
        * @param {string} [params.clientOrderId] client's comment
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        ((IDictionary<string,object>)request)["orderType"] = type;
        object precisedAmount = null;
        if (isTrue(!isEqual(amount, null)))
        {
            precisedAmount = this.amountToPrecision(symbol, amount);
        }
        object cost = this.safeValue(parameters, "cost");
        parameters = this.omit(parameters, "cost");
        if (isTrue(isEqual(type, "limit")))
        {
            if (isTrue(isTrue((isEqual(price, null))) && isTrue((isEqual(cost, null)))))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " createOrder() requires a price or params.cost argument for a "), type), " order")) ;
            } else if (isTrue(isTrue((!isEqual(price, null))) && isTrue((!isEqual(amount, null)))))
            {
                object costString = Precise.stringMul(this.numberToString(price), this.numberToString(precisedAmount));
                cost = this.parseToNumeric(costString);
            }
        }
        object precisedCost = null;
        if (isTrue(!isEqual(cost, null)))
        {
            precisedCost = this.costToPrecision(symbol, cost);
        }
        if (isTrue(isEqual(side, "sell")))
        {
            request = this.handleCreateOrderSide(getValue(market, "baseId"), getValue(market, "quoteId"), precisedAmount, precisedCost, request);
        } else if (isTrue(isEqual(side, "buy")))
        {
            request = this.handleCreateOrderSide(getValue(market, "quoteId"), getValue(market, "baseId"), precisedCost, precisedAmount, request);
        }
        object timeInForce = this.safeValue(parameters, "timeInForce");
        if (isTrue(!isEqual(timeInForce, null)))
        {
            parameters = this.omit(parameters, "timeInForce");
            ((IDictionary<string,object>)request)["timeInForce"] = this.encodeOrderTimeInForce(timeInForce);
        }
        object stopPrice = this.safeString2(parameters, "triggerPrice", "stopPrice");
        if (isTrue(!isEqual(stopPrice, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"triggerPrice"});
            ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, stopPrice);
        }
        object userData = this.safeValue(parameters, "userData", new Dictionary<string, object>() {});
        object comment = this.safeString2(parameters, "clientOrderId", "comment");
        if (isTrue(!isEqual(comment, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"clientOrderId"});
            ((IDictionary<string,object>)userData)["comment"] = comment;
        }
        object stopLossPrice = this.safeString(parameters, "stopLossPrice");
        if (isTrue(!isEqual(stopLossPrice, null)))
        {
            parameters = this.omit(parameters, "stopLossPrice");
            ((IDictionary<string,object>)userData)["stopLoss"] = this.priceToPrecision(symbol, stopLossPrice);
        }
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        if (isTrue(!isEqual(takeProfitPrice, null)))
        {
            parameters = this.omit(parameters, "takeProfitPrice");
            ((IDictionary<string,object>)userData)["takeProfit"] = this.priceToPrecision(symbol, takeProfitPrice);
        }
        if (!isTrue(this.isEmpty(userData)))
        {
            ((IDictionary<string,object>)request)["userData"] = userData;
        }
        object response = await this.privatePostExchangeOrdersCreate(this.extend(request, parameters));
        //
        //     {
        //         "userID": "65671262d93d9525ac009e36",
        //         "orderID": "65671262d93d9525ac009e36170257448481749b7ee2893bafec2",
        //         "orderType": "market",
        //         "buyingCurrency": "ETH",
        //         "sellingCurrency": "USDC",
        //         "buyingQty": 0.002,
        //         "timeInForce": 4,
        //         "boughtQty": 0.002,
        //         "soldQty": 4.587,
        //         "creationTime": 1702574484829,
        //         "seqNumber": 10874285330,
        //         "firstFillTime": 1702574484831,
        //         "lastFillTime": 1702574484831,
        //         "fills": [
        //             {
        //                 "seqNumber": 10874285329,
        //                 "timestamp": 1702574484831,
        //                 "qty": 0.002,
        //                 "price": 2293.5,
        //                 "side": "buy"
        //             }
        //         ],
        //         "completionTime": 1702574484831,
        //         "takerQty": 0.002
        //     }
        //
        return this.parseOrder(response, market);
    }

    public virtual object handleCreateOrderSide(object sellingCurrency, object buyingCurrency, object sellingQty, object buyingQty, object request = null)
    {
        request ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)request)["sellingCurrency"] = sellingCurrency;
        ((IDictionary<string,object>)request)["buyingCurrency"] = buyingCurrency;
        if (isTrue(!isEqual(sellingQty, null)))
        {
            ((IDictionary<string,object>)request)["sellingQty"] = sellingQty;
        }
        if (isTrue(!isEqual(buyingQty, null)))
        {
            ((IDictionary<string,object>)request)["buyingQty"] = buyingQty;
        }
        return request;
    }

    public virtual object encodeOrderTimeInForce(object timeInForce)
    {
        object timeInForceTypes = new Dictionary<string, object>() {
            { "GTC", 1 },
            { "IOC", 2 },
            { "GTD", 3 },
            { "FOK", 4 },
        };
        return this.safeValue(timeInForceTypes, timeInForce, timeInForce);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinmetro#cancelOrder
        * @description cancels an open order
        * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#eaea86da-16ca-4c56-9f00-5b1cb2ad89f8
        * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#47f913fb-8cab-49f4-bc78-d980e6ced316
        * @param {string} id order id
        * @param {string} symbol not used by coinmetro cancelOrder ()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.margin] true for cancelling a margin order
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderID", id },
        };
        object marginMode = null;
        var parametersparametersVariable = this.handleMarginModeAndParams("cancelOrder", parameters);
        parameters = ((IList<object>)parametersparametersVariable)[0];
        parameters = ((IList<object>)parametersparametersVariable)[1];
        object isMargin = this.safeBool(parameters, "margin", false);
        parameters = this.omit(parameters, "margin");
        object response = null;
        if (isTrue(isTrue(isMargin) || isTrue((!isEqual(marginMode, null)))))
        {
            response = await this.privatePostExchangeOrdersCloseOrderID(this.extend(request, parameters));
        } else
        {
            response = await this.privatePutExchangeOrdersCancelOrderID(this.extend(request, parameters));
        }
        //
        //     {
        //         "userID": "65671262d93d9525ac009e36",
        //         "orderID": "65671262d93d9525ac009e3617026635256739c996fe17d7cd5d4",
        //         "orderType": "limit",
        //         "buyingCurrency": "ETH",
        //         "sellingCurrency": "USDC",
        //         "fillStyle": "sell",
        //         "orderPlatform": "trade-v3",
        //         "timeInForce": 1,
        //         "buyingQty": 0.005655,
        //         "sellingQty": 11.31,
        //         "boughtQty": 0,
        //         "soldQty": 0,
        //         "creationTime": 1702663525713,
        //         "seqNumber": 10915220048,
        //         "completionTime": 1702928369053
        //     }
        //
        return this.parseOrder(response);
    }

    public async override Task<object> closePosition(object symbol, object side = null, object parameters = null)
    {
        /**
        * @method
        * @name coinmetro#cancelOrder
        * @description closes an open position
        * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#47f913fb-8cab-49f4-bc78-d980e6ced316
        * @param {string} symbol not used by coinmetro closePosition ()
        * @param {string} [side] not used by coinmetro closePosition ()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.orderID] order id
        * @param {number} [params.fraction] fraction of order to close, between 0 and 1 (defaults to 1)
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orderId = this.safeString(parameters, "orderId");
        if (isTrue(isEqual(orderId, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " closePosition() requires a orderId parameter")) ;
        }
        object request = new Dictionary<string, object>() {
            { "orderID", orderId },
        };
        object response = await this.privatePostExchangeOrdersCloseOrderID(this.extend(request, parameters));
        //
        //     {
        //         "userID": "65671262d93d9525ac009e36",
        //         "orderID": "65671262d93d9525ac009e3617030152811996e5b352556d3d7d8_CL",
        //         "orderType": "market",
        //         "buyingCurrency": "ETH",
        //         "sellingCurrency": "EUR",
        //         "margin": true,
        //         "buyingQty": 0.03,
        //         "timeInForce": 4,
        //         "boughtQty": 0.03,
        //         "soldQty": 59.375,
        //         "creationTime": 1703015488482,
        //         "seqNumber": 10925321179,
        //         "firstFillTime": 1703015488483,
        //         "lastFillTime": 1703015488483,
        //         "fills": [
        //             {
        //                 "seqNumber": 10925321178,
        //                 "timestamp": 1703015488483,
        //                 "qty": 0.03,
        //                 "price": 1979.1666666666667,
        //                 "side": "buy"
        //             }
        //         ],
        //         "completionTime": 1703015488483,
        //         "takerQty": 0.03
        //     }
        //
        return this.parseOrder(response);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinmetro#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#518afd7a-4338-439c-a651-d4fdaa964138
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of open order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object response = await this.privateGetExchangeOrdersActive(parameters);
        object orders = this.parseOrders(response, market, since, limit);
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object order = getValue(orders, i);
            ((IDictionary<string,object>)order)["status"] = "open";
        }
        return orders;
    }

    public async override Task<object> fetchCanceledAndClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinmetro#fetchCanceledAndClosedOrders
        * @description fetches information on multiple canceled and closed orders made by the user
        * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#4d48ae69-8ee2-44d1-a268-71f84e557b7b
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["since"] = since;
        }
        object response = await this.privateGetExchangeOrdersHistorySince(this.extend(request, parameters));
        return this.parseOrders(response, market, since, limit);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinmetro#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#95bbed87-db1c-47a7-a03e-aa247e91d5a6
        * @param {int|string} id order id
        * @param {string} symbol not used by coinmetro fetchOrder ()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderID", id },
        };
        object response = await this.privateGetExchangeOrdersStatusOrderID(this.extend(request, parameters));
        //
        //     {
        //         "_id": "657b4e6d60a954244939ac6f",
        //         "userID": "65671262d93d9525ac009e36",
        //         "orderID": "65671262d93d9525ac009e361702576531985b78465468b9cc544",
        //         "orderType": "market",
        //         "buyingCurrency": "ETH",
        //         "sellingCurrency": "USDC",
        //         "buyingQty": 0.004,
        //         "timeInForce": 4,
        //         "boughtQty": 0.004,
        //         "soldQty": 9.236,
        //         "creationTime": 1702576531995,
        //         "seqNumber": 10874644062,
        //         "firstFillTime": 1702576531995,
        //         "lastFillTime": 1702576531995,
        //         "fills": [
        //             {
        //                 "_id": "657b4e6d60a954244939ac70",
        //                 "seqNumber": 10874644061,
        //                 "timestamp": 1702576531995,
        //                 "qty": 0.004,
        //                 "price": 2309,
        //                 "side": "buy"
        //             }
        //         ],
        //         "completionTime": 1702576531995,
        //         "takerQty": 0.004,
        //         "fees": 0.000004,
        //         "isAncillary": false,
        //         "margin": false,
        //         "trade": false,
        //         "canceled": false
        //     }
        //
        return this.parseOrder(response);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder market
        //     {
        //         "userID": "65671262d93d9525ac009e36",
        //         "orderID": "65671262d93d9525ac009e36170257448481749b7ee2893bafec2",
        //         "orderType": "market",
        //         "buyingCurrency": "ETH",
        //         "sellingCurrency": "USDC",
        //         "buyingQty": 0.002,
        //         "timeInForce": 4,
        //         "boughtQty": 0.002,
        //         "soldQty": 4.587,
        //         "creationTime": 1702574484829,
        //         "seqNumber": 10874285330,
        //         "firstFillTime": 1702574484831,
        //         "lastFillTime": 1702574484831,
        //         "fills": [
        //             {
        //                 "seqNumber": 10874285329,
        //                 "timestamp": 1702574484831,
        //                 "qty": 0.002,
        //                 "price": 2293.5,
        //                 "side": "buy"
        //             }
        //         ],
        //         "completionTime": 1702574484831,
        //         "takerQty": 0.002
        //     }
        //
        // createOrder limit
        //     {
        //         "userID": "65671262d93d9525ac009e36",
        //         "orderID": "65671262d93d9525ac009e3617026635256739c996fe17d7cd5d4",
        //         "orderType": "limit",
        //         "buyingCurrency": "ETH",
        //         "sellingCurrency": "USDC",
        //         "fillStyle": "sell",
        //         "orderPlatform": "trade-v3",
        //         "timeInForce": 1,
        //         "buyingQty": 0.005655,
        //         "sellingQty": 11.31,
        //         "boughtQty": 0,
        //         "soldQty": 0,
        //         "creationTime": 1702663525713,
        //         "seqNumber": 10885528683,
        //         "fees": 0,
        //         "fills": [],
        //         "isAncillary": false,
        //         "margin": false,
        //         "trade": false
        //     }
        //
        // fetchOrders market
        //     {
        //         "userID": "65671262d93d9525ac009e36",
        //         "orderID": "65671262d93d9525ac009e36170257061073952c6423a8c5b4d6c",
        //         "orderType": "market",
        //         "buyingCurrency": "ETH",
        //         "sellingCurrency": "USDC",
        //         "buyingQty": 0.002,
        //         "timeInForce": 4,
        //         "boughtQty": 0.002,
        //         "soldQty": 4.564,
        //         "creationTime": 1702570610746,
        //         "seqNumber": 10873722344,
        //         "firstFillTime": 1702570610747,
        //         "lastFillTime": 1702570610747,
        //         "fills": [
        //             {
        //                 "_id": "657b31d360a9542449381bdc",
        //                 "seqNumber": 10873722343,
        //                 "timestamp": 1702570610747,
        //                 "qty": 0.002,
        //                 "price": 2282,
        //                 "side": "buy"
        //             }
        //         ],
        //         "completionTime": 1702570610747,
        //         "takerQty": 0.002,
        //         "fees": 0.000002,
        //         "isAncillary": false,
        //         "margin": false,
        //         "trade": false,
        //         "canceled": false,
        //         "__v": 0
        //     }
        //
        // fetchOrders margin
        //     {
        //         "userData": {
        //             "takeProfit": 1700,
        //             "stopLoss": 2100
        //         },
        //         "_id": "658201d060a95424499394a2",
        //         "seqNumber": 10925300213,
        //         "orderType": "limit",
        //         "buyingCurrency": "EUR",
        //         "sellingCurrency": "ETH",
        //         "userID": "65671262d93d9525ac009e36",
        //         "closedQty": 0.03,
        //         "sellingQty": 0.03,
        //         "buyingQty": 58.8,
        //         "creationTime": 1703015281205,
        //         "margin": true,
        //         "timeInForce": 1,
        //         "boughtQty": 59.31,
        //         "orderID": "65671262d93d9525ac009e3617030152811996e5b352556d3d7d8",
        //         "lastFillTime": 1703015281206,
        //         "soldQty": 0.03,
        //         "closedTime": 1703015488488,
        //         "closedVal": 59.375,
        //         "trade": true,
        //         "takerQty": 59.31,
        //         "firstFillTime": 1703015281206,
        //         "completionTime": 1703015281206,
        //         "fills": [
        //             {
        //                 "_id": "658201d060a95424499394a3",
        //                 "seqNumber": 10925300212,
        //                 "side": "sell",
        //                 "price": 1977,
        //                 "qty": 0.03,
        //                 "timestamp": 1703015281206
        //             },
        //             {
        //                 "_id": "658201d060a95424499394a4",
        //                 "seqNumber": 10925321178,
        //                 "timestamp": 1703015488483,
        //                 "qty": 0.03,
        //                 "price": 1979.1666666666667,
        //                 "side": "buy"
        //             }
        //         ],
        //         "fees": 0.11875000200000001,
        //         "settledQtys": {
        //             "ETH": -0.000092842104710025
        //         },
        //         "isAncillary": false,
        //         "canceled": false
        //     }
        //
        // fetchOrder
        //     {
        //         "_id": "657b4e6d60a954244939ac6f",
        //         "userID": "65671262d93d9525ac009e36",
        //         "orderID": "65671262d93d9525ac009e361702576531985b78465468b9cc544",
        //         "orderType": "market",
        //         "buyingCurrency": "ETH",
        //         "sellingCurrency": "USDC",
        //         "buyingQty": 0.004,
        //         "timeInForce": 4,
        //         "boughtQty": 0.004,
        //         "soldQty": 9.236,
        //         "creationTime": 1702576531995,
        //         "seqNumber": 10874644062,
        //         "firstFillTime": 1702576531995,
        //         "lastFillTime": 1702576531995,
        //         "fills": [
        //             {
        //                 "_id": "657b4e6d60a954244939ac70",
        //                 "seqNumber": 10874644061,
        //                 "timestamp": 1702576531995,
        //                 "qty": 0.004,
        //                 "price": 2309,
        //                 "side": "buy"
        //             }
        //         ],
        //         "completionTime": 1702576531995,
        //         "takerQty": 0.004,
        //         "fees": 0.000004,
        //         "isAncillary": false,
        //         "margin": false,
        //         "trade": false,
        //         "canceled": false
        //     }
        //
        object timestamp = this.safeInteger(order, "creationTime");
        object isCanceled = this.safeValue(order, "canceled");
        object status = null;
        if (isTrue(isEqual(isCanceled, true)))
        {
            if (isTrue(isEqual(timestamp, null)))
            {
                timestamp = this.safeInteger(order, "completionTime"); // market orders with bad price gain IOC - we mark them as 'rejected'?
                status = "rejected"; // these orders don't have the 'creationTime` param and have 'canceled': true
            } else
            {
                status = "canceled";
            }
        } else
        {
            status = this.safeString(order, "status");
            order = this.omit(order, "status"); // we mark orders from fetchOpenOrders with param 'status': 'open'
        }
        object type = this.safeString(order, "orderType");
        object buyingQty = this.safeString(order, "buyingQty");
        object sellingQty = this.safeString(order, "sellingQty");
        object boughtQty = this.safeString(order, "boughtQty");
        object soldQty = this.safeString(order, "soldQty");
        if (isTrue(isEqual(type, "market")))
        {
            if (isTrue(isTrue(isTrue((isEqual(buyingQty, null))) && isTrue((!isEqual(boughtQty, null)))) && isTrue((!isEqual(boughtQty, "0")))))
            {
                buyingQty = boughtQty;
            }
            if (isTrue(isTrue(isTrue((isEqual(sellingQty, null))) && isTrue((!isEqual(soldQty, null)))) && isTrue((!isEqual(soldQty, "0")))))
            {
                sellingQty = soldQty;
            }
        }
        object buyingCurrencyId = this.safeString(order, "buyingCurrency", "");
        object sellingCurrencyId = this.safeString(order, "sellingCurrency", "");
        object byuingIdPlusSellingId = add(buyingCurrencyId, sellingCurrencyId);
        object sellingIdPlusBuyingId = add(sellingCurrencyId, buyingCurrencyId);
        object side = null;
        object marketId = null;
        object baseAmount = buyingQty;
        object quoteAmount = buyingQty;
        object filled = null;
        object cost = null;
        object feeInBaseOrQuote = null;
        object marketsById = this.indexBy(this.markets, "id");
        if (isTrue(!isEqual(this.safeValue(marketsById, byuingIdPlusSellingId), null)))
        {
            side = "buy";
            marketId = byuingIdPlusSellingId;
            quoteAmount = sellingQty;
            filled = boughtQty;
            cost = soldQty;
            feeInBaseOrQuote = "base";
        } else if (isTrue(!isEqual(this.safeValue(marketsById, sellingIdPlusBuyingId), null)))
        {
            side = "sell";
            marketId = sellingIdPlusBuyingId;
            baseAmount = sellingQty;
            filled = soldQty;
            cost = boughtQty;
            feeInBaseOrQuote = "quote";
        }
        object price = null;
        if (isTrue(isTrue((!isEqual(baseAmount, null))) && isTrue((!isEqual(quoteAmount, null)))))
        {
            price = Precise.stringDiv(quoteAmount, baseAmount);
        }
        market = this.safeMarket(marketId, market);
        object fee = null;
        object feeCost = this.safeString(order, "fees");
        if (isTrue(isTrue((!isEqual(feeCost, null))) && isTrue((!isEqual(feeInBaseOrQuote, null)))))
        {
            fee = new Dictionary<string, object>() {
                { "currency", getValue(market, feeInBaseOrQuote) },
                { "cost", feeCost },
                { "rate", null },
            };
        }
        object trades = this.safeValue(order, "fills", new List<object>() {});
        object userData = this.safeValue(order, "userData", new Dictionary<string, object>() {});
        object triggerPrice = this.safeString(order, "stopPrice");
        object clientOrderId = this.safeString(userData, "comment");
        object takeProfitPrice = this.safeString(userData, "takeProfit");
        object stopLossPrice = this.safeString(userData, "stopLoss");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(order, "orderID") },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", this.safeInteger(order, "lastFillTime") },
            { "status", status },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "timeInForce", this.parseOrderTimeInForce(this.safeInteger(order, "timeInForce")) },
            { "side", side },
            { "price", price },
            { "triggerPrice", triggerPrice },
            { "takeProfitPrice", takeProfitPrice },
            { "stopLossPrice", stopLossPrice },
            { "average", null },
            { "amount", baseAmount },
            { "cost", cost },
            { "filled", filled },
            { "remaining", null },
            { "fee", fee },
            { "fees", null },
            { "trades", trades },
            { "info", order },
        }, market);
    }

    public virtual object parseOrderTimeInForce(object timeInForce)
    {
        object timeInForceTypes = new List<object>() {null, "GTC", "IOC", "GTD", "FOK"};
        return this.safeValue(timeInForceTypes, timeInForce, timeInForce);
    }

    public async override Task<object> borrowCrossMargin(object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name coinmetro#borrowCrossMargin
        * @description create a loan to borrow margin
        * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#5b90b3b9-e5db-4d07-ac9d-d680a06fd110
        * @param {string} code unified currency code of the currency to borrow
        * @param {float} amount the amount to borrow
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object currencyId = getValue(currency, "id");
        object request = new Dictionary<string, object>() {};
        ((IDictionary<string,object>)request)[(string)currencyId] = this.currencyToPrecision(code, amount);
        object response = await this.privatePutUsersMarginCollateral(this.extend(request, parameters));
        //
        //     { "message": "OK" }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object transaction = this.parseMarginLoan(result, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
        });
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        object currencyId = this.safeString(info, "coin");
        return new Dictionary<string, object>() {
            { "id", null },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", null },
            { "symbol", null },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object request = this.omit(parameters, this.extractParams(path));
        object endpoint = add("/", this.implodeParams(path, parameters));
        object url = add(getValue(getValue(this.urls, "api"), api), endpoint);
        object query = this.urlencode(request);
        if (isTrue(isEqual(headers, null)))
        {
            headers = new Dictionary<string, object>() {};
        }
        ((IDictionary<string,object>)headers)["CCXT"] = "true";
        if (isTrue(isEqual(api, "private")))
        {
            if (isTrue(isTrue((isEqual(this.uid, null))) && isTrue((!isEqual(this.apiKey, null)))))
            {
                this.uid = this.apiKey;
            }
            if (isTrue(isTrue((isEqual(this.token, null))) && isTrue((!isEqual(this.secret, null)))))
            {
                this.token = this.secret;
            }
            if (isTrue(isEqual(url, "https://api.coinmetro.com/jwt")))
            {
                ((IDictionary<string,object>)headers)["X-Device-Id"] = "bypass";
                if (isTrue(!isEqual(this.twofa, null)))
                {
                    ((IDictionary<string,object>)headers)["X-OTP"] = this.twofa;
                }
            } else if (isTrue(isEqual(url, "https://api.coinmetro.com/jwtDevice")))
            {
                ((IDictionary<string,object>)headers)["X-Device-Id"] = this.uid;
                if (isTrue(!isEqual(this.twofa, null)))
                {
                    ((IDictionary<string,object>)headers)["X-OTP"] = this.twofa;
                }
            } else
            {
                ((IDictionary<string,object>)headers)["Authorization"] = add("Bearer ", this.token);
                if (!isTrue(((string)url).StartsWith(((string)"https://api.coinmetro.com/open"))))
                {
                    this.checkRequiredCredentials();
                    ((IDictionary<string,object>)headers)["X-Device-Id"] = this.uid;
                }
            }
            if (isTrue(isTrue((isEqual(method, "POST"))) || isTrue((isEqual(method, "PUT")))))
            {
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/x-www-form-urlencoded";
                body = this.urlencode(request);
            }
        } else if (isTrue(!isEqual(getArrayLength(query), 0)))
        {
            url = add(url, add("?", query));
        }
        while (((string)url).EndsWith(((string)"/")))
        {
            url = slice(url, 0, subtract(((string)url).Length, 1));
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        if (isTrue(isTrue(isTrue((!isEqual(code, 200))) && isTrue((!isEqual(code, 201)))) && isTrue((!isEqual(code, 202)))))
        {
            object feedback = add(add(this.id, " "), body);
            object message = this.safeString(response, "message");
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
