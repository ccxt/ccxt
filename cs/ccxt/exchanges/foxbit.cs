namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class foxbit : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "foxbit" },
            { "name", "Foxbit" },
            { "countries", new List<object>() {"pt-BR"} },
            { "rateLimit", 33.334 },
            { "version", "1" },
            { "comment", "Foxbit Exchange" },
            { "certified", false },
            { "pro", false },
            { "has", new Dictionary<string, object>() {
                { "CORS", true },
                { "spot", true },
                { "margin", null },
                { "swap", null },
                { "future", null },
                { "option", null },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createLimitBuyOrder", true },
                { "createLimitSellOrder", true },
                { "createMarketBuyOrder", true },
                { "createMarketSellOrder", true },
                { "createOrder", true },
                { "fecthOrderBook", true },
                { "fetchBalance", true },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchL2OrderBook", true },
                { "fetchLedger", true },
                { "fetchMarkets", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrders", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", true },
                { "fetchTransactions", true },
                { "fetchWithdrawals", true },
                { "loadMarkets", true },
                { "sandbox", false },
                { "withdraw", true },
                { "ws", false },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "1w", "1w" },
                { "2w", "2w" },
                { "1M", "1M" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/63be1a3a-775d-459b-8c03-493c71c0253c" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.foxbit.com.br" },
                    { "private", "https://api.foxbit.com.br" },
                    { "status", "https://metadata-v2.foxbit.com.br/api" },
                } },
                { "www", "https://app.foxbit.com.br" },
                { "doc", new List<object>() {"https://docs.foxbit.com.br"} },
            } },
            { "precisionMode", DECIMAL_PLACES },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "400", typeof(BadRequest) },
                    { "429", typeof(RateLimitExceeded) },
                    { "404", typeof(BadRequest) },
                    { "500", typeof(ExchangeError) },
                    { "2001", typeof(AuthenticationError) },
                    { "2002", typeof(AuthenticationError) },
                    { "2003", typeof(AuthenticationError) },
                    { "2004", typeof(BadRequest) },
                    { "2005", typeof(PermissionDenied) },
                    { "3001", typeof(PermissionDenied) },
                    { "3002", typeof(PermissionDenied) },
                    { "3003", typeof(AccountSuspended) },
                    { "4001", typeof(BadRequest) },
                    { "4002", typeof(InsufficientFunds) },
                    { "4003", typeof(InvalidOrder) },
                    { "4004", typeof(BadSymbol) },
                    { "4005", typeof(BadRequest) },
                    { "4007", typeof(ExchangeError) },
                    { "4008", typeof(InvalidOrder) },
                    { "4009", typeof(PermissionDenied) },
                    { "4011", typeof(RateLimitExceeded) },
                    { "4012", typeof(ExchangeError) },
                    { "5001", typeof(ExchangeNotAvailable) },
                    { "5002", typeof(OnMaintenance) },
                    { "5003", typeof(OnMaintenance) },
                    { "5004", typeof(InvalidOrder) },
                    { "5005", typeof(InvalidOrder) },
                    { "5006", typeof(InvalidOrder) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "v3", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "currencies", 5 },
                            { "markets", 5 },
                            { "markets/ticker/24hr", 60 },
                            { "markets/{market}/orderbook", 6 },
                            { "markets/{market}/candlesticks", 12 },
                            { "markets/{market}/trades/history", 12 },
                            { "markets/{market}/ticker/24hr", 15 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "accounts", 2 },
                            { "accounts/{symbol}/transactions", 60 },
                            { "orders", 2 },
                            { "orders/by-order-id/{id}", 2 },
                            { "trades", 6 },
                            { "deposits/address", 10 },
                            { "deposits", 10 },
                            { "withdrawals", 10 },
                            { "me/fees/trading", 60 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "orders", 2 },
                            { "orders/batch", 7.5 },
                            { "orders/cancel-replace", 3 },
                            { "withdrawals", 10 },
                        } },
                        { "put", new Dictionary<string, object>() {
                            { "orders/cancel", 2 },
                        } },
                    } },
                } },
                { "status", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "status", 30 },
                        } },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "feeSide", "get" },
                    { "tierBased", false },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.005") },
                    { "maker", this.parseNumber("0.0025") },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "sandboxMode", false },
                { "networksById", new Dictionary<string, object>() {
                    { "algorand", "ALGO" },
                    { "arbitrum", "ARBITRUM" },
                    { "avalanchecchain", "AVAX" },
                    { "bitcoin", "BTC" },
                    { "bitcoincash", "BCH" },
                    { "bsc", "BEP20" },
                    { "cardano", "ADA" },
                    { "cosmos", "ATOM" },
                    { "dogecoin", "DOGE" },
                    { "erc20", "ETH" },
                    { "hedera", "HBAR" },
                    { "litecoin", "LTC" },
                    { "near", "NEAR" },
                    { "optimism", "OPTIMISM" },
                    { "polkadot", "DOT" },
                    { "polygon", "MATIC" },
                    { "ripple", "XRP" },
                    { "solana", "SOL" },
                    { "stacks", "STX" },
                    { "stellar", "XLM" },
                    { "tezos", "XTZ" },
                    { "trc20", "TRC20" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "ALGO", "algorand" },
                    { "ARBITRUM", "arbitrum" },
                    { "AVAX", "avalanchecchain" },
                    { "BTC", "bitcoin" },
                    { "BCH", "bitcoincash" },
                    { "BEP20", "bsc" },
                    { "ADA", "cardano" },
                    { "ATOM", "cosmos" },
                    { "DOGE", "dogecoin" },
                    { "ETH", "erc20" },
                    { "HBAR", "hedera" },
                    { "LTC", "litecoin" },
                    { "NEAR", "near" },
                    { "OPTIMISM", "optimism" },
                    { "DOT", "polkadot" },
                    { "MATIC", "polygon" },
                    { "XRP", "ripple" },
                    { "SOL", "solana" },
                    { "STX", "stacks" },
                    { "XLM", "stellar" },
                    { "XTZ", "tezos" },
                    { "TRC20", "trc20" },
                } },
            } },
            { "features", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "sandbox", false },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", true },
                        { "triggerPriceType", new Dictionary<string, object>() {
                            { "last", true },
                            { "mark", false },
                            { "index", false },
                        } },
                        { "triggerDirection", false },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "GTC", true },
                            { "FOK", true },
                            { "IOC", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "leverage", false },
                        { "marketBuyByCost", false },
                        { "marketBuyRequiresPrice", false },
                        { "selfTradePrevention", new Dictionary<string, object>() {
                            { "expire_maker", true },
                            { "expire_taker", true },
                            { "expire_both", true },
                            { "none", true },
                        } },
                        { "trailing", false },
                        { "icebergAmount", false },
                    } },
                    { "createOrders", new Dictionary<string, object>() {
                        { "max", 5 },
                    } },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "daysBack", 90 },
                        { "untilDays", 10000 },
                        { "symbolRequired", true },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 1 },
                        { "daysBack", 90 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "daysBack", 90 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", 100 },
                        { "daysBack", 90 },
                        { "untilDays", 10000 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", 100 },
                        { "daysBack", 90 },
                        { "daysBackCanceled", 90 },
                        { "untilDays", 10000 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 500 },
                    } },
                } },
            } },
        });
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.v3PublicGetCurrencies(parameters);
        // {
        //   "data": [
        //     {
        //       "symbol": "btc",
        //       "name": "Bitcoin",
        //       "type": "CRYPTO",
        //       "precision": 8,
        //       "deposit_info": {
        //         "min_to_confirm": "1",
        //         "min_amount": "0.0001"
        //       },
        //       "withdraw_info": {
        //         "enabled": true,
        //         "min_amount": "0.0001",
        //         "fee": "0.0001"
        //       },
        //       "category": {
        //           "code": "cripto",
        //         "name": "Cripto"
        //       },
        //       "networks": [
        //           {
        //               "name": "Bitcoin",
        //               "code": "btc",
        //               "deposit_info": {
        //                  status: "ENABLED",
        //               },
        //               "withdraw_info": {
        //                  "status": "ENABLED",
        //                  "fee": "0.0001",
        //               },
        //               "has_destination_tag": false
        //           }
        //       ]
        //     }
        //   ]
        // }
        object data = this.safeList(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object currency = getValue(data, i);
            object precision = this.safeInteger(currency, "precision");
            object currencyId = this.safeString(currency, "symbol");
            object name = this.safeString(currency, "name");
            object code = this.safeCurrencyCode(currencyId);
            object depositInfo = this.safeDict(currency, "deposit_info");
            object withdrawInfo = this.safeDict(currency, "withdraw_info");
            object networks = this.safeList(currency, "networks", new List<object>() {});
            object type = this.safeStringLower(currency, "type");
            object parsedNetworks = new Dictionary<string, object>() {};
            for (object j = 0; isLessThan(j, getArrayLength(networks)); postFixIncrement(ref j))
            {
                object network = getValue(networks, j);
                object networkId = this.safeString(network, "code");
                object networkCode = this.networkIdToCode(networkId, code);
                object networkWithdrawInfo = this.safeDict(network, "withdraw_info");
                object networkDepositInfo = this.safeDict(network, "deposit_info");
                object isWithdrawEnabled = isEqual(this.safeString(networkWithdrawInfo, "status"), "ENABLED");
                object isDepositEnabled = isEqual(this.safeString(networkDepositInfo, "status"), "ENABLED");
                ((IDictionary<string,object>)parsedNetworks)[(string)networkCode] = new Dictionary<string, object>() {
                    { "info", currency },
                    { "id", networkId },
                    { "network", networkCode },
                    { "name", this.safeString(network, "name") },
                    { "deposit", isDepositEnabled },
                    { "withdraw", isWithdrawEnabled },
                    { "active", true },
                    { "precision", precision },
                    { "fee", this.safeNumber(networkWithdrawInfo, "fee") },
                    { "limits", new Dictionary<string, object>() {
                        { "amount", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", this.safeNumber(depositInfo, "min_amount") },
                            { "max", null },
                        } },
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", this.safeNumber(withdrawInfo, "min_amount") },
                            { "max", null },
                        } },
                    } },
                };
            }
            if (isTrue(isEqual(this.safeDict(result, code), null)))
            {
                ((IDictionary<string,object>)result)[(string)code] = this.safeCurrencyStructure(new Dictionary<string, object>() {
                    { "id", currencyId },
                    { "code", code },
                    { "info", currency },
                    { "name", name },
                    { "active", true },
                    { "type", type },
                    { "deposit", this.safeBool(depositInfo, "enabled", false) },
                    { "withdraw", this.safeBool(withdrawInfo, "enabled", false) },
                    { "fee", this.safeNumber(withdrawInfo, "fee") },
                    { "precision", precision },
                    { "limits", new Dictionary<string, object>() {
                        { "amount", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", this.safeNumber(depositInfo, "min_amount") },
                            { "max", null },
                        } },
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", this.safeNumber(withdrawInfo, "min_amount") },
                            { "max", null },
                        } },
                    } },
                    { "networks", parsedNetworks },
                });
            }
        }
        return result;
    }

    /**
     * @method
     * @name foxbit#fetchMarkets
     * @description Retrieves data on all markets for foxbit.
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Market-Data/operation/MarketsController_index
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.v3PublicGetMarkets(parameters);
        // {
        //     "data": [
        //       {
        //         "symbol": "btcbrl",
        //         "quantity_min": "0.00000236",
        //         "quantity_increment": "0.00000001",
        //         "quantity_precision": 8,
        //         "price_min": "0.0001",
        //         "price_increment": "0.0001",
        //         "price_precision": 4,
        //         "default_fees": {
        //           "maker": "0.001",
        //           "taker": "0.001"
        //         },
        //         "base": {
        //           "symbol": "btc",
        //           "name": "Bitcoin",
        //           "type": "CRYPTO",
        //           "precision": 8,
        //           "category": {
        //             "code": "cripto",
        //             "name": "Cripto"
        //           },
        //           "deposit_info": {
        //             "min_to_confirm": "1",
        //             "min_amount": "0.0001",
        //             "enabled": true
        //           },
        //           "withdraw_info": {
        //             "enabled": true,
        //             "min_amount": "0.0001",
        //             "fee": "0.0001"
        //           },
        //           "networks": [
        //             {
        //               "name": "Bitcoin",
        //               "code": "bitcoin",
        //               "deposit_info": {
        //                 "status": "ENABLED"
        //               },
        //               "withdraw_info": {
        //                 "status": "ENABLED",
        //                 "fee": "0.0001"
        //               },
        //               "has_destination_tag": false
        //             }
        //           ],
        //           "default_network_code": "bitcoin"
        //         },
        //         "quote": {
        //           "symbol": "btc",
        //           "name": "Bitcoin",
        //           "type": "CRYPTO",
        //           "precision": 8,
        //           "category": {
        //             "code": "cripto",
        //             "name": "Cripto"
        //           },
        //           "deposit_info": {
        //             "min_to_confirm": "1",
        //             "min_amount": "0.0001",
        //             "enabled": true
        //           },
        //           "withdraw_info": {
        //             "enabled": true,
        //             "min_amount": "0.0001",
        //             "fee": "0.0001"
        //           },
        //           "networks": [
        //             {
        //               "name": "Bitcoin",
        //               "code": "bitcoin",
        //               "deposit_info": {
        //                 "status": "ENABLED"
        //               },
        //               "withdraw_info": {
        //                 "status": "ENABLED",
        //                 "fee": "0.0001"
        //               },
        //               "has_destination_tag": false
        //             }
        //           ],
        //           "default_network_code": "bitcoin"
        //         },
        //         "order_type": [
        //           "LIMIT",
        //           "MARKET",
        //           "INSTANT",
        //           "STOP_LIMIT",
        //           "STOP_MARKET"
        //         ]
        //       }
        //     ]
        //   }
        object markets = this.safeList(response, "data", new List<object>() {});
        return this.parseMarkets(markets);
    }

    /**
     * @method
     * @name foxbit#fetchTicker
     * @description Get last 24 hours ticker information, in real-time, for given market.
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Market-Data/operation/MarketsController_ticker
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = await this.v3PublicGetMarketsMarketTicker24hr(this.extend(request, parameters));
        //  {
        //    "data": [
        //      {
        //        "market_symbol": "btcbrl",
        //        "last_trade": {
        //          "price": "358504.69340000",
        //          "volume": "0.00027893",
        //          "date": "2024-01-01T00:00:00.000Z"
        //        },
        //        "rolling_24h": {
        //          "price_change": "3211.87290000",
        //          "price_change_percent": "0.90400726",
        //          "volume": "20.03206866",
        //          "trades_count": "4376",
        //          "open": "355292.82050000",
        //          "high": "362999.99990000",
        //          "low": "355002.88880000"
        //        },
        //        "best": {
        //          "ask": {
        //            "price": "358504.69340000",
        //            "volume": "0.00027893"
        //          },
        //          "bid": {
        //            "price": "358504.69340000",
        //            "volume": "0.00027893"
        //          }
        //        }
        //      }
        //    ]
        //  }
        object data = this.safeList(response, "data", new List<object>() {});
        object result = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseTicker(result, market);
    }

    /**
     * @method
     * @name foxbit#fetchTickers
     * @description Retrieve the ticker data of all markets.
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Market-Data/operation/MarketsController_tickers
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.v3PublicGetMarketsTicker24hr(parameters);
        //  {
        //    "data": [
        //      {
        //        "market_symbol": "btcbrl",
        //        "last_trade": {
        //          "price": "358504.69340000",
        //          "volume": "0.00027893",
        //          "date": "2024-01-01T00:00:00.000Z"
        //        },
        //        "rolling_24h": {
        //          "price_change": "3211.87290000",
        //          "price_change_percent": "0.90400726",
        //          "volume": "20.03206866",
        //          "trades_count": "4376",
        //          "open": "355292.82050000",
        //          "high": "362999.99990000",
        //          "low": "355002.88880000"
        //        },
        //      }
        //    ]
        //  }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTickers(data, symbols);
    }

    /**
     * @method
     * @name foxbit#fetchTradingFees
     * @description fetch the trading fees for multiple markets
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Member-Info/operation/MembersController_listTradingFees
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
     */
    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v3PrivateGetMeFeesTrading(parameters);
        // [
        //     {
        //         "market_symbol": "btcbrl",
        //         "maker": "0.0025",
        //         "taker": "0.005"
        //     }
        // ]
        object data = this.safeList(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object marketId = this.safeString(entry, "market_symbol");
            object market = this.safeMarket(marketId);
            object symbol = getValue(market, "symbol");
            ((IDictionary<string,object>)result)[(string)symbol] = this.parseTradingFee(entry, market);
        }
        return result;
    }

    /**
     * @method
     * @name foxbit#fetchOrderBook
     * @description Exports a copy of the order book of a specific market.
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Market-Data/operation/MarketsController_findOrderbook
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return, the maximum is 100
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object defaultLimit = 20;
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "depth", ((bool) isTrue((isEqual(limit, null)))) ? defaultLimit : limit },
        };
        object response = await this.v3PublicGetMarketsMarketOrderbook(this.extend(request, parameters));
        //  {
        //    "sequence_id": 1234567890,
        //    "timestamp": 1713187921336,
        //    "bids": [
        //      [
        //        "3.00000000",
        //        "300.00000000"
        //      ],
        //      [
        //        "1.70000000",
        //        "310.00000000"
        //      ]
        //    ],
        //    "asks": [
        //      [
        //        "3.00000000",
        //        "300.00000000"
        //      ],
        //      [
        //        "2.00000000",
        //        "321.00000000"
        //      ]
        //    ]
        //  }
        object timestamp = this.safeInteger(response, "timestamp");
        return this.parseOrderBook(response, symbol, timestamp);
    }

    /**
     * @method
     * @name foxbit#fetchTrades
     * @description Retrieve the trades of a specific market.
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Market-Data/operation/MarketsController_publicTrades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
            if (isTrue(isGreaterThan(limit, 200)))
            {
                ((IDictionary<string,object>)request)["page_size"] = 200;
            }
        }
        // [
        //     {
        //         "id": 1,
        //         "price": "329248.74700000",
        //         "volume": "0.00100000",
        //         "taker_side": "BUY",
        //         "created_at": "2024-01-01T00:00:00Z"
        //     }
        // ]
        object response = await this.v3PublicGetMarketsMarketTradesHistory(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    /**
     * @method
     * @name foxbit#fetchOHLCV
     * @description Fetch historical candlestick data containing the open, high, low, and close price, and the volume of a market.
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Market-Data/operation/MarketsController_findCandlesticks
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object interval = this.safeString(this.timeframes, timeframe, timeframe);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "interval", interval },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
            if (isTrue(isGreaterThan(limit, 500)))
            {
                ((IDictionary<string,object>)request)["limit"] = 500;
            }
        }
        object response = await this.v3PublicGetMarketsMarketCandlesticks(this.extend(request, parameters));
        // [
        //     [
        //         "1692918000000", // timestamp
        //         "127772.05150000", // open
        //         "128467.99980000", // high
        //         "127750.01000000", // low
        //         "128353.99990000", // close
        //         "1692918060000", // close timestamp
        //         "0.17080431", // base volume
        //         "21866.35948786", // quote volume
        //         66, // number of trades
        //         "0.12073605", // taker buy base volume
        //         "15466.34096391" // taker buy quote volume
        //     ]
        // ]
        return this.parseOHLCVs(response, market, interval, since, limit);
    }

    /**
     * @method
     * @name foxbit#fetchBalance
     * @description Query for balance and get the amount of funds available for trading or funds locked in orders.
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Account/operation/AccountsController_all
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v3PrivateGetAccounts(parameters);
        // {
        //     "data": [
        //         {
        //         "currency_symbol": "btc",
        //         "balance": "10000.0",
        //         "balance_available": "9000.0",
        //         "balance_locked": "1000.0"
        //         }
        //     ]
        // }
        object accounts = this.safeList(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(accounts)); postFixIncrement(ref i))
        {
            object account = getValue(accounts, i);
            object currencyId = this.safeString(account, "currency_symbol");
            object currencyCode = this.safeCurrencyCode(currencyId);
            object total = this.safeString(account, "balance");
            object used = this.safeString(account, "balance_locked");
            object free = this.safeString(account, "balance_available");
            object balanceObj = new Dictionary<string, object>() {
                { "free", free },
                { "used", used },
                { "total", total },
            };
            ((IDictionary<string,object>)result)[(string)currencyCode] = balanceObj;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name foxbit#fetchOpenOrders
     * @description Fetch all unfilled currently open orders.
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_listOrders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("ACTIVE", symbol, since, limit, parameters);
    }

    /**
     * @method
     * @name foxbit#fetchClosedOrders
     * @description Fetch all currently closed orders.
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_listOrders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("FILLED", symbol, since, limit, parameters);
    }

    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("CANCELED", symbol, since, limit, parameters);
    }

    public async virtual Task<object> fetchOrdersByStatus(object status, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {
            { "state", status },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market_symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
            if (isTrue(isGreaterThan(limit, 100)))
            {
                ((IDictionary<string,object>)request)["page_size"] = 100;
            }
        }
        object response = await this.v3PrivateGetOrders(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data);
    }

    /**
     * @method
     * @name foxbit#createOrder
     * @description Create an order with the specified characteristics
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_create
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market', 'limit', 'stop_market', 'stop_limit', 'instant'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency
     * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.timeInForce] "GTC", "FOK", "IOC", "PO"
     * @param {float} [params.triggerPrice] The time in force for the order. One of GTC, FOK, IOC, PO. See .features or foxbit's doc to see more details.
     * @param {bool} [params.postOnly] true or false whether the order is post-only
     * @param {string} [params.clientOrderId] a unique identifier for the order
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        type = ((string)type).ToUpper();
        if (isTrue(isTrue(isTrue(isTrue(isTrue(!isEqual(type, "LIMIT")) && isTrue(!isEqual(type, "MARKET"))) && isTrue(!isEqual(type, "STOP_MARKET"))) && isTrue(!isEqual(type, "STOP_LIMIT"))) && isTrue(!isEqual(type, "INSTANT"))))
        {
            throw new InvalidOrder ((string)add(add("Invalid order type: ", type), ". Must be one of: limit, market, stop_market, stop_limit, instant.")) ;
        }
        object timeInForce = this.safeStringUpper(parameters, "timeInForce");
        object postOnly = this.safeBool(parameters, "postOnly", false);
        object triggerPrice = this.safeNumber(parameters, "triggerPrice");
        object request = new Dictionary<string, object>() {
            { "market_symbol", getValue(market, "id") },
            { "side", ((string)side).ToUpper() },
            { "type", type },
        };
        if (isTrue(isTrue(isEqual(type, "STOP_MARKET")) || isTrue(isEqual(type, "STOP_LIMIT"))))
        {
            if (isTrue(isEqual(triggerPrice, null)))
            {
                throw new InvalidOrder ((string)add(add("Invalid order type: ", type), ". Must have triggerPrice.")) ;
            }
        }
        if (isTrue(!isEqual(timeInForce, null)))
        {
            if (isTrue(isEqual(timeInForce, "PO")))
            {
                ((IDictionary<string,object>)request)["post_only"] = true;
            } else
            {
                ((IDictionary<string,object>)request)["time_in_force"] = timeInForce;
            }
        }
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["post_only"] = true;
        }
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((IDictionary<string,object>)request)["stop_price"] = this.priceToPrecision(symbol, triggerPrice);
        }
        if (isTrue(isEqual(type, "INSTANT")))
        {
            ((IDictionary<string,object>)request)["amount"] = this.priceToPrecision(symbol, amount);
        } else
        {
            ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(isTrue(isEqual(type, "LIMIT")) || isTrue(isEqual(type, "STOP_LIMIT"))))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
        }
        parameters = this.omit(parameters, new List<object>() {"timeInForce", "postOnly", "triggerPrice", "clientOrderId"});
        object response = await this.v3PrivatePostOrders(this.extend(request, parameters));
        // {
        //     "id": 1234567890,
        //     "sn": "OKMAKSDHRVVREK",
        //     "client_order_id": "451637946501"
        // }
        return this.parseOrder(response, market);
    }

    /**
     * @method
     * @name foxbit#createOrders
     * @description create a list of trade orders
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/createBatch
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object order = this.safeDict(orders, i);
            object symbol = this.safeString(order, "symbol");
            object market = this.market(symbol);
            object type = this.safeStringUpper(order, "type");
            object orderParams = this.safeDict(order, "params", new Dictionary<string, object>() {});
            if (isTrue(isTrue(isTrue(isTrue(isTrue(!isEqual(type, "LIMIT")) && isTrue(!isEqual(type, "MARKET"))) && isTrue(!isEqual(type, "STOP_MARKET"))) && isTrue(!isEqual(type, "STOP_LIMIT"))) && isTrue(!isEqual(type, "INSTANT"))))
            {
                throw new InvalidOrder ((string)add(add("Invalid order type: ", type), ". Must be one of: limit, market, stop_market, stop_limit, instant.")) ;
            }
            object timeInForce = this.safeStringUpper(orderParams, "timeInForce");
            object postOnly = this.safeBool(orderParams, "postOnly", false);
            object triggerPrice = this.safeNumber(orderParams, "triggerPrice");
            object request = new Dictionary<string, object>() {
                { "market_symbol", getValue(market, "id") },
                { "side", this.safeStringUpper(order, "side") },
                { "type", type },
            };
            if (isTrue(isTrue(isEqual(type, "STOP_MARKET")) || isTrue(isEqual(type, "STOP_LIMIT"))))
            {
                if (isTrue(isEqual(triggerPrice, null)))
                {
                    throw new InvalidOrder ((string)add(add("Invalid order type: ", type), ". Must have triggerPrice.")) ;
                }
            }
            if (isTrue(!isEqual(timeInForce, null)))
            {
                if (isTrue(isEqual(timeInForce, "PO")))
                {
                    ((IDictionary<string,object>)request)["post_only"] = true;
                } else
                {
                    ((IDictionary<string,object>)request)["time_in_force"] = timeInForce;
                }
                ((IDictionary<string,object>)orderParams).Remove((string)"timeInForce");
            }
            if (isTrue(postOnly))
            {
                ((IDictionary<string,object>)request)["post_only"] = true;
                ((IDictionary<string,object>)orderParams).Remove((string)"postOnly");
            }
            if (isTrue(!isEqual(triggerPrice, null)))
            {
                ((IDictionary<string,object>)request)["stop_price"] = this.priceToPrecision(symbol, triggerPrice);
                ((IDictionary<string,object>)orderParams).Remove((string)"triggerPrice");
            }
            if (isTrue(isEqual(type, "INSTANT")))
            {
                ((IDictionary<string,object>)request)["amount"] = this.priceToPrecision(symbol, this.safeString(order, "amount"));
            } else
            {
                ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, this.safeString(order, "amount"));
            }
            if (isTrue(isTrue(isEqual(type, "LIMIT")) || isTrue(isEqual(type, "STOP_LIMIT"))))
            {
                ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, this.safeString(order, "price"));
            }
            ((IList<object>)ordersRequests).Add(this.extend(request, orderParams));
        }
        object createOrdersRequest = new Dictionary<string, object>() {
            { "data", ordersRequests },
        };
        object response = await this.v3PrivatePostOrdersBatch(this.extend(createOrdersRequest, parameters));
        // {
        //     "data": [
        //         {
        //         "side": "BUY",
        //         "type": "LIMIT",
        //         "market_symbol": "btcbrl",
        //         "client_order_id": "451637946501",
        //         "remark": "A remarkable note for the order.",
        //         "quantity": "0.42",
        //         "price": "250000.0",
        //         "post_only": true,
        //         "time_in_force": "GTC"
        //         }
        //     ]
        // }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data);
    }

    /**
     * @method
     * @name foxbit#cancelOrder
     * @description Cancel open orders.
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_cancel
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", this.parseNumber(id) },
            { "type", "ID" },
        };
        object response = await this.v3PrivatePutOrdersCancel(this.extend(request, parameters));
        // {
        //     "data": [
        //         {
        //         "sn": "OKMAKSDHRVVREK",
        //         "id": 123456789
        //         }
        //     ]
        // }
        object data = this.safeList(response, "data", new List<object>() {});
        object result = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseOrder(result);
    }

    /**
     * @method
     * @name foxbit#cancelAllOrders
     * @description Cancel all open orders or all open orders for a specific market.
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_cancel
     * @param {string} symbol unified market symbol of the market to cancel orders in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "type", "ALL" },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["type"] = "MARKET";
            ((IDictionary<string,object>)request)["market_symbol"] = getValue(market, "id");
        }
        object response = await this.v3PrivatePutOrdersCancel(this.extend(request, parameters));
        // {
        //     "data": [
        //         {
        //           "sn": "OKMAKSDHRVVREK",
        //           "id": 123456789
        //         }
        //     ]
        // }
        return new List<object> {this.safeOrder(new Dictionary<string, object>() {
    { "info", response },
})};
    }

    /**
     * @method
     * @name foxbit#fetchOrder
     * @description Get an order by ID.
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_findByOrderId
     * @param id
     * @param {string} symbol it is not used in the foxbit API
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object response = await this.v3PrivateGetOrdersByOrderIdId(this.extend(request, parameters));
        // {
        //     "id": "1234567890",
        //     "sn": "OKMAKSDHRVVREK",
        //     "client_order_id": "451637946501",
        //     "market_symbol": "btcbrl",
        //     "side": "BUY",
        //     "type": "LIMIT",
        //     "state": "ACTIVE",
        //     "price": "290000.0",
        //     "price_avg": "295333.3333",
        //     "quantity": "0.42",
        //     "quantity_executed": "0.41",
        //     "instant_amount": "290.0",
        //     "instant_amount_executed": "290.0",
        //     "created_at": "2021-02-15T22:06:32.999Z",
        //     "trades_count": "2",
        //     "remark": "A remarkable note for the order.",
        //     "funds_received": "290.0"
        // }
        return this.parseOrder(response, null);
    }

    /**
     * @method
     * @name foxbit#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_listOrders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.state] Enum: ACTIVE, CANCELED, FILLED, PARTIALLY_CANCELED, PARTIALLY_FILLED
     * @param {string} [params.side] Enum: BUY, SELL
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market_symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
            if (isTrue(isGreaterThan(limit, 100)))
            {
                ((IDictionary<string,object>)request)["page_size"] = 100;
            }
        }
        object response = await this.v3PrivateGetOrders(this.extend(request, parameters));
        // {
        //     "data": [
        //         {
        //         "id": "1234567890",
        //         "sn": "OKMAKSDHRVVREK",
        //         "client_order_id": "451637946501",
        //         "market_symbol": "btcbrl",
        //         "side": "BUY",
        //         "type": "LIMIT",
        //         "state": "ACTIVE",
        //         "price": "290000.0",
        //         "price_avg": "295333.3333",
        //         "quantity": "0.42",
        //         "quantity_executed": "0.41",
        //         "instant_amount": "290.0",
        //         "instant_amount_executed": "290.0",
        //         "created_at": "2021-02-15T22:06:32.999Z",
        //         "trades_count": "2",
        //         "remark": "A remarkable note for the order.",
        //         "funds_received": "290.0"
        //         }
        //     ]
        // }
        object list = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(list, market, since, limit);
    }

    /**
     * @method
     * @name foxbit#fetchMyTrades
     * @description Trade history queries will only have data available for the last 3 months, in descending order (most recents trades first).
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/TradesController_all
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trade structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market_symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
            if (isTrue(isGreaterThan(limit, 100)))
            {
                ((IDictionary<string,object>)request)["page_size"] = 100;
            }
        }
        object response = await this.v3PrivateGetTrades(this.extend(request, parameters));
        // {
        //     "data": [
        //         "id": 1234567890,
        //         "sn": "TC5JZVW2LLJ3IW",
        //         "order_id": 1234567890,
        //         "market_symbol": "btcbrl",
        //         "side": "BUY",
        //         "price": "290000.0",
        //         "quantity": "1.0",
        //         "fee": "0.01",
        //         "fee_currency_symbol": "btc",
        //         "created_at": "2021-02-15T22:06:32.999Z"
        //     ]
        // }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    /**
     * @method
     * @name foxbit#fetchDepositAddress
     * @description Fetch the deposit address for a currency associated with this account.
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Deposit/operation/DepositsController_depositAddress
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.networkCode] the blockchain network to create a deposit address on
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency_symbol", getValue(currency, "id") },
        };
        var networkCodeparamsOmitedVariable = this.handleNetworkCodeAndParams(parameters);
        var networkCode = ((IList<object>) networkCodeparamsOmitedVariable)[0];
        var paramsOmited = ((IList<object>) networkCodeparamsOmitedVariable)[1];
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["network_code"] = this.networkCodeToId(networkCode, code);
        }
        object response = await this.v3PrivateGetDepositsAddress(this.extend(request, paramsOmited));
        // {
        //     "currency_symbol": "btc",
        //     "address": "2N9sS8LgrY19rvcCWDmE1ou1tTVmqk4KQAB",
        //     "message": "Address was retrieved successfully",
        //     "destination_tag": "string",
        //     "network": {
        //         "name": "Bitcoin Network",
        //         "code": "btc"
        //     }
        // }
        return this.parseDepositAddress(response, currency);
    }

    /**
     * @method
     * @name foxbit#fetchDeposits
     * @description Fetch all deposits made to an account.
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Deposit/operation/DepositsController_listOrders
     * @param {string} [code] unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposit structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
            if (isTrue(isGreaterThan(limit, 100)))
            {
                ((IDictionary<string,object>)request)["page_size"] = 100;
            }
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = this.iso8601(since);
        }
        object response = await this.v3PrivateGetDeposits(this.extend(request, parameters));
        // {
        //     "data": [
        //         {
        //             "sn": "OKMAKSDHRVVREK",
        //             "state": "ACCEPTED",
        //             "currency_symbol": "btc",
        //             "amount": "1.0",
        //             "fee": "0.1",
        //             "created_at": "2022-02-18T22:06:32.999Z",
        //             "details_crypto": {
        //                 "transaction_id": "e20f035387020c5d5ea18ad53244f09f3",
        //                 "receiving_address": "2N2rTrnKEFcyJjEJqvVjgWZ3bKvKT7Aij61"
        //             }
        //         }
        //     ]
        // }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit);
    }

    /**
     * @method
     * @name foxbit#fetchWithdrawals
     * @description Fetch all withdrawals made from an account.
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Withdrawal/operation/WithdrawalsController_listWithdrawals
     * @param {string} [code] unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawal structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
            if (isTrue(isGreaterThan(limit, 100)))
            {
                ((IDictionary<string,object>)request)["page_size"] = 100;
            }
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = this.iso8601(since);
        }
        object response = await this.v3PrivateGetWithdrawals(this.extend(request, parameters));
        // {
        //     "data": [
        //         {
        //             "sn": "OKMAKSDHRVVREK",
        //             "state": "ACCEPTED",
        //             "rejection_reason": "monthly_limit_exceeded",
        //             "currency_symbol": "btc",
        //             "amount": "1.0",
        //             "fee": "0.1",
        //             "created_at": "2022-02-18T22:06:32.999Z",
        //             "details_crypto": {
        //                 "transaction_id": "e20f035387020c5d5ea18ad53244f09f3",
        //                 "destination_address": "2N2rTrnKEFcyJjEJqvVjgWZ3bKvKT7Aij61"
        //             },
        //             "details_fiat": {
        //                 "bank": {
        //                     "code": "1",
        //                     "branch": {
        //                         "number": "1234567890",
        //                         "digit": "1"
        //                     },
        //                     "account": {
        //                         "number": "1234567890",
        //                         "digit": "1",
        //                         "type": "CHECK"
        //                     }
        //                 }
        //             }
        //         }
        //     ]
        // }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit);
    }

    /**
     * @method
     * @name foxbit#fetchTransactions
     * @description Fetch all transactions (deposits and withdrawals) made from an account.
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Withdrawal/operation/WithdrawalsController_listWithdrawals
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Deposit/operation/DepositsController_listOrders
     * @param {string} [code] unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawal structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchTransactions(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object withdrawals = await this.fetchWithdrawals(code, since, limit, parameters);
        object deposits = await this.fetchDeposits(code, since, limit, parameters);
        object allTransactions = this.arrayConcat(withdrawals, deposits);
        object result = this.sortBy(allTransactions, "timestamp");
        return result;
    }

    /**
     * @method
     * @name foxbit#fetchStatus
     * @description The latest known information on the availability of the exchange API.
     * @see https://status.foxbit.com/
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
     */
    public async override Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.statusPublicGetStatus(parameters);
        // {
        //     "data": {
        //       "id": 1,
        //       "attributes": {
        //         "status": "NORMAL",
        //         "createdAt": "2023-05-17T18:37:05.934Z",
        //         "updatedAt": "2024-04-17T02:33:50.945Z",
        //         "publishedAt": "2023-05-17T18:37:07.653Z",
        //         "locale": "pt-BR"
        //       }
        //     },
        //     "meta": {
        //     }
        // }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object attributes = this.safeDict(data, "attributes", new Dictionary<string, object>() {});
        object statusRaw = this.safeString(attributes, "status");
        object statusMap = new Dictionary<string, object>() {
            { "NORMAL", "ok" },
            { "UNDER_MAINTENANCE", "maintenance" },
        };
        return new Dictionary<string, object>() {
            { "status", this.safeString(statusMap, statusRaw, statusRaw) },
            { "updated", this.safeString(attributes, "updatedAt") },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    /**
     * @method
     * @name foxbit#editOrder
     * @description Simultaneously cancel an existing order and create a new one.
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_cancelReplace
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of the currency you want to trade in units of the base currency
     * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders, used as stop_price on stop market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " editOrder() requires a symbol argument")) ;
        }
        type = ((string)type).ToUpper();
        if (isTrue(isTrue(isTrue(isTrue(!isEqual(type, "LIMIT")) && isTrue(!isEqual(type, "MARKET"))) && isTrue(!isEqual(type, "STOP_MARKET"))) && isTrue(!isEqual(type, "INSTANT"))))
        {
            throw new InvalidOrder ((string)add(add("Invalid order type: ", type), ". Must be one of: LIMIT, MARKET, STOP_MARKET, INSTANT.")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "mode", "ALLOW_FAILURE" },
            { "cancel", new Dictionary<string, object>() {
                { "type", "ID" },
                { "id", this.parseNumber(id) },
            } },
            { "create", new Dictionary<string, object>() {
                { "type", type },
                { "side", ((string)side).ToUpper() },
                { "market_symbol", getValue(market, "id") },
            } },
        };
        if (isTrue(isTrue(isEqual(type, "LIMIT")) || isTrue(isEqual(type, "MARKET"))))
        {
            ((IDictionary<string,object>)getValue(request, "create"))["quantity"] = this.amountToPrecision(symbol, amount);
            if (isTrue(isEqual(type, "LIMIT")))
            {
                ((IDictionary<string,object>)getValue(request, "create"))["price"] = this.priceToPrecision(symbol, price);
            }
        }
        if (isTrue(isEqual(type, "STOP_MARKET")))
        {
            ((IDictionary<string,object>)getValue(request, "create"))["stop_price"] = this.priceToPrecision(symbol, price);
            ((IDictionary<string,object>)getValue(request, "create"))["quantity"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(isEqual(type, "INSTANT")))
        {
            ((IDictionary<string,object>)getValue(request, "create"))["amount"] = this.priceToPrecision(symbol, amount);
        }
        object response = await this.v3PrivatePostOrdersCancelReplace(this.extend(request, parameters));
        // {
        //     "cancel": {
        //         "id": 123456789
        //     },
        //     "create": {
        //         "id": 1234567890,
        //         "client_order_id": "451637946501"
        //     }
        // }
        return this.parseOrder(getValue(response, "create"), market);
    }

    /**
     * @method
     * @name foxbit#withdraw
     * @description Make a withdrawal.
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Withdrawal/operation/WithdrawalsController_createWithdrawal
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency_symbol", getValue(currency, "id") },
            { "amount", this.numberToString(amount) },
            { "destination_address", address },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["destination_tag"] = tag;
        }
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["network_code"] = this.networkCodeToId(networkCode);
        }
        object response = await this.v3PrivatePostWithdrawals(this.extend(request, parameters));
        // {
        //     "amount": "1",
        //     "currency_symbol": "xrp",
        //     "network_code": "ripple",
        //     "destination_address": "0x1234567890123456789012345678",
        //     "destination_tag": "123456"
        // }
        return this.parseTransaction(response);
    }

    /**
     * @method
     * @name foxbit#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
     * @see https://docs.foxbit.com.br/rest/v3/#tag/Account/operation/AccountsController_getTransactions
     * @param {string} code unified currency code, default is undefined
     * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
     * @param {int} [limit] max number of ledger entrys to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchLedger() requires a code argument")) ;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
            if (isTrue(isGreaterThan(limit, 100)))
            {
                ((IDictionary<string,object>)request)["page_size"] = 100;
            }
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = this.iso8601(since);
        }
        object currency = this.currency(code);
        ((IDictionary<string,object>)request)["symbol"] = getValue(currency, "id");
        object response = await this.v3PrivateGetAccountsSymbolTransactions(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseLedger(data, currency, since, limit);
    }

    public override object parseMarket(object market)
    {
        object id = this.safeString(market, "symbol");
        object baseAssets = this.safeDict(market, "base");
        object baseId = this.safeString(baseAssets, "symbol");
        object quoteAssets = this.safeDict(market, "quote");
        object quoteId = this.safeString(quoteAssets, "symbol");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(bs, "/"), quote);
        object fees = this.safeDict(market, "default_fees");
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", id },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "active", true },
            { "type", "spot" },
            { "spot", true },
            { "margin", false },
            { "future", false },
            { "swap", false },
            { "option", false },
            { "contract", false },
            { "settle", null },
            { "settleId", null },
            { "contractSize", null },
            { "linear", null },
            { "inverse", null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "taker", this.safeNumber(fees, "taker") },
            { "maker", this.safeNumber(fees, "maker") },
            { "percentage", true },
            { "tierBased", false },
            { "feeSide", "get" },
            { "precision", new Dictionary<string, object>() {
                { "price", this.safeInteger(quoteAssets, "precision") },
                { "amount", this.safeInteger(baseAssets, "precision") },
                { "cost", this.safeInteger(quoteAssets, "precision") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "quantity_min") },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "price_min") },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "info", market },
        });
    }

    public virtual object parseTradingFee(object entry, object market = null)
    {
        return new Dictionary<string, object>() {
            { "info", entry },
            { "symbol", getValue(market, "symbol") },
            { "maker", this.safeNumber(entry, "maker") },
            { "taker", this.safeNumber(entry, "taker") },
            { "percentage", true },
            { "tierBased", true },
        };
    }

    public override object parseTicker(object ticker, object market = null)
    {
        object marketId = this.safeString(ticker, "market_symbol");
        object symbol = this.safeSymbol(marketId, market, null, "spot");
        object rolling_24h = getValue(ticker, "rolling_24h");
        object best = this.safeDict(ticker, "best");
        object bestAsk = this.safeDict(best, "ask");
        object bestBid = this.safeDict(best, "bid");
        object lastTrade = getValue(ticker, "last_trade");
        object lastPrice = this.safeString(lastTrade, "price");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", this.parseDate(this.safeString(lastTrade, "date")) },
            { "datetime", this.iso8601(this.parseDate(this.safeString(lastTrade, "date"))) },
            { "high", this.safeNumber(rolling_24h, "high") },
            { "low", this.safeNumber(rolling_24h, "low") },
            { "bid", this.safeNumber(bestBid, "price") },
            { "bidVolume", this.safeNumber(bestBid, "volume") },
            { "ask", this.safeNumber(bestAsk, "price") },
            { "askVolume", this.safeNumber(bestAsk, "volume") },
            { "vwap", null },
            { "open", this.safeNumber(rolling_24h, "open") },
            { "close", lastPrice },
            { "last", lastPrice },
            { "previousClose", null },
            { "change", this.safeString(rolling_24h, "price_change") },
            { "percentage", this.safeString(rolling_24h, "price_change_percent") },
            { "average", null },
            { "baseVolume", this.safeString(rolling_24h, "volume") },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 6)};
    }

    public override object parseTrade(object trade, object market = null)
    {
        object timestamp = this.parseDate(this.safeString(trade, "created_at"));
        object price = this.safeString(trade, "price");
        object amount = this.safeString(trade, "volume", this.safeString(trade, "quantity"));
        object privateSideField = this.safeStringLower(trade, "side");
        object side = this.safeStringLower(trade, "taker_side", privateSideField);
        object cost = Precise.stringMul(price, amount);
        object fee = new Dictionary<string, object>() {
            { "currency", this.safeSymbol(this.safeString(trade, "fee_currency_symbol")) },
            { "cost", this.safeNumber(trade, "fee") },
            { "rate", null },
        };
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", this.safeString(trade, "id") },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "order", null },
            { "type", null },
            { "side", side },
            { "takerOrMaker", null },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "fee", fee },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "PARTIALLY_CANCELED", "open" },
            { "ACTIVE", "open" },
            { "PARTIALLY_FILLED", "open" },
            { "FILLED", "closed" },
            { "PENDING_CANCEL", "canceled" },
            { "CANCELED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        object symbol = this.safeString(order, "market_symbol");
        if (isTrue(isTrue(isEqual(market, null)) && isTrue(!isEqual(symbol, null))))
        {
            market = this.market(symbol);
        }
        if (isTrue(!isEqual(market, null)))
        {
            symbol = getValue(market, "symbol");
        }
        object timestamp = this.parseDate(this.safeString(order, "created_at"));
        object price = this.safeString(order, "price");
        object filled = this.safeString(order, "quantity_executed");
        object remaining = this.safeString(order, "quantity");
        // TODO: validate logic of amount here, should this be calculated?
        object amount = null;
        if (isTrue(isTrue(!isEqual(remaining, null)) && isTrue(!isEqual(filled, null))))
        {
            amount = Precise.stringAdd(remaining, filled);
        }
        object cost = this.safeString(order, "funds_received");
        if (!isTrue(cost))
        {
            object priceAverage = this.safeString(order, "price_avg");
            object priceToCalculate = this.safeString(order, "price", priceAverage);
            cost = Precise.stringMul(priceToCalculate, amount);
        }
        object side = this.safeStringLower(order, "side");
        object feeCurrency = this.safeStringUpper(market, "quoteId");
        if (isTrue(isEqual(side, "buy")))
        {
            feeCurrency = this.safeStringUpper(market, "baseId");
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(order, "id") },
            { "info", order },
            { "clientOrderId", this.safeString(order, "client_order_id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "status", this.parseOrderStatus(this.safeString(order, "state")) },
            { "symbol", this.safeString(market, "symbol") },
            { "type", this.safeString(order, "type") },
            { "timeInForce", this.safeString(order, "time_in_force") },
            { "postOnly", this.safeBool(order, "post_only") },
            { "reduceOnly", null },
            { "side", side },
            { "price", this.parseNumber(price) },
            { "triggerPrice", this.safeNumber(order, "stop_price") },
            { "takeProfitPrice", null },
            { "stopLossPrice", null },
            { "cost", this.parseNumber(cost) },
            { "average", this.safeNumber(order, "price_avg") },
            { "amount", this.parseNumber(amount) },
            { "filled", this.parseNumber(filled) },
            { "remaining", this.parseNumber(remaining) },
            { "trades", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", feeCurrency },
                { "cost", this.safeNumber(order, "fee_paid") },
            } },
        });
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        object network = this.safeDict(depositAddress, "network");
        object networkId = this.safeString(network, "code");
        object currencyCode = this.safeCurrencyCode(null, currency);
        object unifiedNetwork = this.networkIdToCode(networkId, currencyCode);
        return new Dictionary<string, object>() {
            { "address", this.safeString(depositAddress, "address") },
            { "tag", this.safeString(depositAddress, "tag") },
            { "currency", currencyCode },
            { "network", unifiedNetwork },
            { "info", depositAddress },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "SUBMITTING", "pending" },
            { "SUBMITTED", "pending" },
            { "REJECTED", "failed" },
            { "CANCELLED", "canceled" },
            { "ACCEPTED", "ok" },
            { "WARNING", "pending" },
            { "UNBLOCKED", "pending" },
            { "BLOCKED", "pending" },
            { "PROCESSING", "pending" },
            { "CANCELED", "canceled" },
            { "FAILED", "failed" },
            { "DONE", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        object cryptoDetails = this.safeDict(transaction, "details_crypto");
        object address = this.safeString2(cryptoDetails, "receiving_address", "destination_address");
        object sn = this.safeString(transaction, "sn");
        object type = "withdrawal";
        if (isTrue(isTrue(!isEqual(sn, null)) && isTrue(isEqual(getValue(sn, 0), "D"))))
        {
            type = "deposit";
        }
        object fee = this.safeString(transaction, "fee", "0");
        object amount = this.safeString(transaction, "amount");
        object currencySymbol = this.safeString(transaction, "currency_symbol");
        object actualAmount = amount;
        object currencyCode = this.safeCurrencyCode(currencySymbol);
        object status = this.parseTransactionStatus(this.safeString(transaction, "state"));
        object created_at = this.safeString(transaction, "created_at");
        object timestamp = this.parseDate(created_at);
        object datetime = this.iso8601(timestamp);
        if (isTrue(isTrue(!isEqual(fee, null)) && isTrue(!isEqual(amount, null))))
        {
            // actualAmount = amount - fee;
            actualAmount = Precise.stringSub(amount, fee);
        }
        object feeRate = Precise.stringDiv(fee, actualAmount);
        object feeObj = new Dictionary<string, object>() {
            { "cost", this.parseNumber(fee) },
            { "currency", currencyCode },
            { "rate", this.parseNumber(feeRate) },
        };
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString(transaction, "sn") },
            { "txid", this.safeString(cryptoDetails, "transaction_id") },
            { "timestamp", timestamp },
            { "datetime", datetime },
            { "network", this.safeString(transaction, "network_code") },
            { "address", address },
            { "addressTo", address },
            { "addressFrom", null },
            { "tag", this.safeString(transaction, "destination_tag") },
            { "tagTo", this.safeString(transaction, "destination_tag") },
            { "tagFrom", null },
            { "type", type },
            { "amount", this.parseNumber(amount) },
            { "currency", currencyCode },
            { "status", status },
            { "updated", null },
            { "fee", feeObj },
            { "comment", null },
            { "internal", null },
        };
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "DEPOSITING", "transaction" },
            { "WITHDRAWING", "transaction" },
            { "TRADING", "trade" },
            { "INTERNAL_TRANSFERING", "transfer" },
            { "OTHERS", "transaction" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        // {
        //     "uuid": "f8e9f2d6-3c1e-4f2d-8f8e-9f2d6c1e4f2d",
        //     "amount": "0.0001",
        //     "balance": "0.0002",
        //     "created_at": "2021-07-01T12:00:00Z",
        //     "currency_symbol": "btc",
        //     "fee": "0.0001",
        //     "locked": "0.0001",
        //     "locked_amount": "0.0001",
        //     "reason_type": "DEPOSITING"
        // }
        object id = this.safeString(item, "uuid");
        object createdAt = this.safeString(item, "created_at");
        object timestamp = this.parse8601(createdAt);
        object reasonType = this.safeString(item, "reason_type");
        object type = this.parseLedgerEntryType(reasonType);
        object exchangeSymbol = this.safeString(item, "currency_symbol");
        object currencySymbol = this.safeCurrencyCode(exchangeSymbol);
        object direction = "in";
        object amount = this.safeNumber(item, "amount");
        object realAmount = amount;
        object balance = this.safeNumber(item, "balance");
        object fee = new Dictionary<string, object>() {
            { "cost", this.safeNumber(item, "fee") },
            { "currency", currencySymbol },
        };
        if (isTrue(isLessThan(amount, 0)))
        {
            direction = "out";
            realAmount = multiply(amount, -1);
        }
        return new Dictionary<string, object>() {
            { "id", id },
            { "info", item },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "direction", direction },
            { "account", null },
            { "referenceId", null },
            { "referenceAccount", null },
            { "type", type },
            { "currency", currencySymbol },
            { "amount", realAmount },
            { "before", subtract(balance, amount) },
            { "after", balance },
            { "status", "ok" },
            { "fee", fee },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= new List<object>();
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object version = getValue(api, 0);
        object urlPath = getValue(api, 1);
        object fullPath = add(add(add("/rest/", version), "/"), this.implodeParams(path, parameters));
        if (isTrue(isEqual(version, "status")))
        {
            fullPath = "/status";
            urlPath = "status";
        }
        object url = add(getValue(getValue(this.urls, "api"), urlPath), fullPath);
        parameters = this.omit(parameters, this.extractParams(path));
        object timestamp = this.milliseconds();
        object query = "";
        object signatureQuery = "";
        if (isTrue(isEqual(method, "GET")))
        {
            object paramKeys = new List<object>(((IDictionary<string,object>)parameters).Keys);
            object paramKeysLength = getArrayLength(paramKeys);
            if (isTrue(isGreaterThan(paramKeysLength, 0)))
            {
                query = this.urlencode(parameters);
                url = add(url, add("?", query));
            }
            for (object i = 0; isLessThan(i, getArrayLength(paramKeys)); postFixIncrement(ref i))
            {
                object key = getValue(paramKeys, i);
                object value = this.safeString(parameters, key);
                if (isTrue(!isEqual(value, null)))
                {
                    signatureQuery = add(signatureQuery, add(add(key, "="), value));
                }
                if (isTrue(isLessThan(i, subtract(paramKeysLength, 1))))
                {
                    signatureQuery = add(signatureQuery, "&");
                }
            }
        }
        if (isTrue(isTrue(isEqual(method, "POST")) || isTrue(isEqual(method, "PUT"))))
        {
            body = this.json(parameters);
        }
        object bodyToSignature = "";
        if (isTrue(!isEqual(body, null)))
        {
            bodyToSignature = body;
        }
        headers = new Dictionary<string, object>() {
            { "Content-Type", "application/json" },
        };
        if (isTrue(isEqual(urlPath, "private")))
        {
            this.checkRequiredCredentials();
            object preHash = add(add(add(add(this.numberToString(timestamp), method), fullPath), signatureQuery), bodyToSignature);
            object signature = this.hmac(this.encode(preHash), this.encode(this.secret), sha256, "hex");
            ((IDictionary<string,object>)headers)["X-FB-ACCESS-KEY"] = this.apiKey;
            ((IDictionary<string,object>)headers)["X-FB-ACCESS-TIMESTAMP"] = this.numberToString(timestamp);
            ((IDictionary<string,object>)headers)["X-FB-ACCESS-SIGNATURE"] = signature;
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        object error = this.safeDict(response, "error");
        object code = this.safeString(error, "code");
        object details = this.safeList(error, "details");
        object message = this.safeString(error, "message");
        object detailsString = "";
        if (isTrue(details))
        {
            for (object i = 0; isLessThan(i, getArrayLength(details)); postFixIncrement(ref i))
            {
                detailsString = add(add(detailsString, getValue(details, i)), " ");
            }
        }
        if (isTrue(!isEqual(error, null)))
        {
            object feedback = add(add(add(add(this.id, " "), message), " details: "), detailsString);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), detailsString, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
