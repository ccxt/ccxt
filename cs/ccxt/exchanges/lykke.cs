namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class lykke : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "lykke" },
            { "name", "Lykke" },
            { "countries", new List<object>() {"UK"} },
            { "version", "2" },
            { "rateLimit", 200 },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createOrder", true },
                { "createStopLimitOrder", false },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "editOrder", false },
                { "fetchBalance", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", false },
                { "fetchDepositsWithdrawals", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", null },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", false },
                { "fetchOrderTrades", false },
                { "fetchPosition", false },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsForSymbol", false },
                { "fetchPositionsHistory", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", false },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTransactionFees", false },
                { "fetchTransactions", "emulated" },
                { "fetchWithdrawals", false },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "withdraw", true },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", false },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/155840500-1ea4fdf0-47c0-4daa-9597-c6c1cd51b9ec.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://hft-apiv2.lykke.com/api" },
                    { "private", "https://hft-apiv2.lykke.com/api" },
                } },
                { "www", "https://www.lykke.com" },
                { "doc", new List<object>() {"https://hft-apiv2.lykke.com/swagger/ui/index.html", "https://lykkecity.github.io/Trading-API"} },
                { "fees", "https://support.lykke.com/hc/en-us/articles/115002141125-What-are-the-fees-and-charges-" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "assetpairs", 2.5 },
                        { "assetpairs/{id}", 2.5 },
                        { "assets", 2.5 },
                        { "assets/{id}", 2.5 },
                        { "isalive", 2.5 },
                        { "orderbooks", 2.5 },
                        { "tickers", 2.5 },
                        { "prices", 2.5 },
                        { "trades/public/{assetPairId}", 2.5 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "balance", 2.5 },
                        { "trades", 2.5 },
                        { "trades/order/{orderId}", 2.5 },
                        { "orders/active", 1 },
                        { "orders/closed", 1 },
                        { "orders/{orderId}", 1 },
                        { "operations", 2.5 },
                        { "operations/deposits/addresses", 2.5 },
                        { "operations/deposits/addresses/{assetId}", 2.5 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "orders/limit", 1 },
                        { "orders/market", 1 },
                        { "orders/bulk", 1 },
                        { "operations/withdrawals", 2.5 },
                        { "operations/deposits/addresses", 2.5 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "orders", 1 },
                        { "orders/{orderId}", 1 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", true },
                    { "maker", 0 },
                    { "taker", 0 },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "1001", typeof(ExchangeError) },
                    { "1100", typeof(ExchangeError) },
                    { "1101", typeof(ExchangeError) },
                    { "2000", typeof(BadRequest) },
                    { "2001", typeof(InsufficientFunds) },
                    { "2202", typeof(DuplicateOrderId) },
                    { "2003", typeof(ExchangeError) },
                    { "2004", typeof(NotSupported) },
                    { "2005", typeof(ExchangeError) },
                    { "2006", typeof(InsufficientFunds) },
                    { "2007", typeof(InsufficientFunds) },
                    { "2008", typeof(InsufficientFunds) },
                    { "2009", typeof(ExchangeError) },
                    { "2010", typeof(InsufficientFunds) },
                    { "2011", typeof(InvalidOrder) },
                    { "2012", typeof(InvalidOrder) },
                    { "2013", typeof(InvalidOrder) },
                    { "2014", typeof(InvalidOrder) },
                    { "2015", typeof(InvalidOrder) },
                    { "2016", typeof(InvalidOrder) },
                    { "2017", typeof(InvalidOrder) },
                    { "2018", typeof(InvalidOrder) },
                    { "2019", typeof(InvalidOrder) },
                    { "2020", typeof(InvalidOrder) },
                    { "2021", typeof(InvalidOrder) },
                    { "2022", typeof(InvalidOrder) },
                    { "2023", typeof(ExchangeError) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {} },
        });
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name lykke#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://lykkecity.github.io/Trading-API/#get-all-assets
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetAssets(parameters);
        object currencies = this.safeValue(response, "payload", new List<object>() {});
        //
        //     {
        //         "payload":[
        //             {
        //                 "assetId":"115a60c2-0da1-40f9-a7f2-41da723b9074",
        //                 "name":"Monaco Token",
        //                 "symbol":"MCO",
        //                 "accuracy":6,
        //                 "multiplierPower":8,
        //                 "assetAddress":"",
        //                 "blockchainIntegrationLayerId":"",
        //                 "blockchain":"ethereum",
        //                 "type":"erc20Token",
        //                 "isTradable":true,
        //                 "isTrusted":true,
        //                 "kycNeeded":false,
        //                 "blockchainWithdrawal":true,
        //                 "cashoutMinimalAmount":0.1,
        //                 "lowVolumeAmount":null,
        //                 "lykkeEntityId":"LYKKE NL",
        //                 "siriusAssetId":0,
        //                 "siriusBlockchainId":null,
        //                 "blockchainIntegrationType":"none",
        //                 "blockchainDepositEnabled":false,
        //                 "isDisabled":false
        //             }
        //         ],
        //         "error":null
        //     }
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currency = getValue(currencies, i);
            object id = this.safeString(currency, "assetId");
            object code = this.safeString(currency, "symbol");
            object name = this.safeString(currency, "name");
            object rawType = this.safeString(currency, "type");
            object type = ((bool) isTrue((isEqual(rawType, "erc20Token")))) ? "crypto" : "other";
            object deposit = this.safeValue(currency, "blockchainDepositEnabled");
            object withdraw = this.safeValue(currency, "blockchainWithdrawal");
            object isDisabled = this.safeValue(currency, "isDisabled");
            object active = !isTrue(isDisabled);
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "code", code },
                { "info", currency },
                { "type", type },
                { "name", name },
                { "active", active },
                { "deposit", deposit },
                { "withdraw", withdraw },
                { "fee", null },
                { "precision", this.parseNumber(this.parsePrecision(this.safeString(currency, "accuracy"))) },
                { "limits", new Dictionary<string, object>() {
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.safeValue(currency, "cashoutMinimalAmount") },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeValue(currency, "lowVolumeAmount") },
                        { "max", null },
                    } },
                } },
                { "networks", new Dictionary<string, object>() {} },
            };
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name lykke#fetchMarkets
        * @description retrieves data on all markets for lykke
        * @see https://lykkecity.github.io/Trading-API/#get-asset-by-id
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetAssetpairs(parameters);
        object markets = this.safeValue(response, "payload", new List<object>() {});
        //
        //     {
        //         "payload":[
        //             {
        //                 "assetPairId":"AAVEBTC",
        //                 "baseAssetId":"c9e55548-dae5-44fc-bebd-e72249cb19f3",
        //                 "quoteAssetId":"BTC",
        //                 "name":"AAVE/BTC",
        //                 "priceAccuracy":6,
        //                 "baseAssetAccuracy":6,
        //                 "quoteAssetAccuracy":8,
        //                 "minVolume":0.001,
        //                 "minOppositeVolume":0.0001
        //             }
        //         ],
        //         "error":null
        //     }
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object id = this.safeString(market, "assetPairId");
            object name = this.safeString(market, "name");
            object baseAssetId = this.safeString(market, "baseAssetId");
            object quoteAssetId = this.safeString(market, "quoteAssetId");
            var baseIdquoteIdVariable = ((string)name).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
            var baseId = ((IList<object>) baseIdquoteIdVariable)[0];
            var quoteId = ((IList<object>) baseIdquoteIdVariable)[1];
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object symbol = add(add(bs, "/"), quote);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "baseId", baseAssetId },
                { "quoteId", quoteAssetId },
                { "settle", null },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "contract", false },
                { "active", true },
                { "linear", null },
                { "inverse", null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "baseAssetAccuracy"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "priceAccuracy"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minVolume") },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minOppositeVolume") },
                        { "max", null },
                    } },
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", market },
            });
        }
        return result;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // fetchTickers
        //
        //     publicGetTickers
        //
        //     {
        //         "assetPairId":"BTCUSD",
        //         "volumeBase":2.56905016,
        //         "volumeQuote":95653.8730,
        //         "priceChange":-0.0367945778541765034194707584,
        //         "lastPrice":36840.0,
        //         "high":38371.645,
        //         "low":35903.356,
        //         "timestamp":1643295740729
        //     }
        //
        // fetchTicker
        //
        //     publicGetTickers
        //
        //     {
        //         "assetPairId":"BTCUSD",
        //         "volumeBase":2.56905016,
        //         "volumeQuote":95653.8730,
        //         "priceChange":-0.0367945778541765034194707584,
        //         "lastPrice":36840.0,
        //         "high":38371.645,
        //         "low":35903.356,
        //         "timestamp":1643295740729
        //     }
        //
        //     publicGetPrices
        //
        //     {
        //         "assetPairId":"BTCUSD",
        //         "bid":36181.521,
        //         "ask":36244.492,
        //         "timestamp":1643305510990
        //     }
        //
        object timestamp = null; // temporary bug in lykke api, returns unrealistic numbers
        object marketId = this.safeString(ticker, "assetPairId");
        market = this.safeMarket(marketId, market);
        object close = this.safeString(ticker, "lastPrice");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", this.safeString(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(ticker, "bid") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "ask") },
            { "askVolume", null },
            { "vwap", null },
            { "open", null },
            { "close", close },
            { "last", close },
            { "previousClose", null },
            { "change", this.safeString(ticker, "priceChange") },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "volumeBase") },
            { "quoteVolume", this.safeString(ticker, "volumeQuote") },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name lykke#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://lykkecity.github.io/Trading-API/#get-current-prices
        * @see https://lykkecity.github.io/Trading-API/#24hr-ticker-price-change-statistics
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "assetPairIds", getValue(market, "id") },
        };
        // publicGetTickers or publicGetPrices
        object method = this.safeString(this.options, "fetchTickerMethod", "publicGetTickers");
        object response = null;
        if (isTrue(isEqual(method, "publicGetPrices")))
        {
            response = await this.publicGetPrices(this.extend(request, parameters));
        } else
        {
            response = await this.publicGetTickers(this.extend(request, parameters));
        }
        object ticker = this.safeValue(response, "payload", new List<object>() {});
        //
        // publicGetTickers
        //
        //     {
        //         "payload":[
        //             {
        //                 "assetPairId":"BTCUSD",
        //                 "volumeBase":0.78056880,
        //                 "volumeQuote":29782.5169,
        //                 "priceChange":0.0436602362590968619931324699,
        //                 "lastPrice":38626.885,
        //                 "high":38742.896,
        //                 "low":36872.498,
        //                 "timestamp":1643687822840
        //             }
        //         ],
        //         "error":null
        //     }
        //
        // publicGetPrices
        //
        //     {
        //         "payload":[
        //             {
        //                 "assetPairId":"BTCUSD",
        //                 "bid":38597.936,
        //                 "ask":38640.311,
        //                 "timestamp":1643688350847
        //             }
        //         ],
        //         "error":null
        //     }
        //
        return this.parseTicker(this.safeValue(ticker, 0, new Dictionary<string, object>() {}), market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name lykke#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://lykkecity.github.io/Trading-API/#24hr-ticker-price-change-statistics
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetTickers(parameters);
        object tickers = this.safeValue(response, "payload", new List<object>() {});
        //
        //     {
        //         "payload":[
        //             {
        //                 "assetPairId":"BTCUSD",
        //                 "volumeBase":0.78056880,
        //                 "volumeQuote":29782.5169,
        //                 "priceChange":0.0436602362590968619931324699,
        //                 "lastPrice":38626.885,
        //                 "high":38742.896,
        //                 "low":36872.498,
        //                 "timestamp":1643687822840
        //             }
        //         ],
        //         "error":null
        //     }
        //
        return this.parseTickers(tickers, symbols);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name lykke#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://lykkecity.github.io/Trading-API/#asset-pair-order-book-ticker
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "assetPairId", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["depth"] = limit; // default 0
        }
        object response = await this.publicGetOrderbooks(this.extend(request, parameters));
        object payload = this.safeValue(response, "payload", new List<object>() {});
        //
        //     {
        //         "payload":[
        //             {
        //                 "assetPairId": "BTCUSD",
        //                 "timestamp": "1643298038203",
        //                 "bids": [
        //                     {
        //                         "v":0.59034382,
        //                         "p":36665.329
        //                     }
        //                 ],
        //                 "asks": [
        //                     {
        //                         "v":-0.003,
        //                         "p":36729.686
        //                     }
        //                 ]
        //             }
        //         ],
        //         "error":null
        //     }
        //
        object orderbook = this.safeValue(payload, 0, new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(orderbook, "timestamp");
        return this.parseOrderBook(orderbook, getValue(market, "symbol"), timestamp, "bids", "asks", "p", "v");
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        //  public fetchTrades
        //
        //     {
        //         "id":"71df1f0c-be4e-4d45-b809-c108fad5f2a8",
        //         "assetPairId":"BTCUSD",
        //         "timestamp":1643345958414,
        //         "volume":0.00010996,
        //         "price":37205.723,
        //         "side":"buy"
        //      }
        //
        //  private fetchMyTrades
        //         {
        //             "id":"813a3ffa-1c4b-45cb-b13f-1c077ea2748b",
        //             "timestamp":1644155923357,
        //             "assetPairId":"BCHEUR",
        //             "orderId":"1b367978-7e4f-454b-b870-64040d484443",
        //             "role":"Taker",
        //             "side":"sell",
        //             "price":280.569,
        //             "baseVolume":0.01,
        //             "quoteVolume":2.8056,
        //             "baseAssetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
        //             "quoteAssetId":"EUR",
        //             "fee":null
        //         }
        //
        object marketId = this.safeString(trade, "assetPairId");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object id = this.safeString2(trade, "id", "id");
        object orderId = this.safeString(trade, "orderId");
        object timestamp = this.safeInteger(trade, "timestamp");
        object price = this.safeString2(trade, "price", "price");
        object amount = this.safeString2(trade, "volume", "amount");
        if (isTrue(isEqual(amount, null)))
        {
            amount = this.safeString2(trade, "baseVolume", "amount");
        }
        object side = this.safeStringLower(trade, "side");
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", null },
            { "order", orderId },
            { "side", side },
            { "takerOrMaker", null },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", null },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name lykke#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://lykkecity.github.io/Trading-API/#get-public-trades
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "assetPairId", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["take"] = limit;
        }
        object response = await this.publicGetTradesPublicAssetPairId(this.extend(request, parameters));
        object result = this.safeValue(response, "payload", new List<object>() {});
        //
        //     {
        //         "payload":[
        //             {
        //                 "id":"71df1f0c-be4e-4d45-b809-c108fad5f2a8",
        //                 "assetPairId":"BTCUSD",
        //                 "timestamp":1643345958414,
        //                 "volume":0.00010996,
        //                 "price":37205.723,
        //                 "side":"buy"
        //             }
        //         ],
        //         "error":null
        //     }
        //
        return this.parseTrades(result, market, since, limit);
    }

    public override object parseBalance(object response)
    {
        //
        //     [
        //         {
        //             "assetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
        //             "available":0.1,
        //             "reserved":0.0,
        //             "timestamp":1644146723620
        //         }
        //     ]
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object balance = getValue(response, i);
            object currencyId = this.safeString(balance, "assetId");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            object free = this.safeString(balance, "available");
            object used = this.safeString(balance, "reserved");
            ((IDictionary<string,object>)account)["free"] = free;
            ((IDictionary<string,object>)account)["used"] = used;
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name lykke#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://lykkecity.github.io/Trading-API/#get-the-current-balance
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetBalance(parameters);
        object payload = this.safeValue(response, "payload", new List<object>() {});
        //
        //     {
        //         "payload":[
        //             {
        //                 "assetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
        //                 "available":0.1,
        //                 "reserved":0.0,
        //                 "timestamp":1644146723620
        //             }
        //         ],
        //         "error":null
        //     }
        //
        return this.parseBalance(payload);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "Open", "open" },
            { "Pending", "open" },
            { "InOrderBook", "open" },
            { "Processing", "open" },
            { "Matched", "closed" },
            { "Cancelled", "canceled" },
            { "Rejected", "rejected" },
            { "Replaced", "canceled" },
            { "Placed", "open" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        //     {
        //         "id":"1b367978-7e4f-454b-b870-64040d484443",
        //         "timestamp":1644155923357,
        //         "lastTradeTimestamp":1644155923357,
        //         "status":"Matched",
        //         "assetPairId":"BCHEUR",
        //         "type":"Market",
        //         "side":"Sell",
        //         "price":280.569,
        //         "volume":0.01,
        //         "filledVolume":0.01,
        //         "remainingVolume":0.0,
        //         "cost":2.80569
        //     }
        //
        object id = this.safeString(order, "id");
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object marketId = this.safeString(order, "assetPairId");
        object symbol = this.safeSymbol(marketId, market);
        object type = this.safeStringLower(order, "type");
        object lastTradeTimestamp = this.safeInteger(order, "lastTradeTimestamp");
        object timestamp = this.safeInteger(order, "timestamp");
        object price = this.safeString(order, "price");
        object side = this.safeStringLower(order, "side");
        object amount = this.safeString(order, "volume");
        object remaining = this.safeString(order, "remainingVolume");
        object filled = this.safeString(order, "filledVolume");
        object cost = this.safeString(order, "cost");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "amount", amount },
            { "cost", cost },
            { "average", null },
            { "filled", filled },
            { "remaining", remaining },
            { "status", status },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name lykke#createOrder
        * @description create a trade order
        * @see https://lykkecity.github.io/Trading-API/#place-a-limit-order
        * @see https://lykkecity.github.io/Trading-API/#place-a-market-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object query = new Dictionary<string, object>() {
            { "assetPairId", getValue(market, "id") },
            { "side", this.capitalize(side) },
            { "volume", parseFloat(this.amountToPrecision(getValue(market, "symbol"), amount)) },
        };
        if (isTrue(isEqual(type, "limit")))
        {
            ((IDictionary<string,object>)query)["price"] = parseFloat(this.priceToPrecision(getValue(market, "symbol"), price));
        }
        object result = null;
        if (isTrue(isEqual(this.capitalize(type), "Market")))
        {
            result = await this.privatePostOrdersMarket(this.extend(query, parameters));
        } else
        {
            result = await this.privatePostOrdersLimit(this.extend(query, parameters));
        }
        //
        // market
        //
        //         {
        //             "payload":{
        //                 "orderId":"2b98ec26-8410-49b6-9f37-1fb2150e2299",
        //                 "price":280.699
        //             },
        //             "error":null
        //         }
        //
        // limit
        //
        //         {
        //             "payload":{
        //                 "orderId":"27be8802-30be-40ca-bf40-ec886b309c5b"
        //             },
        //             "error":null
        //         }
        //
        object payload = this.safeValue(result, "payload");
        object id = this.safeString(payload, "orderId");
        if (isTrue(isEqual(type, "market")))
        {
            price = this.safeNumber(payload, "price");
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "info", result },
            { "clientOrderId", null },
            { "timestamp", null },
            { "datetime", null },
            { "lastTradeTimestamp", null },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "average", null },
            { "filled", null },
            { "remaining", null },
            { "status", null },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name lykke#cancelOrder
        * @description cancels an open order
        * @see https://lykkecity.github.io/Trading-API/#cancel-orders-by-id
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        //
        //     {
        //         "payload":null,
        //         "error":null
        //     }
        //
        object response = await this.privateDeleteOrdersOrderId(this.extend(request, parameters));
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", response },
        });
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name lykke#cancelAllOrders
        * @description cancel all open orders
        * @see https://lykkecity.github.io/Trading-API/#mass-cancel-orders
        * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["assetPairId"] = getValue(market, "id");
        }
        //
        //     {
        //         "payload":null,
        //         "error":null
        //     }
        //
        object response = await this.privateDeleteOrders(this.extend(request, parameters));
        return new List<object> {this.safeOrder(new Dictionary<string, object>() {
    { "info", response },
})};
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name lykke#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://lykkecity.github.io/Trading-API/#get-order-by-id
        * @param {string} symbol not used by lykke fetchOrder
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        object response = await this.privateGetOrdersOrderId(this.extend(request, parameters));
        object payload = this.safeValue(response, "payload");
        //
        //     {
        //         "payload":{
        //             "id":"1b367978-7e4f-454b-b870-64040d484443",
        //             "timestamp":1644155923357,
        //             "lastTradeTimestamp":1644155923357,
        //             "status":"Matched",
        //             "assetPairId":"BCHEUR",
        //             "type":"Market",
        //             "side":"Sell",
        //             "price":280.569,
        //             "volume":0.01,
        //             "filledVolume":0.01,
        //             "remainingVolume":0.0,
        //             "cost":2.80569
        //         },
        //         "error":null
        //     }
        //
        return this.parseOrder(payload);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name lykke#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://lykkecity.github.io/Trading-API/#get-active-or-closed-orders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["take"] = limit;
        }
        object response = await this.privateGetOrdersActive(this.extend(request, parameters));
        object payload = this.safeValue(response, "payload");
        //
        //     {
        //         "payload":[
        //             {
        //                 "id":"b26f58f5-8542-4b4c-9815-91562b523cc3",
        //                 "timestamp":1644157177155,
        //                 "lastTradeTimestamp":null,
        //                 "status":"Placed",
        //                 "assetPairId":"BCHEUR",
        //                 "type":"Limit",
        //                 "side":"Sell",
        //                 "price":666.666,
        //                 "volume":0.01,
        //                 "filledVolume":0.00,
        //                 "remainingVolume":0.01,
        //                 "cost":0.00000
        //             }
        //         ],
        //         "error":null
        //     }
        //
        return this.parseOrders(payload, market, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name lykke#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://lykkecity.github.io/Trading-API/#get-active-or-closed-orders
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["take"] = limit;
        }
        object response = await this.privateGetOrdersClosed(this.extend(request, parameters));
        object payload = this.safeValue(response, "payload");
        //
        //     {
        //         "payload":[
        //             {
        //                 "id":"1b367978-7e4f-454b-b870-64040d484443",
        //                 "timestamp":1644155923357,
        //                 "lastTradeTimestamp":1644155923357,
        //                 "status":"Matched",
        //                 "assetPairId":"BCHEUR",
        //                 "type":"Market",
        //                 "side":"Sell",
        //                 "price":280.569,
        //                 "volume":0.01,
        //                 "filledVolume":0.01,
        //                 "remainingVolume":0.0,
        //                 "cost":2.80569
        //             }
        //         ],
        //         "error":null
        //     }
        //
        return this.parseOrders(payload, market, since, limit);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name lykke#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://lykkecity.github.io/Trading-API/#get-trade-history
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["take"] = limit; // How many maximum items have to be returned, max 1000 default 100.
        }
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["assetPairId"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = since;
        }
        object response = await this.privateGetTrades(this.extend(request, parameters));
        object payload = this.safeValue(response, "payload");
        //
        //     {
        //         "payload":[
        //             {
        //                 "id":"813a3ffa-1c4b-45cb-b13f-1c077ea2748b",
        //                 "timestamp":1644155923357,
        //                 "assetPairId":"BCHEUR",
        //                 "orderId":"1b367978-7e4f-454b-b870-64040d484443",
        //                 "role":"Taker",
        //                 "side":"sell",
        //                 "price":280.569,
        //                 "baseVolume":0.01,
        //                 "quoteVolume":2.8056,
        //                 "baseAssetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
        //                 "quoteAssetId":"EUR",
        //                 "fee":null
        //             }
        //         ],
        //         "error":null
        //     }
        //
        return this.parseTrades(payload, market, since, limit);
    }

    public override object parseBidAsk(object bidask, object priceKey = null, object amountKey = null, object countOrIdKey = null)
    {
        priceKey ??= 0;
        amountKey ??= 1;
        countOrIdKey ??= 2;
        object price = this.safeString(bidask, priceKey);
        object amount = Precise.stringAbs(this.safeString(bidask, amountKey));
        return new List<object> {this.parseNumber(price), this.parseNumber(amount)};
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name lykke#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://lykkecity.github.io/Trading-API/#get-deposit-address-for-a-given-asset
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "assetId", this.safeString(currency, "id") },
        };
        object response = await this.privateGetOperationsDepositsAddressesAssetId(this.extend(request, parameters));
        //
        //     {
        //         "assetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
        //         "symbol":"BCH",
        //         "address":null,
        //         "baseAddress":null,
        //         "addressExtension":null,
        //         "state":"Active"
        //     }
        //
        object address = this.safeString(response, "baseAddress");
        object tag = this.safeString(response, "addressExtension");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", null },
            { "info", response },
        };
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // withdraw
        //     "3035b1ad-2005-4587-a986-1f7966be78e0"
        //
        // fetchDepositsWithdrawals
        //     {
        //         "operationId":"787201c8-f1cc-45c0-aec1-fa06eeea426b",
        //         "assetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
        //         "totalVolume":0.1,
        //         "fee":0.0,
        //         "type":"deposit",
        //         "timestamp":1644146723620
        //     }
        //
        object id = null;
        object assetId = null;
        object code = null;
        object amount = null;
        object fee = null;
        object type = null;
        object timestamp = null;
        if (isTrue((transaction is string)))
        {
            id = transaction;
        } else
        {
            id = this.safeString(transaction, "operationId");
            assetId = this.safeString(transaction, "assetId");
            code = this.safeCurrencyCode(assetId, currency);
            amount = this.safeNumber(transaction, "totalVolume");
            type = this.safeString(transaction, "type");
            timestamp = this.safeInteger(transaction, "timestamp");
            object feeCost = this.safeNumber(transaction, "fee");
            fee = new Dictionary<string, object>() {
                { "currency", code },
                { "cost", feeCost },
            };
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", null },
            { "addressFrom", null },
            { "address", null },
            { "addressTo", null },
            { "tagFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "type", type },
            { "amount", amount },
            { "currency", code },
            { "status", null },
            { "updated", null },
            { "internal", null },
            { "comment", null },
            { "fee", fee },
        };
    }

    public async override Task<object> fetchDepositsWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name lykke#fetchDepositsWithdrawals
        * @description fetch history of deposits and withdrawals
        * @see https://lykkecity.github.io/Trading-API/#get-the-history-of-withdrawals-and-deposits
        * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
        * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
        * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["take"] = limit;
        }
        object response = await this.privateGetOperations(this.extend(request, parameters));
        object payload = this.safeValue(response, "payload", new List<object>() {});
        //
        //     {
        //         "payload":[
        //             {
        //                 "operationId":"787201c8-f1cc-45c0-aec1-fa06eeea426b",
        //                 "assetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
        //                 "totalVolume":0.1,
        //                 "fee":0.0,
        //                 "type":"deposit",
        //                 "timestamp":1644146723620
        //             }
        //         ],
        //         "error":null
        //     }
        //
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        return this.parseTransactions(payload, currency, since, limit);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name lykke#withdraw
        * @description make a withdrawal
        * @see https://lykkecity.github.io/Trading-API/#withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkAddress(address);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "assetId", getValue(currency, "id") },
            { "volume", parseFloat(this.currencyToPrecision(code, amount)) },
            { "destinationAddress", address },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["destinationAddressExtension"] = tag;
        }
        object response = await this.privatePostOperationsWithdrawals(this.extend(request, parameters));
        //
        //     "3035b1ad-2005-4587-a986-1f7966be78e0"
        //
        return this.parseTransaction(response, currency);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(getValue(getValue(this.urls, "api"), api), "/"), this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        headers = new Dictionary<string, object>() {
            { "Accept", "application/json" },
            { "Content-Type", "application/json" },
        };
        if (isTrue(isEqual(api, "public")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else if (isTrue(isEqual(api, "private")))
        {
            if (isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE")))))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    url = add(url, add("?", this.urlencode(query)));
                }
            }
            this.checkRequiredCredentials();
            ((IDictionary<string,object>)headers)["Authorization"] = add("Bearer ", this.apiKey);
            if (isTrue(isEqual(method, "POST")))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
                {
                    body = this.json(parameters);
                }
            }
            if (isTrue(isEqual(path, "operations/withdrawals")))
            {
                ((IDictionary<string,object>)headers)["X-Request-ID"] = this.uuid();
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        object error = this.safeValue(response, "error", new Dictionary<string, object>() {});
        object errorCode = this.safeString(error, "code");
        if (isTrue(isTrue((!isEqual(errorCode, null))) && isTrue((!isEqual(errorCode, "0")))))
        {
            object feedback = add(add(this.id, " "), body);
            object message = this.safeString(error, "message");
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
