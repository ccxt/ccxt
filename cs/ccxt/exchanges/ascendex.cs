namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class ascendex : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "ascendex" },
            { "name", "AscendEX" },
            { "countries", new List<object>() {"SG"} },
            { "rateLimit", 400 },
            { "certified", false },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createOrder", true },
                { "createOrders", true },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", "emulated" },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", false },
                { "fetchLeverage", "emulated" },
                { "fetchLeverages", true },
                { "fetchLeverageTiers", true },
                { "fetchMarginMode", "emulated" },
                { "fetchMarginModes", true },
                { "fetchMarketLeverageTiers", "emulated" },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", false },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", false },
                { "fetchPosition", false },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", true },
                { "fetchTransactionFee", false },
                { "fetchTransactionFees", false },
                { "fetchTransactions", "emulated" },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", true },
                { "sandbox", true },
                { "setLeverage", true },
                { "setMarginMode", true },
                { "setPositionMode", false },
                { "transfer", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1" },
                { "5m", "5" },
                { "15m", "15" },
                { "30m", "30" },
                { "1h", "60" },
                { "2h", "120" },
                { "4h", "240" },
                { "6h", "360" },
                { "12h", "720" },
                { "1d", "1d" },
                { "1w", "1w" },
                { "1M", "1m" },
            } },
            { "version", "v2" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/112027508-47984600-8b48-11eb-9e17-d26459cc36c6.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "rest", "https://ascendex.com" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "rest", "https://api-test.ascendex-sandbox.com" },
                } },
                { "www", "https://ascendex.com" },
                { "doc", new List<object>() {"https://ascendex.github.io/ascendex-pro-api/#ascendex-pro-api-documentation"} },
                { "fees", "https://ascendex.com/en/feerate/transactionfee-traderate" },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://ascendex.com/en-us/register?inviteCode=EL6BXBQM" },
                    { "discount", 0.25 },
                } },
            } },
            { "api", new Dictionary<string, object>() {
                { "v1", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "assets", 1 },
                            { "products", 1 },
                            { "ticker", 1 },
                            { "barhist/info", 1 },
                            { "barhist", 1 },
                            { "depth", 1 },
                            { "trades", 1 },
                            { "cash/assets", 1 },
                            { "cash/products", 1 },
                            { "margin/assets", 1 },
                            { "margin/products", 1 },
                            { "futures/collateral", 1 },
                            { "futures/contracts", 1 },
                            { "futures/ref-px", 1 },
                            { "futures/market-data", 1 },
                            { "futures/funding-rates", 1 },
                            { "risk-limit-info", 1 },
                            { "exchange-info", 1 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "info", 1 },
                            { "wallet/transactions", 1 },
                            { "wallet/deposit/address", 1 },
                            { "data/balance/snapshot", 1 },
                            { "data/balance/history", 1 },
                        } },
                        { "accountCategory", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "balance", 1 },
                                { "order/open", 1 },
                                { "order/status", 1 },
                                { "order/hist/current", 1 },
                                { "risk", 1 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "order", 1 },
                                { "order/batch", 1 },
                            } },
                            { "delete", new Dictionary<string, object>() {
                                { "order", 1 },
                                { "order/all", 1 },
                                { "order/batch", 1 },
                            } },
                        } },
                        { "accountGroup", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "cash/balance", 1 },
                                { "margin/balance", 1 },
                                { "margin/risk", 1 },
                                { "futures/collateral-balance", 1 },
                                { "futures/position", 1 },
                                { "futures/risk", 1 },
                                { "futures/funding-payments", 1 },
                                { "order/hist", 1 },
                                { "spot/fee", 1 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "transfer", 1 },
                                { "futures/transfer/deposit", 1 },
                                { "futures/transfer/withdraw", 1 },
                            } },
                        } },
                    } },
                } },
                { "v2", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "assets", 1 },
                            { "futures/contract", 1 },
                            { "futures/collateral", 1 },
                            { "futures/pricing-data", 1 },
                            { "futures/ticker", 1 },
                            { "risk-limit-info", 1 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "data", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "order/hist", 1 },
                            } },
                        } },
                        { "get", new Dictionary<string, object>() {
                            { "account/info", 1 },
                        } },
                        { "accountGroup", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "order/hist", 1 },
                                { "futures/position", 1 },
                                { "futures/free-margin", 1 },
                                { "futures/order/hist/current", 1 },
                                { "futures/funding-payments", 1 },
                                { "futures/order/open", 1 },
                                { "futures/order/status", 1 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "futures/isolated-position-margin", 1 },
                                { "futures/margin-type", 1 },
                                { "futures/leverage", 1 },
                                { "futures/transfer/deposit", 1 },
                                { "futures/transfer/withdraw", 1 },
                                { "futures/order", 1 },
                                { "futures/order/batch", 1 },
                                { "futures/order/open", 1 },
                                { "subuser/subuser-transfer", 1 },
                                { "subuser/subuser-transfer-hist", 1 },
                            } },
                            { "delete", new Dictionary<string, object>() {
                                { "futures/order", 1 },
                                { "futures/order/batch", 1 },
                                { "futures/order/all", 1 },
                            } },
                        } },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "feeSide", "get" },
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.002") },
                    { "maker", this.parseNumber("0.002") },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "options", new Dictionary<string, object>() {
                { "account-category", "cash" },
                { "account-group", null },
                { "fetchClosedOrders", new Dictionary<string, object>() {
                    { "method", "v2PrivateDataGetOrderHist" },
                } },
                { "defaultType", "spot" },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "cash" },
                    { "swap", "futures" },
                    { "margin", "margin" },
                } },
                { "transfer", new Dictionary<string, object>() {
                    { "fillResponseFromRequest", true },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "BSC", add("BEP20 ", "(BSC)") },
                    { "ARB", "arbitrum" },
                    { "SOL", "Solana" },
                    { "AVAX", "avalanche C chain" },
                    { "OMNI", "Omni" },
                    { "TRC", "TRC20" },
                    { "TRX", "TRC20" },
                    { "ERC", "ERC20" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "BEP20 (BSC)", "BSC" },
                    { "arbitrum", "ARB" },
                    { "Solana", "SOL" },
                    { "avalanche C chain", "AVAX" },
                    { "Omni", "OMNI" },
                    { "TRC20", "TRC20" },
                    { "ERC20", "ERC20" },
                    { "GO20", "GO20" },
                    { "BEP2", "BEP2" },
                    { "Bitcoin", "BTC" },
                    { "Bitcoin ABC", "BCH" },
                    { "Litecoin", "LTC" },
                    { "Matic Network", "MATIC" },
                    { "xDai", "STAKE" },
                    { "Akash", "AKT" },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "1900", typeof(BadRequest) },
                    { "2100", typeof(AuthenticationError) },
                    { "5002", typeof(BadSymbol) },
                    { "6001", typeof(BadSymbol) },
                    { "6010", typeof(InsufficientFunds) },
                    { "60060", typeof(InvalidOrder) },
                    { "600503", typeof(InvalidOrder) },
                    { "100001", typeof(BadRequest) },
                    { "100002", typeof(BadRequest) },
                    { "100003", typeof(BadRequest) },
                    { "100004", typeof(BadRequest) },
                    { "100005", typeof(BadRequest) },
                    { "100006", typeof(BadRequest) },
                    { "100007", typeof(BadRequest) },
                    { "100008", typeof(BadSymbol) },
                    { "100009", typeof(AuthenticationError) },
                    { "100010", typeof(BadRequest) },
                    { "100011", typeof(BadRequest) },
                    { "100012", typeof(BadRequest) },
                    { "100013", typeof(BadRequest) },
                    { "100101", typeof(ExchangeError) },
                    { "150001", typeof(BadRequest) },
                    { "200001", typeof(AuthenticationError) },
                    { "200002", typeof(ExchangeError) },
                    { "200003", typeof(ExchangeError) },
                    { "200004", typeof(ExchangeError) },
                    { "200005", typeof(ExchangeError) },
                    { "200006", typeof(ExchangeError) },
                    { "200007", typeof(ExchangeError) },
                    { "200008", typeof(ExchangeError) },
                    { "200009", typeof(ExchangeError) },
                    { "200010", typeof(AuthenticationError) },
                    { "200011", typeof(ExchangeError) },
                    { "200012", typeof(ExchangeError) },
                    { "200013", typeof(ExchangeError) },
                    { "200014", typeof(PermissionDenied) },
                    { "200015", typeof(PermissionDenied) },
                    { "300001", typeof(InvalidOrder) },
                    { "300002", typeof(InvalidOrder) },
                    { "300003", typeof(InvalidOrder) },
                    { "300004", typeof(InvalidOrder) },
                    { "300005", typeof(InvalidOrder) },
                    { "300006", typeof(InvalidOrder) },
                    { "300007", typeof(InvalidOrder) },
                    { "300008", typeof(InvalidOrder) },
                    { "300009", typeof(InvalidOrder) },
                    { "300011", typeof(InsufficientFunds) },
                    { "300012", typeof(BadSymbol) },
                    { "300013", typeof(InvalidOrder) },
                    { "300014", typeof(InvalidOrder) },
                    { "300020", typeof(InvalidOrder) },
                    { "300021", typeof(AccountSuspended) },
                    { "300031", typeof(InvalidOrder) },
                    { "310001", typeof(InsufficientFunds) },
                    { "310002", typeof(InvalidOrder) },
                    { "310003", typeof(InvalidOrder) },
                    { "310004", typeof(BadSymbol) },
                    { "310005", typeof(InvalidOrder) },
                    { "510001", typeof(ExchangeError) },
                    { "900001", typeof(ExchangeError) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "BOND", "BONDED" },
                { "BTCBEAR", "BEAR" },
                { "BTCBULL", "BULL" },
                { "BYN", "BeyondFi" },
                { "PLN", "Pollen" },
            } },
        });
    }

    public virtual object getAccount(object parameters = null)
    {
        // get current or provided bitmax sub-account
        parameters ??= new Dictionary<string, object>();
        object account = this.safeValue(parameters, "account", getValue(this.options, "account"));
        object lowercaseAccount = ((string)account).ToLower();
        return this.capitalize(lowercaseAccount);
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object assets = await this.v1PublicGetAssets(parameters);
        //
        //     {
        //         "code":0,
        //         "data":[
        //             {
        //                 "assetCode" : "LTCBULL",
        //                 "assetName" : "3X Long LTC Token",
        //                 "precisionScale" : 9,
        //                 "nativeScale" : 4,
        //                 "withdrawalFee" : "0.2",
        //                 "minWithdrawalAmt" : "1.0",
        //                 "status" : "Normal"
        //             },
        //         ]
        //     }
        //
        object margin = await this.v1PublicGetMarginAssets(parameters);
        //
        //     {
        //         "code":0,
        //         "data":[
        //             {
        //                 "assetCode":"BTT",
        //                 "borrowAssetCode":"BTT-B",
        //                 "interestAssetCode":"BTT-I",
        //                 "nativeScale":0,
        //                 "numConfirmations":1,
        //                 "withdrawFee":"100.0",
        //                 "minWithdrawalAmt":"1000.0",
        //                 "statusCode":"Normal",
        //                 "statusMessage":"",
        //                 "interestRate":"0.001"
        //             }
        //         ]
        //     }
        //
        object cash = await this.v1PublicGetCashAssets(parameters);
        //
        //     {
        //         "code":0,
        //         "data":[
        //             {
        //                 "assetCode":"LTCBULL",
        //                 "nativeScale":4,
        //                 "numConfirmations":20,
        //                 "withdrawFee":"0.2",
        //                 "minWithdrawalAmt":"1.0",
        //                 "statusCode":"Normal",
        //                 "statusMessage":""
        //             }
        //         ]
        //     }
        //
        object assetsData = this.safeValue(assets, "data", new List<object>() {});
        object marginData = this.safeValue(margin, "data", new List<object>() {});
        object cashData = this.safeValue(cash, "data", new List<object>() {});
        object assetsById = this.indexBy(assetsData, "assetCode");
        object marginById = this.indexBy(marginData, "assetCode");
        object cashById = this.indexBy(cashData, "assetCode");
        object dataById = this.deepExtend(assetsById, marginById, cashById);
        object ids = new List<object>(((IDictionary<string,object>)dataById).Keys);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object id = getValue(ids, i);
            object currency = getValue(dataById, id);
            object code = this.safeCurrencyCode(id);
            object scale = this.safeString2(currency, "precisionScale", "nativeScale");
            object precision = this.parseNumber(this.parsePrecision(scale));
            object fee = this.safeNumber2(currency, "withdrawFee", "withdrawalFee");
            object status = this.safeString2(currency, "status", "statusCode");
            object active = (isEqual(status, "Normal"));
            object marginInside = (inOp(currency, "borrowAssetCode"));
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "code", code },
                { "info", currency },
                { "type", null },
                { "margin", marginInside },
                { "name", this.safeString(currency, "assetName") },
                { "active", active },
                { "deposit", null },
                { "withdraw", null },
                { "fee", fee },
                { "precision", precision },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", precision },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.safeNumber(currency, "minWithdrawalAmt") },
                        { "max", null },
                    } },
                } },
                { "networks", new Dictionary<string, object>() {} },
            };
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchMarkets
        * @description retrieves data on all markets for ascendex
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object products = await this.v1PublicGetProducts(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "symbol": "LBA/BTC",
        //                 "baseAsset": "LBA",
        //                 "quoteAsset": "BTC",
        //                 "status": "Normal",
        //                 "minNotional": "0.000625",
        //                 "maxNotional": "6.25",
        //                 "marginTradable": false,
        //                 "commissionType": "Quote",
        //                 "commissionReserveRate": "0.001",
        //                 "tickSize": "0.000000001",
        //                 "lotSize": "1"
        //             },
        //         ]
        //     }
        //
        object cash = await this.v1PublicGetCashProducts(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "symbol": "QTUM/BTC",
        //                 "displayName": "QTUM/BTC",
        //                 "domain": "BTC",
        //                 "tradingStartTime": 1569506400000,
        //                 "collapseDecimals": "0.0001,0.000001,0.00000001",
        //                 "minQty": "0.000000001",
        //                 "maxQty": "1000000000",
        //                 "minNotional": "0.000625",
        //                 "maxNotional": "12.5",
        //                 "statusCode": "Normal",
        //                 "statusMessage": "",
        //                 "tickSize": "0.00000001",
        //                 "useTick": false,
        //                 "lotSize": "0.1",
        //                 "useLot": false,
        //                 "commissionType": "Quote",
        //                 "commissionReserveRate": "0.001",
        //                 "qtyScale": 1,
        //                 "priceScale": 8,
        //                 "notionalScale": 4
        //             }
        //         ]
        //     }
        //
        object perpetuals = await this.v2PublicGetFuturesContract(parameters);
        //
        //    {
        //        "code": 0,
        //        "data": [
        //            {
        //                "symbol": "BTC-PERP",
        //                "status": "Normal",
        //                "displayName": "BTCUSDT",
        //                "settlementAsset": "USDT",
        //                "underlying": "BTC/USDT",
        //                "tradingStartTime": 1579701600000,
        //                "priceFilter": {
        //                    "minPrice": "1",
        //                    "maxPrice": "1000000",
        //                    "tickSize": "1"
        //                },
        //                "lotSizeFilter": {
        //                    "minQty": "0.0001",
        //                    "maxQty": "1000000000",
        //                    "lotSize": "0.0001"
        //                },
        //                "commissionType": "Quote",
        //                "commissionReserveRate": "0.001",
        //                "marketOrderPriceMarkup": "0.03",
        //                "marginRequirements": [
        //                    {
        //                        "positionNotionalLowerBound": "0",
        //                        "positionNotionalUpperBound": "50000",
        //                        "initialMarginRate": "0.01",
        //                        "maintenanceMarginRate": "0.006"
        //                    },
        //                    ...
        //                ]
        //            }
        //        ]
        //    }
        //
        object productsData = this.safeValue(products, "data", new List<object>() {});
        object productsById = this.indexBy(productsData, "symbol");
        object cashData = this.safeValue(cash, "data", new List<object>() {});
        object perpetualsData = this.safeValue(perpetuals, "data", new List<object>() {});
        object cashAndPerpetualsData = this.arrayConcat(cashData, perpetualsData);
        object cashAndPerpetualsById = this.indexBy(cashAndPerpetualsData, "symbol");
        object dataById = this.deepExtend(productsById, cashAndPerpetualsById);
        object ids = new List<object>(((IDictionary<string,object>)dataById).Keys);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object id = getValue(ids, i);
            object market = getValue(dataById, id);
            object settleId = this.safeValue(market, "settlementAsset");
            object settle = this.safeCurrencyCode(settleId);
            object status = this.safeString(market, "status");
            object domain = this.safeString(market, "domain");
            object active = false;
            if (isTrue(isTrue((isTrue((isEqual(status, "Normal"))) || isTrue((isEqual(status, "InternalTrading"))))) && isTrue((!isEqual(domain, "LeveragedETF")))))
            {
                active = true;
            }
            object spot = isEqual(settle, null);
            object swap = !isTrue(spot);
            object linear = ((bool) isTrue(swap)) ? true : null;
            object minQty = this.safeNumber(market, "minQty");
            object maxQty = this.safeNumber(market, "maxQty");
            object minPrice = this.safeNumber(market, "tickSize");
            object maxPrice = null;
            object underlying = this.safeString2(market, "underlying", "symbol");
            object parts = ((string)underlying).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
            object baseId = this.safeString(parts, 0);
            object quoteId = this.safeString(parts, 1);
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object symbol = add(add(bs, "/"), quote);
            if (isTrue(swap))
            {
                object lotSizeFilter = this.safeValue(market, "lotSizeFilter");
                minQty = this.safeNumber(lotSizeFilter, "minQty");
                maxQty = this.safeNumber(lotSizeFilter, "maxQty");
                object priceFilter = this.safeValue(market, "priceFilter");
                minPrice = this.safeNumber(priceFilter, "minPrice");
                maxPrice = this.safeNumber(priceFilter, "maxPrice");
                symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
            }
            object fee = this.safeNumber(market, "commissionReserveRate");
            object marginTradable = this.safeBool(market, "marginTradable", false);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", ((bool) isTrue(swap)) ? "swap" : "spot" },
                { "spot", spot },
                { "margin", ((bool) isTrue(spot)) ? marginTradable : null },
                { "swap", swap },
                { "future", false },
                { "option", false },
                { "active", active },
                { "contract", swap },
                { "linear", linear },
                { "inverse", ((bool) isTrue(swap)) ? !isTrue(linear) : null },
                { "taker", fee },
                { "maker", fee },
                { "contractSize", ((bool) isTrue(swap)) ? this.parseNumber("1") : null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.safeNumber(market, "lotSize") },
                    { "price", this.safeNumber(market, "tickSize") },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", minQty },
                        { "max", maxQty },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", minPrice },
                        { "max", maxPrice },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minNotional") },
                        { "max", this.safeNumber(market, "maxNotional") },
                    } },
                } },
                { "created", this.safeInteger(market, "tradingStartTime") },
                { "info", market },
            });
        }
        return result;
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the ascendex server
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int} the current integer timestamp in milliseconds from the ascendex server
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "requestTime", this.milliseconds() },
        };
        object response = await this.v1PublicGetExchangeInfo(this.extend(request, parameters));
        //
        //    {
        //        "code": 0,
        //        "data": {
        //            "requestTimeEcho": 1656560463601,
        //            "requestReceiveAt": 1656560464331,
        //            "latency": 730
        //        }
        //    }
        //
        object data = this.safeValue(response, "data");
        return this.safeInteger(data, "requestReceiveAt");
    }

    public async override Task<object> fetchAccounts(object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchAccounts
        * @description fetch all the accounts associated with a profile
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
        */
        parameters ??= new Dictionary<string, object>();
        object accountGroup = this.safeString(this.options, "account-group");
        object response = null;
        if (isTrue(isEqual(accountGroup, null)))
        {
            response = await this.v1PrivateGetInfo(parameters);
            //
            //     {
            //         "code":0,
            //         "data":{
            //             "email":"igor.kroitor@gmail.com",
            //             "accountGroup":8,
            //             "viewPermission":true,
            //             "tradePermission":true,
            //             "transferPermission":true,
            //             "cashAccount":["cshrHKLZCjlZ2ejqkmvIHHtPmLYqdnda"],
            //             "marginAccount":["martXoh1v1N3EMQC5FDtSj5VHso8aI2Z"],
            //             "futuresAccount":["futc9r7UmFJAyBY2rE3beA2JFxav2XFF"],
            //             "userUID":"U6491137460"
            //         }
            //     }
            //
            object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
            accountGroup = this.safeString(data, "accountGroup");
            ((IDictionary<string,object>)this.options)["account-group"] = accountGroup;
        }
        return new List<object>() {new Dictionary<string, object>() {
    { "id", accountGroup },
    { "type", null },
    { "code", null },
    { "info", response },
}};
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        object balances = this.safeValue(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object code = this.safeCurrencyCode(this.safeString(balance, "asset"));
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "availableBalance");
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "totalBalance");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public virtual object parseMarginBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        object balances = this.safeValue(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object code = this.safeCurrencyCode(this.safeString(balance, "asset"));
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "availableBalance");
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "totalBalance");
            object debt = this.safeString(balance, "borrowed");
            object interest = this.safeString(balance, "interest");
            ((IDictionary<string,object>)account)["debt"] = Precise.stringAdd(debt, interest);
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public virtual object parseSwapBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object collaterals = this.safeValue(data, "collaterals", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(collaterals)); postFixIncrement(ref i))
        {
            object balance = getValue(collaterals, i);
            object code = this.safeCurrencyCode(this.safeString(balance, "asset"));
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "balance");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://ascendex.github.io/ascendex-pro-api/#cash-account-balance
        * @see https://ascendex.github.io/ascendex-pro-api/#margin-account-balance
        * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#position
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.type] wallet type, 'spot', 'margin', or 'swap'
        * @param {string} [params.marginMode] 'cross' or undefined, for spot margin trading, value of 'isolated' is invalid
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object marketType = null;
        object marginMode = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBalance", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object isMargin = this.safeBool(parameters, "margin", false);
        object isCross = isEqual(marginMode, "cross");
        marketType = ((bool) isTrue((isTrue(isMargin) || isTrue(isCross)))) ? "margin" : marketType;
        parameters = this.omit(parameters, "margin");
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object accountCategory = this.safeString(accountsByType, marketType, "cash");
        object account = this.safeValue(this.accounts, 0, new Dictionary<string, object>() {});
        object accountGroup = this.safeString(account, "id");
        object request = new Dictionary<string, object>() {
            { "account-group", accountGroup },
        };
        if (isTrue(isTrue((isEqual(marginMode, "isolated"))) && isTrue((!isEqual(marketType, "swap")))))
        {
            throw new BadRequest ((string)add(this.id, " does not supported isolated margin trading")) ;
        }
        if (isTrue(isTrue((isEqual(accountCategory, "cash"))) || isTrue((isEqual(accountCategory, "margin")))))
        {
            ((IDictionary<string,object>)request)["account-category"] = accountCategory;
        }
        object response = null;
        if (isTrue(isTrue((isEqual(marketType, "spot"))) || isTrue((isEqual(marketType, "margin")))))
        {
            response = await this.v1PrivateAccountCategoryGetBalance(this.extend(request, parameters));
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            response = await this.v2PrivateAccountGroupGetFuturesPosition(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchBalance() is not currently supported for "), marketType), " markets")) ;
        }
        //
        // cash
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "asset": "BCHSV",
        //                 "totalBalance": "64.298000048",
        //                 "availableBalance": "64.298000048",
        //             },
        //         ]
        //     }
        //
        // margin
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "asset": "BCHSV",
        //                 "totalBalance": "64.298000048",
        //                 "availableBalance": "64.298000048",
        //                 "borrowed": "0",
        //                 "interest": "0",
        //             },
        //         ]
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        //             "ac": "FUTURES",
        //             "collaterals": [
        //                 {"asset":"ADA","balance":"0.355803","referencePrice":"1.05095","discountFactor":"0.9"},
        //                 {"asset":"USDT","balance":"0.000014519","referencePrice":"1","discountFactor":"1"}
        //             ],
        //         }j
        //     }
        //
        if (isTrue(isEqual(marketType, "swap")))
        {
            return this.parseSwapBalance(response);
        } else if (isTrue(isEqual(marketType, "margin")))
        {
            return this.parseMarginBalance(response);
        } else
        {
            return this.parseBalance(response);
        }
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v1PublicGetDepth(this.extend(request, parameters));
        //
        //     {
        //         "code":0,
        //         "data":{
        //             "m":"depth-snapshot",
        //             "symbol":"BTC-PERP",
        //             "data":{
        //                 "ts":1590223998202,
        //                 "seqnum":115444921,
        //                 "asks":[
        //                     ["9207.5","18.2383"],
        //                     ["9207.75","18.8235"],
        //                     ["9208","10.7873"],
        //                 ],
        //                 "bids":[
        //                     ["9207.25","0.4009"],
        //                     ["9207","0.003"],
        //                     ["9206.5","0.003"],
        //                 ]
        //             }
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object orderbook = this.safeValue(data, "data", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(orderbook, "ts");
        object result = this.parseOrderBook(orderbook, symbol, timestamp);
        ((IDictionary<string,object>)result)["nonce"] = this.safeInteger(orderbook, "seqnum");
        return result;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "symbol":"QTUM/BTC",
        //         "open":"0.00016537",
        //         "close":"0.00019077",
        //         "high":"0.000192",
        //         "low":"0.00016537",
        //         "volume":"846.6",
        //         "ask":["0.00018698","26.2"],
        //         "bid":["0.00018408","503.7"],
        //         "type":"spot"
        //     }
        //
        object timestamp = null;
        object marketId = this.safeString(ticker, "symbol");
        object type = this.safeString(ticker, "type");
        object delimiter = ((bool) isTrue((isEqual(type, "spot")))) ? "/" : null;
        object symbol = this.safeSymbol(marketId, market, delimiter);
        object close = this.safeString(ticker, "close");
        object bid = this.safeValue(ticker, "bid", new List<object>() {});
        object ask = this.safeValue(ticker, "ask", new List<object>() {});
        object open = this.safeString(ticker, "open");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", null },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(bid, 0) },
            { "bidVolume", this.safeString(bid, 1) },
            { "ask", this.safeString(ask, 0) },
            { "askVolume", this.safeString(ask, 1) },
            { "vwap", null },
            { "open", open },
            { "close", close },
            { "last", close },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "volume") },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v1PublicGetTicker(this.extend(request, parameters));
        //
        //     {
        //         "code":0,
        //         "data":{
        //             "symbol":"BTC-PERP", // or "BTC/USDT"
        //             "open":"9073",
        //             "close":"9185.75",
        //             "high":"9185.75",
        //             "low":"9185.75",
        //             "volume":"576.8334",
        //             "ask":["9185.75","15.5863"],
        //             "bid":["9185.5","0.003"],
        //             "type":"derivatives", // or "spot"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTicker(data, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://ascendex.github.io/ascendex-pro-api/#ticker
        * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#ticker
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = this.safeValue(symbols, 0);
            market = this.market(symbol);
            object marketIds = this.marketIds(symbols);
            ((IDictionary<string,object>)request)["symbol"] = String.Join(",", ((IList<object>)marketIds).ToArray());
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(type, "spot")))
        {
            response = await this.v1PublicGetTicker(this.extend(request, parameters));
        } else
        {
            response = await this.v2PublicGetFuturesTicker(this.extend(request, parameters));
        }
        //
        //     {
        //         "code":0,
        //         "data":[
        //             {
        //                 "symbol":"QTUM/BTC",
        //                 "open":"0.00016537",
        //                 "close":"0.00019077",
        //                 "high":"0.000192",
        //                 "low":"0.00016537",
        //                 "volume":"846.6",
        //                 "ask":["0.00018698","26.2"],
        //                 "bid":["0.00018408","503.7"],
        //                 "type":"spot"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        if (!isTrue(((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            return this.parseTickers(new List<object>() {data}, symbols);
        }
        return this.parseTickers(data, symbols);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "m":"bar",
        //         "s":"BTC/USDT",
        //         "data":{
        //             "i":"1",
        //             "ts":1590228000000,
        //             "o":"9139.59",
        //             "c":"9131.94",
        //             "h":"9139.99",
        //             "l":"9121.71",
        //             "v":"25.20648"
        //         }
        //     }
        //
        object data = this.safeValue(ohlcv, "data", new Dictionary<string, object>() {});
        return new List<object> {this.safeInteger(data, "ts"), this.safeNumber(data, "o"), this.safeNumber(data, "h"), this.safeNumber(data, "l"), this.safeNumber(data, "c"), this.safeNumber(data, "v")};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "interval", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        // if since and limit are not specified
        // the exchange will return just 1 last candle by default
        object duration = this.parseTimeframe(timeframe);
        object options = this.safeValue(this.options, "fetchOHLCV", new Dictionary<string, object>() {});
        object defaultLimit = this.safeInteger(options, "limit", 500);
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = since;
            if (isTrue(isEqual(limit, null)))
            {
                limit = defaultLimit;
            } else
            {
                limit = mathMin(limit, defaultLimit);
            }
            ((IDictionary<string,object>)request)["to"] = this.sum(since, multiply(multiply(limit, duration), 1000), 1);
        } else if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["n"] = limit; // max 500
        }
        object response = await this.v1PublicGetBarhist(this.extend(request, parameters));
        //
        //     {
        //         "code":0,
        //         "data":[
        //             {
        //                 "m":"bar",
        //                 "s":"BTC/USDT",
        //                 "data":{
        //                     "i":"1",
        //                     "ts":1590228000000,
        //                     "o":"9139.59",
        //                     "c":"9131.94",
        //                     "h":"9139.99",
        //                     "l":"9121.71",
        //                     "v":"25.20648"
        //                 }
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public fetchTrades
        //
        //     {
        //         "p":"9128.5", // price
        //         "q":"0.0030", // quantity
        //         "ts":1590229002385, // timestamp
        //         "bm":false, // if true, the buyer is the market maker, we only use this field to "define the side" of a public trade
        //         "seqnum":180143985289898554
        //     }
        //
        object timestamp = this.safeInteger(trade, "ts");
        object priceString = this.safeString2(trade, "price", "p");
        object amountString = this.safeString(trade, "q");
        object buyerIsMaker = this.safeBool(trade, "bm", false);
        object side = ((bool) isTrue(buyerIsMaker)) ? "sell" : "buy";
        market = this.safeMarket(null, market);
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "id", null },
            { "order", null },
            { "type", null },
            { "takerOrMaker", null },
            { "side", side },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "fee", null },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://ascendex.github.io/ascendex-pro-api/#market-trades
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["n"] = limit; // max 100
        }
        object response = await this.v1PublicGetTrades(this.extend(request, parameters));
        //
        //     {
        //         "code":0,
        //         "data":{
        //             "m":"trades",
        //             "symbol":"BTC-PERP",
        //             "data":[
        //                 {"p":"9128.5","q":"0.0030","ts":1590229002385,"bm":false,"seqnum":180143985289898554},
        //                 {"p":"9129","q":"0.0030","ts":1590229002642,"bm":false,"seqnum":180143985289898587},
        //                 {"p":"9129.5","q":"0.0030","ts":1590229021306,"bm":false,"seqnum":180143985289899043}
        //             ]
        //         }
        //     }
        //
        object records = this.safeValue(response, "data", new List<object>() {});
        object trades = this.safeList(records, "data", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "PendingNew", "open" },
            { "New", "open" },
            { "PartiallyFilled", "open" },
            { "Filled", "closed" },
            { "Canceled", "canceled" },
            { "Rejected", "rejected" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //
        //     {
        //         "id": "16e607e2b83a8bXHbAwwoqDo55c166fa",
        //         "orderId": "16e85b4d9b9a8bXHbAwwoqDoc3d66830",
        //         "orderType": "Market",
        //         "symbol": "BTC/USDT",
        //         "timestamp": 1573576916201
        //     }
        //
        //     {
        //         "ac": "FUTURES",
        //         "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        //         "time": 1640819389454,
        //         "orderId": "a17e0874ecbdU0711043490bbtcpDU5X",
        //         "seqNum": -1,
        //         "orderType": "Limit",
        //         "execInst": "NULL_VAL",
        //         "side": "Buy",
        //         "symbol": "BTC-PERP",
        //         "price": "30000",
        //         "orderQty": "0.002",
        //         "stopPrice": "0",
        //         "stopBy": "ref-px",
        //         "status": "Ack",
        //         "lastExecTime": 1640819389454,
        //         "lastQty": "0",
        //         "lastPx": "0",
        //         "avgFilledPx": "0",
        //         "cumFilledQty": "0",
        //         "fee": "0",
        //         "cumFee": "0",
        //         "feeAsset": "",
        //         "errorCode": "",
        //         "posStopLossPrice": "0",
        //         "posStopLossTrigger": "market",
        //         "posTakeProfitPrice": "0",
        //         "posTakeProfitTrigger": "market",
        //         "liquidityInd": "n"
        //      }
        //
        // fetchOrder, fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "symbol":       "BTC/USDT",
        //         "price":        "8131.22",
        //         "orderQty":     "0.00082",
        //         "orderType":    "Market",
        //         "avgPx":        "7392.02",
        //         "cumFee":       "0.005152238",
        //         "cumFilledQty": "0.00082",
        //         "errorCode":    "",
        //         "feeAsset":     "USDT",
        //         "lastExecTime": 1575953151764,
        //         "orderId":      "a16eee20b6750866943712zWEDdAjt3",
        //         "seqNum":       2623469,
        //         "side":         "Buy",
        //         "status":       "Filled",
        //         "stopPrice":    "",
        //         "execInst":     "NULL_VAL" // "Post" (for postOnly orders), "reduceOnly" (for reduceOnly orders)
        //     }
        //
        //     {
        //         "orderId": "a173ad938fc3U22666567717788c3b66",   // orderId
        //         "seqNum": 18777366360,                           // sequence number
        //         "accountId": "cshwSjbpPjSwHmxPdz2CPQVU9mnbzPpt", // accountId
        //         "symbol": "BTC/USDT",                            // symbol
        //         "orderType": "Limit",                            // order type (Limit/Market/StopMarket/StopLimit)
        //         "side": "Sell",                                  // order side (Buy/Sell)
        //         "price": "11346.77",                             // order price
        //         "stopPrice": "0",                                // stop price (0 by default)
        //         "orderQty": "0.01",                              // order quantity (in base asset)
        //         "status": "Canceled",                            // order status (Filled/Canceled/Rejected)
        //         "createTime": 1596344995793,                     // order creation time
        //         "lastExecTime": 1596344996053,                   // last execution time
        //         "avgFillPrice": "11346.77",                      // average filled price
        //         "fillQty": "0.01",                               // filled quantity (in base asset)
        //         "fee": "-0.004992579",                           // cummulative fee. if negative, this value is the commission charged; if possitive, this value is the rebate received.
        //         "feeAsset": "USDT"                               // fee asset
        //     }
        //
        //     {
        //         "ac": "FUTURES",
        //         "accountId": "testabcdefg",
        //         "avgPx": "0",
        //         "cumFee": "0",
        //         "cumQty": "0",
        //         "errorCode": "NULL_VAL",
        //         "execInst": "NULL_VAL",
        //         "feeAsset": "USDT",
        //         "lastExecTime": 1584072844085,
        //         "orderId": "r170d21956dd5450276356bbtcpKa74",
        //         "orderQty": "1.1499",
        //         "orderType": "Limit",
        //         "price": "4000",
        //         "sendingTime": 1584072841033,
        //         "seqNum": 24105338,
        //         "side": "Buy",
        //         "status": "Canceled",
        //         "stopPrice": "",
        //         "symbol": "BTC-PERP"
        //     },
        //
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object marketId = this.safeString(order, "symbol");
        object symbol = this.safeSymbol(marketId, market, "/");
        object timestamp = this.safeInteger2(order, "timestamp", "sendingTime");
        object lastTradeTimestamp = this.safeInteger(order, "lastExecTime");
        if (isTrue(isEqual(timestamp, null)))
        {
            timestamp = lastTradeTimestamp;
        }
        object price = this.safeString(order, "price");
        object amount = this.safeString(order, "orderQty");
        object average = this.safeString(order, "avgPx");
        object filled = this.safeStringN(order, new List<object>() {"cumFilledQty", "cumQty", "fillQty"});
        object id = this.safeString(order, "orderId");
        object clientOrderId = this.safeString(order, "id");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            if (isTrue(isLessThan(((string)clientOrderId).Length, 1)))
            {
                clientOrderId = null;
            }
        }
        object rawTypeLower = this.safeStringLower(order, "orderType");
        object type = rawTypeLower;
        if (isTrue(!isEqual(rawTypeLower, null)))
        {
            if (isTrue(isEqual(rawTypeLower, "stoplimit")))
            {
                type = "limit";
            }
            if (isTrue(isEqual(rawTypeLower, "stopmarket")))
            {
                type = "market";
            }
        }
        object side = this.safeStringLower(order, "side");
        object feeCost = this.safeNumber2(order, "cumFee", "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrencyId = this.safeString(order, "feeAsset");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrencyCode },
            };
        }
        object stopPrice = this.safeNumber(order, "stopPrice");
        object reduceOnly = null;
        object execInst = this.safeString(order, "execInst");
        if (isTrue(isEqual(execInst, "reduceOnly")))
        {
            reduceOnly = true;
        }
        object postOnly = null;
        if (isTrue(isEqual(execInst, "Post")))
        {
            postOnly = true;
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", postOnly },
            { "reduceOnly", reduceOnly },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "amount", amount },
            { "cost", null },
            { "average", average },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", fee },
            { "trades", null },
        }, market);
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object account = this.safeValue(this.accounts, 0, new Dictionary<string, object>() {});
        object accountGroup = this.safeString(account, "id");
        object request = new Dictionary<string, object>() {
            { "account-group", accountGroup },
        };
        object response = await this.v1PrivateAccountGroupGetSpotFee(this.extend(request, parameters));
        //
        //      {
        //         "code": "0",
        //         "data": {
        //           "domain": "spot",
        //           "userUID": "U1479576458",
        //           "vipLevel": "0",
        //           "fees": [
        //             { symbol: 'HT/USDT', fee: { taker: '0.001', maker: "0.001" } },
        //             { symbol: 'LAMB/BTC', fee: { taker: '0.002', maker: "0.002" } },
        //             { symbol: 'STOS/USDT', fee: { taker: '0.002', maker: "0.002" } },
        //             ...
        //           ]
        //         }
        //      }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object fees = this.safeValue(data, "fees", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(fees)); postFixIncrement(ref i))
        {
            object fee = getValue(fees, i);
            object marketId = this.safeString(fee, "symbol");
            object symbol = this.safeSymbol(marketId, null, "/");
            object takerMaker = this.safeValue(fee, "fee", new Dictionary<string, object>() {});
            ((IDictionary<string,object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "info", fee },
                { "symbol", symbol },
                { "maker", this.safeNumber(takerMaker, "maker") },
                { "taker", this.safeNumber(takerMaker, "taker") },
                { "percentage", null },
                { "tierBased", null },
            };
        }
        return result;
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @ignore
        * @name ascendex#createOrderRequest
        * @description helper function to build request
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.timeInForce] "GTC", "IOC", "FOK", or "PO"
        * @param {bool} [params.postOnly] true or false
        * @param {float} [params.stopPrice] the price at which a trigger order is triggered at
        * @returns {object} request to be sent to the exchange
        */
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object marginMode = null;
        object marketType = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("createOrderRequest", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("createOrderRequest", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object accountCategory = this.safeString(accountsByType, marketType, "cash");
        if (isTrue(!isEqual(marginMode, null)))
        {
            accountCategory = "margin";
        }
        object account = this.safeValue(this.accounts, 0, new Dictionary<string, object>() {});
        object accountGroup = this.safeValue(account, "id");
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "id");
        object request = new Dictionary<string, object>() {
            { "account-group", accountGroup },
            { "account-category", accountCategory },
            { "symbol", getValue(market, "id") },
            { "time", this.milliseconds() },
            { "orderQty", this.amountToPrecision(symbol, amount) },
            { "orderType", type },
            { "side", side },
        };
        object isMarketOrder = (isTrue((isEqual(type, "market"))) || isTrue((isEqual(type, "stop_market"))));
        object isLimitOrder = (isTrue((isEqual(type, "limit"))) || isTrue((isEqual(type, "stop_limit"))));
        object timeInForce = this.safeString(parameters, "timeInForce");
        object postOnly = this.isPostOnly(isMarketOrder, false, parameters);
        object reduceOnly = this.safeBool(parameters, "reduceOnly", false);
        object stopPrice = this.safeValue2(parameters, "triggerPrice", "stopPrice");
        if (isTrue(isLimitOrder))
        {
            ((IDictionary<string,object>)request)["orderPrice"] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(isEqual(timeInForce, "IOC")))
        {
            ((IDictionary<string,object>)request)["timeInForce"] = "IOC";
        }
        if (isTrue(isEqual(timeInForce, "FOK")))
        {
            ((IDictionary<string,object>)request)["timeInForce"] = "FOK";
        }
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["postOnly"] = true;
        }
        if (isTrue(!isEqual(stopPrice, null)))
        {
            ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, stopPrice);
            if (isTrue(isLimitOrder))
            {
                ((IDictionary<string,object>)request)["orderType"] = "stop_limit";
            } else if (isTrue(isMarketOrder))
            {
                ((IDictionary<string,object>)request)["orderType"] = "stop_market";
            }
        }
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["id"] = clientOrderId;
        }
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(!isEqual(accountCategory, null)))
            {
                ((IDictionary<string,object>)request)["category"] = accountCategory;
            }
        } else
        {
            ((IDictionary<string,object>)request)["account-category"] = accountCategory;
            if (isTrue(reduceOnly))
            {
                ((IDictionary<string,object>)request)["execInst"] = "ReduceOnly";
            }
            if (isTrue(postOnly))
            {
                ((IDictionary<string,object>)request)["execInst"] = "Post";
            }
        }
        parameters = this.omit(parameters, new List<object>() {"reduceOnly", "triggerPrice"});
        return this.extend(request, parameters);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#createOrder
        * @description create a trade order on the exchange
        * @see https://ascendex.github.io/ascendex-pro-api/#place-order
        * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#new-order
        * @param {string} symbol unified CCXT market symbol
        * @param {string} type "limit" or "market"
        * @param {string} side "buy" or "sell"
        * @param {float} amount the amount of currency to trade
        * @param {float} [price] *ignored in "market" orders* the price at which the order is to be fullfilled at in units of the quote currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.timeInForce] "GTC", "IOC", "FOK", or "PO"
        * @param {bool} [params.postOnly] true or false
        * @param {float} [params.stopPrice] the price at which a trigger order is triggered at
        * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice that the attached take profit order will be triggered (perpetual swap markets only)
        * @param {float} [params.takeProfit.triggerPrice] *swap only* take profit trigger price
        * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice that the attached stop loss order will be triggered (perpetual swap markets only)
        * @param {float} [params.stopLoss.triggerPrice] *swap only* stop loss trigger price
        * @returns [An order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object market = this.market(symbol);
        object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.v2PrivateAccountGroupPostFuturesOrder(request);
        } else
        {
            response = await this.v1PrivateAccountCategoryPostOrder(request);
        }
        //
        // spot
        //
        //      {
        //          "code":0,
        //          "data": {
        //              "accountId":"cshwT8RKojkT1HoaA5UdeimR2SrmHG2I",
        //              "ac":"CASH",
        //              "action":"place-order",
        //              "status":"Ack",
        //              "info": {
        //                  "symbol":"TRX/USDT",
        //                  "orderType":"StopLimit",
        //                  "timestamp":1654290662172,
        //                  "id":"",
        //                  "orderId":"a1812b6840ddU8191168955av0k6Eyhj"
        //              }
        //          }
        //      }
        //
        // swap
        //
        //      {
        //          "code":0,
        //          "data": {
        //              "meta": {
        //                  "id":"",
        //                  "action":"place-order",
        //                  "respInst":"ACK"
        //              },
        //              "order": {
        //                  "ac":"FUTURES",
        //                  "accountId":"futwT8RKojkT1HoaA5UdeimR2SrmHG2I",
        //                  "time":1654290969965,
        //                  "orderId":"a1812b6cf322U8191168955oJamfTh7b",
        //                  "seqNum":-1,
        //                  "orderType":"StopLimit",
        //                  "execInst":"NULL_VAL",
        //                  "side":"Buy",
        //                  "symbol":"TRX-PERP",
        //                  "price":"0.083",
        //                  "orderQty":"1",
        //                  "stopPrice":"0.082",
        //                  "stopBy":"ref-px",
        //                  "status":"Ack",
        //                  "lastExecTime":1654290969965,
        //                  "lastQty":"0",
        //                  "lastPx":"0",
        //                  "avgFilledPx":"0",
        //                  "cumFilledQty":"0",
        //                  "fee":"0",
        //                  "cumFee":"0",
        //                  "feeAsset":"",
        //                  "errorCode":"",
        //                  "posStopLossPrice":"0",
        //                  "posStopLossTrigger":"market",
        //                  "posTakeProfitPrice":"0",
        //                  "posTakeProfitTrigger":"market",
        //                  "liquidityInd":"n"
        //              }
        //          }
        //      }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object order = this.safeValue2(data, "order", "info", new Dictionary<string, object>() {});
        return this.parseOrder(order, market);
    }

    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#createOrders
        * @description create a list of trade orders
        * @see https://ascendex.github.io/ascendex-pro-api/#place-batch-orders
        * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#place-batch-orders
        * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.timeInForce] "GTC", "IOC", "FOK", or "PO"
        * @param {bool} [params.postOnly] true or false
        * @param {float} [params.stopPrice] the price at which a trigger order is triggered at
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object ordersRequests = new List<object>() {};
        object symbol = null;
        object marginMode = null;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            if (isTrue(isEqual(symbol, null)))
            {
                symbol = marketId;
            } else
            {
                if (isTrue(!isEqual(symbol, marketId)))
                {
                    throw new BadRequest ((string)add(this.id, " createOrders() requires all orders to have the same symbol")) ;
                }
            }
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeValue(rawOrder, "params", new Dictionary<string, object>() {});
            object marginResult = this.handleMarginModeAndParams("createOrders", orderParams);
            object currentMarginMode = getValue(marginResult, 0);
            if (isTrue(!isEqual(currentMarginMode, null)))
            {
                if (isTrue(isEqual(marginMode, null)))
                {
                    marginMode = currentMarginMode;
                } else
                {
                    if (isTrue(!isEqual(marginMode, currentMarginMode)))
                    {
                        throw new BadRequest ((string)add(this.id, " createOrders() requires all orders to have the same margin mode (isolated or cross)")) ;
                    }
                }
            }
            object orderRequest = this.createOrderRequest(marketId, type, side, amount, price, orderParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object market = this.market(symbol);
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object accountCategory = this.safeString(accountsByType, getValue(market, "type"), "cash");
        if (isTrue(!isEqual(marginMode, null)))
        {
            accountCategory = "margin";
        }
        object account = this.safeValue(this.accounts, 0, new Dictionary<string, object>() {});
        object accountGroup = this.safeValue(account, "id");
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            throw new NotSupported ((string)add(this.id, " createOrders() is not currently supported for swap markets on ascendex")) ;
        } else
        {
            ((IDictionary<string,object>)request)["account-group"] = accountGroup;
            ((IDictionary<string,object>)request)["account-category"] = accountCategory;
            ((IDictionary<string,object>)request)["orders"] = ordersRequests;
            response = await this.v1PrivateAccountCategoryPostOrderBatch(request);
        }
        //
        // spot
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "accountId": "cshdAKBO43TKIh2kJtq7FVVb42KIePyS",
        //             "ac": "CASH",
        //             "action": "batch-place-order",
        //             "status": "Ack",
        //             "info": [
        //                 {
        //                     "symbol": "BTC/USDT",
        //                     "orderType": "Limit",
        //                     "timestamp": 1699326589344,
        //                     "id": "",
        //                     "orderId": "a18ba7c1f6efU0711043490p3HvjjN5x"
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object info = this.safeList(data, "info", new List<object>() {});
        return this.parseOrders(info, market);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://ascendex.github.io/ascendex-pro-api/#query-order
        * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#query-order-by-id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        var typequeryVariable = this.handleMarketTypeAndParams("fetchOrder", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object accountCategory = this.safeString(accountsByType, type, "cash");
        object account = this.safeValue(this.accounts, 0, new Dictionary<string, object>() {});
        object accountGroup = this.safeValue(account, "id");
        object request = new Dictionary<string, object>() {
            { "account-group", accountGroup },
            { "account-category", accountCategory },
            { "orderId", id },
        };
        object response = null;
        if (isTrue(isTrue((isEqual(type, "spot"))) || isTrue((isEqual(type, "margin")))))
        {
            response = await this.v1PrivateAccountCategoryGetOrderStatus(this.extend(request, query));
        } else if (isTrue(isEqual(type, "swap")))
        {
            ((IDictionary<string,object>)request)["account-category"] = accountCategory;
            response = await this.v2PrivateAccountGroupGetFuturesOrderStatus(this.extend(request, query));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOrder() is not currently supported for "), type), " markets")) ;
        }
        //
        // AccountCategoryGetOrderStatus
        //
        //     {
        //         "code": 0,
        //         "accountCategory": "CASH",
        //         "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
        //         "data": [
        //             {
        //                 "symbol":       "BTC/USDT",
        //                 "price":        "8131.22",
        //                 "orderQty":     "0.00082",
        //                 "orderType":    "Market",
        //                 "avgPx":        "7392.02",
        //                 "cumFee":       "0.005152238",
        //                 "cumFilledQty": "0.00082",
        //                 "errorCode":    "",
        //                 "feeAsset":     "USDT",
        //                 "lastExecTime": 1575953151764,
        //                 "orderId":      "a16eee20b6750866943712zWEDdAjt3",
        //                 "seqNum":       2623469,
        //                 "side":         "Buy",
        //                 "status":       "Filled",
        //                 "stopPrice":    "",
        //                 "execInst":     "NULL_VAL"
        //             }
        //         ]
        //     }
        //
        // AccountGroupGetFuturesOrderStatus
        //
        //     {
        //         "code": 0,
        //         "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        //         "ac": "FUTURES",
        //         "data": {
        //             "ac": "FUTURES",
        //             "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        //             "time": 1640247020217,
        //             "orderId": "r17de65747aeU0711043490bbtcp0cmt",
        //             "seqNum": 28796162908,
        //             "orderType": "Limit",
        //             "execInst": "NULL_VAL",
        //             "side": "Buy",
        //             "symbol": "BTC-PERP",
        //             "price": "30000",
        //             "orderQty": "0.0021",
        //             "stopPrice": "0",
        //             "stopBy": "market",
        //             "status": "New",
        //             "lastExecTime": 1640247020232,
        //             "lastQty": "0",
        //             "lastPx": "0",
        //             "avgFilledPx": "0",
        //             "cumFilledQty": "0",
        //             "fee": "0",
        //             "cumFee": "0",
        //             "feeAsset": "USDT",
        //             "errorCode": "",
        //             "posStopLossPrice": "0",
        //             "posStopLossTrigger": "market",
        //             "posTakeProfitPrice": "0",
        //             "posTakeProfitTrigger": "market",
        //             "liquidityInd": "n"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://ascendex.github.io/ascendex-pro-api/#list-open-orders
        * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#list-open-orders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        object account = this.safeValue(this.accounts, 0, new Dictionary<string, object>() {});
        object accountGroup = this.safeValue(account, "id");
        var typequeryVariable = this.handleMarketTypeAndParams("fetchOpenOrders", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object accountCategory = this.safeString(accountsByType, type, "cash");
        object request = new Dictionary<string, object>() {
            { "account-group", accountGroup },
            { "account-category", accountCategory },
        };
        object response = null;
        if (isTrue(isTrue((isEqual(type, "spot"))) || isTrue((isEqual(type, "margin")))))
        {
            response = await this.v1PrivateAccountCategoryGetOrderOpen(this.extend(request, query));
        } else if (isTrue(isEqual(type, "swap")))
        {
            ((IDictionary<string,object>)request)["account-category"] = accountCategory;
            response = await this.v2PrivateAccountGroupGetFuturesOrderOpen(this.extend(request, query));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOpenOrders() is not currently supported for "), type), " markets")) ;
        }
        //
        // AccountCategoryGetOrderOpen
        //
        //     {
        //         "ac": "CASH",
        //         "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
        //         "code": 0,
        //         "data": [
        //             {
        //                 "avgPx": "0",         // Average filled price of the order
        //                 "cumFee": "0",       // cumulative fee paid for this order
        //                 "cumFilledQty": "0", // cumulative filled quantity
        //                 "errorCode": "",     // error code; could be empty
        //                 "feeAsset": "USDT",  // fee asset
        //                 "lastExecTime": 1576019723550, //  The last execution time of the order
        //                 "orderId": "s16ef21882ea0866943712034f36d83", // server provided orderId
        //                 "orderQty": "0.0083",  // order quantity
        //                 "orderType": "Limit",  // order type
        //                 "price": "7105",       // order price
        //                 "seqNum": 8193258,     // sequence number
        //                 "side": "Buy",         // order side
        //                 "status": "New",       // order status on matching engine
        //                 "stopPrice": "",       // only available for stop market and stop limit orders; otherwise empty
        //                 "symbol": "BTC/USDT",
        //                 "execInst": "NULL_VAL" // execution instruction
        //             },
        //         ]
        //     }
        //
        // AccountGroupGetFuturesOrderOpen
        //
        // {
        //     "code": 0,
        //     "data": [
        //         {
        //             "ac": "FUTURES",
        //             "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        //             "time": 1640247020217,
        //             "orderId": "r17de65747aeU0711043490bbtcp0cmt",
        //             "seqNum": 28796162908,
        //             "orderType": "Limit",
        //             "execInst": "NULL_VAL",
        //             "side": "Buy",
        //             "symbol": "BTC-PERP",
        //             "price": "30000",
        //             "orderQty": "0.0021",
        //             "stopPrice": "0",
        //             "stopBy": "market",
        //             "status": "New",
        //             "lastExecTime": 1640247020232,
        //             "lastQty": "0",
        //             "lastPx": "0",
        //             "avgFilledPx": "0",
        //             "cumFilledQty": "0",
        //             "fee": "0",
        //             "cumFee": "0",
        //             "feeAsset": "USDT",
        //             "errorCode": "",
        //             "posStopLossPrice": "0",
        //             "posStopLossTrigger": "market",
        //             "posTakeProfitPrice": "0",
        //             "posTakeProfitTrigger": "market",
        //             "liquidityInd": "n"
        //         }
        //     ]
        // }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        if (isTrue(isEqual(accountCategory, "futures")))
        {
            return this.parseOrders(data, market, since, limit);
        }
        // a workaround for https://github.com/ccxt/ccxt/issues/7187
        object orders = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object order = this.parseOrder(getValue(data, i), market);
            ((IList<object>)orders).Add(order);
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://ascendex.github.io/ascendex-pro-api/#list-history-orders-v2
        * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#list-current-history-orders
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch orders for
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object account = this.safeValue(this.accounts, 0, new Dictionary<string, object>() {});
        object accountGroup = this.safeValue(account, "id");
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        var typequeryVariable = this.handleMarketTypeAndParams("fetchClosedOrders", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        object options = this.safeValue(this.options, "fetchClosedOrders", new Dictionary<string, object>() {});
        object defaultMethod = this.safeString(options, "method", "v2PrivateDataGetOrderHist");
        object method = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "spot", defaultMethod },
            { "margin", defaultMethod },
            { "swap", "v2PrivateAccountGroupGetFuturesOrderHistCurrent" },
        });
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object until = this.safeString(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object accountCategory = this.safeString(accountsByType, type, "cash"); // margin, futures
        object response = null;
        if (isTrue(isEqual(method, "v1PrivateAccountCategoryGetOrderHistCurrent")))
        {
            ((IDictionary<string,object>)request)["account-group"] = accountGroup;
            ((IDictionary<string,object>)request)["account-category"] = accountCategory;
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            response = await this.v1PrivateAccountCategoryGetOrderHistCurrent(this.extend(request, query));
        } else if (isTrue(isEqual(method, "v2PrivateDataGetOrderHist")))
        {
            ((IDictionary<string,object>)request)["account"] = accountCategory;
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            response = await this.v2PrivateDataGetOrderHist(this.extend(request, query));
        } else if (isTrue(isEqual(method, "v2PrivateAccountGroupGetFuturesOrderHistCurrent")))
        {
            ((IDictionary<string,object>)request)["account-group"] = accountGroup;
            ((IDictionary<string,object>)request)["account-category"] = accountCategory;
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["pageSize"] = limit;
            }
            response = await this.v2PrivateAccountGroupGetFuturesOrderHistCurrent(this.extend(request, query));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchClosedOrders() is not currently supported for "), type), " markets")) ;
        }
        //
        // accountCategoryGetOrderHistCurrent
        //
        //     {
        //         "code":0,
        //         "accountId":"cshrHKLZCjlZ2ejqkmvIHHtPmLYqdnda",
        //         "ac":"CASH",
        //         "data":[
        //             {
        //                 "seqNum":15561826728,
        //                 "orderId":"a17294d305c0U6491137460bethu7kw9",
        //                 "symbol":"ETH/USDT",
        //                 "orderType":"Limit",
        //                 "lastExecTime":1591635618200,
        //                 "price":"200",
        //                 "orderQty":"0.1",
        //                 "side":"Buy",
        //                 "status":"Canceled",
        //                 "avgPx":"0",
        //                 "cumFilledQty":"0",
        //                 "stopPrice":"",
        //                 "errorCode":"",
        //                 "cumFee":"0",
        //                 "feeAsset":"USDT",
        //                 "execInst":"NULL_VAL"
        //             }
        //         ]
        //     }
        //
        //    {
        //        "code": 0,
        //        "data": [
        //            {
        //                "orderId"     :  "a173ad938fc3U22666567717788c3b66", // orderId
        //                "seqNum"      :  18777366360,                        // sequence number
        //                "accountId"   :  "cshwSjbpPjSwHmxPdz2CPQVU9mnbzPpt", // accountId
        //                "symbol"      :  "BTC/USDT",                         // symbol
        //                "orderType"   :  "Limit",                            // order type (Limit/Market/StopMarket/StopLimit)
        //                "side"        :  "Sell",                             // order side (Buy/Sell)
        //                "price"       :  "11346.77",                         // order price
        //                "stopPrice"   :  "0",                                // stop price (0 by default)
        //                "orderQty"    :  "0.01",                             // order quantity (in base asset)
        //                "status"      :  "Canceled",                         // order status (Filled/Canceled/Rejected)
        //                "createTime"  :  1596344995793,                      // order creation time
        //                "lastExecTime":  1596344996053,                      // last execution time
        //                "avgFillPrice":  "11346.77",                         // average filled price
        //                "fillQty"     :  "0.01",                             // filled quantity (in base asset)
        //                "fee"         :  "-0.004992579",                     // cummulative fee. if negative, this value is the commission charged; if possitive, this value is the rebate received.
        //                "feeAsset"    :  "USDT"                              // fee asset
        //            }
        //        ]
        //    }
        //
        // accountGroupGetFuturesOrderHistCurrent
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "ac": "FUTURES",
        //                 "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        //                 "time": 1640245777002,
        //                 "orderId": "r17de6444fa6U0711043490bbtcpJ2lI",
        //                 "seqNum": 28796124902,
        //                 "orderType": "Limit",
        //                 "execInst": "NULL_VAL",
        //                 "side": "Buy",
        //                 "symbol": "BTC-PERP",
        //                 "price": "30000",
        //                 "orderQty": "0.0021",
        //                 "stopPrice": "0",
        //                 "stopBy": "market",
        //                 "status": "Canceled",
        //                 "lastExecTime": 1640246574886,
        //                 "lastQty": "0",
        //                 "lastPx": "0",
        //                 "avgFilledPx": "0",
        //                 "cumFilledQty": "0",
        //                 "fee": "0",
        //                 "cumFee": "0",
        //                 "feeAsset": "USDT",
        //                 "errorCode": "",
        //                 "posStopLossPrice": "0",
        //                 "posStopLossTrigger": "market",
        //                 "posTakeProfitPrice": "0",
        //                 "posTakeProfitTrigger": "market",
        //                 "liquidityInd": "n"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data");
        object isArray = ((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))));
        if (!isTrue(isArray))
        {
            data = this.safeValue(data, "data", new List<object>() {});
        }
        return this.parseOrders(data, market, since, limit);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#cancelOrder
        * @description cancels an open order
        * @see https://ascendex.github.io/ascendex-pro-api/#cancel-order
        * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#cancel-order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        await this.loadAccounts();
        object market = this.market(symbol);
        var typequeryVariable = this.handleMarketTypeAndParams("cancelOrder", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object accountCategory = this.safeString(accountsByType, type, "cash");
        object account = this.safeValue(this.accounts, 0, new Dictionary<string, object>() {});
        object accountGroup = this.safeValue(account, "id");
        object request = new Dictionary<string, object>() {
            { "account-group", accountGroup },
            { "account-category", accountCategory },
            { "symbol", getValue(market, "id") },
            { "time", this.milliseconds() },
            { "id", "foobar" },
        };
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "id");
        if (isTrue(isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        } else
        {
            ((IDictionary<string,object>)request)["id"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"clientOrderId", "id"});
        }
        object response = null;
        if (isTrue(isTrue((isEqual(type, "spot"))) || isTrue((isEqual(type, "margin")))))
        {
            response = await this.v1PrivateAccountCategoryDeleteOrder(this.extend(request, query));
        } else if (isTrue(isEqual(type, "swap")))
        {
            ((IDictionary<string,object>)request)["account-category"] = accountCategory;
            response = await this.v2PrivateAccountGroupDeleteFuturesOrder(this.extend(request, query));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " cancelOrder() is not currently supported for "), type), " markets")) ;
        }
        //
        // AccountCategoryDeleteOrder
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
        //             "ac": "CASH",
        //             "action": "cancel-order",
        //             "status": "Ack",
        //             "info": {
        //                 "id":        "wv8QGquoeamhssvQBeHOHGQCGlcBjj23",
        //                 "orderId":   "16e6198afb4s8bXHbAwwoqDo2ebc19dc",
        //                 "orderType": "", // could be empty
        //                 "symbol":    "ETH/USDT",
        //                 "timestamp":  1573594877822
        //             }
        //         }
        //     }
        //
        // AccountGroupDeleteFuturesOrder
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "meta": {
        //                 "id": "foobar",
        //                 "action": "cancel-order",
        //                 "respInst": "ACK"
        //             },
        //             "order": {
        //                 "ac": "FUTURES",
        //                 "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        //                 "time": 1640244480476,
        //                 "orderId": "r17de63086f4U0711043490bbtcpPUF4",
        //                 "seqNum": 28795959269,
        //                 "orderType": "Limit",
        //                 "execInst": "NULL_VAL",
        //                 "side": "Buy",
        //                 "symbol": "BTC-PERP",
        //                 "price": "30000",
        //                 "orderQty": "0.0021",
        //                 "stopPrice": "0",
        //                 "stopBy": "market",
        //                 "status": "New",
        //                 "lastExecTime": 1640244480491,
        //                 "lastQty": "0",
        //                 "lastPx": "0",
        //                 "avgFilledPx": "0",
        //                 "cumFilledQty": "0",
        //                 "fee": "0",
        //                 "cumFee": "0",
        //                 "feeAsset": "BTCPC",
        //                 "errorCode": "",
        //                 "posStopLossPrice": "0",
        //                 "posStopLossTrigger": "market",
        //                 "posTakeProfitPrice": "0",
        //                 "posTakeProfitTrigger": "market",
        //                 "liquidityInd": "n"
        //             }
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object order = this.safeValue2(data, "order", "info", new Dictionary<string, object>() {});
        return this.parseOrder(order, market);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#cancelAllOrders
        * @description cancel all open orders
        * @see https://ascendex.github.io/ascendex-pro-api/#cancel-all-orders
        * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#cancel-all-open-orders
        * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        var typequeryVariable = this.handleMarketTypeAndParams("cancelAllOrders", market, parameters);
        var type = ((IList<object>) typequeryVariable)[0];
        var query = ((IList<object>) typequeryVariable)[1];
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object accountCategory = this.safeString(accountsByType, type, "cash");
        object account = this.safeValue(this.accounts, 0, new Dictionary<string, object>() {});
        object accountGroup = this.safeValue(account, "id");
        object request = new Dictionary<string, object>() {
            { "account-group", accountGroup },
            { "account-category", accountCategory },
            { "time", this.milliseconds() },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object response = null;
        if (isTrue(isTrue((isEqual(type, "spot"))) || isTrue((isEqual(type, "margin")))))
        {
            response = await this.v1PrivateAccountCategoryDeleteOrderAll(this.extend(request, query));
        } else if (isTrue(isEqual(type, "swap")))
        {
            ((IDictionary<string,object>)request)["account-category"] = accountCategory;
            response = await this.v2PrivateAccountGroupDeleteFuturesOrderAll(this.extend(request, query));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " cancelAllOrders() is not currently supported for "), type), " markets")) ;
        }
        //
        // AccountCategoryDeleteOrderAll
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "ac": "CASH",
        //             "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
        //             "action": "cancel-all",
        //             "info": {
        //                 "id":  "2bmYvi7lyTrneMzpcJcf2D7Pe9V1P9wy",
        //                 "orderId": "",
        //                 "orderType": "NULL_VAL",
        //                 "symbol": "",
        //                 "timestamp": 1574118495462
        //             },
        //             "status": "Ack"
        //         }
        //     }
        //
        // AccountGroupDeleteFuturesOrderAll
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "ac": "FUTURES",
        //             "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        //             "action": "cancel-all",
        //             "info": {
        //                 "symbol":"BTC-PERP"
        //             }
        //         }
        //     }
        //
        return response;
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "address": "0xe7c70b4e73b6b450ee46c3b5c0f5fb127ca55722",
        //         "destTag": "",
        //         "tagType": "",
        //         "tagId": "",
        //         "chainName": "ERC20",
        //         "numConfirmations": 20,
        //         "withdrawalFee": 1,
        //         "nativeScale": 4,
        //         "tips": []
        //     }
        //
        object address = this.safeString(depositAddress, "address");
        object tagId = this.safeString(depositAddress, "tagId");
        object tag = this.safeString(depositAddress, tagId);
        this.checkAddress(address);
        object code = ((bool) isTrue((isEqual(currency, null)))) ? null : getValue(currency, "code");
        object chainName = this.safeString(depositAddress, "blockchain");
        object network = this.networkIdToCode(chainName, code);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", network },
            { "info", depositAddress },
        };
    }

    public virtual object safeNetwork(object networkId)
    {
        object networksById = this.safeDict(this.options, "networksById");
        return this.safeString(networksById, networkId, networkId);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://ascendex.github.io/ascendex-pro-api/#query-deposit-addresses
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.network] unified network code for deposit chain
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object networkCode = this.safeString2(parameters, "network", "chainName");
        object networkId = this.networkCodeToId(networkCode);
        parameters = this.omit(parameters, new List<object>() {"chainName"});
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "blockchain", networkId },
        };
        object response = await this.v1PrivateGetWalletDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         "code":0,
        //         "data":{
        //             "asset":"USDT",
        //             "assetName":"Tether",
        //             "address":[
        //                 {
        //                     "address":"1N22odLHXnLPCjC8kwBJPTayarr9RtPod6",
        //                     "destTag":"",
        //                     "tagType":"",
        //                     "tagId":"",
        //                     "chainName":"Omni",
        //                     "numConfirmations":3,
        //                     "withdrawalFee":4.7,
        //                     "nativeScale":4,
        //                     "tips":[]
        //                 },
        //                 {
        //                     "address":"0xe7c70b4e73b6b450ee46c3b5c0f5fb127ca55722",
        //                     "destTag":"",
        //                     "tagType":"",
        //                     "tagId":"",
        //                     "chainName":"ERC20",
        //                     "numConfirmations":20,
        //                     "withdrawalFee":1.0,
        //                     "nativeScale":4,
        //                     "tips":[]
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object addresses = this.safeList(data, "address", new List<object>() {});
        object numAddresses = getArrayLength(addresses);
        object address = null;
        if (isTrue(isGreaterThan(numAddresses, 1)))
        {
            object addressesByChainName = this.indexBy(addresses, "chainName");
            if (isTrue(isEqual(networkId, null)))
            {
                object chainNames = new List<object>(((IDictionary<string,object>)addressesByChainName).Keys);
                object chains = String.Join(", ", ((IList<object>)chainNames).ToArray());
                throw new ArgumentsRequired ((string)add(add(this.id, " fetchDepositAddress() returned more than one address, a chainName parameter is required, one of "), chains)) ;
            }
            address = this.safeDict(addressesByChainName, networkId, new Dictionary<string, object>() {});
        } else
        {
            // first address
            address = this.safeDict(addresses, 0, new Dictionary<string, object>() {});
        }
        object result = this.parseDepositAddress(address, currency);
        return this.extend(result, new Dictionary<string, object>() {
            { "info", response },
        });
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "txType", "deposit" },
        };
        return await this.fetchTransactions(code, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "txType", "withdrawal" },
        };
        return await this.fetchTransactions(code, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchDepositsWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchDepositsWithdrawals
        * @description fetch history of deposits and withdrawals
        * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
        * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
        * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["asset"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTs"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["pageSize"] = limit;
        }
        object response = await this.v1PrivateGetWalletTransactions(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "data": [
        //                 {
        //                     "requestId": "wuzd1Ojsqtz4bCA3UXwtUnnJDmU8PiyB",
        //                     "time": 1591606166000,
        //                     "asset": "USDT",
        //                     "transactionType": "deposit",
        //                     "amount": "25",
        //                     "commission": "0",
        //                     "networkTransactionId": "0xbc4eabdce92f14dbcc01d799a5f8ca1f02f4a3a804b6350ea202be4d3c738fce",
        //                     "status": "pending",
        //                     "numConfirmed": 8,
        //                     "numConfirmations": 20,
        //                     "destAddress": { address: "0xe7c70b4e73b6b450ee46c3b5c0f5fb127ca55722" }
        //                 }
        //             ],
        //             "page": 1,
        //             "pageSize": 20,
        //             "hasNext": false
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object transactions = this.safeList(data, "data", new List<object>() {});
        return this.parseTransactions(transactions, currency, since, limit);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "reviewing", "pending" },
            { "pending", "pending" },
            { "confirmed", "ok" },
            { "rejected", "rejected" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        //     {
        //         "requestId": "wuzd1Ojsqtz4bCA3UXwtUnnJDmU8PiyB",
        //         "time": 1591606166000,
        //         "asset": "USDT",
        //         "transactionType": "deposit",
        //         "amount": "25",
        //         "commission": "0",
        //         "networkTransactionId": "0xbc4eabdce92f14dbcc01d799a5f8ca1f02f4a3a804b6350ea202be4d3c738fce",
        //         "status": "pending",
        //         "numConfirmed": 8,
        //         "numConfirmations": 20,
        //         "destAddress": {
        //             "address": "0xe7c70b4e73b6b450ee46c3b5c0f5fb127ca55722",
        //             "destTag": "..." // for currencies that have it
        //         }
        //     }
        //
        object destAddress = this.safeValue(transaction, "destAddress", new Dictionary<string, object>() {});
        object address = this.safeString(destAddress, "address");
        object tag = this.safeString(destAddress, "destTag");
        object timestamp = this.safeInteger(transaction, "time");
        object currencyId = this.safeString(transaction, "asset");
        object amountString = this.safeString(transaction, "amount");
        object feeCostString = this.safeString(transaction, "commission");
        amountString = Precise.stringSub(amountString, feeCostString);
        object code = this.safeCurrencyCode(currencyId, currency);
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString(transaction, "requestId") },
            { "txid", this.safeString(transaction, "networkTransactionId") },
            { "type", this.safeString(transaction, "transactionType") },
            { "currency", code },
            { "network", null },
            { "amount", this.parseNumber(amountString) },
            { "status", this.parseTransactionStatus(this.safeString(transaction, "status")) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "address", address },
            { "addressFrom", null },
            { "addressTo", address },
            { "tag", tag },
            { "tagFrom", null },
            { "tagTo", tag },
            { "updated", null },
            { "comment", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", this.parseNumber(feeCostString) },
                { "rate", null },
            } },
            { "internal", false },
        };
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchPositions
        * @description fetch all open positions
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object account = this.safeValue(this.accounts, 0, new Dictionary<string, object>() {});
        object accountGroup = this.safeString(account, "id");
        object request = new Dictionary<string, object>() {
            { "account-group", accountGroup },
        };
        object response = await this.v2PrivateAccountGroupGetFuturesPosition(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        //             "ac": "FUTURES",
        //             "collaterals": [
        //                 {
        //                     "asset": "USDT",
        //                     "balance": "44.570287262",
        //                     "referencePrice": "1",
        //                     "discountFactor": "1"
        //                 }
        //             ],
        //             "contracts": [
        //                 {
        //                     "symbol": "BTC-PERP",
        //                     "side": "LONG",
        //                     "position": "0.0001",
        //                     "referenceCost": "-3.12277254",
        //                     "unrealizedPnl": "-0.001700233",
        //                     "realizedPnl": "0",
        //                     "avgOpenPrice": "31209",
        //                     "marginType": "isolated",
        //                     "isolatedMargin": "1.654972977",
        //                     "leverage": "2",
        //                     "takeProfitPrice": "0",
        //                     "takeProfitTrigger": "market",
        //                     "stopLossPrice": "0",
        //                     "stopLossTrigger": "market",
        //                     "buyOpenOrderNotional": "0",
        //                     "sellOpenOrderNotional": "0",
        //                     "markPrice": "31210.723063672",
        //                     "indexPrice": "31223.148857925"
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object position = this.safeValue(data, "contracts", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(position)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parsePosition(getValue(position, i)));
        }
        symbols = this.marketSymbols(symbols);
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         "symbol": "BTC-PERP",
        //         "side": "LONG",
        //         "position": "0.0001",
        //         "referenceCost": "-3.12277254",
        //         "unrealizedPnl": "-0.001700233",
        //         "realizedPnl": "0",
        //         "avgOpenPrice": "31209",
        //         "marginType": "isolated",
        //         "isolatedMargin": "1.654972977",
        //         "leverage": "2",
        //         "takeProfitPrice": "0",
        //         "takeProfitTrigger": "market",
        //         "stopLossPrice": "0",
        //         "stopLossTrigger": "market",
        //         "buyOpenOrderNotional": "0",
        //         "sellOpenOrderNotional": "0",
        //         "markPrice": "31210.723063672",
        //         "indexPrice": "31223.148857925"
        //     },
        //
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market);
        object notional = this.safeString(position, "buyOpenOrderNotional");
        if (isTrue(Precise.stringEq(notional, "0")))
        {
            notional = this.safeString(position, "sellOpenOrderNotional");
        }
        object marginType = this.safeString(position, "marginType");
        object marginMode = ((bool) isTrue((isEqual(marginType, "crossed")))) ? "cross" : "isolated";
        object collateral = null;
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            collateral = this.safeString(position, "isolatedMargin");
        }
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", getValue(market, "symbol") },
            { "notional", this.parseNumber(notional) },
            { "marginMode", marginMode },
            { "liquidationPrice", null },
            { "entryPrice", this.safeNumber(position, "avgOpenPrice") },
            { "unrealizedPnl", this.safeNumber(position, "unrealizedPnl") },
            { "percentage", null },
            { "contracts", this.safeNumber(position, "position") },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "markPrice", this.safeNumber(position, "markPrice") },
            { "lastPrice", null },
            { "side", this.safeStringLower(position, "side") },
            { "hedged", null },
            { "timestamp", null },
            { "datetime", null },
            { "lastUpdateTimestamp", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "collateral", collateral },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "leverage", this.safeInteger(position, "leverage") },
            { "marginRatio", null },
            { "stopLossPrice", this.safeNumber(position, "stopLossPrice") },
            { "takeProfitPrice", this.safeNumber(position, "takeProfitPrice") },
        });
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //      {
        //          "time": 1640061364830,
        //          "symbol": "EOS-PERP",
        //          "markPrice": "3.353854865",
        //          "indexPrice": "3.3542",
        //          "openInterest": "14242",
        //          "fundingRate": "-0.000073026",
        //          "nextFundingTime": 1640073600000
        //      }
        //
        object marketId = this.safeString(contract, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object currentTime = this.safeInteger(contract, "time");
        object nextFundingRate = this.safeNumber(contract, "fundingRate");
        object nextFundingRateTimestamp = this.safeInteger(contract, "nextFundingTime");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", this.safeNumber(contract, "markPrice") },
            { "indexPrice", this.safeNumber(contract, "indexPrice") },
            { "interestRate", this.parseNumber("0") },
            { "estimatedSettlePrice", null },
            { "timestamp", currentTime },
            { "datetime", this.iso8601(currentTime) },
            { "previousFundingRate", null },
            { "nextFundingRate", null },
            { "previousFundingTimestamp", null },
            { "nextFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "nextFundingDatetime", null },
            { "fundingRate", nextFundingRate },
            { "fundingTimestamp", nextFundingRateTimestamp },
            { "fundingDatetime", this.iso8601(nextFundingRateTimestamp) },
        };
    }

    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchFundingRates
        * @description fetch the funding rate for multiple markets
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [funding rates structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexe by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.v2PublicGetFuturesPricingData(parameters);
        //
        //     {
        //          "code": 0,
        //          "data": {
        //              "contracts": [
        //                  {
        //                      "time": 1640061364830,
        //                      "symbol": "EOS-PERP",
        //                      "markPrice": "3.353854865",
        //                      "indexPrice": "3.3542",
        //                      "openInterest": "14242",
        //                      "fundingRate": "-0.000073026",
        //                      "nextFundingTime": 1640073600000
        //                  },
        //              ],
        //              "collaterals": [
        //                  {
        //                      "asset": "USDTR",
        //                      "referencePrice": "1"
        //                  },
        //              ]
        //          }
        //      }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object contracts = this.safeValue(data, "contracts", new List<object>() {});
        object result = this.parseFundingRates(contracts);
        return this.filterByArray(result, "symbol", symbols);
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object market = this.market(symbol);
        object account = this.safeValue(this.accounts, 0, new Dictionary<string, object>() {});
        object accountGroup = this.safeString(account, "id");
        amount = this.amountToPrecision(symbol, amount);
        object request = new Dictionary<string, object>() {
            { "account-group", accountGroup },
            { "symbol", getValue(market, "id") },
            { "amount", amount },
        };
        object response = await this.v2PrivateAccountGroupPostFuturesIsolatedPositionMargin(this.extend(request, parameters));
        //
        // Can only change margin for perpetual futures isolated margin positions
        //
        //     {
        //          "code": 0
        //     }
        //
        if (isTrue(isEqual(type, "reduce")))
        {
            amount = Precise.stringAbs(amount);
        }
        return this.extend(this.parseMarginModification(response, market), new Dictionary<string, object>() {
            { "amount", this.parseNumber(amount) },
            { "type", type },
        });
    }

    public override object parseMarginModification(object data, object market = null)
    {
        //
        // addMargin/reduceMargin
        //
        //     {
        //          "code": 0
        //     }
        //
        object errorCode = this.safeString(data, "code");
        object status = ((bool) isTrue((isEqual(errorCode, "0")))) ? "ok" : "failed";
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", getValue(market, "symbol") },
            { "type", null },
            { "marginMode", "isolated" },
            { "amount", null },
            { "total", null },
            { "code", getValue(market, "quote") },
            { "status", status },
            { "timestamp", null },
            { "datetime", null },
        };
    }

    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#reduceMargin
        * @description remove margin from a position
        * @param {string} symbol unified market symbol
        * @param {float} amount the amount of margin to remove
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, prefixUnaryNeg(ref amount), "reduce", parameters);
    }

    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#addMargin
        * @description add margin
        * @param {string} symbol unified market symbol
        * @param {float} amount amount of margin to add
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "add", parameters);
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#setLeverage
        * @description set the level of leverage for a market
        * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#change-contract-leverage
        * @param {float} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        if (isTrue(isTrue((isLessThan(leverage, 1))) || isTrue((isGreaterThan(leverage, 100)))))
        {
            throw new BadRequest ((string)add(this.id, " leverage should be between 1 and 100")) ;
        }
        await this.loadMarkets();
        await this.loadAccounts();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " setLeverage() supports swap contracts only")) ;
        }
        object account = this.safeValue(this.accounts, 0, new Dictionary<string, object>() {});
        object accountGroup = this.safeString(account, "id");
        object request = new Dictionary<string, object>() {
            { "account-group", accountGroup },
            { "symbol", getValue(market, "id") },
            { "leverage", leverage },
        };
        return await this.v2PrivateAccountGroupPostFuturesLeverage(this.extend(request, parameters));
    }

    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#setMarginMode
        * @description set margin mode to 'cross' or 'isolated'
        * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#change-margin-type
        * @param {string} marginMode 'cross' or 'isolated'
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        marginMode = ((string)marginMode).ToLower();
        if (isTrue(isEqual(marginMode, "cross")))
        {
            marginMode = "crossed";
        }
        if (isTrue(isTrue(!isEqual(marginMode, "isolated")) && isTrue(!isEqual(marginMode, "crossed"))))
        {
            throw new BadRequest ((string)add(this.id, " setMarginMode() marginMode argument should be isolated or cross")) ;
        }
        await this.loadMarkets();
        await this.loadAccounts();
        object market = this.market(symbol);
        object account = this.safeValue(this.accounts, 0, new Dictionary<string, object>() {});
        object accountGroup = this.safeString(account, "id");
        object request = new Dictionary<string, object>() {
            { "account-group", accountGroup },
            { "symbol", getValue(market, "id") },
            { "marginType", marginMode },
        };
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " setMarginMode() supports swap contracts only")) ;
        }
        return await this.v2PrivateAccountGroupPostFuturesMarginType(this.extend(request, parameters));
    }

    public async override Task<object> fetchLeverageTiers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchLeverageTiers
        * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v2PublicGetFuturesContract(parameters);
        //
        //     {
        //         "code":0,
        //         "data":[
        //             {
        //                 "symbol":"BTC-PERP",
        //                 "status":"Normal",
        //                 "displayName":"BTCUSDT",
        //                 "settlementAsset":"USDT",
        //                 "underlying":"BTC/USDT",
        //                 "tradingStartTime":1579701600000,
        //                 "priceFilter":{"minPrice":"1","maxPrice":"1000000","tickSize":"1"},
        //                 "lotSizeFilter":{"minQty":"0.0001","maxQty":"1000000000","lotSize":"0.0001"},
        //                 "commissionType":"Quote",
        //                 "commissionReserveRate":"0.001",
        //                 "marketOrderPriceMarkup":"0.03",
        //                 "marginRequirements":[
        //                     {"positionNotionalLowerBound":"0","positionNotionalUpperBound":"50000","initialMarginRate":"0.01","maintenanceMarginRate":"0.006"},
        //                     {"positionNotionalLowerBound":"50000","positionNotionalUpperBound":"200000","initialMarginRate":"0.02","maintenanceMarginRate":"0.012"},
        //                     {"positionNotionalLowerBound":"200000","positionNotionalUpperBound":"2000000","initialMarginRate":"0.04","maintenanceMarginRate":"0.024"},
        //                     {"positionNotionalLowerBound":"2000000","positionNotionalUpperBound":"20000000","initialMarginRate":"0.1","maintenanceMarginRate":"0.06"},
        //                     {"positionNotionalLowerBound":"20000000","positionNotionalUpperBound":"40000000","initialMarginRate":"0.2","maintenanceMarginRate":"0.12"},
        //                     {"positionNotionalLowerBound":"40000000","positionNotionalUpperBound":"1000000000","initialMarginRate":"0.333333","maintenanceMarginRate":"0.2"}
        //                 ]
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data");
        symbols = this.marketSymbols(symbols);
        return this.parseLeverageTiers(data, symbols, "symbol");
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        /**
         * @param {object} info Exchange market response for 1 market
         * @param {object} market CCXT market
         */
        //
        //    {
        //        "symbol":"BTC-PERP",
        //        "status":"Normal",
        //        "displayName":"BTCUSDT",
        //        "settlementAsset":"USDT",
        //        "underlying":"BTC/USDT",
        //        "tradingStartTime":1579701600000,
        //        "priceFilter":{"minPrice":"1","maxPrice":"1000000","tickSize":"1"},
        //        "lotSizeFilter":{"minQty":"0.0001","maxQty":"1000000000","lotSize":"0.0001"},
        //        "commissionType":"Quote",
        //        "commissionReserveRate":"0.001",
        //        "marketOrderPriceMarkup":"0.03",
        //        "marginRequirements":[
        //            {"positionNotionalLowerBound":"0","positionNotionalUpperBound":"50000","initialMarginRate":"0.01","maintenanceMarginRate":"0.006"},
        //            {"positionNotionalLowerBound":"50000","positionNotionalUpperBound":"200000","initialMarginRate":"0.02","maintenanceMarginRate":"0.012"},
        //            {"positionNotionalLowerBound":"200000","positionNotionalUpperBound":"2000000","initialMarginRate":"0.04","maintenanceMarginRate":"0.024"},
        //            {"positionNotionalLowerBound":"2000000","positionNotionalUpperBound":"20000000","initialMarginRate":"0.1","maintenanceMarginRate":"0.06"},
        //            {"positionNotionalLowerBound":"20000000","positionNotionalUpperBound":"40000000","initialMarginRate":"0.2","maintenanceMarginRate":"0.12"},
        //            {"positionNotionalLowerBound":"40000000","positionNotionalUpperBound":"1000000000","initialMarginRate":"0.333333","maintenanceMarginRate":"0.2"}
        //        ]
        //    }
        //
        object marginRequirements = this.safeValue(info, "marginRequirements", new List<object>() {});
        object id = this.safeString(info, "symbol");
        market = this.safeMarket(id, market);
        object tiers = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(marginRequirements)); postFixIncrement(ref i))
        {
            object tier = getValue(marginRequirements, i);
            object initialMarginRate = this.safeString(tier, "initialMarginRate");
            ((IList<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.sum(i, 1) },
                { "currency", getValue(market, "quote") },
                { "minNotional", this.safeNumber(tier, "positionNotionalLowerBound") },
                { "maxNotional", this.safeNumber(tier, "positionNotionalUpperBound") },
                { "maintenanceMarginRate", this.safeNumber(tier, "maintenanceMarginRate") },
                { "maxLeverage", this.parseNumber(Precise.stringDiv("1", initialMarginRate)) },
                { "info", tier },
            });
        }
        return tiers;
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        // {
        //     "assetCode":      "USDT",
        //     "assetName":      "Tether",
        //     "precisionScale":  9,
        //     "nativeScale":     4,
        //     "blockChain": [
        //         {
        //             "chainName":        "Omni",
        //             "withdrawFee":      "30.0",
        //             "allowDeposit":      true,
        //             "allowWithdraw":     true,
        //             "minDepositAmt":    "0.0",
        //             "minWithdrawal":    "50.0",
        //             "numConfirmations":  3
        //         },
        //     ]
        // }
        //
        object blockChains = this.safeValue(fee, "blockChain", new List<object>() {});
        object blockChainsLength = getArrayLength(blockChains);
        object result = new Dictionary<string, object>() {
            { "info", fee },
            { "withdraw", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
        for (object i = 0; isLessThan(i, blockChainsLength); postFixIncrement(ref i))
        {
            object blockChain = getValue(blockChains, i);
            object networkId = this.safeString(blockChain, "chainName");
            object currencyCode = this.safeString(currency, "code");
            object networkCode = this.networkIdToCode(networkId, currencyCode);
            ((IDictionary<string,object>)getValue(result, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                { "deposit", new Dictionary<string, object>() {
                    { "fee", null },
                    { "percentage", null },
                } },
                { "withdraw", new Dictionary<string, object>() {
                    { "fee", this.safeNumber(blockChain, "withdrawFee") },
                    { "percentage", false },
                } },
            };
            if (isTrue(isEqual(blockChainsLength, 1)))
            {
                ((IDictionary<string,object>)getValue(result, "withdraw"))["fee"] = this.safeNumber(blockChain, "withdrawFee");
                ((IDictionary<string,object>)getValue(result, "withdraw"))["percentage"] = false;
            }
        }
        return result;
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://ascendex.github.io/ascendex-pro-api/#list-all-assets
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v2PublicGetAssets(parameters);
        object data = this.safeList(response, "data");
        return this.parseDepositWithdrawFees(data, codes, "assetCode");
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#transfer
        * @description transfer currency internally between wallets on the same account
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object account = this.safeValue(this.accounts, 0, new Dictionary<string, object>() {});
        object accountGroup = this.safeString(account, "id");
        object currency = this.currency(code);
        amount = this.currencyToPrecision(code, amount);
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, toAccount);
        if (isTrue(isTrue(!isEqual(fromId, "cash")) && isTrue(!isEqual(toId, "cash"))))
        {
            throw new ExchangeError ((string)add(this.id, " transfer() only supports direct balance transfer between spot and swap, spot and margin")) ;
        }
        object request = new Dictionary<string, object>() {
            { "account-group", accountGroup },
            { "amount", amount },
            { "asset", getValue(currency, "id") },
            { "fromAccount", fromId },
            { "toAccount", toId },
        };
        object response = await this.v1PrivateAccountGroupPostTransfer(this.extend(request, parameters));
        //
        //    { "code": "0" }
        //
        object transferOptions = this.safeValue(this.options, "transfer", new Dictionary<string, object>() {});
        object fillResponseFromRequest = this.safeBool(transferOptions, "fillResponseFromRequest", true);
        object transfer = this.parseTransfer(response, currency);
        if (isTrue(fillResponseFromRequest))
        {
            ((IDictionary<string,object>)transfer)["fromAccount"] = fromAccount;
            ((IDictionary<string,object>)transfer)["toAccount"] = toAccount;
            ((IDictionary<string,object>)transfer)["amount"] = amount;
            ((IDictionary<string,object>)transfer)["currency"] = code;
        }
        return transfer;
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        //    { "code": "0" }
        //
        object status = this.safeInteger(transfer, "code");
        object currencyCode = this.safeCurrencyCode(null, currency);
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", null },
            { "timestamp", null },
            { "datetime", null },
            { "currency", currencyCode },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", this.parseTransferStatus(status) },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        if (isTrue(isEqual(status, 0)))
        {
            return "ok";
        }
        return "failed";
    }

    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchFundingHistory
        * @description fetch the history of funding payments paid and received on this account
        * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#funding-payment-history
        * @param {string} [symbol] unified market symbol
        * @param {int} [since] the earliest time in ms to fetch funding history for
        * @param {int} [limit] the maximum number of funding history structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallIncremental("fetchFundingHistory", symbol, since, limit, parameters, "page", 25);
        }
        object account = this.safeValue(this.accounts, 0, new Dictionary<string, object>() {});
        object accountGroup = this.safeString(account, "id");
        object request = new Dictionary<string, object>() {
            { "account-group", accountGroup },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["pageSize"] = limit;
        }
        object response = await this.v2PrivateAccountGroupGetFuturesFundingPayments(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "data": [
        //                 {
        //                     "timestamp": 1640476800000,
        //                     "symbol": "BTC-PERP",
        //                     "paymentInUSDT": "-0.013991178",
        //                     "fundingRate": "0.000173497"
        //                 },
        //             ],
        //             "page": 1,
        //             "pageSize": 3,
        //             "hasNext": true
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeList(data, "data", new List<object>() {});
        return this.parseIncomes(rows, market, since, limit);
    }

    public override object parseIncome(object income, object market = null)
    {
        //
        //     {
        //         "timestamp": 1640476800000,
        //         "symbol": "BTC-PERP",
        //         "paymentInUSDT": "-0.013991178",
        //         "fundingRate": "0.000173497"
        //     }
        //
        object marketId = this.safeString(income, "symbol");
        object timestamp = this.safeInteger(income, "timestamp");
        return new Dictionary<string, object>() {
            { "info", income },
            { "symbol", this.safeSymbol(marketId, market, "-", "swap") },
            { "code", "USDT" },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", null },
            { "amount", this.safeNumber(income, "paymentInUSDT") },
        };
    }

    public async override Task<object> fetchMarginModes(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchMarginMode
        * @description fetches the set margin mode of the user
        * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#position
        * @param {string[]} [symbols] a list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [margin mode structures]{@link https://docs.ccxt.com/#/?id=margin-mode-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object account = this.safeValue(this.accounts, 0, new Dictionary<string, object>() {});
        object accountGroup = this.safeString(account, "id");
        object request = new Dictionary<string, object>() {
            { "account-group", accountGroup },
        };
        object response = await this.v2PrivateAccountGroupGetFuturesPosition(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        //             "ac": "FUTURES",
        //             "collaterals": [
        //                 {
        //                     "asset": "USDT",
        //                     "balance": "44.570287262",
        //                     "referencePrice": "1",
        //                     "discountFactor": "1"
        //                 }
        //             ],
        //             "contracts": [
        //                 {
        //                     "symbol": "BTC-PERP",
        //                     "side": "LONG",
        //                     "position": "0.0001",
        //                     "referenceCost": "-3.12277254",
        //                     "unrealizedPnl": "-0.001700233",
        //                     "realizedPnl": "0",
        //                     "avgOpenPrice": "31209",
        //                     "marginType": "isolated",
        //                     "isolatedMargin": "1.654972977",
        //                     "leverage": "2",
        //                     "takeProfitPrice": "0",
        //                     "takeProfitTrigger": "market",
        //                     "stopLossPrice": "0",
        //                     "stopLossTrigger": "market",
        //                     "buyOpenOrderNotional": "0",
        //                     "sellOpenOrderNotional": "0",
        //                     "markPrice": "31210.723063672",
        //                     "indexPrice": "31223.148857925"
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object marginModes = this.safeList(data, "contracts", new List<object>() {});
        return this.parseMarginModes(marginModes, symbols, "symbol");
    }

    public override object parseMarginMode(object marginMode, object market = null)
    {
        object marketId = this.safeString(marginMode, "symbol");
        object marginType = this.safeString(marginMode, "marginType");
        object margin = ((bool) isTrue((isEqual(marginType, "crossed")))) ? "cross" : "isolated";
        return new Dictionary<string, object>() {
            { "info", marginMode },
            { "symbol", this.safeSymbol(marketId, market) },
            { "marginMode", margin },
        };
    }

    public async override Task<object> fetchLeverages(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name ascendex#fetchLeverages
        * @description fetch the set leverage for all contract markets
        * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#position
        * @param {string[]} [symbols] a list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [leverage structures]{@link https://docs.ccxt.com/#/?id=leverage-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object account = this.safeValue(this.accounts, 0, new Dictionary<string, object>() {});
        object accountGroup = this.safeString(account, "id");
        object request = new Dictionary<string, object>() {
            { "account-group", accountGroup },
        };
        object response = await this.v2PrivateAccountGroupGetFuturesPosition(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        //             "ac": "FUTURES",
        //             "collaterals": [
        //                 {
        //                     "asset": "USDT",
        //                     "balance": "44.570287262",
        //                     "referencePrice": "1",
        //                     "discountFactor": "1"
        //                 }
        //             ],
        //             "contracts": [
        //                 {
        //                     "symbol": "BTC-PERP",
        //                     "side": "LONG",
        //                     "position": "0.0001",
        //                     "referenceCost": "-3.12277254",
        //                     "unrealizedPnl": "-0.001700233",
        //                     "realizedPnl": "0",
        //                     "avgOpenPrice": "31209",
        //                     "marginType": "isolated",
        //                     "isolatedMargin": "1.654972977",
        //                     "leverage": "2",
        //                     "takeProfitPrice": "0",
        //                     "takeProfitTrigger": "market",
        //                     "stopLossPrice": "0",
        //                     "stopLossTrigger": "market",
        //                     "buyOpenOrderNotional": "0",
        //                     "sellOpenOrderNotional": "0",
        //                     "markPrice": "31210.723063672",
        //                     "indexPrice": "31223.148857925"
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object leverages = this.safeList(data, "contracts", new List<object>() {});
        return this.parseLeverages(leverages, symbols, "symbol");
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        object marketId = this.safeString(leverage, "symbol");
        object leverageValue = this.safeInteger(leverage, "leverage");
        object marginType = this.safeString(leverage, "marginType");
        object marginMode = ((bool) isTrue((isEqual(marginType, "crossed")))) ? "cross" : "isolated";
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", this.safeSymbol(marketId, market) },
            { "marginMode", marginMode },
            { "longLeverage", leverageValue },
            { "shortLeverage", leverageValue },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object version = getValue(api, 0);
        object access = getValue(api, 1);
        object type = this.safeString(((object)api), 2);
        object url = "";
        object accountCategory = (isEqual(type, "accountCategory"));
        if (isTrue(isTrue(accountCategory) || isTrue((isEqual(type, "accountGroup")))))
        {
            url = add(url, this.implodeParams("/{account-group}", parameters));
            parameters = this.omit(parameters, "account-group");
        }
        object request = this.implodeParams(path, parameters);
        url = add(url, "/api/pro/");
        if (isTrue(isEqual(version, "v2")))
        {
            if (isTrue(isEqual(type, "data")))
            {
                request = add(add(add("data/", version), "/"), request);
            } else
            {
                request = add(add(version, "/"), request);
            }
        } else
        {
            url = add(url, add(version, "/"));
        }
        if (isTrue(accountCategory))
        {
            url = add(url, this.implodeParams("{account-category}/", parameters));
        }
        parameters = this.omit(parameters, "account-category");
        url = add(url, request);
        if (isTrue(isTrue(isTrue((isEqual(version, "v1"))) && isTrue((isEqual(request, "cash/balance")))) || isTrue((isEqual(request, "margin/balance")))))
        {
            request = "balance";
        }
        if (isTrue(isTrue((isEqual(version, "v1"))) && isTrue((isEqual(request, "spot/fee")))))
        {
            request = "fee";
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(request, "subuser"), 0)))
        {
            object parts = ((string)request).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
            request = getValue(parts, 2);
        }
        parameters = this.omit(parameters, this.extractParams(path));
        if (isTrue(isEqual(access, "public")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.urlencode(parameters)));
            }
        } else
        {
            this.checkRequiredCredentials();
            object timestamp = ((object)this.milliseconds()).ToString();
            object payload = add(add(timestamp, "+"), request);
            object hmac = this.hmac(this.encode(payload), this.encode(this.secret), sha256, "base64");
            headers = new Dictionary<string, object>() {
                { "x-auth-key", this.apiKey },
                { "x-auth-timestamp", timestamp },
                { "x-auth-signature", hmac },
            };
            if (isTrue(isEqual(method, "GET")))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
                {
                    url = add(url, add("?", this.urlencode(parameters)));
                }
            } else
            {
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
                body = this.json(parameters);
            }
        }
        url = add(getValue(getValue(this.urls, "api"), "rest"), url);
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        //
        //     {"code": 6010, "message": "Not enough balance."}
        //     {"code": 60060, "message": "The order is already filled or canceled."}
        //     {"code":2100,"message":"ApiKeyFailure"}
        //     {"code":300001,"message":"Price is too low from market price.","reason":"INVALID_PRICE","accountId":"cshrHKLZCjlZ2ejqkmvIHHtPmLYqdnda","ac":"CASH","action":"place-order","status":"Err","info":{"symbol":"BTC/USDT"}}
        //
        object code = this.safeString(response, "code");
        object message = this.safeString(response, "message");
        object error = isTrue((!isEqual(code, null))) && isTrue((!isEqual(code, "0")));
        if (isTrue(isTrue(error) || isTrue((!isEqual(message, null)))))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
