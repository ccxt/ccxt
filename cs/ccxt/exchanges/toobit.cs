namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class toobit : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "toobit" },
            { "name", "Toobit" },
            { "countries", new List<object>() {"KY"} },
            { "version", "v1" },
            { "rateLimit", 20 },
            { "certified", false },
            { "pro", false },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "createOrder", true },
                { "fetchBalance", true },
                { "fetchBidsAsks", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", true },
                { "fetchLastPrices", true },
                { "fetchLedger", true },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchStatus", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchWithdrawals", true },
                { "setMarginMode", true },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/3fc13870-5406-431b-8be0-2aab69c4f225" },
                { "api", new Dictionary<string, object>() {
                    { "common", "https://api.toobit.com" },
                    { "private", "https://api.toobit.com" },
                } },
                { "www", "https://www.toobit.com/" },
                { "doc", new List<object>() {"https://toobit-docs.github.io/apidocs/spot/v1/en/", "https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/"} },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://www.toobit.com/en-US/r?i=IFFPy0" },
                    { "discount", 0.1 },
                } },
                { "fees", "https://www.toobit.com/fee" },
            } },
            { "api", new Dictionary<string, object>() {
                { "common", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "api/v1/time", 1 },
                        { "api/v1/ping", 1 },
                        { "api/v1/exchangeInfo", 1 },
                        { "quote/v1/depth", 1 },
                        { "quote/v1/depth/merged", 1 },
                        { "quote/v1/trades", 1 },
                        { "quote/v1/klines", 1 },
                        { "quote/v1/index/klines", 1 },
                        { "quote/v1/markPrice/klines", 1 },
                        { "quote/v1/markPrice", 1 },
                        { "quote/v1/index", 1 },
                        { "quote/v1/ticker/24hr", 40 },
                        { "quote/v1/contract/ticker/24hr", 40 },
                        { "quote/v1/ticker/price", 1 },
                        { "quote/v1/ticker/bookTicker", 1 },
                        { "api/v1/futures/fundingRate", 1 },
                        { "api/v1/futures/historyFundingRate", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "api/v1/account", 5 },
                        { "api/v1/account/checkApiKey", 1 },
                        { "api/v1/spot/order", multiply(1, 1.67) },
                        { "api/v1/spot/openOrders", multiply(1, 1.67) },
                        { "api/v1/futures/openOrders", multiply(1, 1.67) },
                        { "api/v1/spot/tradeOrders", multiply(5, 1.67) },
                        { "api/v1/futures/historyOrders", multiply(5, 1.67) },
                        { "api/v1/account/trades", multiply(5, 1.67) },
                        { "api/v1/account/balanceFlow", 5 },
                        { "api/v1/account/depositOrders", 5 },
                        { "api/v1/account/withdrawOrders", 5 },
                        { "api/v1/account/deposit/address", 1 },
                        { "api/v1/subAccount", 5 },
                        { "api/v1/futures/accountLeverage", 1 },
                        { "api/v1/futures/order", multiply(1, 1.67) },
                        { "api/v1/futures/positions", multiply(5, 1.67) },
                        { "api/v1/futures/balance", 5 },
                        { "api/v1/futures/userTrades", multiply(5, 1.67) },
                        { "api/v1/futures/balanceFlow", 5 },
                        { "api/v1/futures/commissionRate", 5 },
                        { "api/v1/futures/todayPnl", 5 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "api/v1/spot/orderTest", multiply(1, 1.67) },
                        { "api/v1/spot/order", multiply(1, 1.67) },
                        { "api/v1/futures/order", multiply(1, 1.67) },
                        { "api/v1/spot/batchOrders", multiply(2, 1.67) },
                        { "api/v1/subAccount/transfer", 1 },
                        { "api/v1/account/withdraw", 1 },
                        { "api/v1/futures/marginType", 1 },
                        { "api/v1/futures/leverage", 1 },
                        { "api/v1/futures/batchOrders", multiply(2, 1.67) },
                        { "api/v1/futures/position/trading-stop", multiply(3, 1.67) },
                        { "api/v1/futures/positionMargin", 1 },
                        { "api/v1/userDataStream", 1 },
                        { "api/v1/listenKey", 1 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "api/v1/spot/order", multiply(1, 1.67) },
                        { "api/v1/futures/order", multiply(1, 1.67) },
                        { "api/v1/spot/openOrders", multiply(5, 1.67) },
                        { "api/v1/futures/batchOrders", multiply(5, 1.67) },
                        { "api/v1/spot/cancelOrderByIds", multiply(5, 1.67) },
                        { "api/v1/futures/cancelOrderByIds", multiply(5, 1.67) },
                        { "api/v1/listenKey", 1 },
                    } },
                    { "put", new Dictionary<string, object>() {
                        { "api/v1/listenKey", 1 },
                    } },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "8h", "8h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "1w", "1w" },
                { "1M", "1M" },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "-1000", typeof(OperationFailed) },
                    { "-1001", typeof(OperationFailed) },
                    { "-1002", typeof(PermissionDenied) },
                    { "-1003", typeof(RateLimitExceeded) },
                    { "-1004", typeof(BadRequest) },
                    { "-1006", typeof(OperationFailed) },
                    { "-1007", typeof(OperationFailed) },
                    { "-1014", typeof(OperationFailed) },
                    { "-1015", typeof(RateLimitExceeded) },
                    { "-1016", typeof(OperationRejected) },
                    { "-1020", typeof(OperationRejected) },
                    { "-1021", typeof(OperationRejected) },
                    { "-1022", typeof(OperationRejected) },
                    { "-1100", typeof(BadRequest) },
                    { "-1101", typeof(BadRequest) },
                    { "-1102", typeof(BadRequest) },
                    { "-1103", typeof(BadRequest) },
                    { "-1104", typeof(BadRequest) },
                    { "-1105", typeof(BadRequest) },
                    { "-1106", typeof(BadRequest) },
                    { "-1111", typeof(BadRequest) },
                    { "-1112", typeof(OperationRejected) },
                    { "-1114", typeof(BadRequest) },
                    { "-1115", typeof(BadRequest) },
                    { "-1116", typeof(BadRequest) },
                    { "-1117", typeof(BadRequest) },
                    { "-1118", typeof(InvalidOrder) },
                    { "-1119", typeof(InvalidOrder) },
                    { "-1120", typeof(BadRequest) },
                    { "-1121", typeof(BadRequest) },
                    { "-1125", typeof(OperationRejected) },
                    { "-1127", typeof(OperationRejected) },
                    { "-1128", typeof(BadRequest) },
                    { "-1130", typeof(BadRequest) },
                    { "-1132", typeof(OperationRejected) },
                    { "-1133", typeof(OperationRejected) },
                    { "-1134", typeof(OperationRejected) },
                    { "-1135", typeof(OperationRejected) },
                    { "-1136", typeof(OperationRejected) },
                    { "-1137", typeof(OperationRejected) },
                    { "-1138", typeof(OperationRejected) },
                    { "-1139", typeof(OperationRejected) },
                    { "-1140", typeof(OperationRejected) },
                    { "-1141", typeof(InvalidOrder) },
                    { "-1142", typeof(InvalidOrder) },
                    { "-1143", typeof(InvalidOrder) },
                    { "-1144", typeof(OperationRejected) },
                    { "-1145", typeof(OperationRejected) },
                    { "-1146", typeof(OperationFailed) },
                    { "-1147", typeof(OperationFailed) },
                    { "-1193", typeof(OperationRejected) },
                    { "-1194", typeof(OperationRejected) },
                    { "-1195", typeof(OperationRejected) },
                    { "-1196", typeof(OperationRejected) },
                    { "-1197", typeof(OperationRejected) },
                    { "-1198", typeof(OperationRejected) },
                    { "-1199", typeof(OperationRejected) },
                    { "-1200", typeof(OperationRejected) },
                    { "-1201", typeof(OperationRejected) },
                    { "-1202", typeof(OperationRejected) },
                    { "-1203", typeof(OperationRejected) },
                    { "-1206", typeof(OperationRejected) },
                    { "-2010", typeof(OperationFailed) },
                    { "-2011", typeof(OperationFailed) },
                    { "-2013", typeof(InvalidOrder) },
                    { "-2014", typeof(PermissionDenied) },
                    { "-2015", typeof(PermissionDenied) },
                    { "-2016", typeof(BadRequest) },
                    { "-3050", typeof(ExchangeError) },
                    { "-3101", typeof(OperationRejected) },
                    { "-3102", typeof(OperationRejected) },
                    { "-3103", typeof(BadRequest) },
                    { "-3105", typeof(OperationRejected) },
                    { "-3107", typeof(OperationRejected) },
                    { "-3108", typeof(OperationRejected) },
                    { "-3109", typeof(OperationRejected) },
                    { "-3110", typeof(InsufficientFunds) },
                    { "-3116", typeof(OperationRejected) },
                    { "-3117", typeof(OperationRejected) },
                    { "-3120", typeof(OperationRejected) },
                    { "-3124", typeof(OperationRejected) },
                    { "-3125", typeof(OperationRejected) },
                    { "-3126", typeof(OperationRejected) },
                    { "-3127", typeof(OperationFailed) },
                    { "-3128", typeof(OperationRejected) },
                    { "-3129", typeof(BadRequest) },
                    { "-3130", typeof(OperationRejected) },
                    { "-3131", typeof(NotSupported) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Unknown order sent", typeof(OrderNotFound) },
                    { "Duplicate order sent", typeof(InvalidOrder) },
                    { "Market is closed", typeof(OperationRejected) },
                    { "Account has insufficient balance for requested action", typeof(InsufficientFunds) },
                    { "Market orders are not supported for this symbol", typeof(OperationRejected) },
                    { "Iceberg orders are not supported for this symbol", typeof(OperationRejected) },
                    { "Stop loss orders are not supported for this symbol", typeof(OperationRejected) },
                    { "Stop loss limit orders are not supported for this symbol", typeof(OperationRejected) },
                    { "Take profit orders are not supported for this symbol", typeof(OperationRejected) },
                    { "Take profit limit orders are not supported for this symbol", typeof(OperationRejected) },
                    { "QTY is zero or less", typeof(BadRequest) },
                    { "IcebergQty exceeds QTY", typeof(OperationRejected) },
                    { "This action disabled is on this account", typeof(PermissionDenied) },
                    { "Unsupported order combination", typeof(BadRequest) },
                    { "Order would trigger immediately", typeof(OperationRejected) },
                    { "Cancel order is invalid. Check origClOrdId and orderId", typeof(OperationRejected) },
                    { "Order would immediately match and take", typeof(OperationRejected) },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "options", new Dictionary<string, object>() {
                { "defaultType", "spot" },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "MAIN" },
                    { "swap", "FUTURES" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "BTC", "BTC" },
                    { "ERC20", "ETH" },
                    { "ETH", "ETH" },
                    { "BEP20", "BSC" },
                    { "TRC20", "TRX" },
                    { "SOL", "SOL" },
                    { "MATIC", "MATIC" },
                    { "ARBONE", "ARBITRUM" },
                    { "BASE", "BASE" },
                    { "TON", "TON" },
                    { "AVAXC", "AVAXC" },
                    { "DOGE", "DOGE" },
                    { "XRP", "XRP" },
                    { "DOT", "DOT" },
                    { "ADA", "ADA" },
                    { "LTC", "LTC" },
                    { "APT", "APT" },
                    { "ATOM", "ATOM" },
                    { "ALGO", "ALGO" },
                    { "NEAR", "NEAR" },
                    { "XLM", "XLM" },
                    { "SUI", "SUI" },
                    { "ETC", "ETC" },
                    { "EOS", "EOS" },
                    { "WAVES", "WAVES" },
                    { "ICP", "ICP" },
                    { "ONE", "ONE" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "ETH", "ERC20" },
                    { "ERC20", "ERC20" },
                } },
            } },
            { "features", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "sandbox", false },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", true },
                        { "triggerPriceType", null },
                        { "triggerDirection", false },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "trailing", false },
                        { "leverage", false },
                        { "marketBuyRequiresPrice", false },
                        { "marketBuyByCost", false },
                        { "selfTradePrevention", false },
                        { "iceberg", false },
                    } },
                    { "createOrders", null },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 1000 },
                    } },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 1000 },
                        { "daysBack", 100000 },
                        { "untilDays", 100000 },
                        { "symbolRequired", true },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 1000 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 500 },
                        { "daysBack", 100000 },
                        { "untilDays", 100000 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchClosedOrders", null },
                } },
                { "forDerivatives", new Dictionary<string, object>() {
                    { "createOrders", null },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
            } },
        });
    }

    /**
     * @method
     * @name toobit#fetchStatus
     * @description the latest known information on the availability of the exchange API
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#test-connectivity
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
     */
    public async override Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.commonGetApiV1Ping(parameters);
        return new Dictionary<string, object>() {
            { "status", "ok" },
            { "updated", null },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    /**
     * @method
     * @name toobit#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#check-server-time
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.commonGetApiV1Time(parameters);
        //
        //     {
        //         "serverTime": 1699827319559
        //     }
        //
        return this.safeInteger(response, "serverTime");
    }

    /**
     * @method
     * @name toobit#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.commonGetApiV1ExchangeInfo(parameters);
        ((IDictionary<string,object>)this.options)["exchangeInfo"] = response; // we store it in options for later use in fetchMarkets
        //
        //    {
        //        "timezone": "UTC",
        //        "serverTime": "1755583099926",
        //        "brokerFilters": [],
        //        "symbols": [
        //            {
        //                "filters": [
        //                    {
        //                        "minPrice": "0.01",
        //                        "maxPrice": "10000000.00000000",
        //                        "tickSize": "0.01",
        //                        "filterType": "PRICE_FILTER"
        //                    },
        //                    {
        //                        "minQty": "0.0001",
        //                        "maxQty": "4000",
        //                        "stepSize": "0.0001",
        //                        "filterType": "LOT_SIZE"
        //                    },
        //                    {
        //                        "minNotional": "5",
        //                        "filterType": "MIN_NOTIONAL"
        //                    },
        //                    {
        //                        "minAmount": "5",
        //                        "maxAmount": "6600000",
        //                        "minBuyPrice": "0.01",
        //                        "filterType": "TRADE_AMOUNT"
        //                    },
        //                    {
        //                        "maxSellPrice": "99999999",
        //                        "buyPriceUpRate": "0.1",
        //                        "sellPriceDownRate": "0.1",
        //                        "filterType": "LIMIT_TRADING"
        //                    },
        //                    {
        //                        "buyPriceUpRate": "0.1",
        //                        "sellPriceDownRate": "0.1",
        //                        "filterType": "MARKET_TRADING"
        //                    },
        //                    {
        //                        "noAllowMarketStartTime": "0",
        //                        "noAllowMarketEndTime": "0",
        //                        "limitOrderStartTime": "0",
        //                        "limitOrderEndTime": "0",
        //                        "limitMinPrice": "0",
        //                        "limitMaxPrice": "0",
        //                        "filterType": "OPEN_QUOTE"
        //                    }
        //                ],
        //                "exchangeId": "301",
        //                "symbol": "ETHUSDT",
        //                "symbolName": "ETHUSDT",
        //                "status": "TRADING",
        //                "baseAsset": "ETH",
        //                "baseAssetName": "ETH",
        //                "baseAssetPrecision": "0.0001",
        //                "quoteAsset": "USDT",
        //                "quoteAssetName": "USDT",
        //                "quotePrecision": "0.01",
        //                "icebergAllowed": false,
        //                "isAggregate": false,
        //                "allowMargin": true,
        //             }
        //        ],
        //        "options": [],
        //        "contracts": [
        //            {
        //                 "filters": [ ... ],
        //                 "exchangeId": "301",
        //                 "symbol": "BTC-SWAP-USDT",
        //                 "symbolName": "BTC-SWAP-USDTUSDT",
        //                 "status": "TRADING",
        //                 "baseAsset": "BTC-SWAP-USDT",
        //                 "baseAssetPrecision": "0.001",
        //                 "quoteAsset": "USDT",
        //                 "quoteAssetPrecision": "0.1",
        //                 "icebergAllowed": false,
        //                 "inverse": false,
        //                 "index": "BTC",
        //                 "indexToken": "BTCUSDT",
        //                 "marginToken": "USDT",
        //                 "marginPrecision": "0.0001",
        //                 "contractMultiplier": "0.001",
        //                 "underlying": "BTC",
        //                 "riskLimits": [
        //                     {
        //                         "riskLimitId": "200020911",
        //                         "quantity": "42000.0",
        //                         "initialMargin": "0.02",
        //                         "maintMargin": "0.01",
        //                         "isWhite": false
        //                     },
        //                     {
        //                         "riskLimitId": "200020912",
        //                         "quantity": "84000.0",
        //                         "initialMargin": "0.04",
        //                         "maintMargin": "0.02",
        //                         "isWhite": false
        //                     },
        //                     ...
        //                 ]
        //            },
        //        ],
        //        "coins": [
        //            {
        //                "orgId": "9001",
        //                "coinId": "TCOM",
        //                "coinName": "TCOM",
        //                "coinFullName": "TCOM",
        //                "allowWithdraw": true,
        //                "allowDeposit": true,
        //                "chainTypes": [
        //                    {
        //                        "chainType": "BSC",
        //                        "withdrawFee": "49.55478",
        //                        "minWithdrawQuantity": "77",
        //                        "maxWithdrawQuantity": "0",
        //                        "minDepositQuantity": "48",
        //                        "allowDeposit": true,
        //                        "allowWithdraw": false
        //                    }
        //                ],
        //                "isVirtual": false
        //            },
        //          ...
        //
        object coins = this.safeList(response, "coins", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(coins)); postFixIncrement(ref i))
        {
            object coin = getValue(coins, i);
            object parsed = this.parseCurrency(coin);
            object code = getValue(parsed, "code");
            ((IDictionary<string,object>)result)[(string)code] = parsed;
        }
        return result;
    }

    public override object parseCurrency(object rawCurrency)
    {
        object id = this.safeString(rawCurrency, "coinId");
        object code = this.safeCurrencyCode(id);
        object networks = new Dictionary<string, object>() {};
        object rawNetworks = this.safeList(rawCurrency, "chainTypes");
        for (object j = 0; isLessThan(j, getArrayLength(rawNetworks)); postFixIncrement(ref j))
        {
            object rawNetwork = getValue(rawNetworks, j);
            object networkId = this.safeString(rawNetwork, "chainType");
            object networkCode = this.networkIdToCode(networkId);
            ((IDictionary<string,object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                { "id", networkId },
                { "network", networkCode },
                { "margin", null },
                { "deposit", this.safeBool(rawNetwork, "allowDeposit") },
                { "withdraw", this.safeBool(rawNetwork, "allowWithdraw") },
                { "active", null },
                { "fee", this.safeNumber(rawNetwork, "withdrawFee") },
                { "precision", null },
                { "limits", new Dictionary<string, object>() {
                    { "deposit", new Dictionary<string, object>() {
                        { "min", this.safeNumber(rawNetwork, "minDepositQuantity") },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.safeNumber(rawNetwork, "minWithdrawQuantity") },
                        { "max", this.safeNumber(rawNetwork, "maxWithdrawQuantity") },
                    } },
                } },
                { "info", rawNetwork },
            };
        }
        return this.safeCurrencyStructure(new Dictionary<string, object>() {
            { "id", id },
            { "code", code },
            { "name", this.safeString(rawCurrency, "coinFullName") },
            { "type", null },
            { "active", null },
            { "deposit", this.safeBool(rawCurrency, "allowDeposit") },
            { "withdraw", this.safeBool(rawCurrency, "allowWithdraw") },
            { "fee", null },
            { "precision", null },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "withdraw", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "networks", networks },
            { "info", rawCurrency },
        });
    }

    /**
     * @method
     * @name toobit#fetchMarkets
     * @description retrieves data on all markets for toobit
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#exchange-information
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#exchange-information
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = this.safeDict(this.options, "exchangeInfo");
        if (isTrue(!isEqual(response, null)))
        {
            ((IDictionary<string,object>)this.options)["exchangeInfo"] = null; // reset it to avoid using old cached data
        } else
        {
            response = await this.commonGetApiV1ExchangeInfo(parameters);
        }
        //
        //    {
        //        "timezone": "UTC",
        //        "serverTime": "1755583099926",
        //        "brokerFilters": [],
        //        "symbols": [
        //            {
        //                "filters": [
        //                    {
        //                        "minPrice": "0.01",
        //                        "maxPrice": "10000000.00000000",
        //                        "tickSize": "0.01",
        //                        "filterType": "PRICE_FILTER"
        //                    },
        //                    {
        //                        "minQty": "0.0001",
        //                        "maxQty": "4000",
        //                        "stepSize": "0.0001",
        //                        "filterType": "LOT_SIZE"
        //                    },
        //                    {
        //                        "minNotional": "5",
        //                        "filterType": "MIN_NOTIONAL"
        //                    },
        //                    {
        //                        "minAmount": "5",
        //                        "maxAmount": "6600000",
        //                        "minBuyPrice": "0.01",
        //                        "filterType": "TRADE_AMOUNT"
        //                    },
        //                    {
        //                        "maxSellPrice": "99999999",
        //                        "buyPriceUpRate": "0.1",
        //                        "sellPriceDownRate": "0.1",
        //                        "filterType": "LIMIT_TRADING"
        //                    },
        //                    {
        //                        "buyPriceUpRate": "0.1",
        //                        "sellPriceDownRate": "0.1",
        //                        "filterType": "MARKET_TRADING"
        //                    },
        //                    {
        //                        "noAllowMarketStartTime": "0",
        //                        "noAllowMarketEndTime": "0",
        //                        "limitOrderStartTime": "0",
        //                        "limitOrderEndTime": "0",
        //                        "limitMinPrice": "0",
        //                        "limitMaxPrice": "0",
        //                        "filterType": "OPEN_QUOTE"
        //                    }
        //                ],
        //                "exchangeId": "301",
        //                "symbol": "ETHUSDT",
        //                "symbolName": "ETHUSDT",
        //                "status": "TRADING",
        //                "baseAsset": "ETH",
        //                "baseAssetName": "ETH",
        //                "baseAssetPrecision": "0.0001",
        //                "quoteAsset": "USDT",
        //                "quoteAssetName": "USDT",
        //                "quotePrecision": "0.01",
        //                "icebergAllowed": false,
        //                "isAggregate": false,
        //                "allowMargin": true,
        //             }
        //        ],
        //        "options": [],
        //        "contracts": [
        //            {
        //                 "filters": [ ... ],
        //                 "exchangeId": "301",
        //                 "symbol": "BTC-SWAP-USDT",
        //                 "symbolName": "BTC-SWAP-USDTUSDT",
        //                 "status": "TRADING",
        //                 "baseAsset": "BTC-SWAP-USDT",
        //                 "baseAssetPrecision": "0.001",
        //                 "quoteAsset": "USDT",
        //                 "quoteAssetPrecision": "0.1",
        //                 "icebergAllowed": false,
        //                 "inverse": false,
        //                 "index": "BTC",
        //                 "indexToken": "BTCUSDT",
        //                 "marginToken": "USDT",
        //                 "marginPrecision": "0.0001",
        //                 "contractMultiplier": "0.001",
        //                 "underlying": "BTC",
        //                 "riskLimits": [
        //                     {
        //                         "riskLimitId": "200020911",
        //                         "quantity": "42000.0",
        //                         "initialMargin": "0.02",
        //                         "maintMargin": "0.01",
        //                         "isWhite": false
        //                     },
        //                     {
        //                         "riskLimitId": "200020912",
        //                         "quantity": "84000.0",
        //                         "initialMargin": "0.04",
        //                         "maintMargin": "0.02",
        //                         "isWhite": false
        //                     },
        //                     ...
        //                 ]
        //            },
        //        ],
        //        "coins": [
        //            {
        //                "orgId": "9001",
        //                "coinId": "TCOM",
        //                "coinName": "TCOM",
        //                "coinFullName": "TCOM",
        //                "allowWithdraw": true,
        //                "allowDeposit": true,
        //                "chainTypes": [
        //                    {
        //                        "chainType": "BSC",
        //                        "withdrawFee": "49.55478",
        //                        "minWithdrawQuantity": "77",
        //                        "maxWithdrawQuantity": "0",
        //                        "minDepositQuantity": "48",
        //                        "allowDeposit": true,
        //                        "allowWithdraw": false
        //                    }
        //                ],
        //                "isVirtual": false
        //            },
        //          ...
        //
        object symbols = this.safeList(response, "symbols", new List<object>() {});
        object contracts = this.safeList(response, "contracts", new List<object>() {});
        object all = this.arrayConcat(symbols, contracts);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(all)); postFixIncrement(ref i))
        {
            object market = getValue(all, i);
            object parsed = this.parseMarket(market);
            ((IList<object>)result).Add(parsed);
        }
        return result;
    }

    public override object parseMarket(object market)
    {
        object id = this.safeString(market, "symbol");
        object baseId = this.safeString(market, "baseAsset");
        object quoteId = this.safeString(market, "quoteAsset");
        object baseParts = ((string)baseId).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
        object baseIdClean = getValue(baseParts, 0);
        object bs = this.safeCurrencyCode(baseIdClean);
        object quote = this.safeCurrencyCode(quoteId);
        object settleId = this.safeString(market, "marginToken");
        object settle = this.safeCurrencyCode(settleId);
        object status = this.safeString(market, "status");
        object active = (isEqual(status, "TRADING"));
        object filters = this.safeList(market, "filters", new List<object>() {});
        object filtersByType = this.indexBy(filters, "filterType");
        object priceFilter = this.safeDict(filtersByType, "PRICE_FILTER", new Dictionary<string, object>() {});
        object lotSizeFilter = this.safeDict(filtersByType, "LOT_SIZE", new Dictionary<string, object>() {});
        object minNotionalFilter = this.safeDict(filtersByType, "MIN_NOTIONAL", new Dictionary<string, object>() {});
        object symbol = add(add(bs, "/"), quote);
        object isContract = (inOp(market, "contractMultiplier"));
        object inverse = this.safeBool2(market, "isInverse", "inverse");
        if (isTrue(isContract))
        {
            symbol = add(symbol, add(":", settle));
        }
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", id },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", ((bool) isTrue(isContract)) ? "swap" : "spot" },
            { "spot", !isTrue(isContract) },
            { "margin", false },
            { "swap", isContract },
            { "future", false },
            { "option", false },
            { "active", active },
            { "contract", isContract },
            { "linear", ((bool) isTrue(isContract)) ? !isTrue(inverse) : null },
            { "inverse", ((bool) isTrue(isContract)) ? inverse : null },
            { "contractSize", this.safeNumber(market, "contractMultiplier") },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber(lotSizeFilter, "stepSize") },
                { "price", this.safeNumber(priceFilter, "tickSize") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(lotSizeFilter, "minQty") },
                    { "max", this.safeNumber(lotSizeFilter, "maxQty") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", this.safeNumber(priceFilter, "minPrice") },
                    { "max", this.safeNumber(priceFilter, "maxPrice") },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", this.safeNumber(minNotionalFilter, "minNotional") },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        });
    }

    /**
     * @method
     * @name toobit#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#order-book
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#order-book
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.commonGetQuoteV1Depth(this.extend(request, parameters));
        //
        //    {
        //        "t": "1755593995237",
        //        "b": [
        //            [
        //                "115186.47",
        //                "4.184864"
        //            ],
        //            [
        //                "115186.46",
        //                "0.002756"
        //            ],
        //            ...
        //        ],
        //        "a": [
        //            [
        //                "115186.48",
        //                "6.137369"
        //            ],
        //            [
        //                "115186.49",
        //                "0.002914"
        //            ],
        //            ...
        //        ]
        //    }
        //
        object timestamp = this.safeInteger(response, "t");
        return this.parseOrderBook(response, getValue(market, "symbol"), timestamp, "b", "a");
    }

    /**
     * @method
     * @name toobit#fetchTrades
     * @description get a list of the most recent trades for a particular symbol
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#recent-trades-list
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#recent-trades-list
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum number of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.commonGetQuoteV1Trades(this.extend(request, parameters));
        //
        //    [
        //        {
        //            "t": "1755594277287",
        //            "p": "115276.99",
        //            "q": "0.001508",
        //            "ibm": true
        //        },
        //    ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades
        //
        //        {
        //            "t": "1755594277287",
        //            "p": "115276.99",
        //            "q": "0.001508",
        //            "ibm": true
        //        },
        //        // watchTrades have also an additional fields:
        //             "v": "4864732022868004630",   // trade id
        //             "m": true,                    // is the buyer taker
        //
        // fetchMyTrades
        //
        //        {
        //            "id": "2024934575206059008",
        //            "symbol": "ETHUSDT",
        //            "orderId": "2024934575097029888",
        //            "ticketId": "4864450547563401875",
        //            "price": "4641.21",
        //            "qty": "0.001",
        //            "time": "1756127012094",
        //            "isMaker": false,
        //            "commission": "0.00464121",
        //            "commissionAsset": "USDT",
        //            "makerRebate": "0",
        //            "symbolName": "ETHUSDT",                 // only in SPOT
        //            "isBuyer": false,                        // only in SPOT
        //            "feeAmount": "0.00464121",               // only in SPOT
        //            "feeCoinId": "USDT",                     // only in SPOT
        //            "fee": {                                 // only in SPOT
        //                "feeCoinId": "USDT",
        //                "feeCoinName": "USDT",
        //                "fee": "0.00464121"
        //            },
        //            "type": "LIMIT",                         // only in CONTRACT
        //            "side": "BUY_OPEN",                      // only in CONTRACT
        //            "realizedPnl": "0",                      // only in CONTRACT
        //        },
        //
        object timestamp = this.safeInteger2(trade, "t", "time");
        object priceString = this.safeString2(trade, "p", "price");
        object amountString = this.safeString2(trade, "q", "qty");
        object isBuyer = this.safeBool(trade, "isBuyer");
        object side = null;
        object isBuyerMaker = this.safeBool(trade, "ibm");
        if (isTrue(isEqual(isBuyerMaker, null)))
        {
            object isBuyerTaker = this.safeBool(trade, "m");
            if (isTrue(!isEqual(isBuyerTaker, null)))
            {
                isBuyerMaker = !isTrue(isBuyerTaker);
            }
        }
        if (isTrue(!isEqual(isBuyerMaker, null)))
        {
            if (isTrue(isBuyerMaker))
            {
                side = "sell";
            } else
            {
                side = "buy";
            }
        } else
        {
            if (isTrue(isBuyer))
            {
                side = "buy";
            } else
            {
                side = "sell";
            }
        }
        object feeCurrencyId = this.safeString(trade, "feeCoinId");
        object feeAmount = this.safeString(trade, "feeAmount");
        object fee = null;
        if (isTrue(!isEqual(feeAmount, null)))
        {
            fee = new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(feeCurrencyId) },
                { "cost", feeAmount },
            };
        }
        object isMaker = this.safeBool(trade, "isMaker");
        object takerOrMaker = null;
        if (isTrue(!isEqual(isMaker, null)))
        {
            takerOrMaker = ((bool) isTrue(isMaker)) ? "maker" : "taker";
        }
        market = this.safeMarket(null, market);
        object symbol = getValue(market, "symbol");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", this.safeString2(trade, "id", "v") },
            { "order", this.safeString(trade, "orderId") },
            { "type", null },
            { "side", side },
            { "amount", amountString },
            { "price", priceString },
            { "cost", null },
            { "takerOrMaker", takerOrMaker },
            { "fee", fee },
        }, market);
    }

    /**
     * @method
     * @name toobit#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#kline-candlestick-data
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#kline-candlestick-data
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "interval", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, "until");
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        object endpoint = null;
        var endpointparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "price");
        endpoint = ((IList<object>)endpointparametersVariable)[0];
        parameters = ((IList<object>)endpointparametersVariable)[1];
        if (isTrue(isEqual(endpoint, "index")))
        {
            response = await this.commonGetQuoteV1IndexKlines(this.extend(request, parameters));
        } else if (isTrue(isEqual(endpoint, "mark")))
        {
            response = await this.commonGetQuoteV1MarkPriceKlines(this.extend(request, parameters));
        } else
        {
            response = await this.commonGetQuoteV1Klines(this.extend(request, parameters));
        }
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        return new List<object> {this.safeIntegerN(ohlcv, new List<object>() {0, "time", "t"}), this.safeNumberN(ohlcv, new List<object>() {1, "open", "o"}), this.safeNumberN(ohlcv, new List<object>() {2, "high", "h"}), this.safeNumberN(ohlcv, new List<object>() {3, "low", "l"}), this.safeNumberN(ohlcv, new List<object>() {4, "close", "c"}), this.safeNumberN(ohlcv, new List<object>() {5, "volume", "v"})};
    }

    /**
     * @method
     * @name toobit#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#24hr-ticker-price-change-statistics
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#24hr-ticker-price-change-statistics
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object type = null;
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = this.safeString(symbols, 0);
            market = this.market(symbol);
            object length = getArrayLength(symbols);
            if (isTrue(isEqual(length, 1)))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
        }
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(type, "spot")))
        {
            response = await this.commonGetQuoteV1Ticker24hr(this.extend(request, parameters));
        } else
        {
            response = await this.commonGetQuoteV1ContractTicker24hr(this.extend(request, parameters));
        }
        //
        //    [
        //        {
        //            "t": "1755601440162",
        //            "s": "GRDRUSDT",
        //            "o": "0.38",
        //            "h": "0.38",
        //            "l": "0.38",
        //            "c": "0.38",
        //            "v": "0",
        //            "qv": "0",
        //            "pc": "0",
        //            "pcp": "0"
        //        },
        //        ...
        //
        return this.parseTickers(response, symbols, parameters);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        object marketId = this.safeString(ticker, "s");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(ticker, "t");
        object last = this.safeString(ticker, "c");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "h") },
            { "low", this.safeString(ticker, "l") },
            { "bid", null },
            { "bidVolume", null },
            { "ask", null },
            { "askVolume", null },
            { "vwap", null },
            { "open", this.safeString(ticker, "o") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", this.safeString(ticker, "pc") },
            { "percentage", this.safeString(ticker, "pcp") },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "v") },
            { "quoteVolume", this.safeString(ticker, "qv") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name toobit#fetchLastPrices
     * @description fetches the last price for multiple markets
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#symbol-price-ticker
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#symbol-price-ticker
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the last prices
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of lastprices structures
     */
    public async override Task<object> fetchLastPrices(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            object length = getArrayLength(symbols);
            if (isTrue(isEqual(length, 1)))
            {
                object market = this.market(getValue(symbols, 0));
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
        }
        object response = await this.commonGetQuoteV1TickerPrice(this.extend(request, parameters));
        //
        //    [
        //        {
        //            "s": "BNTUSDT",
        //            "si": "BNTUSDT",
        //            "p": "0.823"
        //        },
        //
        return this.parseLastPrices(response, symbols);
    }

    public override object parseLastPrice(object entry, object market = null)
    {
        object marketId = this.safeString(entry, "s");
        market = this.safeMarket(marketId, market);
        return new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", null },
            { "datetime", null },
            { "price", this.safeNumberOmitZero(entry, "price") },
            { "side", null },
            { "info", entry },
        };
    }

    /**
     * @method
     * @name toobit#fetchBidsAsks
     * @description fetches the bid and ask price and volume for multiple markets
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#symbol-order-book-ticker
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#symbol-order-book-ticker
     * @param {string[]} [symbols] unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchBidsAsks(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            object length = getArrayLength(symbols);
            if (isTrue(isEqual(length, 1)))
            {
                object market = this.market(getValue(symbols, 0));
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
        }
        object response = await this.commonGetQuoteV1TickerBookTicker(this.extend(request, parameters));
        //
        //    [
        //        {
        //            "s": "GRDRUSDT",
        //            "b": "0",
        //            "bq": "0",
        //            "a": "0",
        //            "aq": "0",
        //            "t": "1755936610506"
        //        }, ...
        //
        return this.parseBidsAsksCustom(response, symbols);
    }

    public virtual object parseBidsAsksCustom(object tickers, object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object results = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(tickers)); postFixIncrement(ref i))
        {
            object parsedTicker = this.parseBidAskCustom(getValue(tickers, i));
            object ticker = this.extend(parsedTicker, parameters);
            ((IList<object>)results).Add(ticker);
        }
        symbols = this.marketSymbols(symbols);
        return this.filterByArray(results, "symbol", symbols);
    }

    public virtual object parseBidAskCustom(object ticker)
    {
        return new Dictionary<string, object>() {
            { "timestamp", this.safeString(ticker, "t") },
            { "symbol", this.safeString(ticker, "s") },
            { "bid", this.safeNumber(ticker, "b") },
            { "bidVolume", this.safeNumber(ticker, "bq") },
            { "ask", this.safeNumber(ticker, "a") },
            { "askVolume", this.safeNumber(ticker, "aq") },
            { "info", ticker },
        };
    }

    /**
     * @method
     * @name toobit#fetchFundingRates
     * @description fetch the funding rate for multiple markets
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#funding-rate
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [funding rates structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexe by market symbols
     */
    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            object length = getArrayLength(symbols);
            if (isTrue(isEqual(length, 1)))
            {
                object market = this.market(getValue(symbols, 0));
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
        }
        object response = await this.commonGetApiV1FuturesFundingRate(this.extend(request, parameters));
        //
        //    [
        //        {
        //            "symbol": "BTC-SWAP-USDT",
        //            "rate": "0.0001071148112848",
        //            "nextFundingTime": "1755964800000"
        //        },...
        //
        return this.parseFundingRates(response, symbols);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        object marketId = this.safeString(contract, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object nextFundingRate = this.safeNumber(contract, "rate");
        object nextFundingRateTimestamp = this.safeInteger(contract, "nextFundingTime");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "previousFundingRate", null },
            { "nextFundingRate", null },
            { "previousFundingTimestamp", null },
            { "nextFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "nextFundingDatetime", null },
            { "fundingRate", nextFundingRate },
            { "fundingTimestamp", nextFundingRateTimestamp },
            { "fundingDatetime", this.iso8601(nextFundingRateTimestamp) },
            { "interval", null },
        };
    }

    /**
     * @method
     * @name toobit#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#get-funding-rate-history
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest funding rate to fetch
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory", symbol, since, limit, "8h", parameters);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.commonGetApiV1FuturesHistoryFundingRate(this.extend(request, parameters));
        //
        //    [
        //        {
        //            "id": "869931",
        //            "symbol": "BTC-SWAP-USDT",
        //            "settleTime": "1755936000000",
        //            "settleRate": "0.0001"
        //        }, ...
        //
        return this.parseFundingRateHistories(response, market, since, limit);
    }

    public override object parseFundingRateHistory(object contract, object market = null)
    {
        object timestamp = this.safeInteger(contract, "settleTime");
        object marketId = this.safeString(contract, "symbol");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", this.safeSymbol(marketId, market) },
            { "fundingRate", this.safeNumber(contract, "settleRate") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }

    /**
     * @method
     * @name toobit#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#account-information-user_data
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#futures-account-balance-user_data
     * @param {object} [params] extra parameters specific to the exchange API endpointinvalid
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = null;
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(this.inArray(marketType, new List<object>() {"swap", "future"})))
        {
            response = await this.privateGetApiV1FuturesBalance();
        } else
        {
            response = await this.privateGetApiV1Account();
        }
        return this.parseBalance(response);
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        object balances = this.safeList(response, "balances", response);
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object code = this.safeCurrencyCode(this.safeString(balance, "asset"));
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString2(balance, "free", "availableBalance");
            ((IDictionary<string,object>)account)["total"] = this.safeString2(balance, "total", "balance");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "locked");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name toobit#createOrder
     * @description create a trade order
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#new-order-trade
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#new-order-trade
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market', 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            var requestparametersVariable = this.createOrderRequest(symbol, type, side, amount, price, parameters);
            request = ((IList<object>)requestparametersVariable)[0];
            parameters = ((IList<object>)requestparametersVariable)[1];
            response = await this.privatePostApiV1SpotOrder(this.extend(request, parameters));
        } else
        {
            var requestparametersVariable = this.createContractOrderRequest(symbol, type, side, amount, price, parameters);
            request = ((IList<object>)requestparametersVariable)[0];
            parameters = ((IList<object>)requestparametersVariable)[1];
            response = await this.privatePostApiV1FuturesOrder(this.extend(request, parameters));
        }
        //
        //     {
        //         "symbol": "ETHUSDT",
        //         "price": "0",
        //         "origQty": "0.001",
        //         "orderId": "2024837825254460160",
        //         "clientOrderId": "1756115478113679",
        //         "executedQty": "0",
        //         "status": "PENDING_NEW",
        //         "timeInForce": "GTC",
        //         "type": "MARKET",
        //         "side": "SELL"
        //         "accountId": "1783404067076253952",    // only in spot
        //         "symbolName": "ETHUSDT",               // only in spot
        //         "transactTime": "1756115478604",       // only in spot
        //         "time": "1668418485058",               // only in contract
        //         "updateTime": "1668418485058",         // only in contract
        //         "leverage": "2",                       // only in contract
        //         "avgPrice": "0",                       // only in contract
        //         "marginLocked": "9.5",                 // only in contract
        //         "priceType": "INPUT"                   // only in contract
        //     }
        //
        return this.parseOrder(response, market);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object id = getValue(market, "id");
        object request = new Dictionary<string, object>() {
            { "symbol", id },
            { "side", ((string)side).ToUpper() },
        };
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object cost = null;
        var costparametersVariable = this.handleParamString(parameters, "cost");
        cost = ((IList<object>)costparametersVariable)[0];
        parameters = ((IList<object>)costparametersVariable)[1];
        if (isTrue(isEqual(type, "market")))
        {
            if (isTrue(isTrue(isEqual(cost, null)) && isTrue(isEqual(side, "buy"))))
            {
                throw new ArgumentsRequired ((string)add(this.id, " createOrder() requires params[\"cost\"] for market buy order")) ;
            } else
            {
                ((IDictionary<string,object>)request)["quantity"] = this.costToPrecision(symbol, cost);
            }
        } else
        {
            ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
        }
        object isPostOnly = null;
        var isPostOnlyparametersVariable = this.handlePostOnly(isEqual(type, "market"), false, parameters);
        isPostOnly = ((IList<object>)isPostOnlyparametersVariable)[0];
        parameters = ((IList<object>)isPostOnlyparametersVariable)[1];
        if (isTrue(isPostOnly))
        {
            ((IDictionary<string,object>)request)["type"] = "LIMIT_MAKER";
        } else
        {
            ((IDictionary<string,object>)request)["type"] = ((string)type).ToUpper();
        }
        return new List<object>() {request, parameters};
    }

    public virtual object createContractOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "quantity", this.amountToPrecision(symbol, amount) },
        };
        object reduceOnly = null;
        var reduceOnlyparametersVariable = this.handleParamBool(parameters, "reduceOnly");
        reduceOnly = ((IList<object>)reduceOnlyparametersVariable)[0];
        parameters = ((IList<object>)reduceOnlyparametersVariable)[1];
        if (isTrue(isEqual(side, "buy")))
        {
            side = ((bool) isTrue(reduceOnly)) ? "SELL_CLOSE" : "BUY_OPEN";
        } else if (isTrue(isEqual(side, "sell")))
        {
            side = ((bool) isTrue(reduceOnly)) ? "BUY_CLOSE" : "SELL_OPEN";
        }
        ((IDictionary<string,object>)request)["side"] = side;
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(this.inArray(type, new List<object>() {"limit", "LIMIT"})))
        {
            ((IDictionary<string,object>)request)["type"] = ((string)type).ToUpper();
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        } else if (isTrue(isEqual(type, "market")))
        {
            ((IDictionary<string,object>)request)["type"] = "LIMIT"; // weird, but exchange works this way
            ((IDictionary<string,object>)request)["priceType"] = "MARKET";
        }
        object isPostOnly = null;
        var isPostOnlyparametersVariable = this.handlePostOnly(isEqual(type, "market"), false, parameters);
        isPostOnly = ((IList<object>)isPostOnlyparametersVariable)[0];
        parameters = ((IList<object>)isPostOnlyparametersVariable)[1];
        if (isTrue(isPostOnly))
        {
            ((IDictionary<string,object>)request)["timeInForce"] = "LIMIT_MAKER";
        }
        object values = this.handleTriggerPricesAndParams(symbol, parameters);
        object triggerPrice = getValue(values, 0);
        parameters = getValue(values, 3);
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((IDictionary<string,object>)request)["stopPrice"] = triggerPrice;
        }
        object stopLoss = this.safeDict(parameters, "stopLoss");
        object takeProfit = this.safeDict(parameters, "takeProfit");
        object triggerPriceTypes = new Dictionary<string, object>() {
            { "mark", "MARK_PRICE" },
            { "last", "CONTRACT_PRICE" },
        };
        if (isTrue(!isEqual(stopLoss, null)))
        {
            ((IDictionary<string,object>)request)["stopLoss"] = this.safeValue(stopLoss, "triggerPrice");
            object limitPrice = this.safeValue(stopLoss, "price");
            if (isTrue(!isEqual(limitPrice, null)))
            {
                ((IDictionary<string,object>)request)["slOrderType"] = "LIMIT";
                ((IDictionary<string,object>)request)["slLimitPrice"] = this.priceToPrecision(symbol, limitPrice);
            }
            object triggerPriceType = this.safeString(stopLoss, "triggerPriceType");
            if (isTrue(!isEqual(triggerPriceType, null)))
            {
                ((IDictionary<string,object>)request)["slTriggerBy"] = this.safeString(triggerPriceTypes, triggerPriceType, triggerPriceType);
            }
            parameters = this.omit(parameters, "stopLoss");
        }
        if (isTrue(!isEqual(takeProfit, null)))
        {
            ((IDictionary<string,object>)request)["takeProfit"] = this.safeValue(takeProfit, "triggerPrice");
            object limitPrice = this.safeValue(takeProfit, "price");
            if (isTrue(!isEqual(limitPrice, null)))
            {
                ((IDictionary<string,object>)request)["tpOrderType"] = "LIMIT";
                ((IDictionary<string,object>)request)["tpLimitPrice"] = this.priceToPrecision(symbol, limitPrice);
            }
            object triggerPriceType = this.safeString(takeProfit, "triggerPriceType");
            if (isTrue(!isEqual(triggerPriceType, null)))
            {
                ((IDictionary<string,object>)request)["tpTriggerBy"] = this.safeString(triggerPriceTypes, triggerPriceType, triggerPriceType);
            }
            parameters = this.omit(parameters, "takeProfit");
        }
        if (!isTrue((inOp(parameters, "newClientOrderId"))))
        {
            ((IDictionary<string,object>)request)["newClientOrderId"] = this.uuid();
        }
        return new List<object>() {request, parameters};
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder, cancelOrder
        //
        //     {
        //         "symbol": "ETHUSDT",
        //         "price": "0",
        //         "origQty": "0.001",
        //         "orderId": "2024837825254460160",
        //         "clientOrderId": "1756115478113679",
        //         "executedQty": "0",
        //         "status": "PENDING_NEW",
        //         "timeInForce": "GTC",
        //         "type": "MARKET",
        //         "side": "SELL"
        //         "accountId": "1783404067076253952",    // only in spot
        //         "symbolName": "ETHUSDT",               // only in spot
        //         "transactTime": "1756115478604",       // only in spot
        //         "time": "1668418485058",               // only in contract
        //         "updateTime": "1668418485058",         // only in contract
        //         "leverage": "2",                       // only in contract
        //         "avgPrice": "0",                       // only in contract
        //         "marginLocked": "9.5",                 // only in contract
        //         "priceType": "INPUT"                   // only in contract
        //     }
        //
        //
        // fetchOrder, fetchOrders, fetchOpenOrders
        //
        //    {
        //        "time": "1756140208069",
        //        "updateTime": "1756140208078",
        //        "orderId": "2025045271033977089",
        //        "clientOrderId": "17561402075722006",
        //        "symbol": "ETHUSDT",
        //        "price": "3000",
        //        "origQty": "0.002",
        //        "executedQty": "0",
        //        "avgPrice": "0",
        //        "type": "LIMIT",
        //        "side": "BUY",
        //        "timeInForce": "GTC",
        //        "status": "NEW",
        //        "accountId": "1783404067076253952",  // only in SPOT
        //        "exchangeId": "301",                 // only in SPOT
        //        "symbolName": "ETHUSDT",             // only in SPOT
        //        "cummulativeQuoteQty": "0",          // only in SPOT
        //        "cumulativeQuoteQty": "0",           // only in SPOT
        //        "stopPrice": "0.0",                  // only in SPOT
        //        "icebergQty": "0.0",                 // only in SPOT
        //        "isWorking": true                    // only in SPOT
        //        "leverage": "2",                     // only in CONTRACT
        //        "marginLocked": "9.5",               // only in CONTRACT
        //        "priceType": "INPUT"                 // only in CONTRACT
        //        "triggerType": "0",                  // only in CONTRACT fetchClosedOrders
        //        "fallType": "0",                     // only in CONTRACT fetchClosedOrders
        //        "activeStatus": "0"                  // only in CONTRACT fetchClosedOrders
        //    }
        //
        object timestamp = this.safeInteger2(order, "transactTime", "time");
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object rawType = this.safeString(order, "type");
        object rawSideLower = this.safeStringLower(order, "side");
        object triggerPrice = this.omitZero(this.safeString(order, "stopPrice"));
        if (isTrue(isEqual(triggerPrice, "0.0")))
        {
            triggerPrice = null;
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString(order, "orderId") },
            { "clientOrderId", this.safeString(order, "clientOrderId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", this.safeInteger(order, "updateTime") },
            { "status", this.parseOrderStatus(this.safeString(order, "status")) },
            { "symbol", getValue(market, "symbol") },
            { "type", this.parseOrderType(rawType) },
            { "timeInForce", this.safeString(order, "timeInForce") },
            { "postOnly", (isEqual(rawType, "LIMIT_MAKER")) },
            { "side", rawSideLower },
            { "price", this.omitZero(this.safeString(order, "price")) },
            { "triggerPrice", triggerPrice },
            { "cost", this.omitZero(this.safeString(order, "cumulativeQuoteQty")) },
            { "average", this.safeString(order, "avgPrice") },
            { "amount", this.safeString(order, "origQty") },
            { "filled", this.safeString(order, "executedQty") },
            { "remaining", null },
            { "trades", null },
            { "fee", null },
            { "marginMode", null },
            { "reduceOnly", null },
            { "leverage", null },
            { "hedged", null },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "PENDING_NEW", "open" },
            { "NEW", "open" },
            { "PARTIALLY_FILLED", "open" },
            { "FILLED", "closed" },
            { "PENDING_CANCEL", "canceled" },
            { "CANCELED", "canceled" },
            { "REJECTED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderType(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "MARKET", "market" },
            { "LIMIT", "limit" },
            { "LIMIT_MAKER", "limit" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name toobit#cancelOrder
     * @description cancels an open order
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#cancel-order-trade
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#cancel-order-trade
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        if (isTrue(isEqual(this.safeString(parameters, "clientOrderId"), null)))
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("cancelOrder", market, parameters, "none");
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "none")))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument or the \"defaultType\" parameter to be set to \"spot\" or \"swap\"")) ;
        }
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.privateDeleteApiV1SpotOrder(this.extend(request, parameters));
        } else
        {
            response = await this.privateDeleteApiV1FuturesOrder(this.extend(request, parameters));
        }
        // response same as in `createOrder`
        object status = this.parseOrderStatus(this.safeString(response, "status"));
        if (isTrue(!isEqual(status, "open")))
        {
            throw new OrderNotFound ((string)add(add(add(add(this.id, " order "), id), " can not be canceled, "), this.json(response))) ;
        }
        return this.parseOrder(response, market);
    }

    /**
     * @method
     * @name toobit#cancelAllOrders
     * @description cancel all open orders in a market
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#cancel-all-open-orders-trade
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#cancel-orders-trade
     * @param {string} symbol unified symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("cancelAllOrders", market, parameters, "none");
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "none")))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument or the \"defaultType\" parameter to be set to \"spot\" or \"swap\"")) ;
        }
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.privateDeleteApiV1SpotOpenOrders(this.extend(request, parameters));
        } else
        {
            response = await this.privateDeleteApiV1FuturesBatchOrders(this.extend(request, parameters));
        }
        return new List<object> {this.safeOrder(new Dictionary<string, object>() {
    { "info", response },
})};
    }

    /**
     * @method
     * @name toobit#cancelOrders
     * @description cancel multiple orders
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#cancel-multiple-orders-trade
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#cancel-multiple-orders-trade
     * @param {string[]} ids order ids
     * @param {string} [symbol] unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object idsString = String.Join(",", ((IList<object>)ids).ToArray());
        object request = new Dictionary<string, object>() {
            { "ids", idsString },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("cancelOrders", market, parameters, "none");
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "none")))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument or the \"defaultType\" parameter to be set to \"spot\" or \"swap\"")) ;
        }
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.privateDeleteApiV1SpotCancelOrderByIds(this.extend(request, parameters));
        } else
        {
            response = await this.privateDeleteApiV1FuturesCancelOrderByIds(this.extend(request, parameters));
        }
        object result = this.safeList(response, "result", new List<object>() {});
        return this.parseOrders(result, market);
    }

    /**
     * @method
     * @name toobit#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#query-order-user_data
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#query-order-user_data
     * @param {string} id the order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        object market = this.market(symbol);
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.privateGetApiV1SpotOrder(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetApiV1FuturesOrder(this.extend(request, parameters));
        }
        //
        //    {
        //        "time": "1756140208069",
        //        "updateTime": "1756140208078",
        //        "orderId": "2025045271033977089",
        //        "clientOrderId": "17561402075722006",
        //        "symbol": "ETHUSDT",
        //        "price": "3000",
        //        "origQty": "0.002",
        //        "executedQty": "0",
        //        "avgPrice": "0",
        //        "type": "LIMIT",
        //        "side": "BUY",
        //        "timeInForce": "GTC",
        //        "status": "NEW",
        //        "accountId": "1783404067076253952",  // only in SPOT
        //        "exchangeId": "301",                 // only in SPOT
        //        "symbolName": "ETHUSDT",             // only in SPOT
        //        "cummulativeQuoteQty": "0",          // only in SPOT
        //        "cumulativeQuoteQty": "0",           // only in SPOT
        //        "stopPrice": "0.0",                  // only in SPOT
        //        "icebergQty": "0.0",                 // only in SPOT
        //        "isWorking": true                    // only in SPOT
        //        "leverage": "2",                     // only in CONTRACT
        //        "marginLocked": "9.5",               // only in CONTRACT
        //        "priceType": "INPUT"                 // only in CONTRACT
        //    }
        //
        return this.parseOrder(response, market);
    }

    /**
     * @method
     * @name toobit#fetchOpenOrders
     * @description fetches information on multiple orders made by the user
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#current-open-orders-user_data
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#query-current-open-order-user_data
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOrders", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.privateGetApiV1SpotOpenOrders(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetApiV1FuturesOpenOrders(this.extend(request, parameters));
        }
        return this.parseOrders(response, market, since, limit);
    }

    /**
     * @method
     * @name toobit#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#all-orders-user_data
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOrders", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.privateGetApiV1SpotTradeOrders(request);
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOrders() is not supported for "), marketType), " markets")) ;
        }
        return this.parseOrders(response, market, since, limit);
    }

    /**
     * @method
     * @name toobit#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#query-history-orders-user_data
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        // returns the most recent closed or canceled orders up to circa two weeks ago
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchClosedOrders", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOrders() is not supported for "), marketType), " markets")) ;
        } else
        {
            response = await this.privateGetApiV1FuturesHistoryOrders(request);
        }
        object ordersList = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            ((IList<object>)ordersList).Add(new Dictionary<string, object>() {
                { "result", getValue(response, i) },
            });
        }
        return this.parseOrders(ordersList, market, since, limit);
    }

    /**
     * @method
     * @name toobit#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#account-trade-list-user_data
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#account-trade-list-user_data
     * @param {string} [symbol] unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trade structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch trades for
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object market = this.market(symbol);
        ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.privateGetApiV1AccountTrades(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetApiV1FuturesUserTrades(request);
        }
        return this.parseTrades(response, market, since, limit);
    }

    /**
     * @method
     * @name toobit#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://open.big.one/docs/spot_transfer.html#transfer-of-user
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount 'spot', 'swap'
     * @param {string} toAccount 'spot', 'swap'
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountsByType = this.safeDict(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, toAccount);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "quantity", this.currencyToPrecision(code, amount) },
            { "fromAccountType", fromId },
            { "toAccountType", toId },
        };
        object response = await this.privatePostApiV1SubAccountTransfer(this.extend(request, parameters));
        //
        //    {
        //     "code": 200, // 200 = success
        //     "msg": "success" // response message
        //    }
        //
        return this.parseTransfer(response, currency);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        //    {
        //     "code": 200, // 200 = success
        //     "msg": "success" // response message
        //    }
        //
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", null },
            { "timestamp", null },
            { "datetime", null },
            { "currency", null },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", null },
        };
    }

    /**
     * @method
     * @name toobit#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#get-account-transaction-history-list-user_data
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#get-future-account-transaction-history-list-user_data
     * @param {string} [code] unified currency code, default is undefined
     * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
     * @param {int} [limit] max number of ledger entries to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] end time in ms
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("cancelAllOrders", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.privateGetApiV1AccountBalanceFlow(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetApiV1FuturesBalanceFlow(this.extend(request, parameters));
        }
        //
        // both answers are same format
        //
        // [
        //     {
        //         "id": "539870570957903104",
        //         "accountId": "122216245228131",
        //         "coin": "BTC",
        //         "coinId": "BTC",
        //         "coinName": "BTC",
        //         "flowTypeValue": 51,
        //         "flowType": "USER_ACCOUNT_TRANSFER",
        //         "flowName": "Transfer",
        //         "change": "-12.5",
        //         "total": "379.624059937852365",
        //         "created": "1579093587214"
        //     },
        //
        return this.parseLedger(response, currency, since, limit);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        object currencyId = this.safeString(item, "coinId");
        currency = this.safeCurrency(currencyId, currency);
        object timestamp = this.safeInteger(item, "created");
        object after = this.safeNumber(item, "total");
        object amountRaw = this.safeString(item, "change");
        object amount = this.parseNumber(Precise.stringAbs(amountRaw));
        object direction = "in";
        if (isTrue(((string)amountRaw).StartsWith(((string)"-"))))
        {
            direction = "out";
        }
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", this.safeString(item, "id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "direction", direction },
            { "account", null },
            { "referenceId", null },
            { "referenceAccount", null },
            { "type", this.parseLedgerType(this.safeString(item, "flowType")) },
            { "currency", getValue(currency, "code") },
            { "amount", amount },
            { "before", null },
            { "after", after },
            { "status", null },
            { "fee", null },
        }, currency);
    }

    public virtual object parseLedgerType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "USER_ACCOUNT_TRANSFER", "transfer" },
            { "AIRDROP", "rebate" },
        };
        return this.safeString(types, type, type);
    }

    /**
     * @method
     * @name toobit#fetchTradingFees
     * @description fetch the trading fees for multiple markets
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#user-trade-fee-rate-user_data
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
     */
    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = null;
        object marketType = null;
        object market = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchTradingFees", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchTradingFees(): does not support "), marketType), " markets")) ;
        } else if (isTrue(this.inArray(marketType, new List<object>() {"swap", "future"})))
        {
            object symbol = null;
            var symbolparametersVariable = this.handleParamString(parameters, "symbol");
            symbol = ((IList<object>)symbolparametersVariable)[0];
            parameters = ((IList<object>)symbolparametersVariable)[1];
            if (isTrue(isEqual(symbol, null)))
            {
                throw new BadRequest ((string)add(this.id, " fetchTradingFees requires a params[\"symbol\"]")) ;
            }
            market = this.market(symbol);
            object request = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
            };
            response = await this.privateGetApiV1FuturesCommissionRate(this.extend(request, parameters));
        }
        //
        // {
        //     "openMakerFee": "0.000006", // The trade fee rate for opening pending orders
        //     "openTakerFee": "0.0001", // The trade fee rate for open position taker
        //     "closeMakerFee": "0.0002", // The trade fee rate for closing pending orders
        //     "closeTakerFee": "0.0004" // The trade fee rate for closing a taker order
        // }
        //
        object result = new Dictionary<string, object>() {};
        object entry = response;
        object marketId = this.safeString(entry, "symbol");
        market = this.safeMarket(marketId, market);
        object fee = this.parseTradingFee(entry, market);
        ((IDictionary<string,object>)result)[(string)getValue(market, "symbol")] = fee;
        return result;
    }

    public virtual object parseTradingFee(object data, object market = null)
    {
        object marketId = this.safeString(data, "symbol");
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", this.safeSymbol(marketId, market) },
            { "maker", this.safeNumber(data, "closeMakerFee") },
            { "taker", this.safeNumber(data, "closeTakerFee") },
            { "percentage", null },
            { "tierBased", null },
        };
    }

    /**
     * @method
     * @name toobit#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#deposit-history-user_data
     * @param {string} [code] unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposit structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchDepositsOrWithdrawalsHelper("deposits", code, since, limit, parameters);
    }

    /**
     * @method
     * @name toobit#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#withdrawal-records-user_data
     * @param {string} [code] unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawal structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchDepositsOrWithdrawalsHelper("withdrawals", code, since, limit, parameters);
    }

    public async virtual Task<object> fetchDepositsOrWithdrawalsHelper(object type, object code, object since, object limit, object parameters)
    {
        await this.loadMarkets();
        object currency = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(isEqual(type, "deposits")))
        {
            response = await this.privateGetApiV1AccountDepositOrders(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "withdrawals")))
        {
            response = await this.privateGetApiV1AccountWithdrawOrders(this.extend(request, parameters));
        }
        return this.parseTransactions(response, currency, since, limit, parameters);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits & fetchWithdrawals
        //
        //     {
        //         "time": 1499865549590,
        //         "id": 100234,
        //         "coinName": "EOS",
        //         "statusCode": "DEPOSIT_CAN_WITHDRAW",
        //         "status": "2", // 2=SUCCESS, 11=REJECT, 12=AUDIT
        //         "address": "deposit2bb",
        //         "txId": "98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC",
        //         "txIdUrl": "",
        //         "requiredConfirmTimes": "5",
        //         "confirmTimes": "5",
        //         "quantity": "1.01",
        //         "coin": "EOS",                     // present in "fetchDeposits"
        //         "coinId ":"BHC",                   // present in "fetchWithdrawals"
        //         "addressTag": "19012584",          // present in "fetchDeposits"
        //         "addressExt":"address tag",        // present in "fetchWithdrawals"
        //         "fromAddress": "clarkkent",        // present in "fetchDeposits"
        //         "fromAddressTag": "19029901"       // present in "fetchDeposits"
        //         "arriveQuantity":"14",             // present in "fetchWithdrawals"
        //         "walletHandleTime":"1536232111669",// present in "fetchWithdrawals"
        //         "feeCoinId ":"BHC",                // present in "fetchWithdrawals"
        //         "feeCoinName ":"BHC",              // present in "fetchWithdrawals"
        //         "fee":"0.1",                       // present in "fetchWithdrawals"
        //         "kernelId":"",                     // present in "fetchWithdrawals"
        //         "isInternalTransfer": false        // present in "fetchWithdrawals"
        //     }
        //
        // withdraw
        //
        //     {
        //         "status": 0,
        //         "success": true,
        //         "needBrokerAudit": false, // Do you need a brokerage review?
        //         "id": "423885103582776064",
        //         "refuseReason":"" // failure rejection reason
        //     }
        //
        object timestamp = this.safeInteger(transaction, "time");
        object currencyId = this.safeString2(transaction, "coin", "coinId");
        object code = this.safeCurrencyCode(currencyId, currency);
        object feeString = this.safeString(transaction, "fee");
        object feeCoin = this.safeString(transaction, "feeCoinName");
        object fee = null;
        if (isTrue(!isEqual(feeString, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(feeString) },
                { "currency", this.safeCurrencyCode(feeCoin) },
            };
        }
        object tagTo = this.safeString2(transaction, "addressTag", "addressExt");
        object tagFrom = this.safeString(transaction, "fromAddressTag");
        object addressTo = this.safeString(transaction, "address");
        object addressFrom = this.safeString(transaction, "fromAddress");
        object isWithdraw = (inOp(transaction, "arriveQuantity"));
        object type = ((bool) isTrue(isWithdraw)) ? "withdrawal" : "deposit";
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString(transaction, "id") },
            { "txid", this.safeString(transaction, "txId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", null },
            { "address", null },
            { "addressTo", addressTo },
            { "addressFrom", addressFrom },
            { "tag", null },
            { "tagTo", tagTo },
            { "tagFrom", tagFrom },
            { "type", type },
            { "amount", this.safeNumber(transaction, "quantity") },
            { "currency", code },
            { "status", this.parseTransactionStatus(this.safeString(transaction, "status")) },
            { "updated", null },
            { "fee", fee },
            { "comment", null },
            { "internal", null },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "2", "pending" },
            { "12", "pending" },
            { "11", "failed" },
            { "3", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name toobit#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#deposit-address-user_data
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
        };
        var networkCodeparamsOmittedVariable = this.handleNetworkCodeAndParams(this.extend(request, parameters));
        var networkCode = ((IList<object>) networkCodeparamsOmittedVariable)[0];
        var paramsOmitted = ((IList<object>) networkCodeparamsOmittedVariable)[1];
        if (isTrue(isEqual(networkCode, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDepositAddress() : param[\"network\"] is required")) ;
        }
        ((IDictionary<string,object>)request)["chainType"] = this.networkCodeToId(networkCode);
        object response = await this.privateGetApiV1AccountDepositAddress(this.extend(request, paramsOmitted));
        //
        //     {
        //         "canDeposit":false,//Is it possible to recharge
        //         "address":"0x815bF1c3cc0f49b8FC66B21A7e48fCb476051209",
        //         "addressExt":"address tag",
        //         "minQuantity":"100",//minimum amount
        //         "requiredConfirmTimes ":1,//Arrival confirmation number
        //         "canWithdrawConfirmNum ":12,//Withdrawal confirmation number
        //         "coinType":"ERC20_TOKEN"
        //     }
        //
        return this.parseDepositAddress(response, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        object address = this.safeString(depositAddress, "address");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", this.safeString(currency, "code") },
            { "network", null },
            { "address", address },
            { "tag", this.safeString(depositAddress, "addressExt") },
        };
    }

    /**
     * @method
     * @name toobit#withdraw
     * @description make a withdrawal
     * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#withdraw-user_data
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag a memo for the transaction
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkAddress(address);
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(isEqual(networkCode, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " withdraw() : param[\"network\"] is required")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "address", address },
            { "quantity", this.currencyToPrecision(getValue(currency, "code"), amount) },
            { "network", networkCode },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["addressExt"] = tag;
        }
        object response = await this.privatePostApiV1AccountWithdraw(this.extend(request, parameters));
        //
        // {
        //     "status": 0,
        //     "success": true,
        //     "needBrokerAudit": false, // Do you need a brokerage review?
        //     "id": "423885103582776064", // Withdrawal successful order id
        //     "refuseReason":"" // failure rejection reason
        // }
        //
        return this.parseTransaction(response, currency);
    }

    /**
     * @method
     * @name toobit#setMarginMode
     * @description set margin mode to 'cross' or 'isolated'
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#change-margin-type-trade
     * @param {string} marginMode 'cross' or 'isolated'
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(!isEqual(getValue(market, "type"), "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " setMarginMode() supports swap contracts only")) ;
        }
        marginMode = ((string)marginMode).ToUpper();
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginType", marginMode },
        };
        object response = await this.privatePostApiV1FuturesMarginType(this.extend(request, parameters));
        //
        // {"code":200,"symbolId":"BTC-SWAP-USDT","marginType":"ISOLATED"}
        //
        return response;
    }

    /**
     * @method
     * @name toobit#setLeverage
     * @description set the level of leverage for a market
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#change-initial-leverage-trade
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "leverage", leverage },
        };
        object response = await this.privatePostApiV1FuturesLeverage(this.extend(request, parameters));
        //
        // {"code":200,"symbolId":"BTC-SWAP-USDT","leverage":"19"}
        //
        return response;
    }

    /**
     * @method
     * @name toobit#fetchLeverage
     * @description fetch the set leverage for a market
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#get-the-leverage-multiple-and-position-mode-user_data
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
     */
    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateGetApiV1FuturesAccountLeverage(this.extend(request, parameters));
        //
        // [
        //     {
        //         "symbol":"BTC-SWAP-USDT", //symbol
        //         "leverage":"20",  // leverage
        //         "marginType":"CROSS" // CROSS;ISOLATED
        //     }
        // ]
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseLeverage(data, market);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        object marketId = this.safeString(leverage, "symbol");
        object leverageValue = this.safeInteger(leverage, "leverage");
        object marginType = this.safeString(leverage, "marginType");
        object marginMode = ((bool) isTrue((isEqual(marginType, "crossed")))) ? "cross" : "isolated";
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", this.safeSymbol(marketId, market) },
            { "marginMode", marginMode },
            { "longLeverage", leverageValue },
            { "shortLeverage", leverageValue },
        };
    }

    /**
     * @method
     * @name toobit#fetchPositions
     * @description fetch all open positions
     * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#query-position-user_data
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object length = getArrayLength(symbols);
            if (isTrue(isGreaterThan(length, 1)))
            {
                throw new BadRequest ((string)add(this.id, " fetchPositions() only accepts an array with a single symbol or without symbols argument")) ;
            }
            object firstSymbol = this.safeString(symbols, 0);
            if (isTrue(!isEqual(firstSymbol, null)))
            {
                market = this.market(firstSymbol);
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
        }
        object response = await this.privateGetApiV1FuturesPositions(this.extend(request, parameters));
        //
        //    [
        //        {
        //            "symbol": "DOGE-SWAP-USDT",
        //            "side": "LONG",
        //            "avgPrice": "0.21191",
        //            "position": "63",
        //            "available": "63",
        //            "leverage": "25",
        //            "lastPrice": "0.20932",
        //            "positionValue": "13.3503",
        //            "flp": "0.05471",
        //            "margin": "0.5262",
        //            "marginRate": "",
        //            "unrealizedPnL": "-0.1701",
        //            "profitRate": "-0.3185",
        //            "realizedPnL": "-0.008",
        //            "minMargin": "0",
        //            "maxNotionalValue": "10000000",
        //            "markPrice": "0.20921"
        //        }
        //    ]
        //
        return this.parsePositions(response, symbols);
    }

    public override object parsePosition(object position, object market = null)
    {
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market);
        object side = this.safeStringLower(position, "side");
        object quantity = this.safeString(position, "position");
        object leverage = this.safeInteger(position, "leverage");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", this.safeString(position, "id") },
            { "symbol", getValue(market, "symbol") },
            { "entryPrice", this.safeString(position, "avgPrice") },
            { "markPrice", this.safeString(position, "markPrice") },
            { "lastPrice", this.safeString(position, "lastPrice") },
            { "notional", this.safeString(position, "positionValue") },
            { "collateral", null },
            { "unrealizedPnl", this.safeString(position, "unrealizedPnL") },
            { "side", side },
            { "contracts", this.parseNumber(quantity) },
            { "contractSize", null },
            { "timestamp", null },
            { "datetime", null },
            { "hedged", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "initialMargin", this.safeString(position, "margin") },
            { "initialMarginPercentage", null },
            { "leverage", leverage },
            { "liquidationPrice", null },
            { "marginRatio", null },
            { "marginMode", null },
            { "percentage", null },
        });
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(getValue(getValue(this.urls, "api"), api), "/"), this.implodeParams(path, parameters));
        object isPost = isEqual(method, "POST");
        object isDelete = isEqual(method, "DELETE");
        object extraQuery = new Dictionary<string, object>() {};
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(!isEqual(api, "private")))
        {
            // Public endpoints
            if (!isTrue(isPost))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    url = add(url, add("?", this.urlencode(query)));
                }
            }
        } else
        {
            this.checkRequiredCredentials();
            object timestamp = this.milliseconds();
            // Add timestamp to parameters for signed endpoints
            ((IDictionary<string,object>)extraQuery)["recvWindow"] = this.safeString(this.options, "recvWindow", "5000");
            ((IDictionary<string,object>)extraQuery)["timestamp"] = ((object)timestamp).ToString();
            object queryExtended = this.extend(query, extraQuery);
            object queryString = "";
            if (isTrue(isTrue(isPost) || isTrue(isDelete)))
            {
                // everything else except Batch-Orders
                if (!isTrue(((parameters is IList<object>) || (parameters.GetType().IsGenericType && parameters.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
                {
                    body = this.urlencode(queryExtended);
                } else
                {
                    queryString = this.urlencode(extraQuery);
                    body = this.json(query);
                }
            } else
            {
                queryString = this.urlencode(queryExtended);
            }
            object payload = queryString;
            if (isTrue(!isEqual(body, null)))
            {
                payload = add(body, payload);
            }
            object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha256, "hex");
            if (isTrue(!isEqual(queryString, "")))
            {
                queryString = add(queryString, add("&signature=", signature));
                url = add(url, add("?", queryString));
            } else
            {
                body = add(body, add("&signature=", signature));
            }
            headers = new Dictionary<string, object>() {
                { "X-BB-APIKEY", this.apiKey },
                { "Content-Type", "application/x-www-form-urlencoded" },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        object errorCode = this.safeString(response, "code");
        object message = this.safeString(response, "msg");
        if (isTrue(isTrue(isTrue(errorCode) && isTrue(!isEqual(errorCode, "200"))) && isTrue(!isEqual(errorCode, "0"))))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
