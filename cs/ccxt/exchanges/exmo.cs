namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class exmo : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "exmo" },
            { "name", "EXMO" },
            { "countries", new List<object>() {"LT"} },
            { "rateLimit", 350 },
            { "version", "v1.1" },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", true },
                { "cancelOrder", true },
                { "cancelOrders", false },
                { "createDepositAddress", false },
                { "createOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "editOrder", true },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchCanceledOrders", true },
                { "fetchCurrencies", true },
                { "fetchDeposit", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", "emulated" },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", true },
                { "fetchOrderTrades", true },
                { "fetchPositionMode", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", true },
                { "fetchTransactionFees", true },
                { "fetchTransactions", "emulated" },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "fetchWithdrawal", true },
                { "fetchWithdrawals", true },
                { "reduceMargin", true },
                { "setMargin", false },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1" },
                { "5m", "5" },
                { "15m", "15" },
                { "30m", "30" },
                { "45m", "45" },
                { "1h", "60" },
                { "2h", "120" },
                { "3h", "180" },
                { "4h", "240" },
                { "1d", "D" },
                { "1w", "W" },
                { "1M", "M" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/27766491-1b0ea956-5eda-11e7-9225-40d67b481b8d.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.exmo.com" },
                    { "private", "https://api.exmo.com" },
                    { "web", "https://exmo.me" },
                } },
                { "www", "https://exmo.me" },
                { "referral", "https://exmo.me/?ref=131685" },
                { "doc", new List<object>() {"https://exmo.me/en/api_doc?ref=131685"} },
                { "fees", "https://exmo.com/en/docs/fees" },
            } },
            { "api", new Dictionary<string, object>() {
                { "web", new Dictionary<string, object>() {
                    { "get", new List<object>() {"ctrl/feesAndLimits", "en/docs/fees"} },
                } },
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"currency", "currency/list/extended", "order_book", "pair_settings", "ticker", "trades", "candles_history", "required_amount", "payments/providers/crypto/list"} },
                } },
                { "private", new Dictionary<string, object>() {
                    { "post", new List<object>() {"user_info", "order_create", "order_cancel", "stop_market_order_create", "stop_market_order_cancel", "user_open_orders", "user_trades", "user_cancelled_orders", "order_trades", "deposit_address", "withdraw_crypt", "withdraw_get_txid", "excode_create", "excode_load", "code_check", "wallet_history", "wallet_operations", "margin/user/order/create", "margin/user/order/update", "margin/user/order/cancel", "margin/user/position/close", "margin/user/position/margin_add", "margin/user/position/margin_remove", "margin/currency/list", "margin/pair/list", "margin/settings", "margin/funding/list", "margin/user/info", "margin/user/order/list", "margin/user/order/history", "margin/user/order/trades", "margin/user/order/max_quantity", "margin/user/position/list", "margin/user/position/margin_remove_info", "margin/user/position/margin_add_info", "margin/user/wallet/list", "margin/user/wallet/history", "margin/user/trade/list", "margin/trades", "margin/liquidation/feed"} },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "feeSide", "get" },
                    { "tierBased", true },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.004") },
                    { "taker", this.parseNumber("0.004") },
                } },
                { "transaction", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", false },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "networks", new Dictionary<string, object>() {
                    { "ETH", "ERC20" },
                    { "TRX", "TRC20" },
                } },
                { "fetchTradingFees", new Dictionary<string, object>() {
                    { "method", "fetchPrivateTradingFees" },
                } },
                { "margin", new Dictionary<string, object>() {
                    { "fillResponseFromRequest", true },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "GMT", "GMT Token" },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "140434", typeof(BadRequest) },
                    { "40005", typeof(AuthenticationError) },
                    { "40009", typeof(InvalidNonce) },
                    { "40015", typeof(ExchangeError) },
                    { "40016", typeof(OnMaintenance) },
                    { "40017", typeof(AuthenticationError) },
                    { "40032", typeof(PermissionDenied) },
                    { "40033", typeof(PermissionDenied) },
                    { "40034", typeof(RateLimitExceeded) },
                    { "50052", typeof(InsufficientFunds) },
                    { "50054", typeof(InsufficientFunds) },
                    { "50304", typeof(OrderNotFound) },
                    { "50173", typeof(OrderNotFound) },
                    { "50277", typeof(InvalidOrder) },
                    { "50319", typeof(InvalidOrder) },
                    { "50321", typeof(InvalidOrder) },
                    { "50381", typeof(InvalidOrder) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "range period is too long", typeof(BadRequest) },
                    { "invalid syntax", typeof(BadRequest) },
                    { "API rate limit exceeded", typeof(RateLimitExceeded) },
                } },
            } },
        });
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "position_id", getValue(market, "id") },
            { "quantity", amount },
        };
        object response = null;
        if (isTrue(isEqual(type, "add")))
        {
            response = await this.privatePostMarginUserPositionMarginAdd(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "reduce")))
        {
            response = await this.privatePostMarginUserPositionMarginRemove(this.extend(request, parameters));
        }
        //
        //      {}
        //
        object margin = this.parseMarginModification(response, market);
        object options = this.safeValue(this.options, "margin", new Dictionary<string, object>() {});
        object fillResponseFromRequest = this.safeBool(options, "fillResponseFromRequest", true);
        if (isTrue(fillResponseFromRequest))
        {
            ((IDictionary<string,object>)margin)["type"] = type;
            ((IDictionary<string,object>)margin)["amount"] = amount;
        }
        return margin;
    }

    public override object parseMarginModification(object data, object market = null)
    {
        //
        //      {}
        //
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", this.safeSymbol(null, market) },
            { "type", null },
            { "marginMode", "isolated" },
            { "amount", null },
            { "total", null },
            { "code", this.safeValue(market, "quote") },
            { "status", "ok" },
            { "timestamp", null },
            { "datetime", null },
        };
    }

    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name exmo#reduceMargin
        * @description remove margin from a position
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#eebf9f25-0289-4946-9482-89872c738449
        * @param {string} symbol unified market symbol
        * @param {float} amount the amount of margin to remove
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "reduce", parameters);
    }

    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name exmo#addMargin
        * @description add margin
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#143ef808-79ca-4e49-9e79-a60ea4d8c0e3
        * @param {string} symbol unified market symbol
        * @param {float} amount amount of margin to add
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "add", parameters);
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#90927062-256c-4b03-900f-2b99131f9a54
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#7de7e75c-5833-45a8-b937-c2276d235aaa
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        object options = this.safeValue(this.options, "fetchTradingFees", new Dictionary<string, object>() {});
        object defaultMethod = this.safeString(options, "method", "fetchPrivateTradingFees");
        object method = this.safeString(parameters, "method", defaultMethod);
        parameters = this.omit(parameters, "method");
        if (isTrue(isEqual(method, "fetchPrivateTradingFees")))
        {
            return await this.fetchPrivateTradingFees(parameters);
        } else
        {
            return await this.fetchPublicTradingFees(parameters);
        }
    }

    public async virtual Task<object> fetchPrivateTradingFees(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostMarginPairList(parameters);
        //
        //     {
        //         "pairs": [{
        //             "name": "EXM_USD",
        //             "buy_price": "0.02728391",
        //             "sell_price": "0.0276",
        //             "last_trade_price": "0.0276",
        //             "ticker_updated": "1646956050056696046",
        //             "is_fair_price": true,
        //             "max_price_precision": "8",
        //             "min_order_quantity": "1",
        //             "max_order_quantity": "50000",
        //             "min_order_price": "0.00000001",
        //             "max_order_price": "1000",
        //             "max_position_quantity": "50000",
        //             "trade_taker_fee": "0.05",
        //             "trade_maker_fee": "0",
        //             "liquidation_fee": "0.5",
        //             "max_leverage": "3",
        //             "default_leverage": "3",
        //             "liquidation_level": "5",
        //             "margin_call_level": "7.5",
        //             "position": "1",
        //             "updated": "1638976144797807397"
        //         }
        //         ...
        //         ]
        //     }
        //
        object pairs = this.safeValue(response, "pairs", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(pairs)); postFixIncrement(ref i))
        {
            object pair = getValue(pairs, i);
            object marketId = this.safeString(pair, "name");
            object symbol = this.safeSymbol(marketId, null, "_");
            object makerString = this.safeString(pair, "trade_maker_fee");
            object takerString = this.safeString(pair, "trade_taker_fee");
            object maker = this.parseNumber(Precise.stringDiv(makerString, "100"));
            object taker = this.parseNumber(Precise.stringDiv(takerString, "100"));
            ((IDictionary<string,object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "info", pair },
                { "symbol", symbol },
                { "maker", maker },
                { "taker", taker },
                { "percentage", true },
                { "tierBased", true },
            };
        }
        return result;
    }

    public async virtual Task<object> fetchPublicTradingFees(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetPairSettings(parameters);
        //
        //     {
        //         "BTC_USD": {
        //             "min_quantity": "0.00002",
        //             "max_quantity": "1000",
        //             "min_price": "1",
        //             "max_price": "150000",
        //             "max_amount": "500000",
        //             "min_amount": "1",
        //             "price_precision": "2",
        //             "commission_taker_percent": "0.3",
        //             "commission_maker_percent": "0.3"
        //         },
        //     }
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(this.symbols, i);
            object market = this.market(symbol);
            object fee = this.safeValue(response, getValue(market, "id"), new Dictionary<string, object>() {});
            object makerString = this.safeString(fee, "commission_maker_percent");
            object takerString = this.safeString(fee, "commission_taker_percent");
            object maker = this.parseNumber(Precise.stringDiv(makerString, "100"));
            object taker = this.parseNumber(Precise.stringDiv(takerString, "100"));
            ((IDictionary<string,object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "info", fee },
                { "symbol", symbol },
                { "maker", maker },
                { "taker", taker },
                { "percentage", true },
                { "tierBased", true },
            };
        }
        return result;
    }

    public virtual object parseFixedFloatValue(object input)
    {
        if (isTrue(isTrue((isEqual(input, null))) || isTrue((isEqual(input, "-")))))
        {
            return null;
        }
        if (isTrue(isEqual(input, "")))
        {
            return 0;
        }
        object isPercentage = (isGreaterThanOrEqual(getIndexOf(input, "%"), 0));
        object parts = ((string)input).Split(new [] {((string)" ")}, StringSplitOptions.None).ToList<object>();
        object value = ((string)getValue(parts, 0)).Replace((string)"%", (string)"");
        object result = parseFloat(value);
        if (isTrue(isTrue((isGreaterThan(result, 0))) && isTrue(isPercentage)))
        {
            throw new ExchangeError ((string)add(add(this.id, " parseFixedFloatValue() detected an unsupported non-zero percentage-based fee "), input)) ;
        }
        return result;
    }

    public async override Task<object> fetchTransactionFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchTransactionFees
        * @deprecated
        * @description please use fetchDepositWithdrawFees instead
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#4190035d-24b1-453d-833b-37e0a52f88e2
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [transaction fees structures]{@link https://docs.ccxt.com/#/?id=fees-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object cryptoList = await this.publicGetPaymentsProvidersCryptoList(parameters);
        //
        //     {
        //         "BTC":[
        //             { "type":"deposit", "name":"BTC", "currency_name":"BTC", "min":"0.001", "max":"0", "enabled":true,"comment":"Minimum deposit amount is 0.001 BTC. We do not support BSC and BEP20 network, please consider this when sending funds", "commission_desc":"0%", "currency_confirmations":1 },
        //             { "type":"withdraw", "name":"BTC", "currency_name":"BTC", "min":"0.001", "max":"350", "enabled":true,"comment":"Do not withdraw directly to the Crowdfunding or ICO address as your account will not be credited with tokens from such sales.", "commission_desc":"0.0005 BTC", "currency_confirmations":6 }
        //         ],
        //         "ETH":[
        //             { "type":"withdraw", "name":"ETH", "currency_name":"ETH", "min":"0.01", "max":"500", "enabled":true,"comment":"Do not withdraw directly to the Crowdfunding or ICO address as your account will not be credited with tokens from such sales.", "commission_desc":"0.004 ETH", "currency_confirmations":4 },
        //             { "type":"deposit", "name":"ETH", "currency_name":"ETH", "min":"0.01", "max":"0", "enabled":true,"comment":"Minimum deposit amount is 0.01 ETH. We do not support BSC and BEP20 network, please consider this when sending funds", "commission_desc":"0%", "currency_confirmations":1 }
        //         ],
        //         "USDT":[
        //             { "type":"deposit", "name":"USDT (OMNI)", "currency_name":"USDT", "min":"10", "max":"0", "enabled":false,"comment":"Minimum deposit amount is 10 USDT", "commission_desc":"0%", "currency_confirmations":2 },
        //             { "type":"withdraw", "name":"USDT (OMNI)", "currency_name":"USDT", "min":"10", "max":"100000", "enabled":false,"comment":"Do not withdraw directly to the Crowdfunding or ICO address as your account will not be credited with tokens from such sales.", "commission_desc":"5 USDT", "currency_confirmations":6 },
        //             { "type":"deposit", "name":"USDT (ERC20)", "currency_name":"USDT", "min":"10", "max":"0", "enabled":true,"comment":"Minimum deposit amount is 10 USDT", "commission_desc":"0%", "currency_confirmations":2 },
        //             {
        //                 "type":"withdraw",
        //                 "name":"USDT (ERC20)",
        //                 "currency_name":"USDT",
        //                 "min":"55",
        //                 "max":"200000",
        //                 "enabled":true,
        //                 "comment":"Caution! Do not withdraw directly to a crowdfund or ICO address, as your account will not be credited with tokens from such sales. Recommendation: Due to the high load of ERC20 network, using TRC20 address for withdrawal is recommended.",
        //                 "commission_desc":"10 USDT",
        //                 "currency_confirmations":6
        //             },
        //             { "type":"deposit", "name":"USDT (TRC20)", "currency_name":"USDT", "min":"10", "max":"100000", "enabled":true,"comment":"Minimum deposit amount is 10 USDT. Only TRON main network supported", "commission_desc":"0%", "currency_confirmations":2 },
        //             { "type":"withdraw", "name":"USDT (TRC20)", "currency_name":"USDT", "min":"10", "max":"150000", "enabled":true,"comment":"Caution! Do not withdraw directly to a crowdfund or ICO address, as your account will not be credited with tokens from such sales. Only TRON main network supported.", "commission_desc":"1 USDT", "currency_confirmations":6 }
        //         ],
        //         "XLM":[
        //             { "type":"deposit", "name":"XLM", "currency_name":"XLM", "min":"1", "max":"1000000", "enabled":true,"comment":"Attention! A deposit without memo(invoice) will not be credited. Minimum deposit amount is 1 XLM. We do not support BSC and BEP20 network, please consider this when sending funds", "commission_desc":"0%", "currency_confirmations":1 },
        //             { "type":"withdraw", "name":"XLM", "currency_name":"XLM", "min":"21", "max":"1000000", "enabled":true,"comment":"Caution! Do not withdraw directly to a crowdfund or ICO address, as your account will not be credited with tokens from such sales.", "commission_desc":"0.01 XLM", "currency_confirmations":1 }
        //         ],
        //     }
        //
        object result = new Dictionary<string, object>() {};
        object cryptoListKeys = new List<object>(((IDictionary<string,object>)cryptoList).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(cryptoListKeys)); postFixIncrement(ref i))
        {
            object code = getValue(cryptoListKeys, i);
            if (isTrue(isTrue(!isEqual(codes, null)) && !isTrue(this.inArray(code, codes))))
            {
                continue;
            }
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "deposit", null },
                { "withdraw", null },
            };
            object currency = this.currency(code);
            object currencyId = this.safeString(currency, "id");
            object providers = this.safeValue(cryptoList, currencyId, new List<object>() {});
            for (object j = 0; isLessThan(j, getArrayLength(providers)); postFixIncrement(ref j))
            {
                object provider = getValue(providers, j);
                object typeInner = this.safeString(provider, "type");
                object commissionDesc = this.safeString(provider, "commission_desc");
                object fee = this.parseFixedFloatValue(commissionDesc);
                ((IDictionary<string,object>)getValue(result, code))[(string)typeInner] = fee;
            }
            ((IDictionary<string,object>)getValue(result, code))["info"] = providers;
        }
        // cache them for later use
        ((IDictionary<string,object>)this.options)["transactionFees"] = result;
        return result;
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#4190035d-24b1-453d-833b-37e0a52f88e2
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [transaction fees structures]{@link https://docs.ccxt.com/#/?id=fees-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetPaymentsProvidersCryptoList(parameters);
        //
        //    {
        //        "USDT": [
        //            {
        //                "type": "deposit", // or "withdraw"
        //                "name": "USDT (ERC20)",
        //                "currency_name": "USDT",
        //                "min": "10",
        //                "max": "0",
        //                "enabled": true,
        //                "comment": "Minimum deposit amount is 10 USDT",
        //                "commission_desc": "0%",
        //                "currency_confirmations": 2
        //            },
        //            ...
        //        ],
        //        ...
        //    }
        //
        object result = this.parseDepositWithdrawFees(response, codes);
        // cache them for later use
        ((IDictionary<string,object>)this.options)["transactionFees"] = result;
        return result;
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //    [
        //        {
        //            "type": "deposit", // or "withdraw"
        //            "name": "BTC",
        //            "currency_name": "BTC",
        //            "min": "0.001",
        //            "max": "0",
        //            "enabled": true,
        //            "comment": "Minimum deposit amount is 0.001 BTC. We do not support BSC and BEP20 network, please consider this when sending funds",
        //            "commission_desc": "0%",
        //            "currency_confirmations": 1
        //        },
        //        ...
        //    ]
        //
        object result = this.depositWithdrawFee(fee);
        for (object i = 0; isLessThan(i, getArrayLength(fee)); postFixIncrement(ref i))
        {
            object provider = getValue(fee, i);
            object type = this.safeString(provider, "type");
            object networkId = this.safeString(provider, "name");
            object networkCode = this.networkIdToCode(networkId, this.safeString(currency, "code"));
            object commissionDesc = this.safeString(provider, "commission_desc");
            object splitCommissionDesc = new List<object>() {};
            object percentage = null;
            if (isTrue(!isEqual(commissionDesc, null)))
            {
                splitCommissionDesc = ((string)commissionDesc).Split(new [] {((string)"%")}, StringSplitOptions.None).ToList<object>();
                object splitCommissionDescLength = getArrayLength(splitCommissionDesc);
                percentage = isGreaterThanOrEqual(splitCommissionDescLength, 2);
            }
            object network = this.safeValue(getValue(result, "networks"), networkCode);
            if (isTrue(isEqual(network, null)))
            {
                ((IDictionary<string,object>)getValue(result, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                    { "withdraw", new Dictionary<string, object>() {
                        { "fee", null },
                        { "percentage", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "fee", null },
                        { "percentage", null },
                    } },
                };
            }
            ((IDictionary<string,object>)getValue(getValue(result, "networks"), networkCode))[(string)type] = new Dictionary<string, object>() {
                { "fee", this.parseFixedFloatValue(this.safeString(splitCommissionDesc, 0)) },
                { "percentage", percentage },
            };
        }
        return this.assignDefaultDepositWithdrawFees(result);
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#7cdf0ca8-9ff6-4cf3-aa33-bcec83155c49
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#4190035d-24b1-453d-833b-37e0a52f88e2
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        //
        parameters ??= new Dictionary<string, object>();
        object currencyList = await this.publicGetCurrencyListExtended(parameters);
        //
        //     [
        //         {"name":"VLX","description":"Velas"},
        //         {"name":"RUB","description":"Russian Ruble"},
        //         {"name":"BTC","description":"Bitcoin"},
        //         {"name":"USD","description":"US Dollar"}
        //     ]
        //
        object cryptoList = await this.publicGetPaymentsProvidersCryptoList(parameters);
        //
        //     {
        //         "BTC":[
        //             { "type":"deposit", "name":"BTC", "currency_name":"BTC", "min":"0.001", "max":"0", "enabled":true,"comment":"Minimum deposit amount is 0.001 BTC. We do not support BSC and BEP20 network, please consider this when sending funds", "commission_desc":"0%", "currency_confirmations":1 },
        //             { "type":"withdraw", "name":"BTC", "currency_name":"BTC", "min":"0.001", "max":"350", "enabled":true,"comment":"Do not withdraw directly to the Crowdfunding or ICO address as your account will not be credited with tokens from such sales.", "commission_desc":"0.0005 BTC", "currency_confirmations":6 }
        //         ],
        //         "ETH":[
        //             { "type":"withdraw", "name":"ETH", "currency_name":"ETH", "min":"0.01", "max":"500", "enabled":true,"comment":"Do not withdraw directly to the Crowdfunding or ICO address as your account will not be credited with tokens from such sales.", "commission_desc":"0.004 ETH", "currency_confirmations":4 },
        //             { "type":"deposit", "name":"ETH", "currency_name":"ETH", "min":"0.01", "max":"0", "enabled":true,"comment":"Minimum deposit amount is 0.01 ETH. We do not support BSC and BEP20 network, please consider this when sending funds", "commission_desc":"0%", "currency_confirmations":1 }
        //         ],
        //         "USDT":[
        //             { "type":"deposit", "name":"USDT (OMNI)", "currency_name":"USDT", "min":"10", "max":"0", "enabled":false,"comment":"Minimum deposit amount is 10 USDT", "commission_desc":"0%", "currency_confirmations":2 },
        //             { "type":"withdraw", "name":"USDT (OMNI)", "currency_name":"USDT", "min":"10", "max":"100000", "enabled":false,"comment":"Do not withdraw directly to the Crowdfunding or ICO address as your account will not be credited with tokens from such sales.", "commission_desc":"5 USDT", "currency_confirmations":6 },
        //             { "type":"deposit", "name":"USDT (ERC20)", "currency_name":"USDT", "min":"10", "max":"0", "enabled":true,"comment":"Minimum deposit amount is 10 USDT", "commission_desc":"0%", "currency_confirmations":2 },
        //             { "type":"withdraw", "name":"USDT (ERC20)", "currency_name":"USDT", "min":"55", "max":"200000", "enabled":true, "comment":"Caution! Do not withdraw directly to a crowdfund or ICO address, as your account will not be credited with tokens from such sales. Recommendation: Due to the high load of ERC20 network, using TRC20 address for withdrawal is recommended.",  "commission_desc":"10 USDT", "currency_confirmations":6 },
        //             { "type":"deposit", "name":"USDT (TRC20)", "currency_name":"USDT", "min":"10", "max":"100000", "enabled":true,"comment":"Minimum deposit amount is 10 USDT. Only TRON main network supported", "commission_desc":"0%", "currency_confirmations":2 },
        //             { "type":"withdraw", "name":"USDT (TRC20)", "currency_name":"USDT", "min":"10", "max":"150000", "enabled":true,"comment":"Caution! Do not withdraw directly to a crowdfund or ICO address, as your account will not be credited with tokens from such sales. Only TRON main network supported.", "commission_desc":"1 USDT", "currency_confirmations":6 }
        //         ],
        //         "XLM":[
        //             { "type":"deposit", "name":"XLM", "currency_name":"XLM", "min":"1", "max":"1000000", "enabled":true,"comment":"Attention! A deposit without memo(invoice) will not be credited. Minimum deposit amount is 1 XLM. We do not support BSC and BEP20 network, please consider this when sending funds", "commission_desc":"0%", "currency_confirmations":1 },
        //             { "type":"withdraw", "name":"XLM", "currency_name":"XLM", "min":"21", "max":"1000000", "enabled":true,"comment":"Caution! Do not withdraw directly to a crowdfund or ICO address, as your account will not be credited with tokens from such sales.", "commission_desc":"0.01 XLM", "currency_confirmations":1 }
        //         ],
        //     }
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currencyList)); postFixIncrement(ref i))
        {
            object currency = getValue(currencyList, i);
            object currencyId = this.safeString(currency, "name");
            object name = this.safeString(currency, "description");
            object providers = this.safeValue(cryptoList, currencyId);
            object active = false;
            object type = "crypto";
            object limits = new Dictionary<string, object>() {
                { "deposit", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "withdraw", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            };
            object fee = null;
            object depositEnabled = null;
            object withdrawEnabled = null;
            if (isTrue(isEqual(providers, null)))
            {
                active = true;
                type = "fiat";
            } else
            {
                for (object j = 0; isLessThan(j, getArrayLength(providers)); postFixIncrement(ref j))
                {
                    object provider = getValue(providers, j);
                    object typeInner = this.safeString(provider, "type");
                    object minValue = this.safeString(provider, "min");
                    object maxValue = this.safeString(provider, "max");
                    if (isTrue(Precise.stringEq(maxValue, "0.0")))
                    {
                        maxValue = null;
                    }
                    object activeProvider = this.safeValue(provider, "enabled");
                    if (isTrue(isEqual(typeInner, "deposit")))
                    {
                        if (isTrue(isTrue(activeProvider) && !isTrue(depositEnabled)))
                        {
                            depositEnabled = true;
                        } else if (!isTrue(activeProvider))
                        {
                            depositEnabled = false;
                        }
                    } else if (isTrue(isEqual(typeInner, "withdraw")))
                    {
                        if (isTrue(isTrue(activeProvider) && !isTrue(withdrawEnabled)))
                        {
                            withdrawEnabled = true;
                        } else if (!isTrue(activeProvider))
                        {
                            withdrawEnabled = false;
                        }
                    }
                    if (isTrue(activeProvider))
                    {
                        active = true;
                        object limitMin = this.numberToString(getValue(getValue(limits, typeInner), "min"));
                        if (isTrue(isTrue((isEqual(getValue(getValue(limits, typeInner), "min"), null))) || isTrue((Precise.stringLt(minValue, limitMin)))))
                        {
                            ((IDictionary<string,object>)getValue(limits, typeInner))["min"] = minValue;
                            ((IDictionary<string,object>)getValue(limits, typeInner))["max"] = maxValue;
                            if (isTrue(isEqual(typeInner, "withdraw")))
                            {
                                object commissionDesc = this.safeString(provider, "commission_desc");
                                fee = this.parseFixedFloatValue(commissionDesc);
                            }
                        }
                    }
                }
            }
            object code = this.safeCurrencyCode(currencyId);
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", currencyId },
                { "code", code },
                { "name", name },
                { "type", type },
                { "active", active },
                { "deposit", depositEnabled },
                { "withdraw", withdrawEnabled },
                { "fee", fee },
                { "precision", this.parseNumber("1e-8") },
                { "limits", limits },
                { "info", providers },
                { "networks", new Dictionary<string, object>() {} },
            };
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchMarkets
        * @description retrieves data on all markets for exmo
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#7de7e75c-5833-45a8-b937-c2276d235aaa
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetPairSettings(parameters);
        //
        //     {
        //         "BTC_USD":{
        //             "min_quantity":"0.0001",
        //             "max_quantity":"1000",
        //             "min_price":"1",
        //             "max_price":"30000",
        //             "max_amount":"500000",
        //             "min_amount":"1",
        //             "price_precision":8,
        //             "commission_taker_percent":"0.4",
        //             "commission_maker_percent":"0.4"
        //         },
        //     }
        //
        object marginPairsDict = new Dictionary<string, object>() {};
        if (isTrue(this.checkRequiredCredentials(false)))
        {
            object marginPairs = await this.privatePostMarginPairList(parameters);
            //
            //    {
            //        "pairs": [
            //            {
            //                "buy_price": "55978.85",
            //                "default_leverage": "3",
            //                "is_fair_price": true,
            //                "last_trade_price": "55999.23",
            //                "liquidation_fee": "2",
            //                "liquidation_level": "10",
            //                "margin_call_level": "15",
            //                "max_leverage": "3",
            //                "max_order_price": "150000",
            //                "max_order_quantity": "1",
            //                "max_position_quantity": "1",
            //                "max_price_precision": 2,
            //                "min_order_price": "1",
            //                "min_order_quantity": "0.00002",
            //                "name": "BTC_USD",
            //                "position": 1,
            //                "sell_price": "55985.51",
            //                "ticker_updated": "1619019818936107989",
            //                "trade_maker_fee": "0",
            //                "trade_taker_fee": "0.05",
            //                "updated": "1619008608955599013"
            //            }
            //        ]
            //    }
            //
            object pairs = this.safeValue(marginPairs, "pairs");
            marginPairsDict = this.indexBy(pairs, "name");
        }
        object keys = new List<object>(((IDictionary<string,object>)response).Keys);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object id = getValue(keys, i);
            object market = getValue(response, id);
            object marginMarket = this.safeValue(marginPairsDict, id);
            object symbol = ((string)id).Replace((string)"_", (string)"/");
            var baseIdquoteIdVariable = ((string)symbol).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
            var baseId = ((IList<object>) baseIdquoteIdVariable)[0];
            var quoteId = ((IList<object>) baseIdquoteIdVariable)[1];
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object takerString = this.safeString(market, "commission_taker_percent");
            object makerString = this.safeString(market, "commission_maker_percent");
            object maxQuantity = this.safeString(market, "max_quantity");
            object marginMaxQuantity = this.safeString(marginMarket, "max_order_quantity");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", !isEqual(marginMarket, null) },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", null },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", this.parseNumber(Precise.stringDiv(takerString, "100")) },
                { "maker", this.parseNumber(Precise.stringDiv(makerString, "100")) },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber("1e-8") },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "price_precision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", this.safeNumber(market, "leverage") },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_quantity") },
                        { "max", this.parseNumber(Precise.stringMax(maxQuantity, marginMaxQuantity)) },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_price") },
                        { "max", this.safeNumber(market, "max_price") },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_amount") },
                        { "max", this.safeNumber(market, "max_amount") },
                    } },
                } },
                { "created", null },
                { "info", market },
            });
        }
        return result;
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#65eeb949-74e5-4631-9184-c38387fe53e8
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "resolution", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        object maxLimit = 3000;
        object duration = this.parseTimeframe(timeframe);
        object now = this.milliseconds();
        if (isTrue(isEqual(since, null)))
        {
            if (isTrue(isEqual(limit, null)))
            {
                limit = 1000; // cap default at generous amount
            } else
            {
                limit = mathMin(limit, maxLimit);
            }
            ((IDictionary<string,object>)request)["from"] = subtract(subtract(this.parseToInt(divide(now, 1000)), multiply(limit, duration)), 1);
            ((IDictionary<string,object>)request)["to"] = this.parseToInt(divide(now, 1000));
        } else
        {
            ((IDictionary<string,object>)request)["from"] = subtract(this.parseToInt(divide(since, 1000)), 1);
            if (isTrue(isEqual(limit, null)))
            {
                limit = maxLimit;
            } else
            {
                limit = mathMin(limit, maxLimit);
            }
            object to = this.sum(since, multiply(multiply(limit, duration), 1000));
            ((IDictionary<string,object>)request)["to"] = this.parseToInt(divide(to, 1000));
        }
        object response = await this.publicGetCandlesHistory(this.extend(request, parameters));
        //
        //     {
        //         "candles":[
        //             {"t":1584057600000,"o":0.02235144,"c":0.02400233,"h":0.025171,"l":0.02221,"v":5988.34031761},
        //             {"t":1584144000000,"o":0.0240373,"c":0.02367413,"h":0.024399,"l":0.0235,"v":2027.82522329},
        //             {"t":1584230400000,"o":0.02363458,"c":0.02319242,"h":0.0237948,"l":0.02223196,"v":1707.96944997},
        //         ]
        //     }
        //
        object candles = this.safeList(response, "candles", new List<object>() {});
        return this.parseOHLCVs(candles, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "t":1584057600000,
        //         "o":0.02235144,
        //         "c":0.02400233,
        //         "h":0.025171,
        //         "l":0.02221,
        //         "v":5988.34031761
        //     }
        //
        return new List<object> {this.safeInteger(ohlcv, "t"), this.safeNumber(ohlcv, "o"), this.safeNumber(ohlcv, "h"), this.safeNumber(ohlcv, "l"), this.safeNumber(ohlcv, "c"), this.safeNumber(ohlcv, "v")};
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object wallets = this.safeValue(response, "wallets");
        if (isTrue(!isEqual(wallets, null)))
        {
            object currencyIds = new List<object>(((IDictionary<string,object>)wallets).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
            {
                object currencyId = getValue(currencyIds, i);
                object item = getValue(wallets, currencyId);
                object currency = this.safeCurrencyCode(currencyId);
                object account = this.account();
                ((IDictionary<string,object>)account)["used"] = this.safeString(item, "used");
                ((IDictionary<string,object>)account)["free"] = this.safeString(item, "free");
                ((IDictionary<string,object>)account)["total"] = this.safeString(item, "balance");
                ((IDictionary<string,object>)result)[(string)currency] = account;
            }
        } else
        {
            object free = this.safeValue(response, "balances", new Dictionary<string, object>() {});
            object used = this.safeValue(response, "reserved", new Dictionary<string, object>() {});
            object currencyIds = new List<object>(((IDictionary<string,object>)free).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
            {
                object currencyId = getValue(currencyIds, i);
                object code = this.safeCurrencyCode(currencyId);
                object account = this.account();
                if (isTrue(inOp(free, currencyId)))
                {
                    ((IDictionary<string,object>)account)["free"] = this.safeString(free, currencyId);
                }
                if (isTrue(inOp(used, currencyId)))
                {
                    ((IDictionary<string,object>)account)["used"] = this.safeString(used, currencyId);
                }
                ((IDictionary<string,object>)result)[(string)code] = account;
            }
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#59c5160f-27a1-4d9a-8cfb-7979c7ffaac6
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#c8388df7-1f9f-4d41-81c4-5a387d171dc6
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] *isolated* fetches the isolated margin balance
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBalance", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, "cross")))
        {
            throw new BadRequest ((string)add(this.id, " does not support cross margin")) ;
        }
        object response = null;
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            response = await this.privatePostMarginUserWalletList(parameters);
        } else
        {
            response = await this.privatePostUserInfo(parameters);
        }
        return this.parseBalance(response);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#c60c51a8-e683-4f45-a000-820723d37871
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.publicGetOrderBook(this.extend(request, parameters));
        object result = this.safeDict(response, getValue(market, "id"));
        return this.parseOrderBook(result, getValue(market, "symbol"), null, "bid", "ask");
    }

    public async override Task<object> fetchOrderBooks(object symbols = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchOrderBooks
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data for multiple markets
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#c60c51a8-e683-4f45-a000-820723d37871
        * @param {string[]|undefined} symbols list of unified market symbols, all symbols fetched if undefined, default is undefined
        * @param {int} [limit] max number of entries per orderbook to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbol
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ids = null;
        if (isTrue(isEqual(symbols, null)))
        {
            ids = String.Join(",", ((IList<object>)this.ids).ToArray());
            // max URL length is 2083 symbols, including http schema, hostname, tld, etc...
            if (isTrue(isGreaterThan(getArrayLength(ids), 2048)))
            {
                object numIds = getArrayLength(this.ids);
                throw new ExchangeError ((string)add(add(add(this.id, " fetchOrderBooks() has "), ((object)numIds).ToString()), " symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks")) ;
            }
        } else
        {
            ids = this.marketIds(symbols);
            ids = String.Join(",", ((IList<object>)ids).ToArray());
        }
        object request = new Dictionary<string, object>() {
            { "pair", ids },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.publicGetOrderBook(this.extend(request, parameters));
        object result = new Dictionary<string, object>() {};
        object marketIds = new List<object>(((IDictionary<string,object>)response).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = getValue(marketIds, i);
            object symbol = this.safeSymbol(marketId);
            ((IDictionary<string,object>)result)[(string)symbol] = this.parseOrderBook(getValue(response, marketId), symbol, null, "bid", "ask");
        }
        return result;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "buy_price":"0.00002996",
        //         "sell_price":"0.00003002",
        //         "last_trade":"0.00002992",
        //         "high":"0.00003028",
        //         "low":"0.00002935",
        //         "avg":"0.00002963",
        //         "vol":"1196546.3163222",
        //         "vol_curr":"35.80066578",
        //         "updated":1642291733
        //     }
        //
        object timestamp = this.safeTimestamp(ticker, "updated");
        market = this.safeMarket(null, market);
        object last = this.safeString(ticker, "last_trade");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(ticker, "buy_price") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "sell_price") },
            { "askVolume", null },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", this.safeString(ticker, "avg") },
            { "baseVolume", this.safeString(ticker, "vol") },
            { "quoteVolume", this.safeString(ticker, "vol_curr") },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#4c8e6459-3503-4361-b012-c34bb9f7e385
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.publicGetTicker(parameters);
        //
        //     {
        //         "ADA_BTC":{
        //             "buy_price":"0.00002996",
        //             "sell_price":"0.00003002",
        //             "last_trade":"0.00002992",
        //             "high":"0.00003028",
        //             "low":"0.00002935",
        //             "avg":"0.00002963",
        //             "vol":"1196546.3163222",
        //             "vol_curr":"35.80066578",
        //             "updated":1642291733
        //         }
        //     }
        //
        object result = new Dictionary<string, object>() {};
        object marketIds = new List<object>(((IDictionary<string,object>)response).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = getValue(marketIds, i);
            object market = this.safeMarket(marketId, null, "_");
            object symbol = getValue(market, "symbol");
            object ticker = this.safeValue(response, marketId);
            ((IDictionary<string,object>)result)[(string)symbol] = this.parseTicker(ticker, market);
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#4c8e6459-3503-4361-b012-c34bb9f7e385
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetTicker(parameters);
        object market = this.market(symbol);
        return this.parseTicker(getValue(response, getValue(market, "id")), market);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //     {
        //         "trade_id":165087520,
        //         "date":1587470005,
        //         "type":"buy",
        //         "quantity":"1.004",
        //         "price":"0.02491461",
        //         "amount":"0.02501426"
        //     },
        //
        // fetchMyTrades, fetchOrderTrades
        //
        //     {
        //         "trade_id": 3,
        //         "date": 1435488248,
        //         "type": "buy",
        //         "pair": "BTC_USD",
        //         "order_id": 12345,
        //         "quantity": 1,
        //         "price": 100,
        //         "amount": 100,
        //         "exec_type": "taker",
        //         "commission_amount": "0.02",
        //         "commission_currency": "BTC",
        //         "commission_percent": "0.2"
        //     }
        //
        // fetchMyTrades (margin)
        //
        //    {
        //        "trade_id": "692861757015952517",
        //        "trade_dt": "1693951853197811824",
        //        "trade_type": "buy",
        //        "pair": "ADA_USDT",
        //        "quantity": "1.96607879",
        //        "price": "0.2568",
        //        "amount": "0.50488903"
        //    }
        //
        object timestamp = this.safeTimestamp(trade, "date");
        object id = this.safeString(trade, "trade_id");
        object orderId = this.safeString(trade, "order_id");
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString(trade, "quantity");
        object costString = this.safeString(trade, "amount");
        object side = this.safeString2(trade, "type", "trade_type");
        object type = null;
        object marketId = this.safeString(trade, "pair");
        market = this.safeMarket(marketId, market, "_");
        object symbol = getValue(market, "symbol");
        object isMaker = this.safeValue(trade, "is_maker");
        object takerOrMakerDefault = null;
        if (isTrue(!isEqual(isMaker, null)))
        {
            takerOrMakerDefault = ((bool) isTrue(isMaker)) ? "maker" : "taker";
        }
        object takerOrMaker = this.safeString(trade, "exec_type", takerOrMakerDefault);
        object fee = null;
        object feeCostString = this.safeString(trade, "commission_amount");
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCurrencyId = this.safeString(trade, "commission_currency");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            object feeRateString = this.safeString(trade, "commission_percent");
            if (isTrue(!isEqual(feeRateString, null)))
            {
                feeRateString = Precise.stringDiv(feeRateString, "1000", 18);
            }
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", feeCurrencyCode },
                { "rate", feeRateString },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "order", orderId },
            { "type", type },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", priceString },
            { "amount", amountString },
            { "cost", costString },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#5a5a9c0d-cf17-47f6-9d62-6d4404ebd5ac
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        object response = await this.publicGetTrades(this.extend(request, parameters));
        //
        //     {
        //         "ETH_BTC":[
        //             {
        //                 "trade_id":165087520,
        //                 "date":1587470005,
        //                 "type":"buy",
        //                 "quantity":"1.004",
        //                 "price":"0.02491461",
        //                 "amount":"0.02501426"
        //             },
        //             {
        //                 "trade_id":165087369,
        //                 "date":1587469938,
        //                 "type":"buy",
        //                 "quantity":"0.94",
        //                 "price":"0.02492348",
        //                 "amount":"0.02342807"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, getValue(market, "id"), new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#b8d8d9af-4f46-46a1-939b-ad261d79f452  // spot
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#f4b1aaf8-399f-403b-ab5e-4926d967a106  // margin
        * @param {string} symbol a symbol is required but it can be a single string, or a non-empty array
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] *required for margin orders* the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        *
        * EXCHANGE SPECIFIC PARAMETERS
        * @param {int} [params.offset] last deal offset, default = 0
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchMyTrades", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, "cross")))
        {
            throw new BadRequest ((string)add(this.id, "only isolated margin is supported")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object pair = getValue(market, "id");
        object isSpot = !isEqual(marginMode, "isolated");
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100;
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(isSpot))
        {
            ((IDictionary<string,object>)request)["pair"] = pair;
        } else
        {
            ((IDictionary<string,object>)request)["pair_name"] = pair;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object offset = this.safeInteger(parameters, "offset", 0);
        ((IDictionary<string,object>)request)["offset"] = offset;
        object response = null;
        if (isTrue(isSpot))
        {
            response = await this.privatePostUserTrades(this.extend(request, parameters));
        } else
        {
            object responseFromExchange = await this.privatePostMarginTrades(this.extend(request, parameters));
            //
            //    {
            //        "trades": {
            //            "ADA_USDT": [
            //                {
            //                    "trade_id": "692861757015952517",
            //                    "trade_dt": "1693951853197811824",
            //                    "trade_type": "buy",
            //                    "pair": "ADA_USDT",
            //                    "quantity": "1.96607879",
            //                    "price": "0.2568",
            //                    "amount": "0.50488903"
            //                },
            //            ]
            //            ...
            //        }
            //    }
            //
            response = this.safeValue(responseFromExchange, "trades");
        }
        object result = new List<object>() {};
        object marketIdsInner = new List<object>(((IDictionary<string,object>)response).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(marketIdsInner)); postFixIncrement(ref i))
        {
            object marketId = getValue(marketIdsInner, i);
            object resultMarket = this.safeMarket(marketId, null, "_");
            object items = getValue(response, marketId);
            object trades = this.parseTrades(items, resultMarket, since, limit);
            result = this.arrayConcat(result, trades);
        }
        return this.filterBySinceLimit(result, since, limit);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#createOrder
        * @description create a trade order
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#80daa469-ec59-4d0a-b229-6a311d8dd1cd
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#de6f4321-eeac-468c-87f7-c4ad7062e265  // stop market
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#3561b86c-9ff1-436e-8e68-ac926b7eb523  // margin
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.stopPrice] the price at which a trigger order is triggered at
        * @param {string} [params.timeInForce] *spot only* 'fok', 'ioc' or 'post_only'
        * @param {boolean} [params.postOnly] *spot only* true for post only orders
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object isMarket = isTrue((isEqual(type, "market"))) && isTrue((isEqual(price, null)));
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, "cross")))
        {
            throw new BadRequest ((string)add(this.id, " only supports isolated margin")) ;
        }
        object isSpot = (!isEqual(marginMode, "isolated"));
        object triggerPrice = this.safeNumberN(parameters, new List<object>() {"triggerPrice", "stopPrice", "stop_price"});
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
            { "quantity", this.amountToPrecision(getValue(market, "symbol"), amount) },
        };
        object clientOrderId = this.safeValue2(parameters, "client_id", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            clientOrderId = this.safeInteger2(parameters, "client_id", "clientOrderId");
            if (isTrue(isEqual(clientOrderId, null)))
            {
                throw new BadRequest ((string)add(this.id, " createOrder() client order id must be an integer / numeric literal")) ;
            } else
            {
                ((IDictionary<string,object>)request)["client_id"] = clientOrderId;
            }
        }
        object leverage = this.safeNumber(parameters, "leverage");
        if (isTrue(!isTrue(isSpot) && isTrue((isEqual(leverage, null)))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createOrder requires an extra param params[\"leverage\"] for margin orders")) ;
        }
        parameters = this.omit(parameters, new List<object>() {"stopPrice", "stop_price", "triggerPrice", "timeInForce", "client_id", "clientOrderId"});
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(getValue(market, "symbol"), price);
        }
        object response = null;
        if (isTrue(isSpot))
        {
            if (isTrue(!isEqual(triggerPrice, null)))
            {
                if (isTrue(isEqual(type, "limit")))
                {
                    throw new BadRequest ((string)add(this.id, " createOrder () cannot create stop limit orders for spot, only stop market")) ;
                } else
                {
                    ((IDictionary<string,object>)request)["type"] = side;
                    ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, triggerPrice);
                }
                response = await this.privatePostStopMarketOrderCreate(this.extend(request, parameters));
            } else
            {
                object execType = this.safeString(parameters, "exec_type");
                object isPostOnly = null;
                var isPostOnlyparametersVariable = this.handlePostOnly(isEqual(type, "market"), isEqual(execType, "post_only"), parameters);
                isPostOnly = ((IList<object>)isPostOnlyparametersVariable)[0];
                parameters = ((IList<object>)isPostOnlyparametersVariable)[1];
                object timeInForce = this.safeString(parameters, "timeInForce");
                ((IDictionary<string,object>)request)["price"] = ((bool) isTrue(isMarket)) ? 0 : this.priceToPrecision(getValue(market, "symbol"), price);
                if (isTrue(isEqual(type, "limit")))
                {
                    ((IDictionary<string,object>)request)["type"] = side;
                } else if (isTrue(isEqual(type, "market")))
                {
                    ((IDictionary<string,object>)request)["type"] = add("market_", side);
                }
                if (isTrue(isPostOnly))
                {
                    ((IDictionary<string,object>)request)["exec_type"] = "post_only";
                } else if (isTrue(!isEqual(timeInForce, null)))
                {
                    ((IDictionary<string,object>)request)["exec_type"] = timeInForce;
                }
                response = await this.privatePostOrderCreate(this.extend(request, parameters));
            }
        } else
        {
            if (isTrue(!isEqual(triggerPrice, null)))
            {
                ((IDictionary<string,object>)request)["stop_price"] = this.priceToPrecision(symbol, triggerPrice);
                if (isTrue(isEqual(type, "limit")))
                {
                    ((IDictionary<string,object>)request)["type"] = add("stop_limit_", side);
                } else if (isTrue(isEqual(type, "market")))
                {
                    ((IDictionary<string,object>)request)["type"] = add("stop_", side);
                } else
                {
                    ((IDictionary<string,object>)request)["type"] = type;
                }
            } else
            {
                if (isTrue(isTrue(isEqual(type, "limit")) || isTrue(isEqual(type, "market"))))
                {
                    ((IDictionary<string,object>)request)["type"] = add(add(type, "_"), side);
                } else
                {
                    ((IDictionary<string,object>)request)["type"] = type;
                }
            }
            response = await this.privatePostMarginUserOrderCreate(this.extend(request, parameters));
        }
        return this.parseOrder(response, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#cancelOrder
        * @description cancels an open order
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#1f710d4b-75bc-4b65-ad68-006f863a3f26
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#a4d0aae8-28f7-41ac-94fd-c4030130453d  // stop market
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#705dfec5-2b35-4667-862b-faf54eca6209  // margin
        * @param {string} id order id
        * @param {string} symbol not used by exmo cancelOrder ()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.trigger] true to cancel a trigger order
        * @param {string} [params.marginMode] set to 'cross' or 'isolated' to cancel a margin order
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object stop = this.safeValue2(parameters, "trigger", "stop");
        parameters = this.omit(parameters, new List<object>() {"trigger", "stop"});
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("cancelOrder", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, "cross")))
        {
            throw new BadRequest ((string)add(this.id, " only supports isolated margin")) ;
        }
        object response = null;
        if (isTrue((isEqual(marginMode, "isolated"))))
        {
            ((IDictionary<string,object>)request)["order_id"] = id;
            response = await this.privatePostMarginUserOrderCancel(this.extend(request, parameters));
        } else
        {
            if (isTrue(stop))
            {
                ((IDictionary<string,object>)request)["parent_order_id"] = id;
                response = await this.privatePostStopMarketOrderCancel(this.extend(request, parameters));
            } else
            {
                ((IDictionary<string,object>)request)["order_id"] = id;
                response = await this.privatePostOrderCancel(this.extend(request, parameters));
            }
        }
        return this.parseOrder(response);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchOrder
        * @description *spot only* fetches information on an order made by the user
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#cf27781e-28e5-4b39-a52d-3110f5d22459  // spot
        * @param {string} symbol not used by exmo fetchOrder
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "order_id", ((object)id).ToString() },
        };
        object response = await this.privatePostOrderTrades(this.extend(request, parameters));
        //
        //     {
        //         "type": "buy",
        //         "in_currency": "BTC",
        //         "in_amount": "1",
        //         "out_currency": "USD",
        //         "out_amount": "100",
        //         "trades": [
        //             {
        //                 "trade_id": 3,
        //                 "date": 1435488248,
        //                 "type": "buy",
        //                 "pair": "BTC_USD",
        //                 "order_id": 12345,
        //                 "quantity": 1,
        //                 "price": 100,
        //                 "amount": 100
        //             }
        //         ]
        //     }
        //
        object order = this.parseOrder(response);
        ((IDictionary<string,object>)order)["id"] = ((object)id).ToString();
        return order;
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#cf27781e-28e5-4b39-a52d-3110f5d22459  // spot
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#00810661-9119-46c5-aec5-55abe9cb42c7  // margin
        * @param {string} id order id
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] set to "isolated" to fetch trades for a margin order
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOrderTrades", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, "cross")))
        {
            throw new BadRequest ((string)add(this.id, " only supports isolated margin")) ;
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "order_id", ((object)id).ToString() },
        };
        object response = null;
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            response = await this.privatePostMarginUserOrderTrades(this.extend(request, parameters));
        } else
        {
            response = await this.privatePostOrderTrades(this.extend(request, parameters));
        }
        object trades = this.safeList(response, "trades");
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#0e135370-daa4-4689-8acd-b6876dee9ba1  // spot open orders
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#a7cfd4f0-476e-4675-b33f-22a46902f245  // margin
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] set to "isolated" for margin orders
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOpenOrders", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object isMargin = (isTrue((isEqual(marginMode, "cross"))) || isTrue((isEqual(marginMode, "isolated"))));
        object response = null;
        object orders = new List<object>() {};
        if (isTrue(isMargin))
        {
            response = await this.privatePostMarginUserOrderList(parameters);
            //
            //    {
            //        "orders": [
            //            {
            //                "client_id": "0",
            //                "comment": "",
            //                "created": "1619068707985325495",
            //                "distance": "0",
            //                "expire": 0,
            //                "funding_currency": "BTC",
            //                "funding_quantity": "0.01",
            //                "funding_rate": "0.02",
            //                "leverage": "2",
            //                "order_id": "123",
            //                "pair": "BTC_USD",
            //                "previous_type": "limit_sell",
            //                "price": "58000",
            //                "quantity": "0.01",
            //                "src": 0,
            //                "stop_price": "0",
            //                "trigger_price": "58000",
            //                "type": "limit_sell",
            //                "updated": 1619068707989411800
            //            }
            //        ]
            //    }
            //
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "status", "open" },
            });
            object responseOrders = this.safeValue(response, "orders");
            orders = this.parseOrders(responseOrders, market, since, limit, parameters);
        } else
        {
            response = await this.privatePostUserOpenOrders(parameters);
            //
            //    {
            //        "USDT_USD": [
            //            {
            //                "parent_order_id": "507061384740151010",
            //                "client_id": "100500",
            //                "created": "1589547391",
            //                "type": "stop_market_buy",
            //                "pair": "USDT_USD",
            //                "quantity": "1",
            //                "trigger_price": "5",
            //                "amount": "5"
            //            }
            //        ],
            //        ...
            //    }
            //
            object marketIds = new List<object>(((IDictionary<string,object>)response).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
            {
                object marketId = getValue(marketIds, i);
                object marketInner = this.safeMarket(marketId);
                parameters = this.extend(parameters, new Dictionary<string, object>() {
                    { "status", "open" },
                });
                object parsedOrders = this.parseOrders(getValue(response, marketId), marketInner, since, limit, parameters);
                orders = this.arrayConcat(orders, parsedOrders);
            }
        }
        return orders;
    }

    public virtual object parseStatus(object status)
    {
        if (isTrue(isEqual(status, null)))
        {
            return null;
        }
        object statuses = new Dictionary<string, object>() {
            { "cancel_started", "canceled" },
        };
        if (isTrue(isGreaterThanOrEqual(getIndexOf(status, "cancel"), 0)))
        {
            status = "canceled";
        }
        return this.safeString(statuses, status, status);
    }

    public virtual object parseSide(object orderType)
    {
        object side = new Dictionary<string, object>() {
            { "limit_buy", "buy" },
            { "limit_sell", "sell" },
            { "market_buy", "buy" },
            { "market_sell", "sell" },
            { "stop_buy", "buy" },
            { "stop_sell", "sell" },
            { "stop_limit_buy", "buy" },
            { "stop_limit_sell", "sell" },
            { "trailing_stop_buy", "buy" },
            { "trailing_stop_sell", "sell" },
            { "stop_market_sell", "sell" },
            { "stop_market_buy", "buy" },
            { "buy", "buy" },
            { "sell", "sell" },
        };
        return this.safeString(side, orderType, orderType);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // fetchOrders, fetchOpenOrders, fetchClosedOrders, fetchCanceledOrders
        //
        //     {
        //         "order_id": "14",
        //         "created": "1435517311",
        //         "type": "buy",
        //         "pair": "BTC_USD",
        //         "price": "100",
        //         "quantity": "1",
        //         "amount": "100"
        //     }
        //
        // fetchOrder
        //
        //     {
        //         "type": "buy",
        //         "in_currency": "BTC",
        //         "in_amount": "1",
        //         "out_currency": "USD",
        //         "out_amount": "100",
        //         "trades": [
        //             {
        //                 "trade_id": 3,
        //                 "date": 1435488248,
        //                 "type": "buy",
        //                 "pair": "BTC_USD",
        //                 "order_id": 12345,
        //                 "quantity": 1,
        //                 "price": 100,
        //                 "amount": 100
        //             }
        //         ]
        //     }
        //
        // Margin fetchOpenOrders
        //
        //    {
        //        "client_id": "0",
        //        "comment": "",
        //        "created": "1619068707985325495",
        //        "distance": "0",
        //        "expire": 0,
        //        "funding_currency": "BTC",
        //        "funding_quantity": "0.01",
        //        "funding_rate": "0.02",
        //        "leverage": "2",
        //        "order_id": "123",
        //        "pair": "BTC_USD",
        //        "previous_type": "limit_sell",
        //        "price": "58000",
        //        "quantity": "0.01",
        //        "src": 0,
        //        "stop_price": "0",
        //        "trigger_price": "58000",
        //        "type": "limit_sell",
        //        "updated": 1619068707989411800
        //    }
        //
        // Margin fetchClosedOrders
        //
        //    {
        //        "distance": "0",
        //        "event_id": "692842802860022508",
        //        "event_time": "1619069531190173720",
        //        "event_type": "OrderCancelStarted",
        //        "order_id": "123",
        //        "order_status": "cancel_started",
        //        "order_type": "limit_sell",
        //        "pair": "BTC_USD",
        //        "price": "54115",
        //        "quantity": "0.001",
        //        "stop_price": "0",
        //        "trade_id": "0",
        //        "trade_price": "0",
        //        "trade_quantity": "0",
        //        "trade_type": ""
        //    },
        //
        object id = this.safeString2(order, "order_id", "parent_order_id");
        object eventTime = this.safeIntegerProduct2(order, "event_time", "created", 0.000001);
        object timestamp = this.safeTimestamp(order, "created", eventTime);
        object orderType = this.safeString2(order, "type", "order_type");
        object side = this.parseSide(orderType);
        object marketId = null;
        if (isTrue(inOp(order, "pair")))
        {
            marketId = getValue(order, "pair");
        } else if (isTrue(isTrue((inOp(order, "in_currency"))) && isTrue((inOp(order, "out_currency")))))
        {
            if (isTrue(isEqual(side, "buy")))
            {
                marketId = add(add(getValue(order, "in_currency"), "_"), getValue(order, "out_currency"));
            } else
            {
                marketId = add(add(getValue(order, "out_currency"), "_"), getValue(order, "in_currency"));
            }
        }
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object amount = this.safeString(order, "quantity");
        if (isTrue(isEqual(amount, null)))
        {
            object amountField = ((bool) isTrue((isEqual(side, "buy")))) ? "in_amount" : "out_amount";
            amount = this.safeString(order, amountField);
        }
        object price = this.safeString(order, "price");
        object cost = this.safeString(order, "amount");
        object transactions = this.safeValue(order, "trades", new List<object>() {});
        object clientOrderId = this.safeInteger(order, "client_id");
        object triggerPrice = this.safeString(order, "stop_price");
        if (isTrue(isEqual(triggerPrice, "0")))
        {
            triggerPrice = null;
        }
        object type = null;
        if (isTrue(isTrue((!isEqual(orderType, "buy"))) && isTrue((!isEqual(orderType, "sell")))))
        {
            type = orderType;
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "datetime", this.iso8601(timestamp) },
            { "timestamp", timestamp },
            { "lastTradeTimestamp", this.safeIntegerProduct(order, "updated", 0.000001) },
            { "status", this.parseStatus(this.safeString(order, "order_status")) },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", triggerPrice },
            { "triggerPrice", triggerPrice },
            { "cost", cost },
            { "amount", amount },
            { "filled", null },
            { "remaining", null },
            { "average", null },
            { "trades", transactions },
            { "fee", null },
            { "info", order },
        }, market);
    }

    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchCanceledOrders
        * @description fetches information on multiple canceled orders made by the user
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#1d2524dd-ae6d-403a-a067-77b50d13fbe5  // margin
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#a51be1d0-af5f-44e4-99d7-f7b04c6067d0  // spot canceled orders
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] timestamp in ms of the earliest order, default is undefined
        * @param {int} [limit] max number of orders to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] set to "isolated" for margin orders
        * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOrders", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, "cross")))
        {
            throw new BadRequest ((string)add(this.id, " only supports isolated margin")) ;
        }
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100;
        }
        object isSpot = (!isEqual(marginMode, "isolated"));
        if (isTrue(!isEqual(symbol, null)))
        {
            object marketInner = this.market(symbol);
            symbol = getValue(marketInner, "symbol");
        }
        object request = new Dictionary<string, object>() {
            { "limit", limit },
        };
        ((IDictionary<string,object>)request)["offset"] = ((bool) isTrue((!isEqual(since, null)))) ? limit : 0;
        ((IDictionary<string,object>)request)["limit"] = limit;
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object response = null;
        if (isTrue(isSpot))
        {
            response = await this.privatePostUserCancelledOrders(this.extend(request, parameters));
            //
            //    [
            //        {
            //            "order_id": "27056153840",
            //            "client_id": "0",
            //            "created": "1653428646",
            //            "type": "buy",
            //            "pair": "BTC_USDT",
            //            "quantity": "0.1",
            //            "price": "10",
            //            "amount": "1"
            //        }
            //    ]
            //
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "status", "canceled" },
            });
            return this.parseOrders(response, market, since, limit, parameters);
        } else
        {
            object responseSwap = await this.privatePostMarginUserOrderHistory(this.extend(request, parameters));
            //
            //    {
            //        "items": [
            //            {
            //                "event_id": "692862104574106858",
            //                "event_time": "1694116400173489405",
            //                "event_type": "OrderCancelStarted",
            //                "order_id": "692862104561289319",
            //                "order_type": "stop_limit_sell",
            //                "order_status": "cancel_started",
            //                "trade_id": "0",
            //                "trade_type":"",
            //                "trade_quantity": "0",
            //                "trade_price": "0",
            //                "pair": "ADA_USDT",
            //                "quantity": "12",
            //                "price": "0.23",
            //                "stop_price": "0.22",
            //                "distance": "0"
            //            }
            //            ...
            //        ]
            //    }
            //
            object items = this.safeValue(responseSwap, "items");
            object orders = this.parseOrders(items, market, since, limit, parameters);
            object result = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
            {
                object order = getValue(orders, i);
                if (isTrue(isEqual(getValue(order, "status"), "canceled")))
                {
                    ((IList<object>)result).Add(order);
                }
            }
            return result;
        }
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#editOrder
        * @description *margin only* edit a trade order
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#f27ee040-c75f-4b59-b608-d05bd45b7899  // margin
        * @param {string} id order id
        * @param {string} symbol unified CCXT market symbol
        * @param {string} type not used by exmo editOrder
        * @param {string} side not used by exmo editOrder
        * @param {float} [amount] how much of the currency you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.triggerPrice] stop price for stop-market and stop-limit orders
        * @param {string} params.marginMode must be set to isolated
        *
        * EXCHANGE SPECIFIC PARAMETERS
        * @param {int} [params.distance] distance for trailing stop orders
        * @param {int} [params.expire] expiration timestamp in UTC timezone for the order. order will not be expired if expire is 0
        * @param {string} [params.comment] optional comment for order. up to 50 latin symbols, whitespaces, underscores
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("editOrder", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(!isEqual(marginMode, "isolated")))
        {
            throw new BadRequest ((string)add(this.id, " editOrder() can only be used for isolated margin orders")) ;
        }
        object triggerPrice = this.safeNumberN(parameters, new List<object>() {"triggerPrice", "stopPrice", "stop_price"});
        parameters = this.omit(parameters, new List<object>() {"triggerPrice", "stopPrice"});
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["quantity"] = amount;
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(getValue(market, "symbol"), price);
        }
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((IDictionary<string,object>)request)["stop_price"] = this.priceToPrecision(getValue(market, "symbol"), triggerPrice);
        }
        object response = await this.privatePostMarginUserOrderUpdate(this.extend(request, parameters));
        return this.parseOrder(response);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#c8f9ced9-7ab6-4383-a6a4-bc54469ba60e
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostDepositAddress(parameters);
        //
        //     {
        //         "TRX":"TBnwrf4ZdoYXE3C8L2KMs7YPSL3fg6q6V9",
        //         "USDTTRC20":"TBnwrf4ZdoYXE3C8L2KMs7YPSL3fg6q6V9"
        //     }
        //
        object depositAddress = this.safeString(response, code);
        object address = null;
        object tag = null;
        if (isTrue(depositAddress))
        {
            object addressAndTag = ((string)depositAddress).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            address = getValue(addressAndTag, 0);
            object numParts = getArrayLength(addressAndTag);
            if (isTrue(isGreaterThan(numParts, 1)))
            {
                tag = getValue(addressAndTag, 1);
            }
        }
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", null },
            { "info", response },
        };
    }

    public virtual object getMarketFromTrades(object trades)
    {
        object tradesBySymbol = this.indexBy(trades, "pair");
        object symbols = new List<object>(((IDictionary<string,object>)tradesBySymbol).Keys);
        object numSymbols = getArrayLength(symbols);
        if (isTrue(isEqual(numSymbols, 1)))
        {
            return getValue(this.markets, getValue(symbols, 0));
        }
        return null;
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#withdraw
        * @description make a withdrawal
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#3ab9c34d-ad58-4f87-9c57-2e2ea88a8325
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "amount", amount },
            { "currency", getValue(currency, "id") },
            { "address", address },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["invoice"] = tag;
        }
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object network = this.safeStringUpper(parameters, "network"); // this line allows the user to specify either ERC20 or ETH
        network = this.safeString(networks, network, network); // handle ERC20>ETH alias
        if (isTrue(!isEqual(network, null)))
        {
            ((IDictionary<string,object>)request)["transport"] = network;
            parameters = this.omit(parameters, "network");
        }
        object response = await this.privatePostWithdrawCrypt(this.extend(request, parameters));
        return this.parseTransaction(response, currency);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "transferred", "ok" },
            { "paid", "ok" },
            { "pending", "pending" },
            { "processing", "pending" },
            { "verifying", "pending" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDepositsWithdrawals
        //
        //    {
        //        "dt": 1461841192,
        //        "type": "deposit",
        //        "curr": "RUB",
        //        "status": "processing",
        //        "provider": "Qiwi (LA) [12345]",
        //        "amount": "1",
        //        "account": "",
        //        "txid": "ec46f784ad976fd7f7539089d1a129fe46...",
        //    }
        //
        // fetchWithdrawals
        //
        //    {
        //        "operation_id": 47412538520634344,
        //        "created": 1573760013,
        //        "updated": 1573760013,
        //        "type": "withdraw",
        //        "currency": "DOGE",
        //        "status": "Paid",
        //        "amount": "300",
        //        "provider": "DOGE",
        //        "commission": "0",
        //        "account": "DOGE: DBVy8pF1f8yxaCVEHqHeR7kkcHecLQ8nRS",
        //        "order_id": 69670170,
        //        "provider_type": "crypto",
        //        "crypto_address": "DBVy8pF1f8yxaCVEHqHeR7kkcHecLQ8nRS",
        //        "card_number": "",
        //        "wallet_address": "",
        //        "email": "",
        //        "phone": "",
        //        "extra": {
        //            "txid": "f2b66259ae1580f371d38dd27e31a23fff8c04122b65ee3ab5a3f612d579c792",
        //            "confirmations": null,
        //            "excode": "",
        //            "invoice": ""
        //        },
        //        "error": ""
        //    }
        //
        // withdraw
        //
        //    {
        //        "result": true,
        //        "error": "",
        //        "task_id": 11775077
        //    }
        //
        object timestamp = this.safeTimestamp2(transaction, "dt", "created");
        object amountString = this.safeString(transaction, "amount");
        if (isTrue(!isEqual(amountString, null)))
        {
            amountString = Precise.stringAbs(amountString);
        }
        object txid = this.safeString(transaction, "txid");
        if (isTrue(isEqual(txid, null)))
        {
            object extra = this.safeValue(transaction, "extra", new Dictionary<string, object>() {});
            object extraTxid = this.safeString(extra, "txid");
            if (isTrue(!isEqual(extraTxid, "")))
            {
                txid = extraTxid;
            }
        }
        object type = this.safeString(transaction, "type");
        object currencyId = this.safeString2(transaction, "curr", "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object address = null;
        object comment = null;
        object account = this.safeString(transaction, "account");
        if (isTrue(isEqual(type, "deposit")))
        {
            comment = account;
        } else if (isTrue(isEqual(type, "withdrawal")))
        {
            address = account;
            if (isTrue(!isEqual(address, null)))
            {
                object parts = ((string)address).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
                object numParts = getArrayLength(parts);
                if (isTrue(isEqual(numParts, 2)))
                {
                    address = this.safeString(parts, 1);
                    address = ((string)address).Replace((string)" ", (string)"");
                }
            }
        }
        object fee = new Dictionary<string, object>() {
            { "currency", null },
            { "cost", null },
            { "rate", null },
        };
        // fixed funding fees only (for now)
        if (!isTrue(getValue(getValue(this.fees, "transaction"), "percentage")))
        {
            object key = ((bool) isTrue((isEqual(type, "withdrawal")))) ? "withdraw" : "deposit";
            object feeCost = this.safeString(transaction, "commission");
            if (isTrue(isEqual(feeCost, null)))
            {
                object transactionFees = this.safeValue(this.options, "transactionFees", new Dictionary<string, object>() {});
                object codeFees = this.safeValue(transactionFees, code, new Dictionary<string, object>() {});
                feeCost = this.safeString(codeFees, key);
            }
            // users don't pay for cashbacks, no fees for that
            object provider = this.safeString(transaction, "provider");
            if (isTrue(isEqual(provider, "cashback")))
            {
                feeCost = "0";
            }
            if (isTrue(!isEqual(feeCost, null)))
            {
                // withdrawal amount includes the fee
                if (isTrue(isEqual(type, "withdrawal")))
                {
                    amountString = Precise.stringSub(amountString, feeCost);
                }
                ((IDictionary<string,object>)fee)["cost"] = this.parseNumber(feeCost);
                ((IDictionary<string,object>)fee)["currency"] = code;
            }
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString2(transaction, "order_id", "task_id") },
            { "txid", txid },
            { "type", type },
            { "currency", code },
            { "network", this.safeString(transaction, "provider") },
            { "amount", this.parseNumber(amountString) },
            { "status", this.parseTransactionStatus(this.safeStringLower(transaction, "status")) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "address", address },
            { "addressFrom", null },
            { "addressTo", address },
            { "tag", null },
            { "tagFrom", null },
            { "tagTo", null },
            { "updated", this.safeTimestamp(transaction, "updated") },
            { "comment", comment },
            { "internal", null },
            { "fee", fee },
        };
    }

    public async override Task<object> fetchDepositsWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchDepositsWithdrawals
        * @description fetch history of deposits and withdrawals
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#31e69a33-4849-4e6a-b4b4-6d574238f6a7
        * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
        * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
        * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["date"] = this.parseToInt(divide(since, 1000));
        }
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object response = await this.privatePostWalletHistory(this.extend(request, parameters));
        //
        //     {
        //       "result": true,
        //       "error": "",
        //       "begin": "1493942400",
        //       "end": "1494028800",
        //       "history": [
        //          {
        //            "dt": 1461841192,
        //            "type": "deposit",
        //            "curr": "RUB",
        //            "status": "processing",
        //            "provider": "Qiwi (LA) [12345]",
        //            "amount": "1",
        //            "account": "",
        //            "txid": "ec46f784ad976fd7f7539089d1a129fe46...",
        //          },
        //          {
        //            "dt": 1463414785,
        //            "type": "withdrawal",
        //            "curr": "USD",
        //            "status": "paid",
        //            "provider": "EXCODE",
        //            "amount": "-1",
        //            "account": "EX-CODE_19371_USDda...",
        //            "txid": "",
        //          },
        //       ],
        //     }
        //
        return this.parseTransactions(getValue(response, "history"), currency, since, limit);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#97f1becd-7aad-4e0e-babe-7bbe09e33706
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        object request = new Dictionary<string, object>() {
            { "type", "withdraw" },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default: 100, maximum: 100
        }
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        object response = await this.privatePostWalletOperations(this.extend(request, parameters));
        //
        //     {
        //         "items": [
        //         {
        //             "operation_id": 47412538520634344,
        //             "created": 1573760013,
        //             "updated": 1573760013,
        //             "type": "withdraw",
        //             "currency": "DOGE",
        //             "status": "Paid",
        //             "amount": "300",
        //             "provider": "DOGE",
        //             "commission": "0",
        //             "account": "DOGE: DBVy8pF1f8yxaCVEHqHeR7kkcHecLQ8nRS",
        //             "order_id": 69670170,
        //             "extra": {
        //                 "txid": "f2b66259ae1580f371d38dd27e31a23fff8c04122b65ee3ab5a3f612d579c792",
        //                 "excode": "",
        //                 "invoice": ""
        //             },
        //             "error": ""
        //         },
        //     ],
        //         "count": 23
        //     }
        //
        object items = this.safeList(response, "items", new List<object>() {});
        return this.parseTransactions(items, currency, since, limit);
    }

    public async virtual Task<object> fetchWithdrawal(object id, object code = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchWithdrawal
        * @description fetch data on a currency withdrawal via the withdrawal id
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#97f1becd-7aad-4e0e-babe-7bbe09e33706
        * @param {string} id withdrawal id
        * @param {string} code unified currency code of the currency withdrawn, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        object request = new Dictionary<string, object>() {
            { "order_id", id },
            { "type", "withdraw" },
        };
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        object response = await this.privatePostWalletOperations(this.extend(request, parameters));
        //
        //     {
        //         "items": [
        //         {
        //             "operation_id": 47412538520634344,
        //             "created": 1573760013,
        //             "updated": 1573760013,
        //             "type": "deposit",
        //             "currency": "DOGE",
        //             "status": "Paid",
        //             "amount": "300",
        //             "provider": "DOGE",
        //             "commission": "0",
        //             "account": "DOGE: DBVy8pF1f8yxaCVEHqHeR7kkcHecLQ8nRS",
        //             "order_id": 69670170,
        //             "extra": {
        //                 "txid": "f2b66259ae1580f371d38dd27e31a23fff8c04122b65ee3ab5a3f612d579c792",
        //                 "excode": "",
        //                 "invoice": ""
        //             },
        //             "error": ""
        //         },
        //     ],
        //         "count": 23
        //     }
        //
        object items = this.safeValue(response, "items", new List<object>() {});
        object first = this.safeDict(items, 0, new Dictionary<string, object>() {});
        return this.parseTransaction(first, currency);
    }

    public async virtual Task<object> fetchDeposit(object id = null, object code = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchDeposit
        * @description fetch information on a deposit
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#97f1becd-7aad-4e0e-babe-7bbe09e33706
        * @param {string} id deposit id
        * @param {string} code unified currency code, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        object request = new Dictionary<string, object>() {
            { "order_id", id },
            { "type", "deposit" },
        };
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        object response = await this.privatePostWalletOperations(this.extend(request, parameters));
        //
        //     {
        //         "items": [
        //         {
        //             "operation_id": 47412538520634344,
        //             "created": 1573760013,
        //             "updated": 1573760013,
        //             "type": "deposit",
        //             "currency": "DOGE",
        //             "status": "Paid",
        //             "amount": "300",
        //             "provider": "DOGE",
        //             "commission": "0",
        //             "account": "DOGE: DBVy8pF1f8yxaCVEHqHeR7kkcHecLQ8nRS",
        //             "order_id": 69670170,
        //             "extra": {
        //                 "txid": "f2b66259ae1580f371d38dd27e31a23fff8c04122b65ee3ab5a3f612d579c792",
        //                 "excode": "",
        //                 "invoice": ""
        //             },
        //             "error": ""
        //         },
        //     ],
        //         "count": 23
        //     }
        //
        object items = this.safeValue(response, "items", new List<object>() {});
        object first = this.safeDict(items, 0, new Dictionary<string, object>() {});
        return this.parseTransaction(first, currency);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exmo#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#97f1becd-7aad-4e0e-babe-7bbe09e33706
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        object request = new Dictionary<string, object>() {
            { "type", "deposit" },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default: 100, maximum: 100
        }
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        object response = await this.privatePostWalletOperations(this.extend(request, parameters));
        //
        //     {
        //         "items": [
        //         {
        //             "operation_id": 47412538520634344,
        //             "created": 1573760013,
        //             "updated": 1573760013,
        //             "type": "deposit",
        //             "currency": "DOGE",
        //             "status": "Paid",
        //             "amount": "300",
        //             "provider": "DOGE",
        //             "commission": "0",
        //             "account": "DOGE: DBVy8pF1f8yxaCVEHqHeR7kkcHecLQ8nRS",
        //             "order_id": 69670170,
        //             "extra": {
        //                 "txid": "f2b66259ae1580f371d38dd27e31a23fff8c04122b65ee3ab5a3f612d579c792",
        //                 "excode": "",
        //                 "invoice": ""
        //             },
        //             "error": ""
        //         },
        //     ],
        //         "count": 23
        //     }
        //
        object items = this.safeList(response, "items", new List<object>() {});
        return this.parseTransactions(items, currency, since, limit);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(getValue(getValue(this.urls, "api"), api), "/");
        if (isTrue(!isEqual(api, "web")))
        {
            url = add(url, add(this.version, "/"));
        }
        url = add(url, path);
        if (isTrue(isTrue((isEqual(api, "public"))) || isTrue((isEqual(api, "web")))))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.urlencode(parameters)));
            }
        } else if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object nonce = this.nonce();
            body = this.urlencode(this.extend(new Dictionary<string, object>() {
                { "nonce", nonce },
            }, parameters));
            headers = new Dictionary<string, object>() {
                { "Content-Type", "application/x-www-form-urlencoded" },
                { "Key", this.apiKey },
                { "Sign", this.hmac(this.encode(body), this.encode(this.secret), sha512) },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        if (isTrue(isTrue((inOp(response, "error"))) && !isTrue((inOp(response, "result")))))
        {
            // error: {
            //     "code": "140434",
            //     "msg": "Your margin balance is not sufficient to place the order for '5 TON'. Please top up your margin wallet by "2.5 USDT"."
            // }
            //
            object errorCode = this.safeValue(response, "error", new Dictionary<string, object>() {});
            object messageError = this.safeString(errorCode, "msg");
            object code = this.safeString(errorCode, "code");
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), messageError, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        if (isTrue(isTrue((inOp(response, "result"))) || isTrue((inOp(response, "errmsg")))))
        {
            //
            //     {"result":false,"error":"Error 50052: Insufficient funds"}
            //     {"s":"error","errmsg":"strconv.ParseInt: parsing \"\": invalid syntax"}
            //
            object success = this.safeBool(response, "result", false);
            if (isTrue((success is string)))
            {
                if (isTrue(isTrue((isEqual(success, "true"))) || isTrue((isEqual(success, "1")))))
                {
                    success = true;
                } else
                {
                    success = false;
                }
            }
            if (!isTrue(success))
            {
                object code = null;
                object message = this.safeString2(response, "error", "errmsg");
                object errorParts = ((string)message).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
                object numParts = getArrayLength(errorParts);
                if (isTrue(isGreaterThan(numParts, 1)))
                {
                    object errorSubParts = ((string)getValue(errorParts, 0)).Split(new [] {((string)" ")}, StringSplitOptions.None).ToList<object>();
                    object numSubParts = getArrayLength(errorSubParts);
                    code = ((bool) isTrue((isGreaterThan(numSubParts, 1)))) ? getValue(errorSubParts, 1) : getValue(errorSubParts, 0);
                }
                object feedback = add(add(this.id, " "), body);
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
                this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
                throw new ExchangeError ((string)feedback) ;
            }
        }
        return null;
    }
}
