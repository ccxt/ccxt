namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class huobijp : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "huobijp" },
            { "name", "Huobi Japan" },
            { "countries", new List<object>() {"JP"} },
            { "rateLimit", 100 },
            { "userAgent", getValue(this.userAgents, "chrome39") },
            { "certified", false },
            { "version", "v1" },
            { "hostname", "api-cloud.bittrade.co.jp" },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", null },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createStopLimitOrder", false },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchOrderTrades", true },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingLimits", true },
                { "fetchWithdrawals", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1min" },
                { "5m", "5min" },
                { "15m", "15min" },
                { "30m", "30min" },
                { "1h", "60min" },
                { "4h", "4hour" },
                { "1d", "1day" },
                { "1w", "1week" },
                { "1M", "1mon" },
                { "1y", "1year" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/85734211-85755480-b705-11ea-8b35-0b7f1db33a2f.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "market", "https://{hostname}" },
                    { "public", "https://{hostname}" },
                    { "private", "https://{hostname}" },
                    { "v2Public", "https://{hostname}" },
                    { "v2Private", "https://{hostname}" },
                } },
                { "www", "https://www.huobi.co.jp" },
                { "referral", "https://www.huobi.co.jp/register/?invite_code=znnq3" },
                { "doc", "https://api-doc.huobi.co.jp" },
                { "fees", "https://www.huobi.co.jp/support/fee" },
            } },
            { "api", new Dictionary<string, object>() {
                { "v2Public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "reference/currencies", 1 },
                        { "market-status", 1 },
                    } },
                } },
                { "v2Private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "account/ledger", 1 },
                        { "account/withdraw/quota", 1 },
                        { "account/withdraw/address", 1 },
                        { "account/deposit/address", 1 },
                        { "account/repayment", 5 },
                        { "reference/transact-fee-rate", 1 },
                        { "account/asset-valuation", 0.2 },
                        { "point/account", 5 },
                        { "sub-user/user-list", 1 },
                        { "sub-user/user-state", 1 },
                        { "sub-user/account-list", 1 },
                        { "sub-user/deposit-address", 1 },
                        { "sub-user/query-deposit", 1 },
                        { "user/api-key", 1 },
                        { "user/uid", 1 },
                        { "algo-orders/opening", 1 },
                        { "algo-orders/history", 1 },
                        { "algo-orders/specific", 1 },
                        { "c2c/offers", 1 },
                        { "c2c/offer", 1 },
                        { "c2c/transactions", 1 },
                        { "c2c/repayment", 1 },
                        { "c2c/account", 1 },
                        { "etp/reference", 1 },
                        { "etp/transactions", 5 },
                        { "etp/transaction", 5 },
                        { "etp/rebalance", 1 },
                        { "etp/limit", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "account/transfer", 1 },
                        { "account/repayment", 5 },
                        { "point/transfer", 5 },
                        { "sub-user/management", 1 },
                        { "sub-user/creation", 1 },
                        { "sub-user/tradable-market", 1 },
                        { "sub-user/transferability", 1 },
                        { "sub-user/api-key-generation", 1 },
                        { "sub-user/api-key-modification", 1 },
                        { "sub-user/api-key-deletion", 1 },
                        { "sub-user/deduct-mode", 1 },
                        { "algo-orders", 1 },
                        { "algo-orders/cancel-all-after", 1 },
                        { "algo-orders/cancellation", 1 },
                        { "c2c/offer", 1 },
                        { "c2c/cancellation", 1 },
                        { "c2c/cancel-all", 1 },
                        { "c2c/repayment", 1 },
                        { "c2c/transfer", 1 },
                        { "etp/creation", 5 },
                        { "etp/redemption", 5 },
                        { "etp/{transactId}/cancel", 10 },
                        { "etp/batch-cancel", 50 },
                    } },
                } },
                { "market", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "history/kline", 1 },
                        { "detail/merged", 1 },
                        { "depth", 1 },
                        { "trade", 1 },
                        { "history/trade", 1 },
                        { "detail", 1 },
                        { "tickers", 1 },
                        { "etp", 1 },
                    } },
                } },
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "common/symbols", 1 },
                        { "common/currencys", 1 },
                        { "common/timestamp", 1 },
                        { "common/exchange", 1 },
                        { "settings/currencys", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "account/accounts", 0.2 },
                        { "account/accounts/{id}/balance", 0.2 },
                        { "account/accounts/{sub-uid}", 1 },
                        { "account/history", 4 },
                        { "cross-margin/loan-info", 1 },
                        { "margin/loan-info", 1 },
                        { "fee/fee-rate/get", 1 },
                        { "order/openOrders", 0.4 },
                        { "order/orders", 0.4 },
                        { "order/orders/{id}", 0.4 },
                        { "order/orders/{id}/matchresults", 0.4 },
                        { "order/orders/getClientOrder", 0.4 },
                        { "order/history", 1 },
                        { "order/matchresults", 1 },
                        { "query/deposit-withdraw", 1 },
                        { "margin/loan-orders", 0.2 },
                        { "margin/accounts/balance", 0.2 },
                        { "cross-margin/loan-orders", 1 },
                        { "cross-margin/accounts/balance", 1 },
                        { "points/actions", 1 },
                        { "points/orders", 1 },
                        { "subuser/aggregate-balance", 10 },
                        { "stable-coin/exchange_rate", 1 },
                        { "stable-coin/quote", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "account/transfer", 1 },
                        { "futures/transfer", 1 },
                        { "order/batch-orders", 0.4 },
                        { "order/orders/place", 0.2 },
                        { "order/orders/submitCancelClientOrder", 0.2 },
                        { "order/orders/batchCancelOpenOrders", 0.4 },
                        { "order/orders/{id}/submitcancel", 0.2 },
                        { "order/orders/batchcancel", 0.4 },
                        { "dw/withdraw/api/create", 1 },
                        { "dw/withdraw-virtual/{id}/cancel", 1 },
                        { "dw/transfer-in/margin", 10 },
                        { "dw/transfer-out/margin", 10 },
                        { "margin/orders", 10 },
                        { "margin/orders/{id}/repay", 10 },
                        { "cross-margin/transfer-in", 1 },
                        { "cross-margin/transfer-out", 1 },
                        { "cross-margin/orders", 1 },
                        { "cross-margin/orders/{id}/repay", 1 },
                        { "stable-coin/exchange", 1 },
                        { "subuser/transfer", 10 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "feeSide", "get" },
                    { "tierBased", false },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.002") },
                    { "taker", this.parseNumber("0.002") },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "broad", new Dictionary<string, object>() {
                    { "contract is restricted of closing positions on API.  Please contact customer service", typeof(OnMaintenance) },
                    { "maintain", typeof(OnMaintenance) },
                } },
                { "exact", new Dictionary<string, object>() {
                    { "bad-request", typeof(BadRequest) },
                    { "base-date-limit-error", typeof(BadRequest) },
                    { "api-not-support-temp-addr", typeof(PermissionDenied) },
                    { "timeout", typeof(RequestTimeout) },
                    { "gateway-internal-error", typeof(ExchangeNotAvailable) },
                    { "account-frozen-balance-insufficient-error", typeof(InsufficientFunds) },
                    { "invalid-amount", typeof(InvalidOrder) },
                    { "order-limitorder-amount-min-error", typeof(InvalidOrder) },
                    { "order-limitorder-amount-max-error", typeof(InvalidOrder) },
                    { "order-marketorder-amount-min-error", typeof(InvalidOrder) },
                    { "order-limitorder-price-min-error", typeof(InvalidOrder) },
                    { "order-limitorder-price-max-error", typeof(InvalidOrder) },
                    { "order-holding-limit-failed", typeof(InvalidOrder) },
                    { "order-orderprice-precision-error", typeof(InvalidOrder) },
                    { "order-etp-nav-price-max-error", typeof(InvalidOrder) },
                    { "order-orderstate-error", typeof(OrderNotFound) },
                    { "order-queryorder-invalid", typeof(OrderNotFound) },
                    { "order-update-error", typeof(ExchangeNotAvailable) },
                    { "api-signature-check-failed", typeof(AuthenticationError) },
                    { "api-signature-not-valid", typeof(AuthenticationError) },
                    { "base-record-invalid", typeof(OrderNotFound) },
                    { "base-symbol-trade-disabled", typeof(BadSymbol) },
                    { "base-symbol-error", typeof(BadSymbol) },
                    { "system-maintenance", typeof(OnMaintenance) },
                    { "invalid symbol", typeof(BadSymbol) },
                    { "symbol trade not open now", typeof(BadSymbol) },
                    { "invalid-address", typeof(BadRequest) },
                    { "base-currency-chain-error", typeof(BadRequest) },
                    { "dw-insufficient-balance", typeof(InsufficientFunds) },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "defaultNetwork", "ERC20" },
                { "networks", new Dictionary<string, object>() {
                    { "ETH", "erc20" },
                    { "TRX", "trc20" },
                    { "HRC20", "hrc20" },
                    { "HECO", "hrc20" },
                    { "HT", "hrc20" },
                    { "ALGO", "algo" },
                    { "OMNI", "" },
                } },
                { "fetchOrdersByStatesMethod", "private_get_order_orders" },
                { "fetchOpenOrdersMethod", "fetch_open_orders_v1" },
                { "createMarketBuyOrderRequiresPrice", true },
                { "fetchMarketsMethod", "publicGetCommonSymbols" },
                { "fetchBalanceMethod", "privateGetAccountAccountsIdBalance" },
                { "createOrderMethod", "privatePostOrderOrdersPlace" },
                { "currencyToPrecisionRoundingMode", TRUNCATE },
                { "language", "en-US" },
                { "broker", new Dictionary<string, object>() {
                    { "id", "AA03022abc" },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "GET", "Themis" },
                { "GTC", "Game.com" },
                { "HIT", "HitChain" },
                { "PNT", "Penta" },
                { "SBTC", "Super Bitcoin" },
                { "BIFI", "Bitcoin File" },
            } },
        });
    }

    /**
     * @method
     * @name huobijp#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetCommonTimestamp(parameters);
        return this.safeInteger(response, "data");
    }

    public async override Task<object> fetchTradingLimits(object symbols = null, object parameters = null)
    {
        // this method should not be called directly, use loadTradingLimits () instead
        //  by default it will try load withdrawal fees of all currencies (with separate requests)
        //  however if you define symbols = [ 'ETH/BTC', 'LTC/BTC' ] in args it will only load those
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbols, null)))
        {
            symbols = this.symbols;
        }
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            ((IDictionary<string,object>)result)[(string)symbol] = await this.fetchTradingLimitsById(this.marketId(symbol), parameters);
        }
        return result;
    }

    public async virtual Task<object> fetchTradingLimitsById(object id, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "symbol", id },
        };
        object response = await this.publicGetCommonExchange(this.extend(request, parameters));
        //
        //     { status:   "ok",
        //         "data": {                                  symbol: "aidocbtc",
        //                              "buy-limit-must-less-than":  1.1,
        //                          "sell-limit-must-greater-than":  0.9,
        //                         "limit-order-must-greater-than":  1,
        //                            "limit-order-must-less-than":  5000000,
        //                    "market-buy-order-must-greater-than":  0.0001,
        //                       "market-buy-order-must-less-than":  100,
        //                   "market-sell-order-must-greater-than":  1,
        //                      "market-sell-order-must-less-than":  500000,
        //                       "circuit-break-when-greater-than":  10000,
        //                          "circuit-break-when-less-than":  10,
        //                 "market-sell-order-rate-must-less-than":  0.1,
        //                  "market-buy-order-rate-must-less-than":  0.1        } }
        //
        return this.parseTradingLimits(this.safeValue(response, "data", new Dictionary<string, object>() {}));
    }

    public virtual object parseTradingLimits(object limits, object symbol = null, object parameters = null)
    {
        //
        //   {                                  symbol: "aidocbtc",
        //                  "buy-limit-must-less-than":  1.1,
        //              "sell-limit-must-greater-than":  0.9,
        //             "limit-order-must-greater-than":  1,
        //                "limit-order-must-less-than":  5000000,
        //        "market-buy-order-must-greater-than":  0.0001,
        //           "market-buy-order-must-less-than":  100,
        //       "market-sell-order-must-greater-than":  1,
        //          "market-sell-order-must-less-than":  500000,
        //           "circuit-break-when-greater-than":  10000,
        //              "circuit-break-when-less-than":  10,
        //     "market-sell-order-rate-must-less-than":  0.1,
        //      "market-buy-order-rate-must-less-than":  0.1        }
        //
        parameters ??= new Dictionary<string, object>();
        return new Dictionary<string, object>() {
            { "info", limits },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(limits, "limit-order-must-greater-than") },
                    { "max", this.safeNumber(limits, "limit-order-must-less-than") },
                } },
            } },
        };
    }

    public override object costToPrecision(object symbol, object cost)
    {
        return this.decimalToPrecision(cost, TRUNCATE, getValue(getValue(getValue(this.markets, symbol), "precision"), "cost"), this.precisionMode);
    }

    /**
     * @method
     * @name huobijp#fetchMarkets
     * @description retrieves data on all markets for huobijp
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object method = getValue(this.options, "fetchMarketsMethod");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { parameters }));
        //
        //    {
        //        "status": "ok",
        //        "data": [
        //            {
        //                "base-currency": "xrp",
        //                "quote-currency": "btc",
        //                "price-precision": 9,
        //                "amount-precision": 2,
        //                "symbol-partition": "default",
        //                "symbol": "xrpbtc",
        //                "state": "online",
        //                "value-precision": 8,
        //                "min-order-amt": 1,
        //                "max-order-amt": 5000000,
        //                "min-order-value": 0.0001,
        //                "limit-order-min-order-amt": 1,
        //                "limit-order-max-order-amt": 5000000,
        //                "limit-order-max-buy-amt": 5000000,
        //                "limit-order-max-sell-amt": 5000000,
        //                "sell-market-min-order-amt": 1,
        //                "sell-market-max-order-amt": 500000,
        //                "buy-market-max-order-value": 100,
        //                "leverage-ratio": 5,
        //                "super-margin-leverage-ratio": 3,
        //                "api-trading": "enabled",
        //                "tags": ""
        //            }
        //            ...
        //         ]
        //    }
        //
        object markets = this.safeValue(response, "data", new List<object>() {});
        object numMarkets = getArrayLength(markets);
        if (isTrue(isLessThan(numMarkets, 1)))
        {
            throw new NetworkError ((string)add(add(this.id, " fetchMarkets() returned empty response: "), this.json(markets))) ;
        }
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object baseId = this.safeString(market, "base-currency");
            object quoteId = this.safeString(market, "quote-currency");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object state = this.safeString(market, "state");
            object leverageRatio = this.safeString(market, "leverage-ratio", "1");
            object superLeverageRatio = this.safeString(market, "super-margin-leverage-ratio", "1");
            object margin = isTrue(Precise.stringGt(leverageRatio, "1")) || isTrue(Precise.stringGt(superLeverageRatio, "1"));
            object fee = ((bool) isTrue((isEqual(bs, "OMG")))) ? this.parseNumber("0") : this.parseNumber("0.002");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", add(baseId, quoteId) },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", margin },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", (isEqual(state, "online")) },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", fee },
                { "maker", fee },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "price-precision"))) },
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "amount-precision"))) },
                    { "cost", this.parseNumber(this.parsePrecision(this.safeString(market, "value-precision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.parseNumber("1") },
                        { "max", this.parseNumber(leverageRatio) },
                        { "superMax", this.parseNumber(superLeverageRatio) },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min-order-amt") },
                        { "max", this.safeNumber(market, "max-order-amt") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min-order-value") },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", market },
            });
        }
        return result;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // fetchTicker
        //
        //     {
        //         "amount": 26228.672978342216,
        //         "open": 9078.95,
        //         "close": 9146.86,
        //         "high": 9155.41,
        //         "id": 209988544334,
        //         "count": 265846,
        //         "low": 8988.0,
        //         "version": 209988544334,
        //         "ask": [ 9146.87, 0.156134 ],
        //         "vol": 2.3822168242201668E8,
        //         "bid": [ 9146.86, 0.080758 ],
        //     }
        //
        // fetchTickers
        //     {
        //         "symbol": "bhdht",
        //         "open":  2.3938,
        //         "high":  2.4151,
        //         "low":  2.3323,
        //         "close":  2.3909,
        //         "amount":  628.992,
        //         "vol":  1493.71841095,
        //         "count":  2088,
        //         "bid":  2.3643,
        //         "bidSize":  0.7136,
        //         "ask":  2.4061,
        //         "askSize":  0.4156
        //     }
        //
        object symbol = this.safeSymbol(null, market);
        object timestamp = this.safeInteger(ticker, "ts");
        object bid = null;
        object bidVolume = null;
        object ask = null;
        object askVolume = null;
        if (isTrue(inOp(ticker, "bid")))
        {
            if (isTrue(((getValue(ticker, "bid") is IList<object>) || (getValue(ticker, "bid").GetType().IsGenericType && getValue(ticker, "bid").GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                bid = this.safeString(getValue(ticker, "bid"), 0);
                bidVolume = this.safeString(getValue(ticker, "bid"), 1);
            } else
            {
                bid = this.safeString(ticker, "bid");
                bidVolume = this.safeString(ticker, "bidSize");
            }
        }
        if (isTrue(inOp(ticker, "ask")))
        {
            if (isTrue(((getValue(ticker, "ask") is IList<object>) || (getValue(ticker, "ask").GetType().IsGenericType && getValue(ticker, "ask").GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                ask = this.safeString(getValue(ticker, "ask"), 0);
                askVolume = this.safeString(getValue(ticker, "ask"), 1);
            } else
            {
                ask = this.safeString(ticker, "ask");
                askVolume = this.safeString(ticker, "askSize");
            }
        }
        object open = this.safeString(ticker, "open");
        object close = this.safeString(ticker, "close");
        object baseVolume = this.safeString(ticker, "amount");
        object quoteVolume = this.safeString(ticker, "vol");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", bid },
            { "bidVolume", bidVolume },
            { "ask", ask },
            { "askVolume", askVolume },
            { "vwap", null },
            { "open", open },
            { "close", close },
            { "last", close },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name huobijp#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "type", "step0" },
        };
        object response = await this.marketGetDepth(this.extend(request, parameters));
        //
        //     {
        //         "status": "ok",
        //         "ch": "market.btcusdt.depth.step0",
        //         "ts": 1583474832790,
        //         "tick": {
        //             "bids": [
        //                 [ 9100.290000000000000000, 0.200000000000000000 ],
        //                 [ 9099.820000000000000000, 0.200000000000000000 ],
        //                 [ 9099.610000000000000000, 0.205000000000000000 ],
        //             ],
        //             "asks": [
        //                 [ 9100.640000000000000000, 0.005904000000000000 ],
        //                 [ 9101.010000000000000000, 0.287311000000000000 ],
        //                 [ 9101.030000000000000000, 0.012121000000000000 ],
        //             ],
        //             "ts":1583474832008,
        //             "version":104999698780
        //         }
        //     }
        //
        if (isTrue(inOp(response, "tick")))
        {
            if (!isTrue(getValue(response, "tick")))
            {
                throw new BadSymbol ((string)add(add(this.id, " fetchOrderBook() returned empty response: "), this.json(response))) ;
            }
            object tick = this.safeValue(response, "tick");
            object timestamp = this.safeInteger(tick, "ts", this.safeInteger(response, "ts"));
            object result = this.parseOrderBook(tick, symbol, timestamp);
            ((IDictionary<string,object>)result)["nonce"] = this.safeInteger(tick, "version");
            return result;
        }
        throw new ExchangeError ((string)add(add(this.id, " fetchOrderBook() returned unrecognized response: "), this.json(response))) ;
    }

    /**
     * @method
     * @name huobijp#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.marketGetDetailMerged(this.extend(request, parameters));
        //
        //     {
        //         "status": "ok",
        //         "ch": "market.btcusdt.detail.merged",
        //         "ts": 1583494336669,
        //         "tick": {
        //             "amount": 26228.672978342216,
        //             "open": 9078.95,
        //             "close": 9146.86,
        //             "high": 9155.41,
        //             "id": 209988544334,
        //             "count": 265846,
        //             "low": 8988.0,
        //             "version": 209988544334,
        //             "ask": [ 9146.87, 0.156134 ],
        //             "vol": 2.3822168242201668E8,
        //             "bid": [ 9146.86, 0.080758 ],
        //         }
        //     }
        //
        object ticker = this.parseTicker(getValue(response, "tick"), market);
        object timestamp = this.safeInteger(response, "ts");
        ((IDictionary<string,object>)ticker)["timestamp"] = timestamp;
        ((IDictionary<string,object>)ticker)["datetime"] = this.iso8601(timestamp);
        return ticker;
    }

    /**
     * @method
     * @name huobijp#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.marketGetTickers(parameters);
        object tickers = this.safeValue(response, "data", new List<object>() {});
        object timestamp = this.safeInteger(response, "ts");
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(tickers)); postFixIncrement(ref i))
        {
            object marketId = this.safeString(getValue(tickers, i), "symbol");
            object market = this.safeMarket(marketId);
            object symbol = getValue(market, "symbol");
            object ticker = this.parseTicker(getValue(tickers, i), market);
            ((IDictionary<string,object>)ticker)["timestamp"] = timestamp;
            ((IDictionary<string,object>)ticker)["datetime"] = this.iso8601(timestamp);
            ((IDictionary<string,object>)result)[(string)symbol] = ticker;
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //     {
        //         "amount": 0.010411000000000000,
        //         "trade-id": 102090736910,
        //         "ts": 1583497692182,
        //         "id": 10500517034273194594947,
        //         "price": 9096.050000000000000000,
        //         "direction": "sell"
        //     }
        //
        // fetchMyTrades (private)
        //
        //     {
        //          "symbol": "swftcbtc",
        //          "fee-currency": "swftc",
        //          "filled-fees": "0",
        //          "source": "spot-api",
        //          "id": 83789509854000,
        //          "type": "buy-limit",
        //          "order-id": 83711103204909,
        //          'filled-points': "0.005826843283532154",
        //          "fee-deduct-currency": "ht",
        //          'filled-amount': "45941.53",
        //          "price": "0.0000001401",
        //          "created-at": 1597933260729,
        //          "match-id": 100087455560,
        //          "role": "maker",
        //          "trade-id": 100050305348
        //     },
        //
        object marketId = this.safeString(trade, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object timestamp = this.safeInteger2(trade, "ts", "created-at");
        object order = this.safeString(trade, "order-id");
        object side = this.safeString(trade, "direction");
        object type = this.safeString(trade, "type");
        if (isTrue(!isEqual(type, null)))
        {
            object typeParts = ((string)type).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            side = getValue(typeParts, 0);
            type = getValue(typeParts, 1);
        }
        object takerOrMaker = this.safeString(trade, "role");
        object price = this.safeString(trade, "price");
        object amount = this.safeString2(trade, "filled-amount", "amount");
        object cost = Precise.stringMul(price, amount);
        object fee = null;
        object feeCost = this.safeString(trade, "filled-fees");
        object feeCurrency = this.safeCurrencyCode(this.safeString(trade, "fee-currency"));
        object filledPoints = this.safeString(trade, "filled-points");
        if (isTrue(!isEqual(filledPoints, null)))
        {
            if (isTrue(isTrue((isEqual(feeCost, null))) || isTrue((Precise.stringEq(feeCost, "0.0")))))
            {
                feeCost = filledPoints;
                feeCurrency = this.safeCurrencyCode(this.safeString(trade, "fee-deduct-currency"));
            }
        }
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrency },
            };
        }
        object tradeId = this.safeString2(trade, "trade-id", "tradeId");
        object id = this.safeString(trade, "id", tradeId);
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "symbol", symbol },
            { "order", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "type", type },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "fee", fee },
        });
    }

    /**
     * @method
     * @name huobijp#fetchOrderTrades
     * @description fetch all the trades made from a single order
     * @param {string} id order id
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object response = await this.privateGetOrderOrdersIdMatchresults(this.extend(request, parameters));
        return this.parseTrades(getValue(response, "data"), null, since, limit);
    }

    /**
     * @method
     * @name huobijp#fetchMyTrades
     * @description fetch all trades made by the user
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit; // 1-100 orders, default is 100
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start-time"] = since; // a date within 120 days from today
        }
        object response = await this.privateGetOrderMatchresults(this.extend(request, parameters));
        return this.parseTrades(getValue(response, "data"), market, since, limit);
    }

    /**
     * @method
     * @name huobijp#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        limit ??= 1000;
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = mathMin(limit, 2000);
        }
        object response = await this.marketGetHistoryTrade(this.extend(request, parameters));
        //
        //     {
        //         "status": "ok",
        //         "ch": "market.btcusdt.trade.detail",
        //         "ts": 1583497692365,
        //         "data": [
        //             {
        //                 "id": 105005170342,
        //                 "ts": 1583497692182,
        //                 "data": [
        //                     {
        //                         "amount": 0.010411000000000000,
        //                         "trade-id": 102090736910,
        //                         "ts": 1583497692182,
        //                         "id": 10500517034273194594947,
        //                         "price": 9096.050000000000000000,
        //                         "direction": "sell"
        //                     }
        //                 ]
        //             },
        //             // ...
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object trades = this.safeValue(getValue(data, i), "data", new List<object>() {});
            for (object j = 0; isLessThan(j, getArrayLength(trades)); postFixIncrement(ref j))
            {
                object trade = this.parseTrade(getValue(trades, j), market);
                ((IList<object>)result).Add(trade);
            }
        }
        result = this.sortBy(result, "timestamp");
        return this.filterBySymbolSinceLimit(result, getValue(market, "symbol"), since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "amount":1.2082,
        //         "open":0.025096,
        //         "close":0.025095,
        //         "high":0.025096,
        //         "id":1591515300,
        //         "count":6,
        //         "low":0.025095,
        //         "vol":0.0303205097
        //     }
        //
        return new List<object> {this.safeTimestamp(ohlcv, "id"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "amount")};
    }

    /**
     * @method
     * @name huobijp#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        limit ??= 1000;
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "period", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = mathMin(limit, 2000);
        }
        object response = await this.marketGetHistoryKline(this.extend(request, parameters));
        //
        //     {
        //         "status":"ok",
        //         "ch":"market.ethbtc.kline.1min",
        //         "ts":1591515374371,
        //         "data":[
        //             {"amount":0.0,"open":0.025095,"close":0.025095,"high":0.025095,"id":1591515360,"count":0,"low":0.025095,"vol":0.0},
        //             {"amount":1.2082,"open":0.025096,"close":0.025095,"high":0.025096,"id":1591515300,"count":6,"low":0.025095,"vol":0.0303205097},
        //             {"amount":0.0648,"open":0.025096,"close":0.025096,"high":0.025096,"id":1591515240,"count":2,"low":0.025096,"vol":0.0016262208},
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    /**
     * @method
     * @name huobijp#fetchAccounts
     * @description fetch all the accounts associated with a profile
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
     */
    public async override Task<object> fetchAccounts(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetAccountAccounts(parameters);
        return getValue(response, "data");
    }

    /**
     * @method
     * @name huobijp#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "language", getValue(this.options, "language") },
        };
        object response = await this.publicGetSettingsCurrencys(this.extend(request, parameters));
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {
        //                 "currency-addr-with-tag":false,
        //                 "fast-confirms":12,
        //                 "safe-confirms":12,
        //                 "currency-type":"eth",
        //                 "quote-currency":true,
        //                 "withdraw-enable-timestamp":1609430400000,
        //                 "deposit-enable-timestamp":1609430400000,
        //                 "currency-partition":"all",
        //                 "support-sites":["OTC","INSTITUTION","MINEPOOL"],
        //                 "withdraw-precision":6,
        //                 "visible-assets-timestamp":1508839200000,
        //                 "deposit-min-amount":"1",
        //                 "withdraw-min-amount":"10",
        //                 "show-precision":"8",
        //                 "tags":"",
        //                 "weight":23,
        //                 "full-name":"Tether USDT",
        //                 "otc-enable":1,
        //                 "visible":true,
        //                 "white-enabled":false,
        //                 "country-disabled":false,
        //                 "deposit-enabled":true,
        //                 "withdraw-enabled":true,
        //                 "name":"usdt",
        //                 "state":"online",
        //                 "display-name":"USDT",
        //                 "suspend-withdraw-desc":null,
        //                 "withdraw-desc":"Minimum withdrawal amount: 10 USDT (ERC20). !>_<!To ensure the safety of your funds, your withdrawal request will be manually reviewed if your security strategy or password is changed. Please wait for phone calls or emails from our staff.!>_<!Please make sure that your computer and browser are secure and your information is protected from being tampered or leaked.",
        //                 "suspend-deposit-desc":null,
        //                 "deposit-desc":"Please dont deposit any other digital assets except USDT to the above address. Otherwise, you may lose your assets permanently. !>_<!Depositing to the above address requires confirmations of the entire network. It will arrive after 12 confirmations, and it will be available to withdraw after 12 confirmations. !>_<!Minimum deposit amount: 1 USDT. Any deposits less than the minimum will not be credited or refunded.!>_<!Your deposit address wont change often. If there are any changes, we will notify you via announcement or email.!>_<!Please make sure that your computer and browser are secure and your information is protected from being tampered or leaked.",
        //                 "suspend-visible-desc":null
        //             }
        //         ]
        //     }
        //
        object currencies = this.safeValue(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currency = getValue(currencies, i);
            object id = this.safeValue(currency, "name");
            object code = this.safeCurrencyCode(id);
            object depositEnabled = this.safeValue(currency, "deposit-enabled");
            object withdrawEnabled = this.safeValue(currency, "withdraw-enabled");
            object countryDisabled = this.safeValue(currency, "country-disabled");
            object visible = this.safeBool(currency, "visible", false);
            object state = this.safeString(currency, "state");
            object active = isTrue(isTrue(isTrue(isTrue(visible) && isTrue(depositEnabled)) && isTrue(withdrawEnabled)) && isTrue((isEqual(state, "online")))) && !isTrue(countryDisabled);
            object name = this.safeString(currency, "display-name");
            object precision = this.parseNumber(this.parsePrecision(this.safeString(currency, "withdraw-precision")));
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "code", code },
                { "type", "crypto" },
                { "name", name },
                { "active", active },
                { "deposit", depositEnabled },
                { "withdraw", withdrawEnabled },
                { "fee", null },
                { "precision", precision },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", precision },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", this.safeNumber(currency, "deposit-min-amount") },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.safeNumber(currency, "withdraw-min-amount") },
                        { "max", null },
                    } },
                } },
                { "info", currency },
            };
        }
        return result;
    }

    public override object parseBalance(object response)
    {
        object balances = this.safeValue(getValue(response, "data"), "list", new List<object>() {});
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object currencyId = this.safeString(balance, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = null;
            if (isTrue(inOp(result, code)))
            {
                account = getValue(result, code);
            } else
            {
                account = this.account();
            }
            if (isTrue(isEqual(getValue(balance, "type"), "trade")))
            {
                ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "balance");
            }
            if (isTrue(isEqual(getValue(balance, "type"), "frozen")))
            {
                ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "balance");
            }
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name huobijp#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object method = getValue(this.options, "fetchBalanceMethod");
        object request = new Dictionary<string, object>() {
            { "id", getValue(getValue(this.accounts, 0), "id") },
        };
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        return this.parseBalance(response);
    }

    public async virtual Task<object> fetchOrdersByStates(object states, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "states", states },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object method = this.safeString(this.options, "fetchOrdersByStatesMethod", "private_get_order_orders");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //     { "status":   "ok",
        //         "data": [ {                  id:  13997833014,
        //                                "symbol": "ethbtc",
        //                          "account-id":  3398321,
        //                                "amount": "0.045000000000000000",
        //                                 "price": "0.034014000000000000",
        //                          "created-at":  1545836976871,
        //                                  "type": "sell-limit",
        //                        "field-amount": "0.045000000000000000",
        //                   "field-cash-amount": "0.001530630000000000",
        //                          "field-fees": "0.000003061260000000",
        //                         "finished-at":  1545837948214,
        //                                "source": "spot-api",
        //                                 "state": "filled",
        //                         "canceled-at":  0                      }  ] }
        //
        return this.parseOrders(getValue(response, "data"), market, since, limit);
    }

    /**
     * @method
     * @name huobijp#fetchOrder
     * @description fetches information on an order made by the user
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object response = await this.privateGetOrderOrdersId(this.extend(request, parameters));
        object order = this.safeDict(response, "data");
        return this.parseOrder(order);
    }

    /**
     * @method
     * @name huobijp#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStates("pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled", symbol, since, limit, parameters);
    }

    /**
     * @method
     * @name huobijp#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of  open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object method = this.safeString(this.options, "fetchOpenOrdersMethod", "fetch_open_orders_v1");
        return await ((Task<object>)callDynamically(this, method, new object[] { symbol, since, limit, parameters }));
    }

    public async virtual Task<object> fetchOpenOrdersV1(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOpenOrdersV1() requires a symbol argument")) ;
        }
        return await this.fetchOrdersByStates("pre-submitted,submitted,partial-filled", symbol, since, limit, parameters);
    }

    /**
     * @method
     * @name huobijp#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStates("filled,partial-canceled,canceled", symbol, since, limit, parameters);
    }

    public async virtual Task<object> fetchOpenOrdersV2(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object accountId = this.safeString(parameters, "account-id");
        if (isTrue(isEqual(accountId, null)))
        {
            // pick the first account
            await this.loadAccounts();
            for (object i = 0; isLessThan(i, getArrayLength(this.accounts)); postFixIncrement(ref i))
            {
                object account = getValue(this.accounts, i);
                if (isTrue(isEqual(getValue(account, "type"), "spot")))
                {
                    accountId = this.safeString(account, "id");
                    if (isTrue(!isEqual(accountId, null)))
                    {
                        break;
                    }
                }
            }
        }
        ((IDictionary<string,object>)request)["account-id"] = accountId;
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        }
        object omitted = this.omit(parameters, "account-id");
        object response = await this.privateGetOrderOpenOrders(this.extend(request, omitted));
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {
        //                 "symbol":"ethusdt",
        //                 "source":"api",
        //                 "amount":"0.010000000000000000",
        //                 "account-id":1528640,
        //                 "created-at":1561597491963,
        //                 "price":"400.000000000000000000",
        //                 "filled-amount":"0.0",
        //                 "filled-cash-amount":"0.0",
        //                 "filled-fees":"0.0",
        //                 "id":38477101630,
        //                 "state":"submitted",
        //                 "type":"sell-limit"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "partial-filled", "open" },
            { "partial-canceled", "canceled" },
            { "filled", "closed" },
            { "canceled", "canceled" },
            { "submitted", "open" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        //     {                  id:  13997833014,
        //                    "symbol": "ethbtc",
        //              "account-id":  3398321,
        //                    "amount": "0.045000000000000000",
        //                     "price": "0.034014000000000000",
        //              "created-at":  1545836976871,
        //                      "type": "sell-limit",
        //            "field-amount": "0.045000000000000000", // they have fixed it for filled-amount
        //       "field-cash-amount": "0.001530630000000000", // they have fixed it for filled-cash-amount
        //              "field-fees": "0.000003061260000000", // they have fixed it for filled-fees
        //             "finished-at":  1545837948214,
        //                    "source": "spot-api",
        //                     "state": "filled",
        //             "canceled-at":  0                      }
        //
        //     {                  id:  20395337822,
        //                    "symbol": "ethbtc",
        //              "account-id":  5685075,
        //                    "amount": "0.001000000000000000",
        //                     "price": "0.0",
        //              "created-at":  1545831584023,
        //                      "type": "buy-market",
        //            "field-amount": "0.029100000000000000", // they have fixed it for filled-amount
        //       "field-cash-amount": "0.000999788700000000", // they have fixed it for filled-cash-amount
        //              "field-fees": "0.000058200000000000", // they have fixed it for filled-fees
        //             "finished-at":  1545831584181,
        //                    "source": "spot-api",
        //                     "state": "filled",
        //             "canceled-at":  0                      }
        //
        object id = this.safeString(order, "id");
        object side = null;
        object type = null;
        object status = null;
        if (isTrue(inOp(order, "type")))
        {
            object orderType = ((string)getValue(order, "type")).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            side = getValue(orderType, 0);
            type = getValue(orderType, 1);
            status = this.parseOrderStatus(this.safeString(order, "state"));
        }
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(order, "created-at");
        object clientOrderId = this.safeString(order, "client-order-id");
        object amount = this.safeString(order, "amount");
        object filled = this.safeString2(order, "filled-amount", "field-amount"); // typo in their API, filled amount
        object price = this.safeString(order, "price");
        object cost = this.safeString2(order, "filled-cash-amount", "field-cash-amount"); // same typo
        object feeCost = this.safeString2(order, "filled-fees", "field-fees"); // typo in their API, filled fees
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrency = ((bool) isTrue((isEqual(side, "sell")))) ? getValue(market, "quote") : getValue(market, "base");
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrency },
            };
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "average", null },
            { "cost", cost },
            { "amount", amount },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", fee },
            { "trades", null },
        }, market);
    }

    /**
     * @method
     * @name huobijp#createMarketBuyOrderWithCost
     * @description create a market buy order by providing the symbol and cost
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
        }
        ((IDictionary<string,object>)parameters)["createMarketBuyOrderRequiresPrice"] = false;
        return await this.createOrder(symbol, "market", "buy", cost, null, parameters);
    }

    /**
     * @method
     * @name huobijp#createOrder
     * @description create a trade order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "account-id", getValue(getValue(this.accounts, 0), "id") },
            { "symbol", getValue(market, "id") },
            { "type", add(add(side, "-"), type) },
        };
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "client-order-id"); // must be 64 chars max and unique within 24 hours
        if (isTrue(isEqual(clientOrderId, null)))
        {
            object broker = this.safeValue(this.options, "broker", new Dictionary<string, object>() {});
            object brokerId = this.safeString(broker, "id");
            ((IDictionary<string,object>)request)["client-order-id"] = add(brokerId, this.uuid());
        } else
        {
            ((IDictionary<string,object>)request)["client-order-id"] = clientOrderId;
        }
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "client-order-id"});
        if (isTrue(isTrue((isEqual(type, "market"))) && isTrue((isEqual(side, "buy")))))
        {
            object quoteAmount = null;
            object createMarketBuyOrderRequiresPrice = true;
            var createMarketBuyOrderRequiresPriceparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "createMarketBuyOrderRequiresPrice", true);
            createMarketBuyOrderRequiresPrice = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[0];
            parameters = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[1];
            object cost = this.safeNumber(parameters, "cost");
            parameters = this.omit(parameters, "cost");
            if (isTrue(!isEqual(cost, null)))
            {
                quoteAmount = this.amountToPrecision(symbol, cost);
            } else if (isTrue(createMarketBuyOrderRequiresPrice))
            {
                if (isTrue(isEqual(price, null)))
                {
                    throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")) ;
                } else
                {
                    // despite that cost = amount * price is in quote currency and should have quote precision
                    // the exchange API requires the cost supplied in 'amount' to be of base precision
                    // more about it here:
                    // https://github.com/ccxt/ccxt/pull/4395
                    // https://github.com/ccxt/ccxt/issues/7611
                    // we use amountToPrecision here because the exchange requires cost in base precision
                    object amountString = this.numberToString(amount);
                    object priceString = this.numberToString(price);
                    quoteAmount = this.amountToPrecision(symbol, Precise.stringMul(amountString, priceString));
                }
            } else
            {
                quoteAmount = this.amountToPrecision(symbol, amount);
            }
            ((IDictionary<string,object>)request)["amount"] = quoteAmount;
        } else
        {
            ((IDictionary<string,object>)request)["amount"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(isTrue(isTrue(isTrue(isTrue(isEqual(type, "limit")) || isTrue(isEqual(type, "ioc"))) || isTrue(isEqual(type, "limit-maker"))) || isTrue(isEqual(type, "stop-limit"))) || isTrue(isEqual(type, "stop-limit-fok"))))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object method = getValue(this.options, "createOrderMethod");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        object id = this.safeString(response, "data");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", response },
            { "id", id },
            { "timestamp", null },
            { "datetime", null },
            { "lastTradeTimestamp", null },
            { "status", null },
            { "symbol", symbol },
            { "type", type },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "filled", null },
            { "remaining", null },
            { "cost", null },
            { "trades", null },
            { "fee", null },
            { "clientOrderId", null },
            { "average", null },
        }, market);
    }

    /**
     * @method
     * @name huobijp#cancelOrder
     * @description cancels an open order
     * @param {string} id order id
     * @param {string} symbol not used by huobijp cancelOrder ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.privatePostOrderOrdersIdSubmitcancel(new Dictionary<string, object>() {
            { "id", id },
        });
        //
        //     {
        //         "status": "ok",
        //         "data": "10138899000",
        //     }
        //
        return this.extend(this.parseOrder(response), new Dictionary<string, object>() {
            { "id", id },
            { "status", "canceled" },
        });
    }

    /**
     * @method
     * @name huobijp#cancelOrders
     * @description cancel multiple orders
     * @param {string[]} ids order ids
     * @param {string} symbol not used by huobijp cancelOrders ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object clientOrderIds = this.safeValue2(parameters, "clientOrderIds", "client-order-ids");
        parameters = this.omit(parameters, new List<object>() {"clientOrderIds", "client-order-ids"});
        object request = new Dictionary<string, object>() {};
        if (isTrue(isEqual(clientOrderIds, null)))
        {
            ((IDictionary<string,object>)request)["order-ids"] = ids;
        } else
        {
            ((IDictionary<string,object>)request)["client-order-ids"] = clientOrderIds;
        }
        object response = await this.privatePostOrderOrdersBatchcancel(this.extend(request, parameters));
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "success": [
        //                 "5983466"
        //             ],
        //             "failed": [
        //                 {
        //                     "err-msg": "Incorrect order state",
        //                     "order-state": 7,
        //                     "order-id": "",
        //                     "err-code": "order-orderstate-error",
        //                     "client-order-id": "first"
        //                 },
        //                 {
        //                     "err-msg": "Incorrect order state",
        //                     "order-state": 7,
        //                     "order-id": "",
        //                     "err-code": "order-orderstate-error",
        //                     "client-order-id": "second"
        //                 },
        //                 {
        //                     "err-msg": "The record is not found.",
        //                     "order-id": "",
        //                     "err-code": "base-not-found",
        //                     "client-order-id": "third"
        //                 }
        //             ]
        //         }
        //     }
        //
        return this.parseCancelOrders(response);
    }

    public virtual object parseCancelOrders(object orders)
    {
        //
        //    {
        //        "success": [
        //            "5983466"
        //        ],
        //        "failed": [
        //            {
        //                "err-msg": "Incorrect order state",
        //                "order-state": 7,
        //                "order-id": "",
        //                "err-code": "order-orderstate-error",
        //                "client-order-id": "first"
        //            },
        //            ...
        //        ]
        //    }
        //
        //    {
        //        "errors": [
        //            {
        //                "order_id": "769206471845261312",
        //                "err_code": 1061,
        //                "err_msg": "This order doesnt exist."
        //            }
        //        ],
        //        "successes": "1258075374411399168,1258075393254871040"
        //    }
        //
        object successes = this.safeString(orders, "successes");
        object success = null;
        if (isTrue(!isEqual(successes, null)))
        {
            success = ((string)successes).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
        } else
        {
            success = this.safeList(orders, "success", new List<object>() {});
        }
        object failed = this.safeList2(orders, "errors", "failed", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(success)); postFixIncrement(ref i))
        {
            object order = getValue(success, i);
            ((IList<object>)result).Add(this.safeOrder(new Dictionary<string, object>() {
                { "info", order },
                { "id", order },
                { "status", "canceled" },
            }));
        }
        for (object i = 0; isLessThan(i, getArrayLength(failed)); postFixIncrement(ref i))
        {
            object order = getValue(failed, i);
            ((IList<object>)result).Add(this.safeOrder(new Dictionary<string, object>() {
                { "info", order },
                { "id", this.safeString2(order, "order-id", "order_id") },
                { "status", "failed" },
                { "clientOrderId", this.safeString(order, "client-order-id") },
            }));
        }
        return result;
    }

    /**
     * @method
     * @name huobijp#cancelAllOrders
     * @description cancel all open orders
     * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object response = await this.privatePostOrderOrdersBatchCancelOpenOrders(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "data": {
        //             "success-count": 2,
        //             "failed-count": 0,
        //             "next-id": 5454600
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return new List<object> {this.safeOrder(new Dictionary<string, object>() {
    { "info", data },
})};
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "currency": "usdt",
        //         "address": "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
        //         "addressTag": "",
        //         "chain": "usdterc20", // trc20usdt, hrc20usdt, usdt, algousdt
        //     }
        //
        object address = this.safeString(depositAddress, "address");
        object tag = this.safeString(depositAddress, "addressTag");
        object currencyId = this.safeString(depositAddress, "currency");
        currency = this.safeCurrency(currencyId, currency);
        object code = this.safeCurrencyCode(currencyId, currency);
        object networkId = this.safeString(depositAddress, "chain");
        object networks = this.safeValue(currency, "networks", new Dictionary<string, object>() {});
        object networksById = this.indexBy(networks, "id");
        object networkValue = this.safeValue(networksById, networkId, networkId);
        object network = this.safeString(networkValue, "network");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", network },
            { "info", depositAddress },
        };
    }

    /**
     * @method
     * @name huobijp#fetchDeposits
     * @description fetch all deposits made to an account
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isTrue(isEqual(limit, null)) || isTrue(isGreaterThan(limit, 100))))
        {
            limit = 100;
        }
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object request = new Dictionary<string, object>() {
            { "type", "deposit" },
            { "from", 0 },
        };
        if (isTrue(!isEqual(currency, null)))
        {
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit; // max 100
        }
        object response = await this.privateGetQueryDepositWithdraw(this.extend(request, parameters));
        // return response
        return this.parseTransactions(getValue(response, "data"), currency, since, limit);
    }

    /**
     * @method
     * @name huobijp#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isTrue(isEqual(limit, null)) || isTrue(isGreaterThan(limit, 100))))
        {
            limit = 100;
        }
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object request = new Dictionary<string, object>() {
            { "type", "withdraw" },
            { "from", 0 },
        };
        if (isTrue(!isEqual(currency, null)))
        {
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit; // max 100
        }
        object response = await this.privateGetQueryDepositWithdraw(this.extend(request, parameters));
        // return response
        return this.parseTransactions(getValue(response, "data"), currency, since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //     {
        //         "id": 8211029,
        //         "type": "deposit",
        //         "currency": "eth",
        //         "chain": "eth",
        //         'tx-hash': "bd315....",
        //         "amount": 0.81162421,
        //         "address": "4b8b....",
        //         'address-tag": '",
        //         "fee": 0,
        //         "state": "safe",
        //         "created-at": 1542180380965,
        //         "updated-at": 1542180788077
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "id": 6908275,
        //         "type": "withdraw",
        //         "currency": "btc",
        //         "chain": "btc",
        //         'tx-hash': "c1a1a....",
        //         "amount": 0.80257005,
        //         "address": "1QR....",
        //         'address-tag": '",
        //         "fee": 0.0005,
        //         "state": "confirmed",
        //         "created-at": 1552107295685,
        //         "updated-at": 1552108032859
        //     }
        //
        // withdraw
        //
        //     {
        //         "status": "ok",
        //         "data": "99562054"
        //     }
        //
        object timestamp = this.safeInteger(transaction, "created-at");
        object code = this.safeCurrencyCode(this.safeString(transaction, "currency"));
        object type = this.safeString(transaction, "type");
        if (isTrue(isEqual(type, "withdraw")))
        {
            type = "withdrawal";
        }
        object feeCost = this.safeString(transaction, "fee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            feeCost = Precise.stringAbs(feeCost);
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString2(transaction, "id", "data") },
            { "txid", this.safeString(transaction, "tx-hash") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", this.safeStringUpper(transaction, "chain") },
            { "address", this.safeString(transaction, "address") },
            { "addressTo", null },
            { "addressFrom", null },
            { "tag", this.safeString(transaction, "address-tag") },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", type },
            { "amount", this.safeNumber(transaction, "amount") },
            { "currency", code },
            { "status", this.parseTransactionStatus(this.safeString(transaction, "state")) },
            { "updated", this.safeInteger(transaction, "updated-at") },
            { "comment", null },
            { "internal", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", this.parseNumber(feeCost) },
                { "rate", null },
            } },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "unknown", "failed" },
            { "confirming", "pending" },
            { "confirmed", "ok" },
            { "safe", "ok" },
            { "orphan", "failed" },
            { "submitted", "pending" },
            { "canceled", "canceled" },
            { "reexamine", "pending" },
            { "reject", "failed" },
            { "pass", "pending" },
            { "wallet-reject", "failed" },
            { "confirm-error", "failed" },
            { "repealed", "failed" },
            { "wallet-transfer", "pending" },
            { "pre-transfer", "pending" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name huobijp#withdraw
     * @description make a withdrawal
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        this.checkAddress(address);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "address", address },
            { "amount", amount },
            { "currency", ((string)getValue(currency, "id")).ToLower() },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["addr-tag"] = tag; // only for XRP?
        }
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object network = this.safeStringUpper(parameters, "network"); // this line allows the user to specify either ERC20 or ETH
        network = this.safeStringLower(networks, network, network); // handle ETH>ERC20 alias
        if (isTrue(!isEqual(network, null)))
        {
            // possible chains - usdterc20, trc20usdt, hrc20usdt, usdt, algousdt
            if (isTrue(isEqual(network, "erc20")))
            {
                ((IDictionary<string,object>)request)["chain"] = add(getValue(currency, "id"), network);
            } else
            {
                ((IDictionary<string,object>)request)["chain"] = add(network, getValue(currency, "id"));
            }
            parameters = this.omit(parameters, "network");
        }
        object response = await this.privatePostDwWithdrawApiCreate(this.extend(request, parameters));
        //
        //     {
        //         "status": "ok",
        //         "data": "99562054"
        //     }
        //
        return this.parseTransaction(response, currency);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = "/";
        if (isTrue(isEqual(api, "market")))
        {
            url = add(url, api);
        } else if (isTrue(isTrue((isEqual(api, "public"))) || isTrue((isEqual(api, "private")))))
        {
            url = add(url, this.version);
        } else if (isTrue(isTrue((isEqual(api, "v2Public"))) || isTrue((isEqual(api, "v2Private")))))
        {
            url = add(url, "v2");
        }
        url = add(url, add("/", this.implodeParams(path, parameters)));
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(isTrue(isEqual(api, "private")) || isTrue(isEqual(api, "v2Private"))))
        {
            this.checkRequiredCredentials();
            object timestamp = this.ymdhms(this.milliseconds(), "T");
            object request = new Dictionary<string, object>() {
                { "SignatureMethod", "HmacSHA256" },
                { "SignatureVersion", "2" },
                { "AccessKeyId", this.apiKey },
                { "Timestamp", timestamp },
            };
            if (isTrue(!isEqual(method, "POST")))
            {
                request = this.extend(request, query);
            }
            object requestSorted = this.keysort(request);
            object auth = this.urlencode(requestSorted);
            // unfortunately, PHP demands double quotes for the escaped newline symbol
            // eslint-disable-next-line quotes
            object payload = String.Join("\n", ((IList<object>)new List<object>() {method, this.hostname, url, auth}).ToArray());
            object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha256, "base64");
            auth = add(auth, add("&", this.urlencode(new Dictionary<string, object>() {
    { "Signature", signature },
})));
            url = add(url, add("?", auth));
            if (isTrue(isEqual(method, "POST")))
            {
                body = this.json(query);
                headers = new Dictionary<string, object>() {
                    { "Content-Type", "application/json" },
                };
            } else
            {
                headers = new Dictionary<string, object>() {
                    { "Content-Type", "application/x-www-form-urlencoded" },
                };
            }
        } else
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.urlencode(parameters)));
            }
        }
        url = add(this.implodeParams(getValue(getValue(this.urls, "api"), api), new Dictionary<string, object>() {
    { "hostname", this.hostname },
}), url);
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        if (isTrue(inOp(response, "status")))
        {
            //
            //     {"status":"error","err-code":"order-limitorder-amount-min-error","err-msg":"limit order amount error, min: `0.001`","data":null}
            //
            object status = this.safeString(response, "status");
            if (isTrue(isEqual(status, "error")))
            {
                object code = this.safeString(response, "err-code");
                object feedback = add(add(this.id, " "), body);
                this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
                object message = this.safeString(response, "err-msg");
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
                throw new ExchangeError ((string)feedback) ;
            }
        }
        return null;
    }
}
