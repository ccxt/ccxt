namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class xt : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "xt" },
            { "name", "XT" },
            { "countries", new List<object>() {"SC"} },
            { "rateLimit", 100 },
            { "version", "v4" },
            { "certified", false },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", false },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", true },
                { "option", false },
                { "addMargin", true },
                { "borrowMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "createDepositAddress", false },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createPostOnlyOrder", false },
                { "createReduceOnlyOrder", true },
                { "editOrder", true },
                { "fetchAccounts", false },
                { "fetchAllGreeks", false },
                { "fetchBalance", true },
                { "fetchBidsAsks", true },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRate", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchBorrowRatesPerSymbol", false },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDeposit", false },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawals", false },
                { "fetchDepositWithdrawFee", false },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", true },
                { "fetchFundingInterval", true },
                { "fetchFundingIntervals", false },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", false },
                { "fetchGreeks", false },
                { "fetchIndexOHLCV", false },
                { "fetchL3OrderBook", false },
                { "fetchLedger", true },
                { "fetchLedgerEntry", false },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", true },
                { "fetchMarketLeverageTiers", true },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", false },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOption", false },
                { "fetchOptionChain", false },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", false },
                { "fetchOrders", true },
                { "fetchOrdersByStatus", true },
                { "fetchOrderTrades", false },
                { "fetchPosition", true },
                { "fetchPositions", true },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchSettlementHistory", false },
                { "fetchStatus", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTradingLimits", false },
                { "fetchTransactionFee", false },
                { "fetchTransactionFees", false },
                { "fetchTransactions", false },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "fetchVolatilityHistory", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "fetchWithdrawalWhitelist", false },
                { "reduceMargin", true },
                { "repayMargin", false },
                { "setLeverage", true },
                { "setMargin", false },
                { "setMarginMode", true },
                { "setPositionMode", false },
                { "signIn", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "precisionMode", TICK_SIZE },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/14319357/232636712-466df2fc-560a-4ca4-aab2-b1d954a58e24.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "spot", "https://sapi.xt.com" },
                    { "linear", "https://fapi.xt.com" },
                    { "inverse", "https://dapi.xt.com" },
                    { "user", "https://api.xt.com" },
                } },
                { "www", "https://xt.com" },
                { "referral", "https://www.xt.com/en/accounts/register?ref=9PTM9VW" },
                { "doc", new List<object>() {"https://doc.xt.com/", "https://github.com/xtpub/api-doc"} },
                { "fees", "https://www.xt.com/en/rate" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "currencies", 1 },
                            { "depth", 10 },
                            { "kline", 1 },
                            { "symbol", 1 },
                            { "ticker", 1 },
                            { "ticker/book", 1 },
                            { "ticker/price", 1 },
                            { "ticker/24h", 1 },
                            { "time", 1 },
                            { "trade/history", 1 },
                            { "trade/recent", 1 },
                            { "wallet/support/currency", 1 },
                        } },
                    } },
                    { "linear", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "future/market/v1/public/contract/risk-balance", 1 },
                            { "future/market/v1/public/contract/open-interest", 1 },
                            { "future/market/v1/public/leverage/bracket/detail", 1 },
                            { "future/market/v1/public/leverage/bracket/list", 1 },
                            { "future/market/v1/public/q/agg-ticker", 1 },
                            { "future/market/v1/public/q/agg-tickers", 1 },
                            { "future/market/v1/public/q/deal", 1 },
                            { "future/market/v1/public/q/depth", 1 },
                            { "future/market/v1/public/q/funding-rate", 1 },
                            { "future/market/v1/public/q/funding-rate-record", 1 },
                            { "future/market/v1/public/q/index-price", 1 },
                            { "future/market/v1/public/q/kline", 1 },
                            { "future/market/v1/public/q/mark-price", 1 },
                            { "future/market/v1/public/q/symbol-index-price", 1 },
                            { "future/market/v1/public/q/symbol-mark-price", 1 },
                            { "future/market/v1/public/q/ticker", 1 },
                            { "future/market/v1/public/q/tickers", 1 },
                            { "future/market/v1/public/symbol/coins", 3.33 },
                            { "future/market/v1/public/symbol/detail", 3.33 },
                            { "future/market/v1/public/symbol/list", 1 },
                        } },
                    } },
                    { "inverse", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "future/market/v1/public/contract/risk-balance", 1 },
                            { "future/market/v1/public/contract/open-interest", 1 },
                            { "future/market/v1/public/leverage/bracket/detail", 1 },
                            { "future/market/v1/public/leverage/bracket/list", 1 },
                            { "future/market/v1/public/q/agg-ticker", 1 },
                            { "future/market/v1/public/q/agg-tickers", 1 },
                            { "future/market/v1/public/q/deal", 1 },
                            { "future/market/v1/public/q/depth", 1 },
                            { "future/market/v1/public/q/funding-rate", 1 },
                            { "future/market/v1/public/q/funding-rate-record", 1 },
                            { "future/market/v1/public/q/index-price", 1 },
                            { "future/market/v1/public/q/kline", 1 },
                            { "future/market/v1/public/q/mark-price", 1 },
                            { "future/market/v1/public/q/symbol-index-price", 1 },
                            { "future/market/v1/public/q/symbol-mark-price", 1 },
                            { "future/market/v1/public/q/ticker", 1 },
                            { "future/market/v1/public/q/tickers", 1 },
                            { "future/market/v1/public/symbol/coins", 3.33 },
                            { "future/market/v1/public/symbol/detail", 3.33 },
                            { "future/market/v1/public/symbol/list", 1 },
                        } },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "balance", 1 },
                            { "balances", 1 },
                            { "batch-order", 1 },
                            { "deposit/address", 1 },
                            { "deposit/history", 1 },
                            { "history-order", 1 },
                            { "open-order", 1 },
                            { "order", 1 },
                            { "order/{orderId}", 1 },
                            { "trade", 1 },
                            { "withdraw/history", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "order", 0.2 },
                            { "withdraw", 10 },
                            { "balance/transfer", 1 },
                            { "balance/account/transfer", 1 },
                            { "ws-token", 1 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "batch-order", 1 },
                            { "open-order", 1 },
                            { "order/{orderId}", 1 },
                        } },
                        { "put", new Dictionary<string, object>() {
                            { "order/{orderId}", 1 },
                        } },
                    } },
                    { "linear", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "future/trade/v1/entrust/plan-detail", 1 },
                            { "future/trade/v1/entrust/plan-list", 1 },
                            { "future/trade/v1/entrust/plan-list-history", 1 },
                            { "future/trade/v1/entrust/profit-detail", 1 },
                            { "future/trade/v1/entrust/profit-list", 1 },
                            { "future/trade/v1/order/detail", 1 },
                            { "future/trade/v1/order/list", 1 },
                            { "future/trade/v1/order/list-history", 1 },
                            { "future/trade/v1/order/trade-list", 1 },
                            { "future/user/v1/account/info", 1 },
                            { "future/user/v1/balance/bills", 1 },
                            { "future/user/v1/balance/detail", 1 },
                            { "future/user/v1/balance/funding-rate-list", 1 },
                            { "future/user/v1/balance/list", 1 },
                            { "future/user/v1/position/adl", 1 },
                            { "future/user/v1/position/list", 1 },
                            { "future/user/v1/user/collection/list", 1 },
                            { "future/user/v1/user/listen-key", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "future/trade/v1/entrust/cancel-all-plan", 1 },
                            { "future/trade/v1/entrust/cancel-all-profit-stop", 1 },
                            { "future/trade/v1/entrust/cancel-plan", 1 },
                            { "future/trade/v1/entrust/cancel-profit-stop", 1 },
                            { "future/trade/v1/entrust/create-plan", 1 },
                            { "future/trade/v1/entrust/create-profit", 1 },
                            { "future/trade/v1/entrust/update-profit-stop", 1 },
                            { "future/trade/v1/order/cancel", 1 },
                            { "future/trade/v1/order/cancel-all", 1 },
                            { "future/trade/v1/order/create", 1 },
                            { "future/trade/v1/order/create-batch", 1 },
                            { "future/trade/v1/order/update", 1 },
                            { "future/user/v1/account/open", 1 },
                            { "future/user/v1/position/adjust-leverage", 1 },
                            { "future/user/v1/position/auto-margin", 1 },
                            { "future/user/v1/position/close-all", 1 },
                            { "future/user/v1/position/margin", 1 },
                            { "future/user/v1/user/collection/add", 1 },
                            { "future/user/v1/user/collection/cancel", 1 },
                            { "future/user/v1/position/change-type", 1 },
                        } },
                    } },
                    { "inverse", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "future/trade/v1/entrust/plan-detail", 1 },
                            { "future/trade/v1/entrust/plan-list", 1 },
                            { "future/trade/v1/entrust/plan-list-history", 1 },
                            { "future/trade/v1/entrust/profit-detail", 1 },
                            { "future/trade/v1/entrust/profit-list", 1 },
                            { "future/trade/v1/order/detail", 1 },
                            { "future/trade/v1/order/list", 1 },
                            { "future/trade/v1/order/list-history", 1 },
                            { "future/trade/v1/order/trade-list", 1 },
                            { "future/user/v1/account/info", 1 },
                            { "future/user/v1/balance/bills", 1 },
                            { "future/user/v1/balance/detail", 1 },
                            { "future/user/v1/balance/funding-rate-list", 1 },
                            { "future/user/v1/balance/list", 1 },
                            { "future/user/v1/position/adl", 1 },
                            { "future/user/v1/position/list", 1 },
                            { "future/user/v1/user/collection/list", 1 },
                            { "future/user/v1/user/listen-key", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "future/trade/v1/entrust/cancel-all-plan", 1 },
                            { "future/trade/v1/entrust/cancel-all-profit-stop", 1 },
                            { "future/trade/v1/entrust/cancel-plan", 1 },
                            { "future/trade/v1/entrust/cancel-profit-stop", 1 },
                            { "future/trade/v1/entrust/create-plan", 1 },
                            { "future/trade/v1/entrust/create-profit", 1 },
                            { "future/trade/v1/entrust/update-profit-stop", 1 },
                            { "future/trade/v1/order/cancel", 1 },
                            { "future/trade/v1/order/cancel-all", 1 },
                            { "future/trade/v1/order/create", 1 },
                            { "future/trade/v1/order/create-batch", 1 },
                            { "future/trade/v1/order/update", 1 },
                            { "future/user/v1/account/open", 1 },
                            { "future/user/v1/position/adjust-leverage", 1 },
                            { "future/user/v1/position/auto-margin", 1 },
                            { "future/user/v1/position/close-all", 1 },
                            { "future/user/v1/position/margin", 1 },
                            { "future/user/v1/user/collection/add", 1 },
                            { "future/user/v1/user/collection/cancel", 1 },
                        } },
                    } },
                    { "user", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "user/account", 1 },
                            { "user/account/api-key", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "user/account", 1 },
                            { "user/account/api-key", 1 },
                        } },
                        { "put", new Dictionary<string, object>() {
                            { "user/account/api-key", 1 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "user/account/{apiKeyId}", 1 },
                        } },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.002") },
                    { "taker", this.parseNumber("0.002") },
                    { "tiers", new Dictionary<string, object>() {
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.002")}, new List<object> {this.parseNumber("5000"), this.parseNumber("0.0018")}, new List<object> {this.parseNumber("10000"), this.parseNumber("0.0016")}, new List<object> {this.parseNumber("20000"), this.parseNumber("0.0014")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("150000"), this.parseNumber("0.0010")}, new List<object> {this.parseNumber("300000"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("600000"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("1200000"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("2500000"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("6000000"), this.parseNumber("0.0004")}, new List<object> {this.parseNumber("15000000"), this.parseNumber("0.0003")}, new List<object> {this.parseNumber("30000000"), this.parseNumber("0.0002")}} },
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.002")}, new List<object> {this.parseNumber("5000"), this.parseNumber("0.0018")}, new List<object> {this.parseNumber("10000"), this.parseNumber("0.0016")}, new List<object> {this.parseNumber("20000"), this.parseNumber("0.0014")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("150000"), this.parseNumber("0.0010")}, new List<object> {this.parseNumber("300000"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("600000"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("1200000"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("2500000"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("6000000"), this.parseNumber("0.0004")}, new List<object> {this.parseNumber("15000000"), this.parseNumber("0.0003")}, new List<object> {this.parseNumber("30000000"), this.parseNumber("0.0002")}} },
                    } },
                } },
                { "contract", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.0004") },
                    { "taker", this.parseNumber("0.0006") },
                    { "tiers", new Dictionary<string, object>() {
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0004")}, new List<object> {this.parseNumber("200000"), this.parseNumber("0.00038")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.00036")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.00034")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0.00032")}, new List<object> {this.parseNumber("15000000"), this.parseNumber("0.00028")}, new List<object> {this.parseNumber("30000000"), this.parseNumber("0.00024")}, new List<object> {this.parseNumber("50000000"), this.parseNumber("0.0002")}, new List<object> {this.parseNumber("100000000"), this.parseNumber("0.00016")}, new List<object> {this.parseNumber("300000000"), this.parseNumber("0.00012")}, new List<object> {this.parseNumber("500000000"), this.parseNumber("0.00008")}} },
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("200000"), this.parseNumber("0.000588")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.00057")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.00054")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0.00051")}, new List<object> {this.parseNumber("15000000"), this.parseNumber("0.00048")}, new List<object> {this.parseNumber("30000000"), this.parseNumber("0.00045")}, new List<object> {this.parseNumber("50000000"), this.parseNumber("0.00045")}, new List<object> {this.parseNumber("100000000"), this.parseNumber("0.00036")}, new List<object> {this.parseNumber("300000000"), this.parseNumber("0.00033")}, new List<object> {this.parseNumber("500000000"), this.parseNumber("0.0003")}} },
                    } },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "400", typeof(NetworkError) },
                    { "404", typeof(ExchangeError) },
                    { "429", typeof(RateLimitExceeded) },
                    { "500", typeof(ExchangeError) },
                    { "502", typeof(ExchangeError) },
                    { "503", typeof(OnMaintenance) },
                    { "AUTH_001", typeof(AuthenticationError) },
                    { "AUTH_002", typeof(AuthenticationError) },
                    { "AUTH_003", typeof(AuthenticationError) },
                    { "AUTH_004", typeof(AuthenticationError) },
                    { "AUTH_005", typeof(AuthenticationError) },
                    { "AUTH_006", typeof(AuthenticationError) },
                    { "AUTH_007", typeof(AuthenticationError) },
                    { "AUTH_101", typeof(AuthenticationError) },
                    { "AUTH_102", typeof(AuthenticationError) },
                    { "AUTH_103", typeof(AuthenticationError) },
                    { "AUTH_104", typeof(AuthenticationError) },
                    { "AUTH_105", typeof(AuthenticationError) },
                    { "AUTH_106", typeof(PermissionDenied) },
                    { "SYMBOL_001", typeof(BadSymbol) },
                    { "SYMBOL_002", typeof(BadSymbol) },
                    { "SYMBOL_003", typeof(BadSymbol) },
                    { "SYMBOL_004", typeof(BadSymbol) },
                    { "SYMBOL_005", typeof(BadSymbol) },
                    { "ORDER_001", typeof(InvalidOrder) },
                    { "ORDER_002", typeof(InsufficientFunds) },
                    { "ORDER_003", typeof(InvalidOrder) },
                    { "ORDER_004", typeof(InvalidOrder) },
                    { "ORDER_005", typeof(InvalidOrder) },
                    { "ORDER_006", typeof(InvalidOrder) },
                    { "ORDER_007", typeof(PermissionDenied) },
                    { "ORDER_F0101", typeof(InvalidOrder) },
                    { "ORDER_F0102", typeof(InvalidOrder) },
                    { "ORDER_F0103", typeof(InvalidOrder) },
                    { "ORDER_F0201", typeof(InvalidOrder) },
                    { "ORDER_F0202", typeof(InvalidOrder) },
                    { "ORDER_F0203", typeof(InvalidOrder) },
                    { "ORDER_F0301", typeof(InvalidOrder) },
                    { "ORDER_F0401", typeof(InvalidOrder) },
                    { "ORDER_F0501", typeof(InvalidOrder) },
                    { "ORDER_F0502", typeof(InvalidOrder) },
                    { "ORDER_F0601", typeof(InvalidOrder) },
                    { "COMMON_001", typeof(ExchangeError) },
                    { "COMMON_002", typeof(ExchangeError) },
                    { "COMMON_003", typeof(BadRequest) },
                    { "CURRENCY_001", typeof(BadRequest) },
                    { "DEPOSIT_001", typeof(BadRequest) },
                    { "DEPOSIT_002", typeof(PermissionDenied) },
                    { "DEPOSIT_003", typeof(BadRequest) },
                    { "DEPOSIT_004", typeof(BadRequest) },
                    { "DEPOSIT_005", typeof(BadRequest) },
                    { "DEPOSIT_006", typeof(BadRequest) },
                    { "DEPOSIT_007", typeof(BadRequest) },
                    { "DEPOSIT_008", typeof(BadRequest) },
                    { "WITHDRAW_001", typeof(BadRequest) },
                    { "WITHDRAW_002", typeof(BadRequest) },
                    { "WITHDRAW_003", typeof(PermissionDenied) },
                    { "WITHDRAW_004", typeof(BadRequest) },
                    { "WITHDRAW_005", typeof(BadRequest) },
                    { "WITHDRAW_006", typeof(BadRequest) },
                    { "WITHDRAW_008", typeof(PermissionDenied) },
                    { "WITHDRAW_009", typeof(PermissionDenied) },
                    { "WITHDRAW_010", typeof(BadRequest) },
                    { "WITHDRAW_011", typeof(InsufficientFunds) },
                    { "WITHDRAW_012", typeof(PermissionDenied) },
                    { "WITHDRAW_013", typeof(PermissionDenied) },
                    { "WITHDRAW_014", typeof(BadRequest) },
                    { "WITHDRAW_015", typeof(BadRequest) },
                    { "WITHDRAW_016", typeof(BadRequest) },
                    { "WITHDRAW_017", typeof(BadRequest) },
                    { "WITHDRAW_018", typeof(BadRequest) },
                    { "WITHDRAW_019", typeof(BadRequest) },
                    { "WITHDRAW_020", typeof(PermissionDenied) },
                    { "WITHDRAW_021", typeof(PermissionDenied) },
                    { "WITHDRAW_022", typeof(BadRequest) },
                    { "WITHDRAW_023", typeof(BadRequest) },
                    { "WITHDRAW_024", typeof(BadRequest) },
                    { "WITHDRAW_025", typeof(BadRequest) },
                    { "FUND_001", typeof(BadRequest) },
                    { "FUND_002", typeof(InsufficientFunds) },
                    { "FUND_003", typeof(BadRequest) },
                    { "FUND_004", typeof(ExchangeError) },
                    { "FUND_005", typeof(PermissionDenied) },
                    { "FUND_014", typeof(BadRequest) },
                    { "FUND_015", typeof(BadRequest) },
                    { "FUND_016", typeof(BadRequest) },
                    { "FUND_017", typeof(BadRequest) },
                    { "FUND_018", typeof(BadRequest) },
                    { "FUND_019", typeof(BadRequest) },
                    { "FUND_020", typeof(BadRequest) },
                    { "FUND_021", typeof(BadRequest) },
                    { "FUND_022", typeof(BadRequest) },
                    { "FUND_044", typeof(BadRequest) },
                    { "TRANSFER_001", typeof(BadRequest) },
                    { "TRANSFER_002", typeof(InsufficientFunds) },
                    { "TRANSFER_003", typeof(BadRequest) },
                    { "TRANSFER_004", typeof(PermissionDenied) },
                    { "TRANSFER_005", typeof(PermissionDenied) },
                    { "TRANSFER_006", typeof(PermissionDenied) },
                    { "TRANSFER_007", typeof(RequestTimeout) },
                    { "TRANSFER_008", typeof(BadRequest) },
                    { "TRANSFER_009", typeof(BadRequest) },
                    { "TRANSFER_010", typeof(PermissionDenied) },
                    { "TRANSFER_011", typeof(PermissionDenied) },
                    { "TRANSFER_012", typeof(PermissionDenied) },
                    { "symbol_not_support_trading_via_api", typeof(BadSymbol) },
                    { "open_order_min_nominal_value_limit", typeof(InvalidOrder) },
                    { "insufficient_balance", typeof(InsufficientFunds) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "The symbol does not support trading via API", typeof(BadSymbol) },
                    { "Exceeds the minimum notional value of a single order", typeof(InvalidOrder) },
                    { "insufficient balance", typeof(InsufficientFunds) },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "8h", "8h" },
                { "1d", "1d" },
                { "3d", "3d" },
                { "1w", "1w" },
                { "1M", "1M" },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "options", new Dictionary<string, object>() {
                { "adjustForTimeDifference", false },
                { "timeDifference", 0 },
                { "accountsById", new Dictionary<string, object>() {
                    { "spot", "SPOT" },
                    { "leverage", "LEVER" },
                    { "finance", "FINANCE" },
                    { "swap", "FUTURES_U" },
                    { "future", "FUTURES_U" },
                    { "linear", "FUTURES_U" },
                    { "inverse", "FUTURES_C" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "ERC20", "Ethereum" },
                    { "TRC20", "Tron" },
                    { "BEP20", "BNB Smart Chain" },
                    { "BEP2", "BNB-BEP2" },
                    { "ETH", "Ethereum" },
                    { "TRON", "Tron" },
                    { "BNB", "BNB Smart Chain" },
                    { "AVAX", "AVAX C-Chain" },
                    { "GAL", "GAL(FT)" },
                    { "ALEO", "ALEO(IOU)" },
                    { "BTC", "Bitcoin" },
                    { "XT", "XT Smart Chain" },
                    { "ETC", "Ethereum Classic" },
                    { "MATIC", "Polygon" },
                    { "LTC", "Litecoin" },
                    { "BTS", "BitShares" },
                    { "XRP", "Ripple" },
                    { "XLM", "Stellar Network" },
                    { "ADA", "Cardano" },
                    { "XWC", "XWC-XWC" },
                    { "DOGE", "dogecoin" },
                    { "DCR", "Decred" },
                    { "SC", "Siacoin" },
                    { "XTZ", "Tezos" },
                    { "ZEC", "Zcash" },
                    { "XMR", "Monero" },
                    { "LSK", "Lisk" },
                    { "ATOM", "Cosmos" },
                    { "ONT", "Ontology" },
                    { "ALGO", "Algorand" },
                    { "SOL", "SOL-SOL" },
                    { "DOT", "Polkadot" },
                    { "ZEN", "Horizen" },
                    { "FIL", "Filecoin" },
                    { "CHZ", "chz" },
                    { "ICP", "Internet Computer" },
                    { "KSM", "Kusama" },
                    { "LUNA", "Terra" },
                    { "THETA", "Theta Token" },
                    { "FTM", "Fantom" },
                    { "VET", "VeChain" },
                    { "NEAR", "NEAR Protocol" },
                    { "ONE", "Harmony" },
                    { "KLAY", "Klaytn" },
                    { "AR", "Arweave" },
                    { "CELT", "OKT" },
                    { "EGLD", "Elrond eGold" },
                    { "CRO", "CRO-CRONOS" },
                    { "BCH", "Bitcoin Cash" },
                    { "GLMR", "Moonbeam" },
                    { "LOOP", "LOOP-LRC" },
                    { "REI", "REI Network" },
                    { "ASTR", "Astar Network" },
                    { "OP", "OPT" },
                    { "MMT", "MMT-MMT" },
                    { "TBC", "TBC-TBC" },
                    { "OMAX", "OMAX-OMAX CHAIN" },
                    { "GMMT", "GMMT chain" },
                    { "ZIL", "Zilliqa" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "Ethereum", "ERC20" },
                    { "Tron", "TRC20" },
                    { "BNB Smart Chain", "BEP20" },
                    { "BNB-BEP2", "BEP2" },
                    { "Bitcoin", "BTC" },
                    { "XT Smart Chain", "XT" },
                    { "Ethereum Classic", "ETC" },
                    { "Polygon", "MATIC" },
                    { "Litecoin", "LTC" },
                    { "BitShares", "BTS" },
                    { "Ripple", "XRP" },
                    { "Stellar Network", "XLM" },
                    { "Cardano", "ADA" },
                    { "XWC-XWC", "XWC" },
                    { "dogecoin", "DOGE" },
                    { "Decred", "DCR" },
                    { "Siacoin", "SC" },
                    { "Tezos", "XTZ" },
                    { "Zcash", "ZEC" },
                    { "Monero", "XMR" },
                    { "Lisk", "LSK" },
                    { "Cosmos", "ATOM" },
                    { "Ontology", "ONT" },
                    { "Algorand", "ALGO" },
                    { "SOL-SOL", "SOL" },
                    { "Polkadot", "DOT" },
                    { "Horizen", "ZEN" },
                    { "Filecoin", "FIL" },
                    { "chz", "CHZ" },
                    { "Internet Computer", "ICP" },
                    { "Kusama", "KSM" },
                    { "Terra", "LUNA" },
                    { "Theta Token", "THETA" },
                    { "Fantom", "FTM" },
                    { "VeChain", "VET" },
                    { "AVAX C-Chain", "AVAX" },
                    { "NEAR Protocol", "NEAR" },
                    { "Harmony", "ONE" },
                    { "Klaytn", "KLAY" },
                    { "Arweave", "AR" },
                    { "OKT", "CELT" },
                    { "Elrond eGold", "EGLD" },
                    { "CRO-CRONOS", "CRO" },
                    { "Bitcoin Cash", "BCH" },
                    { "Moonbeam", "GLMR" },
                    { "LOOP-LRC", "LOOP" },
                    { "REI Network", "REI" },
                    { "Astar Network", "ASTR" },
                    { "GAL(FT)", "GAL" },
                    { "ALEO(IOU)", "ALEO" },
                    { "OPT", "OP" },
                    { "MMT-MMT", "MMT" },
                    { "TBC-TBC", "TBC" },
                    { "OMAX-OMAX CHAIN", "OMAX" },
                    { "GMMT chain", "GMMT" },
                    { "Zilliqa", "ZIL" },
                } },
                { "createMarketBuyOrderRequiresPrice", true },
                { "recvWindow", "5000" },
            } },
            { "features", new Dictionary<string, object>() {
                { "default", new Dictionary<string, object>() {
                    { "sandbox", false },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", false },
                        { "triggerDirection", false },
                        { "triggerPriceType", null },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "trailing", false },
                        { "leverage", false },
                        { "marketBuyByCost", true },
                        { "marketBuyRequiresPrice", false },
                        { "selfTradePrevention", false },
                        { "iceberg", false },
                    } },
                    { "createOrders", null },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", 100 },
                        { "daysBack", 100000 },
                        { "untilDays", 100000 },
                        { "marketType", true },
                        { "subType", true },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", true },
                        { "trailing", false },
                        { "marketType", true },
                        { "subType", true },
                        { "symbolRequired", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", 100 },
                        { "trigger", true },
                        { "trailing", false },
                        { "marketType", true },
                        { "subType", true },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", 100 },
                        { "daysBack", 100000 },
                        { "untilDays", 100000 },
                        { "trigger", true },
                        { "trailing", false },
                        { "marketType", true },
                        { "subType", true },
                        { "symbolRequired", false },
                    } },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", 100 },
                        { "daysBack", 100000 },
                        { "daysBackCanceled", 1 },
                        { "untilDays", 100000 },
                        { "trigger", true },
                        { "trailing", false },
                        { "marketType", true },
                        { "subType", true },
                        { "symbolRequired", false },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 1000 },
                    } },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "extends", "default" },
                } },
                { "forDerivatives", new Dictionary<string, object>() {
                    { "extends", "default" },
                    { "createOrder", new Dictionary<string, object>() {
                        { "triggerPrice", true },
                        { "triggerPriceType", new Dictionary<string, object>() {
                            { "last", true },
                            { "mark", true },
                            { "index", true },
                        } },
                        { "stopLossPrice", true },
                        { "takeProfitPrice", true },
                    } },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "daysBack", null },
                        { "untilDays", null },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "forDerivatives" },
                    } },
                    { "inverse", new Dictionary<string, object>() {
                        { "extends", "forDerivatives" },
                    } },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "forDerivatives" },
                    } },
                    { "inverse", new Dictionary<string, object>() {
                        { "extends", "forDerivatives" },
                    } },
                } },
            } },
        });
    }

    public override object nonce()
    {
        return subtract(this.milliseconds(), getValue(this.options, "timeDifference"));
    }

    /**
     * @method
     * @name xt#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the xt server
     * @see https://doc.xt.com/#market1serverInfo
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {int} the current integer timestamp in milliseconds from the xt server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicSpotGetTime(parameters);
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": {
        //             "serverTime": 1677823301643
        //         }
        //     }
        //
        object data = this.safeValue(response, "result");
        return this.safeInteger(data, "serverTime");
    }

    /**
     * @method
     * @name xt#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://doc.xt.com/#deposit_withdrawalsupportedCurrenciesGet
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object promisesRaw = new List<object> {this.publicSpotGetWalletSupportCurrency(parameters), this.publicSpotGetCurrencies(parameters)};
        var chainsResponsecurrenciesResponseVariable = await promiseAll(promisesRaw);
        var chainsResponse = ((IList<object>) chainsResponsecurrenciesResponseVariable)[0];
        var currenciesResponse = ((IList<object>) chainsResponsecurrenciesResponseVariable)[1];
        //
        // currencies
        //
        //    {
        //        "time": "1686626116145",
        //        "version": "5dbbb2f2527c22b2b2e3b47187ef13d1",
        //        "currencies": [
        //            {
        //                "id": "2",
        //                "currency": "btc",
        //                "fullName": "Bitcoin",
        //                "logo": "https://a.static-global.com/1/currency/btc.png",
        //                "cmcLink": "https://coinmarketcap.com/currencies/bitcoin/",
        //                "weight": "99999",
        //                "maxPrecision": "10",
        //                "depositStatus": "1",
        //                "withdrawStatus": "1",
        //                "convertEnabled": "1",
        //                "transferEnabled": "1",
        //                "isChainExist": "1",
        //                "plates": [152]
        //            },
        //        ],
        //    }
        //
        //
        // chains
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": [
        //             {
        //                 "currency": "btc",
        //                 "supportChains": [
        //                     {
        //                         "chain": "Bitcoin",
        //                         "depositEnabled": true,
        //                         "withdrawEnabled": true,
        //                         "withdrawFeeAmount": 0.0009,
        //                         "withdrawMinAmount": 0.0005,
        //                         "depositFeeRate": 0
        //                     },
        //                 ]
        //             },
        //         ]
        //     }
        //
        // note: individual network's full data is available on per-currency endpoint: https://www.xt.com/sapi/v4/balance/public/currency/11
        //
        object chainsData = this.safeValue(chainsResponse, "result", new List<object>() {});
        object currenciesResult = this.safeValue(currenciesResponse, "result", new List<object>() {});
        object currenciesData = this.safeValue(currenciesResult, "currencies", new List<object>() {});
        object chainsDataIndexed = this.indexBy(chainsData, "currency");
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currenciesData)); postFixIncrement(ref i))
        {
            object entry = getValue(currenciesData, i);
            object currencyId = this.safeString(entry, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object networkEntry = this.safeValue(chainsDataIndexed, currencyId, new Dictionary<string, object>() {});
            object rawNetworks = this.safeValue(networkEntry, "supportChains", new List<object>() {});
            object networks = new Dictionary<string, object>() {};
            for (object j = 0; isLessThan(j, getArrayLength(rawNetworks)); postFixIncrement(ref j))
            {
                object rawNetwork = getValue(rawNetworks, j);
                object networkId = this.safeString(rawNetwork, "chain");
                object networkCode = this.networkIdToCode(networkId, code);
                ((IDictionary<string,object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                    { "info", rawNetwork },
                    { "id", networkId },
                    { "network", networkCode },
                    { "name", null },
                    { "active", null },
                    { "fee", this.safeNumber(rawNetwork, "withdrawFeeAmount") },
                    { "precision", null },
                    { "deposit", this.safeBool(rawNetwork, "depositEnabled") },
                    { "withdraw", this.safeBool(rawNetwork, "withdrawEnabled") },
                    { "limits", new Dictionary<string, object>() {
                        { "amount", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", this.safeNumber(rawNetwork, "withdrawMinAmount") },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                    } },
                };
            }
            object typeRaw = this.safeString(entry, "type");
            object type = null;
            if (isTrue(isEqual(typeRaw, "FT")))
            {
                type = "crypto";
            } else
            {
                type = "other";
            }
            ((IDictionary<string,object>)result)[(string)code] = this.safeCurrencyStructure(new Dictionary<string, object>() {
                { "info", entry },
                { "id", currencyId },
                { "code", code },
                { "name", this.safeString(entry, "fullName") },
                { "active", null },
                { "fee", null },
                { "precision", this.parseNumber(this.parsePrecision(this.safeString(entry, "maxPrecision"))) },
                { "deposit", isEqual(this.safeString(entry, "depositStatus"), "1") },
                { "withdraw", isEqual(this.safeString(entry, "withdrawStatus"), "1") },
                { "networks", networks },
                { "type", type },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
            });
        }
        return result;
    }

    /**
     * @method
     * @name xt#fetchMarkets
     * @description retrieves data on all markets for xt
     * @see https://doc.xt.com/#market2symbol
     * @see https://doc.xt.com/#futures_quotesgetSymbols
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.options, "adjustForTimeDifference")))
        {
            await this.loadTimeDifference();
        }
        object promisesUnresolved = new List<object> {this.fetchSpotMarkets(parameters), this.fetchSwapAndFutureMarkets(parameters)};
        object promises = await promiseAll(promisesUnresolved);
        object spotMarkets = getValue(promises, 0);
        object swapAndFutureMarkets = getValue(promises, 1);
        return this.arrayConcat(spotMarkets, swapAndFutureMarkets);
    }

    public async virtual Task<object> fetchSpotMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicSpotGetSymbol(parameters);
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": {
        //             "time": 1677881368812,
        //             "version": "abb101d1543e54bee40687b135411ba0",
        //             "symbols": [
        //                 {
        //                     "id": 640,
        //                     "symbol": "xt_usdt",
        //                     "state": "ONLINE",
        //                     "stateTime": 1554048000000,
        //                     "tradingEnabled": true,
        //                     "openapiEnabled": true,
        //                     "nextStateTime": null,
        //                     "nextState": null,
        //                     "depthMergePrecision": 5,
        //                     "baseCurrency": "xt",
        //                     "baseCurrencyPrecision": 8,
        //                     "baseCurrencyId": 128,
        //                     "quoteCurrency": "usdt",
        //                     "quoteCurrencyPrecision": 8,
        //                     "quoteCurrencyId": 11,
        //                     "pricePrecision": 4,
        //                     "quantityPrecision": 2,
        //                     "orderTypes": ["LIMIT","MARKET"],
        //                     "timeInForces": ["GTC","IOC"],
        //                     "displayWeight": 10002,
        //                     "displayLevel": "FULL",
        //                     "plates": [],
        //                     "filters":[
        //                         {
        //                             "filter": "QUOTE_QTY",
        //                             "min": "1"
        //                         },
        //                         {
        //                             "filter": "PROTECTION_LIMIT",
        //                             "buyMaxDeviation": "0.8",
        //                             "sellMaxDeviation": "4"
        //                         },
        //                         {
        //                             "filter": "PROTECTION_MARKET",
        //                             "maxDeviation": "0.02"
        //                         }
        //                     ]
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object symbols = this.safeValue(data, "symbols", new List<object>() {});
        return this.parseMarkets(symbols);
    }

    public async virtual Task<object> fetchSwapAndFutureMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object markets = await promiseAll(new List<object> {this.publicLinearGetFutureMarketV1PublicSymbolList(parameters), this.publicInverseGetFutureMarketV1PublicSymbolList(parameters)});
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": [
        //             {
        //                 "id": 52,
        //                 "symbolGroupId": 71,
        //                 "symbol": "xt_usdt",
        //                 "pair": "xt_usdt",
        //                 "contractType": "PERPETUAL",
        //                 "productType": "perpetual",
        //                 "predictEventType": null,
        //                 "underlyingType": "U_BASED",
        //                 "contractSize": "1",
        //                 "tradeSwitch": true,
        //                 "isDisplay": true,
        //                 "isOpenApi": false,
        //                 "state": 0,
        //                 "initLeverage": 20,
        //                 "initPositionType": "CROSSED",
        //                 "baseCoin": "xt",
        //                 "quoteCoin": "usdt",
        //                 "baseCoinPrecision": 8,
        //                 "baseCoinDisplayPrecision": 4,
        //                 "quoteCoinPrecision": 8,
        //                 "quoteCoinDisplayPrecision": 4,
        //                 "quantityPrecision": 0,
        //                 "pricePrecision": 4,
        //                 "supportOrderType": "LIMIT,MARKET",
        //                 "supportTimeInForce": "GTC,FOK,IOC,GTX",
        //                 "supportEntrustType": "TAKE_PROFIT,STOP,TAKE_PROFIT_MARKET,STOP_MARKET,TRAILING_STOP_MARKET",
        //                 "supportPositionType": "CROSSED,ISOLATED",
        //                 "minQty": "1",
        //                 "minNotional": "5",
        //                 "maxNotional": "20000000",
        //                 "multiplierDown": "0.1",
        //                 "multiplierUp": "0.1",
        //                 "maxOpenOrders": 200,
        //                 "maxEntrusts": 200,
        //                 "makerFee": "0.0004",
        //                 "takerFee": "0.0006",
        //                 "liquidationFee": "0.01",
        //                 "marketTakeBound": "0.1",
        //                 "depthPrecisionMerge": 5,
        //                 "labels": ["HOT"],
        //                 "onboardDate": 1657101601000,
        //                 "enName": "XTUSDT ",
        //                 "cnName": "XTUSDT",
        //                 "minStepPrice": "0.0001",
        //                 "minPrice": null,
        //                 "maxPrice": null,
        //                 "deliveryDate": 1669879634000,
        //                 "deliveryPrice": null,
        //                 "deliveryCompletion": false,
        //                 "cnDesc": null,
        //                 "enDesc": null
        //             },
        //         ]
        //     }
        //
        object swapAndFutureMarkets = this.arrayConcat(this.safeValue(getValue(markets, 0), "result", new List<object>() {}), this.safeValue(getValue(markets, 1), "result", new List<object>() {}));
        return this.parseMarkets(swapAndFutureMarkets);
    }

    public override object parseMarkets(object markets)
    {
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parseMarket(getValue(markets, i)));
        }
        return result;
    }

    public override object parseMarket(object market)
    {
        //
        // spot
        //
        //     {
        //         "id": 640,
        //         "symbol": "xt_usdt",
        //         "state": "ONLINE",
        //         "stateTime": 1554048000000,
        //         "tradingEnabled": true,
        //         "openapiEnabled": true,
        //         "nextStateTime": null,
        //         "nextState": null,
        //         "depthMergePrecision": 5,
        //         "baseCurrency": "xt",
        //         "baseCurrencyPrecision": 8,
        //         "baseCurrencyId": 128,
        //         "quoteCurrency": "usdt",
        //         "quoteCurrencyPrecision": 8,
        //         "quoteCurrencyId": 11,
        //         "pricePrecision": 4,
        //         "quantityPrecision": 2,
        //         "orderTypes": ["LIMIT","MARKET"],
        //         "timeInForces": ["GTC","IOC"],
        //         "displayWeight": 10002,
        //         "displayLevel": "FULL",
        //         "plates": [],
        //         "filters":[
        //             {
        //                 "filter": "QUOTE_QTY",
        //                 "min": "1"
        //             },
        //             {
        //                 "filter": "PRICE",
        //                 "min": null,
        //                 "max": null,
        //                 "tickSize": null
        //             },
        //             {
        //                 "filter": "QUANTITY",
        //                 "min": null,
        //                 "max": null,
        //                 "tickSize": null
        //             },
        //             {
        //                 "filter": "PROTECTION_LIMIT",
        //                 "buyMaxDeviation": "0.8",
        //                 "sellMaxDeviation": "4"
        //             },
        //             {
        //                 "filter": "PROTECTION_MARKET",
        //                 "maxDeviation": "0.02"
        //             },
        //             {
        //                  "filter": "PROTECTION_ONLINE",
        //                  "durationSeconds": "300",
        //                  "maxPriceMultiple": "5"
        //             },
        //         ]
        //     }
        //
        // swap and future
        //
        //     {
        //         "id": 52,
        //         "symbolGroupId": 71,
        //         "symbol": "xt_usdt",
        //         "pair": "xt_usdt",
        //         "contractType": "PERPETUAL",
        //         "productType": "perpetual",
        //         "predictEventType": null,
        //         "underlyingType": "U_BASED",
        //         "contractSize": "1",
        //         "tradeSwitch": true,
        //         "isDisplay": true,
        //         "isOpenApi": false,
        //         "state": 0,
        //         "initLeverage": 20,
        //         "initPositionType": "CROSSED",
        //         "baseCoin": "xt",
        //         "quoteCoin": "usdt",
        //         "baseCoinPrecision": 8,
        //         "baseCoinDisplayPrecision": 4,
        //         "quoteCoinPrecision": 8,
        //         "quoteCoinDisplayPrecision": 4,
        //         "quantityPrecision": 0,
        //         "pricePrecision": 4,
        //         "supportOrderType": "LIMIT,MARKET",
        //         "supportTimeInForce": "GTC,FOK,IOC,GTX",
        //         "supportEntrustType": "TAKE_PROFIT,STOP,TAKE_PROFIT_MARKET,STOP_MARKET,TRAILING_STOP_MARKET",
        //         "supportPositionType": "CROSSED,ISOLATED",
        //         "minQty": "1",
        //         "minNotional": "5",
        //         "maxNotional": "20000000",
        //         "multiplierDown": "0.1",
        //         "multiplierUp": "0.1",
        //         "maxOpenOrders": 200,
        //         "maxEntrusts": 200,
        //         "makerFee": "0.0004",
        //         "takerFee": "0.0006",
        //         "liquidationFee": "0.01",
        //         "marketTakeBound": "0.1",
        //         "depthPrecisionMerge": 5,
        //         "labels": ["HOT"],
        //         "onboardDate": 1657101601000,
        //         "enName": "XTUSDT ",
        //         "cnName": "XTUSDT",
        //         "minStepPrice": "0.0001",
        //         "minPrice": null,
        //         "maxPrice": null,
        //         "deliveryDate": 1669879634000,
        //         "deliveryPrice": null,
        //         "deliveryCompletion": false,
        //         "cnDesc": null,
        //         "enDesc": null
        //     }
        //
        object id = this.safeString(market, "symbol");
        object baseId = this.safeString2(market, "baseCurrency", "baseCoin");
        object quoteId = this.safeString2(market, "quoteCurrency", "quoteCoin");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object state = this.safeString(market, "state");
        object symbol = add(add(bs, "/"), quote);
        object filters = this.safeValue(market, "filters", new List<object>() {});
        object minAmount = null;
        object maxAmount = null;
        object minCost = null;
        object maxCost = null;
        object minPrice = null;
        object maxPrice = null;
        object amountPrecision = null;
        for (object i = 0; isLessThan(i, getArrayLength(filters)); postFixIncrement(ref i))
        {
            object entry = getValue(filters, i);
            object filter = this.safeString(entry, "filter");
            if (isTrue(isEqual(filter, "QUANTITY")))
            {
                minAmount = this.safeNumber(entry, "min");
                maxAmount = this.safeNumber(entry, "max");
                amountPrecision = this.safeNumber(entry, "tickSize");
            }
            if (isTrue(isEqual(filter, "QUOTE_QTY")))
            {
                minCost = this.safeNumber(entry, "min");
            }
            if (isTrue(isEqual(filter, "PRICE")))
            {
                minPrice = this.safeNumber(entry, "min");
                maxPrice = this.safeNumber(entry, "max");
            }
        }
        if (isTrue(isEqual(amountPrecision, null)))
        {
            amountPrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "quantityPrecision")));
        }
        object underlyingType = this.safeString(market, "underlyingType");
        object linear = null;
        object inverse = null;
        object settleId = null;
        object settle = null;
        object expiry = null;
        object future = false;
        object swap = false;
        object contract = false;
        object spot = true;
        object type = "spot";
        if (isTrue(isEqual(underlyingType, "U_BASED")))
        {
            symbol = add(add(symbol, ":"), quote);
            settleId = baseId;
            settle = quote;
            linear = true;
            inverse = false;
        } else if (isTrue(isEqual(underlyingType, "COIN_BASED")))
        {
            symbol = add(add(symbol, ":"), bs);
            settleId = baseId;
            settle = bs;
            linear = false;
            inverse = true;
        }
        if (isTrue(!isEqual(underlyingType, null)))
        {
            expiry = this.safeInteger(market, "deliveryDate");
            object productType = this.safeString(market, "productType");
            if (isTrue(!isEqual(productType, "perpetual")))
            {
                symbol = add(add(symbol, "-"), this.yymmdd(expiry));
                type = "future";
                future = true;
            } else
            {
                type = "swap";
                swap = true;
            }
            minAmount = this.safeNumber(market, "minQty");
            minCost = this.safeNumber(market, "minNotional");
            maxCost = this.safeNumber(market, "maxNotional");
            minPrice = this.safeNumber(market, "minPrice");
            maxPrice = this.safeNumber(market, "maxPrice");
            contract = true;
            spot = false;
        }
        object isActive = false;
        if (isTrue(contract))
        {
            isActive = this.safeValue(market, "isOpenApi", false);
        } else
        {
            if (isTrue(isTrue(isTrue((isEqual(state, "ONLINE"))) && isTrue((this.safeValue(market, "tradingEnabled")))) && isTrue((this.safeValue(market, "openapiEnabled")))))
            {
                isActive = true;
            }
        }
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", id },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", type },
            { "spot", spot },
            { "margin", null },
            { "swap", swap },
            { "future", future },
            { "option", false },
            { "active", isActive },
            { "contract", contract },
            { "linear", linear },
            { "inverse", inverse },
            { "taker", this.safeNumber(market, "takerFee") },
            { "maker", this.safeNumber(market, "makerFee") },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "expiry", expiry },
            { "expiryDatetime", this.iso8601(expiry) },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "pricePrecision"))) },
                { "amount", amountPrecision },
                { "base", this.parseNumber(this.parsePrecision(this.safeString(market, "baseCoinPrecision"))) },
                { "quote", this.parseNumber(this.parsePrecision(this.safeString(market, "quoteCoinPrecision"))) },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", this.parseNumber("1") },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", minAmount },
                    { "max", maxAmount },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", minPrice },
                    { "max", maxPrice },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", minCost },
                    { "max", maxCost },
                } },
            } },
            { "info", market },
        });
    }

    /**
     * @method
     * @name xt#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://doc.xt.com/#market4kline
     * @see https://doc.xt.com/#futures_quotesgetKLine
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} params extra parameters specific to the xt api endpoint
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate", false);
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, 1000);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "interval", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        } else
        {
            ((IDictionary<string,object>)request)["limit"] = 1000;
        }
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, new List<object>() {"until"});
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = null;
        if (isTrue(getValue(market, "linear")))
        {
            response = await this.publicLinearGetFutureMarketV1PublicQKline(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "inverse")))
        {
            response = await this.publicInverseGetFutureMarketV1PublicQKline(this.extend(request, parameters));
        } else
        {
            response = await this.publicSpotGetKline(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": [
        //             {
        //                 "t": 1678167720000,
        //                 "o": "22467.85",
        //                 "c": "22465.87",
        //                 "h": "22468.86",
        //                 "l": "22465.21",
        //                 "q": "1.316656",
        //                 "v": "29582.73018498"
        //             },
        //         ]
        //     }
        //
        // swap and future
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": [
        //             {
        //                 "s": "btc_usdt",
        //                 "p": "btc_usdt",
        //                 "t": 1678168020000,
        //                 "o": "22450.0",
        //                 "c": "22441.5",
        //                 "h": "22450.0",
        //                 "l": "22441.5",
        //                 "a": "312931",
        //                 "v": "702461.58895"
        //             },
        //         ]
        //     }
        //
        object ohlcvs = this.safeValue(response, "result", new List<object>() {});
        return this.parseOHLCVs(ohlcvs, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        // spot
        //
        //     {
        //         "t": 1678167720000,
        //         "o": "22467.85",
        //         "c": "22465.87",
        //         "h": "22468.86",
        //         "l": "22465.21",
        //         "q": "1.316656",
        //         "v": "29582.73018498"
        //     }
        //
        // swap and future
        //
        //     {
        //         "s": "btc_usdt",
        //         "p": "btc_usdt",
        //         "t": 1678168020000,
        //         "o": "22450.0",
        //         "c": "22441.5",
        //         "h": "22450.0",
        //         "l": "22441.5",
        //         "a": "312931",
        //         "v": "702461.58895"
        //     }
        //
        object volumeIndex = ((bool) isTrue((getValue(market, "inverse")))) ? "v" : "a";
        return new List<object> {this.safeInteger(ohlcv, "t"), this.safeNumber(ohlcv, "o"), this.safeNumber(ohlcv, "h"), this.safeNumber(ohlcv, "l"), this.safeNumber(ohlcv, "c"), this.safeNumber2(ohlcv, "q", volumeIndex)};
    }

    /**
     * @method
     * @name xt#fetchOrderBook
     * @see https://doc.xt.com/#market3depth
     * @see https://doc.xt.com/#futures_quotesgetDepth
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @param {string} symbol unified market symbol to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 500);
            }
            response = await this.publicSpotGetDepth(this.extend(request, parameters));
        } else
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["level"] = mathMin(limit, 50);
            } else
            {
                ((IDictionary<string,object>)request)["level"] = 50;
            }
            if (isTrue(getValue(market, "linear")))
            {
                response = await this.publicLinearGetFutureMarketV1PublicQDepth(this.extend(request, parameters));
            } else if (isTrue(getValue(market, "inverse")))
            {
                response = await this.publicInverseGetFutureMarketV1PublicQDepth(this.extend(request, parameters));
            }
        }
        //
        // spot
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": {
        //             "timestamp": 1678169975184,
        //             "lastUpdateId": 1675333221812,
        //             "bids": [
        //                 ["22444.51", "0.129887"],
        //                 ["22444.49", "0.114245"],
        //                 ["22444.30", "0.225956"]
        //             ],
        //             "asks": [
        //                 ["22446.19", "0.095330"],
        //                 ["22446.24", "0.224413"],
        //                 ["22446.28", "0.329095"]
        //             ]
        //         }
        //     }
        //
        // swap and future
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": {
        //             "t": 1678170311005,
        //             "s": "btc_usdt",
        //             "u": 471694545627,
        //             "b": [
        //                 ["22426", "198623"],
        //                 ["22423.5", "80295"],
        //                 ["22423", "163580"]
        //             ],
        //             "a": [
        //                 ["22427", "3417"],
        //                 ["22428.5", "43532"],
        //                 ["22429", "119"]
        //             ]
        //         }
        //     }
        //
        object orderBook = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger2(orderBook, "timestamp", "t");
        if (isTrue(getValue(market, "spot")))
        {
            object ob = this.parseOrderBook(orderBook, symbol, timestamp);
            ((IDictionary<string,object>)ob)["nonce"] = this.safeInteger(orderBook, "lastUpdateId");
            return ob;
        }
        object swapOb = this.parseOrderBook(orderBook, symbol, timestamp, "b", "a");
        ((IDictionary<string,object>)swapOb)["nonce"] = this.safeInteger2(orderBook, "u", "lastUpdateId");
        return swapOb;
    }

    /**
     * @method
     * @name xt#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://doc.xt.com/#market10ticker24h
     * @see https://doc.xt.com/#futures_quotesgetAggTicker
     * @param {string} symbol unified market symbol to fetch the ticker for
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "linear")))
        {
            response = await this.publicLinearGetFutureMarketV1PublicQAggTicker(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "inverse")))
        {
            response = await this.publicInverseGetFutureMarketV1PublicQAggTicker(this.extend(request, parameters));
        } else
        {
            response = await this.publicSpotGetTicker24h(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": [
        //             {
        //                 "s": "btc_usdt",
        //                 "t": 1678172693931,
        //                 "cv": "34.00",
        //                 "cr": "0.0015",
        //                 "o": "22398.05",
        //                 "l": "22323.72",
        //                 "h": "22600.50",
        //                 "c": "22432.05",
        //                 "q": "7962.256931",
        //                 "v": "178675209.47416856"
        //             }
        //         ]
        //     }
        //
        // swap and future
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": {
        //             "t": 1678172848572,
        //             "s": "btc_usdt",
        //             "c": "22415.5",
        //             "h": "22590.0",
        //             "l": "22310.0",
        //             "a": "623654031",
        //             "v": "1399166074.31675",
        //             "o": "22381.5",
        //             "r": "0.0015",
        //             "i": "22424.5",
        //             "m": "22416.5",
        //             "bp": "22415",
        //             "ap": "22415.5"
        //         }
        //     }
        //
        object ticker = this.safeValue(response, "result");
        if (isTrue(getValue(market, "spot")))
        {
            return this.parseTicker(getValue(ticker, 0), market);
        }
        return this.parseTicker(ticker, market);
    }

    /**
     * @method
     * @name xt#fetchTickers
     * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
     * @see https://doc.xt.com/#market10ticker24h
     * @see https://doc.xt.com/#futures_quotesgetAggTickers
     * @param {string} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object} an array of [ticker structures]{@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            symbols = this.marketSymbols(symbols);
            market = this.market(getValue(symbols, 0));
        }
        object request = new Dictionary<string, object>() {};
        object type = null;
        object subType = null;
        object response = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchTickers", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.publicInverseGetFutureMarketV1PublicQAggTickers(this.extend(request, parameters));
        } else if (isTrue(isTrue(isTrue((isEqual(subType, "linear"))) || isTrue((isEqual(type, "swap")))) || isTrue((isEqual(type, "future")))))
        {
            response = await this.publicLinearGetFutureMarketV1PublicQAggTickers(this.extend(request, parameters));
        } else
        {
            response = await this.publicSpotGetTicker24h(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": [
        //             {
        //                 "s": "btc_usdt",
        //                 "t": 1678172693931,
        //                 "cv": "34.00",
        //                 "cr": "0.0015",
        //                 "o": "22398.05",
        //                 "l": "22323.72",
        //                 "h": "22600.50",
        //                 "c": "22432.05",
        //                 "q": "7962.256931",
        //                 "v": "178675209.47416856"
        //             }
        //         ]
        //     }
        //
        // swap and future
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": [
        //             {
        //                 "t": 1680738775108,
        //                 "s": "badger_usdt",
        //                 "c": "2.7176",
        //                 "h": "2.7917",
        //                 "l": "2.6818",
        //                 "a": "88332",
        //                 "v": "242286.3520",
        //                 "o": "2.7422",
        //                 "r": "-0.0089",
        //                 "i": "2.7155",
        //                 "m": "2.7161",
        //                 "bp": "2.7152",
        //                 "ap": "2.7176"
        //             },
        //         ]
        //     }
        //
        object tickers = this.safeValue(response, "result", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(tickers)); postFixIncrement(ref i))
        {
            object ticker = this.parseTicker(getValue(tickers, i), market);
            object symbol = getValue(ticker, "symbol");
            ((IDictionary<string,object>)result)[(string)symbol] = ticker;
        }
        return this.filterByArray(result, "symbol", symbols);
    }

    /**
     * @method
     * @name xt#fetchBidsAsks
     * @description fetches the bid and ask price and volume for multiple markets
     * @see https://doc.xt.com/#market9tickerBook
     * @param {string} [symbols] unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure}
     */
    public async override Task<object> fetchBidsAsks(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            market = this.market(getValue(symbols, 0));
        }
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchBidsAsks", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(!isEqual(subType, null)))
        {
            throw new NotSupported ((string)add(this.id, " fetchBidsAsks() is not available for swap and future markets, only spot markets are supported")) ;
        }
        object response = await this.publicSpotGetTickerBook(this.extend(request, parameters));
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": [
        //             {
        //                 "s": "kas_usdt",
        //                 "t": 1679539891853,
        //                 "ap": "0.016298",
        //                 "aq": "5119.09",
        //                 "bp": "0.016290",
        //                 "bq": "135.37"
        //             },
        //         ]
        //     }
        //
        object tickers = this.safeValue(response, "result", new List<object>() {});
        return this.parseTickers(tickers, symbols);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // spot: fetchTicker, fetchTickers
        //
        //     {
        //         "s": "btc_usdt",
        //         "t": 1678172693931,
        //         "cv": "34.00",
        //         "cr": "0.0015",
        //         "o": "22398.05",
        //         "l": "22323.72",
        //         "h": "22600.50",
        //         "c": "22432.05",
        //         "q": "7962.256931",
        //         "v": "178675209.47416856"
        //     }
        //
        // swap and future: fetchTicker, fetchTickers
        //
        //     {
        //         "t": 1678172848572,
        //         "s": "btc_usdt",
        //         "c": "22415.5",
        //         "h": "22590.0",
        //         "l": "22310.0",
        //         "a": "623654031",
        //         "v": "1399166074.31675",
        //         "o": "22381.5",
        //         "r": "0.0015",
        //         "i": "22424.5",
        //         "m": "22416.5",
        //         "bp": "22415",
        //         "ap": "22415.5"
        //     }
        //
        // fetchBidsAsks
        //
        //     {
        //         "s": "kas_usdt",
        //         "t": 1679539891853,
        //         "ap": "0.016298",
        //         "aq": "5119.09",
        //         "bp": "0.016290",
        //         "bq": "135.37"
        //     }
        //
        object marketId = this.safeString(ticker, "s");
        object marketType = ((bool) isTrue((!isEqual(market, null)))) ? getValue(market, "type") : null;
        object hasSpotKeys = isTrue((inOp(ticker, "cv"))) || isTrue((inOp(ticker, "aq")));
        if (isTrue(isEqual(marketType, null)))
        {
            marketType = ((bool) isTrue(hasSpotKeys)) ? "spot" : "contract";
        }
        market = this.safeMarket(marketId, market, "_", marketType);
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger(ticker, "t");
        object percentage = this.safeString2(ticker, "cr", "r");
        if (isTrue(!isEqual(percentage, null)))
        {
            percentage = Precise.stringMul(percentage, "100");
        }
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeNumber(ticker, "h") },
            { "low", this.safeNumber(ticker, "l") },
            { "bid", this.safeNumber(ticker, "bp") },
            { "bidVolume", this.safeNumber(ticker, "bq") },
            { "ask", this.safeNumber(ticker, "ap") },
            { "askVolume", this.safeNumber(ticker, "aq") },
            { "vwap", null },
            { "open", this.safeString(ticker, "o") },
            { "close", this.safeString(ticker, "c") },
            { "last", this.safeString(ticker, "c") },
            { "previousClose", null },
            { "change", this.safeNumber(ticker, "cv") },
            { "percentage", this.parseNumber(percentage) },
            { "average", null },
            { "baseVolume", this.safeNumber(ticker, "a") },
            { "quoteVolume", this.safeNumber(ticker, "v") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name xt#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://doc.xt.com/#market5tradeRecent
     * @see https://doc.xt.com/#futures_quotesgetDeal
     * @param {string} symbol unified market symbol to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            response = await this.publicSpotGetTradeRecent(this.extend(request, parameters));
        } else
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["num"] = limit;
            }
            if (isTrue(getValue(market, "linear")))
            {
                response = await this.publicLinearGetFutureMarketV1PublicQDeal(this.extend(request, parameters));
            } else if (isTrue(getValue(market, "inverse")))
            {
                response = await this.publicInverseGetFutureMarketV1PublicQDeal(this.extend(request, parameters));
            }
        }
        //
        // spot
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": [
        //             {
        //                 "i": 203530723141917063,
        //                 "t": 1678227505815,
        //                 "p": "22038.81",
        //                 "q": "0.000978",
        //                 "v": "21.55395618",
        //                 "b": true
        //             },
        //         ]
        //     }
        //
        // swap and future
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": [
        //             {
        //                 "t": 1678227683897,
        //                 "s": "btc_usdt",
        //                 "p": "22031",
        //                 "a": "1067",
        //                 "m": "BID"
        //             },
        //         ]
        //     }
        //
        object trades = this.safeValue(response, "result", new List<object>() {});
        return this.parseTrades(trades, market);
    }

    /**
     * @method
     * @name xt#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://doc.xt.com/#tradetradeGet
     * @see https://doc.xt.com/#futures_ordergetTrades
     * @param {string} [symbol] unified market symbol to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object type = null;
        object subType = null;
        object response = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchMyTrades", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(isTrue(isTrue((!isEqual(subType, null))) || isTrue((isEqual(type, "swap")))) || isTrue((isEqual(type, "future")))))
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["size"] = limit;
            }
            if (isTrue(isEqual(subType, "inverse")))
            {
                response = await this.privateInverseGetFutureTradeV1OrderTradeList(this.extend(request, parameters));
            } else
            {
                response = await this.privateLinearGetFutureTradeV1OrderTradeList(this.extend(request, parameters));
            }
        } else
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchMyTrades", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            object marginOrSpotRequest = ((bool) isTrue((!isEqual(marginMode, null)))) ? "LEVER" : "SPOT";
            ((IDictionary<string,object>)request)["bizType"] = marginOrSpotRequest;
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            response = await this.privateSpotGetTrade(this.extend(request, parameters));
        }
        //
        // spot and margin
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": {
        //             "hasPrev": false,
        //             "hasNext": false,
        //             "items": [
        //                 {
        //                     "symbol": "btc_usdt",
        //                     "tradeId": "206906233569974658",
        //                     "orderId": "206906233178463488",
        //                     "orderSide": "SELL",
        //                     "orderType": "MARKET",
        //                     "bizType": "SPOT",
        //                     "time": 1679032290215,
        //                     "price": "25703.46",
        //                     "quantity": "0.000099",
        //                     "quoteQty": "2.54464254",
        //                     "baseCurrency": "btc",
        //                     "quoteCurrency": "usdt",
        //                     "fee": "0.00508929",
        //                     "feeCurrency": "usdt",
        //                     "takerMaker": "TAKER"
        //                 },
        //             ]
        //         }
        //     }
        //
        // swap and future
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": {
        //             "page": 1,
        //             "ps": 10,
        //             "total": 2,
        //             "items": [
        //                 {
        //                     "orderId": "207260566170987200",
        //                     "execId": "207260566790603265",
        //                     "symbol": "btc_usdt",
        //                     "quantity": "13",
        //                     "price": "27368",
        //                     "fee": "0.02134704",
        //                     "feeCoin": "usdt",
        //                     "timestamp": 1679116769838,
        //                     "takerMaker": "TAKER"
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object trades = this.safeValue(data, "items", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // spot: fetchTrades
        //
        //     {
        //         "i": 203530723141917063,
        //         "t": 1678227505815,
        //         "p": "22038.81",
        //         "q": "0.000978",
        //         "v": "21.55395618",
        //         "b": true
        //     }
        //
        // spot: watchTrades
        //
        //    {
        //        s: 'btc_usdt',
        //        i: '228825383103928709',
        //        t: 1684258222702,
        //        p: '27003.65',
        //        q: '0.000796',
        //        b: true
        //    }
        //
        // spot: watchMyTrades
        //
        //    {
        //        "s": "btc_usdt",                // symbol
        //        "t": 1656043204763,             // time
        //        "i": "6316559590087251233",     // tradeId
        //        "oi": "6216559590087220004",    // orderId
        //        "p": "30000",                   // trade price
        //        "q": "3",                       // qty quantity
        //        "v": "90000"                    // volume trade amount
        //    }
        //
        // swap and future: fetchTrades
        //
        //     {
        //         "t": 1678227683897,
        //         "s": "btc_usdt",
        //         "p": "22031",
        //         "a": "1067",
        //         "m": "BID"
        //     }
        //
        // spot: fetchMyTrades
        //
        //     {
        //         "symbol": "btc_usdt",
        //         "tradeId": "206906233569974658",
        //         "orderId": "206906233178463488",
        //         "orderSide": "SELL",
        //         "orderType": "MARKET",
        //         "bizType": "SPOT",
        //         "time": 1679032290215,
        //         "price": "25703.46",
        //         "quantity": "0.000099",
        //         "quoteQty": "2.54464254",
        //         "baseCurrency": "btc",
        //         "quoteCurrency": "usdt",
        //         "fee": "0.00508929",
        //         "feeCurrency": "usdt",
        //         "takerMaker": "TAKER"
        //     }
        //
        // swap and future: fetchMyTrades
        //
        //     {
        //         "orderId": "207260566170987200",
        //         "execId": "207260566790603265",
        //         "symbol": "btc_usdt",
        //         "quantity": "13",
        //         "price": "27368",
        //         "fee": "0.02134704",
        //         "feeCoin": "usdt",
        //         "timestamp": 1679116769838,
        //         "takerMaker": "TAKER"
        //     }
        //
        // contract watchMyTrades
        //
        //    {
        //        "symbol": 'btc_usdt',
        //        "orderSide": 'SELL',
        //        "positionSide": 'LONG',
        //        "orderId": '231485367663419328',
        //        "price": '27152.7',
        //        "quantity": '33',
        //        "marginUnfrozen": '2.85318000',
        //        "timestamp": 1684892412565
        //    }
        //
        // watchMyTrades (ws, swap)
        //
        //    {
        //        'fee': '0.04080840',
        //        'isMaker': False,
        //        'marginUnfrozen': '0.75711984',
        //        'orderId': '376172779053188416',
        //        'orderSide': 'BUY',
        //        'positionSide': 'LONG',
        //        'price': '3400.70',
        //        'quantity': '2',
        //        'symbol': 'eth_usdt',
        //        'timestamp': 1719388579622
        //    }
        //
        object marketId = this.safeString2(trade, "s", "symbol");
        object marketType = ((bool) isTrue((!isEqual(market, null)))) ? getValue(market, "type") : null;
        object hasSpotKeys = isTrue(isTrue((inOp(trade, "b"))) || isTrue((inOp(trade, "bizType")))) || isTrue((inOp(trade, "oi")));
        if (isTrue(isEqual(marketType, null)))
        {
            marketType = ((bool) isTrue(hasSpotKeys)) ? "spot" : "contract";
        }
        market = this.safeMarket(marketId, market, "_", marketType);
        object side = null;
        object takerOrMaker = null;
        object isBuyerMaker = this.safeBool(trade, "b");
        if (isTrue(!isEqual(isBuyerMaker, null)))
        {
            side = ((bool) isTrue(isBuyerMaker)) ? "sell" : "buy";
            takerOrMaker = "taker"; // public trades always taker
        } else
        {
            object takerMaker = this.safeStringLower(trade, "takerMaker");
            if (isTrue(!isEqual(takerMaker, null)))
            {
                takerOrMaker = takerMaker;
            } else
            {
                object isMaker = this.safeBool(trade, "isMaker");
                if (isTrue(!isEqual(isMaker, null)))
                {
                    takerOrMaker = ((bool) isTrue(isMaker)) ? "maker" : "taker";
                }
            }
            object orderSide = this.safeStringLower(trade, "orderSide");
            if (isTrue(!isEqual(orderSide, null)))
            {
                side = orderSide;
            } else
            {
                object bidOrAsk = this.safeString(trade, "m");
                if (isTrue(!isEqual(bidOrAsk, null)))
                {
                    side = ((bool) isTrue((isEqual(bidOrAsk, "BID")))) ? "buy" : "sell";
                }
            }
        }
        object timestamp = this.safeIntegerN(trade, new List<object>() {"t", "time", "timestamp"});
        object quantity = this.safeString2(trade, "q", "quantity");
        object amount = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            amount = quantity;
        } else
        {
            if (isTrue(isEqual(quantity, null)))
            {
                amount = Precise.stringMul(this.safeString(trade, "a"), this.numberToString(getValue(market, "contractSize")));
            } else
            {
                amount = Precise.stringMul(quantity, this.numberToString(getValue(market, "contractSize")));
            }
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeStringN(trade, new List<object>() {"i", "tradeId", "execId"}) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "order", this.safeString2(trade, "orderId", "oi") },
            { "type", this.safeStringLower(trade, "orderType") },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", this.safeString2(trade, "p", "price") },
            { "amount", amount },
            { "cost", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(this.safeString2(trade, "feeCurrency", "feeCoin")) },
                { "cost", this.safeString(trade, "fee") },
            } },
        }, market);
    }

    /**
     * @method
     * @name xt#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://doc.xt.com/#balancebalancesGet
     * @see https://doc.xt.com/#futures_usergetBalances
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
        object subType = null;
        object response = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchBalance", null, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object isContractWallet = (isTrue((isEqual(type, "swap"))) || isTrue((isEqual(type, "future"))));
        if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.privateInverseGetFutureUserV1BalanceList(parameters);
        } else if (isTrue(isTrue((isEqual(subType, "linear"))) || isTrue(isContractWallet)))
        {
            response = await this.privateLinearGetFutureUserV1BalanceList(parameters);
        } else
        {
            response = await this.privateSpotGetBalances(parameters);
        }
        //
        // spot
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": {
        //             "totalUsdtAmount": "31.75931133",
        //             "totalBtcAmount": "0.00115951",
        //             "assets": [
        //                 {
        //                     "currency": "usdt",
        //                     "currencyId": 11,
        //                     "frozenAmount": "0.03834082",
        //                     "availableAmount": "31.70995965",
        //                     "totalAmount": "31.74830047",
        //                     "convertBtcAmount": "0.00115911",
        //                     "convertUsdtAmount": "31.74830047"
        //                 },
        //             ]
        //         }
        //     }
        //
        // swap and future
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": [
        //             {
        //                 "coin": "usdt",
        //                 "walletBalance": "19.29849875",
        //                 "openOrderMarginFrozen": "0",
        //                 "isolatedMargin": "0.709475",
        //                 "crossedMargin": "0",
        //                 "availableBalance": "18.58902375",
        //                 "bonus": "0",
        //                 "coupon":"0"
        //             }
        //         ]
        //     }
        //
        object balances = null;
        if (isTrue(isTrue((!isEqual(subType, null))) || isTrue(isContractWallet)))
        {
            balances = this.safeValue(response, "result", new List<object>() {});
        } else
        {
            object data = this.safeValue(response, "result", new Dictionary<string, object>() {});
            balances = this.safeValue(data, "assets", new List<object>() {});
        }
        return this.parseBalance(balances);
    }

    public override object parseBalance(object response)
    {
        //
        // spot
        //
        //     {
        //         "currency": "usdt",
        //         "currencyId": 11,
        //         "frozenAmount": "0.03834082",
        //         "availableAmount": "31.70995965",
        //         "totalAmount": "31.74830047",
        //         "convertBtcAmount": "0.00115911",
        //         "convertUsdtAmount": "31.74830047"
        //     }
        //
        // swap and future
        //
        //     {
        //         "coin": "usdt",
        //         "walletBalance": "19.29849875",
        //         "openOrderMarginFrozen": "0",
        //         "isolatedMargin": "0.709475",
        //         "crossedMargin": "0",
        //         "availableBalance": "18.58902375",
        //         "bonus": "0",
        //         "coupon":"0"
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object balance = getValue(response, i);
            object currencyId = this.safeString2(balance, "currency", "coin");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            object free = this.safeString2(balance, "availableAmount", "availableBalance");
            object used = this.safeString(balance, "frozenAmount");
            object total = this.safeString2(balance, "totalAmount", "walletBalance");
            if (isTrue(isEqual(used, null)))
            {
                object crossedAndIsolatedMargin = Precise.stringAdd(this.safeString(balance, "crossedMargin"), this.safeString(balance, "isolatedMargin"));
                used = Precise.stringAdd(this.safeString(balance, "openOrderMarginFrozen"), crossedAndIsolatedMargin);
            }
            ((IDictionary<string,object>)account)["free"] = free;
            ((IDictionary<string,object>)account)["used"] = used;
            ((IDictionary<string,object>)account)["total"] = total;
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name xt#createMarketBuyOrderWithCost
     * @see https://doc.xt.com/#orderorderPost
     * @description create a market buy order by providing the symbol and cost
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
        }
        return await this.createOrder(symbol, "market", "buy", cost, 1, parameters);
    }

    /**
     * @method
     * @name xt#createOrder
     * @description create a trade order
     * @see https://doc.xt.com/#orderorderPost
     * @see https://doc.xt.com/#futures_ordercreate
     * @see https://doc.xt.com/#futures_entrustcreatePlan
     * @see https://doc.xt.com/#futures_entrustcreateProfit
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency
     * @param {float} [price] the price to fulfill the order, in units of the quote currency, can be ignored in market orders
     * @param {object} params extra parameters specific to the xt api endpoint
     * @param {string} [params.timeInForce] 'GTC', 'IOC', 'FOK' or 'GTX'
     * @param {string} [params.entrustType] 'TAKE_PROFIT', 'STOP', 'TAKE_PROFIT_MARKET', 'STOP_MARKET', 'TRAILING_STOP_MARKET', required if stopPrice is defined, currently isn't functioning on xt's side
     * @param {string} [params.triggerPriceType] 'INDEX_PRICE', 'MARK_PRICE', 'LATEST_PRICE', required if stopPrice is defined
     * @param {float} [params.triggerPrice] price to trigger a stop order
     * @param {float} [params.stopPrice] alias for triggerPrice
     * @param {float} [params.stopLoss] price to set a stop-loss on an open position
     * @param {float} [params.takeProfit] price to set a take-profit on an open position
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        if (isTrue(getValue(market, "spot")))
        {
            return await this.createSpotOrder(symbol, type, side, amount, price, parameters);
        } else
        {
            return await this.createContractOrder(symbol, type, side, amount, price, parameters);
        }
    }

    public async virtual Task<object> createSpotOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", ((string)side).ToUpper() },
            { "type", ((string)type).ToUpper() },
        };
        object timeInForce = null;
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object marginOrSpotRequest = ((bool) isTrue((!isEqual(marginMode, null)))) ? "LEVER" : "SPOT";
        ((IDictionary<string,object>)request)["bizType"] = marginOrSpotRequest;
        if (isTrue(isEqual(type, "market")))
        {
            timeInForce = this.safeStringUpper(parameters, "timeInForce", "FOK");
            if (isTrue(isEqual(side, "buy")))
            {
                object cost = this.safeString(parameters, "cost");
                parameters = this.omit(parameters, "cost");
                object createMarketBuyOrderRequiresPrice = this.safeBool(this.options, "createMarketBuyOrderRequiresPrice", true);
                if (isTrue(createMarketBuyOrderRequiresPrice))
                {
                    if (isTrue(isTrue(isEqual(price, null)) && isTrue((isEqual(cost, null)))))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() requires a price argument or cost in params for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option to false and pass in the cost to spend into the amount parameter")) ;
                    } else
                    {
                        object amountString = this.numberToString(amount);
                        object priceString = this.numberToString(price);
                        object costCalculated = null;
                        if (isTrue(!isEqual(price, null)))
                        {
                            costCalculated = Precise.stringMul(amountString, priceString);
                        } else
                        {
                            costCalculated = cost;
                        }
                        ((IDictionary<string,object>)request)["quoteQty"] = this.costToPrecision(symbol, costCalculated);
                    }
                } else
                {
                    object amountCost = ((bool) isTrue((!isEqual(cost, null)))) ? cost : amount;
                    ((IDictionary<string,object>)request)["quoteQty"] = this.costToPrecision(symbol, amountCost);
                }
            }
        } else
        {
            timeInForce = this.safeStringUpper(parameters, "timeInForce", "GTC");
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(isTrue((isEqual(side, "sell"))) || isTrue((isEqual(type, "limit")))))
        {
            ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
        }
        ((IDictionary<string,object>)request)["timeInForce"] = timeInForce;
        object response = await this.privateSpotPostOrder(this.extend(request, parameters));
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": {
        //             "orderId": "204371980095156544"
        //         }
        //     }
        //
        object order = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(order, market);
    }

    public async virtual Task<object> createContractOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "origQty", this.amountToPrecision(symbol, amount) },
        };
        object timeInForce = this.safeStringUpper(parameters, "timeInForce");
        if (isTrue(!isEqual(timeInForce, null)))
        {
            ((IDictionary<string,object>)request)["timeInForce"] = timeInForce;
        }
        object reduceOnly = this.safeValue(parameters, "reduceOnly", false);
        if (isTrue(isEqual(side, "buy")))
        {
            object requestType = ((bool) isTrue((reduceOnly))) ? "SHORT" : "LONG";
            ((IDictionary<string,object>)request)["positionSide"] = requestType;
        } else
        {
            object requestType = ((bool) isTrue((reduceOnly))) ? "LONG" : "SHORT";
            ((IDictionary<string,object>)request)["positionSide"] = requestType;
        }
        object response = null;
        object triggerPrice = this.safeNumber2(parameters, "triggerPrice", "stopPrice");
        object stopLoss = this.safeNumber2(parameters, "stopLoss", "triggerStopPrice");
        object takeProfit = this.safeNumber2(parameters, "takeProfit", "triggerProfitPrice");
        object isTrigger = (!isEqual(triggerPrice, null));
        object isStopLoss = (!isEqual(stopLoss, null));
        object isTakeProfit = (!isEqual(takeProfit, null));
        if (isTrue(!isEqual(price, null)))
        {
            if (isTrue(!isTrue((isStopLoss)) && !isTrue((isTakeProfit))))
            {
                ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            }
        }
        if (isTrue(isTrigger))
        {
            ((IDictionary<string,object>)request)["timeInForce"] = this.safeStringUpper(parameters, "timeInForce", "GTC");
            ((IDictionary<string,object>)request)["triggerPriceType"] = this.safeString(parameters, "triggerPriceType", "LATEST_PRICE");
            ((IDictionary<string,object>)request)["orderSide"] = ((string)side).ToUpper();
            ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, triggerPrice);
            object entrustType = ((bool) isTrue((isEqual(type, "market")))) ? "STOP_MARKET" : "STOP";
            ((IDictionary<string,object>)request)["entrustType"] = entrustType;
            parameters = this.omit(parameters, "triggerPrice");
            if (isTrue(getValue(market, "linear")))
            {
                response = await this.privateLinearPostFutureTradeV1EntrustCreatePlan(this.extend(request, parameters));
            } else if (isTrue(getValue(market, "inverse")))
            {
                response = await this.privateInversePostFutureTradeV1EntrustCreatePlan(this.extend(request, parameters));
            }
        } else if (isTrue(isTrue(isStopLoss) || isTrue(isTakeProfit)))
        {
            if (isTrue(isStopLoss))
            {
                ((IDictionary<string,object>)request)["triggerStopPrice"] = this.priceToPrecision(symbol, stopLoss);
            } else
            {
                ((IDictionary<string,object>)request)["triggerProfitPrice"] = this.priceToPrecision(symbol, takeProfit);
            }
            parameters = this.omit(parameters, new List<object>() {"stopLoss", "takeProfit"});
            if (isTrue(getValue(market, "linear")))
            {
                response = await this.privateLinearPostFutureTradeV1EntrustCreateProfit(this.extend(request, parameters));
            } else if (isTrue(getValue(market, "inverse")))
            {
                response = await this.privateInversePostFutureTradeV1EntrustCreateProfit(this.extend(request, parameters));
            }
        } else
        {
            ((IDictionary<string,object>)request)["orderSide"] = ((string)side).ToUpper();
            ((IDictionary<string,object>)request)["orderType"] = ((string)type).ToUpper();
            if (isTrue(getValue(market, "linear")))
            {
                response = await this.privateLinearPostFutureTradeV1OrderCreate(this.extend(request, parameters));
            } else if (isTrue(getValue(market, "inverse")))
            {
                response = await this.privateInversePostFutureTradeV1OrderCreate(this.extend(request, parameters));
            }
        }
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": "206410760006650176"
        //     }
        //
        return this.parseOrder(response, market);
    }

    /**
     * @method
     * @name xt#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://doc.xt.com/#orderorderGet
     * @see https://doc.xt.com/#futures_ordergetById
     * @see https://doc.xt.com/#futures_entrustgetPlanById
     * @see https://doc.xt.com/#futures_entrustgetProfitById
     * @param {string} id order id
     * @param {string} [symbol] unified symbol of the market the order was made in
     * @param {object} params extra parameters specific to the xt api endpoint
     * @param {bool} [params.trigger] if the order is a trigger order or not
     * @param {bool} [params.stopLossTakeProfit] if the order is a stop-loss or take-profit order
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        object type = null;
        object subType = null;
        object response = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchOrder", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchOrder", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object trigger = this.safeValue(parameters, "stop");
        object stopLossTakeProfit = this.safeValue(parameters, "stopLossTakeProfit");
        if (isTrue(trigger))
        {
            ((IDictionary<string,object>)request)["entrustId"] = id;
        } else if (isTrue(stopLossTakeProfit))
        {
            ((IDictionary<string,object>)request)["profitId"] = id;
        } else
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        if (isTrue(trigger))
        {
            parameters = this.omit(parameters, "stop");
            if (isTrue(isEqual(subType, "inverse")))
            {
                response = await this.privateInverseGetFutureTradeV1EntrustPlanDetail(this.extend(request, parameters));
            } else
            {
                response = await this.privateLinearGetFutureTradeV1EntrustPlanDetail(this.extend(request, parameters));
            }
        } else if (isTrue(stopLossTakeProfit))
        {
            parameters = this.omit(parameters, "stopLossTakeProfit");
            if (isTrue(isEqual(subType, "inverse")))
            {
                response = await this.privateInverseGetFutureTradeV1EntrustProfitDetail(this.extend(request, parameters));
            } else
            {
                response = await this.privateLinearGetFutureTradeV1EntrustProfitDetail(this.extend(request, parameters));
            }
        } else if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.privateInverseGetFutureTradeV1OrderDetail(this.extend(request, parameters));
        } else if (isTrue(isTrue(isTrue((isEqual(subType, "linear"))) || isTrue((isEqual(type, "swap")))) || isTrue((isEqual(type, "future")))))
        {
            response = await this.privateLinearGetFutureTradeV1OrderDetail(this.extend(request, parameters));
        } else
        {
            response = await this.privateSpotGetOrderOrderId(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": {
        //             "symbol": "btc_usdt",
        //             "orderId": "207505997850909952",
        //             "clientOrderId": null,
        //             "baseCurrency": "btc",
        //             "quoteCurrency": "usdt",
        //             "side": "BUY",
        //             "type": "LIMIT",
        //             "timeInForce": "GTC",
        //             "price": "20000.00",
        //             "origQty": "0.001000",
        //             "origQuoteQty": "20.00",
        //             "executedQty": "0.000000",
        //             "leavingQty": "0.001000",
        //             "tradeBase": "0.000000",
        //             "tradeQuote": "0.00",
        //             "avgPrice": null,
        //             "fee": null,
        //             "feeCurrency": null,
        //             "closed": false,
        //             "state": "NEW",
        //             "time": 1679175285162,
        //             "updatedTime": 1679175285255
        //         }
        //     }
        //
        // swap and future
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": {
        //             "orderId": "211451874783183936",
        //             "clientOrderId": null,
        //             "symbol": "btc_usdt",
        //             "orderType": "LIMIT",
        //             "orderSide": "BUY",
        //             "positionSide": "LONG",
        //             "timeInForce": "GTC",
        //             "closePosition": false,
        //             "price": "20000",
        //             "origQty": "10",
        //             "avgPrice": "0",
        //             "executedQty": "0",
        //             "marginFrozen": "1.34533334",
        //             "remark": null,
        //             "triggerProfitPrice": null,
        //             "triggerStopPrice": null,
        //             "sourceId": null,
        //             "sourceType": "DEFAULT",
        //             "forceClose": false,
        //             "closeProfit": null,
        //             "state": "NEW",
        //             "createdTime": 1680116055693,
        //             "updatedTime": 1680116055693
        //         }
        //     }
        //
        // trigger
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": {
        //             "entrustId": "216300248132756992",
        //             "symbol": "btc_usdt",
        //             "entrustType": "STOP",
        //             "orderSide": "SELL",
        //             "positionSide": "SHORT",
        //             "timeInForce": "GTC",
        //             "closePosition": null,
        //             "price": "20000",
        //             "origQty": "1",
        //             "stopPrice": "19000",
        //             "triggerPriceType": "LATEST_PRICE",
        //             "state": "NOT_TRIGGERED",
        //             "marketOrderLevel": null,
        //             "createdTime": 1681271998064,
        //             "updatedTime": 1681271998064,
        //             "ordinary": false
        //         }
        //     }
        //
        // stop-loss and take-profit
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": {
        //             "profitId": "216306213226230400",
        //             "symbol": "btc_usdt",
        //             "positionSide": "LONG",
        //             "origQty": "1",
        //             "triggerPriceType": "LATEST_PRICE",
        //             "triggerProfitPrice": null,
        //             "triggerStopPrice": "20000",
        //             "entryPrice": null,
        //             "positionSize": null,
        //             "isolatedMargin": null,
        //             "executedQty": null,
        //             "avgPrice": null,
        //             "positionType": "ISOLATED",
        //             "state": "NOT_TRIGGERED",
        //             "createdTime": 1681273420039
        //         }
        //     }
        //
        object order = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(order, market);
    }

    /**
     * @method
     * @name xt#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @see https://doc.xt.com/#orderhistoryOrderGet
     * @see https://doc.xt.com/#futures_ordergetHistory
     * @see https://doc.xt.com/#futures_entrustgetPlanHistory
     * @param {string} [symbol] unified market symbol of the market the orders were made in
     * @param {int} [since] timestamp in ms of the earliest order
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} params extra parameters specific to the xt api endpoint
     * @param {bool} [params.trigger] if the order is a trigger order or not
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object type = null;
        object subType = null;
        object response = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchOrders", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object trigger = this.safeValue2(parameters, "trigger", "stop");
        if (isTrue(trigger))
        {
            parameters = this.omit(parameters, new List<object>() {"trigger", "stop"});
            if (isTrue(isEqual(subType, "inverse")))
            {
                response = await this.privateInverseGetFutureTradeV1EntrustPlanListHistory(this.extend(request, parameters));
            } else
            {
                response = await this.privateLinearGetFutureTradeV1EntrustPlanListHistory(this.extend(request, parameters));
            }
        } else if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.privateInverseGetFutureTradeV1OrderListHistory(this.extend(request, parameters));
        } else if (isTrue(isTrue(isTrue((isEqual(subType, "linear"))) || isTrue((isEqual(type, "swap")))) || isTrue((isEqual(type, "future")))))
        {
            response = await this.privateLinearGetFutureTradeV1OrderListHistory(this.extend(request, parameters));
        } else
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOrders", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            object marginOrSpotRequest = ((bool) isTrue((!isEqual(marginMode, null)))) ? "LEVER" : "SPOT";
            ((IDictionary<string,object>)request)["bizType"] = marginOrSpotRequest;
            response = await this.privateSpotGetHistoryOrder(this.extend(request, parameters));
        }
        //
        //  spot and margin
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": {
        //             "hasPrev": false,
        //             "hasNext": true,
        //             "items": [
        //                 {
        //                     "symbol": "btc_usdt",
        //                     "orderId": "207505997850909952",
        //                     "clientOrderId": null,
        //                     "baseCurrency": "btc",
        //                     "quoteCurrency": "usdt",
        //                     "side": "BUY",
        //                     "type": "LIMIT",
        //                     "timeInForce": "GTC",
        //                     "price": "20000.00",
        //                     "origQty": "0.001000",
        //                     "origQuoteQty": "20.00",
        //                     "executedQty": "0.000000",
        //                     "leavingQty": "0.000000",
        //                     "tradeBase": "0.000000",
        //                     "tradeQuote": "0.00",
        //                     "avgPrice": null,
        //                     "fee": null,
        //                     "feeCurrency": null,
        //                     "closed": true,
        //                     "state": "CANCELED",
        //                     "time": 1679175285162,
        //                     "updatedTime": 1679175488492
        //                 },
        //             ]
        //         }
        //     }
        //
        // swap and future
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": {
        //             "hasPrev": false,
        //             "hasNext": true,
        //             "items": [
        //                 {
        //                     "orderId": "207519546930995456",
        //                     "clientOrderId": null,
        //                     "symbol": "btc_usdt",
        //                     "orderType": "LIMIT",
        //                     "orderSide": "BUY",
        //                     "positionSide": "LONG",
        //                     "timeInForce": "GTC",
        //                     "closePosition": false,
        //                     "price": "20000",
        //                     "origQty": "100",
        //                     "avgPrice": "0",
        //                     "executedQty": "0",
        //                     "marginFrozen": "4.12",
        //                     "remark": null,
        //                     "triggerProfitPrice": null,
        //                     "triggerStopPrice": null,
        //                     "sourceId": null,
        //                     "sourceType": "DEFAULT",
        //                     "forceClose": false,
        //                     "closeProfit": null,
        //                     "state": "CANCELED",
        //                     "createdTime": 1679178515689,
        //                     "updatedTime": 1679180096172
        //                 },
        //             ]
        //         }
        //     }
        //
        // stop
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": {
        //             "hasPrev": false,
        //             "hasNext": false,
        //             "items": [
        //                 {
        //                     "entrustId": "216300248132756992",
        //                     "symbol": "btc_usdt",
        //                     "entrustType": "STOP",
        //                     "orderSide": "SELL",
        //                     "positionSide": "SHORT",
        //                     "timeInForce": "GTC",
        //                     "closePosition": null,
        //                     "price": "20000",
        //                     "origQty": "1",
        //                     "stopPrice": "19000",
        //                     "triggerPriceType": "LATEST_PRICE",
        //                     "state": "USER_REVOCATION",
        //                     "marketOrderLevel": null,
        //                     "createdTime": 1681271998064,
        //                     "updatedTime": 1681273188674,
        //                     "ordinary": false
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object orders = this.safeValue(data, "items", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async virtual Task<object> fetchOrdersByStatus(object status, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object type = null;
        object subType = null;
        object response = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchOrdersByStatus", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchOrdersByStatus", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object trigger = this.safeBool2(parameters, "stop", "trigger");
        object stopLossTakeProfit = this.safeValue(parameters, "stopLossTakeProfit");
        if (isTrue(isEqual(status, "open")))
        {
            if (isTrue(isTrue(trigger) || isTrue(stopLossTakeProfit)))
            {
                ((IDictionary<string,object>)request)["state"] = "NOT_TRIGGERED";
            } else if (isTrue(isEqual(type, "swap")))
            {
                ((IDictionary<string,object>)request)["state"] = "UNFINISHED"; // NEW & PARTIALLY_FILLED
            }
        } else if (isTrue(isEqual(status, "closed")))
        {
            if (isTrue(isTrue(trigger) || isTrue(stopLossTakeProfit)))
            {
                ((IDictionary<string,object>)request)["state"] = "TRIGGERED";
            } else
            {
                ((IDictionary<string,object>)request)["state"] = "FILLED";
            }
        } else if (isTrue(isEqual(status, "canceled")))
        {
            if (isTrue(isTrue(trigger) || isTrue(stopLossTakeProfit)))
            {
                ((IDictionary<string,object>)request)["state"] = "USER_REVOCATION";
            } else
            {
                ((IDictionary<string,object>)request)["state"] = "CANCELED";
            }
        } else
        {
            ((IDictionary<string,object>)request)["state"] = status;
        }
        if (isTrue(isTrue(isTrue(isTrue(isTrue(trigger) || isTrue(stopLossTakeProfit)) || isTrue((!isEqual(subType, null)))) || isTrue((isEqual(type, "swap")))) || isTrue((isEqual(type, "future")))))
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["startTime"] = since;
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["size"] = limit;
            }
        }
        if (isTrue(trigger))
        {
            parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
            if (isTrue(isEqual(subType, "inverse")))
            {
                response = await this.privateInverseGetFutureTradeV1EntrustPlanList(this.extend(request, parameters));
            } else
            {
                response = await this.privateLinearGetFutureTradeV1EntrustPlanList(this.extend(request, parameters));
            }
        } else if (isTrue(stopLossTakeProfit))
        {
            parameters = this.omit(parameters, "stopLossTakeProfit");
            if (isTrue(isEqual(subType, "inverse")))
            {
                response = await this.privateInverseGetFutureTradeV1EntrustProfitList(this.extend(request, parameters));
            } else
            {
                response = await this.privateLinearGetFutureTradeV1EntrustProfitList(this.extend(request, parameters));
            }
        } else if (isTrue(isTrue(isTrue((!isEqual(subType, null))) || isTrue((isEqual(type, "swap")))) || isTrue((isEqual(type, "future")))))
        {
            if (isTrue(isEqual(subType, "inverse")))
            {
                response = await this.privateInverseGetFutureTradeV1OrderList(this.extend(request, parameters));
            } else
            {
                response = await this.privateLinearGetFutureTradeV1OrderList(this.extend(request, parameters));
            }
        } else
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOrdersByStatus", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            object marginOrSpotRequest = ((bool) isTrue((!isEqual(marginMode, null)))) ? "LEVER" : "SPOT";
            ((IDictionary<string,object>)request)["bizType"] = marginOrSpotRequest;
            if (isTrue(!isEqual(status, "open")))
            {
                if (isTrue(!isEqual(since, null)))
                {
                    ((IDictionary<string,object>)request)["startTime"] = since;
                }
                if (isTrue(!isEqual(limit, null)))
                {
                    request = this.omit(request, "size");
                    ((IDictionary<string,object>)request)["limit"] = limit;
                }
                response = await this.privateSpotGetHistoryOrder(this.extend(request, parameters));
            } else
            {
                response = await this.privateSpotGetOpenOrder(this.extend(request, parameters));
            }
        }
        //
        // spot and margin
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": {
        //             "hasPrev": false,
        //             "hasNext": true,
        //             "items": [
        //                 {
        //                     "symbol": "btc_usdt",
        //                     "orderId": "207505997850909952",
        //                     "clientOrderId": null,
        //                     "baseCurrency": "btc",
        //                     "quoteCurrency": "usdt",
        //                     "side": "BUY",
        //                     "type": "LIMIT",
        //                     "timeInForce": "GTC",
        //                     "price": "20000.00",
        //                     "origQty": "0.001000",
        //                     "origQuoteQty": "20.00",
        //                     "executedQty": "0.000000",
        //                     "leavingQty": "0.000000",
        //                     "tradeBase": "0.000000",
        //                     "tradeQuote": "0.00",
        //                     "avgPrice": null,
        //                     "fee": null,
        //                     "feeCurrency": null,
        //                     "closed": true,
        //                     "state": "CANCELED",
        //                     "time": 1679175285162,
        //                     "updatedTime": 1679175488492
        //                 },
        //             ]
        //         }
        //     }
        //
        // spot and margin: fetchOpenOrders
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": [
        //             {
        //                 "symbol": "eth_usdt",
        //                 "orderId": "208249323222264320",
        //                 "clientOrderId": null,
        //                 "baseCurrency": "eth",
        //                 "quoteCurrency": "usdt",
        //                 "side": "BUY",
        //                 "type": "LIMIT",
        //                 "timeInForce": "GTC",
        //                 "price": "1300.00",
        //                 "origQty": "0.0032",
        //                 "origQuoteQty": "4.16",
        //                 "executedQty": "0.0000",
        //                 "leavingQty": "0.0032",
        //                 "tradeBase": "0.0000",
        //                 "tradeQuote": "0.00",
        //                 "avgPrice": null,
        //                 "fee": null,
        //                 "feeCurrency": null,
        //                 "closed": false,
        //                 "state": "NEW",
        //                 "time": 1679352507741,
        //                 "updatedTime": 1679352507869
        //             },
        //         ]
        //     }
        //
        // swap and future
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": {
        //             "page": 1,
        //             "ps": 10,
        //             "total": 25,
        //             "items": [
        //                 {
        //                     "orderId": "207519546930995456",
        //                     "clientOrderId": null,
        //                     "symbol": "btc_usdt",
        //                     "orderType": "LIMIT",
        //                     "orderSide": "BUY",
        //                     "positionSide": "LONG",
        //                     "timeInForce": "GTC",
        //                     "closePosition": false,
        //                     "price": "20000",
        //                     "origQty": "100",
        //                     "avgPrice": "0",
        //                     "executedQty": "0",
        //                     "marginFrozen": "4.12",
        //                     "remark": null,
        //                     "triggerProfitPrice": null,
        //                     "triggerStopPrice": null,
        //                     "sourceId": null,
        //                     "sourceType": "DEFAULT",
        //                     "forceClose": false,
        //                     "closeProfit": null,
        //                     "state": "CANCELED",
        //                     "createdTime": 1679178515689,
        //                     "updatedTime": 1679180096172
        //                 },
        //             ]
        //         }
        //     }
        //
        // stop
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": {
        //             "page": 1,
        //             "ps": 3,
        //             "total": 8,
        //             "items": [
        //                 {
        //                     "entrustId": "216300248132756992",
        //                     "symbol": "btc_usdt",
        //                     "entrustType": "STOP",
        //                     "orderSide": "SELL",
        //                     "positionSide": "SHORT",
        //                     "timeInForce": "GTC",
        //                     "closePosition": null,
        //                     "price": "20000",
        //                     "origQty": "1",
        //                     "stopPrice": "19000",
        //                     "triggerPriceType": "LATEST_PRICE",
        //                     "state": "USER_REVOCATION",
        //                     "marketOrderLevel": null,
        //                     "createdTime": 1681271998064,
        //                     "updatedTime": 1681273188674,
        //                     "ordinary": false
        //                 },
        //             ]
        //         }
        //     }
        //
        // stop-loss and take-profit
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": {
        //             "page": 1,
        //             "ps": 3,
        //             "total": 2,
        //             "items": [
        //                 {
        //                     "profitId": "216306213226230400",
        //                     "symbol": "btc_usdt",
        //                     "positionSide": "LONG",
        //                     "origQty": "1",
        //                     "triggerPriceType": "LATEST_PRICE",
        //                     "triggerProfitPrice": null,
        //                     "triggerStopPrice": "20000",
        //                     "entryPrice": "0",
        //                     "positionSize": "0",
        //                     "isolatedMargin": "0",
        //                     "executedQty": "0",
        //                     "avgPrice": null,
        //                     "positionType": "ISOLATED",
        //                     "state": "USER_REVOCATION",
        //                     "createdTime": 1681273420039
        //                 },
        //             ]
        //         }
        //     }
        //
        object orders = new List<object>() {};
        object resultDict = this.safeDict(response, "result");
        if (isTrue(!isEqual(resultDict, null)))
        {
            orders = this.safeList(resultDict, "items", new List<object>() {});
        } else
        {
            orders = this.safeList(response, "result");
        }
        return this.parseOrders(orders, market, since, limit);
    }

    /**
     * @method
     * @name xt#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://doc.xt.com/#orderopenOrderGet
     * @see https://doc.xt.com/#futures_ordergetOrders
     * @see https://doc.xt.com/#futures_entrustgetPlan
     * @see https://doc.xt.com/#futures_entrustgetProfit
     * @param {string} [symbol] unified market symbol of the market the orders were made in
     * @param {int} [since] timestamp in ms of the earliest order
     * @param {int} [limit] the maximum number of open order structures to retrieve
     * @param {object} params extra parameters specific to the xt api endpoint
     * @param {bool} [params.trigger] if the order is a trigger order or not
     * @param {bool} [params.stopLossTakeProfit] if the order is a stop-loss or take-profit order
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("open", symbol, since, limit, parameters);
    }

    /**
     * @method
     * @name xt#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://doc.xt.com/#orderhistoryOrderGet
     * @see https://doc.xt.com/#futures_ordergetOrders
     * @see https://doc.xt.com/#futures_entrustgetPlan
     * @see https://doc.xt.com/#futures_entrustgetProfit
     * @param {string} [symbol] unified market symbol of the market the orders were made in
     * @param {int} [since] timestamp in ms of the earliest order
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} params extra parameters specific to the xt api endpoint
     * @param {bool} [params.trigger] if the order is a trigger order or not
     * @param {bool} [params.stopLossTakeProfit] if the order is a stop-loss or take-profit order
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("closed", symbol, since, limit, parameters);
    }

    /**
     * @method
     * @name xt#fetchCanceledOrders
     * @description fetches information on multiple canceled orders made by the user
     * @see https://doc.xt.com/#orderhistoryOrderGet
     * @see https://doc.xt.com/#futures_ordergetOrders
     * @see https://doc.xt.com/#futures_entrustgetPlan
     * @see https://doc.xt.com/#futures_entrustgetProfit
     * @param {string} [symbol] unified market symbol of the market the orders were made in
     * @param {int} [since] timestamp in ms of the earliest order
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} params extra parameters specific to the xt api endpoint
     * @param {bool} [params.trigger] if the order is a trigger order or not
     * @param {bool} [params.stopLossTakeProfit] if the order is a stop-loss or take-profit order
     * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
     */
    public async override Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("canceled", symbol, since, limit, parameters);
    }

    /**
     * @method
     * @name xt#cancelOrder
     * @description cancels an open order
     * @see https://doc.xt.com/#orderorderDel
     * @see https://doc.xt.com/#futures_ordercancel
     * @see https://doc.xt.com/#futures_entrustcancelPlan
     * @see https://doc.xt.com/#futures_entrustcancelProfit
     * @param {string} id order id
     * @param {string} [symbol] unified symbol of the market the order was made in
     * @param {object} params extra parameters specific to the xt api endpoint
     * @param {bool} [params.trigger] if the order is a trigger order or not
     * @param {bool} [params.stopLossTakeProfit] if the order is a stop-loss or take-profit order
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        object type = null;
        object subType = null;
        object response = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("cancelOrder", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("cancelOrder", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object trigger = this.safeValue2(parameters, "trigger", "stop");
        object stopLossTakeProfit = this.safeValue(parameters, "stopLossTakeProfit");
        if (isTrue(trigger))
        {
            ((IDictionary<string,object>)request)["entrustId"] = id;
        } else if (isTrue(stopLossTakeProfit))
        {
            ((IDictionary<string,object>)request)["profitId"] = id;
        } else
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        if (isTrue(trigger))
        {
            parameters = this.omit(parameters, new List<object>() {"trigger", "stop"});
            if (isTrue(isEqual(subType, "inverse")))
            {
                response = await this.privateInversePostFutureTradeV1EntrustCancelPlan(this.extend(request, parameters));
            } else
            {
                response = await this.privateLinearPostFutureTradeV1EntrustCancelPlan(this.extend(request, parameters));
            }
        } else if (isTrue(stopLossTakeProfit))
        {
            parameters = this.omit(parameters, "stopLossTakeProfit");
            if (isTrue(isEqual(subType, "inverse")))
            {
                response = await this.privateInversePostFutureTradeV1EntrustCancelProfitStop(this.extend(request, parameters));
            } else
            {
                response = await this.privateLinearPostFutureTradeV1EntrustCancelProfitStop(this.extend(request, parameters));
            }
        } else if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.privateInversePostFutureTradeV1OrderCancel(this.extend(request, parameters));
        } else if (isTrue(isTrue(isTrue((isEqual(subType, "linear"))) || isTrue((isEqual(type, "swap")))) || isTrue((isEqual(type, "future")))))
        {
            response = await this.privateLinearPostFutureTradeV1OrderCancel(this.extend(request, parameters));
        } else
        {
            response = await this.privateSpotDeleteOrderOrderId(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": {
        //             "cancelId": "208322474307982720"
        //         }
        //     }
        //
        // swap and future
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": "208319789679471616"
        //     }
        //
        object isContractResponse = (isTrue(isTrue((!isEqual(subType, null))) || isTrue((isEqual(type, "swap")))) || isTrue((isEqual(type, "future"))));
        object order = ((bool) isTrue(isContractResponse)) ? response : this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(order, market);
    }

    /**
     * @method
     * @name xt#cancelAllOrders
     * @description cancel all open orders in a market
     * @see https://doc.xt.com/#orderopenOrderDel
     * @see https://doc.xt.com/#futures_ordercancelBatch
     * @see https://doc.xt.com/#futures_entrustcancelPlanBatch
     * @see https://doc.xt.com/#futures_entrustcancelProfitBatch
     * @param {string} [symbol] unified market symbol of the market to cancel orders in
     * @param {object} params extra parameters specific to the xt api endpoint
     * @param {bool} [params.trigger] if the order is a trigger order or not
     * @param {bool} [params.stopLossTakeProfit] if the order is a stop-loss or take-profit order
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object type = null;
        object subType = null;
        object response = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("cancelAllOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("cancelAllOrders", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object trigger = this.safeValue2(parameters, "trigger", "stop");
        object stopLossTakeProfit = this.safeValue(parameters, "stopLossTakeProfit");
        if (isTrue(trigger))
        {
            parameters = this.omit(parameters, new List<object>() {"trigger", "stop"});
            if (isTrue(isEqual(subType, "inverse")))
            {
                response = await this.privateInversePostFutureTradeV1EntrustCancelAllPlan(this.extend(request, parameters));
            } else
            {
                response = await this.privateLinearPostFutureTradeV1EntrustCancelAllPlan(this.extend(request, parameters));
            }
        } else if (isTrue(stopLossTakeProfit))
        {
            parameters = this.omit(parameters, "stopLossTakeProfit");
            if (isTrue(isEqual(subType, "inverse")))
            {
                response = await this.privateInversePostFutureTradeV1EntrustCancelAllProfitStop(this.extend(request, parameters));
            } else
            {
                response = await this.privateLinearPostFutureTradeV1EntrustCancelAllProfitStop(this.extend(request, parameters));
            }
        } else if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.privateInversePostFutureTradeV1OrderCancelAll(this.extend(request, parameters));
        } else if (isTrue(isTrue(isTrue((isEqual(subType, "linear"))) || isTrue((isEqual(type, "swap")))) || isTrue((isEqual(type, "future")))))
        {
            response = await this.privateLinearPostFutureTradeV1OrderCancelAll(this.extend(request, parameters));
        } else
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("cancelAllOrders", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            object marginOrSpotRequest = ((bool) isTrue((!isEqual(marginMode, null)))) ? "LEVER" : "SPOT";
            ((IDictionary<string,object>)request)["bizType"] = marginOrSpotRequest;
            response = await this.privateSpotDeleteOpenOrder(this.extend(request, parameters));
        }
        //
        // spot and margin
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": null
        //     }
        //
        // swap and future
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": true
        //     }
        //
        return new List<object> {this.safeOrder(response)};
    }

    /**
     * @method
     * @name xt#cancelOrders
     * @description cancel multiple orders
     * @see https://doc.xt.com/#orderbatchOrderDel
     * @param {string[]} ids order ids
     * @param {string} [symbol] unified market symbol of the market to cancel orders in
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
     */
    public async override Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderIds", ids },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("cancelOrders", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(!isEqual(subType, null)))
        {
            throw new NotSupported ((string)add(this.id, " cancelOrders() does not support swap and future orders, only spot orders are accepted")) ;
        }
        object response = await this.privateSpotDeleteBatchOrder(this.extend(request, parameters));
        //
        // spot
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": null
        //     }
        //
        return new List<object> {this.safeOrder(response)};
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // spot: createOrder
        //
        //     {
        //         "orderId": "204371980095156544"
        //     }
        //
        // spot: cancelOrder
        //
        //     {
        //         "cancelId": "208322474307982720"
        //     }
        //
        // swap and future: createOrder, cancelOrder, editOrder
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": "206410760006650176"
        //     }
        //
        // spot: fetchOrder, fetchOrders, fetchOpenOrders, fetchClosedOrders, fetchCanceledOrders, fetchOrdersByStatus
        //
        //     {
        //         "symbol": "btc_usdt",
        //         "orderId": "207505997850909952",
        //         "clientOrderId": null,
        //         "baseCurrency": "btc",
        //         "quoteCurrency": "usdt",
        //         "side": "BUY",
        //         "type": "LIMIT",
        //         "timeInForce": "GTC",
        //         "price": "20000.00",
        //         "origQty": "0.001000",
        //         "origQuoteQty": "20.00",
        //         "executedQty": "0.000000",
        //         "leavingQty": "0.001000",
        //         "tradeBase": "0.000000",
        //         "tradeQuote": "0.00",
        //         "avgPrice": null,
        //         "fee": null,
        //         "feeCurrency": null,
        //         "closed": false,
        //         "state": "NEW",
        //         "time": 1679175285162,
        //         "updatedTime": 1679175285255
        //     }
        //
        // swap and future: fetchOrder, fetchOrders, fetchOpenOrders, fetchClosedOrders, fetchCanceledOrders, fetchOrdersByStatus
        //
        //     {
        //         "orderId": "207519546930995456",
        //         "clientOrderId": null,
        //         "symbol": "btc_usdt",
        //         "orderType": "LIMIT",
        //         "orderSide": "BUY",
        //         "positionSide": "LONG",
        //         "timeInForce": "GTC",
        //         "closePosition": false,
        //         "price": "20000",
        //         "origQty": "100",
        //         "avgPrice": "0",
        //         "executedQty": "0",
        //         "marginFrozen": "4.12",
        //         "remark": null,
        //         "triggerProfitPrice": null,
        //         "triggerStopPrice": null,
        //         "sourceId": null,
        //         "sourceType": "DEFAULT",
        //         "forceClose": false,
        //         "closeProfit": null,
        //         "state": "CANCELED",
        //         "createdTime": 1679178515689,
        //         "updatedTime": 1679180096172
        //     }
        //
        // trigger: fetchOrder, fetchOrders, fetchOpenOrders, fetchClosedOrders, fetchCanceledOrders, fetchOrdersByStatus
        //
        //     {
        //         "entrustId": "216300248132756992",
        //         "symbol": "btc_usdt",
        //         "entrustType": "STOP",
        //         "orderSide": "SELL",
        //         "positionSide": "SHORT",
        //         "timeInForce": "GTC",
        //         "closePosition": null,
        //         "price": "20000",
        //         "origQty": "1",
        //         "stopPrice": "19000",
        //         "triggerPriceType": "LATEST_PRICE",
        //         "state": "NOT_TRIGGERED",
        //         "marketOrderLevel": null,
        //         "createdTime": 1681271998064,
        //         "updatedTime": 1681271998064,
        //         "ordinary": false
        //     }
        //
        // stop-loss and take-profit: fetchOrder, fetchOpenOrders, fetchClosedOrders, fetchCanceledOrders, fetchOrdersByStatus
        //
        //     {
        //         "profitId": "216306213226230400",
        //         "symbol": "btc_usdt",
        //         "positionSide": "LONG",
        //         "origQty": "1",
        //         "triggerPriceType": "LATEST_PRICE",
        //         "triggerProfitPrice": null,
        //         "triggerStopPrice": "20000",
        //         "entryPrice": null,
        //         "positionSize": null,
        //         "isolatedMargin": null,
        //         "executedQty": null,
        //         "avgPrice": null,
        //         "positionType": "ISOLATED",
        //         "state": "NOT_TRIGGERED",
        //         "createdTime": 1681273420039
        //     }
        //
        // spot editOrder
        //
        //     {
        //         "orderId": "484203027161892224",
        //         "modifyId": "484203544105344000",
        //         "clientModifyId": null
        //     }
        //
        object marketId = this.safeString(order, "symbol");
        object marketType = ((bool) isTrue(isTrue((inOp(order, "result"))) || isTrue((inOp(order, "positionSide"))))) ? "contract" : "spot";
        market = this.safeMarket(marketId, market, null, marketType);
        object symbol = this.safeSymbol(marketId, market, null, marketType);
        object timestamp = this.safeInteger2(order, "time", "createdTime");
        object quantity = this.safeNumber(order, "origQty");
        object amount = ((bool) isTrue((isEqual(marketType, "spot")))) ? quantity : Precise.stringMul(this.numberToString(quantity), this.numberToString(getValue(market, "contractSize")));
        object filledQuantity = this.safeNumber(order, "executedQty");
        object filled = ((bool) isTrue((isEqual(marketType, "spot")))) ? filledQuantity : Precise.stringMul(this.numberToString(filledQuantity), this.numberToString(getValue(market, "contractSize")));
        object lastUpdatedTimestamp = this.safeInteger(order, "updatedTime");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeStringN(order, new List<object>() {"orderId", "result", "cancelId", "entrustId", "profitId"}) },
            { "clientOrderId", this.safeString2(order, "clientOrderId", "clientModifyId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastUpdatedTimestamp },
            { "lastUpdateTimestamp", lastUpdatedTimestamp },
            { "symbol", symbol },
            { "type", this.safeStringLower2(order, "type", "orderType") },
            { "timeInForce", this.safeString(order, "timeInForce") },
            { "postOnly", null },
            { "side", this.safeStringLower2(order, "side", "orderSide") },
            { "price", this.safeNumber(order, "price") },
            { "triggerPrice", this.safeNumber(order, "stopPrice") },
            { "stopLoss", this.safeNumber(order, "triggerStopPrice") },
            { "takeProfit", this.safeNumber(order, "triggerProfitPrice") },
            { "amount", amount },
            { "filled", filled },
            { "remaining", this.safeNumber(order, "leavingQty") },
            { "cost", null },
            { "average", this.safeNumber(order, "avgPrice") },
            { "status", this.parseOrderStatus(this.safeString(order, "state")) },
            { "fee", new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(this.safeString(order, "feeCurrency")) },
                { "cost", this.safeNumber(order, "fee") },
            } },
            { "trades", null },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "open" },
            { "PARTIALLY_FILLED", "open" },
            { "FILLED", "closed" },
            { "CANCELED", "canceled" },
            { "REJECTED", "rejected" },
            { "EXPIRED", "expired" },
            { "UNFINISHED", "open" },
            { "NOT_TRIGGERED", "open" },
            { "TRIGGERING", "open" },
            { "TRIGGERED", "closed" },
            { "USER_REVOCATION", "canceled" },
            { "PLATFORM_REVOCATION", "rejected" },
            { "HISTORY", "expired" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name xt#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
     * @see https://doc.xt.com/#futures_usergetBalanceBill
     * @param {string} [code] unified currency code
     * @param {int} [since] timestamp in ms of the earliest ledger entry
     * @param {int} [limit] max number of ledger entries to return
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/en/latest/manual.html#ledger-structure}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object type = null;
        object subType = null;
        object response = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchLedger", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchLedger", null, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.privateInverseGetFutureUserV1BalanceBills(this.extend(request, parameters));
        } else if (isTrue(isTrue(isTrue((isEqual(subType, "linear"))) || isTrue((isEqual(type, "swap")))) || isTrue((isEqual(type, "future")))))
        {
            response = await this.privateLinearGetFutureUserV1BalanceBills(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchLedger() does not support spot transactions, only swap and future wallet transactions are supported")) ;
        }
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": {
        //             "hasPrev": false,
        //             "hasNext": false,
        //             "items": [
        //                 {
        //                     "id": "207260567109387525",
        //                     "coin": "usdt",
        //                     "symbol": "btc_usdt",
        //                     "type": "FEE",
        //                     "amount": "-0.0213",
        //                     "side": "SUB",
        //                     "afterAmount": null,
        //                     "createdTime": 1679116769914
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object ledger = this.safeValue(data, "items", new List<object>() {});
        return this.parseLedger(ledger, currency, since, limit);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //         "id": "207260567109387524",
        //         "coin": "usdt",
        //         "symbol": "btc_usdt",
        //         "type": "FEE",
        //         "amount": "-0.0213",
        //         "side": "SUB",
        //         "afterAmount": null,
        //         "createdTime": 1679116769914
        //     }
        //
        object side = this.safeString(item, "side");
        object direction = ((bool) isTrue((isEqual(side, "ADD")))) ? "in" : "out";
        object currencyId = this.safeString(item, "coin");
        currency = this.safeCurrency(currencyId, currency);
        object timestamp = this.safeInteger(item, "createdTime");
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", this.safeString(item, "id") },
            { "direction", direction },
            { "account", null },
            { "referenceId", null },
            { "referenceAccount", null },
            { "type", this.parseLedgerEntryType(this.safeString(item, "type")) },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber(item, "amount") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "before", null },
            { "after", this.safeNumber(item, "afterAmount") },
            { "status", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", null },
                { "cost", null },
            } },
        }, currency);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object ledgerType = new Dictionary<string, object>() {
            { "EXCHANGE", "transfer" },
            { "CLOSE_POSITION", "trade" },
            { "TAKE_OVER", "trade" },
            { "MERGE", "trade" },
            { "QIANG_PING_MANAGER", "fee" },
            { "FUND", "fee" },
            { "FEE", "fee" },
            { "ADL", "auto-deleveraging" },
        };
        return this.safeString(ledgerType, type, type);
    }

    /**
     * @method
     * @name xt#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://doc.xt.com/#deposit_withdrawaldepositAddressGet
     * @param {string} code unified currency code
     * @param {object} params extra parameters specific to the xt api endpoint
     * @param {string} params.network required network id
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/en/latest/manual.html#address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        object currency = this.currency(code);
        object networkId = this.networkCodeToId(networkCode, code);
        this.checkRequiredArgument("fetchDepositAddress", networkId, "network");
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "chain", networkId },
        };
        object response = await this.privateSpotGetDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": {
        //             "address": "0x7f7173cf29d3846d20ca5a3aec1120b93dbd157a",
        //             "memo": ""
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseDepositAddress(result, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "address": "0x7f7173cf29d3846d20ca5a3aec1120b93dbd157a",
        //         "memo": ""
        //     }
        //
        object address = this.safeString(depositAddress, "address");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "network", null },
            { "address", address },
            { "tag", this.safeString(depositAddress, "memo") },
        };
    }

    /**
     * @method
     * @name xt#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://doc.xt.com/#deposit_withdrawalhistoryDepositGet
     * @param {string} [code] unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of transaction structures to retrieve
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/en/latest/manual.html#transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 10, max 200
        }
        object response = await this.privateSpotGetDepositHistory(this.extend(request, parameters));
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": {
        //             "hasPrev": false,
        //             "hasNext": false,
        //             "items": [
        //                 {
        //                     "id": 170368702,
        //                     "currency": "usdt",
        //                     "chain": "Ethereum",
        //                     "memo": "",
        //                     "status": "SUCCESS",
        //                     "amount": "31.792528",
        //                     "confirmations": 12,
        //                     "transactionId": "0x90b8487c258b81b85e15e461b1839c49d4d8e6e9de4c1adb658cd47d4f5c5321",
        //                     "address": "0x7f7172cf29d3846d30ca5a3aec1120b92dbd150b",
        //                     "fromAddr": "0x7830c87c02e56aff27fa9ab1241711331fa86f58",
        //                     "createdTime": 1678491442000
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object deposits = this.safeValue(data, "items", new List<object>() {});
        return this.parseTransactions(deposits, currency, since, limit, parameters);
    }

    /**
     * @method
     * @name xt#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://doc.xt.com/#deposit_withdrawalwithdrawHistory
     * @param {string} [code] unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of transaction structures to retrieve
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/en/latest/manual.html#transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 10, max 200
        }
        object response = await this.privateSpotGetWithdrawHistory(this.extend(request, parameters));
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": {
        //             "hasPrev": false,
        //             "hasNext": false,
        //             "items": [
        //                 {
        //                     "id": 950898,
        //                     "currency": "usdt",
        //                     "chain": "Tron",
        //                     "address": "TGB2vxTjiqraVZBy7YHXF8V3CSMVhQKcaf",
        //                     "memo": "",
        //                     "status": "SUCCESS",
        //                     "amount": "5",
        //                     "fee": "2",
        //                     "confirmations": 6,
        //                     "transactionId": "c36e230b879842b1d7afd19d15ee1a866e26eaa0626e367d6f545d2932a15156",
        //                     "createdTime": 1680049062000
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object withdrawals = this.safeValue(data, "items", new List<object>() {});
        return this.parseTransactions(withdrawals, currency, since, limit, parameters);
    }

    /**
     * @method
     * @name xt#withdraw
     * @description make a withdrawal
     * @see https://doc.xt.com/#deposit_withdrawalwithdraw
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} [tag]
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/en/latest/manual.html#transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        object networkIdsByCodes = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object networkId = this.safeString2(networkIdsByCodes, networkCode, code, code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "chain", networkId },
            { "amount", this.currencyToPrecision(code, amount) },
            { "address", address },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["memo"] = tag;
        }
        object response = await this.privateSpotPostWithdraw(this.extend(request, parameters));
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": {
        //             "id": 950898
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseTransaction(result, currency);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //     {
        //         "id": 170368702,
        //         "currency": "usdt",
        //         "chain": "Ethereum",
        //         "memo": "",
        //         "status": "SUCCESS",
        //         "amount": "31.792528",
        //         "confirmations": 12,
        //         "transactionId": "0x90b8487c258b81b85e15e461b1839c49d4d8e6e9de4c1adb658cd47d4f5c5321",
        //         "address": "0x7f7172cf29d3846d30ca5a3aec1120b92dbd150b",
        //         "fromAddr": "0x7830c87c02e56aff27fa9ab1241711331fa86f58",
        //         "createdTime": 1678491442000
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "id": 950898,
        //         "currency": "usdt",
        //         "chain": "Tron",
        //         "address": "TGB2vxTjiqraVZBy7YHXF8V3CSMVhQKcaf",
        //         "memo": "",
        //         "status": "SUCCESS",
        //         "amount": "5",
        //         "fee": "2",
        //         "confirmations": 6,
        //         "transactionId": "c36e230b879842b1d7afd19d15ee1a866e26eaa0626e367d6f545d2932a15156",
        //         "createdTime": 1680049062000
        //     }
        //
        // withdraw
        //
        //     {
        //         "id": 950898
        //     }
        //
        object type = ((bool) isTrue((inOp(transaction, "fromAddr")))) ? "deposit" : "withdraw";
        object timestamp = this.safeInteger(transaction, "createdTime");
        object address = this.safeString(transaction, "address");
        object memo = this.safeString(transaction, "memo");
        object currencyCode = this.safeCurrencyCode(this.safeString(transaction, "currency"), currency);
        object fee = this.safeNumber(transaction, "fee");
        object feeCurrency = ((bool) isTrue((!isEqual(fee, null)))) ? currencyCode : null;
        object networkId = this.safeString(transaction, "chain");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString(transaction, "id") },
            { "txid", this.safeString(transaction, "transactionId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "updated", null },
            { "addressFrom", this.safeString(transaction, "fromAddr") },
            { "addressTo", address },
            { "address", address },
            { "tagFrom", null },
            { "tagTo", null },
            { "tag", memo },
            { "type", type },
            { "amount", this.safeNumber(transaction, "amount") },
            { "currency", currencyCode },
            { "network", this.networkIdToCode(networkId, currencyCode) },
            { "status", this.parseTransactionStatus(this.safeString(transaction, "status")) },
            { "comment", memo },
            { "fee", new Dictionary<string, object>() {
                { "currency", feeCurrency },
                { "cost", fee },
                { "rate", null },
            } },
            { "internal", null },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "SUBMIT", "pending" },
            { "REVIEW", "pending" },
            { "AUDITED", "pending" },
            { "PENDING", "pending" },
            { "CANCEL", "canceled" },
            { "FAIL", "failed" },
            { "SUCCESS", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name xt#setLeverage
     * @description set the level of leverage for a market
     * @see https://doc.xt.com/#futures_useradjustLeverage
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} params extra parameters specific to the xt api endpoint
     * @param {string} params.positionSide 'LONG' or 'SHORT'
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        object positionSide = this.safeString(parameters, "positionSide");
        this.checkRequiredArgument("setLeverage", positionSide, "positionSide", new List<object>() {"LONG", "SHORT"});
        if (isTrue(isTrue((isLessThan(leverage, 1))) || isTrue((isGreaterThan(leverage, 125)))))
        {
            throw new BadRequest ((string)add(this.id, " setLeverage() leverage should be between 1 and 125")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue((getValue(market, "contract"))))
        {
            throw new BadSymbol ((string)add(this.id, " setLeverage() supports contract markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "positionSide", positionSide },
            { "leverage", leverage },
        };
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("setLeverage", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.privateInversePostFutureUserV1PositionAdjustLeverage(this.extend(request, parameters));
        } else
        {
            response = await this.privateLinearPostFutureUserV1PositionAdjustLeverage(this.extend(request, parameters));
        }
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": null
        //     }
        //
        return response;
    }

    /**
     * @method
     * @name xt#addMargin
     * @description add margin to a position
     * @see https://doc.xt.com/#futures_useradjustMargin
     * @param {string} symbol unified market symbol
     * @param {float} amount amount of margin to add
     * @param {object} params extra parameters specific to the xt api endpoint
     * @param {string} params.positionSide 'LONG' or 'SHORT'
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/?id=margin-structure}
     */
    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "ADD", parameters);
    }

    /**
     * @method
     * @name xt#reduceMargin
     * @description remove margin from a position
     * @see https://doc.xt.com/#futures_useradjustMargin
     * @param {string} symbol unified market symbol
     * @param {float} amount the amount of margin to remove
     * @param {object} params extra parameters specific to the xt api endpoint
     * @param {string} params.positionSide 'LONG' or 'SHORT'
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/?id=margin-structure}
     */
    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "SUB", parameters);
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object addOrReduce, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object positionSide = this.safeString(parameters, "positionSide");
        this.checkRequiredArgument("setLeverage", positionSide, "positionSide", new List<object>() {"LONG", "SHORT"});
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "margin", amount },
            { "type", addOrReduce },
            { "positionSide", positionSide },
        };
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("modifyMarginHelper", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.privateInversePostFutureUserV1PositionMargin(this.extend(request, parameters));
        } else
        {
            response = await this.privateLinearPostFutureUserV1PositionMargin(this.extend(request, parameters));
        }
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": null
        //     }
        //
        return this.parseMarginModification(response, market);
    }

    public override object parseMarginModification(object data, object market = null)
    {
        return new Dictionary<string, object>() {
            { "info", data },
            { "type", null },
            { "amount", null },
            { "code", null },
            { "symbol", this.safeSymbol(null, market) },
            { "status", null },
            { "marginMode", null },
            { "total", null },
            { "timestamp", null },
            { "datetime", null },
        };
    }

    /**
     * @method
     * @name xt#fetchLeverageTiers
     * @description retrieve information on the maximum leverage for different trade sizes
     * @see https://doc.xt.com/#futures_quotesgetLeverageBrackets
     * @param {string} [symbols] a list of unified market symbols
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/?id=leverage-tiers-structure}
     */
    public async override Task<object> fetchLeverageTiers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchLeverageTiers", null, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.publicInverseGetFutureMarketV1PublicLeverageBracketList(parameters);
        } else
        {
            response = await this.publicLinearGetFutureMarketV1PublicLeverageBracketList(parameters);
        }
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": [
        //             {
        //                 "symbol": "rad_usdt",
        //                 "leverageBrackets": [
        //                     {
        //                         "symbol": "rad_usdt",
        //                         "bracket": 1,
        //                         "maxNominalValue": "5000",
        //                         "maintMarginRate": "0.025",
        //                         "startMarginRate": "0.05",
        //                         "maxStartMarginRate": null,
        //                         "maxLeverage": "20",
        //                         "minLeverage": "1"
        //                     },
        //                 ]
        //             },
        //         ]
        //     }
        //
        object data = this.safeValue(response, "result", new List<object>() {});
        symbols = this.marketSymbols(symbols);
        return this.parseLeverageTiers(data, symbols, "symbol");
    }

    public override object parseLeverageTiers(object response, object symbols = null, object marketIdKey = null)
    {
        //
        //     {
        //         "symbol": "rad_usdt",
        //         "leverageBrackets": [
        //             {
        //                 "symbol": "rad_usdt",
        //                 "bracket": 1,
        //                 "maxNominalValue": "5000",
        //                 "maintMarginRate": "0.025",
        //                 "startMarginRate": "0.05",
        //                 "maxStartMarginRate": null,
        //                 "maxLeverage": "20",
        //                 "minLeverage": "1"
        //             },
        //         ]
        //     }
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object marketId = this.safeString(entry, "symbol");
            object market = this.safeMarket(marketId, null, "_", "contract");
            object symbol = this.safeSymbol(marketId, market);
            if (isTrue(!isEqual(symbols, null)))
            {
                if (isTrue(this.inArray(symbol, symbols)))
                {
                    ((IDictionary<string,object>)result)[(string)symbol] = this.parseMarketLeverageTiers(entry, market);
                }
            } else
            {
                ((IDictionary<string,object>)result)[(string)symbol] = this.parseMarketLeverageTiers(getValue(response, i), market);
            }
        }
        return result;
    }

    /**
     * @method
     * @name xt#fetchMarketLeverageTiers
     * @description retrieve information on the maximum leverage for different trade sizes of a single market
     * @see https://doc.xt.com/#futures_quotesgetLeverageBracket
     * @param {string} symbol unified market symbol
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object} a [leverage tiers structure]{@link https://docs.ccxt.com/?id=leverage-tiers-structure}
     */
    public async override Task<object> fetchMarketLeverageTiers(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchMarketLeverageTiers", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.publicInverseGetFutureMarketV1PublicLeverageBracketDetail(this.extend(request, parameters));
        } else
        {
            response = await this.publicLinearGetFutureMarketV1PublicLeverageBracketDetail(this.extend(request, parameters));
        }
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": {
        //             "symbol": "btc_usdt",
        //             "leverageBrackets": [
        //                 {
        //                     "symbol": "btc_usdt",
        //                     "bracket": 1,
        //                     "maxNominalValue": "500000",
        //                     "maintMarginRate": "0.004",
        //                     "startMarginRate": "0.008",
        //                     "maxStartMarginRate": null,
        //                     "maxLeverage": "125",
        //                     "minLeverage": "1"
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseMarketLeverageTiers(data, market);
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        //
        //     {
        //         "symbol": "rad_usdt",
        //         "leverageBrackets": [
        //             {
        //                 "symbol": "rad_usdt",
        //                 "bracket": 1,
        //                 "maxNominalValue": "5000",
        //                 "maintMarginRate": "0.025",
        //                 "startMarginRate": "0.05",
        //                 "maxStartMarginRate": null,
        //                 "maxLeverage": "20",
        //                 "minLeverage": "1"
        //             },
        //         ]
        //     }
        //
        object tiers = new List<object>() {};
        object brackets = this.safeValue(info, "leverageBrackets", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(brackets)); postFixIncrement(ref i))
        {
            object tier = getValue(brackets, i);
            object marketId = this.safeString(info, "symbol");
            market = this.safeMarket(marketId, market, "_", "contract");
            ((IList<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.safeInteger(tier, "bracket") },
                { "symbol", this.safeSymbol(marketId, market, "_", "contract") },
                { "currency", getValue(market, "settle") },
                { "minNotional", this.safeNumber(getValue(brackets, subtract(i, 1)), "maxNominalValue", 0) },
                { "maxNotional", this.safeNumber(tier, "maxNominalValue") },
                { "maintenanceMarginRate", this.safeNumber(tier, "maintMarginRate") },
                { "maxLeverage", this.safeNumber(tier, "maxLeverage") },
                { "info", tier },
            });
        }
        return tiers;
    }

    /**
     * @method
     * @name xt#fetchFundingRateHistory
     * @description fetches historical funding rates
     * @see https://doc.xt.com/#futures_quotesgetFundingRateRecord
     * @param {string} [symbol] unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of [funding rate structures] to fetch
     * @param {object} params extra parameters specific to the xt api endpoint
     * @param {bool} params.paginate true/false whether to use the pagination helper to aumatically paginate through the results
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchFundingRateHistory", symbol, since, limit, parameters, "id", "id", 1, 200);
        }
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRateHistory() supports swap contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        } else
        {
            ((IDictionary<string,object>)request)["limit"] = 200; // max
        }
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchFundingRateHistory", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.publicInverseGetFutureMarketV1PublicQFundingRateRecord(this.extend(request, parameters));
        } else
        {
            response = await this.publicLinearGetFutureMarketV1PublicQFundingRateRecord(this.extend(request, parameters));
        }
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": {
        //             "hasPrev": false,
        //             "hasNext": true,
        //             "items": [
        //                 {
        //                     "id": "210441653482221888",
        //                     "symbol": "btc_usdt",
        //                     "fundingRate": "0.000057",
        //                     "createdTime": 1679875200000,
        //                     "collectionInternal": 28800
        //                 },
        //             ]
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object items = this.safeValue(result, "items", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(items)); postFixIncrement(ref i))
        {
            object entry = getValue(items, i);
            object marketId = this.safeString(entry, "symbol");
            object symbolInner = this.safeSymbol(marketId, market);
            object timestamp = this.safeInteger(entry, "createdTime");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbolInner },
                { "fundingRate", this.safeNumber(entry, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    /**
     * @method
     * @name xt#fetchFundingInterval
     * @description fetch the current funding rate interval
     * @see https://doc.xt.com/#futures_quotesgetFundingRate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingInterval(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchFundingRate(symbol, parameters);
    }

    /**
     * @method
     * @name xt#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://doc.xt.com/#futures_quotesgetFundingRate
     * @param {string} symbol unified market symbol
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRate() supports swap contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchFundingRate", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.publicInverseGetFutureMarketV1PublicQFundingRate(this.extend(request, parameters));
        } else
        {
            response = await this.publicLinearGetFutureMarketV1PublicQFundingRate(this.extend(request, parameters));
        }
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": {
        //             "symbol": "btc_usdt",
        //             "fundingRate": "0.000086",
        //             "nextCollectionTime": 1680307200000,
        //             "collectionInternal": 8
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseFundingRate(result, market);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //     {
        //         "symbol": "btc_usdt",
        //         "fundingRate": "0.000086",
        //         "nextCollectionTime": 1680307200000,
        //         "collectionInternal": 8
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        object symbol = this.safeSymbol(marketId, market, "_", "swap");
        object timestamp = this.safeInteger(contract, "nextCollectionTime");
        object interval = this.safeString(contract, "collectionInternal");
        if (isTrue(!isEqual(interval, null)))
        {
            interval = add(interval, "h");
        }
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", this.safeNumber(contract, "fundingRate") },
            { "fundingTimestamp", timestamp },
            { "fundingDatetime", this.iso8601(timestamp) },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", interval },
        };
    }

    /**
     * @method
     * @name xt#fetchFundingHistory
     * @description fetch the funding history
     * @see https://doc.xt.com/#futures_usergetFunding
     * @param {string} symbol unified market symbol
     * @param {int} [since] the starting timestamp in milliseconds
     * @param {int} [limit] the number of entries to return
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object[]} a list of [funding history structures]{@link https://docs.ccxt.com/?id=funding-history-structure}
     */
    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingHistory() supports swap contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchFundingHistory", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.privateInverseGetFutureUserV1BalanceFundingRateList(this.extend(request, parameters));
        } else
        {
            response = await this.privateLinearGetFutureUserV1BalanceFundingRateList(this.extend(request, parameters));
        }
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": {
        //             "hasPrev": false,
        //             "hasNext": false,
        //             "items": [
        //                 {
        //                     "id": "210804044057280512",
        //                     "symbol": "btc_usdt",
        //                     "cast": "-0.0013",
        //                     "coin": "usdt",
        //                     "positionSide": "SHORT",
        //                     "createdTime": 1679961600653
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object items = this.safeValue(data, "items", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(items)); postFixIncrement(ref i))
        {
            object entry = getValue(items, i);
            ((IList<object>)result).Add(this.parseFundingHistory(entry, market));
        }
        object sorted = this.sortBy(result, "timestamp");
        return this.filterBySinceLimit(sorted, since, limit);
    }

    public virtual object parseFundingHistory(object contract, object market = null)
    {
        //
        //     {
        //         "id": "210804044057280512",
        //         "symbol": "btc_usdt",
        //         "cast": "-0.0013",
        //         "coin": "usdt",
        //         "positionSide": "SHORT",
        //         "createdTime": 1679961600653
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        object symbol = this.safeSymbol(marketId, market, "_", "swap");
        object currencyId = this.safeString(contract, "coin");
        object code = this.safeCurrencyCode(currencyId);
        object timestamp = this.safeInteger(contract, "createdTime");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "code", code },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", this.safeString(contract, "id") },
            { "amount", this.safeNumber(contract, "cast") },
        };
    }

    /**
     * @method
     * @name xt#fetchPosition
     * @description fetch data on a single open contract trade position
     * @see https://doc.xt.com/#futures_usergetPosition
     * @param {string} symbol unified market symbol of the market the position is held in
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object} a [position structure]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchPosition", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.privateInverseGetFutureUserV1PositionList(this.extend(request, parameters));
        } else
        {
            response = await this.privateLinearGetFutureUserV1PositionList(this.extend(request, parameters));
        }
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": [
        //             {
        //                 "symbol": "btc_usdt",
        //                 "positionType": "ISOLATED",
        //                 "positionSide": "SHORT",
        //                 "contractType": "PERPETUAL",
        //                 "positionSize": "10",
        //                 "closeOrderSize": "0",
        //                 "availableCloseSize": "10",
        //                 "entryPrice": "27060",
        //                 "openOrderSize": "0",
        //                 "isolatedMargin": "1.0824",
        //                 "openOrderMarginFrozen": "0",
        //                 "realizedProfit": "-0.00130138",
        //                 "autoMargin": false,
        //                 "leverage": 25
        //             },
        //         ]
        //     }
        //
        object positions = this.safeValue(response, "result", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object entry = getValue(positions, i);
            object marketId = this.safeString(entry, "symbol");
            object marketInner = this.safeMarket(marketId, null, null, "contract");
            object positionSize = this.safeString(entry, "positionSize");
            if (isTrue(!isEqual(positionSize, "0")))
            {
                return this.parsePosition(entry, marketInner);
            }
        }
        return null;
    }

    /**
     * @method
     * @name xt#fetchPositions
     * @description fetch all open positions
     * @see https://doc.xt.com/#futures_usergetPosition
     * @param {string} [symbols] list of unified market symbols, not supported with xt
     * @param {object} params extra parameters specific to the xt api endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchPositions", null, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.privateInverseGetFutureUserV1PositionList(parameters);
        } else
        {
            response = await this.privateLinearGetFutureUserV1PositionList(parameters);
        }
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": [
        //             {
        //                 "symbol": "btc_usdt",
        //                 "positionType": "ISOLATED",
        //                 "positionSide": "SHORT",
        //                 "contractType": "PERPETUAL",
        //                 "positionSize": "10",
        //                 "closeOrderSize": "0",
        //                 "availableCloseSize": "10",
        //                 "entryPrice": "27060",
        //                 "openOrderSize": "0",
        //                 "isolatedMargin": "1.0824",
        //                 "openOrderMarginFrozen": "0",
        //                 "realizedProfit": "-0.00130138",
        //                 "autoMargin": false,
        //                 "leverage": 25
        //             },
        //         ]
        //     }
        //
        object positions = this.safeValue(response, "result", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object entry = getValue(positions, i);
            object marketId = this.safeString(entry, "symbol");
            object marketInner = this.safeMarket(marketId, null, null, "contract");
            ((IList<object>)result).Add(this.parsePosition(entry, marketInner));
        }
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         "symbol": "btc_usdt",
        //         "positionType": "ISOLATED",
        //         "positionSide": "SHORT",
        //         "contractType": "PERPETUAL",
        //         "positionSize": "10",
        //         "closeOrderSize": "0",
        //         "availableCloseSize": "10",
        //         "entryPrice": "27060",
        //         "openOrderSize": "0",
        //         "isolatedMargin": "1.0824",
        //         "openOrderMarginFrozen": "0",
        //         "realizedProfit": "-0.00130138",
        //         "autoMargin": false,
        //         "leverage": 25
        //     }
        //
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market, null, "contract");
        object symbol = this.safeSymbol(marketId, market, null, "contract");
        object positionType = this.safeString(position, "positionType");
        object marginMode = ((bool) isTrue((isEqual(positionType, "CROSSED")))) ? "cross" : "isolated";
        object collateral = this.safeNumber(position, "isolatedMargin");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "hedged", null },
            { "side", this.safeStringLower(position, "positionSide") },
            { "contracts", this.safeNumber(position, "positionSize") },
            { "contractSize", getValue(market, "contractSize") },
            { "entryPrice", this.safeNumber(position, "entryPrice") },
            { "markPrice", null },
            { "notional", null },
            { "leverage", this.safeInteger(position, "leverage") },
            { "collateral", collateral },
            { "initialMargin", collateral },
            { "maintenanceMargin", null },
            { "initialMarginPercentage", null },
            { "maintenanceMarginPercentage", null },
            { "unrealizedPnl", null },
            { "liquidationPrice", null },
            { "marginMode", marginMode },
            { "percentage", null },
            { "marginRatio", null },
        });
    }

    /**
     * @method
     * @name xt#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://doc.xt.com/#transfersubTransferPost
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account to transfer from -  spot, swap, leverage, finance
     * @param {string} toAccount account to transfer to - spot, swap, leverage, finance
     * @param {object} params extra parameters specific to the whitebit api endpoint
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountsByType = this.safeValue(this.options, "accountsById");
        object fromAccountId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toAccountId = this.safeString(accountsByType, toAccount, toAccount);
        object amountString = this.currencyToPrecision(code, amount);
        object request = new Dictionary<string, object>() {
            { "bizId", this.uuid() },
            { "currency", getValue(currency, "id") },
            { "amount", amountString },
            { "from", fromAccountId },
            { "to", toAccountId },
        };
        object response = await this.privateSpotPostBalanceTransfer(this.extend(request, parameters));
        //
        //   {
        //       info: { rc: '0', mc: 'SUCCESS', ma: [], result: '226971333791398656' },
        //       id: '226971333791398656',
        //       timestamp: undefined,
        //       datetime: undefined,
        //       currency: undefined,
        //       amount: undefined,
        //       fromAccount: undefined,
        //       toAccount: undefined,
        //       status: undefined
        //   }
        //
        return this.parseTransfer(response, currency);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", this.safeString(transfer, "result") },
            { "timestamp", null },
            { "datetime", null },
            { "currency", null },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", null },
        };
    }

    /**
     * @method
     * @name xt#setMarginMode
     * @description set margin mode to 'cross' or 'isolated'
     * @see https://doc.xt.com/#futures_userchangePositionType
     * @param {string} marginMode 'cross' or 'isolated'
     * @param {string} [symbol] required
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.positionSide] *required* "long" or "short"
     * @returns {object} response from the exchange
     */
    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(getValue(market, "spot")))
        {
            throw new BadSymbol ((string)add(this.id, " setMarginMode() supports contract markets only")) ;
        }
        marginMode = ((string)marginMode).ToLower();
        if (isTrue(isTrue(!isEqual(marginMode, "isolated")) && isTrue(!isEqual(marginMode, "cross"))))
        {
            throw new BadRequest ((string)add(this.id, " setMarginMode() marginMode argument should be isolated or cross")) ;
        }
        if (isTrue(isEqual(marginMode, "cross")))
        {
            marginMode = "CROSSED";
        } else
        {
            marginMode = "ISOLATED";
        }
        object posSide = this.safeStringUpper(parameters, "positionSide");
        if (isTrue(isEqual(posSide, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a positionSide parameter, either \"LONG\" or \"SHORT\"")) ;
        }
        object request = new Dictionary<string, object>() {
            { "positionType", marginMode },
            { "positionSide", posSide },
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateLinearPostFutureUserV1PositionChangeType(this.extend(request, parameters));
        //
        // {
        //     "error": {
        //       "code": "",
        //       "msg": ""
        //     },
        //     "msgInfo": "",
        //     "result": {},
        //     "returnCode": 0
        // }
        //
        return response;  // unify return type
    }

    /**
     * @method
     * @name xt#editOrder
     * @description cancels an order and places a new order
     * @see https://doc.xt.com/#orderorderUpdate
     * @see https://doc.xt.com/#futures_orderupdate
     * @see https://doc.xt.com/#futures_entrustupdateProfit
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of the currency you want to trade in units of the base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.stopLoss] price to set a stop-loss on an open position
     * @param {float} [params.takeProfit] price to set a take-profit on an open position
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(amount, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " editOrder() requires an amount argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        object stopLoss = this.safeNumber2(parameters, "stopLoss", "triggerStopPrice");
        object takeProfit = this.safeNumber2(parameters, "takeProfit", "triggerProfitPrice");
        parameters = this.omit(parameters, new List<object>() {"stopLoss", "takeProfit"});
        object isStopLoss = (!isEqual(stopLoss, null));
        object isTakeProfit = (!isEqual(takeProfit, null));
        if (isTrue(isTrue(isStopLoss) || isTrue(isTakeProfit)))
        {
            ((IDictionary<string,object>)request)["profitId"] = id;
        } else
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            if (isTrue(isStopLoss))
            {
                ((IDictionary<string,object>)request)["triggerStopPrice"] = this.priceToPrecision(symbol, stopLoss);
            } else if (isTrue(!isEqual(takeProfit, null)))
            {
                ((IDictionary<string,object>)request)["triggerProfitPrice"] = this.priceToPrecision(symbol, takeProfit);
            } else
            {
                ((IDictionary<string,object>)request)["origQty"] = this.amountToPrecision(symbol, amount);
            }
            object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("editOrder", market, parameters);
            subType = ((IList<object>)subTypeparametersVariable)[0];
            parameters = ((IList<object>)subTypeparametersVariable)[1];
            if (isTrue(isEqual(subType, "inverse")))
            {
                if (isTrue(isTrue(isStopLoss) || isTrue(isTakeProfit)))
                {
                    response = await this.privateInversePostFutureTradeV1EntrustUpdateProfitStop(this.extend(request, parameters));
                } else
                {
                    response = await this.privateInversePostFutureTradeV1OrderUpdate(this.extend(request, parameters));
                }
            } else
            {
                if (isTrue(isTrue(isStopLoss) || isTrue(isTakeProfit)))
                {
                    response = await this.privateLinearPostFutureTradeV1EntrustUpdateProfitStop(this.extend(request, parameters));
                } else
                {
                    response = await this.privateLinearPostFutureTradeV1OrderUpdate(this.extend(request, parameters));
                }
            }
        } else
        {
            ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
            response = await this.privateSpotPutOrderOrderId(this.extend(request, parameters));
        }
        object result = ((bool) isTrue((getValue(market, "swap")))) ? response : this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(result, market);
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        //
        // spot: error
        //
        //     {
        //         "rc": 1,
        //         "mc": "AUTH_103",
        //         "ma": [],
        //         "result": null
        //     }
        //
        // spot: success
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": []
        //     }
        //
        // swap and future: error
        //
        //     {
        //         "returnCode": 1,
        //         "msgInfo": "failure",
        //         "error": {
        //             "code": "403",
        //             "msg": "invalid signature"
        //         },
        //         "result": null
        //     }
        //
        // swap and future: success
        //
        //     {
        //         "returnCode": 0,
        //         "msgInfo": "success",
        //         "error": null,
        //         "result": null
        //     }
        //
        // other:
        //
        //     {
        //         "rc": 0,
        //         "mc": "SUCCESS",
        //         "ma": [],
        //         "result": {}
        //     }
        //
        // {"returnCode":1,"msgInfo":"failure","error":{"code":"insufficient_balance","msg":"insufficient balance","args":[]},"result":null}
        //
        //
        object status = this.safeStringUpper2(response, "msgInfo", "mc");
        if (isTrue(isTrue(!isEqual(status, null)) && isTrue(!isEqual(status, "SUCCESS"))))
        {
            object feedback = add(add(this.id, " "), body);
            object error = this.safeValue(response, "error", new Dictionary<string, object>() {});
            object spotErrorCode = this.safeString(response, "mc");
            object errorCode = this.safeString(error, "code", spotErrorCode);
            object spotMessage = this.safeString(response, "msgInfo");
            object message = this.safeString(error, "msg", spotMessage);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= new List<object>();
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object signed = isEqual(getValue(api, 0), "private");
        object endpoint = getValue(api, 1);
        object request = add("/", this.implodeParams(path, parameters));
        object payload = null;
        if (isTrue(isTrue((isEqual(endpoint, "spot"))) || isTrue((isEqual(endpoint, "user")))))
        {
            if (isTrue(signed))
            {
                payload = add(add("/", this.version), request);
            } else
            {
                payload = add(add(add("/", this.version), "/public"), request);
            }
        } else
        {
            payload = request;
        }
        object url = add(getValue(getValue(this.urls, "api"), endpoint), payload);
        object query = this.omit(parameters, this.extractParams(path));
        object urlencoded = this.urlencode(this.keysort(query));
        headers = new Dictionary<string, object>() {
            { "Content-Type", "application/json" },
        };
        if (isTrue(signed))
        {
            this.checkRequiredCredentials();
            object defaultRecvWindow = this.safeString(this.options, "recvWindow");
            object recvWindow = this.safeString(query, "recvWindow", defaultRecvWindow);
            object timestamp = this.numberToString(this.nonce());
            body = query;
            if (isTrue(isTrue(isTrue(isTrue(isTrue((isEqual(payload, "/v4/order"))) || isTrue((isEqual(payload, "/future/trade/v1/order/create")))) || isTrue((isEqual(payload, "/future/trade/v1/entrust/create-plan")))) || isTrue((isEqual(payload, "/future/trade/v1/entrust/create-profit")))) || isTrue((isEqual(payload, "/future/trade/v1/order/create-batch")))))
            {
                object id = "CCXT";
                if (isTrue(isGreaterThan(getIndexOf(payload, "future"), -1)))
                {
                    ((IDictionary<string,object>)body)["clientMedia"] = id;
                } else
                {
                    ((IDictionary<string,object>)body)["media"] = id;
                }
            }
            object isUndefinedBody = (isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(path, "order/{orderId}")))) || isTrue((isEqual(path, "ws-token"))));
            if (isTrue(isTrue((isEqual(method, "PUT"))) && isTrue((isEqual(endpoint, "spot")))))
            {
                isUndefinedBody = false;
            }
            body = ((bool) isTrue(isUndefinedBody)) ? null : this.json(body);
            object payloadString = null;
            if (isTrue(isTrue((isEqual(endpoint, "spot"))) || isTrue((isEqual(endpoint, "user")))))
            {
                payloadString = add(add(add(add(add(add("xt-validate-algorithms=HmacSHA256&xt-validate-appkey=", this.apiKey), "&xt-validate-recvwindow="), recvWindow), "&xt-validate-t"), "imestamp="), timestamp);
                if (isTrue(isUndefinedBody))
                {
                    if (isTrue(urlencoded))
                    {
                        url = add(url, add("?", urlencoded));
                        payloadString = add(payloadString, add(add(add(add(add("#", method), "#"), payload), "#"), this.rawencode(this.keysort(query))));
                    } else
                    {
                        payloadString = add(payloadString, add(add(add("#", method), "#"), payload));
                    }
                } else
                {
                    payloadString = add(payloadString, add(add(add(add(add("#", method), "#"), payload), "#"), body));
                }
                ((IDictionary<string,object>)headers)["xt-validate-algorithms"] = "HmacSHA256";
                ((IDictionary<string,object>)headers)["xt-validate-recvwindow"] = recvWindow;
            } else
            {
                payloadString = add(add(add(add("xt-validate-appkey=", this.apiKey), "&xt-validate-t"), "imestamp="), timestamp); // we can't glue timestamp, breaks in php
                if (isTrue(isEqual(method, "GET")))
                {
                    if (isTrue(urlencoded))
                    {
                        url = add(url, add("?", urlencoded));
                        payloadString = add(payloadString, add(add(add("#", payload), "#"), urlencoded));
                    } else
                    {
                        payloadString = add(payloadString, add("#", payload));
                    }
                } else
                {
                    payloadString = add(payloadString, add(add(add("#", payload), "#"), body));
                }
            }
            object signature = this.hmac(this.encode(payloadString), this.encode(this.secret), sha256);
            ((IDictionary<string,object>)headers)["xt-validate-appkey"] = this.apiKey;
            ((IDictionary<string,object>)headers)["xt-validate-timestamp"] = timestamp;
            ((IDictionary<string,object>)headers)["xt-validate-signature"] = signature;
        } else
        {
            if (isTrue(urlencoded))
            {
                url = add(url, add("?", urlencoded));
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }
}
