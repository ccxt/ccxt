namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class btcmarkets : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "btcmarkets" },
            { "name", "BTC Markets" },
            { "countries", new List<object>() {"AU"} },
            { "rateLimit", 1000 },
            { "version", "v3" },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createDepositAddress", false },
                { "createOrder", true },
                { "createReduceOnlyOrder", false },
                { "fetchBalance", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchClosedOrders", "emulated" },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchDepositAddress", false },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLeverage", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchPosition", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTransactions", "emulated" },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "withdraw", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/51840849/89731817-b3fb8480-da52-11ea-817f-783b08aaf32b.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.btcmarkets.net" },
                    { "private", "https://api.btcmarkets.net" },
                } },
                { "www", "https://btcmarkets.net" },
                { "doc", new List<object>() {"https://api.btcmarkets.net/doc/v3", "https://github.com/BTCMarkets/API"} },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"markets", "markets/{marketId}/ticker", "markets/{marketId}/trades", "markets/{marketId}/orderbook", "markets/{marketId}/candles", "markets/tickers", "markets/orderbooks", "time"} },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new List<object>() {"orders", "orders/{id}", "batchorders/{ids}", "trades", "trades/{id}", "withdrawals", "withdrawals/{id}", "deposits", "deposits/{id}", "transfers", "transfers/{id}", "addresses", "withdrawal-fees", "assets", "accounts/me/trading-fees", "accounts/me/withdrawal-limits", "accounts/me/balances", "accounts/me/transactions", "reports/{id}"} },
                    { "post", new List<object>() {"orders", "batchorders", "withdrawals", "reports"} },
                    { "delete", new List<object>() {"orders", "orders/{id}", "batchorders/{ids}"} },
                    { "put", new List<object>() {"orders/{id}"} },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "1h", "1h" },
                { "1d", "1d" },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "3", typeof(InvalidOrder) },
                { "6", typeof(DDoSProtection) },
                { "InsufficientFund", typeof(InsufficientFunds) },
                { "InvalidPrice", typeof(InvalidOrder) },
                { "InvalidAmount", typeof(InvalidOrder) },
                { "MissingArgument", typeof(InvalidOrder) },
                { "OrderAlreadyCancelled", typeof(InvalidOrder) },
                { "OrderNotFound", typeof(OrderNotFound) },
                { "OrderStatusIsFinal", typeof(InvalidOrder) },
                { "InvalidPaginationParameter", typeof(BadRequest) },
            } },
            { "fees", new Dictionary<string, object>() {
                { "percentage", true },
                { "tierBased", true },
                { "maker", this.parseNumber("-0.0005") },
                { "taker", this.parseNumber("0.0020") },
            } },
            { "options", new Dictionary<string, object>() {
                { "fees", new Dictionary<string, object>() {
                    { "AUD", new Dictionary<string, object>() {
                        { "maker", this.parseNumber("0.0085") },
                        { "taker", this.parseNumber("0.0085") },
                    } },
                } },
            } },
        });
    }

    public async virtual Task<object> fetchTransactionsWithMethod(object method, object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["after"] = since;
        }
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        return this.parseTransactions(response, currency, since, limit);
    }

    public async override Task<object> fetchDepositsWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name btcmarkets#fetchDepositsWithdrawals
        * @description fetch history of deposits and withdrawals
        * @see https://docs.btcmarkets.net/v3/#tag/Fund-Management-APIs/paths/~1v3~1transfers/get
        * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
        * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
        * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsWithMethod("privateGetTransfers", code, since, limit, parameters);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name btcmarkets#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://docs.btcmarkets.net/v3/#tag/Fund-Management-APIs/paths/~1v3~1deposits/get
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsWithMethod("privateGetDeposits", code, since, limit, parameters);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name btcmarkets#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://docs.btcmarkets.net/v3/#tag/Fund-Management-APIs/paths/~1v3~1withdrawals/get
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsWithMethod("privateGetWithdrawals", code, since, limit, parameters);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "Accepted", "pending" },
            { "Pending Authorization", "pending" },
            { "Complete", "ok" },
            { "Cancelled", "cancelled" },
            { "Failed", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseTransactionType(object type)
    {
        object statuses = new Dictionary<string, object>() {
            { "Withdraw", "withdrawal" },
            { "Deposit", "deposit" },
        };
        return this.safeString(statuses, type, type);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        //    {
        //         "id": "6500230339",
        //         "assetName": "XRP",
        //         "amount": "500",
        //         "type": "Deposit",
        //         "creationTime": "2020-07-27T07:52:08.640000Z",
        //         "status": "Complete",
        //         "description": "RIPPLE Deposit, XRP 500",
        //         "fee": "0",
        //         "lastUpdate": "2020-07-27T07:52:08.665000Z",
        //         "paymentDetail": {
        //             "txId": "lsjflsjdfljsd",
        //             "address": "kjasfkjsdf?dt=873874545"
        //         }
        //    }
        //
        //    {
        //         "id": "500985282",
        //         "assetName": "BTC",
        //         "amount": "0.42570126",
        //         "type": "Withdraw",
        //         "creationTime": "2017-07-29T12:49:03.931000Z",
        //         "status": "Complete",
        //         "description": "BTC withdraw from [nick-btcmarkets@snowmonkey.co.uk] to Address: 1B9DsnSYQ54VMqFHVJYdGoLMCYzFwrQzsj amount: 0.42570126 fee: 0.00000000",
        //         "fee": "0.0005",
        //         "lastUpdate": "2017-07-29T12:52:20.676000Z",
        //         "paymentDetail": {
        //             "txId": "fkjdsfjsfljsdfl",
        //             "address": "a;daddjas;djas"
        //         }
        //    }
        //
        //    {
        //         "id": "505102262",
        //         "assetName": "XRP",
        //         "amount": "979.836",
        //         "type": "Deposit",
        //         "creationTime": "2017-07-31T08:50:01.053000Z",
        //         "status": "Complete",
        //         "description": "Ripple Deposit, X 979.8360",
        //         "fee": "0",
        //         "lastUpdate": "2017-07-31T08:50:01.290000Z"
        //     }
        //
        object timestamp = this.parse8601(this.safeString(transaction, "creationTime"));
        object lastUpdate = this.parse8601(this.safeString(transaction, "lastUpdate"));
        object type = this.parseTransactionType(this.safeStringLower(transaction, "type"));
        if (isTrue(isEqual(type, "withdraw")))
        {
            type = "withdrawal";
        }
        object cryptoPaymentDetail = this.safeValue(transaction, "paymentDetail", new Dictionary<string, object>() {});
        object txid = this.safeString(cryptoPaymentDetail, "txId");
        object address = this.safeString(cryptoPaymentDetail, "address");
        object tag = null;
        if (isTrue(!isEqual(address, null)))
        {
            object addressParts = ((string)address).Split(new [] {((string)"?dt=")}, StringSplitOptions.None).ToList<object>();
            object numParts = getArrayLength(addressParts);
            if (isTrue(isGreaterThan(numParts, 1)))
            {
                address = getValue(addressParts, 0);
                tag = getValue(addressParts, 1);
            }
        }
        object addressTo = address;
        object tagTo = tag;
        object addressFrom = null;
        object tagFrom = null;
        object fee = this.safeString(transaction, "fee");
        object status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        object currencyId = this.safeString(transaction, "assetName");
        object code = this.safeCurrencyCode(currencyId);
        object amount = this.safeString(transaction, "amount");
        if (isTrue(fee))
        {
            amount = Precise.stringSub(amount, fee);
        }
        return new Dictionary<string, object>() {
            { "id", this.safeString(transaction, "id") },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", null },
            { "address", address },
            { "addressTo", addressTo },
            { "addressFrom", addressFrom },
            { "tag", tag },
            { "tagTo", tagTo },
            { "tagFrom", tagFrom },
            { "type", type },
            { "amount", this.parseNumber(amount) },
            { "currency", code },
            { "status", status },
            { "updated", lastUpdate },
            { "comment", this.safeString(transaction, "description") },
            { "internal", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", this.parseNumber(fee) },
                { "rate", null },
            } },
            { "info", transaction },
        };
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name btcmarkets#fetchMarkets
        * @description retrieves data on all markets for btcmarkets
        * @see https://docs.btcmarkets.net/v3/#tag/Market-Data-APIs/paths/~1v3~1markets/get
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetMarkets(parameters);
        //
        //     [
        //         {
        //             "marketId":"COMP-AUD",
        //             "baseAssetName":"COMP",
        //             "quoteAssetName":"AUD",
        //             "minOrderAmount":"0.00007",
        //             "maxOrderAmount":"1000000",
        //             "amountDecimals":"8",
        //             "priceDecimals":"2"
        //         }
        //     ]
        //
        return this.parseMarkets(response);
    }

    public override object parseMarket(object market)
    {
        object baseId = this.safeString(market, "baseAssetName");
        object quoteId = this.safeString(market, "quoteAssetName");
        object id = this.safeString(market, "marketId");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(bs, "/"), quote);
        object fees = this.safeValue(this.safeValue(this.options, "fees", new Dictionary<string, object>() {}), quote, this.fees);
        object pricePrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "priceDecimals")));
        object minAmount = this.safeNumber(market, "minOrderAmount");
        object maxAmount = this.safeNumber(market, "maxOrderAmount");
        object minPrice = null;
        if (isTrue(isEqual(quote, "AUD")))
        {
            minPrice = pricePrecision;
        }
        return new Dictionary<string, object>() {
            { "id", id },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", null },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", null },
            { "type", "spot" },
            { "spot", true },
            { "margin", false },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "active", null },
            { "contract", false },
            { "linear", null },
            { "inverse", null },
            { "taker", getValue(fees, "taker") },
            { "maker", getValue(fees, "maker") },
            { "contractSize", null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "amountDecimals"))) },
                { "price", pricePrecision },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", minAmount },
                    { "max", maxAmount },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", minPrice },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        };
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name btcmarkets#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @see https://docs.btcmarkets.net/v3/#tag/Misc-APIs/paths/~1v3~1time/get
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetTime(parameters);
        //
        //     {
        //         "timestamp": "2019-09-01T18:34:27.045000Z"
        //     }
        //
        return this.parse8601(this.safeString(response, "timestamp"));
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object balance = getValue(response, i);
            object currencyId = this.safeString(balance, "assetName");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "locked");
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "balance");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name btcmarkets#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://docs.btcmarkets.net/v3/#tag/Account-APIs/paths/~1v3~1accounts~1me~1balances/get
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetAccountsMeBalances(parameters);
        return this.parseBalance(response);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         "2020-09-12T18:30:00.000000Z",
        //         "14409.45", // open
        //         "14409.45", // high
        //         "14403.91", // low
        //         "14403.91", // close
        //         "0.01571701" // volume
        //     ]
        //
        return new List<object> {this.parse8601(this.safeString(ohlcv, 0)), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name btcmarkets#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://docs.btcmarkets.net/v3/#tag/Market-Data-APIs/paths/~1v3~1markets~1{marketId}~1candles/get
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "marketId", getValue(market, "id") },
            { "timeWindow", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default is 10, max 200
        }
        object response = await this.publicGetMarketsMarketIdCandles(this.extend(request, parameters));
        //
        //     [
        //         ["2020-09-12T18:30:00.000000Z","14409.45","14409.45","14403.91","14403.91","0.01571701"],
        //         ["2020-09-12T18:21:00.000000Z","14409.45","14409.45","14409.45","14409.45","0.0035"],
        //         ["2020-09-12T18:03:00.000000Z","14361.37","14361.37","14361.37","14361.37","0.00345221"],
        //     ]
        //
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name btcmarkets#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://docs.btcmarkets.net/v3/#tag/Market-Data-APIs/paths/~1v3~1markets~1{marketId}~1orderbook/get
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "marketId", getValue(market, "id") },
        };
        object response = await this.publicGetMarketsMarketIdOrderbook(this.extend(request, parameters));
        //
        //     {
        //         "marketId":"BTC-AUD",
        //         "snapshotId":1599936148941000,
        //         "asks":[
        //             ["14459.45","0.00456475"],
        //             ["14463.56","2"],
        //             ["14470.91","0.98"],
        //         ],
        //         "bids":[
        //             ["14421.01","0.52"],
        //             ["14421","0.75"],
        //             ["14418","0.3521"],
        //         ]
        //     }
        //
        object timestamp = this.safeIntegerProduct(response, "snapshotId", 0.001);
        object orderbook = this.parseOrderBook(response, symbol, timestamp);
        ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger(response, "snapshotId");
        return orderbook;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // fetchTicker
        //
        //     {
        //         "marketId":"BAT-AUD",
        //         "bestBid":"0.3751",
        //         "bestAsk":"0.377",
        //         "lastPrice":"0.3769",
        //         "volume24h":"56192.97613335",
        //         "volumeQte24h":"21179.13270465",
        //         "price24h":"0.0119",
        //         "pricePct24h":"3.26",
        //         "low24h":"0.3611",
        //         "high24h":"0.3799",
        //         "timestamp":"2020-08-09T18:28:23.280000Z"
        //     }
        //
        object marketId = this.safeString(ticker, "marketId");
        market = this.safeMarket(marketId, market, "-");
        object symbol = getValue(market, "symbol");
        object timestamp = this.parse8601(this.safeString(ticker, "timestamp"));
        object last = this.safeString(ticker, "lastPrice");
        object baseVolume = this.safeString(ticker, "volume24h");
        object quoteVolume = this.safeString(ticker, "volumeQte24h");
        object change = this.safeString(ticker, "price24h");
        object percentage = this.safeString(ticker, "pricePct24h");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high24h") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(ticker, "bestBid") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "bestAsk") },
            { "askVolume", null },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", change },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name btcmarkets#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://docs.btcmarkets.net/v3/#tag/Market-Data-APIs/paths/~1v3~1markets~1{marketId}~1ticker/get
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "marketId", getValue(market, "id") },
        };
        object response = await this.publicGetMarketsMarketIdTicker(this.extend(request, parameters));
        //
        //     {
        //         "marketId":"BAT-AUD",
        //         "bestBid":"0.3751",
        //         "bestAsk":"0.377",
        //         "lastPrice":"0.3769",
        //         "volume24h":"56192.97613335",
        //         "volumeQte24h":"21179.13270465",
        //         "price24h":"0.0119",
        //         "pricePct24h":"3.26",
        //         "low24h":"0.3611",
        //         "high24h":"0.3799",
        //         "timestamp":"2020-08-09T18:28:23.280000Z"
        //     }
        //
        return this.parseTicker(response, market);
    }

    public async virtual Task<object> fetchTicker2(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "id", getValue(market, "id") },
        };
        object response = await this.publicGetMarketsMarketIdTicker(this.extend(request, parameters));
        return this.parseTicker(response, market);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public fetchTrades
        //
        //     {
        //         "id":"6191646611",
        //         "price":"539.98",
        //         "amount":"0.5",
        //         "timestamp":"2020-08-09T15:21:05.016000Z",
        //         "side":"Ask"
        //     }
        //
        // private fetchMyTrades
        //
        //     {
        //         "id": "36014819",
        //         "marketId": "XRP-AUD",
        //         "timestamp": "2019-06-25T16:01:02.977000Z",
        //         "price": "0.67",
        //         "amount": "1.50533262",
        //         "side": "Ask",
        //         "fee": "0.00857285",
        //         "orderId": "3648306",
        //         "liquidityType": "Taker",
        //         "clientOrderId": "48"
        //     }
        //
        object timestamp = this.parse8601(this.safeString(trade, "timestamp"));
        object marketId = this.safeString(trade, "marketId");
        market = this.safeMarket(marketId, market, "-");
        object feeCurrencyCode = ((bool) isTrue((isEqual(getValue(market, "quote"), "AUD")))) ? getValue(market, "quote") : getValue(market, "base");
        object side = this.safeString(trade, "side");
        if (isTrue(isEqual(side, "Bid")))
        {
            side = "buy";
        } else if (isTrue(isEqual(side, "Ask")))
        {
            side = "sell";
        }
        object id = this.safeString(trade, "id");
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString(trade, "amount");
        object orderId = this.safeString(trade, "orderId");
        object fee = null;
        object feeCostString = this.safeString(trade, "fee");
        if (isTrue(!isEqual(feeCostString, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", feeCurrencyCode },
            };
        }
        object takerOrMaker = this.safeStringLower(trade, "liquidityType");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "order", orderId },
            { "symbol", getValue(market, "symbol") },
            { "type", null },
            { "side", side },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "takerOrMaker", takerOrMaker },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name btcmarkets#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://docs.btcmarkets.net/v3/#tag/Market-Data-APIs/paths/~1v3~1markets~1{marketId}~1trades/get
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "marketId", getValue(market, "id") },
        };
        object response = await this.publicGetMarketsMarketIdTrades(this.extend(request, parameters));
        //
        //     [
        //         {"id":"6191646611","price":"539.98","amount":"0.5","timestamp":"2020-08-09T15:21:05.016000Z","side":"Ask"},
        //         {"id":"6191646610","price":"539.99","amount":"0.5","timestamp":"2020-08-09T15:21:05.015000Z","side":"Ask"},
        //         {"id":"6191646590","price":"540","amount":"0.00233785","timestamp":"2020-08-09T15:21:04.171000Z","side":"Bid"},
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name btcmarkets#createOrder
        * @description create a trade order
        * @see https://docs.btcmarkets.net/v3/#tag/Order-Placement-APIs/paths/~1v3~1orders/post
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "marketId", getValue(market, "id") },
            { "amount", this.amountToPrecision(symbol, amount) },
            { "side", ((bool) isTrue((isEqual(side, "buy")))) ? "Bid" : "Ask" },
        };
        object lowercaseType = ((string)type).ToLower();
        object orderTypes = this.safeValue(this.options, "orderTypes", new Dictionary<string, object>() {
            { "limit", "Limit" },
            { "market", "Market" },
            { "stop", "Stop" },
            { "stop limit", "Stop Limit" },
            { "take profit", "Take Profit" },
        });
        ((IDictionary<string,object>)request)["type"] = this.safeString(orderTypes, lowercaseType, type);
        object priceIsRequired = false;
        object triggerPriceIsRequired = false;
        if (isTrue(isEqual(lowercaseType, "limit")))
        {
            priceIsRequired = true;
        } else if (isTrue(isEqual(lowercaseType, "stop limit")))
        {
            triggerPriceIsRequired = true;
            priceIsRequired = true;
        } else if (isTrue(isEqual(lowercaseType, "take profit")))
        {
            triggerPriceIsRequired = true;
        } else if (isTrue(isEqual(lowercaseType, "stop")))
        {
            triggerPriceIsRequired = true;
        }
        if (isTrue(priceIsRequired))
        {
            if (isTrue(isEqual(price, null)))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " createOrder() requires a price argument for a "), type), "order")) ;
            } else
            {
                ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            }
        }
        if (isTrue(triggerPriceIsRequired))
        {
            object triggerPrice = this.safeNumber(parameters, "triggerPrice");
            parameters = this.omit(parameters, "triggerPrice");
            if (isTrue(isEqual(triggerPrice, null)))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " createOrder() requires a triggerPrice parameter for a "), type), "order")) ;
            } else
            {
                ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
            }
        }
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientOrderId"] = clientOrderId;
        }
        parameters = this.omit(parameters, "clientOrderId");
        object response = await this.privatePostOrders(this.extend(request, parameters));
        //
        //     {
        //         "orderId": "7524",
        //         "marketId": "BTC-AUD",
        //         "side": "Bid",
        //         "type": "Limit",
        //         "creationTime": "2019-08-30T11:08:21.956000Z",
        //         "price": "100.12",
        //         "amount": "1.034",
        //         "openAmount": "1.034",
        //         "status": "Accepted",
        //         "clientOrderId": "1234-5678",
        //         "timeInForce": "IOC",
        //         "postOnly": false,
        //         "selfTrade": "P",
        //         "triggerAmount": "105",
        //         "targetAmount": "1000"
        //     }
        //
        return this.parseOrder(response, market);
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name btcmarkets#cancelOrders
        * @description cancel multiple orders
        * @see https://docs.btcmarkets.net/v3/#tag/Batch-Order-APIs/paths/~1v3~1batchorders~1{ids}/delete
        * @param {string[]} ids order ids
        * @param {string} symbol not used by btcmarkets cancelOrders ()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            ((List<object>)ids)[Convert.ToInt32(i)] = parseInt(getValue(ids, i));
        }
        object request = new Dictionary<string, object>() {
            { "ids", ids },
        };
        return await this.privateDeleteBatchordersIds(this.extend(request, parameters));
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name btcmarkets#cancelOrder
        * @description cancels an open order
        * @see https://docs.btcmarkets.net/v3/#operation/cancelOrder
        * @param {string} id order id
        * @param {string} symbol not used by btcmarket cancelOrder ()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        return await this.privateDeleteOrdersId(this.extend(request, parameters));
    }

    public override object calculateFee(object symbol, object type, object side, object amount, object price, object takerOrMaker = null, object parameters = null)
    {
        /**
        * @method
        * @description calculates the presumptive fee that would be charged for an order
        * @param {string} symbol unified market symbol
        * @param {string} type not used by btcmarkets.calculateFee
        * @param {string} side not used by btcmarkets.calculateFee
        * @param {float} amount how much you want to trade, in units of the base currency on most exchanges, or number of contracts
        * @param {float} price the price for the order to be filled at, in units of the quote currency
        * @param {string} takerOrMaker 'taker' or 'maker'
        * @param {object} params
        * @returns {object} contains the rate, the percentage multiplied to the order amount to obtain the fee amount, and cost, the total value of the fee in units of the quote currency, for the order
        */
        takerOrMaker ??= "taker";
        parameters ??= new Dictionary<string, object>();
        object market = getValue(this.markets, symbol);
        object currency = null;
        object cost = null;
        if (isTrue(isEqual(getValue(market, "quote"), "AUD")))
        {
            currency = getValue(market, "quote");
            object amountString = this.numberToString(amount);
            object priceString = this.numberToString(price);
            object otherUnitsAmount = Precise.stringMul(amountString, priceString);
            cost = this.costToPrecision(symbol, otherUnitsAmount);
        } else
        {
            currency = getValue(market, "base");
            cost = this.amountToPrecision(symbol, amount);
        }
        object rate = getValue(market, takerOrMaker);
        object rateCost = Precise.stringMul(this.numberToString(rate), cost);
        return new Dictionary<string, object>() {
            { "type", takerOrMaker },
            { "currency", currency },
            { "rate", rate },
            { "cost", parseFloat(this.feeToPrecision(symbol, rateCost)) },
        };
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "Accepted", "open" },
            { "Placed", "open" },
            { "Partially Matched", "open" },
            { "Fully Matched", "closed" },
            { "Cancelled", "canceled" },
            { "Partially Cancelled", "canceled" },
            { "Failed", "rejected" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //
        //     {
        //         "orderId": "7524",
        //         "marketId": "BTC-AUD",
        //         "side": "Bid",
        //         "type": "Limit",
        //         "creationTime": "2019-08-30T11:08:21.956000Z",
        //         "price": "100.12",
        //         "amount": "1.034",
        //         "openAmount": "1.034",
        //         "status": "Accepted",
        //         "clientOrderId": "1234-5678",
        //         "timeInForce": "IOC",
        //         "postOnly": false,
        //         "selfTrade": "P",
        //         "triggerAmount": "105",
        //         "targetAmount": "1000"
        //     }
        //
        object timestamp = this.parse8601(this.safeString(order, "creationTime"));
        object marketId = this.safeString(order, "marketId");
        market = this.safeMarket(marketId, market, "-");
        object side = this.safeString(order, "side");
        if (isTrue(isEqual(side, "Bid")))
        {
            side = "buy";
        } else if (isTrue(isEqual(side, "Ask")))
        {
            side = "sell";
        }
        object type = this.safeStringLower(order, "type");
        object price = this.safeString(order, "price");
        object amount = this.safeString(order, "amount");
        object remaining = this.safeString(order, "openAmount");
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object id = this.safeString(order, "orderId");
        object clientOrderId = this.safeString(order, "clientOrderId");
        object timeInForce = this.safeString(order, "timeInForce");
        object stopPrice = this.safeNumber(order, "triggerPrice");
        object postOnly = this.safeValue(order, "postOnly");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "cost", null },
            { "amount", amount },
            { "filled", null },
            { "remaining", remaining },
            { "average", null },
            { "status", status },
            { "trades", null },
            { "fee", null },
        }, market);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name btcmarkets#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://docs.btcmarkets.net/v3/#operation/getOrderById
        * @param {string} symbol not used by btcmarkets fetchOrder
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object response = await this.privateGetOrdersId(this.extend(request, parameters));
        return this.parseOrder(response);
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name btcmarkets#fetchOrders
        * @description fetches information on multiple orders made by the user
        * @see https://docs.btcmarkets.net/v3/#operation/listOrders
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "status", "all" },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["marketId"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["after"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetOrders(this.extend(request, parameters));
        return this.parseOrders(response, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name btcmarkets#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://docs.btcmarkets.net/v3/#operation/listOrders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "status", "open" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name btcmarkets#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://docs.btcmarkets.net/v3/#operation/listOrders
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object orders = await this.fetchOrders(symbol, since, limit, parameters);
        return this.filterBy(orders, "status", "closed");
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name btcmarkets#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://docs.btcmarkets.net/v3/#operation/getTrades
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["marketId"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["after"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetTrades(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "id": "36014819",
        //             "marketId": "XRP-AUD",
        //             "timestamp": "2019-06-25T16:01:02.977000Z",
        //             "price": "0.67",
        //             "amount": "1.50533262",
        //             "side": "Ask",
        //             "fee": "0.00857285",
        //             "orderId": "3648306",
        //             "liquidityType": "Taker",
        //             "clientOrderId": "48"
        //         },
        //         {
        //             "id": "3568960",
        //             "marketId": "GNT-AUD",
        //             "timestamp": "2019-06-20T08:44:04.488000Z",
        //             "price": "0.1362",
        //             "amount": "0.85",
        //             "side": "Bid",
        //             "fee": "0.00098404",
        //             "orderId": "3543015",
        //             "liquidityType": "Maker"
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name btcmarkets#withdraw
        * @description make a withdrawal
        * @see https://docs.btcmarkets.net/v3/#tag/Fund-Management-APIs/paths/~1v3~1withdrawals/post
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency_id", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        if (isTrue(!isEqual(code, "AUD")))
        {
            this.checkAddress(address);
            ((IDictionary<string,object>)request)["toAddress"] = address;
        }
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["toAddress"] = add(add(address, "?dt="), tag);
        }
        object response = await this.privatePostWithdrawals(this.extend(request, parameters));
        //
        //      {
        //          "id": "4126657",
        //          "assetName": "XRP",
        //          "amount": "25",
        //          "type": "Withdraw",
        //          "creationTime": "2019-09-04T00:04:10.973000Z",
        //          "status": "Pending Authorization",
        //          "description": "XRP withdraw from [me@test.com] to Address: abc amount: 25 fee: 0",
        //          "fee": "0",
        //          "lastUpdate": "2019-09-04T00:04:11.018000Z",
        //          "paymentDetail": {
        //              "address": "abc"
        //          }
        //      }
        //
        return this.parseTransaction(response, currency);
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object request = add(add(add("/", this.version), "/"), this.implodeParams(path, parameters));
        object query = this.keysort(this.omit(parameters, this.extractParams(path)));
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object nonce = ((object)this.nonce()).ToString();
            object secret = this.base64ToBinary(this.secret);
            object auth = add(add(method, request), nonce);
            if (isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE")))))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    request = add(request, add("?", this.urlencode(query)));
                }
            } else
            {
                body = this.json(query);
                auth = add(auth, body);
            }
            object signature = this.hmac(this.encode(auth), secret, sha512, "base64");
            headers = new Dictionary<string, object>() {
                { "Accept", "application/json" },
                { "Accept-Charset", "UTF-8" },
                { "Content-Type", "application/json" },
                { "BM-AUTH-APIKEY", this.apiKey },
                { "BM-AUTH-TIMESTAMP", nonce },
                { "BM-AUTH-SIGNATURE", signature },
            };
        } else if (isTrue(isEqual(api, "public")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                request = add(request, add("?", this.urlencode(query)));
            }
        }
        object url = add(getValue(getValue(this.urls, "api"), api), request);
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        if (isTrue(inOp(response, "success")))
        {
            if (!isTrue(getValue(response, "success")))
            {
                object error = this.safeString(response, "errorCode");
                object feedback = add(add(this.id, " "), body);
                this.throwExactlyMatchedException(this.exceptions, error, feedback);
                throw new ExchangeError ((string)feedback) ;
            }
        }
        // v3 api errors
        if (isTrue(isGreaterThanOrEqual(code, 400)))
        {
            object errorCode = this.safeString(response, "code");
            object message = this.safeString(response, "message");
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(this.exceptions, errorCode, feedback);
            this.throwExactlyMatchedException(this.exceptions, message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
