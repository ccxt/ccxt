namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class bigone : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bigone" },
            { "name", "BigONE" },
            { "countries", new List<object>() {"CN"} },
            { "version", "v3" },
            { "rateLimit", 20 },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", true },
                { "future", null },
                { "option", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createPostOnlyOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "fetchBalance", true },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchMarkets", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTransactionFees", false },
                { "fetchWithdrawals", true },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "min1" },
                { "5m", "min5" },
                { "15m", "min15" },
                { "30m", "min30" },
                { "1h", "hour1" },
                { "3h", "hour3" },
                { "4h", "hour4" },
                { "6h", "hour6" },
                { "12h", "hour12" },
                { "1d", "day1" },
                { "1w", "week1" },
                { "1M", "month1" },
            } },
            { "hostname", "big.one" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/4e5cfd53-98cc-4b90-92cd-0d7b512653d1" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://{hostname}/api/v3" },
                    { "private", "https://{hostname}/api/v3/viewer" },
                    { "contractPublic", "https://{hostname}/api/contract/v2" },
                    { "contractPrivate", "https://{hostname}/api/contract/v2" },
                    { "webExchange", "https://{hostname}/api/" },
                } },
                { "www", "https://big.one" },
                { "doc", "https://open.big.one/docs/api.html" },
                { "fees", "https://bigone.zendesk.com/hc/en-us/articles/115001933374-BigONE-Fee-Policy" },
                { "referral", "https://b1.run/users/new?code=D3LLBVFT" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"ping", "asset_pairs", "asset_pairs/{asset_pair_name}/depth", "asset_pairs/{asset_pair_name}/trades", "asset_pairs/{asset_pair_name}/ticker", "asset_pairs/{asset_pair_name}/candles", "asset_pairs/tickers"} },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new List<object>() {"accounts", "fund/accounts", "assets/{asset_symbol}/address", "orders", "orders/{id}", "orders/multi", "trades", "withdrawals", "deposits"} },
                    { "post", new List<object>() {"orders", "orders/{id}/cancel", "orders/cancel", "withdrawals", "transfer"} },
                } },
                { "contractPublic", new Dictionary<string, object>() {
                    { "get", new List<object>() {"symbols", "instruments", "depth@{symbol}/snapshot", "instruments/difference", "instruments/prices"} },
                } },
                { "contractPrivate", new Dictionary<string, object>() {
                    { "get", new List<object>() {"accounts", "orders/{id}", "orders", "orders/opening", "orders/count", "orders/opening/count", "trades", "trades/count"} },
                    { "post", new List<object>() {"orders", "orders/batch"} },
                    { "put", new List<object>() {"positions/{symbol}/margin", "positions/{symbol}/risk-limit"} },
                    { "delete", new List<object>() {"orders/{id}", "orders/batch"} },
                } },
                { "webExchange", new Dictionary<string, object>() {
                    { "get", new List<object>() {"v3/assets"} },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "maker", this.parseNumber("0.001") },
                    { "taker", this.parseNumber("0.001") },
                } },
                { "funding", new Dictionary<string, object>() {
                    { "withdraw", new Dictionary<string, object>() {} },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "createMarketBuyOrderRequiresPrice", true },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "SPOT" },
                    { "fund", "FUND" },
                    { "funding", "FUND" },
                    { "future", "CONTRACT" },
                    { "swap", "CONTRACT" },
                } },
                { "transfer", new Dictionary<string, object>() {
                    { "fillResponseFromRequest", true },
                } },
                { "exchangeMillisecondsCorrection", -100 },
                { "fetchCurrencies", new Dictionary<string, object>() {
                    { "webApiEnable", true },
                    { "webApiRetries", 5 },
                    { "webApiMuteFailure", true },
                } },
                { "defaultNetwork", "ERC20" },
                { "defaultNetworks", new Dictionary<string, object>() {
                    { "USDT", "TRC20" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "ABBC", "ABBC" },
                    { "ACA", "Acala" },
                    { "AE", "Aeternity" },
                    { "ALGO", "Algorand" },
                    { "APT", "Aptos" },
                    { "AR", "Arweave" },
                    { "ASTR", "Astar" },
                    { "AVAXC", "Avax" },
                    { "AVAXX", "AvaxChain" },
                    { "BEAM", "Beam" },
                    { "BEP20", "BinanceSmartChain" },
                    { "BITCI", "BitciChain" },
                    { "BTC", "Bitcoin" },
                    { "BCH", "BitcoinCash" },
                    { "BSV", "BitcoinSV" },
                    { "CELO", "Celo" },
                    { "CKKB", "CKB" },
                    { "ATOM", "Cosmos" },
                    { "CRC20", "CRO" },
                    { "DASH", "Dash" },
                    { "DOGE", "Dogecoin" },
                    { "XEC", "ECash" },
                    { "EOS", "EOS" },
                    { "ETH", "Ethereum" },
                    { "ETC", "EthereumClassic" },
                    { "ETHW", "EthereumPow" },
                    { "FTM", "Fantom" },
                    { "FIL", "Filecoin" },
                    { "FSN", "Fusion" },
                    { "GRIN", "Grin" },
                    { "ONE", "Harmony" },
                    { "HRC20", "Hecochain" },
                    { "HBAR", "Hedera" },
                    { "HNT", "Helium" },
                    { "ZEN", "Horizen" },
                    { "IOST", "IOST" },
                    { "IRIS", "IRIS" },
                    { "KLAY", "Klaytn" },
                    { "KSM", "Kusama" },
                    { "LTC", "Litecoin" },
                    { "XMR", "Monero" },
                    { "GLMR", "Moonbeam" },
                    { "NEAR", "Near" },
                    { "NEO", "Neo" },
                    { "NEON3", "NeoN3" },
                    { "OASIS", "Oasis" },
                    { "OKC", "Okexchain" },
                    { "ONT", "Ontology" },
                    { "OPTIMISM", "Optimism" },
                    { "DOT", "Polkadot" },
                    { "MATIC", "Polygon" },
                    { "QTUM", "Qtum" },
                    { "REI", "REI" },
                    { "XRP", "Ripple" },
                    { "SGB", "SGB" },
                    { "SDN", "Shiden" },
                    { "SOL", "Solana" },
                    { "XLM", "Stellar" },
                    { "TERA", "Tera" },
                    { "XTZ", "Tezos" },
                    { "TRC20", "Tron" },
                    { "VET", "Vechain" },
                    { "VSYS", "VSystems" },
                    { "WAX", "WAX" },
                    { "ZEC", "Zcash" },
                } },
            } },
            { "features", new Dictionary<string, object>() {
                { "default", new Dictionary<string, object>() {
                    { "sandbox", false },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", true },
                        { "triggerPriceType", null },
                        { "triggerDirection", true },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", false },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "trailing", false },
                        { "leverage", false },
                        { "marketBuyRequiresPrice", true },
                        { "marketBuyByCost", true },
                        { "selfTradePrevention", false },
                        { "iceberg", false },
                    } },
                    { "createOrders", null },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 200 },
                        { "daysBack", null },
                        { "untilDays", null },
                        { "symbolRequired", true },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 200 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", true },
                    } },
                    { "fetchOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 200 },
                        { "daysBack", null },
                        { "untilDays", null },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", true },
                    } },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 200 },
                        { "daysBack", null },
                        { "daysBackCanceled", null },
                        { "untilDays", null },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", true },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 500 },
                    } },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "extends", "default" },
                } },
                { "forDerivatives", new Dictionary<string, object>() {
                    { "extends", "default" },
                    { "createOrder", new Dictionary<string, object>() {
                        { "triggerPriceType", new Dictionary<string, object>() {
                            { "mark", true },
                            { "index", true },
                            { "last", true },
                        } },
                    } },
                    { "fetchOrders", new Dictionary<string, object>() {
                        { "daysBack", 100000 },
                        { "untilDays", 100000 },
                    } },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "daysBack", 100000 },
                        { "untilDays", 100000 },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "forDerivatives" },
                    } },
                    { "inverse", new Dictionary<string, object>() {
                        { "extends", "forDerivatives" },
                    } },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "10001", typeof(BadRequest) },
                    { "10005", typeof(ExchangeError) },
                    { "Amount's scale must greater than AssetPair's base scale", typeof(InvalidOrder) },
                    { "Price mulit with amount should larger than AssetPair's min_quote_value", typeof(InvalidOrder) },
                    { "10007", typeof(BadRequest) },
                    { "10011", typeof(ExchangeError) },
                    { "10013", typeof(BadSymbol) },
                    { "10014", typeof(InsufficientFunds) },
                    { "10403", typeof(PermissionDenied) },
                    { "10429", typeof(RateLimitExceeded) },
                    { "40004", typeof(AuthenticationError) },
                    { "40103", typeof(AuthenticationError) },
                    { "40104", typeof(AuthenticationError) },
                    { "40301", typeof(PermissionDenied) },
                    { "40302", typeof(ExchangeError) },
                    { "40601", typeof(ExchangeError) },
                    { "40602", typeof(ExchangeError) },
                    { "40603", typeof(InsufficientFunds) },
                    { "40604", typeof(InvalidOrder) },
                    { "40605", typeof(InvalidOrder) },
                    { "40120", typeof(InvalidOrder) },
                    { "40121", typeof(InvalidOrder) },
                    { "60100", typeof(BadSymbol) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "CRE", "Cybereits" },
                { "FXT", "FXTTOKEN" },
                { "FREE", "FreeRossDAO" },
                { "MBN", "Mobilian Coin" },
                { "ONE", "BigONE Token" },
            } },
        });
    }

    /**
     * @method
     * @name bigone#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @param {dict} [params] extra parameters specific to the exchange API endpoint
     * @returns {dict} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        // we use undocumented link (possible, less informative alternative is : https://big.one/api/uc/v3/assets/accounts)
        parameters ??= new Dictionary<string, object>();
        object data = await this.fetchWebEndpoint("fetchCurrencies", "webExchangeGetV3Assets", true);
        if (isTrue(isEqual(data, null)))
        {
            return new Dictionary<string, object>() {};
        }
        //
        // {
        //     "code": "0",
        //     "message": "",
        //     "data": [
        //       {
        //             "uuid": "17082d1c-0195-4fb6-8779-2cdbcb9eeb3c",
        //             "symbol": "USDT",
        //             "name": "TetherUS",
        //             "scale": 12,
        //             "is_fiat": false,
        //             "is_transfer_enabled": true,
        //             "transfer_scale": 12,
        //             "binding_gateways": [
        //                 {
        //                     "guid": "07efc37f-d1ec-4bc9-8339-a745256ea2ba",
        //                     "is_deposit_enabled": true,
        //                     "gateway_name": "Ethereum",
        //                     "min_withdrawal_amount": "0.000001",
        //                     "withdrawal_fee": "5.71",
        //                     "is_withdrawal_enabled": true,
        //                     "min_deposit_amount": "0.000001",
        //                     "is_memo_required": false,
        //                     "withdrawal_scale": 6,
        //                     "scale": 12
        //                 },
        //                 {
        //                     "guid": "4e387a9a-a480-40a3-b4ae-ed1773c2db5a",
        //                     "is_deposit_enabled": true,
        //                     "gateway_name": "BinanceSmartChain",
        //                     "min_withdrawal_amount": "10",
        //                     "withdrawal_fee": "5",
        //                     "is_withdrawal_enabled": false,
        //                     "min_deposit_amount": "1",
        //                     "is_memo_required": false,
        //                     "withdrawal_scale": 8,
        //                     "scale": 12
        //                 }
        //             ]
        //         },
        //       ...
        //     ],
        // }
        //
        object currenciesData = this.safeList(data, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currenciesData)); postFixIncrement(ref i))
        {
            object currency = getValue(currenciesData, i);
            object id = this.safeString(currency, "symbol");
            object code = this.safeCurrencyCode(id);
            object name = this.safeString(currency, "name");
            object networks = new Dictionary<string, object>() {};
            object chains = this.safeList(currency, "binding_gateways", new List<object>() {});
            object currencyMaxPrecision = this.parsePrecision(this.safeString2(currency, "withdrawal_scale", "scale"));
            for (object j = 0; isLessThan(j, getArrayLength(chains)); postFixIncrement(ref j))
            {
                object chain = getValue(chains, j);
                object networkId = this.safeString(chain, "gateway_name");
                object networkCode = this.networkIdToCode(networkId);
                object deposit = this.safeBool(chain, "is_deposit_enabled");
                object withdraw = this.safeBool(chain, "is_withdrawal_enabled");
                object minDepositAmount = this.safeString(chain, "min_deposit_amount");
                object minWithdrawalAmount = this.safeString(chain, "min_withdrawal_amount");
                object withdrawalFee = this.safeString(chain, "withdrawal_fee");
                object precision = this.parsePrecision(this.safeString2(chain, "withdrawal_scale", "scale"));
                ((IDictionary<string,object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                    { "id", networkId },
                    { "network", networkCode },
                    { "margin", null },
                    { "deposit", deposit },
                    { "withdraw", withdraw },
                    { "active", null },
                    { "fee", this.parseNumber(withdrawalFee) },
                    { "precision", this.parseNumber(precision) },
                    { "limits", new Dictionary<string, object>() {
                        { "deposit", new Dictionary<string, object>() {
                            { "min", minDepositAmount },
                            { "max", null },
                        } },
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", minWithdrawalAmount },
                            { "max", null },
                        } },
                    } },
                    { "info", chain },
                };
            }
            object chainLength = getArrayLength(chains);
            object type = null;
            if (isTrue(this.safeBool(currency, "is_fiat")))
            {
                type = "fiat";
            } else if (isTrue(isEqual(chainLength, 0)))
            {
                if (isTrue(this.isLeveragedCurrency(id)))
                {
                    type = "leveraged";
                } else
                {
                    type = "other";
                }
            } else
            {
                type = "crypto";
            }
            ((IDictionary<string,object>)result)[(string)code] = this.safeCurrencyStructure(new Dictionary<string, object>() {
                { "id", id },
                { "code", code },
                { "info", currency },
                { "name", name },
                { "type", type },
                { "active", null },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "precision", this.parseNumber(currencyMaxPrecision) },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "networks", networks },
            });
        }
        return result;
    }

    /**
     * @method
     * @name bigone#fetchMarkets
     * @description retrieves data on all markets for bigone
     * @see https://open.big.one/docs/spot_asset_pair.html
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object promises = new List<object> {this.publicGetAssetPairs(parameters), this.contractPublicGetSymbols(parameters)};
        object promisesResult = await promiseAll(promises);
        object response = getValue(promisesResult, 0);
        object contractResponse = getValue(promisesResult, 1);
        //
        //     {
        //         "code":0,
        //         "data":[
        //             {
        //                 "id":"01e48809-b42f-4a38-96b1-c4c547365db1",
        //                 "name":"PCX-BTC",
        //                 "quote_scale":7,
        //                 "quote_asset":{
        //                     "id":"0df9c3c3-255a-46d7-ab82-dedae169fba9",
        //                     "symbol":"BTC",
        //                     "name":"Bitcoin",
        //                 },
        //                 "base_asset":{
        //                     "id":"405484f7-4b03-4378-a9c1-2bd718ecab51",
        //                     "symbol":"PCX",
        //                     "name":"ChainX",
        //                 },
        //                 "base_scale":3,
        //                 "min_quote_value":"0.0001",
        //                 "max_quote_value":"35"
        //             },
        //         ]
        //     }
        //
        //
        //    [
        //        {
        //            "baseCurrency": "BTC",
        //            "multiplier": 1,
        //            "enable": true,
        //            "priceStep": 0.5,
        //            "maxRiskLimit": 1000,
        //            "pricePrecision": 1,
        //            "maintenanceMargin": 0.00500,
        //            "symbol": "BTCUSD",
        //            "valuePrecision": 4,
        //            "minRiskLimit": 100,
        //            "riskLimit": 100,
        //            "isInverse": true,
        //            "riskStep": 1,
        //            "settleCurrency": "BTC",
        //            "baseName": "Bitcoin",
        //            "feePrecision": 8,
        //            "priceMin": 0.5,
        //            "priceMax": 1E+6,
        //            "initialMargin": 0.01000,
        //            "quoteCurrency": "USD"
        //        },
        //        ...
        //    ]
        //
        object markets = this.safeList(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object baseAsset = this.safeDict(market, "base_asset", new Dictionary<string, object>() {});
            object quoteAsset = this.safeDict(market, "quote_asset", new Dictionary<string, object>() {});
            object baseId = this.safeString(baseAsset, "symbol");
            object quoteId = this.safeString(quoteAsset, "symbol");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            ((IList<object>)result).Add(this.safeMarketStructure(new Dictionary<string, object>() {
                { "id", this.safeString(market, "name") },
                { "uuid", this.safeString(market, "id") },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", true },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "base_scale"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "quote_scale"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_quote_value") },
                        { "max", this.safeNumber(market, "max_quote_value") },
                    } },
                } },
                { "created", null },
                { "info", market },
            }));
        }
        for (object i = 0; isLessThan(i, getArrayLength(contractResponse)); postFixIncrement(ref i))
        {
            object market = getValue(contractResponse, i);
            object baseId = this.safeString(market, "baseCurrency");
            object quoteId = this.safeString(market, "quoteCurrency");
            object settleId = this.safeString(market, "settleCurrency");
            object marketId = this.safeString(market, "symbol");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object settle = this.safeCurrencyCode(settleId);
            object inverse = this.safeBool(market, "isInverse");
            ((IList<object>)result).Add(this.safeMarketStructure(new Dictionary<string, object>() {
                { "id", marketId },
                { "symbol", add(add(add(add(bs, "/"), quote), ":"), settle) },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", "swap" },
                { "spot", false },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "active", this.safeBool(market, "enable") },
                { "contract", true },
                { "linear", !isTrue(inverse) },
                { "inverse", inverse },
                { "contractSize", this.safeNumber(market, "multiplier") },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "valuePrecision"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "pricePrecision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "priceMin") },
                        { "max", this.safeNumber(market, "priceMax") },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "initialMargin") },
                        { "max", null },
                    } },
                } },
                { "info", market },
            }));
        }
        return result;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // spot
        //
        //    {
        //        "asset_pair_name": "ETH-BTC",
        //        "bid": {
        //            "price": "0.021593",
        //            "order_count": 1,
        //            "quantity": "0.20936"
        //        },
        //        "ask": {
        //            "price": "0.021613",
        //            "order_count": 1,
        //            "quantity": "2.87064"
        //        },
        //        "open": "0.021795",
        //        "high": "0.021795",
        //        "low": "0.021471",
        //        "close": "0.021613",
        //        "volume": "117078.90431",
        //        "daily_change": "-0.000182"
        //    }
        //
        // contract
        //
        //    {
        //        "usdtPrice": 1.00031998,
        //        "symbol": "BTCUSD",
        //        "btcPrice": 34700.4,
        //        "ethPrice": 1787.83,
        //        "nextFundingRate": 0.00010,
        //        "fundingRate": 0.00010,
        //        "latestPrice": 34708.5,
        //        "last24hPriceChange": 0.0321,
        //        "indexPrice": 34700.4,
        //        "volume24h": 261319063,
        //        "turnover24h": 8204.129380685496,
        //        "nextFundingTime": 1698285600000,
        //        "markPrice": 34702.4646738,
        //        "last24hMaxPrice": 35127.5,
        //        "volume24hInUsd": 0.0,
        //        "openValue": 32.88054722085945,
        //        "last24hMinPrice": 33552.0,
        //        "openInterest": 1141372.0
        //    }
        //
        object marketType = ((bool) isTrue((inOp(ticker, "asset_pair_name")))) ? "spot" : "swap";
        object marketId = this.safeString2(ticker, "asset_pair_name", "symbol");
        object symbol = this.safeSymbol(marketId, market, "-", marketType);
        object close = this.safeString2(ticker, "close", "latestPrice");
        object bid = this.safeDict(ticker, "bid", new Dictionary<string, object>() {});
        object ask = this.safeDict(ticker, "ask", new Dictionary<string, object>() {});
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "high", this.safeString2(ticker, "high", "last24hMaxPrice") },
            { "low", this.safeString2(ticker, "low", "last24hMinPrice") },
            { "bid", this.safeString(bid, "price") },
            { "bidVolume", this.safeString(bid, "quantity") },
            { "ask", this.safeString(ask, "price") },
            { "askVolume", this.safeString(ask, "quantity") },
            { "vwap", null },
            { "open", this.safeString(ticker, "open") },
            { "close", close },
            { "last", close },
            { "previousClose", null },
            { "change", this.safeString2(ticker, "daily_change", "last24hPriceChange") },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString2(ticker, "volume", "volume24h") },
            { "quoteVolume", this.safeString(ticker, "volume24hInUsd") },
            { "markPrice", this.safeString(ticker, "markPrice") },
            { "indexPrice", this.safeString(ticker, "indexPrice") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name bigone#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://open.big.one/docs/spot_tickers.html
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTicker", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            object request = new Dictionary<string, object>() {
                { "asset_pair_name", getValue(market, "id") },
            };
            object response = await this.publicGetAssetPairsAssetPairNameTicker(this.extend(request, parameters));
            //
            //     {
            //         "code":0,
            //         "data":{
            //             "asset_pair_name":"ETH-BTC",
            //             "bid":{"price":"0.021593","order_count":1,"quantity":"0.20936"},
            //             "ask":{"price":"0.021613","order_count":1,"quantity":"2.87064"},
            //             "open":"0.021795",
            //             "high":"0.021795",
            //             "low":"0.021471",
            //             "close":"0.021613",
            //             "volume":"117078.90431",
            //             "daily_change":"-0.000182"
            //         }
            //     }
            //
            object ticker = this.safeDict(response, "data", new Dictionary<string, object>() {});
            return this.parseTicker(ticker, market);
        } else
        {
            object tickers = await this.fetchTickers(new List<object>() {symbol}, parameters);
            return this.safeValue(tickers, symbol);
        }
    }

    /**
     * @method
     * @name bigone#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://open.big.one/docs/spot_tickers.html
     * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object symbol = this.safeString(symbols, 0);
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object isSpot = isEqual(type, "spot");
        object request = new Dictionary<string, object>() {};
        symbols = this.marketSymbols(symbols);
        object data = null;
        if (isTrue(isSpot))
        {
            if (isTrue(!isEqual(symbols, null)))
            {
                object ids = this.marketIds(symbols);
                ((IDictionary<string,object>)request)["pair_names"] = String.Join(",", ((IList<object>)ids).ToArray());
            }
            object response = await this.publicGetAssetPairsTickers(this.extend(request, parameters));
            //
            //    {
            //        "code": 0,
            //        "data": [
            //            {
            //                "asset_pair_name": "PCX-BTC",
            //                "bid": {
            //                    "price": "0.000234",
            //                    "order_count": 1,
            //                    "quantity": "0.518"
            //                },
            //                "ask": {
            //                    "price": "0.0002348",
            //                    "order_count": 1,
            //                    "quantity": "2.348"
            //                },
            //                "open": "0.0002343",
            //                "high": "0.0002348",
            //                "low": "0.0002162",
            //                "close": "0.0002348",
            //                "volume": "12887.016",
            //                "daily_change": "0.0000005"
            //            },
            //            ...
            //        ]
            //    }
            //
            data = this.safeList(response, "data", new List<object>() {});
        } else
        {
            data = await this.contractPublicGetInstruments(parameters);
        }
        object tickers = this.parseTickers(data, symbols);
        return this.filterByArrayTickers(tickers, "symbol", symbols);
    }

    /**
     * @method
     * @name bigone#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://open.big.one/docs/spot_ping.html
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetPing(parameters);
        //
        //     {
        //         "data": {
        //             "timestamp": 1527665262168391000
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(data, "Timestamp");
        return this.parseToInt(divide(timestamp, 1000000));
    }

    /**
     * @method
     * @name bigone#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://open.big.one/docs/contract_misc.html#get-orderbook-snapshot
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object response = null;
        if (isTrue(getValue(market, "contract")))
        {
            object request = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
            };
            response = await this.contractPublicGetDepthSymbolSnapshot(this.extend(request, parameters));
            //
            //    {
            //        bids: {
            //            '20000': '20',
            //            ...
            //            '34552': '64851',
            //            '34526.5': '59594',
            //            ...
            //            '34551.5': '29711'
            //        },
            //        asks: {
            //            '34557': '34395',
            //            ...
            //            '40000': '20',
            //            '34611.5': '56024',
            //            ...
            //            '34578.5': '66367'
            //        },
            //        to: '59737174',
            //        lastPrice: '34554.5',
            //        bestPrices: {
            //            ask: '34557.0',
            //            bid: '34552.0'
            //        },
            //        from: '0'
            //    }
            //
            return this.parseContractOrderBook(response, getValue(market, "symbol"), limit);
        } else
        {
            object request = new Dictionary<string, object>() {
                { "asset_pair_name", getValue(market, "id") },
            };
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit; // default 50, max 200
            }
            response = await this.publicGetAssetPairsAssetPairNameDepth(this.extend(request, parameters));
            //
            //     {
            //         "code":0,
            //         "data": {
            //             "asset_pair_name": "EOS-BTC",
            //             "bids": [
            //                 { "price": "42", "order_count": 4, "quantity": "23.33363711" }
            //             ],
            //             "asks": [
            //                 { "price": "45", "order_count": 2, "quantity": "4193.3283464" }
            //             ]
            //         }
            //     }
            //
            object orderbook = this.safeDict(response, "data", new Dictionary<string, object>() {});
            return this.parseOrderBook(orderbook, getValue(market, "symbol"), null, "bids", "asks", "price", "quantity");
        }
    }

    public virtual object parseContractBidsAsks(object bidsAsks)
    {
        object bidsAsksKeys = new List<object>(((IDictionary<string,object>)bidsAsks).Keys);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(bidsAsksKeys)); postFixIncrement(ref i))
        {
            object price = getValue(bidsAsksKeys, i);
            object amount = getValue(bidsAsks, price);
            ((IList<object>)result).Add(new List<object> {this.parseNumber(price), this.parseNumber(amount)});
        }
        return result;
    }

    public virtual object parseContractOrderBook(object orderbook, object symbol, object limit = null)
    {
        object responseBids = this.safeValue(orderbook, "bids");
        object responseAsks = this.safeValue(orderbook, "asks");
        object bids = this.parseContractBidsAsks(responseBids);
        object asks = this.parseContractBidsAsks(responseAsks);
        return ((object)new Dictionary<string, object>() {
            { "symbol", symbol },
            { "bids", this.filterByLimit(this.sortBy(bids, 0, true), limit) },
            { "asks", this.filterByLimit(this.sortBy(asks, 0), limit) },
            { "timestamp", null },
            { "datetime", null },
            { "nonce", null },
        });
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //     {
        //         "id": 38199941,
        //         "price": "3378.67",
        //         "amount": "0.019812",
        //         "taker_side": "ASK",
        //         "created_at": "2019-01-29T06:05:56Z"
        //     }
        //
        // fetchMyTrades (private)
        //
        //     {
        //         "id": 10854280,
        //         "asset_pair_name": "XIN-USDT",
        //         "price": "70",
        //         "amount": "1",
        //         "taker_side": "ASK",
        //         "maker_order_id": 58284908,
        //         "taker_order_id": 58284909,
        //         "maker_fee": "0.0008",
        //         "taker_fee": "0.07",
        //         "side": "SELF_TRADING",
        //         "inserted_at": "2019-04-16T12:00:01Z"
        //     },
        //
        //     {
        //         "id": 10854263,
        //         "asset_pair_name": "XIN-USDT",
        //         "price": "75.7",
        //         "amount": "12.743149",
        //         "taker_side": "BID",
        //         "maker_order_id": null,
        //         "taker_order_id": 58284888,
        //         "maker_fee": null,
        //         "taker_fee": "0.0025486298",
        //         "side": "BID",
        //         "inserted_at": "2019-04-15T06:20:57Z"
        //     }
        //
        object timestamp = this.parse8601(this.safeString2(trade, "created_at", "inserted_at"));
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString(trade, "amount");
        object marketId = this.safeString(trade, "asset_pair_name");
        market = this.safeMarket(marketId, market, "-");
        object side = this.safeString(trade, "side");
        object takerSide = this.safeString(trade, "taker_side");
        object takerOrMaker = null;
        if (isTrue(isTrue(isTrue((!isEqual(takerSide, null))) && isTrue((!isEqual(side, null)))) && isTrue((!isEqual(side, "SELF_TRADING")))))
        {
            takerOrMaker = ((bool) isTrue((isEqual(takerSide, side)))) ? "taker" : "maker";
        }
        if (isTrue(isEqual(side, null)))
        {
            // taker side is not related to buy/sell side
            // the following code is probably a mistake
            side = ((bool) isTrue((isEqual(takerSide, "ASK")))) ? "sell" : "buy";
        } else
        {
            if (isTrue(isEqual(side, "BID")))
            {
                side = "buy";
            } else if (isTrue(isEqual(side, "ASK")))
            {
                side = "sell";
            }
        }
        object makerOrderId = this.safeString(trade, "maker_order_id");
        object takerOrderId = this.safeString(trade, "taker_order_id");
        object orderId = null;
        if (isTrue(!isEqual(makerOrderId, null)))
        {
            orderId = makerOrderId;
        } else if (isTrue(!isEqual(takerOrderId, null)))
        {
            orderId = takerOrderId;
        }
        object id = this.safeString(trade, "id");
        object result = new Dictionary<string, object>() {
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "order", orderId },
            { "type", "limit" },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "info", trade },
        };
        object makerCurrencyCode = null;
        object takerCurrencyCode = null;
        if (isTrue(!isEqual(takerOrMaker, null)))
        {
            if (isTrue(isEqual(side, "buy")))
            {
                if (isTrue(isEqual(takerOrMaker, "maker")))
                {
                    makerCurrencyCode = getValue(market, "base");
                    takerCurrencyCode = getValue(market, "quote");
                } else
                {
                    makerCurrencyCode = getValue(market, "quote");
                    takerCurrencyCode = getValue(market, "base");
                }
            } else
            {
                if (isTrue(isEqual(takerOrMaker, "maker")))
                {
                    makerCurrencyCode = getValue(market, "quote");
                    takerCurrencyCode = getValue(market, "base");
                } else
                {
                    makerCurrencyCode = getValue(market, "base");
                    takerCurrencyCode = getValue(market, "quote");
                }
            }
        } else if (isTrue(isEqual(side, "SELF_TRADING")))
        {
            if (isTrue(isEqual(takerSide, "BID")))
            {
                makerCurrencyCode = getValue(market, "quote");
                takerCurrencyCode = getValue(market, "base");
            } else if (isTrue(isEqual(takerSide, "ASK")))
            {
                makerCurrencyCode = getValue(market, "base");
                takerCurrencyCode = getValue(market, "quote");
            }
        }
        object makerFeeCost = this.safeString(trade, "maker_fee");
        object takerFeeCost = this.safeString(trade, "taker_fee");
        if (isTrue(!isEqual(makerFeeCost, null)))
        {
            if (isTrue(!isEqual(takerFeeCost, null)))
            {
                ((IDictionary<string,object>)result)["fees"] = new List<object>() {new Dictionary<string, object>() {
    { "cost", makerFeeCost },
    { "currency", makerCurrencyCode },
}, new Dictionary<string, object>() {
    { "cost", takerFeeCost },
    { "currency", takerCurrencyCode },
}};
            } else
            {
                ((IDictionary<string,object>)result)["fee"] = new Dictionary<string, object>() {
                    { "cost", makerFeeCost },
                    { "currency", makerCurrencyCode },
                };
            }
        } else if (isTrue(!isEqual(takerFeeCost, null)))
        {
            ((IDictionary<string,object>)result)["fee"] = new Dictionary<string, object>() {
                { "cost", takerFeeCost },
                { "currency", takerCurrencyCode },
            };
        } else
        {
            ((IDictionary<string,object>)result)["fee"] = null;
        }
        return this.safeTrade(((object)result), market);
    }

    /**
     * @method
     * @name bigone#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://open.big.one/docs/spot_asset_pair_trade.html
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(getValue(market, "contract")))
        {
            throw new NotSupported ((string)add(this.id, " fetchTrades () can only fetch trades for spot markets")) ;
        }
        object request = new Dictionary<string, object>() {
            { "asset_pair_name", getValue(market, "id") },
        };
        object response = await this.publicGetAssetPairsAssetPairNameTrades(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "id": 38199941,
        //                 "price": "3378.67",
        //                 "amount": "0.019812",
        //                 "taker_side": "ASK",
        //                 "created_at": "2019-01-29T06:05:56Z"
        //             },
        //             {
        //                 "id": 38199934,
        //                 "price": "3376.14",
        //                 "amount": "0.019384",
        //                 "taker_side": "ASK",
        //                 "created_at": "2019-01-29T06:05:40Z"
        //             }
        //         ]
        //     }
        //
        object trades = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "close": "0.021562",
        //         "high": "0.021563",
        //         "low": "0.02156",
        //         "open": "0.021563",
        //         "time": "2019-11-21T07:54:00Z",
        //         "volume": "59.84376"
        //     }
        //
        return new List<object> {this.parse8601(this.safeString(ohlcv, "time")), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    /**
     * @method
     * @name bigone#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://open.big.one/docs/spot_asset_pair_candle.html
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the earliest candle to fetch
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(getValue(market, "contract")))
        {
            throw new NotSupported ((string)add(this.id, " fetchOHLCV () can only fetch ohlcvs for spot markets")) ;
        }
        object until = this.safeInteger(parameters, "until");
        object untilIsDefined = (!isEqual(until, null));
        object sinceIsDefined = (!isEqual(since, null));
        if (isTrue(isEqual(limit, null)))
        {
            limit = ((bool) isTrue((isTrue(sinceIsDefined) && isTrue(untilIsDefined)))) ? 500 : 100; // default 100, max 500, if since and limit defined then fetch all the candles between them unless it exceeds the max of 500
        }
        object request = new Dictionary<string, object>() {
            { "asset_pair_name", getValue(market, "id") },
            { "period", this.safeString(this.timeframes, timeframe, timeframe) },
            { "limit", limit },
        };
        if (isTrue(sinceIsDefined))
        {
            // const start = this.parseToInt (since / 1000);
            object duration = this.parseTimeframe(timeframe);
            object endByLimit = this.sum(since, multiply(multiply(limit, duration), 1000));
            if (isTrue(untilIsDefined))
            {
                ((IDictionary<string,object>)request)["time"] = this.iso8601(mathMin(endByLimit, add(until, 1)));
            } else
            {
                ((IDictionary<string,object>)request)["time"] = this.iso8601(endByLimit);
            }
        } else if (isTrue(untilIsDefined))
        {
            ((IDictionary<string,object>)request)["time"] = this.iso8601(add(until, 1));
        }
        parameters = this.omit(parameters, "until");
        object response = await this.publicGetAssetPairsAssetPairNameCandles(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "close": "0.021656",
        //                 "high": "0.021658",
        //                 "low": "0.021652",
        //                 "open": "0.021652",
        //                 "time": "2019-11-21T09:30:00Z",
        //                 "volume": "53.08664"
        //             },
        //             {
        //                 "close": "0.021652",
        //                 "high": "0.021656",
        //                 "low": "0.021652",
        //                 "open": "0.021656",
        //                 "time": "2019-11-21T09:29:00Z",
        //                 "volume": "88.39861"
        //             },
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        object balances = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object symbol = this.safeString(balance, "asset_symbol");
            object code = this.safeCurrencyCode(symbol);
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "balance");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "locked_balance");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name bigone#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://open.big.one/docs/fund_accounts.html
     * @see https://open.big.one/docs/spot_accounts.html
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = this.safeString(parameters, "type", "");
        parameters = this.omit(parameters, "type");
        object response = null;
        if (isTrue(isTrue(isEqual(type, "funding")) || isTrue(isEqual(type, "fund"))))
        {
            response = await this.privateGetFundAccounts(parameters);
        } else
        {
            response = await this.privateGetAccounts(parameters);
        }
        //
        //     {
        //         "code":0,
        //         "data":[
        //             {"asset_symbol":"NKC","balance":"0","locked_balance":"0"},
        //             {"asset_symbol":"UBTC","balance":"0","locked_balance":"0"},
        //             {"asset_symbol":"READ","balance":"0","locked_balance":"0"},
        //         ],
        //     }
        //
        return this.parseBalance(response);
    }

    public virtual object parseType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "STOP_LIMIT", "limit" },
            { "STOP_MARKET", "market" },
            { "LIMIT", "limit" },
            { "MARKET", "market" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        //    {
        //        "id": "42154072251",
        //        "asset_pair_name": "SOL-USDT",
        //        "price": "20",
        //        "amount": "0.5",
        //        "filled_amount": "0",
        //        "avg_deal_price": "0",
        //        "side": "ASK",
        //        "state": "PENDING",
        //        "created_at": "2023-09-13T03:42:00Z",
        //        "updated_at": "2023-09-13T03:42:00Z",
        //        "type": "LIMIT",
        //        "stop_price": "0",
        //        "immediate_or_cancel": false,
        //        "post_only": false,
        //        "client_order_id": ''
        //    }
        //
        object id = this.safeString(order, "id");
        object marketId = this.safeString(order, "asset_pair_name");
        object symbol = this.safeSymbol(marketId, market, "-");
        object timestamp = this.parse8601(this.safeString(order, "created_at"));
        object side = this.safeString(order, "side");
        if (isTrue(isEqual(side, "BID")))
        {
            side = "buy";
        } else
        {
            side = "sell";
        }
        object triggerPrice = this.safeString(order, "stop_price");
        if (isTrue(Precise.stringEq(triggerPrice, "0")))
        {
            triggerPrice = null;
        }
        object immediateOrCancel = this.safeBool(order, "immediate_or_cancel");
        object timeInForce = null;
        if (isTrue(immediateOrCancel))
        {
            timeInForce = "IOC";
        }
        object type = this.parseType(this.safeString(order, "type"));
        object price = this.safeString(order, "price");
        object amount = null;
        object filled = null;
        object cost = null;
        if (isTrue(isTrue(isEqual(type, "market")) && isTrue(isEqual(side, "buy"))))
        {
            cost = this.safeString(order, "filled_amount");
        } else
        {
            amount = this.safeString(order, "amount");
            filled = this.safeString(order, "filled_amount");
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", this.safeString(order, "client_order_id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", this.parse8601(this.safeString(order, "updated_at")) },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", this.safeBool(order, "post_only") },
            { "side", side },
            { "price", price },
            { "triggerPrice", triggerPrice },
            { "amount", amount },
            { "cost", cost },
            { "average", this.safeString(order, "avg_deal_price") },
            { "filled", filled },
            { "remaining", null },
            { "status", this.parseOrderStatus(this.safeString(order, "state")) },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    /**
     * @method
     * @name bigone#createMarketBuyOrderWithCost
     * @description create a market buy order by providing the symbol and cost
     * @see https://open.big.one/docs/spot_orders.html#create-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
        }
        ((IDictionary<string,object>)parameters)["createMarketBuyOrderRequiresPrice"] = false;
        return await this.createOrder(symbol, "market", "buy", cost, null, parameters);
    }

    /**
     * @method
     * @name bigone#createOrder
     * @description create a trade order
     * @see https://open.big.one/docs/spot_orders.html#create-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.triggerPrice] the price at which a trigger order is triggered at
     * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
     * @param {string} [params.timeInForce] "GTC", "IOC", or "PO"
     * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
     *
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {string} [params.operator] *stop order only* GTE or LTE (default)
     * @param {string} [params.client_order_id] must match ^[a-zA-Z0-9-_]{1,36}$ this regex. client_order_id is unique in 24 hours, If created 24 hours later and the order closed, it will be released and can be reused
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object isBuy = (isEqual(side, "buy"));
        object requestSide = ((bool) isTrue(isBuy)) ? "BID" : "ASK";
        object uppercaseType = ((string)type).ToUpper();
        object isLimit = isEqual(uppercaseType, "LIMIT");
        object exchangeSpecificParam = this.safeBool(parameters, "post_only", false);
        object postOnly = null;
        var postOnlyparametersVariable = this.handlePostOnly((isEqual(uppercaseType, "MARKET")), exchangeSpecificParam, parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        object triggerPrice = this.safeStringN(parameters, new List<object>() {"triggerPrice", "stopPrice", "stop_price"});
        object request = new Dictionary<string, object>() {
            { "asset_pair_name", getValue(market, "id") },
            { "side", requestSide },
            { "amount", this.amountToPrecision(symbol, amount) },
        };
        if (isTrue(isTrue(isLimit) || isTrue((isEqual(uppercaseType, "STOP_LIMIT")))))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            if (isTrue(isLimit))
            {
                object timeInForce = this.safeString(parameters, "timeInForce");
                if (isTrue(isEqual(timeInForce, "IOC")))
                {
                    ((IDictionary<string,object>)request)["immediate_or_cancel"] = true;
                }
                if (isTrue(postOnly))
                {
                    ((IDictionary<string,object>)request)["post_only"] = true;
                }
            }
            ((IDictionary<string,object>)request)["amount"] = this.amountToPrecision(symbol, amount);
        } else
        {
            if (isTrue(isBuy))
            {
                object createMarketBuyOrderRequiresPrice = true;
                var createMarketBuyOrderRequiresPriceparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                createMarketBuyOrderRequiresPrice = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[0];
                parameters = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[1];
                object cost = this.safeNumber(parameters, "cost");
                parameters = this.omit(parameters, "cost");
                if (isTrue(createMarketBuyOrderRequiresPrice))
                {
                    if (isTrue(isTrue((isEqual(price, null))) && isTrue((isEqual(cost, null)))))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")) ;
                    } else
                    {
                        object amountString = this.numberToString(amount);
                        object priceString = this.numberToString(price);
                        object quoteAmount = this.parseToNumeric(Precise.stringMul(amountString, priceString));
                        object costRequest = ((bool) isTrue((!isEqual(cost, null)))) ? cost : quoteAmount;
                        ((IDictionary<string,object>)request)["amount"] = this.costToPrecision(symbol, costRequest);
                    }
                } else
                {
                    ((IDictionary<string,object>)request)["amount"] = this.costToPrecision(symbol, amount);
                }
            } else
            {
                ((IDictionary<string,object>)request)["amount"] = this.amountToPrecision(symbol, amount);
            }
        }
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((IDictionary<string,object>)request)["stop_price"] = this.priceToPrecision(symbol, triggerPrice);
            ((IDictionary<string,object>)request)["operator"] = ((bool) isTrue(isBuy)) ? "GTE" : "LTE";
            if (isTrue(isLimit))
            {
                uppercaseType = "STOP_LIMIT";
            } else if (isTrue(isEqual(uppercaseType, "MARKET")))
            {
                uppercaseType = "STOP_MARKET";
            }
        }
        ((IDictionary<string,object>)request)["type"] = uppercaseType;
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
        }
        parameters = this.omit(parameters, new List<object>() {"stop_price", "stopPrice", "triggerPrice", "timeInForce", "clientOrderId"});
        object response = await this.privatePostOrders(this.extend(request, parameters));
        //
        //    {
        //        "id": 10,
        //        "asset_pair_name": "EOS-BTC",
        //        "price": "10.00",
        //        "amount": "10.00",
        //        "filled_amount": "9.0",
        //        "avg_deal_price": "12.0",
        //        "side": "ASK",
        //        "state": "FILLED",
        //        "created_at":"2019-01-29T06:05:56Z",
        //        "updated_at":"2019-01-29T06:05:56Z"
        //    }
        //
        object order = this.safeDict(response, "data");
        return this.parseOrder(order, market);
    }

    /**
     * @method
     * @name bigone#cancelOrder
     * @description cancels an open order
     * @see https://open.big.one/docs/spot_orders.html#cancel-order
     * @param {string} id order id
     * @param {string} symbol Not used by bigone cancelOrder ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object response = await this.privatePostOrdersIdCancel(this.extend(request, parameters));
        //    {
        //        "id": 10,
        //        "asset_pair_name": "EOS-BTC",
        //        "price": "10.00",
        //        "amount": "10.00",
        //        "filled_amount": "9.0",
        //        "avg_deal_price": "12.0",
        //        "side": "ASK",
        //        "state": "CANCELLED",
        //        "created_at":"2019-01-29T06:05:56Z",
        //        "updated_at":"2019-01-29T06:05:56Z"
        //    }
        object order = this.safeDict(response, "data");
        return this.parseOrder(order);
    }

    /**
     * @method
     * @name bigone#cancelAllOrders
     * @description cancel all open orders
     * @see https://open.big.one/docs/spot_orders.html#cancel-all-orders
     * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "asset_pair_name", getValue(market, "id") },
        };
        object response = await this.privatePostOrdersCancel(this.extend(request, parameters));
        //
        //     {
        //         "code":0,
        //         "data": {
        //             "cancelled":[
        //                 58272370,
        //                 58272377
        //             ],
        //             "failed": []
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object cancelled = this.safeList(data, "cancelled", new List<object>() {});
        object failed = this.safeList(data, "failed", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(cancelled)); postFixIncrement(ref i))
        {
            object orderId = getValue(cancelled, i);
            ((IList<object>)result).Add(this.safeOrder(new Dictionary<string, object>() {
                { "info", orderId },
                { "id", orderId },
                { "status", "canceled" },
            }));
        }
        for (object i = 0; isLessThan(i, getArrayLength(failed)); postFixIncrement(ref i))
        {
            object orderId = getValue(failed, i);
            ((IList<object>)result).Add(this.safeOrder(new Dictionary<string, object>() {
                { "info", orderId },
                { "id", orderId },
                { "status", "failed" },
            }));
        }
        return result;
    }

    /**
     * @method
     * @name bigone#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://open.big.one/docs/spot_orders.html#get-one-order
     * @param {string} id the order id
     * @param {string} symbol not used by bigone fetchOrder
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object response = await this.privateGetOrdersId(this.extend(request, parameters));
        object order = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(order);
    }

    /**
     * @method
     * @name bigone#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @see https://open.big.one/docs/spot_orders.html#get-user-orders-in-one-asset-pair
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "asset_pair_name", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 20, max 200
        }
        object response = await this.privateGetOrders(this.extend(request, parameters));
        //
        //    {
        //        "code":0,
        //        "data": [
        //             {
        //                 "id": 10,
        //                 "asset_pair_name": "ETH-BTC",
        //                 "price": "10.00",
        //                 "amount": "10.00",
        //                 "filled_amount": "9.0",
        //                 "avg_deal_price": "12.0",
        //                 "side": "ASK",
        //                 "state": "FILLED",
        //                 "created_at":"2019-01-29T06:05:56Z",
        //                 "updated_at":"2019-01-29T06:05:56Z",
        //             },
        //         ],
        //        "page_token":"dxzef",
        //    }
        //
        object orders = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    /**
     * @method
     * @name bigone#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://open.big.one/docs/spot_trade.html#trades-of-user
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "asset_pair_name", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 20, max 200
        }
        object response = await this.privateGetTrades(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "id": 10854280,
        //                 "asset_pair_name": "XIN-USDT",
        //                 "price": "70",
        //                 "amount": "1",
        //                 "taker_side": "ASK",
        //                 "maker_order_id": 58284908,
        //                 "taker_order_id": 58284909,
        //                 "maker_fee": "0.0008",
        //                 "taker_fee": "0.07",
        //                 "side": "SELF_TRADING",
        //                 "inserted_at": "2019-04-16T12:00:01Z"
        //             },
        //             {
        //                 "id": 10854263,
        //                 "asset_pair_name": "XIN-USDT",
        //                 "price": "75.7",
        //                 "amount": "12.743149",
        //                 "taker_side": "BID",
        //                 "maker_order_id": null,
        //                 "taker_order_id": 58284888,
        //                 "maker_fee": null,
        //                 "taker_fee": "0.0025486298",
        //                 "side": "BID",
        //                 "inserted_at": "2019-04-15T06:20:57Z"
        //             }
        //         ],
        //         "page_token":"dxfv"
        //     }
        //
        object trades = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "PENDING", "open" },
            { "FILLED", "closed" },
            { "CANCELLED", "canceled" },
        };
        return this.safeString(statuses, status);
    }

    /**
     * @method
     * @name bigone#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://open.big.one/docs/spot_orders.html#get-user-orders-in-one-asset-pair
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of  open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "state", "PENDING" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    /**
     * @method
     * @name bigone#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://open.big.one/docs/spot_orders.html#get-user-orders-in-one-asset-pair
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "state", "FILLED" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public override object nonce()
    {
        object exchangeTimeCorrection = multiply(this.safeInteger(this.options, "exchangeMillisecondsCorrection", 0), 1000000);
        return this.sum(multiply(this.microseconds(), 1000), exchangeTimeCorrection);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object query = this.omit(parameters, this.extractParams(path));
        object baseUrl = this.implodeHostname(getValue(getValue(this.urls, "api"), api));
        object url = add(add(baseUrl, "/"), this.implodeParams(path, parameters));
        headers = new Dictionary<string, object>() {};
        if (isTrue(isTrue(isTrue(isEqual(api, "public")) || isTrue(isEqual(api, "webExchange"))) || isTrue(isEqual(api, "contractPublic"))))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else
        {
            this.checkRequiredCredentials();
            object nonce = ((object)this.nonce()).ToString();
            object request = new Dictionary<string, object>() {
                { "type", "OpenAPIV2" },
                { "sub", this.apiKey },
                { "nonce", nonce },
            };
            object token = jwt(request, this.encode(this.secret), sha256);
            ((IDictionary<string,object>)headers)["Authorization"] = add("Bearer ", token);
            if (isTrue(isEqual(method, "GET")))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    url = add(url, add("?", this.urlencode(query)));
                }
            } else if (isTrue(isEqual(method, "POST")))
            {
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
                body = this.json(query);
            }
        }
        ((IDictionary<string,object>)headers)["User-Agent"] = add(add(add("ccxt/", this.id), "-"), this.version);
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    /**
     * @method
     * @name bigone#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://open.big.one/docs/spot_deposit.html#get-deposite-address-of-one-asset-of-user
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset_symbol", getValue(currency, "id") },
        };
        var networkCodeparamsOmittedVariable = this.handleNetworkCodeAndParams(parameters);
        var networkCode = ((IList<object>) networkCodeparamsOmittedVariable)[0];
        var paramsOmitted = ((IList<object>) networkCodeparamsOmittedVariable)[1];
        object response = await this.privateGetAssetsAssetSymbolAddress(this.extend(request, paramsOmitted));
        //
        // the actual response format is not the same as the documented one
        // the data key contains an array in the actual response
        //
        //     {
        //         "code":0,
        //         "message":"",
        //         "data":[
        //             {
        //                 "id":5521878,
        //                 "chain":"Bitcoin",
        //                 "value":"1GbmyKoikhpiQVZ1C9sbF17mTyvBjeobVe",
        //                 "memo":""
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object dataLength = getArrayLength(data);
        if (isTrue(isLessThan(dataLength, 1)))
        {
            throw new ExchangeError ((string)add(this.id, " fetchDepositAddress() returned empty address response")) ;
        }
        object chainsIndexedById = this.indexBy(data, "chain");
        object selectedNetworkId = this.selectNetworkIdFromRawNetworks(code, networkCode, chainsIndexedById);
        object addressObject = this.safeDict(chainsIndexedById, selectedNetworkId, new Dictionary<string, object>() {});
        object address = this.safeString(addressObject, "value");
        object tag = this.safeString(addressObject, "memo");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "info", response },
            { "currency", code },
            { "network", this.networkIdToCode(selectedNetworkId) },
            { "address", address },
            { "tag", tag },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "WITHHOLD", "ok" },
            { "UNCONFIRMED", "pending" },
            { "CONFIRMED", "ok" },
            { "COMPLETED", "ok" },
            { "PENDING", "pending" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //     {
        //         "amount": "25.0",
        //         "asset_symbol": "BTS"
        //         "confirms": 100,
        //         "id": 5,
        //         "inserted_at": "2018-02-16T11:39:58.000Z",
        //         "is_internal": false,
        //         "kind": "default",
        //         "memo": "",
        //         "state": "WITHHOLD",
        //         "txid": "72e03037d144dae3d32b68b5045462b1049a0755",
        //         "updated_at": "2018-11-09T10:20:09.000Z",
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "amount": "5",
        //         "asset_symbol": "ETH",
        //         "completed_at": "2018-03-15T16:13:45.610463Z",
        //         "customer_id": "10",
        //         "id": 10,
        //         "inserted_at": "2018-03-15T16:13:45.610463Z",
        //         "is_internal": true,
        //         "note": "2018-03-15T16:13:45.610463Z",
        //         "state": "CONFIRMED",
        //         "target_address": "0x4643bb6b393ac20a6175c713175734a72517c63d6f7"
        //         "txid": "0x4643bb6b393ac20a6175c713175734a72517c63d6f73a3ca90a15356f2e967da0",
        //     }
        //
        // withdraw
        //
        //     {
        //         "id":1077391,
        //         "customer_id":1082679,
        //         "amount":"21.9000000000000000",
        //         "txid":"",
        //         "is_internal":false,
        //         "kind":"on_chain",
        //         "state":"PENDING",
        //         "inserted_at":"2020-06-03T00:50:57+00:00",
        //         "updated_at":"2020-06-03T00:50:57+00:00",
        //         "memo":"",
        //         "target_address":"rDYtYT3dBeuw376rvHqoZBKW3UmvguoBAf",
        //         "fee":"0.1000000000000000",
        //         "asset_symbol":"XRP"
        //     }
        //
        object currencyId = this.safeString(transaction, "asset_symbol");
        object code = this.safeCurrencyCode(currencyId);
        object id = this.safeString(transaction, "id");
        object amount = this.safeNumber(transaction, "amount");
        object status = this.parseTransactionStatus(this.safeString(transaction, "state"));
        object timestamp = this.parse8601(this.safeString(transaction, "inserted_at"));
        object updated = this.parse8601(this.safeString2(transaction, "updated_at", "completed_at"));
        object txid = this.safeString(transaction, "txid");
        object address = this.safeString(transaction, "target_address");
        object tag = this.safeString(transaction, "memo");
        object type = ((bool) isTrue((inOp(transaction, "customer_id")))) ? "withdrawal" : "deposit";
        object intern = this.safeBool(transaction, "is_internal");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", null },
            { "addressFrom", null },
            { "address", null },
            { "addressTo", address },
            { "tagFrom", null },
            { "tag", tag },
            { "tagTo", null },
            { "type", type },
            { "amount", amount },
            { "currency", code },
            { "status", status },
            { "updated", updated },
            { "fee", null },
            { "comment", null },
            { "internal", intern },
        };
    }

    /**
     * @method
     * @name bigone#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://open.big.one/docs/spot_deposit.html#deposit-of-user
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["asset_symbol"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 50
        }
        object response = await this.privateGetDeposits(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "page_token": "NQ==",
        //         "data": [
        //             {
        //                 "id": 5,
        //                 "amount": "25.0",
        //                 "confirms": 100,
        //                 "txid": "72e03037d144dae3d32b68b5045462b1049a0755",
        //                 "is_internal": false,
        //                 "inserted_at": "2018-02-16T11:39:58.000Z",
        //                 "updated_at": "2018-11-09T10:20:09.000Z",
        //                 "kind": "default",
        //                 "memo": "",
        //                 "state": "WITHHOLD",
        //                 "asset_symbol": "BTS"
        //             }
        //         ]
        //     }
        //
        object deposits = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(deposits, currency, since, limit);
    }

    /**
     * @method
     * @name bigone#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://open.big.one/docs/spot_withdrawal.html#get-withdrawals-of-user
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["asset_symbol"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 50
        }
        object response = await this.privateGetWithdrawals(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "id": 10,
        //                 "customer_id": "10",
        //                 "asset_symbol": "ETH",
        //                 "amount": "5",
        //                 "state": "CONFIRMED",
        //                 "note": "2018-03-15T16:13:45.610463Z",
        //                 "txid": "0x4643bb6b393ac20a6175c713175734a72517c63d6f73a3ca90a15356f2e967da0",
        //                 "completed_at": "2018-03-15T16:13:45.610463Z",
        //                 "inserted_at": "2018-03-15T16:13:45.610463Z",
        //                 "is_internal": true,
        //                 "target_address": "0x4643bb6b393ac20a6175c713175734a72517c63d6f7"
        //             }
        //         ],
        //         "page_token":"dxvf"
        //     }
        //
        object withdrawals = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(withdrawals, currency, since, limit);
    }

    /**
     * @method
     * @name bigone#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://open.big.one/docs/spot_transfer.html#transfer-of-user
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount 'SPOT', 'FUND', or 'CONTRACT'
     * @param {string} toAccount 'SPOT', 'FUND', or 'CONTRACT'
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountsByType = this.safeDict(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, toAccount);
        object guid = this.safeString(parameters, "guid", this.uuid());
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
            { "from", fromId },
            { "to", toId },
            { "guid", guid },
        };
        object response = await this.privatePostTransfer(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": null
        //     }
        //
        object transfer = this.parseTransfer(response, currency);
        object transferOptions = this.safeDict(this.options, "transfer", new Dictionary<string, object>() {});
        object fillResponseFromRequest = this.safeBool(transferOptions, "fillResponseFromRequest", true);
        if (isTrue(fillResponseFromRequest))
        {
            ((IDictionary<string,object>)transfer)["fromAccount"] = fromAccount;
            ((IDictionary<string,object>)transfer)["toAccount"] = toAccount;
            ((IDictionary<string,object>)transfer)["amount"] = amount;
            ((IDictionary<string,object>)transfer)["id"] = guid;
        }
        return transfer;
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        //     {
        //         "code": 0,
        //         "data": null
        //     }
        //
        object code = this.safeString(transfer, "code");
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", null },
            { "timestamp", null },
            { "datetime", null },
            { "currency", null },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", this.parseTransferStatus(code) },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "0", "ok" },
        };
        return this.safeString(statuses, status, "failed");
    }

    /**
     * @method
     * @name bigone#withdraw
     * @description make a withdrawal
     * @see https://open.big.one/docs/spot_withdrawal.html#create-withdrawal-of-user
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(currency, "id") },
            { "target_address", address },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["memo"] = tag;
        }
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["gateway_name"] = this.networkCodeToId(networkCode);
        }
        // requires write permission on the wallet
        object response = await this.privatePostWithdrawals(this.extend(request, parameters));
        //
        //     {
        //         "code":0,
        //         "message":"",
        //         "data":{
        //             "id":1077391,
        //             "customer_id":1082679,
        //             "amount":"21.9000000000000000",
        //             "txid":"",
        //             "is_internal":false,
        //             "kind":"on_chain",
        //             "state":"PENDING",
        //             "inserted_at":"2020-06-03T00:50:57+00:00",
        //             "updated_at":"2020-06-03T00:50:57+00:00",
        //             "memo":"",
        //             "target_address":"rDYtYT3dBeuw376rvHqoZBKW3UmvguoBAf",
        //             "fee":"0.1000000000000000",
        //             "asset_symbol":"XRP"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTransaction(data, currency);
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        //
        //      {"code":10013,"message":"Resource not found"}
        //      {"code":40004,"message":"invalid jwt"}
        //
        object code = this.safeString(response, "code");
        object message = this.safeString(response, "message");
        if (isTrue(isTrue((!isEqual(code, "0"))) && isTrue((!isEqual(code, null)))))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
