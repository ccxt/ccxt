namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class bitso : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bitso" },
            { "name", "Bitso" },
            { "countries", new List<object>() {"MX"} },
            { "rateLimit", 2000 },
            { "version", "v3" },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createDepositAddress", false },
                { "createOrder", true },
                { "createReduceOnlyOrder", false },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchDeposit", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", false },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLedger", true },
                { "fetchLeverage", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderTrades", true },
                { "fetchPosition", false },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsForSymbol", false },
                { "fetchPositionsHistory", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", false },
                { "fetchTime", false },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", true },
                { "fetchTransactionFee", false },
                { "fetchTransactionFees", true },
                { "fetchTransactions", false },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "reduceMargin", false },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/51840849/87295554-11f98280-c50e-11ea-80d6-15b3bafa8cbf.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "rest", "https://bitso.com/api" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "rest", "https://stage.bitso.com/api" },
                } },
                { "www", "https://bitso.com" },
                { "doc", "https://bitso.com/api_info" },
                { "fees", "https://bitso.com/fees" },
                { "referral", "https://bitso.com/?ref=itej" },
            } },
            { "precisionMode", TICK_SIZE },
            { "options", new Dictionary<string, object>() {
                { "precision", new Dictionary<string, object>() {
                    { "XRP", 0.000001 },
                    { "MXN", 0.01 },
                    { "TUSD", 0.01 },
                } },
                { "defaultPrecision", 1e-8 },
                { "networks", new Dictionary<string, object>() {
                    { "TRC20", "trx" },
                    { "ERC20", "erc20" },
                    { "BEP20", "bsc" },
                    { "BEP2", "bep2" },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "60" },
                { "5m", "300" },
                { "15m", "900" },
                { "30m", "1800" },
                { "1h", "3600" },
                { "4h", "14400" },
                { "12h", "43200" },
                { "1d", "86400" },
                { "1w", "604800" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"available_books", "ticker", "order_book", "trades", "ohlc"} },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new List<object>() {"account_status", "balance", "fees", "fundings", "fundings/{fid}", "funding_destination", "kyc_documents", "ledger", "ledger/trades", "ledger/fees", "ledger/fundings", "ledger/withdrawals", "mx_bank_codes", "open_orders", "order_trades/{oid}", "orders/{oid}", "user_trades", "user_trades/{tid}", "withdrawals/", "withdrawals/{wid}"} },
                    { "post", new List<object>() {"bitcoin_withdrawal", "debit_card_withdrawal", "ether_withdrawal", "orders", "phone_number", "phone_verification", "phone_withdrawal", "spei_withdrawal", "ripple_withdrawal", "bcash_withdrawal", "litecoin_withdrawal"} },
                    { "delete", new List<object>() {"orders", "orders/{oid}", "orders/all"} },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "0201", typeof(AuthenticationError) },
                { "104", typeof(InvalidNonce) },
                { "0304", typeof(BadRequest) },
            } },
        });
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitso#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
        * @param {string} [code] unified currency code, default is undefined
        * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int} [limit] max number of ledger entries to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetLedger(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "payload": [{
        //             "eid": "2510b3e2bc1c87f584500a18084f35ed",
        //             "created_at": "2022-06-08T12:21:42+0000",
        //             "balance_updates": [{
        //                 "amount": "0.00080000",
        //                 "currency": "btc"
        //             }],
        //             "operation": "funding",
        //             "details": {
        //                 "network": "btc",
        //                 "method": "btc",
        //                 "method_name": "Bitcoin",
        //                 "asset": "btc",
        //                 "protocol": "btc",
        //                 "integration": "bitgo-v2",
        //                 "fid": "6112c6369100d6ecceb7f54f17cf0511"
        //             }
        //         }]
        //     }
        //
        object payload = this.safeValue(response, "payload", new List<object>() {});
        object currency = this.safeCurrency(code);
        return this.parseLedger(payload, currency, since, limit);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "funding", "transaction" },
            { "withdrawal", "transaction" },
            { "trade", "trade" },
            { "fee", "fee" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //         "eid": "2510b3e2bc1c87f584500a18084f35ed",
        //         "created_at": "2022-06-08T12:21:42+0000",
        //         "balance_updates": [{
        //             "amount": "0.00080000",
        //             "currency": "btc"
        //         }],
        //         "operation": "funding",
        //         "details": {
        //             "network": "btc",
        //             "method": "btc",
        //             "method_name": "Bitcoin",
        //             "asset": "btc",
        //             "protocol": "btc",
        //             "integration": "bitgo-v2",
        //             "fid": "6112c6369100d6ecceb7f54f17cf0511"
        //         }
        //     }
        //
        //  trade
        //     {
        //         "eid": "8976c6053f078f704f037d82a813678a",
        //         "created_at": "2022-06-08T17:01:48+0000",
        //         "balance_updates": [{
        //                 "amount": "59.21320500",
        //                 "currency": "mxn"
        //             },
        //             {
        //                 "amount": "-0.00010000",
        //                 "currency": "btc"
        //             }
        //         ],
        //         "operation": "trade",
        //         "details": {
        //             "tid": "72145428",
        //             "oid": "JO5TZmMZjzjlZDyT"
        //         }
        //     }
        //
        //  fee
        //     {
        //         "eid": "cbbb3c8d4e41723d25d2850dcb7c3c74",
        //         "created_at": "2022-06-08T17:01:48+0000",
        //         "balance_updates": [{
        //             "amount": "-0.38488583",
        //             "currency": "mxn"
        //         }],
        //         "operation": "fee",
        //         "details": {
        //             "tid": "72145428",
        //             "oid": "JO5TZmMZjzjlZDyT"
        //         }
        //     }
        object operation = this.safeString(item, "operation");
        object type = this.parseLedgerEntryType(operation);
        object balanceUpdates = this.safeValue(item, "balance_updates", new List<object>() {});
        object firstBalance = this.safeValue(balanceUpdates, 0, new Dictionary<string, object>() {});
        object direction = null;
        object fee = null;
        object amount = this.safeString(firstBalance, "amount");
        object currencyId = this.safeString(firstBalance, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        currency = this.safeCurrency(currencyId, currency);
        object details = this.safeValue(item, "details", new Dictionary<string, object>() {});
        object referenceId = this.safeString2(details, "fid", "wid");
        if (isTrue(isEqual(referenceId, null)))
        {
            referenceId = this.safeString(details, "tid");
        }
        if (isTrue(isEqual(operation, "funding")))
        {
            direction = "in";
        } else if (isTrue(isEqual(operation, "withdrawal")))
        {
            direction = "out";
        } else if (isTrue(isEqual(operation, "trade")))
        {
            direction = null;
        } else if (isTrue(isEqual(operation, "fee")))
        {
            direction = "out";
            object cost = Precise.stringAbs(amount);
            fee = new Dictionary<string, object>() {
                { "cost", cost },
                { "currency", currency },
            };
        }
        object timestamp = this.parse8601(this.safeString(item, "created_at"));
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", this.safeString(item, "eid") },
            { "direction", direction },
            { "account", null },
            { "referenceId", referenceId },
            { "referenceAccount", null },
            { "type", type },
            { "currency", code },
            { "amount", amount },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "before", null },
            { "after", null },
            { "status", "ok" },
            { "fee", fee },
        }, currency);
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name bitso#fetchMarkets
        * @description retrieves data on all markets for bitso
        * @see https://docs.bitso.com/bitso-api/docs/list-available-books
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetAvailableBooks(parameters);
        //
        //     {
        //         "success":true,
        //         "payload":[
        //             {
        //                 "book":"btc_mxn",
        //                 "minimum_price":"500",
        //                 "maximum_price":"10000000",
        //                 "minimum_amount":"0.00005",
        //                 "maximum_amount":"500",
        //                 "minimum_value":"5",
        //                 "maximum_value":"10000000",
        //                 "tick_size":"0.01",
        //                 "fees":{
        //                     "flat_rate":{"maker":"0.500","taker":"0.650"},
        //                     "structure":[
        //                         {"volume":"1500000","maker":"0.00500","taker":"0.00650"},
        //                         {"volume":"2000000","maker":"0.00490","taker":"0.00637"},
        //                         {"volume":"5000000","maker":"0.00480","taker":"0.00624"},
        //                         {"volume":"7000000","maker":"0.00440","taker":"0.00572"},
        //                         {"volume":"10000000","maker":"0.00420","taker":"0.00546"},
        //                         {"volume":"15000000","maker":"0.00400","taker":"0.00520"},
        //                         {"volume":"35000000","maker":"0.00370","taker":"0.00481"},
        //                         {"volume":"50000000","maker":"0.00300","taker":"0.00390"},
        //                         {"volume":"150000000","maker":"0.00200","taker":"0.00260"},
        //                         {"volume":"250000000","maker":"0.00100","taker":"0.00130"},
        //                         {"volume":"9999999999","maker":"0.00000","taker":"0.00130"},
        //                     ]
        //                 }
        //             },
        //         ]
        //     }
        object markets = this.safeValue(response, "payload", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object id = this.safeString(market, "book");
            var baseIdquoteIdVariable = ((string)id).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
            var baseId = ((IList<object>) baseIdquoteIdVariable)[0];
            var quoteId = ((IList<object>) baseIdquoteIdVariable)[1];
            object bs = ((string)baseId).ToUpper();
            object quote = ((string)quoteId).ToUpper();
            bs = this.safeCurrencyCode(bs);
            quote = this.safeCurrencyCode(quote);
            object fees = this.safeValue(market, "fees", new Dictionary<string, object>() {});
            object flatRate = this.safeValue(fees, "flat_rate", new Dictionary<string, object>() {});
            object takerString = this.safeString(flatRate, "taker");
            object makerString = this.safeString(flatRate, "maker");
            object taker = this.parseNumber(Precise.stringDiv(takerString, "100"));
            object maker = this.parseNumber(Precise.stringDiv(makerString, "100"));
            object feeTiers = this.safeValue(fees, "structure", new List<object>() {});
            object fee = new Dictionary<string, object>() {
                { "taker", taker },
                { "maker", maker },
                { "percentage", true },
                { "tierBased", true },
            };
            object takerFees = new List<object>() {};
            object makerFees = new List<object>() {};
            for (object j = 0; isLessThan(j, getArrayLength(feeTiers)); postFixIncrement(ref j))
            {
                object tier = getValue(feeTiers, j);
                object volume = this.safeNumber(tier, "volume");
                object takerFee = this.safeNumber(tier, "taker");
                object makerFee = this.safeNumber(tier, "maker");
                ((IList<object>)takerFees).Add(new List<object>() {volume, takerFee});
                ((IList<object>)makerFees).Add(new List<object>() {volume, makerFee});
                if (isTrue(isEqual(j, 0)))
                {
                    ((IDictionary<string,object>)fee)["taker"] = takerFee;
                    ((IDictionary<string,object>)fee)["maker"] = makerFee;
                }
            }
            object tiers = new Dictionary<string, object>() {
                { "taker", takerFees },
                { "maker", makerFees },
            };
            ((IDictionary<string,object>)fee)["tiers"] = tiers;
            // TODO: precisions can be also set from https://bitso.com/api/v3/catalogues ->available_currency_conversions->currencies (or ->currencies->metadata)  or https://bitso.com/api/v3/get_exchange_rates/mxn
            object defaultPricePrecision = this.safeNumber(getValue(this.options, "precision"), quote, getValue(this.options, "defaultPrecision"));
            ((IList<object>)result).Add(this.extend(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", null },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", taker },
                { "maker", maker },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.safeNumber(getValue(this.options, "precision"), bs, getValue(this.options, "defaultPrecision")) },
                    { "price", this.safeNumber(market, "tick_size", defaultPricePrecision) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minimum_amount") },
                        { "max", this.safeNumber(market, "maximum_amount") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minimum_price") },
                        { "max", this.safeNumber(market, "maximum_price") },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minimum_value") },
                        { "max", this.safeNumber(market, "maximum_value") },
                    } },
                } },
                { "created", null },
                { "info", market },
            }, fee));
        }
        return result;
    }

    public override object parseBalance(object response)
    {
        object payload = this.safeValue(response, "payload", new Dictionary<string, object>() {});
        object balances = this.safeValue(payload, "balances", new List<object>() {});
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object currencyId = this.safeString(balance, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "available");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "locked");
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "total");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bitso#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://docs.bitso.com/bitso-api/docs/get-account-balance
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetBalance(parameters);
        //
        //     {
        //       "success": true,
        //       "payload": {
        //         "balances": [
        //           {
        //             "currency": "bat",
        //             "available": "0.00000000",
        //             "locked": "0.00000000",
        //             "total": "0.00000000",
        //             "pending_deposit": "0.00000000",
        //             "pending_withdrawal": "0.00000000"
        //           },
        //           {
        //             "currency": "bch",
        //             "available": "0.00000000",
        //             "locked": "0.00000000",
        //             "total": "0.00000000",
        //             "pending_deposit": "0.00000000",
        //             "pending_withdrawal": "0.00000000"
        //           },
        //         ],
        //       },
        //     }
        //
        return this.parseBalance(response);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitso#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://docs.bitso.com/bitso-api/docs/list-order-book
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "book", getValue(market, "id") },
        };
        object response = await this.publicGetOrderBook(this.extend(request, parameters));
        object orderbook = this.safeValue(response, "payload");
        object timestamp = this.parse8601(this.safeString(orderbook, "updated_at"));
        return this.parseOrderBook(orderbook, getValue(market, "symbol"), timestamp, "bids", "asks", "price", "amount");
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "high":"37446.85",
        //         "last":"36599.54",
        //         "created_at":"2022-01-28T12:06:11+00:00",
        //         "book":"btc_usdt",
        //         "volume":"7.29075419",
        //         "vwap":"36579.1564400307",
        //         "low":"35578.52",
        //         "ask":"36574.76",
        //         "bid":"36538.22",
        //         "change_24":"-105.64"
        //     }
        //
        object symbol = this.safeSymbol(null, market);
        object timestamp = this.parse8601(this.safeString(ticker, "created_at"));
        object vwap = this.safeString(ticker, "vwap");
        object baseVolume = this.safeString(ticker, "volume");
        object quoteVolume = Precise.stringMul(baseVolume, vwap);
        object last = this.safeString(ticker, "last");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(ticker, "bid") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "ask") },
            { "askVolume", null },
            { "vwap", vwap },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitso#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://docs.bitso.com/bitso-api/docs/ticker
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "book", getValue(market, "id") },
        };
        object response = await this.publicGetTicker(this.extend(request, parameters));
        object ticker = this.safeValue(response, "payload");
        //
        //     {
        //         "success":true,
        //         "payload":{
        //             "high":"37446.85",
        //             "last":"37051.96",
        //             "created_at":"2022-01-28T17:03:29+00:00",
        //             "book":"btc_usdt",
        //             "volume":"6.16176186",
        //             "vwap":"36582.6293169472",
        //             "low":"35578.52",
        //             "ask":"37083.62",
        //             "bid":"37039.66",
        //             "change_24":"478.45"
        //         }
        //     }
        //
        return this.parseTicker(ticker, market);
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitso#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "book", getValue(market, "id") },
            { "time_bucket", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = since;
            if (isTrue(!isEqual(limit, null)))
            {
                object duration = this.parseTimeframe(timeframe);
                ((IDictionary<string,object>)request)["end"] = this.sum(since, multiply(multiply(duration, limit), 1000));
            }
        } else if (isTrue(!isEqual(limit, null)))
        {
            object now = this.milliseconds();
            ((IDictionary<string,object>)request)["end"] = now;
            ((IDictionary<string,object>)request)["start"] = subtract(now, multiply(multiply(this.parseTimeframe(timeframe), 1000), limit));
        }
        object response = await this.publicGetOhlc(this.extend(request, parameters));
        //
        //     {
        //         "success":true,
        //         "payload": [
        //             {
        //                 "bucket_start_time":1648219140000,
        //                 "first_trade_time":1648219154990,
        //                 "last_trade_time":1648219189441,
        //                 "first_rate":"44958.60",
        //                 "last_rate":"44979.88",
        //                 "min_rate":"44957.33",
        //                 "max_rate":"44979.88",
        //                 "trade_count":8,
        //                 "volume":"0.00082814",
        //                 "vwap":"44965.02"
        //             },
        //         ]
        //     }
        //
        object payload = this.safeList(response, "payload", new List<object>() {});
        return this.parseOHLCVs(payload, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "bucket_start_time":1648219140000,
        //         "first_trade_time":1648219154990,
        //         "last_trade_time":1648219189441,
        //         "first_rate":"44958.60",
        //         "last_rate":"44979.88",
        //         "min_rate":"44957.33",
        //         "max_rate":"44979.88",
        //         "trade_count":8,
        //         "volume":"0.00082814",
        //         "vwap":"44965.02"
        //     },
        //
        return new List<object> {this.safeInteger(ohlcv, "bucket_start_time"), this.safeNumber(ohlcv, "first_rate"), this.safeNumber(ohlcv, "max_rate"), this.safeNumber(ohlcv, "min_rate"), this.safeNumber(ohlcv, "last_rate"), this.safeNumber(ohlcv, "volume")};
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //      {
        //          "book": "btc_usdt",
        //          "created_at": "2021-11-24T12:14:53+0000",
        //          "amount": "0.00026562",
        //          "maker_side": "sell",
        //          "price": "56471.55",
        //          "tid": "52557338"
        //      }
        //
        // fetchMyTrades (private)
        //
        //      {
        //          "book": "btc_usdt",
        //          "created_at": "2021-11-24T12:31:03+0000",
        //          "minor": "11.30356000",
        //          "major": "-0.00020000",
        //          "fees_amount": "0.01119052",
        //          "fees_currency": "usdt",
        //          "minor_currency": "usdt",
        //          "major_currency": "btc",
        //          "oid": "djTzMIWx2Vi3iMjl",
        //          "tid": "52559051",
        //          "price": "56517.80",
        //          "side": "sell",
        //          "maker_side": "buy"
        //      }
        //
        // fetchOrderTrades (private)
        //
        //      {
        //          "book": "btc_usdt",
        //          "created_at": "2021-11-24T12:30:52+0000",
        //          "minor": "-11.33047916",
        //          "major": "0.00020020",
        //          "fees_amount": "0.00000020",
        //          "fees_currency": "btc",
        //          "minor_currency": "usdt",
        //          "major_currency": "btc",
        //          "oid": "O0D2zcljjjQF5xlG",
        //          "tid": "52559030",
        //          "price": "56595.80",
        //          "side": "buy",
        //          "maker_side": "sell"
        //      }
        //
        object timestamp = this.parse8601(this.safeString(trade, "created_at"));
        object marketId = this.safeString(trade, "book");
        object symbol = this.safeSymbol(marketId, market, "_");
        object side = this.safeString(trade, "side");
        object makerSide = this.safeString(trade, "maker_side");
        object takerOrMaker = null;
        if (isTrue(!isEqual(side, null)))
        {
            if (isTrue(isEqual(side, makerSide)))
            {
                takerOrMaker = "maker";
            } else
            {
                takerOrMaker = "taker";
            }
        } else
        {
            if (isTrue(isEqual(makerSide, "buy")))
            {
                side = "sell";
            } else
            {
                side = "buy";
            }
        }
        object amount = this.safeString2(trade, "amount", "major");
        if (isTrue(!isEqual(amount, null)))
        {
            amount = Precise.stringAbs(amount);
        }
        object fee = null;
        object feeCost = this.safeString(trade, "fees_amount");
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrencyId = this.safeString(trade, "fees_currency");
            object feeCurrency = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrency },
            };
        }
        object cost = this.safeString(trade, "minor");
        if (isTrue(!isEqual(cost, null)))
        {
            cost = Precise.stringAbs(cost);
        }
        object price = this.safeString(trade, "price");
        object orderId = this.safeString(trade, "oid");
        object id = this.safeString(trade, "tid");
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "order", orderId },
            { "type", null },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitso#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://docs.bitso.com/bitso-api/docs/list-trades
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "book", getValue(market, "id") },
        };
        object response = await this.publicGetTrades(this.extend(request, parameters));
        return this.parseTrades(getValue(response, "payload"), market, since, limit);
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name bitso#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @see https://docs.bitso.com/bitso-api/docs/list-fees
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetFees(parameters);
        //
        //    {
        //        "success": true,
        //        "payload": {
        //            "fees": [
        //                {
        //                    "book": "btc_mxn",
        //                    "fee_percent": "0.6500",
        //                    "fee_decimal": "0.00650000",
        //                    "taker_fee_percent": "0.6500",
        //                    "taker_fee_decimal": "0.00650000",
        //                    "maker_fee_percent": "0.5000",
        //                    "maker_fee_decimal": "0.00500000",
        //                    "volume_currency": "mxn",
        //                    "current_volume": "0.00",
        //                    "next_volume": "1500000.00",
        //                    "next_maker_fee_percent": "0.490",
        //                    "next_taker_fee_percent": "0.637",
        //                    "nextVolume": "1500000.00",
        //                    "nextFee": "0.490",
        //                    "nextTakerFee": "0.637"
        //                },
        //                ...
        //            ],
        //            "deposit_fees": [
        //                {
        //                    "currency": "btc",
        //                    "method": "rewards",
        //                    "fee": "0.00",
        //                    "is_fixed": false
        //                },
        //                ...
        //            ],
        //            "withdrawal_fees": {
        //                "ada": "0.20958100",
        //                "bch": "0.00009437",
        //                "ars": "0",
        //                "btc": "0.00001209",
        //                ...
        //            }
        //        }
        //    }
        //
        object payload = this.safeValue(response, "payload", new Dictionary<string, object>() {});
        object fees = this.safeValue(payload, "fees", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(fees)); postFixIncrement(ref i))
        {
            object fee = getValue(fees, i);
            object marketId = this.safeString(fee, "book");
            object symbol = this.safeSymbol(marketId, null, "_");
            ((IDictionary<string,object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "info", fee },
                { "symbol", symbol },
                { "maker", this.safeNumber(fee, "maker_fee_decimal") },
                { "taker", this.safeNumber(fee, "taker_fee_decimal") },
                { "percentage", true },
                { "tierBased", true },
            };
        }
        return result;
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitso#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://docs.bitso.com/bitso-api/docs/user-trades
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        limit ??= 25;
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        // the don't support fetching trades starting from a date yet
        // use the `marker` extra param for that
        // this is not a typo, the variable name is 'marker' (don't confuse with 'market')
        object markerInParams = (inOp(parameters, "marker"));
        // warn the user with an exception if the user wants to filter
        // starting from since timestamp, but does not set the trade id with an extra 'marker' param
        if (isTrue(isTrue((!isEqual(since, null))) && !isTrue(markerInParams)))
        {
            throw new ExchangeError ((string)add(this.id, " fetchMyTrades() does not support fetching trades starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id")) ;
        }
        // convert it to an integer unconditionally
        if (isTrue(markerInParams))
        {
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "marker", parseInt(getValue(parameters, "marker")) },
            });
        }
        object request = new Dictionary<string, object>() {
            { "book", getValue(market, "id") },
            { "limit", limit },
        };
        object response = await this.privateGetUserTrades(this.extend(request, parameters));
        return this.parseTrades(getValue(response, "payload"), market, since, limit);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitso#createOrder
        * @description create a trade order
        * @see https://docs.bitso.com/bitso-api/docs/place-an-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "book", getValue(market, "id") },
            { "side", side },
            { "type", type },
            { "major", this.amountToPrecision(getValue(market, "symbol"), amount) },
        };
        if (isTrue(isEqual(type, "limit")))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(getValue(market, "symbol"), price);
        }
        object response = await this.privatePostOrders(this.extend(request, parameters));
        object id = this.safeString(getValue(response, "payload"), "oid");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", response },
            { "id", id },
        }, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitso#cancelOrder
        * @description cancels an open order
        * @see https://docs.bitso.com/bitso-api/docs/cancel-an-order
        * @param {string} id order id
        * @param {string} symbol not used by bitso cancelOrder ()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "oid", id },
        };
        object response = await this.privateDeleteOrdersOid(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "payload": ["yWTQGxDMZ0VimZgZ"]
        //     }
        //
        object payload = this.safeList(response, "payload", new List<object>() {});
        object orderId = this.safeString(payload, 0);
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", response },
            { "id", orderId },
        });
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitso#cancelOrders
        * @description cancel multiple orders
        * @see https://docs.bitso.com/bitso-api/docs/cancel-an-order
        * @param {string[]} ids order ids
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(((ids is IList<object>) || (ids.GetType().IsGenericType && ids.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() ids argument should be an array")) ;
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object oids = String.Join(",", ((IList<object>)ids).ToArray());
        object request = new Dictionary<string, object>() {
            { "oids", oids },
        };
        object response = await this.privateDeleteOrders(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "payload": ["yWTQGxDMZ0VimZgZ"]
        //     }
        //
        object payload = this.safeValue(response, "payload", new List<object>() {});
        object orders = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(payload)); postFixIncrement(ref i))
        {
            object id = getValue(payload, i);
            ((IList<object>)orders).Add(this.parseOrder(id, market));
        }
        return orders;
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitso#cancelAllOrders
        * @description cancel all open orders
        * @see https://docs.bitso.com/bitso-api/docs/cancel-an-order
        * @param {undefined} symbol bitso does not support canceling orders for only a specific market
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(!isEqual(symbol, null)))
        {
            throw new NotSupported ((string)add(this.id, " cancelAllOrders() deletes all orders for user, it does not support filtering by symbol.")) ;
        }
        object response = await this.privateDeleteOrdersAll(parameters);
        //
        //     {
        //         "success": true,
        //         "payload": ["NWUZUYNT12ljwzDT", "kZUkZmQ2TTjkkYTY"]
        //     }
        //
        object payload = this.safeValue(response, "payload", new List<object>() {});
        object canceledOrders = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(payload)); postFixIncrement(ref i))
        {
            object order = this.parseOrder(getValue(payload, i));
            ((IList<object>)canceledOrders).Add(order);
        }
        return canceledOrders;
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "partial-fill", "open" },
            { "partially filled", "open" },
            { "queued", "open" },
            { "completed", "closed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        //
        // canceledOrder
        // yWTQGxDMZ0VimZgZ
        //
        object id = null;
        if (isTrue((order is string)))
        {
            id = order;
        } else
        {
            id = this.safeString(order, "oid");
        }
        object side = this.safeString(order, "side");
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object marketId = this.safeString(order, "book");
        object symbol = this.safeSymbol(marketId, market, "_");
        object orderType = this.safeString(order, "type");
        object timestamp = this.parse8601(this.safeString(order, "created_at"));
        object price = this.safeString(order, "price");
        object amount = this.safeString(order, "original_amount");
        object remaining = this.safeString(order, "unfilled_amount");
        object clientOrderId = this.safeString(order, "client_id");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", symbol },
            { "type", orderType },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "amount", amount },
            { "cost", null },
            { "remaining", remaining },
            { "filled", null },
            { "status", status },
            { "fee", null },
            { "average", null },
            { "trades", null },
        }, market);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitso#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://docs.bitso.com/bitso-api/docs/list-open-orders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        limit ??= 25;
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        // the don't support fetching trades starting from a date yet
        // use the `marker` extra param for that
        // this is not a typo, the variable name is 'marker' (don't confuse with 'market')
        object markerInParams = (inOp(parameters, "marker"));
        // warn the user with an exception if the user wants to filter
        // starting from since timestamp, but does not set the trade id with an extra 'marker' param
        if (isTrue(isTrue((!isEqual(since, null))) && !isTrue(markerInParams)))
        {
            throw new ExchangeError ((string)add(this.id, " fetchOpenOrders() does not support fetching orders starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id")) ;
        }
        // convert it to an integer unconditionally
        if (isTrue(markerInParams))
        {
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "marker", parseInt(getValue(parameters, "marker")) },
            });
        }
        object request = new Dictionary<string, object>() {
            { "book", getValue(market, "id") },
            { "limit", limit },
        };
        object response = await this.privateGetOpenOrders(this.extend(request, parameters));
        object orders = this.parseOrders(getValue(response, "payload"), market, since, limit);
        return orders;
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitso#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://docs.bitso.com/bitso-api/docs/look-up-orders
        * @param {string} id the order id
        * @param {string} symbol not used by bitso fetchOrder
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetOrdersOid(new Dictionary<string, object>() {
            { "oid", id },
        });
        object payload = this.safeValue(response, "payload");
        if (isTrue(((payload is IList<object>) || (payload.GetType().IsGenericType && payload.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            object numOrders = getArrayLength(getValue(response, "payload"));
            if (isTrue(isEqual(numOrders, 1)))
            {
                return this.parseOrder(getValue(payload, 0));
            }
        }
        throw new OrderNotFound ((string)add(add(add(this.id, ": The order "), id), " not found.")) ;
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitso#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @see https://docs.bitso.com/bitso-api/docs/list-user-trades
        * @param {string} id order id
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "oid", id },
        };
        object response = await this.privateGetOrderTradesOid(this.extend(request, parameters));
        return this.parseTrades(getValue(response, "payload"), market);
    }

    public async virtual Task<object> fetchDeposit(object id, object code = null, object parameters = null)
    {
        /**
        * @method
        * @name bitso#fetchDeposit
        * @description fetch information on a deposit
        * @see https://docs.bitso.com/bitso-payouts-funding/docs/fundings
        * @param {string} id deposit id
        * @param {string} code bitso does not support filtering by currency code and will ignore this argument
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "fid", id },
        };
        object response = await this.privateGetFundingsFid(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "payload": [{
        //             "fid": "6112c6369100d6ecceb7f54f17cf0511",
        //             "status": "complete",
        //             "created_at": "2022-06-08T12:02:49+0000",
        //             "currency": "btc",
        //             "method": "btc",
        //             "method_name": "Bitcoin",
        //             "amount": "0.00080000",
        //             "asset": "btc",
        //             "network": "btc",
        //             "protocol": "btc",
        //             "integration": "bitgo-v2",
        //             "details": {
        //                 "receiving_address": "3N2vbcYKhogs6RoTb4eYCUJ3beRSqLgSif",
        //                 "tx_hash": "327f3838531f211485ec59f9d0a119fea1595591e274d942b2c10b9b8262eb1d",
        //                 "confirmations": "4"
        //             }
        //         }]
        //     }
        //
        object transactions = this.safeValue(response, "payload", new List<object>() {});
        object first = this.safeDict(transactions, 0, new Dictionary<string, object>() {});
        return this.parseTransaction(first);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitso#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://docs.bitso.com/bitso-payouts-funding/docs/fundings
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object response = await this.privateGetFundings(parameters);
        //
        //     {
        //         "success": true,
        //         "payload": [{
        //             "fid": "6112c6369100d6ecceb7f54f17cf0511",
        //             "status": "complete",
        //             "created_at": "2022-06-08T12:02:49+0000",
        //             "currency": "btc",
        //             "method": "btc",
        //             "method_name": "Bitcoin",
        //             "amount": "0.00080000",
        //             "asset": "btc",
        //             "network": "btc",
        //             "protocol": "btc",
        //             "integration": "bitgo-v2",
        //             "details": {
        //                 "receiving_address": "3N2vbcYKhogs6RoTb4eYCUJ3beRSqLgSif",
        //                 "tx_hash": "327f3838531f211485ec59f9d0a119fea1595591e274d942b2c10b9b8262eb1d",
        //                 "confirmations": "4"
        //             }
        //         }]
        //     }
        //
        object transactions = this.safeList(response, "payload", new List<object>() {});
        return this.parseTransactions(transactions, currency, since, limit, parameters);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name bitso#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "fund_currency", getValue(currency, "id") },
        };
        object response = await this.privateGetFundingDestination(this.extend(request, parameters));
        object address = this.safeString(getValue(response, "payload"), "account_identifier");
        object tag = null;
        if (isTrue(isGreaterThanOrEqual(getIndexOf(address, "?dt="), 0)))
        {
            object parts = ((string)address).Split(new [] {((string)"?dt=")}, StringSplitOptions.None).ToList<object>();
            address = this.safeString(parts, 0);
            tag = this.safeString(parts, 1);
        }
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "info", response },
            { "currency", code },
            { "network", null },
            { "address", address },
            { "tag", tag },
        };
    }

    public async override Task<object> fetchTransactionFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name bitso#fetchTransactionFees
        * @deprecated
        * @description please use fetchDepositWithdrawFees instead
        * @see https://docs.bitso.com/bitso-api/docs/list-fees
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetFees(parameters);
        //
        //    {
        //        "success": true,
        //        "payload": {
        //            "fees": [
        //                {
        //                    "book": "btc_mxn",
        //                    "fee_percent": "0.6500",
        //                    "fee_decimal": "0.00650000",
        //                    "taker_fee_percent": "0.6500",
        //                    "taker_fee_decimal": "0.00650000",
        //                    "maker_fee_percent": "0.5000",
        //                    "maker_fee_decimal": "0.00500000",
        //                    "volume_currency": "mxn",
        //                    "current_volume": "0.00",
        //                    "next_volume": "1500000.00",
        //                    "next_maker_fee_percent": "0.490",
        //                    "next_taker_fee_percent": "0.637",
        //                    "nextVolume": "1500000.00",
        //                    "nextFee": "0.490",
        //                    "nextTakerFee": "0.637"
        //                },
        //                ...
        //            ],
        //            "deposit_fees": [
        //                {
        //                    "currency": "btc",
        //                    "method": "rewards",
        //                    "fee": "0.00",
        //                    "is_fixed": false
        //                },
        //                ...
        //            ],
        //            "withdrawal_fees": {
        //                "ada": "0.20958100",
        //                "bch": "0.00009437",
        //                "ars": "0",
        //                "btc": "0.00001209",
        //                ...
        //            }
        //        }
        //    }
        //
        object result = new Dictionary<string, object>() {};
        object payload = this.safeValue(response, "payload", new Dictionary<string, object>() {});
        object depositFees = this.safeValue(payload, "deposit_fees", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(depositFees)); postFixIncrement(ref i))
        {
            object depositFee = getValue(depositFees, i);
            object currencyId = this.safeString(depositFee, "currency");
            object code = this.safeCurrencyCode(currencyId);
            if (isTrue(isTrue((!isEqual(codes, null))) && !isTrue(this.inArray(code, codes))))
            {
                continue;
            }
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "deposit", this.safeNumber(depositFee, "fee") },
                { "withdraw", null },
                { "info", new Dictionary<string, object>() {
                    { "deposit", depositFee },
                    { "withdraw", null },
                } },
            };
        }
        object withdrawalFees = this.safeValue(payload, "withdrawal_fees", new List<object>() {});
        object currencyIds = new List<object>(((IDictionary<string,object>)withdrawalFees).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencyIds, i);
            object code = this.safeCurrencyCode(currencyId);
            if (isTrue(isTrue((!isEqual(codes, null))) && !isTrue(this.inArray(code, codes))))
            {
                continue;
            }
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "deposit", this.safeValue(getValue(result, code), "deposit") },
                { "withdraw", this.safeNumber(withdrawalFees, currencyId) },
                { "info", new Dictionary<string, object>() {
                    { "deposit", this.safeValue(getValue(getValue(result, code), "info"), "deposit") },
                    { "withdraw", this.safeNumber(withdrawalFees, currencyId) },
                } },
            };
        }
        return result;
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name bitso#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://docs.bitso.com/bitso-api/docs/list-fees
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetFees(parameters);
        //
        //    {
        //        "success": true,
        //        "payload": {
        //            "fees": [
        //                {
        //                    "book": "btc_mxn",
        //                    "fee_percent": "0.6500",
        //                    "fee_decimal": "0.00650000",
        //                    "taker_fee_percent": "0.6500",
        //                    "taker_fee_decimal": "0.00650000",
        //                    "maker_fee_percent": "0.5000",
        //                    "maker_fee_decimal": "0.00500000",
        //                    "volume_currency": "mxn",
        //                    "current_volume": "0.00",
        //                    "next_volume": "1500000.00",
        //                    "next_maker_fee_percent": "0.490",
        //                    "next_taker_fee_percent": "0.637",
        //                    "nextVolume": "1500000.00",
        //                    "nextFee": "0.490",
        //                    "nextTakerFee": "0.637"
        //                },
        //                ...
        //            ],
        //            "deposit_fees": [
        //                {
        //                    "currency": "btc",
        //                    "method": "rewards",
        //                    "fee": "0.00",
        //                    "is_fixed": false
        //                },
        //                ...
        //            ],
        //            "withdrawal_fees": {
        //                "ada": "0.20958100",
        //                "bch": "0.00009437",
        //                "ars": "0",
        //                "btc": "0.00001209",
        //                ...
        //            }
        //        }
        //    }
        //
        object payload = this.safeList(response, "payload", new List<object>() {});
        return this.parseDepositWithdrawFees(payload, codes);
    }

    public override object parseDepositWithdrawFees(object response, object codes = null, object currencyIdKey = null)
    {
        //
        //    {
        //        "fees": [
        //            {
        //                "book": "btc_mxn",
        //                "fee_percent": "0.6500",
        //                "fee_decimal": "0.00650000",
        //                "taker_fee_percent": "0.6500",
        //                "taker_fee_decimal": "0.00650000",
        //                "maker_fee_percent": "0.5000",
        //                "maker_fee_decimal": "0.00500000",
        //                "volume_currency": "mxn",
        //                "current_volume": "0.00",
        //                "next_volume": "1500000.00",
        //                "next_maker_fee_percent": "0.490",
        //                "next_taker_fee_percent": "0.637",
        //                "nextVolume": "1500000.00",
        //                "nextFee": "0.490",
        //                "nextTakerFee": "0.637"
        //            },
        //            ...
        //        ],
        //        "deposit_fees": [
        //            {
        //                "currency": "btc",
        //                "method": "rewards",
        //                "fee": "0.00",
        //                "is_fixed": false
        //            },
        //            ...
        //        ],
        //        "withdrawal_fees": {
        //            "ada": "0.20958100",
        //            "bch": "0.00009437",
        //            "ars": "0",
        //            "btc": "0.00001209",
        //            ...
        //        }
        //    }
        //
        object result = new Dictionary<string, object>() {};
        object depositResponse = this.safeValue(response, "deposit_fees", new List<object>() {});
        object withdrawalResponse = this.safeValue(response, "withdrawal_fees", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(depositResponse)); postFixIncrement(ref i))
        {
            object entry = getValue(depositResponse, i);
            object currencyId = this.safeString(entry, "currency");
            object code = this.safeCurrencyCode(currencyId);
            if (isTrue(isTrue((isEqual(codes, null))) || isTrue((inOp(codes, code)))))
            {
                ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                    { "deposit", new Dictionary<string, object>() {
                        { "fee", this.safeNumber(entry, "fee") },
                        { "percentage", !isTrue(this.safeValue(entry, "is_fixed")) },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "fee", null },
                        { "percentage", null },
                    } },
                    { "networks", new Dictionary<string, object>() {} },
                    { "info", entry },
                };
            }
        }
        object withdrawalKeys = new List<object>(((IDictionary<string,object>)withdrawalResponse).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(withdrawalKeys)); postFixIncrement(ref i))
        {
            object currencyId = getValue(withdrawalKeys, i);
            object code = this.safeCurrencyCode(currencyId);
            if (isTrue(isTrue((isEqual(codes, null))) || isTrue((inOp(codes, code)))))
            {
                object withdrawFee = this.parseNumber(getValue(withdrawalResponse, currencyId));
                object resultValue = this.safeValue(result, code);
                if (isTrue(isEqual(resultValue, null)))
                {
                    ((IDictionary<string,object>)result)[(string)code] = this.depositWithdrawFee(new Dictionary<string, object>() {});
                }
                ((IDictionary<string,object>)getValue(getValue(result, code), "withdraw"))["fee"] = withdrawFee;
                ((IDictionary<string,object>)getValue(getValue(result, code), "info"))[(string)code] = withdrawFee;
            }
        }
        return result;
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name bitso#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object methods = new Dictionary<string, object>() {
            { "BTC", "Bitcoin" },
            { "ETH", "Ether" },
            { "XRP", "Ripple" },
            { "BCH", "Bcash" },
            { "LTC", "Litecoin" },
        };
        object currency = this.currency(code);
        object method = ((bool) isTrue((inOp(methods, code)))) ? getValue(methods, code) : null;
        if (isTrue(isEqual(method, null)))
        {
            throw new ExchangeError ((string)add(add(this.id, " not valid withdraw coin: "), code)) ;
        }
        object request = new Dictionary<string, object>() {
            { "amount", amount },
            { "address", address },
            { "destination_tag", tag },
        };
        object classMethod = add(add("privatePost", method), "Withdrawal");
        object response = await ((Task<object>)callDynamically(this, classMethod, new object[] { this.extend(request, parameters) }));
        //
        //     {
        //         "success": true,
        //         "payload": [
        //             {
        //                 "wid": "c5b8d7f0768ee91d3b33bee648318688",
        //                 "status": "pending",
        //                 "created_at": "2016-04-08T17:52:31.000+00:00",
        //                 "currency": "btc",
        //                 "method": "Bitcoin",
        //                 "amount": "0.48650929",
        //                 "details": {
        //                     "withdrawal_address": "18MsnATiNiKLqUHDTRKjurwMg7inCrdNEp",
        //                     "tx_hash": "d4f28394693e9fb5fffcaf730c11f32d1922e5837f76ca82189d3bfe30ded433"
        //                 }
        //             },
        //         ]
        //     }
        //
        object payload = this.safeValue(response, "payload", new List<object>() {});
        object first = this.safeDict(payload, 0);
        return this.parseTransaction(first, currency);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // deposit
        //     {
        //         "fid": "6112c6369100d6ecceb7f54f17cf0511",
        //         "status": "complete",
        //         "created_at": "2022-06-08T12:02:49+0000",
        //         "currency": "btc",
        //         "method": "btc",
        //         "method_name": "Bitcoin",
        //         "amount": "0.00080000",
        //         "asset": "btc",
        //         "network": "btc",
        //         "protocol": "btc",
        //         "integration": "bitgo-v2",
        //         "details": {
        //             "receiving_address": "3NmvbcYKhogs6RoTb4eYCUJ3beRSqLgSif",
        //             "tx_hash": "327f3838531f611485ec59f9d0a119fea1595591e274d942b2c10b9b8262eb1d",
        //             "confirmations": "4"
        //         }
        //     }
        //
        // withdraw
        //
        //     {
        //         "wid": "c5b8d7f0768ee91d3b33bee648318688",
        //         "status": "pending",
        //         "created_at": "2016-04-08T17:52:31.000+00:00",
        //         "currency": "btc",
        //         "method": "Bitcoin",
        //         "amount": "0.48650929",
        //         "details": {
        //             "withdrawal_address": "18MsnATiNiKLqUHDTRKjurwMg7inCrdNEp",
        //             "tx_hash": "d4f28394693e9fb5fffcaf730c11f32d1922e5837f76ca82189d3bfe30ded433"
        //         }
        //     }
        //
        object currencyId = this.safeString2(transaction, "currency", "asset");
        currency = this.safeCurrency(currencyId, currency);
        object details = this.safeValue(transaction, "details", new Dictionary<string, object>() {});
        object datetime = this.safeString(transaction, "created_at");
        object withdrawalAddress = this.safeString(details, "withdrawal_address");
        object receivingAddress = this.safeString(details, "receiving_address");
        object networkId = this.safeString2(transaction, "network", "method");
        object status = this.safeString(transaction, "status");
        object withdrawId = this.safeString(transaction, "wid");
        object networkCode = this.networkIdToCode(networkId);
        object networkCodeUpper = ((bool) isTrue((!isEqual(networkCode, null)))) ? ((string)networkCode).ToUpper() : null;
        return new Dictionary<string, object>() {
            { "id", this.safeString2(transaction, "wid", "fid") },
            { "txid", this.safeString(details, "tx_hash") },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "network", networkCodeUpper },
            { "addressFrom", receivingAddress },
            { "address", ((bool) isTrue((!isEqual(withdrawalAddress, null)))) ? withdrawalAddress : receivingAddress },
            { "addressTo", withdrawalAddress },
            { "amount", this.safeNumber(transaction, "amount") },
            { "type", ((bool) isTrue((isEqual(withdrawId, null)))) ? "deposit" : "withdrawal" },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "status", this.parseTransactionStatus(status) },
            { "updated", null },
            { "tagFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "comment", null },
            { "internal", null },
            { "fee", null },
            { "info", transaction },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "pending", "pending" },
            { "in_progress", "pending" },
            { "complete", "ok" },
            { "failed", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object endpoint = add(add(add("/", this.version), "/"), this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(isTrue(isEqual(method, "GET")) || isTrue(isEqual(method, "DELETE"))))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                endpoint = add(endpoint, add("?", this.urlencode(query)));
            }
        }
        object url = add(getValue(getValue(this.urls, "api"), "rest"), endpoint);
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object nonce = ((object)this.nonce()).ToString();
            object request = String.Join("", ((IList<object>)new List<object>() {nonce, method, endpoint}).ToArray());
            if (isTrue(isTrue(!isEqual(method, "GET")) && isTrue(!isEqual(method, "DELETE"))))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    body = this.json(query);
                    request = add(request, body);
                }
            }
            object signature = this.hmac(this.encode(request), this.encode(this.secret), sha256);
            object auth = add(add(add(add(this.apiKey, ":"), nonce), ":"), signature);
            headers = new Dictionary<string, object>() {
                { "Authorization", add("Bitso ", auth) },
                { "Content-Type", "application/json" },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        if (isTrue(inOp(response, "success")))
        {
            //
            //     {"success":false,"error":{"code":104,"message":"Cannot perform request - nonce must be higher than 1520307203724237"}}
            //
            object success = this.safeBool(response, "success", false);
            if (isTrue((success is string)))
            {
                if (isTrue(isTrue((isEqual(success, "true"))) || isTrue((isEqual(success, "1")))))
                {
                    success = true;
                } else
                {
                    success = false;
                }
            }
            if (!isTrue(success))
            {
                object feedback = add(add(this.id, " "), this.json(response));
                object error = this.safeValue(response, "error");
                if (isTrue(isEqual(error, null)))
                {
                    throw new ExchangeError ((string)feedback) ;
                }
                object code = this.safeString(error, "code");
                this.throwExactlyMatchedException(this.exceptions, code, feedback);
                throw new ExchangeError ((string)feedback) ;
            }
        }
        return null;
    }
}
