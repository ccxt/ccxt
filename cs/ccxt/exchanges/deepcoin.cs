namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class deepcoin : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "deepcoin" },
            { "name", "deepcoin" },
            { "version", "v1" },
            { "countries", new List<object>() {"SG"} },
            { "rateLimit", 1000 },
            { "pro", false },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "cancelOrder", true },
                { "createOrder", true },
                { "fetchBalance", true },
                { "fetchClosedOrders", true },
                { "fetchMarkets", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1H", "1H" },
                { "2H", "2H" },
                { "4H", "4H" },
                { "12H", "12H" },
                { "1D", "1D" },
                { "1W", "1W" },
                { "1M", "1M" },
                { "1Y", "1Y" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://www.deepcoin.com/static/images/nav-logo-black-7ad2482d753feb3.svg" },
                { "api", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "public", "https://api.deepcoin.com" },
                        { "private", "https://test-api.goodtest.cc" },
                    } },
                } },
                { "www", "https://www.deepcoin.com" },
                { "doc", "https://www.deepcoin.com/en/docs" },
            } },
            { "precisionMode", TICK_SIZE },
            { "api", new Dictionary<string, object>() {
                { "v1", new Dictionary<string, object>() {
                    { "private", new Dictionary<string, object>() {
                        { "post", new List<object>() {"deepcoin/trade/cancel-order", "deepcoin/trade/order"} },
                        { "get", new List<object>() {"deepcoin/trade/orders-pending", "deepcoin/trade/orders-history", "deepcoin/trade/order", "deepcoin/trade/fills", "deepcoin/account/balances"} },
                    } },
                    { "public", new Dictionary<string, object>() {
                        { "get", new List<object>() {"deepcoin/market/instruments", "deepcoin/market/tickers", "deepcoin/market/books", "deepcoin/market/candles"} },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {} },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {} },
                { "broad", new Dictionary<string, object>() {} },
            } },
        });
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name deepcoin#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://www.deepcoin.com/en/docs#deepcoin-trade-fills
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {string} [params.instType] Instrument type. 'SPOT' or 'SWAP', 'SPOT' by default
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "instType", this.safeString(parameters, "instType", "SPOT") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["begin"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v1PrivateGetDeepcoinTradeFills(this.extend(request, parameters));
        object result = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(result, market, since, limit);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name deepcoin#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {string} [params.instType] Instrument type. 'SPOT' or 'SWAP', 'SPOT' by default
        * @param {object} [params.ccy] currency, eg:'USDT'
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "instType", this.safeString(parameters, "instType", "SPOT") },
        };
        object response = await this.v1PrivateGetDeepcoinAccountBalances(this.extend(request, parameters));
        return this.parseBalance(response);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name deepcoin#fetchOrder
        * @description fetches information on an order made by the user
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "ordId", id },
        };
        object response = await this.v1PrivateGetDeepcoinTradeOrder(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        if (isTrue(isEqual(getArrayLength(data), 0)))
        {
            return this.safeOrder(new Dictionary<string, object>() {});
        }
        return this.parseOrder(this.extend(request, parameters, getValue(data, 0)));
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name delta#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://www.deepcoin.com/en/docs#deepcoin-trade-orders-history
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of open order structures to retrieve
        * @param {string} [params.instType] Instrument type. 'SPOT' or 'SWAP', 'SPOT' by default
        * @param {string} [params.ordType] Order type. 'market': Market order,'limit': Limit order,'post_only': Post-only order
        * @param {string} [params.state] State. 'live' or 'partially_filled'
        * @param {string} [params.after] Pagination of data to return records earlier than the requested ordId, eg:"1000314896749646
        * @param {string} [params.before] Pagination of data to return records newer than the requested ordId, eg:"1000314896749646
        * @param {object} [params.ordId] order id
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "instType", this.safeString(parameters, "instType", "SPOT") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v1PrivateGetDeepcoinTradeOrdersHistory(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parseOrder(this.extend(request, parameters, getValue(data, i))));
        }
        return result;
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name deepcoin#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://www.deepcoin.com/en/docs#deepcoin-trade-orders-pending
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of open order structures to retrieve
        * @param {string} [params.instType] Instrument type. 'SPOT' or 'SWAP', 'SPOT' by default
        * @param {string} [params.ordType] Order type. 'market': Market order,'limit': Limit order,'post_only': Post-only order
        * @param {string} [params.state] State. 'live' or 'partially_filled'
        * @param {string} [params.after] Pagination of data to return records earlier than the requested ordId, eg:"1000314896749646
        * @param {string} [params.before] Pagination of data to return records newer than the requested ordId, eg:"1000314896749646
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object ordType = this.safeString(parameters, "ordType");
        object state = this.safeString(parameters, "state");
        object after = this.safeString(parameters, "after");
        object before = this.safeString(parameters, "before");
        object request = new Dictionary<string, object>() {
            { "instType", this.safeString(parameters, "instType", "SPOT") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(ordType, null)))
        {
            ((IDictionary<string,object>)request)["ordType"] = ordType;
        }
        if (isTrue(!isEqual(state, null)))
        {
            ((IDictionary<string,object>)request)["state"] = state;
        }
        if (isTrue(!isEqual(after, null)))
        {
            ((IDictionary<string,object>)request)["after"] = after;
        }
        if (isTrue(!isEqual(before, null)))
        {
            ((IDictionary<string,object>)request)["before"] = before;
        }
        object response = await this.v1PrivateGetDeepcoinTradeOrdersPending(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parseOrder(this.extend(request, parameters, getValue(data, i))));
        }
        return result;
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name deepcoin#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://www.deepcoin.com/en/docs#deepcoin-market-candles
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume(base units)
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "bar", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["before"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v1PublicGetDeepcoinMarketCandles(this.extend(request, parameters));
        object result = this.safeList(response, "data", new List<object>() {});
        return this.parseOHLCVs(result, market, timeframe, since, limit);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name deepcoin#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://www.deepcoin.com/en/docs#deepcoin-market-books
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        limit ??= 10;
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "sz", limit },
        };
        object response = await this.v1PublicGetDeepcoinMarketBooks(this.extend(request, parameters));
        object result = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrderBook(result, getValue(market, "symbol"), null);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name deepcoin#fetchTicker
        * @description fetches price tickers for multiple data, statistical information calculated over the past 24 hours for each market
        * @see https://www.deepcoin.com/en/docs#deepcoin-market-tickers
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://www.deepcoin.com/en/docs#deepcoin-market-tickers}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instType", this.marketTypeToInstType(getValue(market, "type")) },
            { "instId", getValue(market, "id") },
        };
        object response = await this.v1PublicGetDeepcoinMarketTickers(this.extend(request, parameters));
        object tickers = this.safeList(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(tickers)); postFixIncrement(ref i))
        {
            object ticker = this.parseTicker(getValue(tickers, i));
            ((IDictionary<string,object>)result)[(string)getValue(ticker, "symbol")] = ticker;
        }
        result = this.filterByArrayTickers(result, "symbol", new List<object>() {symbol});
        return getValue(result, symbol);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name deepcoin#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://www.deepcoin.com/en/docs#deepcoin-market-tickers
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://www.deepcoin.com/en/docs#deepcoin-market-tickers}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "instType", this.safeString(parameters, "instType", "SPOT") },
        };
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.v1PublicGetDeepcoinMarketTickers(this.extend(request, parameters));
        object tickers = this.safeList(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(tickers)); postFixIncrement(ref i))
        {
            object ticker = this.parseTicker(getValue(tickers, i));
            object symbol = getValue(ticker, "symbol");
            ((IDictionary<string,object>)result)[(string)symbol] = ticker;
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name deepcoin#fetchMarkets
        * @description retrieves data on all markets for deepcoin
        * @see https://www.deepcoin.com/en/docs#deepcoin-market-instruments
        * @param {string} [params.uly] Underlying. Only applicable to SWAP
        * @param {string} [params.instId] Instrument ID
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object instTypes = new List<object>() {"SPOT", "SWAP"};
        object result = new List<object>() {};
        for (object j = 0; isLessThan(j, getArrayLength(instTypes)); postFixIncrement(ref j))
        {
            object request = new Dictionary<string, object>() {
                { "instType", getValue(instTypes, j) },
            };
            object response = await this.v1PublicGetDeepcoinMarketInstruments(this.extend(request, parameters));
            object markets = this.safeList(response, "data", new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
            {
                ((IList<object>)result).Add(this.parseMarket(getValue(markets, i)));
            }
        }
        return result;
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name whitebit#createOrder
        * @description create a trade order
        * @see https://www.deepcoin.com/en/docs#deepcoin-trade-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {string} [params.tdMode] Margin mode 'cross', isolated Non-Margin mode 'cash', 'cash' by default
        * @param {string} [params.ccy] Margin currency. Only applicable to cross MARGIN orders in Single-currency margin. eg:'USDT'
        * @param {string} [params.clOrdId] client order id as assigned by the client, A combination of case-sensitive alphanumerics, all numbers, or all letters of up to 32 characters
        * @param {string} [params.ccy] Margin currency. Only applicable to cross MARGIN orders in Single-currency margin. eg:'USDT'
        * @param {string} [params.tag]  Order tag. A combination of case-sensitive alphanumerics, all numbers, or all letters of up to 16 characters
        * @param {string} [params.posSide] Position side. 'long' or 'short'
        * @param {string} [params.mrgPosition] Margin position. 'merge' or 'split'
        * @param {string} [params.closePosId] Waiting for closing split margin positions. Required in split margin mode. eg:'1001063717138767'
        * @param {string} [params.reduceOnly] Whether the order can only reduce the position size. Valid options: 'true' or 'false'. The default value is 'false'. Only applicable to MARGIN orders, and FUTURES/SWAP orders in net mode Only applicable to Single-currency margin and Multi-currency margin
        * @param {string} [params.tgtCcy] Quantity type. 'base_ccy': Base currency, 'quote_ccy': Quote currency, Only applicable to SPOT Market Orders Default is 'quote_ccy' for buy, 'base_ccy' for sell
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object tdMode = this.safeString(parameters, "tdMode", "cash");
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "side", side },
            { "sz", amount },
            { "tdMode", tdMode },
            { "ordType", type },
            { "px", price },
        };
        object response = await this.v1PrivatePostDeepcoinTradeOrder(this.extend(request, parameters));
        object result = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(this.extend(request, parameters, result));
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name deepcoin#cancelOrder
        * @description cancels an open order
        * @see https://www.deepcoin.com/en/docs#deepcoin-trade-cancel-order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {string} [params.clOrdId] client order id as assigned by the client, A combination of case-sensitive alphanumerics, all numbers, or all letters of up to 32 characters.
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "ordId", id },
        };
        object response = await this.v1PrivatePostDeepcoinTradeCancelOrder(this.extend(request, parameters));
        return this.parseOrder(response);
    }

    public override object parseTrade(object trade, object market = null)
    {
        object orderId = this.safeString(trade, "ordId");
        object timestamp = this.safeNumber(trade, "ts");
        object fee = new Dictionary<string, object>() {
            { "cost", this.safeString(trade, "fee") },
            { "currency", this.safeString(trade, "feeCcy") },
        };
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", orderId },
            { "order", orderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", this.safeStringUpper(trade, "instId") },
            { "type", null },
            { "side", this.safeString(trade, "side") },
            { "price", this.safeNumber(trade, "fillPx") },
            { "amount", this.safeNumber(trade, "fillSz") },
            { "cost", null },
            { "takerOrMaker", this.safeStringUpper(trade, "execType") },
            { "fee", fee },
        }, market);
    }

    public override object parseBalance(object response)
    {
        object balances = this.safeList(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {
            { "info", balances },
        };
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object code = this.safeString(balance, "ccy");
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "bal");
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "availBal");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "frozenBal");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        object timestamp = this.safeNumber(ticker, "ts", 0.001);
        // const last = this.safeString (ticker, 'close');
        return this.safeTicker(new Dictionary<string, object>() {
            { "info", ticker },
            { "symbol", this.safeStringUpper(ticker, "instId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeNumber(ticker, "high24h") },
            { "low", this.safeNumber(ticker, "low24h") },
            { "bid", this.safeNumber(ticker, "bidPx") },
            { "bidVolume", this.safeNumber(ticker, "bidSz") },
            { "ask", this.safeNumber(ticker, "askPx") },
            { "askVolume", this.safeNumber(ticker, "askSz") },
            { "vwap", null },
            { "open", this.safeString(ticker, "open24h") },
            { "close", this.safeNumber(ticker, "last") },
            { "last", this.safeNumber(ticker, "last") },
            { "previousClose", null },
            { "baseVolume", this.safeNumber(ticker, "volCcy24h") },
            { "quoteVolume", this.safeNumber(ticker, "vol24h") },
        }, market);
    }

    public override object parseMarket(object market)
    {
        object instType = this.safeString(market, "instType");
        object id = this.safeString(market, "instId");
        object isSpot = false;
        object isSwap = false;
        object isContract = false;
        object type = null;
        if (isTrue(isEqual(instType, "SPOT")))
        {
            isSpot = true;
            type = "spot";
        } else if (isTrue(isEqual(instType, "SWAP")))
        {
            isSwap = true;
            isContract = true;
            type = "swap";
        }
        // const uly = this.safeString (market, 'uly');
        object bs = this.safeStringUpper(market, "baseCcy");
        object quote = this.safeStringUpper(market, "quoteCcy");
        object state = this.safeString(market, "state");
        object active = isEqual(state, "live");
        object contractSize = this.safeNumber(market, "ctVal");
        object settle = this.safeString(market, "ctValCcy");
        object created = this.safeNumber(market, "listTime");
        object maxLever = this.safeNumber(market, "lever");
        object minSz = this.safeNumber(market, "minSz");
        object ctType = this.safeString(market, "ctType");
        // const alias = this.safeString (market, 'alias');
        // const maxLmtSz = this.safeString (market, 'maxLmtSz');
        // const maxMktSz = this.safeString (market, 'maxMktSz');
        object pricePrecision = this.safeNumber(market, "tickSz");
        object amountPrecision = this.safeNumber(market, "lotSz");
        return new Dictionary<string, object>() {
            { "info", market },
            { "id", id },
            { "symbol", this.safeStringUpper(market, "instId") },
            { "base", bs },
            { "quote", quote },
            { "baseId", bs },
            { "quoteId", quote },
            { "active", active },
            { "type", type },
            { "spot", isSpot },
            { "margin", null },
            { "future", null },
            { "swap", isSwap },
            { "option", null },
            { "contract", isContract },
            { "settle", settle },
            { "settleId", settle },
            { "contractSize", contractSize },
            { "linear", isEqual(ctType, "linear") },
            { "inverse", isEqual(ctType, "inverse") },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "taker", null },
            { "maker", null },
            { "percentage", null },
            { "tierBased", null },
            { "feeSide", null },
            { "precision", new Dictionary<string, object>() {
                { "price", pricePrecision },
                { "amount", amountPrecision },
                { "cost", null },
            } },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", minSz },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", maxLever },
                } },
            } },
            { "created", created },
        };
    }

    public virtual object parseStatus(object state)
    {
        if (isTrue(isTrue(isEqual(state, "live")) || isTrue(isEqual(state, "partially_filled"))))
        {
            return "open";
        } else if (isTrue(isEqual(state, "filled")))
        {
            return "closed";
        } else if (isTrue(isEqual(state, "canceled")))
        {
            return "canceled";
        } else
        {
            return null;
        }
    }

    public override object parseOrder(object order, object market = null)
    {
        object timestamp = this.safeNumber(order, "cTime");
        object lastTradeTimestamp = this.safeNumber(order, "fillTime");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString(order, "ordId") },
            { "symbol", this.safeStringUpper(order, "instId") },
            { "clientOrderId", this.safeString(order, "clOrdId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "status", this.parseStatus(this.safeString(order, "state")) },
            { "timeInForce", null },
            { "side", this.safeString(order, "side") },
            { "type", this.safeString(order, "ordType") },
            { "price", this.safeNumber(order, "px") },
            { "average", this.safeNumber(order, "avgPx") },
            { "amount", this.safeNumber(order, "sz") },
            { "filled", this.safeNumber(order, "accFillSz") },
            { "remaining", null },
            { "cost", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", this.safeString(order, "feeCcy") },
                { "cost", this.safeNumber(order, "fee") },
            } },
            { "postOnly", isEqual(this.safeString(order, "ordType"), "post_only") },
            { "trades", null },
        });
    }

    public virtual object marketTypeToInstType(object type)
    {
        return ((string)type).ToUpper();
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object version = this.safeValue(((object)api), 0);
        object accessibility = this.safeValue(((object)api), 1);
        object query = this.urlencode(parameters);
        object timestamp = this.iso8601(this.milliseconds());
        object url = add(add(getValue(getValue(getValue(this.urls, "api"), version), accessibility), "/"), path);
        object payload = add(add(add(timestamp, method), "/"), path);
        if (isTrue(isEqual(method, "GET")))
        {
            url = add(url, add("?", query));
            payload = add(payload, add("?", query));
        } else if (isTrue(isEqual(method, "POST")))
        {
            body = this.json(parameters);
            payload = add(payload, body);
        }
        if (isTrue(isEqual(accessibility, "private")))
        {
            object secret = this.secret;
            object signature = this.hmac(this.encode(payload), this.encode(secret), sha256, "base64");
            headers = new Dictionary<string, object>() {
                { "Content-Type", "application/json" },
                { "DC-ACCESS-KEY", this.apiKey },
                { "DC-ACCESS-SIGN", signature },
                { "DC-ACCESS-TIMESTAMP", timestamp },
                { "DC-ACCESS-PASSPHRASE", this.password },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        object errorCode = this.safeString2(response, "sCode", "code");
        object errorMsg = this.safeString2(response, "sMsg", "msg");
        if (isTrue(isTrue(!isEqual(errorCode, null)) && isTrue(!isEqual(errorCode, "0"))))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), errorMsg, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
